quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,"W[1]; *. void mnpsdf(); -*Calculates the eigenvalues of v to see if positive-def; *-* ======================================================; *-* if not, adds constant along diagonal to make positive.; *. void mnrazz(Double_t ynew, Double_t* pnew, Double_t* y, Int_t& jh, Int_t& jl); Called only by MNSIMP (and MNIMPR) to add a new point*-*-; *-* =====================================================; *-* and remove an old one from the current simplex, and get the; *-* estimated distance to minimum.; *. void mnrn15(Double_t& val, Int_t& inseed); This is a super-portable random number generator; *-* ================================================; *-* It should not overflow on any 32-bit machine.; *-* The cycle is only ~10**9, so use with care!; *-* Note especially that VAL must not be undefined on input.; *-* Set Default Starting Seed; *. void mnrset(Int_t iopt); Resets function value and errors to UNDEFINED; *-* =============================================; *-* If IOPT=1,; *-* If IOPT=0, sets only MINOS errors to undefined; *-* Called from MNCLER and whenever problem changes, for example; *-* after SET LIMITS, SET PARAM, CALL FCN 6; *. void mnsave(); -*Writes current parameter values and step sizes onto file ISYSSA; *-* ===============================================================; *-* in format which can be reread by Minuit for restarting.; *-* The covariance matrix is also output if it exists.; *. void mnscan(); Scans the values of FCN as a function of one parameter*-; *-* ======================================================; *-* and plots the resulting values as a curve using MNPLOT.; *-* It may be called to scan one parameter or all parameters.; *-* retains the best function and parameter values found.; *. void mnseek(); -*-*Performs a rough (but global) minimization by monte carlo search; *-* ================================================================; *-* Each time a new minimum is found, the search area is shifted; *-* to be centered at the best value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:52314,error,errors,52314,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,20,['error'],['errors']
Availability,"WebWindow &win, bool remote = false, std::string *produced_key = nullptr);; 76 ; 77 bool CreateServer(bool with_http = false);; 78 ; 79 bool InformListener(const std::string &msg);; 80 ; 81 static std::string GenerateKey(int keylen = 32);; 82 ; 83public:; 84 RWebWindowsManager();; 85 ; 86 ~RWebWindowsManager();; 87 ; 88 /// Returns THttpServer instance; 89 THttpServer *GetServer() const { return fServer.get(); }; 90 ; 91 /// Returns http address of the server, empty string when not available; 92 std::string GetServerAddr() const { return fAddr; }; 93 ; 94 /// Assign show callback which can catch window showing, used by RBrowser; 95 void SetShowCallback(WebWindowShowCallback_t func) { fShowCallback = func; }; 96 ; 97 /// Assign show callback which can catch window showing, used by RBrowser; 98 void SetDeleteCallback(WebWindowDeleteCallback_t func) { fDeleteCallback = func; }; 99 ; 100 static std::shared_ptr<RWebWindowsManager> &Instance();; 101 ; 102 std::shared_ptr<RWebWindow> CreateWindow();; 103 ; 104 void Terminate();; 105 ; 106 static bool IsMainThrd();; 107 static void AssignMainThrd();; 108 ; 109 static void SetLoopbackMode(bool on = true);; 110 static bool IsLoopbackMode();; 111 ; 112 static void SetUseSessionKey(bool on = true);; 113 static void SetUseConnectionKey(bool on = true);; 114 ; 115 static void AddServerLocation(const std::string &server_prefix, const std::string &files_path);; 116 static std::map<std::string, std::string> GetServerLocations();; 117 static void ClearServerLocations();; 118};; 119 ; 120} // namespace ROOT; 121 ; 122#endif; RWebWindow.hxx; onOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void onDefinition TGWin32VirtualXProxy.cxx:106; winOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html:3990,avail,available,3990,doc/master/RWebWindowsManager_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindowsManager_8hxx_source.html,1,['avail'],['available']
Availability,"When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" the error band is smoothed. Because of the; 715smoothing algorithm used some artefacts may appear at the end of the band; 716like in the following example. In such cases ""E3"" should be used instead; 717of ""E4"".; 718 ; 719Begin_Macro(source); 720{; 721 auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; 722 ce4->Divide(2,1);; 723 auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; 724 Int_t i;; 725 for (i=0;i<10000;i++) he4->Fill(g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:31009,error,error,31009,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['error']
Availability,"Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 50 , Width = 50 ) Output = ( 1 , 50 , 50 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 50 , Width = 1 ) Output = ( 1 , 50 , 1 ) Activation Function = Identity; : Using 800 events for training and 200 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 33494.1; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 34747.6 33079.7 0.0192196 0.00176099 45822.6 0; : 2 Minimum Test error found - save the configuration ; : 2 | 34222.2 32417.1 0.0195047 0.0017702 45109.9 0; : 3 Minimum Test error found - save the configuration ; : 3 | 33496 31618.4 0.0197158 0.00178336 44611.8 0; : 4 Minimum Test error found - save the configuration ; : 4 | 32719.2 30843.2 0.0198205 0.00178286 44351.8 0; : 5 Minimum Test error found - save the configuration ; : 5 | 31879.6 30001 0.0200761 0.00184919 43891 0; : 6 Minimum Test error found - save the configuration ; : 6 | 30965 29177.4 0.0203037 0.00185469 43362.8 0; : 7 Minimum Test error found - save the configuration ; : 7 | 30273.8 28682.9 0.0206315 0.00190133 42711.9 0; : 8 Minimum Test error found - save the configuration ; : 8 | 29852.4 28319.6 0.0206438 0.00186969 42611.9 0; : 9 Minimum Test error found - save the configuration ; : 9 | 29498.2 28000.3 0.0204359 0.0018446 43030.8 0; : 10 Minimum Test error found - save the configuration ; : 10 | 29182.7 27696.8 0.0202998 0.00181461 43277.8 0; : 11 Minimum Test error found - save the configuration ; : 11 | 28878.3 27413.2 0.0196838 0.00176755 44652.2 0; : 12 Minimum Test error found - save the configura",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:11433,error,error,11433,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"Width(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Graphics and the Graphical User Interface”. When a histogram is automatically created as a result of a TTree::Draw , the style of the histogram is inherited from the tree attributes and the current style is ignored. The tree attributes are the ones set in the current TStyle at the time the tree was created. You can change the existing tree to use the current style, by calling TTree::UseCurrentStyle() .; 3.8.2 Draw Options; The following draw options are supported on all histogram classes:. “AXIS”: Draw only the axis.; “HIST”: When a histogram has errors, it is visualized by default with error bars. To visualize it without errors use HIST together with the required option (e.g. “HIST SAME C”).; “SAME”: Superimpose on previous picture in the same pad.; “CYL”: Use cylindrical coordinates.; “POL”: Use polar coordinates.; “SPH”: Use spherical coordinates.; “PSR”: Use pseudo-rapidity/phi coordinates.; “LEGO”: Draw a lego plot with hidden line removal.; “LEGO1”: Draw a lego plot with hidden surface removal.; “LEGO2”: Draw a lego plot using colors to show the cell contents.; “SURF”: Draw a surface plot with hidden line removal.; “SURF1”: Draw a surface plot with hidden surface removal.; “SURF2”: Draw a surface plot using colors to show the cell contents.; “SURF3”: Same as SURF with a contour view on the top.; “SURF4”: Draw a surface plot using Gouraud shading.; “SURF5”: Same as SURF3 but only the colored contour is drawn. Used with option CYL , SPH or PSR it allows to draw colored contours on a sphere, a cylinder or in a pseudo rapidly space. In ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:85210,error,errors,85210,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['error'],"['error', 'errors']"
Availability,"Width(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if (fH->GetBinErrorOption() == TH1::kNormal) {; 6464 ey1 = factor*fH->GetBinError(k);; 6465 ey2 = ey1;; 6466 } else {; 6467 ey1 = factor*fH->GetBinErrorLow(k);; 6468 ey2 = factor*fH->GetBinErrorUp(k);; 6469 }; 6470 ex2 = ex1;; 6471 ; 6472 xi4 = xp;; 6473 xi3 = xp;; 6474 xi2 = xp + ex2;; 6475 xi1 = xp - ex1;; 6476 ; 6477 yi1 = yp;; 6478 yi2 = yp;; 6479 yi3 = yp - ey1;; 6480 yi4 = yp + ey2;; 6481 ; 6482 // take the LOG if necessary; 6483 if (Hoption.Logx) {; 6484 xi1 = TMath::Log10(TMath::Max(xi1,logxmin));; 6485 xi2 = TMath::Log10(TMath::Max(xi2,logxmin));; 6486 xi3 = TMath::Log10(TMath::Max(xi3,logxmin));; 6487 xi4 = TMath::Log10(TMath::Max(xi4,logxmin));; 6488 }; 6489 if (Hoption.Logy) {; 6490 yi1 = TMath::Log10(TMath::Max(yi1,logymin));; 6491 yi2 = TMath::Log10(TMath::Max(yi2,logymin));; 6492 yi3 = TMath::Log10(TMath::Max(yi3,logymin));; 6493 yi4 = TMath::Log10(TMath::Max(yi4,logymin));; 6494 }; 6495 ; 6496 // test if error bars are not outside the limits; 6497 // otherwise they are truncated; 6498 ; 6499 xi1 = TMath::Max(xi1,xmin);; 6500 xi2 = TMath::Min(xi2,xmax);; 6501 yi3 = TMath::Max(yi3,ymin);; 6502 yi4 = TMath::Min(yi4,ymax);; 6503 ; 6504 // test if the marker is on the frame limits. If ""Yes"", the; 6505 // marker will not be drawn and the error bars will be readjusted.; 6506 ; 6507 drawmarker = kTRUE;; 6508 if (!option0 && !option3) {; 6509 if (Hoption.Logy && yp < logymin) goto L30;; 6510 if (yi1 < ymin || yi1 > ymax) goto L30;; 6511 if (Hoption.Error != 0 && yp == 0 && ey1 <= 0) drawmarker = kFALSE;; 6512 }; 6513 if (!symbolsize || !errormarker) drawmarker = kFALSE;; 6514 ; 6515 // draw the error rectangles; 6516 if (option2) {; 6517 if (yi3 >= ymax) goto L30;; 6518 if (yi4 <= ymin) goto L30;; 6519 gPad->PaintBox(xi1,yi3,xi2,yi4);; 6520 }; 6521 ; 6522 // keep points for fill area drawing; 6523 if (option3) {; 6524 xline[if1-1] = xi3;; 6525 xline[if2-1] = xi3;; 6526 yline[if1-1] = yi4;; 6527 yline[if2-1] = y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:238413,error,error,238413,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['error']
Availability,Widthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Style_tfPattern; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGedPatternSelect.html:21636,down,down,21636,root/html530/TGedPatternSelect.html,https://root.cern,https://root.cern/root/html530/TGedPatternSelect.html,9,['down'],['down']
Availability,Widthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; Style_tfPattern; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedPatternSelect.html:21298,down,down,21298,root/html528/TGedPatternSelect.html,https://root.cern,https://root.cern/root/html528/TGedPatternSelect.html,1,['down'],['down']
Availability,"Work(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); Int_tCalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* sl, TMessag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerAdaptive.html:2579,error,error,2579,root/html602/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html602/TPacketizerAdaptive.html,4,['error'],['error']
Availability,"Workspace& w); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsStudy*RooAbsStudy::clone(const char* newname = """") const; virtual TObject*RooAbsStudy::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; RooLinkedList*RooAbsStudy::detailedData(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidRooAbsStudy::dump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Bool_texecute(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Bool_tfinalize(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooGenFitStudy.html:1712,error,error,1712,root/html530/RooGenFitStudy.html,https://root.cern,https://root.cern/root/html530/RooGenFitStudy.html,3,['error'],['error']
Availability,"Wrapper_t)( m->InterfaceMethod() );; 345 }; 346 TBuffer::EMode mode = TBuffer::kWrite;; 347 Int_t size = 10000;; 348 void *args[] = { &mode, &size };; 349 TBuffer *result;; 350 creator(nullptr,2,args,&result);; 351 return result;; 352}; 353 ; 354////////////////////////////////////////////////////////////////////////////////; 355/// Clone an object.; 356/// This function is called when the directory is not a TDirectoryFile.; 357/// This version has to load the I/O package, hence via Cling.; 358///; 359/// If autoadd is true and if the object class has a; 360/// DirectoryAutoAdd function, it will be called at the end of the; 361/// function with the parameter gDirector. This usually means that; 362/// the object will be appended to the current ROOT directory.; 363 ; 364TObject *TDirectory::CloneObject(const TObject *obj, Bool_t autoadd /* = kTRUE */); 365{; 366 // if no default ctor return immediately (error issued by New()); 367 char *pobj = (char*)obj->IsA()->New();; 368 if (!pobj) {; 369 Fatal(""CloneObject"",""Failed to create new object"");; 370 return nullptr;; 371 }; 372 ; 373 Int_t baseOffset = obj->IsA()->GetBaseClassOffset(TObject::Class());; 374 if (baseOffset==-1) {; 375 // cl does not inherit from TObject.; 376 // Since this is not supported in this function, the only reason we could reach this code; 377 // is because something is screwed up in the ROOT code.; 378 Fatal(""CloneObject"",""Incorrect detection of the inheritance from TObject for class %s.\n"",; 379 obj->IsA()->GetName());; 380 }; 381 TObject *newobj = (TObject*)(pobj+baseOffset);; 382 ; 383 //create a buffer where the object will be streamed; 384 //We are forced to go via the I/O package (ie TBufferFile).; 385 //Invoking TBufferFile via CINT will automatically load the I/O library; 386 TBuffer *buffer = R__CreateBuffer();; 387 if (!buffer) {; 388 Fatal(""CloneObject"",""Not able to create a TBuffer!"");; 389 return nullptr;; 390 }; 391 buffer->MapObject(obj); //register obj in map to handle self referen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:12656,error,error,12656,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['error'],['error']
Availability,"Write the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). support for streaming TStreamerInfo added by Rene Brun May 2008 support for streaming TProcessID added by Rene Brun June 2008 ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 522 of file TSocket.cxx. ◆ Send() [3/4]. Int_t TSocket::Send ; (; Int_t ; kind). virtual . Send a single message opcode. ; Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TPSocket, TSSLSocket",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:35478,error,error,35478,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['error'],['error']
Availability,"WriteDelete; };. private:. TMVA::TActivation*fActivationactivation equation; Double_tfActivationValueactivation/output value; Double_tfDEDwsum of all deltas; Double_tfDeltaerror field of neuron; Double_tfErrorerror, only set for output neurons; Bool_tfForcedValueflag for forced input value; TMVA::TNeuronInput*fInputCalculatorinput calculator; TObjArray*fLinksInarray of input synapses; TObjArray*fLinksOutarray of output synapses; Double_tfValueinput value; static TMVA::MsgLogger*fgLogger! message logger, static to save resources. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuron(); standard constructor. ~TNeuron(); destructor. void InitNeuron(); initialize the neuron, most variables still need to be set via setters. void ForceValue(Double_t value); force the value, typically for input and bias neurons. void CalculateValue(); calculate neuron input. void CalculateActivationValue(); calculate neuron activation/output. void CalculateDelta(); calculate error field. void SetInputCalculator(TMVA::TNeuronInput* calculator); set input calculator. void SetActivationEqn(TMVA::TActivation* activation); set activation equation. void AddPreLink(TMVA::TSynapse* pre); add synapse as a pre-link to this neuron. void AddPostLink(TMVA::TSynapse* post); add synapse as a post-link to this neuron. void DeletePreLinks(); delete all pre-links. void DeleteLinksArray(TObjArray*& links); delete an array of TSynapses. void SetError(Double_t error); set error, this should only be done for an output neuron. void UpdateSynapsesBatch(); update and adjust the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in batch mode. void UpdateSynapsesSequential(); update the pre-synapses for each neuron (input neuron has no pre-synapse); this method should only be called in sequential mode. void AdjustSynapseWeights(); adjust the pre-synapses' weights for each neuron (input neuron has no pre-synapse); this method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TNeuron.html:7266,error,error,7266,root/html528/TMVA__TNeuron.html,https://root.cern,https://root.cern/root/html528/TMVA__TNeuron.html,6,['error'],['error']
Availability,"X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:33270,error,error,33270,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['error'],['error']
Availability,"X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 353 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 993 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 364 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TClin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:32983,error,error,32983,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['error'],['error']
Availability,"X"",""one histogram is empty"");; 2243 return 0.0;; 2244 }; 2245 ; 2246 if ( comparisonWW && ( sumw1 <= 0.0 && sumw2 <= 0.0 ) ){; 2247 Error(""Chi2TestX"",""Hist1 and Hist2 have both all zero errors\n"");; 2248 return 0.0;; 2249 }; 2250 ; 2251 //THE TEST; 2252 Int_t m = 0, n = 0;; 2253 ; 2254 //Experiment - experiment comparison; 2255 if (comparisonUU) {; 2256 Double_t sum = sum1 + sum2;; 2257 for (Int_t i = i_start; i <= i_end; ++i) {; 2258 for (Int_t j = j_start; j <= j_end; ++j) {; 2259 for (Int_t k = k_start; k <= k_end; ++k) {; 2260 ; 2261 Int_t bin = GetBin(i, j, k);; 2262 ; 2263 Double_t cnt1 = RetrieveBinContent(bin);; 2264 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2265 ; 2266 if (scaledHistogram) {; 2267 // scale bin value to effective bin entries; 2268 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2269 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2270 ; 2271 if (e1sq > 0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2272 else cnt1 = 0;; 2273 ; 2274 if (e2sq > 0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2275 else cnt2 = 0;; 2276 }; 2277 ; 2278 if (Int_t(cnt1) == 0 && Int_t(cnt2) == 0) --ndf; // no data means one degree of freedom less; 2279 else {; 2280 ; 2281 Double_t cntsum = cnt1 + cnt2;; 2282 Double_t nexp1 = cntsum * sum1 / sum;; 2283 //Double_t nexp2 = binsum*sum2/sum;; 2284 ; 2285 if (res) res[i - i_start] = (cnt1 - nexp1) / TMath::Sqrt(nexp1);; 2286 ; 2287 if (cnt1 < 1) ++m;; 2288 if (cnt2 < 1) ++n;; 2289 ; 2290 //Habermann correction for residuals; 2291 Double_t correc = (1. - sum1 / sum) * (1. - cntsum / sum);; 2292 if (res) res[i - i_start] /= TMath::Sqrt(correc);; 2293 ; 2294 Double_t delta = sum2 * cnt1 - sum1 * cnt2;; 2295 chi2 += delta * delta / cntsum;; 2296 }; 2297 }; 2298 }; 2299 }; 2300 chi2 /= sum1 * sum2;; 2301 ; 2302 // flag error only when of the two histogram is zero; 2303 if (m) {; 2304 igood += 1;; 2305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:91557,error,errors,91557,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"X, fEmatUncorrAx, fDeltaCorrX, fDeltaCorrAx. void SetTauError(Double_t delta_tau); set uncertainty on tau. Bool_t GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). Bool_t GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). TMatrixDSparse * GetSummedErrorMatrixYY(void). TMatrixDSparse * GetSummedErrorMatrixXX(void). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void GetRhoItotal(TH1* rhoi, const Int_t* binMap = 0, TH2* invEmat = 0); get global correlation coefficients including systematic,statistical,background,tau errors; rhoi: output histogram; binMap: for each global bin, indicate in which histogram bin; to store its content; invEmat: output histogram for inverse of error matrix; (pointer may zero if inverse is not requested). TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareUncorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap). void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat). TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintArea). void AddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode). void SubtractBackground(const TH1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:19192,error,errors,19192,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,12,['error'],"['error', 'errors']"
Availability,"X, windir, posixwindir, bufsize);; 3485 else; 3486 snprintf(posixwindir, sizeof(posixwindir), ""/Windows/"");; 3487 if (strstr(filename, posixwindir) ||; 3488 strstr(filename, ""/usr/bin/cyg"")); 3489 return;; 3490#elif defined(R__WIN32); 3491 if (strstr(filename, ""/Windows/"")); 3492 return;; 3493#elif defined (R__LINUX); 3494 if (strstr(filename, ""/ld-linux""); 3495 || strstr(filename, ""linux-gnu/""); 3496 || strstr(filename, ""/libstdc++.""); 3497 || strstr(filename, ""/libgcc""); 3498 || strstr(filename, ""/libc.""); 3499 || strstr(filename, ""/libdl.""); 3500 || strstr(filename, ""/libm."")); 3501 return;; 3502#endif; 3503 // Update string of available libraries.; 3504 if (!fSharedLibs.IsNull()) {; 3505 fSharedLibs.Append("" "");; 3506 }; 3507 fSharedLibs.Append(filename);; 3508}; 3509 ; 3510////////////////////////////////////////////////////////////////////////////////; 3511/// Load a library file in cling's memory.; 3512/// if 'system' is true, the library is never unloaded.; 3513/// Return 0 on success, -1 on failure.; 3514 ; 3515Int_t TCling::Load(const char* filename, Bool_t system); 3516{; 3517 assert(!IsFromRootCling() && ""Trying to load library from rootcling!"");; 3518 ; 3519 // Used to return 0 on success, 1 on duplicate, -1 on failure, -2 on ""fatal"".; 3520 R__LOCKGUARD_CLING(gInterpreterMutex);; 3521 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3522 std::string canonLib = DLM->lookupLibrary(filename);; 3523 cling::DynamicLibraryManager::LoadLibResult res; 3524 = cling::DynamicLibraryManager::kLoadLibNotFound;; 3525 if (!canonLib.empty()) {; 3526 if (system); 3527 res = DLM->loadLibrary(filename, system, true);; 3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:136570,failure,failure,136570,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['failure'],['failure']
Availability,"X2NDC(newx2); //new x end position; 638 ; 639To change the type of information for an histogram with an existing; 640`TPaveStats` one should do:; 641 ; 642 st->SetOptStat(mode);; 643 ; 644Where `mode` has the same meaning than when calling `gStyle->SetOptStat(mode)`; 645(see above).; 646 ; 647One can delete the statistics box for a histogram `TH1* h` with:; 648 ; 649 h->SetStats(0); 650 ; 651and activate it again with:; 652 ; 653 h->SetStats(1).; 654 ; 655Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; 656`$ROOTSYS/etc/system.rootrc` or `.rootrc` (look for the string `Hist.Stats.`).; 657 ; 658 ; 659\anchor HP08; 660### Fit Statistics; 661 ; 662 ; 663The type of information about fit parameters printed in the histogram statistics; 664box can be selected via the parameter mode. The parameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Mark",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:29717,error,errors,29717,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['error'],['errors']
Availability,"XAllocColor. If we are on a >= 15 (15, 16 or 24) plane true color machine we will calculate the pixel value using: for 15 and 16 bit true colors have 6 bits precision per color however only the 5 most significant bits are used in the color index. Except for 16 bits where green uses all 6 bits. I.e.: 15 bits = rrrrrgggggbbbbb 16 bits = rrrrrggggggbbbbb for 24 bits each r, g and b are represented by 8 bits.; Since all colors are set with a max of 65535 (16 bits) per r, g, b we just right shift them by 10, 11 and 10 bits for 16 planes, and (10, 10, 10 for 15 planes) and by 8 bits for 24 planes. Returns kFALSE in case color allocation failed. ; Definition at line 1159 of file TGWin32.cxx. ◆ Bell(). void TGWin32::Bell ; (; Int_t ; percent). overridevirtual . Sets the sound bell. Percent is loudness from -100% to 100%. ; Reimplemented from TVirtualX.; Definition at line 6307 of file TGWin32.cxx. ◆ ChangeActivePointerGrab(). void TGWin32::ChangeActivePointerGrab ; (; Window_t ; win, . UInt_t ; mask, . Cursor_t ; cur . ). overridevirtual . Changes the active cursor of the specified window. ; Reimplemented from TVirtualX.; Definition at line 7644 of file TGWin32.cxx. ◆ ChangeGC(). void TGWin32::ChangeGC ; (; GContext_t ; gc, . GCValues_t * ; gval . ). overridevirtual . Change entries in an existing graphics context, gc, by values from gval. ; Reimplemented from TVirtualX.; Definition at line 5448 of file TGWin32.cxx. ◆ ChangeProperties(). void TGWin32::ChangeProperties ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . Int_t ; format, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Put data into Clipboard. ; Reimplemented from TVirtualX.; Definition at line 7698 of file TGWin32.cxx. ◆ ChangeProperty(). void TGWin32::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . This function alters the property for the specified window and causes the X server to generate a PropertyNotify even",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32.html:55326,mask,mask,55326,doc/master/classTGWin32.html,https://root.cern,https://root.cern/doc/master/classTGWin32.html,1,['mask'],['mask']
Availability,"XRD_REAL64; workers XRD_REAL64. Return 0 on success, -1 on any failure. Int_t SendDataSetInfo(TDSet* , TList* , const char* , const char* ); Post information about the processed dataset(s). The information is taken; from the TDSet object 'dset' and integrated with the missing files; information in the list 'missing'. The string 'qid' is the uninque; ID of the query; 'begin' the starting time. The records sent by this call will appear with ids 'dataset_<dataset_name_hash>'. There are two versions of this record, with or without the starting time.; The starting time could be looked up from the summary record, if available. The default version 1 contains the following information:. dsn XRD_STRING; querytag XRD_STRING; querybegin XRD_STRING; numfiles XRD_REAL64; missfiles XRD_REAL64. Version 0 contains the following information:; (no 'querybegin'). dsn XRD_STRING; querytag XRD_STRING; numfiles XRD_REAL64; missfiles XRD_REAL64. The information is posted with a bulk insert. Returns 0 on success, -1 on failure. Int_t SendFileInfo(TDSet* , TList* , const char* , const char* ); Post information about the requested files. The information is taken; from the TDSet object 'dset' and integrated with the missing files; information in the list 'missing'. The string 'qid' is the unique; ID of the query; 'begin' the starting time. The records sent by this call will appear with ids 'file_<file_name_hash>'. There are two versions of this record, with or without the starting time.; The starting time could be looked up from the summary record, if available. The default version 1 contains the following information:. lfn XRD_STRING; path XRD_STRING; querytag XRD_STRING; querybegin XRD_STRING; status XRD_REAL64. Version 0 contains the following information:; (no 'querybegin'). lfn XRD_STRING; path XRD_STRING; querytag XRD_STRING; status XRD_REAL64. The information is posted with a bulk insert. Returns 0 on success, -1 on failure. TProofMonSenderML(const char* serv, const char* tag, const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofMonSenderML.html:9530,failure,failure,9530,root/html602/TProofMonSenderML.html,https://root.cern,https://root.cern/root/html602/TProofMonSenderML.html,4,['failure'],['failure']
Availability,"XRootdNature of remote file server; TStringfUrlInitial url; static THashListfgAddrFQDNCross-table address<->FQDN; static THashListfgAdminHashList of existing XrdClientAdmin; static Bool_tfgInitDoneAvoid initializing more than once; static Bool_tfgRootdBCControl rootd backward compatibility. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSystem. ←; TNetSystem. ←; TXNetSystem. Function documentation; TXNetSystem(Bool_t owner = kTRUE); Create system management class without connecting to server. TXNetSystem(const char* url, Bool_t owner = kTRUE); Create system management class and connect to server specified by url. XrdClientAdmin * Connect(const char* url); Init a connection to the server.; Returns a pointer to the appropriate instance of XrdClientAdmin or 0; in case of failure. void InitXrdClient(); One-time initialization of some communication variables for xrootd protocol. void* OpenDirectory(const char* dir); Open a directory. Returns a non-zero pointer (with no special; purpose) in case of success, 0 in case of error. void FreeDirectory(void* dirp); Free(Close) the directory referenced by dirp. Int_t MakeDirectory(const char* dir); Create a directory. Return 0 on success, -1 otherwise. const char* GetDirEntry(void* dirp); Get directory entry for directory referenced by dirp.; Returns 0 in case there are no more entries. Int_t GetPathInfo(const char* path, FileStat_t& buf); Get info about a file. Info is returned in the form of a FileStat_t; structure (see TSystem.h).; The function returns 0 in case of success and 1 if the file could; not be stat'ed.; NOTICE: Not all information is available with an xrootd server. Bool_t ConsistentWith(const char* path, void* dirptr); Check consistency of this helper with the one required; by 'path' or 'dirptr'. Bool_t AccessPathName(const char* path, EAccessMode mode); Returns FALSE if one can access a file using the specified access mode.; NB: for the time being mode is ignored for XROOTD (just checks existence; of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetSystem.html:21733,error,error,21733,root/html602/TXNetSystem.html,https://root.cern,https://root.cern/root/html602/TXNetSystem.html,4,['error'],['error']
Availability,"XTnn"" Draw bin contents as text at angle nn (0 < nn <= 90). . ""X+"" The X-axis is drawn on the top side of the plot. . ""Y+"" The Y-axis is drawn on the right side of the plot. . ""MIN0"" Set minimum value for the Y axis to 0, equivalent to gStyle->SetHistMinimumZero(). . Options supported for 1D histograms. Option Description . "" "" Default. . ""AH"" Draw histogram without axis. ""A"" can be combined with any drawing option. For instance, ""AC"" draws the histogram as a smooth Curve without axis. . ""]["" When this option is selected the first and last vertical lines of the histogram are not drawn. . ""B"" Bar chart option. . ""BAR"" Like option ""B"", but bars can be drawn with a 3D effect. . ""HBAR"" Like option ""BAR"", but bars are drawn horizontally. . ""C"" Draw a smooth Curve through the histogram bins. . ""E0"" Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping . ""E1"" Draw error bars with perpendicular lines at the edges. . ""E2"" Draw error bars with rectangles. . ""E3"" Draw a fill area through the end points of the vertical error bars. . ""E4"" Draw a smoothed filled area through the end points of the error bars. . ""E5"" Like E3 but ignore the bins with 0 contents. . ""E6"" Like E4 but ignore the bins with 0 contents. . ""X0"" When used with one of the ""E"" option, it suppress the error bar along X as gStyle->SetErrorX(0) would do. . ""L"" Draw a line through the bin contents. . ""P"" Draw current marker at each bin except empty bins. . ""P*"" Draw a star marker at each bin except empty bins. . ""P0"" Draw current marker at each bin including empty bins. . ""PIE"" Draw histogram as a Pie Chart. . ""*H"" Draw histogram with a * at each bin. . ""LF2"" Draw histogram like with option ""L"" but with a fill area. Note that ""L"" draws also a fill area if the hist fill color is set but the fill area corresponds to the histogram contour. . Options supported for 2D histograms. Option Description . "" "" Default (color plot). . ""ARR"" Arrow mode. Shows gradient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:7595,error,error,7595,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['error'],['error']
Availability,"Xaxis()->ImportAttributes( &outAxis);; 1982 THashList* labels=outAxis.GetLabels();; 1983 if (labels) {; 1984 TIter iL(labels);; 1985 TObjString* lb;; 1986 Int_t i = 1;; 1987 while ((lb=(TObjString*)iL())) {; 1988 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1989 i++;; 1990 }; 1991 }; 1992 ; 1993 h1->SetLineColor(this->GetLineColor());; 1994 h1->SetFillColor(this->GetFillColor());; 1995 h1->SetMarkerColor(this->GetMarkerColor());; 1996 h1->SetMarkerStyle(this->GetMarkerStyle());; 1997 ; 1998 // check if histogram is weighted; 1999 // in case need to store sum of weight square/bin for the profile; 2000 TArrayD & binSumw2 = *(h1->GetBinSumw2());; 2001 bool useWeights = (GetSumw2N() > 0);; 2002 if (useWeights && (binSumw2.fN != h1->GetNcells()) ) h1->Sumw2();; 2003 // we need to set this bit because we fill the profile using a single Fill for many entries; 2004 // This is needed for the changes applied to make automatically the histogram weighted in ROOT 6 versions; 2005 else h1->SetBit(TH1::kIsNotW);; 2006 ; 2007 // Fill the profile histogram; 2008 // no entries/bin is available so can fill only using bin content as weight; 2009 ; 2010 // implement filling of projected histogram; 2011 // outbin is bin number of outAxis (the projected axis). Loop is done on all bin of TH2 histograms; 2012 // inbin is the axis being integrated. Loop is done only on the selected bins; 2013 for ( Int_t outbin = 0; outbin <= outAxis.GetNbins() + 1; ++outbin) {; 2014 if (outAxis.TestBit(TAxis::kAxisRange) && ( outbin < firstOutBin || outbin > lastOutBin )) continue;; 2015 ; 2016 // find corresponding bin number in h1 for outbin (binOut); 2017 Double_t xOut = outAxis.GetBinCenter(outbin);; 2018 Int_t binOut = h1->GetXaxis()->FindBin( xOut );; 2019 if (binOut <0) continue;; 2020 ; 2021 for (Int_t inbin = firstbin ; inbin <= lastbin ; ++inbin) {; 2022 Int_t binx, biny;; 2023 if (onX) { binx = outbin; biny=inbin; }; 2024 else { binx = inbin; biny=outbin; }; 2025 ; 2026 if (ncuts) {; 2027 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:80791,avail,available,80791,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['avail'],['available']
Availability,"Xinv(). TH2D * TSVDUnfold::GetXinv ; (; ); const. Returns the computed inverse of the covariance matrix. ; Definition at line 604 of file TSVDUnfold.cxx. ◆ GetXtau(). TH2D * TSVDUnfold::GetXtau ; (; ); const. Returns the computed regularized covariance matrix corresponding to total uncertainties on measured spectrum as passed in the constructor. ; Note that this covariance matrix will not contain the effects of forced normalization if spectrum is normalized to unit area. ; Definition at line 596 of file TSVDUnfold.cxx. ◆ H2M(). void TSVDUnfold::H2M ; (; const TH2D * ; histo, . TMatrixD & ; mat . ). staticprivate . Fill 2D histogram into matrix. ; Definition at line 644 of file TSVDUnfold.cxx. ◆ H2V(). void TSVDUnfold::H2V ; (; const TH1D * ; histo, . TVectorD & ; vec . ). staticprivate . Fill 1D histogram into vector. ; Definition at line 620 of file TSVDUnfold.cxx. ◆ H2Verr(). void TSVDUnfold::H2Verr ; (; const TH1D * ; histo, . TVectorD & ; vec . ). staticprivate . Fill 1D histogram errors into vector. ; Definition at line 628 of file TSVDUnfold.cxx. ◆ InitHistos(). void TSVDUnfold::InitHistos ; (; ). private . Definition at line 807 of file TSVDUnfold.cxx. ◆ IsA(). TClass * TSVDUnfold::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 156 of file TSVDUnfold.h. ◆ M2H(). void TSVDUnfold::M2H ; (; const TMatrixD & ; mat, . TH2D & ; histo . ). staticprivate . Fill 2D histogram into matrix. ; Definition at line 656 of file TSVDUnfold.cxx. ◆ MatDivVec(). TMatrixD TSVDUnfold::MatDivVec ; (; const TMatrixD & ; mat, . const TVectorD & ; vec, . Int_t ; zero = 0 . ). staticprivate . Divide matrix entries by vector. ; Definition at line 684 of file TSVDUnfold.cxx. ◆ RegularisedSymMatInvert(). void TSVDUnfold::RegularisedSymMatInvert ; (; TMatrixDSym & ; mat, . Double_t ; eps = 1e-3 . ). staticprivate . naive regularised inversion cuts off small elements ; Definition at line 827 of file TSVDUnf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:22759,error,errors,22759,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['error'],['errors']
Availability,"Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supposed to be of length nz+1. void SetDirectory(TDirectory* dir); By default when an histogram is created, it is added to the list; of histogram objects in the current directory in memory.; Remove reference to this histogram from current directory and add; reference to new directory dir. dir can be 0 in which case the; histogram does not belong to any directory. Note that the directory is not a real property of the histogram and; it will not be copied when the histogram is copied or cloned.; If the user wants to have the copied (cloned) histogram in the same; directory, he needs to set again the directory using SetDirectory to the; copied histograms. void SetError(const Double_t* error); Replace bin errors by values in array error. void SetName(const char* name); Change the name of this histogram. void SetNameTitle(const char* name, const char* title); Change the name and title of this histogram. void SetStats(Bool_t stats = kTRUE); Set statistics option on/off. By default, the statistics box is drawn.; The paint options can be selected via gStyle->SetOptStats.; This function sets/resets the kNoStats bin in the histogram object.; It has priority over the Style option. void Sumw2(Bool_t flag = kTRUE); Create structure to store sum of squares of weights. if histogram is already filled, the sum of squares of weights; is filled with the existing bin contents. The error per bin will be computed as sqrt(sum of squares of weight); for each bin. This function is automatically called when the histogram is created; if the static function TH1::SetDefaultSumw2 has been called before.; If flag = false the structure is deleted. TF1 * GetFunction(const char* name) const; Return pointer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:127131,error,error,127131,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,6,['error'],"['error', 'errors']"
Availability,"Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); Create a 2-D Profile with fix bins in X and variable bins in Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); Create a 2-D Profile with variable bins in X and variable bins in Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Double_t zlow, Double_t zup, Option_t* option = """"); Constructor for Profile2D histograms with range in z; *-* ====================================================; The first eight parameters are similar to TH2D::TH2D.; Only the values of Z between ZMIN and ZMAX will be considered at filling time.; zmin and zmax will also be the maximum and minimum values; on the z scale when drawing the profile2D. See TProfile2D::BuildOptions for more explanations on errors. void BuildOptions(Double_t zmin, Double_t zmax, Option_t* option); Set Profile2D histogram structure and options*-*-; *-* =============================================. If a cell has N data points all with the same value Z (especially; possible when dealing with integers), the spread in Z for that cell; is zero, and the uncertainty assigned is also zero, and the cell is; ignored in making subsequent fits. If SQRT(Z) was the correct error; in the case above, then SQRT(Z)/SQRT(N) would be the correct error here.; In fact, any cell with non-zero number of entries N but with zero spread; should have an uncertainty SQRT(Z)/SQRT(N). Now, is SQRT(Z)/SQRT(N) really the correct uncertainty?; that it is only in the case where the Z variable is some sort; of counting statistics, following a Poisson distribution. This should; probably be set as the default case. However, Z can be any variable; from an original NTUPLE, not necessarily distributed ""Poissonly"".; The co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:30280,error,errors,30280,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,4,['error'],['errors']
Availability,"Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); Create a 2-D Profile with fix bins in X and variable bins in Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins, Int_t nbinsy, const Double_t* ybins, Option_t* option = """"); Create a 2-D Profile with variable bins in X and variable bins in Y. TProfile2D(const char* name, const char* title, Int_t nbinsx, Double_t xlow, Double_t xup, Int_t nbinsy, Double_t ylow, Double_t yup, Double_t zlow, Double_t zup, Option_t* option = """"); Constructor for Profile2D histograms with range in z; *-* ====================================================; The first eight parameters are similar to TH2D::TH2D.; Only the values of Z between ZMIN and ZMAX will be considered at filling time.; zmin and zmax will also be the maximum and minimum values; on the z scale when drawing the profile2D. See TProfile2D::BuildOptions for more explanations on errors. void BuildOptions(Double_t zmin, Double_t zmax, Option_t* option); Set Profile2D histogram structure and options*-*-; *-* =============================================. zmin: minimum value allowed for z; zmax: maximum value allowed for z; if (zmin = zmax = 0) there are no limits on the allowed z values (zmin = -inf, zmax = +inf). option: this is the option for the computation of the t error of the profile ( TProfile2D::GetBinError ); possible values for the options are documented in TProfile2D::SetErrorOption. TProfile2D(const TProfile2D& profile); Copy constructor. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1. Bool_t Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*Replace contents of this profile2D by the addition of h1 and h2; *-* ===================================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:32133,error,errors,32133,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,6,['error'],['errors']
Availability,"YChi2Var& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Mon Dec 7 13:49:53 2009 » Last generated: 2009-12-07 13:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooXYChi2Var.html:41452,error,error,41452,root/html526/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html526/RooXYChi2Var.html,2,['error'],['error']
Availability,"YS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Clonevirtual TObject * Clone(const char *newname="""") constMake a clone of an object using the Streamer facility.Definition TObject.cxx:229; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPRegexpDefinition TPRegexp.h:36; TPRegexp::MatchBBool_t MatchB(const TString &s, const TString &mods="""", Int_t start=0, Int_t nMaxMatch=10)Definition TPRegexp.h:78; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887; TROOT::IndentLevelstatic void IndentLevel()Functions used by ls() to indent an object hierarchy.Definition TROOT.cxx:2895; TROOT::DecreaseDirLevelstatic Int_t DecreaseDirLevel()Decrease the indentation level for ls().Definition TROOT.cxx:2746; TRegexpRegula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:38697,error,error,38697,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['error'],['error']
Availability,"YS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static Bool_t CheckFile (const char *path, const char *location=0);  CheckFile() returns kTRUE on success and kFALSE on failure. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TString GetDcapPath (const char *path);  Transform the input path into a path usuable by the dcap C library, i.e either dcap://nodename.org/where/filename.root or /pnfs/where/filename.root. ;  ; static const char * GetDcapVersion ();  Return dCache version string. ;  ; static void SetOnError (EOnErrorAction=kOnErrorDefault);  Set on error handler. ;  ; static void SetOpenTimeout (UInt_t secs);  Set file open timeout. ;  ; static void SetReplyHostName (const char *host_name);  Set reply host name. ;  ; static Bool_t Stage (const char *path, UInt_t secs, const char *location=0);  Stage() returns kTRUE on success and kFALSE on failure. ;  ;  Static Public Member Functions inherited from TFile; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:26916,error,error,26916,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['error'],['error']
Availability,"Yaxis() constDefinition RooPlot.cxx:1264; RooPlot::Drawvoid Draw(Option_t *options=nullptr) overrideDraw this plot and all of the elements it contains.Definition RooPlot.cxx:637; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf208_convolutionDefinition rf208_convolution.py:1; ; [#1] INFO:Eval -- RooRealVar::setRange(t) new range named 'refrange_fft_lxg' created with bounds [-10,30]; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539f82d770 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; [#1] INFO:Fitting -- RooAbsPdf::fitTo(lxg_over_lxg_Int[t]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_lxg_over_lxg_Int[t]_lxgData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539fd9f650 with pdf lx_CONV_gauss_CACHE_Obs[t] for nset () with code 1 from preexisting content.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(lxg) creating new cache 0x56539fcccee0 with pdf lx_CONV_gauss_CACHE_Obs[t]_NORM_t for nset (t) with code 0; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf208_convolution.C. tutorialsroofitrf208_convolution.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf208__convolution_8C.html:4273,error,error,4273,doc/master/rf208__convolution_8C.html,https://root.cern,https://root.cern/doc/master/rf208__convolution_8C.html,1,['error'],['error']
Availability,"Ylowd(). Double_t * TGraphBentErrors::GetEYlowd ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 86 of file TGraphBentErrors.h. ◆ IsA(). TClass * TGraphBentErrors::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGraph.; Definition at line 101 of file TGraphBentErrors.h. ◆ Print(). void TGraphBentErrors::Print ; (; Option_t * ; chopt = """"); const. overridevirtual . Print graph and errors values. ; Reimplemented from TGraph.; Definition at line 495 of file TGraphBentErrors.cxx. ◆ SavePrimitive(). void TGraphBentErrors::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save primitive as a C++ statement(s) on output stream out. ; Reimplemented from TGraph.; Definition at line 551 of file TGraphBentErrors.cxx. ◆ Scale(). void TGraphBentErrors::Scale ; (; Double_t ; c1 = 1., . Option_t * ; option = ""y"" . ). overridevirtual . Multiply the values and errors of a TGraphBentErrors by a constant c1. ; If option contains ""x"" the x values and errors are scaled If option contains ""y"" the y values and errors are scaled If option contains ""xy"" both x and y values and errors are scaled ; Reimplemented from TGraph.; Definition at line 510 of file TGraphBentErrors.cxx. ◆ SetPointError() [1/2]. void TGraphBentErrors::SetPointError ; (; Double_t ; exl, . Double_t ; exh, . Double_t ; eyl, . Double_t ; eyh, . Double_t ; exld = 0, . Double_t ; exhd = 0, . Double_t ; eyld = 0, . Double_t ; eyhd = 0 . ). virtual . Set ex and ey values for point pointed by the mouse. ; Definition at line 587 of file TGraphBentErrors.cxx. ◆ SetPointError() [2/2]. void TGraphBentErrors::SetPointError ; (; Int_t ; i, . Double_t ; exl, . Double_t ; exh, . Double_t ; eyl, . Double_t ; eyh, . Double_t ; exld = 0, . Double_t ; exhd = 0, . Double_t ; eyld = 0, . Double_t ; eyhd = 0 . ). virtual . Set ex and ey values for point number i. ; Definition at line 624 of file TGraphBentErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:43196,error,errors,43196,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,1,['error'],['errors']
Availability,"You can select the active camera from the viewer’s Camera menu on the top menu bar. There are three perspective camera choices:. Perspective (Floor XOZ) Default; Perspective (Floor YOZ); Perspective (Floor XOY). In each case the perspective camera is constrained to keep the chosen floor plane, defined by a pair of world axes, appearing level at all times - i.e. there is no banking of the ‘horizon’ that you experience when a plane rolls. There are also three orthographic camera choices:. Orthographic (XOY); Orthographic (XOZ); Orthographic (ZOY). Orthographic projections are generally constrained to look down one of the global axes of the world, with the other two axes lying horizontal/vertical on the viewer window. Therefore, XOY has the X-axis horizontal, the Y-axis vertical. You can always confirm the orientation and constraints of the camera in the world by enabling axis drawing in the “Guides” tab - see sections “Guides” and “Clipping” below. For orthographic camera a ruler-depicting current scene units is also available.; You can also pick the current camera by obtaining a handle to the GL Viewer object behind the interface:; TGLViewer * v = (TGLViewer *)gPad->GetViewer3D();; calling the method TGLViewer::SetCurrentCamera with one of the TGLViewer::ECameraType types:; v->SetCurrentCamera(TGLViewer::kCameraPerspXOZ);; See also $ROOTSYS/tutorials/gl/glViewerExercise.C.; 9.13.2.2 Adjusting Cameras; The interactions with the camera are summarized above. In each case the interaction is listed, along with description and user actions required to achieve it. For all cameras you can reset the original default view, framing the entire scene, by double clicking any mouse button. GL Viewer camera interactions. For the Zoom interaction you can use the following modifiers combinations to adjust the sensitivity:. Shiftx 10; Ctrlx 0.1; Shift + Ctrlx 0.01. The modifiers must be applied after the zoom action has started (right mouse button is down).; Note for orthographic camera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:389950,avail,available,389950,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"You must provide a default constructor or an I/O constructor for your class. See the “The Default Constructor” paragraph in this chapter.; #include <iostream.h>; #include ""TObject.h""; class SClass : public TObject {; private:; Float_t fX; //x position in centimeters; Float_t fY; //y position in centimeters; Int_t fTempValue; //! temporary state value; public:; SClass() { fX = fY = -1; }; void Print() const;; void SetX(float x) { fX = x; }; void SetY(float y) { fY = y; }. ClassDef(SClass, 1); };; Step 2: Add a call to the ClassDef macro to at the end of the class definition (in the SClass.h file). ClassDef(SClass,1). Add a call to the ClassImp macro in the implementation file (SClass.cxx): ClassImp(SClass).; // SClass.cxx:; #include ""SClass.h""; ClassImp(SClass);; void SClass::Print() const {; cout << ""fX = "" << fX << "", fY = "" << fY << endl;; }; You can add a class without using the ClassDef and ClassImp macros; however, you will be limited. Specifically the object I/O features of ROOT will not be available to you for these classes. See “Cling the C++ Interpreter”. The ShowMembers and Streamer method, as well as the >> operator overloads, are implemented only if you use ClassDef and ClassImp. See $ROOTSYS/include/Rtypes.h for the definition of ClassDef and ClassImp. To exclude a data member from the Streamer, add a ! as the first character in the comments of the field:; Int_t fTempValue; //! temporary state value; 15.5.1 The LinkDef.h File; Step 3: The LinkDef.h file tells rootcling which classes should be added to the dictionary.; #ifdef __CLING__; #pragma link C++ class SClass;; #endif; Three options can trail the class name:. - : tells rootcling not to generate the Streamer method for this class. This is necessary for those classes that need a customized Streamer method. #pragma link C++ class SClass-; // no streamer. ! : tells rootcling not to generate the operator>>(TBuffer &b,MyClass *&obj) method for this class. This is necessary to be able to write pointers to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:824018,avail,available,824018,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"ZIP64_EXTENDED_USIZE_LEN; static TZIPFile::EZIPConstantskZIP64_EXTENDED_USIZE_OFF; static TZIPFile::EZIPConstantskZIP64_EXTENTED_CSIZE_OFF; static TZIPFile::EZIPConstantskZIP_MAGIC_LEN. Class Charts. Inheritance Chart:. TObject. ←; TArchiveFile. ←; TZIPFile. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Long64_t ReadZip64EndLocator(Long64_t pos); Read Zip64 end of central directory locator. Returns -1 in case of error,; -2 in case end locator magic is not found (i.e. not a zip64 file) and; offset of Zip64 end of central directory record in case of success. Int_t ReadZip64EndRecord(Long64_t pos); Read Zip64 end of central directory record. Returns -1 in case of error; and 0 in case of success. Int_t ReadDirectory(); Read the directory of the ZIP archive. Returns -1 in case of error,; 0 otherwise. Int_t ReadMemberHeader(TZIPMember* member); Read the member header of the ZIP archive. Sets the position where; the data starts in the member object. Returns -1 in case of error,; 0 otherwise. Int_t DecodeZip64ExtendedExtraField(TZIPMember* m, Bool_t global = kTRUE); Decode the Zip64 extended extra field. If global is true, decode the; extra field coming from the central directory, if false decode the; extra field coming from the local file header. Returns -1 in case of; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TZIPFile.html:16301,error,error,16301,root/html602/TZIPFile.html,https://root.cern,https://root.cern/root/html602/TZIPFile.html,4,['error'],['error']
Availability,"Zaxis()Definition TH1.h:326; TH1::fNcellsInt_t fNcellsNumber of bins(1D), cells (2D) +U/Overflows.Definition TH1.h:89; TH1::fTsumwDouble_t fTsumwTotal Sum of weights.Definition TH1.h:96; TH1::fTsumw2Double_t fTsumw2Total Sum of squares of weights.Definition TH1.h:97; TH1::fTsumwx2Double_t fTsumwx2Total Sum of weight*X*X.Definition TH1.h:99; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetNbinsZvirtual Int_t GetNbinsZ() constDefinition TH1.h:299; TH1::kIsNotW@ kIsNotWHistogram is forced to be not weighted even when the histogram is filled with weighted.Definition TH1.h:172; TH1::CanExtendAllAxesvirtual Bool_t CanExtendAllAxes() constReturns true if all axes are extendable.Definition TH1.cxx:6636; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TH1::kNstat@ kNstatSize of statistics data (up to TProfile3D)Definition TH1.h:184; TH1::fEntriesDouble_t fEntriesNumber of entries.Definition TH1.h:95; TH1::fZaxisTAxis fZaxisZ axis descriptor.Definition TH1.h:92; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::fXaxisTAxis fX",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:57536,error,error,57536,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"Zaxis; static TObject::(anonymous)TObject::kZombie. protected:. Short_tfBarOffset(1000*offset) for bar charts or legos; Short_tfBarWidth(1000*width) for bar charts or legos; TH1::EBinErrorOptfBinStatErrOptoption for bin statistical errors; Double_t*fBuffer[fBufferSize] entry buffer; Int_tfBufferSizefBuffer size; TArrayDfContourArray to display contour levels; Int_tfDimension!Histogram dimension (1, 2 or 3 dim); TDirectory*fDirectory!Pointer to directory holding this histogram; Double_tfEntriesNumber of entries; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; TList*fFunctions->Pointer to list of functions (fits and user); Double_t*fIntegral!Integral of bins used by GetRandom; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Double_tfMaximumMaximum value for plotting; Double_tfMinimumMinimum value for plotting; TStringTNamed::fNameobject identifier; Int_tfNcellsnumber of bins(1D), cells (2D) +U/Overflows; Double_tfNormFactorNormalization factor; TStringfOptionhistogram options; TVirtualHistPainter*fPainter!pointer to histogram painter; TArrayDfSumw2Array of sum of squares of weights; TStringTNamed::fTitleobject title; Double_tfTsumwTotal Sum of weights; Double_tfTsumw2Total Sum of squares of weights; Double_tfTsumwxTotal Sum of weight*X; Double_tfTsumwx2Total Sum of weight*X*X; TAxisfXaxisX axis descriptor; TAxisfYaxisY axis descriptor; TAxisfZaxisZ axis descriptor; static Bool_tfgAddDirectory!flag to add histograms to the directory; static Int_tfgBufferSize!default buffer size for automatic histograms; static Bool_tfgDefaultSumw2!flag to call TH1::Sumw2 automatically at histogram creation time; static Bool_tfgStatOverflows!flag to use under/overflows in statistics. Class Charts. Inheritance; Inherited Members; Includes; Librar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:38119,error,errors,38119,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['errors']
Availability,"ZaxisTAxis * GetZaxis() constGet z axis of the function. (In case this object is a TF2 or TF3)Definition TF1.cxx:2422; TF1::GetRandomvirtual Double_t GetRandom(TRandom *rng=nullptr, Option_t *opt=nullptr)Return a random number following this function shape.Definition TF1.cxx:2192; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::GetNparvirtual Int_t GetNpar() constDefinition TF1.h:509; TF1::fBetastd::vector< Double_t > fBeta! Array beta. is approximated by x = alpha +beta*r *gamma*r**2Definition TF1.h:280; TF1::fNDFInt_t fNDFNumber of degrees of freedom in the fit.Definition TF1.h:270; TF1::fHistogramTH1 * fHistogram! Pointer to histogram used for visualisationDefinition TF1.h:283; TF1::fCompositionstd::unique_ptr< TF1AbsComposition > fCompositionPointer to composition (NSUM or CONV)Definition TF1.h:290; TF1::SetParErrorsvirtual void SetParErrors(const Double_t *errors)Set errors for all active parameters when calling this function, the array errors must have at least ...Definition TF1.cxx:3490; TF1::DoCreateHistogramvirtual TH1 * DoCreateHistogram(Double_t xmin, Double_t xmax, Bool_t recreate=kFALSE)Create histogram with bin content equal to function value computed at the bin center This histogram w...Definition TF1.cxx:3048; TF1::fNpfitsInt_t fNpfitsNumber of points used in the fit.Definition TF1.h:269; TF1::Derivative2virtual Double_t Derivative2(Double_t x, Double_t *params=nullptr, Double_t epsilon=0.001) constReturns the second derivative of the function at point x, computed by Richardson's extrapolation meth...Definition TF1.cxx:1178; TF1::SetCurrentstatic void SetCurrent(TF1 *f1)Static function setting the current function.Definition TF1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:179905,error,errors,179905,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,3,['error'],['errors']
Availability,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $ » Last generated: 2010-11-25 07:09; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparseArrayChunk.html:6348,error,errors,6348,root/html528/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html528/THnSparseArrayChunk.html,2,['error'],['errors']
Availability,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: THnSparse.h 36894 2010-11-24 11:04:47Z moneta $ » Last generated: 2011-07-04 15:33; This page has been automatically generated. For comments or suggestions regarding the document",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THnSparseArrayChunk.html:6417,error,errors,6417,root/html530/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html530/THnSparseArrayChunk.html,2,['error'],['errors']
Availability,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id: THnSparse_Internal.h 41546 2011-10-24 14:42:42Z axel $ » Last generated: 2011-12-02 14:28; This page has been automatically generated. For comments or suggestions regarding the d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/THnSparseArrayChunk.html:6417,error,errors,6417,root/html532/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html532/THnSparseArrayChunk.html,4,['error'],['errors']
Availability,"Zombie(). private:. THnSparseArrayChunk(const THnSparseArrayChunk&); THnSparseArrayChunk&operator=(const THnSparseArrayChunk&). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TArray*fContentbin content; Int_tfCoordinateAllocationSize! size of the allocated coordinate buffer; -1 means none or fCoordinatesSize; Char_t*fCoordinates[fCoordinatesSize] compact bin coordinate buffer; Int_tfCoordinatesSizesize of the bin coordinate buffer; Int_tfSingleCoordinateSizesize of a single bin coordinate; TArrayD*fSumw2bin errors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THnSparseArrayChunk(Int_t coordsize, bool errors, TArray* cont); (Default) initialize a chunk. Takes ownership of cont (~THnSparseArrayChunk deletes it),; and create an ArrayF for errors if ""errors"" is true. ~THnSparseArrayChunk(); Destructor. void AddBin(Int_t idx, const Char_t* idxbuf); Create a new bin in this chunk. void Sumw2(); Turn on support of errors. THnSparseArrayChunk(const THnSparseArrayChunk& ). THnSparseArrayChunk& operator=(const THnSparseArrayChunk& ). THnSparseArrayChunk(); {}. void AddBinContent(Int_t idx, Double_t v = 1.). Int_t GetEntries() const; { return fCoordinatesSize / fSingleCoordinateSize; }. Bool_t Matches(Int_t idx, const Char_t* idxbuf) const; Check whether bin at idx batches idxbuf.; If we don't store indexes we trust the caller that it does match,; see comment in THnSparseCompactBinCoord::GetHash(). » Author: Axel Naumann (2007-09-11) » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THnSparseArrayChunk.html:6436,error,errors,6436,root/html534/THnSparseArrayChunk.html,https://root.cern,https://root.cern/root/html534/THnSparseArrayChunk.html,4,['error'],['errors']
Availability,"Zombie(); static TApplication*Open(const char* url, Int_t debug, const char* script); static Int_tParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual Long_tProcessRemote(const char* line, Int_t* error = 0); voidSetSignalHandler(TSignalHandler* sh). private:. TApplication(const TApplication&); TApplication&operator=(const TApplication&). Data Members; public:. enum EStatusBits { kProcessRemotely; kDefaultApplication; };; enum EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*fgApplicationsList of available applications. private:. TApplicationImp*fAppImp!Window system specific application implementation; Int_tfArgcNumber of com mand line arguments; char**fArgvCommand line arguments; TApplication::EExitOnExceptionfExitOnExceptionExit on exception option; TObjArray*fFilesArray of input files (TObjString's) specified via argv; TStringfIdleCommandCommand to execute while application is idle; TTimer*fIdleTimerIdle timer; Bool_tfIsRunningTrue when in event loop (Run() has been called); Bool_tfNoLogDo not process logon and logoff macros; Bool_tfNoLogoDo not show splash screen and welcome message; Bool_tfQuitExit after having processed input files; Bool_tfReturnFromRunWhen true return from Run(); TSignalHandler*fSigHandlerInterrupt handler; Bool_tfUseMemstatRun with TMemStat enabled; TStringfWorkDirWorking",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TApplication.html:11332,avail,available,11332,root/html528/TApplication.html,https://root.cern,https://root.cern/root/html528/TApplication.html,6,['avail'],['available']
Availability,"Zombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTArchiveFile::fArchiveNameArchive file name; TStringfCommentArchive comment; TArchiveMember*TArchiveFile::fCurMemberCurrent archive member; Long64_tfDirOffsetCentral directory offset (from the beginning of the archive); Long64_tfDirPosCentral directory position; Long64_tfDirSizeCentral directory size; TFile*TArchiveFile::fFileFile stream used to access the archive; Int_tTArchiveFile::fMemberIndexIndex of sub-file in archive; TStringTArchiveFile::fMemberNameSub-file name; TObjArray*TArchiveFile::fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Int_t ReadDirectory(); Read the directory of the ZIP archive. Returns -1 in case of error,; 0 otherwise. Int_t ReadMemberHeader(TZIPMember* member); Read the member header of the ZIP archive. Sets the position where; the data starts in the member object. Returns -1 in case of error,; 0 otherwise. Int_t SetCurrentMember(); Find the desired member in the member array and make it the; current member. Returns -1 in case member is not found, 0 otherwise. UInt_t Get(const void* buffer, Int_t bytes); Read a ""bytes"" long little-endian integer value from ""buffe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TZIPFile.html:10274,error,error,10274,root/html528/TZIPFile.html,https://root.cern,https://root.cern/root/html528/TZIPFile.html,1,['error'],['error']
Availability,"Zombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTArchiveFile::fArchiveNameArchive file name; TStringfCommentArchive comment; TArchiveMember*TArchiveFile::fCurMemberCurrent archive member; Long64_tfDirOffsetCentral directory offset (from the beginning of the archive); Long64_tfDirPosCentral directory position; Long64_tfDirSizeCentral directory size; TFile*TArchiveFile::fFileFile stream used to access the archive; Int_tTArchiveFile::fMemberIndexIndex of sub-file in archive; TStringTArchiveFile::fMemberNameSub-file name; TObjArray*TArchiveFile::fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Long64_t ReadZip64EndLocator(Long64_t pos); Read Zip64 end of central directory locator. Returns -1 in case of error,; -2 in case end locator magic is not found (i.e. not a zip64 file) and; offset of Zip64 end of central directory record in case of success. Int_t ReadZip64EndRecord(Long64_t pos); Read Zip64 end of central directory record. Returns -1 in case of error; and 0 in case of success. Int_t ReadDirectory(); Read the directory of the ZIP archive. Returns -1 in case of error,; 0 otherwise. Int_t ReadMemberHeader(TZIPMember* member); Read the mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TZIPFile.html:11767,error,error,11767,root/html530/TZIPFile.html,https://root.cern,https://root.cern/root/html530/TZIPFile.html,5,['error'],['error']
Availability,"[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiE4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html:18163,toler,tolerance,18163,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiE4D_double___.html,6,['toler'],['tolerance']
Availability,"[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. Scalar Dot(const OtherLorentzVector & q); ------ Operations combining two Lorentz vectors ------. scalar (Dot) product of two LorentzVector vectors (metric is -,-,-,+); Enable the product using any other LorentzVector implementing; the x(), y() , y() and t() member functions; \param q any LorentzVector implementing the x(), y() , z() and t(); member functions; \return the result of v.q of type according to the base scalar type of v. return operator*( Scalar(-1) ); LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PtEtaPhiM4D<double> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect(); TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoordinate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html:17425,toler,tolerance,17425,root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__LorentzVector_-p1PtEtaPhiM4D_double___.html,6,['toler'],['tolerance']
Availability,"[2/2]. Handle_t TGCocoa::CreateOpenGLContext ; (; Window_t ; windowID, . Handle_t ; sharedContext . ). overridevirtual . Creates OpenGL context for window ""windowID"". ; Reimplemented from TVirtualX.; Definition at line 3285 of file TGCocoa.mm. ◆ CreateOpenGLWindow(). Window_t TGCocoa::CreateOpenGLWindow ; (; Window_t ; parentID, . UInt_t ; width, . UInt_t ; height, . const std::vector< std::pair< UInt_t, Int_t > > & ; format . ). overridevirtual . Create window with special pixel format. Noop everywhere except Cocoa. ; Reimplemented from TVirtualX.; Definition at line 3206 of file TGCocoa.mm. ◆ CreatePictureFromData(). Bool_t TGCocoa::CreatePictureFromData ; (; Drawable_t ; id, . char ** ; data, . Pixmap_t & ; pict, . Pixmap_t & ; pict_mask, . PictureAttributes_t & ; attr . ). overridevirtual . Creates a picture pict from data in bitmap format. ; The picture attributes ""attr"" are used for input and output. Returns kTRUE in case of success, kFALSE otherwise. If the mask ""pict_mask"" does not exist it is set to kNone. ; Reimplemented from TVirtualX.; Definition at line 4217 of file TGCocoa.mm. ◆ CreatePictureFromFile(). Bool_t TGCocoa::CreatePictureFromFile ; (; Drawable_t ; id, . const char * ; filename, . Pixmap_t & ; pict, . Pixmap_t & ; pict_mask, . PictureAttributes_t & ; attr . ). overridevirtual . Creates a picture pict from data in file ""filename"". ; The picture attributes ""attr"" are used for input and output. Returns kTRUE in case of success, kFALSE otherwise. If the mask ""pict_mask"" does not exist it is set to kNone. ; Reimplemented from TVirtualX.; Definition at line 4202 of file TGCocoa.mm. ◆ CreatePixmap() [1/2]. Pixmap_t TGCocoa::CreatePixmap ; (; Drawable_t ; id, . const char * ; bitmap, . UInt_t ; width, . UInt_t ; height, . ULong_t ; forecolor, . ULong_t ; backcolor, . Int_t ; depth . ). overridevirtual . Creates a pixmap from bitmap data of the width, height, and depth you specified and returns a pixmap that identifies it. ; The width and height argume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:65827,mask,mask,65827,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability,"[2/2]. TPackMgr::TPackMgr ; (; const char * ; dir, . const char * ; key = ""L0"" . ). Create a PROOF package manager. ; Definition at line 49 of file TPackMgr.cxx. ◆ ~TPackMgr(). TPackMgr::~TPackMgr ; (; ). override . Destroy a TPackMgr instance. ; Definition at line 64 of file TPackMgr.cxx. Member Function Documentation. ◆ Build(). Int_t TPackMgr::Build ; (; const char * ; pack, . Int_t ; opt = TPackMgr::kCheckROOT . ). Method to build a package. ; Return -1 on error, 0 otherwise ; Definition at line 87 of file TPackMgr.cxx. ◆ Class(). static TClass * TPackMgr::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TPackMgr::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TPackMgr::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 106 of file TPackMgr.h. ◆ Clean(). Int_t TPackMgr::Clean ; (; const char * ; pack). Clean dir for package 'pack' Return -1 in case of error, 0 otherwise. ; Definition at line 576 of file TPackMgr.cxx. ◆ DeclFileName(). static const char * TPackMgr::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 106 of file TPackMgr.h. ◆ FindParPath(). Int_t TPackMgr::FindParPath ; (; TPackMgr * ; packmgr, . const char * ; pack, . TString & ; par . ). static . Get the full path to PAR, looking also in the global dirs. ; Returns -1 if not found, 0 if available in global dirs, 1 if it can be uploaded from the local package dir. For the cases >= 0, par is filled with the path of the PAR file ; Definition at line 934 of file TPackMgr.cxx. ◆ GetDir(). const char * TPackMgr::GetDir ; (; ); const. inline . Definition at line 77 of file TPackMgr.h. ◆ GetDownloadDir(). Int_t TPackMgr::GetDownloadDir ; (; TString & ; dldir). Method to get the download dir; create if not existing Return -1 in case of error (not found; not created), 0 otherwise. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:16470,error,error,16470,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['error'],['error']
Availability,"[2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.01562 , s = 4.5; [5] h = 0.003906 , s = 3.75; [6] h = 0.0009766 , s = 4.125; [7] h = 0.0002441 , s = 3.938; [8] h = 6.104e-05 , s = 4.031; [9] h = 1.526e-05 , s = 3.984; [10] h = 3.815e-06 , s = 4.008; [11] h = 9.537e-07 , s = 3.996; [12] h = 2.384e-07 , s = 4.002; [13] h = 5.96e-08 , s = 3.999; [14] h = 1.49e-08 , s = 4; [15] h = 3.725e-09 , s = 4; [16] h = 9.313e-10 , s = 4; [17] h = 2.328e-10 , s = 4; [18] h = 5.821e-11 , s = 4; [19] h = 1.455e-11 , s = 4; [20] h = 3.638e-12 , s = 4; ; prevFCN = 2171.25988 mean=-1.438, ; prevFCN = 2171.25988 mean=1.465, ; prevFCN = 2171.25988 mean=-1.465, ; prevFCN = 2171.25988 mean=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a: using 0.5; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for mean: using 0.6; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma: using 0.1921; ; prevFCN = 2171.25988 a=2.017, ; prevFCN = 2171.25988 a=1.983, ; prevFCN = 2171.25988 a=2.172, ; prevFCN = 2171.691427 a=1.84, [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_mean over range (-6,6) did not converge after 20 steps; [1] h = 1 , s = 0; [2] h = 0.25 , s = 6; [3] h = 0.0625 , s = 3; [4] h = 0.01562 , s = 4.5; [5] h = 0.003906 , s = 3.75; [6] h = 0.0009766 , s = 3.375; [7] h = 0.0002441 , s = 3.562; [8] h = 6.104e-05 , s = 3.656; [9] h = 1.526e-05 , s = 3.703; [10] h = 3.815e-06 , s = 3.68; [11] h = 9.537e-07 , s = 3.691; [12] h = 2.384e-07 , s = 3.686; [13] h = 5.96e-08 , s = 3.683; [14] h = 1.49e-08 , s = 3.681; [15] h = 3.725e-09 , s = 3.68; [16] h = 9.313e-10 , s = 3.68; [17] h = 2.328e-10 , s = 3.68; [18] h = 5.821e-11 , s = 3.68; [19] h = 1.455e-11 , s = 3.68; [20] h = 3.638e-12 , s = 3.68; [#0] WARNING:Integration -- RooRombergIntegrator::integral: integral of model_me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf211__paramconv_8C.html:29233,error,error,29233,doc/master/rf211__paramconv_8C.html,https://root.cern,https://root.cern/doc/master/rf211__paramconv_8C.html,4,"['avail', 'error']","['available', 'error']"
Availability,"[3][2]. tree->Draw(""fMatrix[ ][ ] - fVertex[ ][ ]""). This is the same as case 15. The first dimension minimum is 4 (from fMatrix), and the second dimension minimum is 3 (from fVertex). Twelve values are selected from each entry. tree->Draw(""fClosestDistance""). This event data member fClosestDistance is a variable length array:; Float_t *fClosestDistance; //[fNvertex]; This command selects all elements, but the number per entry depends on the number of vertices of that entry. tree->Draw(""fClosestDistance[fNvertex/2]""). With this command the element at fNvertex/2 of the fClosestDistancearray is selected. Only one per entry is selected. tree->Draw(""sqrt(fPx*fPx + fPy*fPy + fPz*fPz)""). This command shows the use of a mathematical expression. It draws the square root of the sum of the product. tree->Draw(""TMath::BreitWigner(fPx,3,2)""). The formula can contains call to a function that takes numerical arguments and returns a numerical value. The function needs to be declared to the dictionary and need to be available from the global namespace. In particular, global functions and public static member functions can be called. tree->Draw(""fEvtHdr.fEvtNum"",""fType==""type1"" ""). You can compare strings, using the symbols == and !=, in the first two parameters of the Draw command (TTreeFormula). In this case, the event number for ‘type1’ events is plotted. tree->Draw(""fEvtHdr.fEvtNum"",""strstr(fType,""1"") ""). To compare strings, you can also use strstr. In this case, events having a ‘1’ in fType are selected. tree->Draw(""fTracks.fPoints""). If fPoints is a data member of the Track class declared as:; Int_t fNpoint;; Int_t *fPoints; [fNpoint]; The size of the array fPoints varies with each track of each event. This command draws all the value in the fPoints arrays. tree->Draw(""fTracks.fPoints - fTracks.fPoints[][fAvgPoints]"");. When fAvgPoints is a data member of the Event class, this example selects:; fTracks[0].fPoints[0] - fTracks[0].fPoint[fAvgPoints]; fTracks[0].fPoints[1] - fTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:601072,avail,available,601072,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"[Number of times the classifier will be boosted]; : Parsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Architecture=GPU:Layout=TANH|100,TANH|50,TANH|10,LINEAR:TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|100,TANH|50,TANH|10,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""GPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""Optimizer=ADAM,LearningRate=1e-3,TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:5199,error,error,5199,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['error'],['error']
Availability,"[TMVA] Pymva test (Keras) failing on 632 and main; [#15370] - Broken link in HS3 printout; [#15340] - Webgraphics: canvas displayed, but many error printed; [#15253] - C++ standard not propagated via CMake anymore; [#15197] - RBDT does not support xgboost inference; [#15156] - Segfault in TMVA::Experimental::SOFIE::RModel::Streamer; [#15139] - cmake option -Dall=YES breaks the cmake; [#15118] - jsoninterface does not build if provided with RapidYAML; [#15108] - Turn off clang-format for Linkdef files; [#15090] - TClass::GetClassInfo() is not thread safe; [#15077] - Passing different floating point types to RVec utility functions; [#15048] - [ntuple] Handling of virtual inheritance broken; [#15040] - RDataFrame Inaccurate example of progress bar from documentation; [#15028] - RDataFrame Unable to cacheread remote file; [#15027] - spurrious cmake message about AfterImage with -Dminimal=ON; [#14981] - RVecs leak memory with np.asarray in pyROOT; [#14964] - ROOT-HEAD fails with “cling interactive line includer >>>: fatal error: module file ‘[snip]/Vc.pcm’ not found: module file not found”; [#14958] - ROOT_HEAD failed with error message: Fail to detect cryptographic random generator; [#14921] - ROOT Fails to build macOS 14.4 arm64 Xcode 15.3; [#14914] - VecOps::Take with default argument doesn’t check correctly the out of boundary condition; [#14910] - hadd issue when using parallelization together with indirect file; [#14902] - compilation error; [#14863] - [hist] TH1::SaveAs missing default option argument causes compilation errors; [#14855] - TRatioPlot crashes if loaded from the file; [#14842] - TRatioplot gives “different” results with Web Graphics; [#14838] - Problems with Confidence Band of TRatioPlot; [#14801] - TEfficiency drawing to .C is broken; [#14793] - 6.26 cannot read file written with 6.30.4; [#14772] - [cling] Undocumented behaviour of root macro_C.so; [#14767] - rootn.exe instant crash on startup; [#14765] - TGenPhaseSpace weight normalization; [#14748]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:26273,error,error,26273,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['error'],['error']
Availability,"[This is very unlikely to work, but who knows!]; 5018 {; 5019 TClass__GetCallingNewRAII callingNew(defConstructor);; 5020 p = gCling->ClassInfo_New(GetClassInfo());; 5021 }; 5022 if (!p && !quiet) {; 5023 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5024 Error(""New"", ""cannot create object of class %s"", GetName());; 5025 }; 5026 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5027 // There is no dictionary at all, so this is an emulated; 5028 // class; however we do have the services of a collection proxy,; 5029 // so this is an emulated STL class.; 5030 {; 5031 TClass__GetCallingNewRAII callingNew(defConstructor);; 5032 p = fCollectionProxy->NewObject();; 5033 }; 5034 if (!p && !quiet) {; 5035 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5036 Error(""New"", ""cannot create object of class %s"", GetName());; 5037 }; 5038 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5039 // There is no dictionary at all and we do not have; 5040 // the services of a collection proxy available, so; 5041 // use the streamer info to approximate calling a; 5042 // constructor (basically we just make sure that the; 5043 // pointer data members are null, unless they are marked; 5044 // as preallocated with the ""->"" comment, in which case; 5045 // we default-construct an object to point at).; 5046 ; 5047 // Do not register any TObject's that we create; 5048 // as a result of creating this object.; 5049 // FIXME: Why do we do this?; 5050 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5051 ; 5052 Bool_t statsave = GetObjectStat();; 5053 if(statsave) {; 5054 SetObjectStat(kFALSE);; 5055 }; 5056 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5057 if (!sinfo) {; 5058 if (!quiet); 5059 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5060 return nullptr;; 5061 }; 5062 ; 5063 {; 5064 TClass__",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:192342,avail,available,192342,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"[This is very unlikely to work, but who knows!]; 5085 {; 5086 TClass__GetCallingNewRAII callingNew(defConstructor);; 5087 p = gCling->ClassInfo_New(GetClassInfo());; 5088 }; 5089 if (!p && !quiet) {; 5090 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5091 Error(""New"", ""cannot create object of class %s"", GetName());; 5092 }; 5093 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5094 // There is no dictionary at all, so this is an emulated; 5095 // class; however we do have the services of a collection proxy,; 5096 // so this is an emulated STL class.; 5097 {; 5098 TClass__GetCallingNewRAII callingNew(defConstructor);; 5099 p = fCollectionProxy->NewObject();; 5100 }; 5101 if (!p && !quiet) {; 5102 //Error(""New"", ""cannot create object of class %s version %d"", GetName(), fClassVersion);; 5103 Error(""New"", ""cannot create object of class %s"", GetName());; 5104 }; 5105 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5106 // There is no dictionary at all and we do not have; 5107 // the services of a collection proxy available, so; 5108 // use the streamer info to approximate calling a; 5109 // constructor (basically we just make sure that the; 5110 // pointer data members are null, unless they are marked; 5111 // as preallocated with the ""->"" comment, in which case; 5112 // we default-construct an object to point at).; 5113 ; 5114 // Do not register any TObject's that we create; 5115 // as a result of creating this object.; 5116 // FIXME: Why do we do this?; 5117 // FIXME: Partial Answer: Is this because we may never actually deregister them???; 5118 ; 5119 Bool_t statsave = GetObjectStat();; 5120 if(statsave) {; 5121 SetObjectStat(kFALSE);; 5122 }; 5123 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5124 if (!sinfo) {; 5125 if (!quiet); 5126 Error(""New"", ""Cannot construct class '%s' version %d, no streamer info available!"", GetName(), fClassVersion);; 5127 return nullptr;; 5128 }; 5129 ; 5130 {; 5131 TClass__",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:195093,avail,available,195093,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"[i]+.5;; y1[i] = 10*sin(x1[i]);; y2[i] = 10*cos(x1[i]);; y3[i] = 10*sin(x1[i])-2;; }. TGraph *gr1 = new TGraph(n,x1,y1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);. TGraph *gr2 = new TGraph(n,x2,y2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. TGraph *gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");. return c1;; }; Graphs with error bars; Three classes are available to handle graphs with error bars:; TGraphErrors, TGraphAsymmErrors and TGraphBentErrors.; In addition to the drawing options previously described, the graphs with error; bars can be drawn with the following extra options:. ""Z""; By default horizonthal and vertical small lines are drawn at; the end of the error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""0""; By default, when a data point is outside the visible range along the Y axis the error; bars are not drawn. Combined with other options, this option forces error bars'; drawing for the data points outside the visible range along the Y axis. ""2""; Error r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphPainter.html:5164,error,error,5164,root/html530/TGraphPainter.html,https://root.cern,https://root.cern/root/html530/TGraphPainter.html,1,['error'],['error']
Availability,"[i]+.5;; y1[i] = 10*sin(x1[i]);; y2[i] = 10*cos(x1[i]);; y3[i] = 10*sin(x1[i])-2;; }. TGraph *gr1 = new TGraph(n,x1,y1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);. TGraph *gr2 = new TGraph(n,x2,y2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. TGraph *gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");. return c1;; }; Graphs with error bars; Three classes are available to handle graphs with error bars:; TGraphErrors, TGraphAsymmErrors and TGraphBentErrors.; In addition to the drawing options previously described, the graphs with error; bars can be drawn with the following extra options:. ""Z""; By default horizonthal and vertical small lines are drawn at; the end of the error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error alo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:5164,error,error,5164,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['error']
Availability,"[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXhigh[i] > xmax) xmax = fX[i]+fEXhigh[i];; 262 if (fY[i] -fEYlow[i] < ymin) {; 263 if (gPad && gPad->GetLogy()) {; 264 if (fEYlow[i] < fY[i]) ymin = fY[i]-fEYlow[i];; 265 else ymin = TMath::Min(ymin,fY[i]/3);; 266 } else {; 267 ymin = fY[i]-fEYlow[i];; 268 }; 269 }; 270 if (fY[i] +fEYhigh[i] > ymax) ymax = fY[i]+fEYhigh[i];; 271 }; 272}; 273 ; 274 ; 275////////////////////////////////////////////////////////////////////////////////; 276/// Copy and release.; 277 ; 278void TGraphBentErrors::CopyAndRelease(Double_t **newarrays,; 279 Int_t ibegin, Int_t iend, Int_t obegin); 280{; 281 CopyPoints(newarrays, ibegin, iend, obegin);; 282 if (newarrays) {; 283 delete[] fEXlow;; 284 fEXlow = newarrays[0];; 285 delete[] fEXhigh;; 286 fEXhigh = newarrays[1];; 287 delete[] fEYlow;; 288 fEYlow = newarrays[2];; 289 delete[] fEYhigh;; 290 fEYhigh = newarrays[3];; 291 delete[] fEXlowd;; 292 fEXlowd = newarrays[4];; 293 delete[] fEXhighd;; 294 fEXhighd = newarrays[5];; 295 delete[] fEYlowd;; 296 fEYlowd = newarrays[6];; 297 delete[] fEYhighd;; 298 fEYhighd = newarrays[7];; 299 delete[] fX;; 300 fX = newarrays[8];; 301 delete[] fY;; 302 fY = newarrays[9];; 303 delete[] newarrays;; 304 }; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Copy errors from `fE*** `to `arrays[***]`; 310/// or to `f***` Copy points.; 311 ; 312Bool_t TGraphBentErrors::CopyPoints(Double_t **arrays,; 313 Int_t ibegin, Int_t iend, Int_t obegin); 314{; 315 if (TGraph::CopyPoints(arrays ? arrays+8 : nullptr, ibegin, iend, obegin)) {; 316 Int_t n = (iend - ibegin)*sizeof(Double_t);; 317 if (arrays) {; 318 memmove(&arrays[0][obegin], &fEXlow[ibegin], n);; 319 memmove(&arrays[1][obegin], &fEXhigh[ibegin], n);; 320 memmove(&arrays[2][obegin], &fEYlow[ibegin], n);; 321 memmove(&arrays[3][obegin], &fEYhigh[ibegin], n);; 322 memmove(&arrays[4][obegin], &fEXlowd[ibegin], n);; 323",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:9979,error,errors,9979,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errors']
Availability,"[i];; 13357 uint8_t mask = 0;; 13358 ; 13359 if (8 * i + 8 < slash) {; 13360 mask = 0xFFu;; 13361 } else if (8 * i < slash) {; 13362 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13363 }; 13364 if ((ip & mask) != net) {; 13365 return 0;; 13366 }; 13367 }; 13368 return 1;; 13369 }; 13370 }; 13371 }; 13372 }; 13373#else; 13374 (void)no_strict;; 13375#endif; 13376 ; 13377 /* malformed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 char mult;; 13388 double v;; 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0);; 13409 if (matched >= 0) {; 13410 /* a valid IP subnet */; 13411 if (matched) {; 13412 throttle = (int)v;; 13413 }; 13414 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13415 throttle = (int)v;; 13416 }; 13417 }; 13418 }; 13419 ; 13420 return throttle;; 13421}; 13422 ; 13423 ; 13424/* The mg_upload function is superseeded by mg_handle_form_request. */; 13425#include ""handle_form.inl""; 13426 ; 13427 ; 13428static int; 13429get_first_ssl_listener_index(const struct mg_context *ctx); 13430{; 13431 unsigned int i;; 13432 int idx = -1;; 13433 if (ctx) {; 13434 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:391561,error,errors,391561,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['errors']
Availability,"[i];; 13358 uint8_t mask = 0;; 13359 ; 13360 if (8 * i + 8 < slash) {; 13361 mask = 0xFFu;; 13362 } else if (8 * i < slash) {; 13363 mask = (uint8_t)(0xFFu << (8 * i + 8 - slash));; 13364 }; 13365 if ((ip & mask) != net) {; 13366 return 0;; 13367 }; 13368 }; 13369 return 1;; 13370 }; 13371 }; 13372 }; 13373 }; 13374#else; 13375 (void)no_strict;; 13376#endif; 13377 ; 13378 /* malformed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 char mult;; 13389 double v;; 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0);; 13410 if (matched >= 0) {; 13411 /* a valid IP subnet */; 13412 if (matched) {; 13413 throttle = (int)v;; 13414 }; 13415 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13416 throttle = (int)v;; 13417 }; 13418 }; 13419 }; 13420 ; 13421 return throttle;; 13422}; 13423 ; 13424 ; 13425/* The mg_upload function is superseeded by mg_handle_form_request. */; 13426#include ""handle_form.inl""; 13427 ; 13428 ; 13429static int; 13430get_first_ssl_listener_index(const struct mg_context *ctx); 13431{; 13432 unsigned int i;; 13433 int idx = -1;; 13434 if (ctx) {; 13435 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:391594,error,errors,391594,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['errors']
Availability,"[in] sumEntries The number of observed events.; 686/// \param[in] nset The normalization set when asking the pdf for the expected; 687/// number of events.; 688/// \param[in] observedSumW2 The number of observed events when weighting with; 689/// squared weights. If non-zero, the weight-squared error; 690/// correction is applied to the extended term.; 691/// \param[in] doOffset Offset the extended term by a counterterm where the; 692/// expected number of events equals the observed number of events.; 693/// This constant shift results in a term closer to zero that is; 694/// approximately chi-square distributed. It is useful to do this; 695/// also when summing multiple NLL terms to avoid numeric precision; 696/// loss that happens if you sum multiple terms of different orders; 697/// of magnitude.; 698///; 699/// The weight-squared error correction works as follows:; 700/// adjust poisson such that; 701/// estimate of \f$N_\mathrm{expect}\f$ stays at the same value, but has a different variance, rescale; 702/// both the observed and expected count of the Poisson with a factor \f$ \sum w_{i} / \sum w_{i}^2 \f$; 703/// (the effective weight of the Poisson term),; 704/// i.e., change \f$\mathrm{Poisson}(N_\mathrm{observed} = \sum w_{i} | N_\mathrm{expect} )\f$; 705/// to \f$ \mathrm{Poisson}(\sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 | N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 ) \f$,; 706/// weighted by the effective weight \f$ \sum w_{i}^2 / \sum w_{i} \f$ in the likelihood.; 707/// Since here we compute the likelihood with the weight square, we need to multiply by the; 708/// square of the effective weight:; 709/// - \f$ W_\mathrm{expect} = N_\mathrm{expect} \cdot \sum w_{i} / \sum w_{i}^2 \f$ : effective expected entries; 710/// - \f$ W_\mathrm{observed} = \sum w_{i} \cdot \sum w_{i} / \sum w_{i}^2 \f$ : effective observed entries; 711///; 712/// The extended term for the likelihood weighted by the square of the weight will be then:; 713///; 714/// \f$ \lef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:26982,error,error,26982,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['error'],['error']
Availability,"[in]colorspecifies and returns the RGB values for the pixel specified in the structure . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 128 of file TVirtualX.cxx. ◆ QueryPointer() [1/2]. void TVirtualX::QueryPointer ; (; Int_t & ; ix, . Int_t & ; iy . ). virtual . Returns the pointer position. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 598 of file TVirtualX.cxx. ◆ QueryPointer() [2/2]. void TVirtualX::QueryPointer ; (; Window_t ; id, . Window_t & ; rootw, . Window_t & ; childw, . Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). virtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; Parameters. [in]idspecifies the window ; [in]rootwthe root window that the pointer is in ; [in]childwthe child window that the pointer is located in, if any ; [in]root_x,root_ythe pointer coordinates relative to the root window's origin ; [in]win_x,win_ythe pointer coordinates relative to the specified window ""id"" ; [in]maskthe current state of the modifier keys and pointer buttons . Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 2087 of file TVirtualX.cxx. ◆ RaiseWindow(). void TVirtualX::RaiseWindow ; (; Window_t ; id). virtual . Raises the specified window to the top of the stack so that no sibling window obscures it. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1052 of file TVirtualX.cxx. ◆ ReadGIF(). Pixmap_t TVirtualX::ReadGIF ; (; Int_t ; x0, . Int_t ; y0, . const char * ; file, . Window_t ; id = 0 . ). virtual . If id is NULL - loads the specified gif file at position [x0,y0] in the current window. ; Otherwise creates pixmap from gif file ; Reimplemented in TGWin32, TGX11, and TGCocoa.; Definition at line 607 of file TVirtualX.cxx. ◆ ReadPictureDataFromFile(). Bool_t TVirtualX::ReadPictur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:110715,mask,maskthe,110715,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['mask'],['maskthe']
Availability,"\( N\) independent variables, \( D_j\) is the known, quantity dependent at \(\mathbf{x}_j\) and \( E_j\) is the square error in \( D_j\), the class will try to find the parameterization ; \[; D_p(\mathbf{x}) = \sum_{l=1}^{L} c_l \prod_{i=1}^{N} p_{li}\left(x_i\right); = \sum_{l=1}^{L} c_l F_l(\mathbf{x}); \]. such that. \[; S \equiv \sum_{j=1}^{M} \left(D_j - D_p\left(\mathbf{x}_j\right)\right)^2; \]. is minimal. Here \(p_{li}(x_i)\) are monomials, or Chebyshev or Legendre polynomials, labelled \(l = 1, \ldots, L\), in each variable \( x_i\), \( i=1, \ldots, N\).; So what TMultiDimFit does, is to determine the number of terms \( L\), and then \( L\) terms (or functions) \( F_l\), and the \( L\) coefficients \( c_l\), so that \( S\) is minimal (TMultiDimFit::FindParameterization).; Of course it's more than a little unlikely that \( S\) will ever become exact zero as a result of the procedure outlined below. Therefore, the user is asked to provide a minimum relative error \( \epsilon\) (TMultiDimFit::SetMinRelativeError), and \( S\) will be considered minimized when. \[; R = \frac{S}{\sum_{j=1}^M D_j^2} < \epsilon; \]. Optionally, the user may impose a functional expression by specifying the powers of each variable in \( L\) specified functions \( F_1, \ldots,F_L\) (TMultiDimFit::SetPowers). In that case, only the coefficients \( c_l\) is calculated by the class. Limiting the Number of Terms; As always when dealing with fits, there's a real chance of over fitting. As is well-known, it's always possible to fit an \( N-1\) polynomial in \( x\) to \( N\) points \( (x,y)\) with \(\chi^2 = 0\), but the polynomial is not likely to fit new data at all 1. Therefore, the user is asked to provide an upper limit, \( L_{max}\) to the number of terms in \( D_p\) (TMultiDimFit::SetMaxTerms).; However, since there's an infinite number of \( F_l\) to choose from, the user is asked to give the maximum power. \( P_{max,i}\), of each variable \( x_i\) to be considered in the minimizatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:3572,error,error,3572,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['error'],['error']
Availability,"\(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimzation is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issueing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimzation result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParameters() and; FunctionMinimum::userCovariance(). are provided. These can be used as new input to a new minimizati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:41701,error,errors,41701,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,"['avail', 'error']","['available', 'errors']"
Availability,"\(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&); Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specified via MnUserParameters. No covariance is available.; 5.15.3 MnUserParameterState(const MnUserParameters&,; const MnUserCovariance&); Construct a state from starting values specified via MnUserParameters and MnUserCovariance.; 5.15.4 parameters(); The method parameters() returns a const reference to the MnUserParameters data member.; 5.15.5 covariance(); The method covariance() returns a const reference to the MnUserCovariance data member.; 5.15.6 globalCC(); The method globalCC() returns a const reference to the MnGlobalCorrelationCoeff data member.; 5.15.7 MnUserParameterState::isValid() and; MnUserParameterState::hasCovariance(); isValid() returns true if the the state is valid, false if not. hasCovariance returns true if the the state has a valid covariance, false otherwise.; 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),; MnUserParameterState::nfcn(); After minimization:. fval() returns the function value at the minimum; edm() returns the expected vertival distance to the minimum EDM; nfcn() returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:62475,avail,available,62475,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['avail'],['available']
Availability,"\(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general assymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:23168,error,error,23168,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['error']
Availability,"\(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:19146,error,error,19146,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['error'],['error']
Availability,"\(b\). Since the transformation is necessarily non-linear, it would transform a nice linear problem into a nasty non-linear one, which is the reason why limits should be avoided if not necessary. In addition, the transformation does require some computer time, so it slows down the computation a little bit, and more importantly, it introduces additional numerical inaccuracy into the problem in addition to what is introduced in the numerical calculation of the FCN value. The effects of non-linearity and numerical roundoff both become more important as the external value gets closer to one of the limits (expressed as the distance to nearest limit divided by distance between limits). The user must therefore be aware of the fact that, for example, if he puts limits of \((0,10^{10})\) on a parameter, then the values \(0.0\) and \(1.0\) will be indistinguishable to the accuracy of most machines.; The transformation also affects the parameter error matrix, of course, so Minuit does a transformation of the error matrix (and the `‘parabolic’' parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. How to get the right answer from MINUIT.; MINUIT offers the user a choice of several minimization algorithms. The MIGRAD algorithm is in general the best minimizer for nearly all functions. It is a variable-metric method with inexact line search, a stable metric updating scheme, and checks for positive-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:4012,error,error,4012,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,3,['error'],"['error', 'errors']"
Availability,"\) and will be represented as the size of the notch (where iqr is the size of the box and N is the number of entries of the whole distribution). Candle plots like these are usually called ""notched candle plots"".; In case the significance of the median is greater that the size of the box, the box will have an unnatural shape. Usually it means the chart has not enough data, or that representing this uncertainty is not useful; The Mean; The mean can be drawn as a dashed line or as a circle or not drawn at all. The mean is the arithmetic average of the values in the distribution. It is calculated using GetMean(). Because histograms are binned data, the mean value can differ from a calculation on the raw-data. If the distribution is large enough and gaussian shaped the mean will be exactly the median.; The Whiskers; The whiskers represent the part of the distribution not covered by the box. The upper 25% and the lower 25% of the distribution are located within the whiskers. Two representations are available. A simple one (using w=1) defining the lower whisker from the lowest data value to the bottom of the box, and the upper whisker from the top of the box to the highest data value. In this representation the whisker-lines are dashed.; A more complex one having a further restriction. The whiskers are still connected to the box but their length cannot exceed \( 1.5\times iqr \). So it might be that the outermost part of the underlying distribution will not be covered by the whiskers. Usually these missing parts will be represented by the outliers (see points). Of course the upper and the lower whisker may differ in length. In this representation the whiskers are drawn as solid lines. SinceROOT version 6.11/01; Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1 will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of the lower whisker to the upper whisker in order to cover 95% of the distribution inside tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:61697,avail,available,61697,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avail'],['available']
Availability,"\[; r(a,b) = \frac{\left|g_{16}(a,b)-g_{8}(a,b)\right|}{1+\left|g_{16}(a,b)\right|}; \]. Then, ; \[; G = \sum_{i=1}^{k}g_{16}(x_{i-1},x_{i}); \]. where, starting with \(x_{0} = A\) and finishing with \(x_{k} = B\), the subdivision points \(x_{i}(i=1,2,...)\) are given by ; \[; x_{i} = x_{i-1} + \lambda(B-x_{i-1}); \]. \(\lambda\) is equal to the first member of the sequence 1,1/2,1/4,... for which \(r(x_{i-1}, x_{i}) < EPS\). If, at any stage in the process of subdivision, the ratio ; \[; q = \left|\frac{x_{i}-x_{i-1}}{B-A}\right|; \]. is so small that 1+0.005q is indistinguishable from 1 to machine accuracy, an error exit occurs with the function value set equal to zero.; Accuracy: The user provides absolute and relative error bounds (epsrel and epsabs) and the algorithm will stop when the estimated error is less than the epsabs OR is less than |I| * epsrel. Unless there is severe cancellation of positive and negative values of f(x) over the interval [A,B], the relative error may be considered as specifying a bound on the relative error of I in the case |I|>1, and a bound on the absolute error in the case |I|<1. More precisely, if k is the number of sub-intervals contributing to the approximation (see Method), and if ; \[; I_{abs} = \int^{B}_{A} \left|f(x)\right|dx; \]. then the relation ; \[; \frac{\left|G-I\right|}{I_{abs}+k} < EPS; \]. will nearly always be true, provided the routine terminates without printing an error message. For functions f having no singularities in the closed interval [A,B] the accuracy will usually be much higher than this.; Error handling: The requested accuracy cannot be obtained (see Method). The function value is set equal to zero.; Note 1: Values of the function f(x) at the interval end-points A and B are not required. The subprogram may therefore be used when these values are undefined ; Implements ROOT::Math::VirtualIntegratorOneDim.; Definition at line 52 of file GaussIntegrator.cxx. ◆ IntegralCauchy(). double ROOT::Math::GaussInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussIntegrator.html:7658,error,error,7658,doc/master/classROOT_1_1Math_1_1GaussIntegrator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GaussIntegrator.html,3,['error'],['error']
Availability,"\\; 48 h(j) &= H(j) / W(j) & &\text{mean of Y,} \\; 49 s(j) &= \sqrt{E(j)/W(j)- h(j)^2} & &\text{standard deviation of Y} \\; 50 e(j) &= s(j)/\sqrt{W(j)} & &\text{standard error on the mean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; 69 This simple/crude approximation was suggested in order to keep the bin; 70 during a fit operation. But note that this approximation is not the default behaviour.; 71 See also TProfile::BuildOptions for more on error options.; 72 ; 73 ### Creating and drawing a profile histogram; 74~~~{.cpp}; 75{; 76 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 77 auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:3040,error,error,3040,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['error']
Availability,"\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantles",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMathText.html:15138,down,downharpoonleft,15138,root/html602/TMathText.html,https://root.cern,https://root.cern/root/html602/TMathText.html,4,['down'],['downharpoonleft']
Availability,"\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantless""); l.DrawText(x2, y, ""\\eqslantl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMathText.html:15142,down,downharpoonleft,15142,root/html534/TMathText.html,https://root.cern,https://root.cern/root/html534/TMathText.html,2,['down'],['downharpoonleft']
Availability,"\\left( \\prod_f {d^3p_f\\over (2\\pi)^3} {1\\over 2E_f} \\right) \\left| \\mathscr{M} \\left(m_A - \\left\\{p_f\\right\\} \\right) \\right|^2 (2\\pi)^4 \\delta^{(4)} \\left(p_A - \\sum p_f \\right)"");; l.DrawMathText(0.50, 0.425, ""4\\mathrm{Re}\\left\\{{2\\over 1-\\Delta\\alpha} \\chi(s) \\left[ \\^{g}_\\nu^e \\^{g}_\\nu^f (1 + \\cos^2\\theta) + \\^{g}_a^e \\^{g}_a^f \\cos\\theta \\right] \\right\\}"");; l.DrawMathText(0.50, 0.330, ""p(n) = {1\\over\\pi\\sqrt{2}} \\sum_{k = 1}^\\infty \\sqrt{k} A_k(n) {d\\over dn} {\\sinh \\left\\{ {\\pi\\over k} \\sqrt{2\\over 3} \\sqrt{n - {1\\over 24}} \\right\\} \\over \\sqrt{n - {1\\over 24}}}"");; l.DrawMathText(0.13, 0.150, ""{(\\ell+1)C_{\\ell}^{TE} \\over 2\\pi}"");; l.DrawMathText(0.27, 0.110, ""\\mathbb{N} \\subset \\mathbb{R}"");; l.DrawMathText(0.63, 0.100, ""\\hbox{RHIC スピン物理 Нью-Йорк}"");. c1->Print(""c1.gif"");; c1->Print(""c1.jpg"");; c1->Print(""c1.png"");; c1->Print(""c1.ps"");; c1->Print(""c1.eps"");. return c1;; }. The list of all available symbols is given in the following example:. Picture; Source. // This macro draw all possible symbols provided by TMathtext; //Author: Olivier Couet. {; TCanvas *c1 = new TCanvas(""mathtext"",""TMathText symbol"",1200,1400);. TMathText l;; l.SetTextSize(0.013);; l.SetTextFont(132);. // Draw 1st Column; l.SetTextAlign(12);; float y, step, x1, x2;; y = 0.99; step = 0.0126; x1 = 0.01; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\\""""); l.DrawText(x2, y, ""\\\"""");; y -= step ; l.DrawMathText(x1, y, ""\\'""); l.DrawText(x2, y, ""\\'"");; y -= step ; l.DrawMathText(x1, y, ""\\.""); l.DrawText(x2, y, ""\\."");; y -= step ; l.DrawMathText(x1, y, ""\\=""); l.DrawText(x2, y, ""\\="");; y -= step ; l.DrawMathText(x1, y, ""\\Box""); l.DrawText(x2, y, ""\\Box"");; y -= step ; l.DrawMathText(x1, y, ""\\Bumpeq""); l.DrawText(x2, y, ""\\Bumpeq"");; y -= step ; l.DrawMathText(x1, y, ""\\Cap""); l.DrawText(x2, y, ""\\Cap"");; y -= step ; l.DrawMathText(x1, y, ""\\Cup""); l.DrawText(x2, y, ""\\Cup"");; y -= step ; l.DrawMathText(x1, y, ""\\Delta""); l.D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMathText.html:2345,avail,available,2345,root/html602/TMathText.html,https://root.cern,https://root.cern/root/html602/TMathText.html,4,['avail'],['available']
Availability,"\brief 1-D histogram with a double per channel (see TH1 documentation); 72@}; 73*/; 74 ; 75/** \class TH1; 76 \ingroup Histograms; 77TH1 is the base class of all histogram classes in %ROOT.; 78 ; 79It provides the common interface for operations such as binning, filling, drawing, which; 80will be detailed below.; 81 ; 82-# [Creating histograms](\ref creating-histograms); 83 - [Labelling axes](\ref labelling-axis); 84-# [Binning](\ref binning); 85 - [Fix or variable bin size](\ref fix-var); 86 - [Convention for numbering bins](\ref convention); 87 - [Alphanumeric Bin Labels](\ref alpha); 88 - [Histograms with automatic bins](\ref auto-bin); 89 - [Rebinning](\ref rebinning); 90-# [Filling histograms](\ref filling-histograms); 91 - [Associated errors](\ref associated-errors); 92 - [Associated functions](\ref associated-functions); 93 - [Projections of histograms](\ref prof-hist); 94 - [Random Numbers and histograms](\ref random-numbers); 95 - [Making a copy of a histogram](\ref making-a-copy); 96 - [Normalizing histograms](\ref normalizing); 97-# [Drawing histograms](\ref drawing-histograms); 98 - [Setting Drawing histogram contour levels (2-D hists only)](\ref cont-level); 99 - [Setting histogram graphics attributes](\ref graph-att); 100 - [Customising how axes are drawn](\ref axis-drawing); 101-# [Fitting histograms](\ref fitting-histograms); 102-# [Saving/reading histograms to/from a ROOT file](\ref saving-histograms); 103-# [Operations on histograms](\ref operations-on-histograms); 104-# [Miscellaneous operations](\ref misc); 105 ; 106ROOT supports the following histogram types:; 107 ; 108 - 1-D histograms:; 109 - TH1C : histograms with one byte per channel. Maximum bin content = 127; 110 - TH1S : histograms with one short per channel. Maximum bin content = 32767; 111 - TH1I : histograms with one int per channel. Maximum bin content = INT_MAX (\ref intmax ""*""); 112 - TH1L : histograms with one long64 per channel. Maximum bin content = LLONG_MAX (\ref llongmax ""**"")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:2933,error,errors,2933,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['errors']
Availability,"\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");. // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMathText.html:15098,down,downharpoonleft,15098,root/html602/TMathText.html,https://root.cern,https://root.cern/root/html602/TMathText.html,4,['down'],['downharpoonleft']
Availability,"\digamma"");; y -= step ; l.DrawMathText(x1, y, ""\\div""); l.DrawText(x2, y, ""\\div"");; y -= step ; l.DrawMathText(x1, y, ""\\divideontimes""); l.DrawText(x2, y, ""\\divideontimes"");; y -= step ; l.DrawMathText(x1, y, ""\\doteq""); l.DrawText(x2, y, ""\\doteq"");; y -= step ; l.DrawMathText(x1, y, ""\\doteqdot""); l.DrawText(x2, y, ""\\doteqdot"");; y -= step ; l.DrawMathText(x1, y, ""\\dotplus""); l.DrawText(x2, y, ""\\dotplus"");; y -= step ; l.DrawMathText(x1, y, ""\\doublebarwedge""); l.DrawText(x2, y, ""\\doublebarwedge"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecap""); l.DrawText(x2, y, ""\\doublecap"");; y -= step ; l.DrawMathText(x1, y, ""\\doublecup""); l.DrawText(x2, y, ""\\doublecup"");; y -= step ; l.DrawMathText(x1, y, ""\\downarrow""); l.DrawText(x2, y, ""\\downarrow"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownarrows""); l.DrawText(x2, y, ""\\downdownarrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downdownharpoons""); l.DrawText(x2, y, ""\\downdownharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonleft""); l.DrawText(x2, y, ""\\downharpoonleft"");; y -= step ; l.DrawMathText(x1, y, ""\\downharpoonright""); l.DrawText(x2, y, ""\\downharpoonright"");; y -= step ; l.DrawMathText(x1, y, ""\\downuparrows""); l.DrawText(x2, y, ""\\downuparrows"");; y -= step ; l.DrawMathText(x1, y, ""\\downupharpoons""); l.DrawText(x2, y, ""\\downupharpoons"");; y -= step ; l.DrawMathText(x1, y, ""\\ell""); l.DrawText(x2, y, ""\\ell"");; y -= step ; l.DrawMathText(x1, y, ""\\emptyset""); l.DrawText(x2, y, ""\\emptyset"");; y -= step ; l.DrawMathText(x1, y, ""\\epsilon""); l.DrawText(x2, y, ""\\epsilon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqcirc""); l.DrawText(x2, y, ""\\eqcirc"");; ; // Draw 3rd Column; y = 0.99; step = 0.0126; x1 = 0.27; x2 = x1+0.02;; l.DrawMathText(x1, y, ""\\eqcolon""); l.DrawText(x2, y, ""\\eqcolon"");; y -= step ; l.DrawMathText(x1, y, ""\\eqsim""); l.DrawText(x2, y, ""\\eqsim"");; y -= step ; l.DrawMathText(x1, y, ""\\eqslantgtr""); l.DrawText(x2, y, ""\\eqslantgtr"");; y -= step ; l.DrawMathText(x1, y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMathText.html:15102,down,downharpoonleft,15102,root/html534/TMathText.html,https://root.cern,https://root.cern/root/html534/TMathText.html,2,['down'],['downharpoonleft']
Availability,"\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation errors, then the error definition (return value of the FCNBase::up() method, see [howto:errordef]) should be \(1.0\). If the \(\mbox{FCN}\) is a negative-log-likelihood function, then the one-standard-deviation value for FCNBase::up() to return is \(0.5\). If the \(\mbox{FCN}\) is a chisquare, but the user wants two-standard-deviation errors, then FCNBase::up() should return \(= 4.0\), etc.; Note that in the usual case where M is being used to perform a fit to some experimental data, the parameter errors will be proportional to the uncertainty in the data, and therefore meaningful parameter errors cannot be obtained unless the measurement errors of the data are known. In the common case ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14967,error,errors,14967,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,8,['error'],"['error', 'errors']"
Availability,"\n \; 1499reduction of overfitting: \n \; 1500\n \; 1501 - different training settings can be stacked. Such that the initial training \n\; 1502 is done with a large learning rate and a large drop out fraction whilst \n \; 1503 in a later stage learning rate and drop out can be reduced. \n \; 1504 - drop out \n \; 1505 [recommended: \n \; 1506 initial training stage: 0.0 for the first layer, 0.5 for later layers. \n \; 1507 later training stage: 0.1 or 0.0 for all layers \n \; 1508 final training stage: 0.0] \n \; 1509 Drop out is a technique where a at each training cycle a fraction of arbitrary \n \; 1510 nodes is disabled. This reduces co-adaptation of weights and thus reduces overfitting. \n \; 1511 - L1 and L2 regularization are available \n \; 1512 - Minibatches \n \; 1513 [recommended 10 - 150] \n \; 1514 Arbitrary mini-batch sizes can be chosen. \n \; 1515 - Multithreading \n \; 1516 [recommended: True] \n \; 1517 Multithreading can be turned on. The minibatches are distributed to the available \n \; 1518 cores. The algorithm is lock-free (\""Hogwild!\""-style) for each cycle. \n \; 1519 \n \; 1520 Options: \n \; 1521 \""Layout\"": \n \; 1522 - example: \""TANH|(N+30)*2,TANH|(N+30),LINEAR\"" \n \; 1523 - meaning: \n \; 1524 . two hidden layers (separated by \"",\"") \n \; 1525 . the activation function is TANH (other options: RELU, SOFTSIGN, LINEAR) \n \; 1526 . the activation function for the output layer is LINEAR \n \; 1527 . the first hidden layer has (N+30)*2 nodes where N is the number of input neurons \n \; 1528 . the second hidden layer has N+30 nodes, where N is the number of input neurons \n \; 1529 . the number of nodes in the output layer is determined by the number of output nodes \n \; 1530 and can therefore not be chosen freely. \n \; 1531 \n \; 1532 \""ErrorStrategy\"": \n \; 1533 - SUMOFSQUARES \n \; 1534 The error of the neural net is determined by a sum-of-squares error function \n \; 1535 For regression, this is the only possible choice. \n \; 1536 -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:55510,avail,available,55510,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['avail'],['available']
Availability,"\n"",r2);; 2601/// printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; 2602/// printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; 2603/// printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; 2604/// printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; 2605/// delete [] x;; 2606/// delete [] w;; 2607/// }; 2608/// ~~~; 2609///; 2610/// This example produces the following results:; 2611///; 2612/// ~~~ {.cpp}; 2613/// g->Integral(0,5) = 1.25331; 2614/// g->Integral(0,1000) = 1.25319; 2615/// g->IntegralFast(n,x,w,0,5) = 1.25331; 2616/// g->IntegralFast(n,x,w,0,1000) = 1.25331; 2617/// g->IntegralFast(n,x,w,0,10000) = 1.25331; 2618/// g->IntegralFast(n,x,w,0,100000)= 1.253; 2619/// ~~~; 2620 ; 2621Double_t TF1::IntegralOneDim(Double_t a, Double_t b, Double_t epsrel, Double_t epsabs, Double_t &error); 2622{; 2623 //Double_t *parameters = GetParameters();; 2624 TF1_EvalWrapper wf1(this, nullptr, fgAbsValue);; 2625 Double_t result = 0;; 2626 Int_t status = 0;; 2627 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerance();; 2628 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerance();; 2629 if (ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationOneDim::kGAUSS) {; 2630 ROOT::Math::GaussIntegrator iod(epsabs, epsrel);; 2631 iod.SetFunction(wf1);; 2632 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2633 result = iod.Integral(a, b);; 2634 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2635 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:96857,error,error,96857,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"\pm \frac{\pi}{2}\f$; 140that MINUIT prints a warning to this effect when it prints; 141the parameter values.; 142 ; 143The minimizer can become blocked at a limit, because at a limit; 144the derivative seen by the minimizer; 145\f$\partial F / \partial P_{\mathrm{int}}\f$; 146is zero no matter what the real derivative; 147\f$\partial F / \partial P_{\mathrm{ext}}\f$ is.; 148 ; 149\f[; 150\frac{\partial F}{\partial P_{\mathrm{int}}} =; 151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:7903,error,errors,7903,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['errors']
Availability,"\sqrt{(P_{\mathrm{ext}} - a + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& a - 1 + \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; Upper bound \(b\):; \[\begin{aligned}; P_{\mathrm{int}} &=& \pm\sqrt{(b - P_{\mathrm{ext}} + 1)^2 - 1} \\; P_{\mathrm{ext}} &=& b + 1 - \sqrt{P_{\mathrm{int}}^2 + 1} \end{aligned}\]; The transformation of course also affects the parameter error matrix, so M does a transformation of the error matrix (and the “parabolic” parameter errors) when there are parameter limits. Users should however realize that the transformation is only a linear approximation, and that it cannot give a meaningful result if one or more parameters is very close to a limit, where \(\partial P_{\mathrm{ext}} / \partial P_{\mathrm{int}} \approx 0\). Therefore, it is recommended that:. Limits on variable parameters should be used only when needed in order to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits should then be removed if possible, in order to perform or re-perform the error analysis without limits. Further discussion of the effects of parameter limits may be found in the last chapter.; 2.4 M strategy; At many places in the analysis of the \(\mbox{FCN}\) (the user provided function), M must decide whether to be “safe” and waste a few function calls in order to know where it is, or to be “fast” and attempt to get the requested results with the fewest possible calls at a certain risk of not obtaining the precision desired by the user. In order to allow the user to influence these decisions, there is a M class MnStrategy (see [api:strategy]) which the user can use to put different settings. In the current release, this MnStrategy can be instantiated with three different minimization quality levels for low (0), medium (1) and high (2) quality. Default settings for iteration cycles and tolerances are initialized then. The default setting is set for medium quality. Value 0 (low) indicates to M that i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:16273,error,error,16273,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['error'],['error']
Availability,"\sum w \cdot Z^2 \\; 43 W(i,j) &= \sum w \\; 44 h(i,j) &= \frac{H(i,j)}{W(i,j)} \\; 45 s(i,j) &= \sqrt{E(i,j)/W(i,j)- h(i,j)^2} \\; 46 e(i,j) &= \frac{s(i,j)}{\sqrt{W(i,j)}}; 47 \end{align}; 48 \f]; 49 The bin content is always the mean of the Z values, but errors change depending on options:; 50 \f[; 51 \begin{align}; 52 \text{GetBinContent}(i,j) &= h(i,j) \\; 53 \text{GetBinError}(i,j) &=; 54 \begin{cases}; 55 e(i,j) &\text{if option="""" (default). Error of the mean of all z values.} \\; 56 s(i,j) &\text{if option=""s"". Standard deviation of z values.} \\; 57 \begin{cases} e(j) &\text{if } h(i,j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(i,j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 58 1/\sqrt{W(i,j)} &\text{if option=""g"". Error of a weighted mean when combining measurements with variances of } w. \\; 59 \end{cases}; 60 \end{align}; 61 \f]; 62 ; 63 In the special case where s(I,J) is zero (eg, case of 1 entry only in one cell); 64 the bin error e(I,J) is computed from the average of the s(I,J) for all cells; 65 if the static function TProfile2D::Approximate has been called.; 66 This simple/crude approximation was suggested in order to keep the cell; 67 during a fit operation. But note that this approximation is not the default behaviour.; 68 ; 69 ### Creating and drawing a 2D profile; 70 ~~~~{.cpp}; 71 {; 72 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 73 auto hprof2d = new TProfile2D(""hprof2d"",""Profile of pz versus px and py"",40,-4,4,40,-4,4,0,20);; 74 Float_t px, py, pz;; 75 for ( Int_t i=0; i<25000; i++) {; 76 gRandom->Rannor(px,py);; 77 pz = px*px + py*py;; 78 hprof2d->Fill(px,py,pz,1);; 79 }; 80 hprof2d->Draw();; 81 }; 82 ~~~~; 83*/; 84 ; 85////////////////////////////////////////////////////////////////////////////////; 86/// Default constructor for Profile2D histograms.; 87 ; 88TProfile2D::TProfile2D(); 89{; 90 fTsumwz = fTsumwz2 = 0;; 91 fScaling = kFALSE;; 92 BuildOptions(0,0,"""")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:2859,error,error,2859,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability,"\text{effective entries} = \frac{(\sum w_{i})^{2}}{\sum w_{i}^{2}}; \]. The points are assigned a x value at the center of each histogram bin. The y values are \(\text{eff} = \frac{\text{pass}}{\text{total}}\) for all options except for the bayesian methods where the result depends on the chosen option.; If the denominator becomes 0 or pass > total, the corresponding bin is skipped. 2) calculating ratios of two Poisson means (option 'pois'):; The two histograms are interpreted as independent Poisson processes and the ratio ; \[; \tau = \frac{n_{1}}{n_{2}} = \frac{\varepsilon}{1 - \varepsilon}; \]. with \(\varepsilon = \frac{n_{1}}{n_{1} + n_{2}}\). The histogram 'pass' is interpreted as \(n_{1}\) and the total histogram is used for \(n_{2}\).; The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties of efficiency by a parameter transformation: ; \[; \Delta \tau_{low/up} = \frac{1}{(1 - \varepsilon)^{2}} \Delta \varepsilon_{low/up}; \]. The x errors span each histogram bin (lowedge ... lowedge+width) The y errors depend on the chosen statistic methode which can be determined by the options given below. For a detailed description of the used statistic calculations please have a look at the corresponding functions!; Options:; v : verbose mode: prints information about the number of used bins and calculated efficiencies with their errors; cl=x : determine the used confidence level (0<x<1) (default is 0.683); cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); w : Wilson interval (see TEfficiency::Wilson); n : normal approximation propagation (see TEfficiency::Normal); ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); midp : Lancaster mid-P interval (see TEfficiency::MidPInterval); b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0 (see TEfficiency::Bayesian); mode : use mode of posterior for Bayesian interval (default is mean);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphAsymmErrors.html:45145,error,errors,45145,doc/master/classTGraphAsymmErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphAsymmErrors.html,1,['error'],['errors']
Availability,"] (size_t sz, void *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClassTree.html:14778,error,error,14778,doc/master/classTClassTree.html,https://root.cern,https://root.cern/doc/master/classTClassTree.html,1,['error'],['error']
Availability,"] (size_t sz, void *vp);  ; TObject & operator= (const TObject &rhs);  TObject assignment operator. ;  ; virtual void Pop ();  Pop on object drawn in a pad to the top of the display list. ;  ; virtual Int_t Read (const char *name);  Read contents of object with specified name from the current directory. ;  ; virtual void RecursiveRemove (TObject *obj);  Recursively remove this object from a list. ;  ; void ResetBit (UInt_t f);  ; virtual void SavePrimitive (std::ostream &out, Option_t *option="""");  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SetBit (UInt_t f);  ; void SetBit (UInt_t f, Bool_t set);  Set or unset the user status bits as specified in f. ;  ; virtual void SetDrawOption (Option_t *option="""");  Set drawing option for object. ;  ; virtual void SetUniqueID (UInt_t uid);  Set the unique object id. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void SysError (const char *method, const char *msgfmt,...) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSpline1.html:9220,error,error,9220,doc/master/classTMVA_1_1TSpline1.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSpline1.html,3,['error'],['error']
Availability,"] * fM[kYX]) * det;; 855 T detzz = (fM[kXX] * fM[kYY] - fM[kXY] * fM[kYX]) * det;; 856 // Set det=0 cases to 0; 857 if (any_of(detZmask)) {; 858 detxx(detZmask) = T(0);; 859 detxy(detZmask) = T(0);; 860 detxz(detZmask) = T(0);; 861 detyx(detZmask) = T(0);; 862 detyy(detZmask) = T(0);; 863 detyz(detZmask) = T(0);; 864 detzx(detZmask) = T(0);; 865 detzy(detZmask) = T(0);; 866 detzz(detZmask) = T(0);; 867 }; 868 // set final components; 869 SetComponents(detxx, -detyx, detzx, -detxx * fM[kDX] + detyx * fM[kDY] - detzx * fM[kDZ], -detxy, detyy, -detzy,; 870 detxy * fM[kDX] - detyy * fM[kDY] + detzy * fM[kDZ], detxz, -detyz, detzz,; 871 -detxz * fM[kDX] + detyz * fM[kDY] - detzz * fM[kDZ]);; 872 }; 873 ; 874 /**; 875 Return the inverse of the transformation.; 876 */; 877 Transform3D<T> Inverse() const; 878 {; 879 Transform3D<T> t(*this);; 880 t.Invert();; 881 return t;; 882 }; 883 ; 884 /**; 885 Equality operator. Check equality for each element; 886 To do: use T tolerance; 887 */; 888 bool operator==(const Transform3D<T> &rhs) const; 889 {; 890 return (fM[0] == rhs.fM[0] && fM[1] == rhs.fM[1] && fM[2] == rhs.fM[2] && fM[3] == rhs.fM[3] &&; 891 fM[4] == rhs.fM[4] && fM[5] == rhs.fM[5] && fM[6] == rhs.fM[6] && fM[7] == rhs.fM[7] &&; 892 fM[8] == rhs.fM[8] && fM[9] == rhs.fM[9] && fM[10] == rhs.fM[10] && fM[11] == rhs.fM[11]);; 893 }; 894 ; 895 /**; 896 Inequality operator. Check equality for each element; 897 To do: use T tolerance; 898 */; 899 bool operator!=(const Transform3D<T> &rhs) const { return !operator==(rhs); }; 900 ; 901protected:; 902 ; 903 /**; 904 make transformation from first a rotation then a translation; 905 */; 906 void AssignFrom(const Rotation3D &r, const Vector &v); 907 {; 908 // assignment from rotation + translation; 909 ; 910 T rotData[9];; 911 r.GetComponents(rotData, rotData + 9);; 912 // first raw; 913 for (int i = 0; i < 3; ++i) fM[i] = rotData[i];; 914 // second raw; 915 for (int i = 0; i < 3; ++i) fM[kYX + i] = rotData[3 + i];; 916 // third ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:30877,toler,tolerance,30877,doc/master/GenVector_2Transform3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html,1,['toler'],['tolerance']
Availability,"] + detzy * fM[kDZ], detxz, -detyz, detzz,; 871 -detxz * fM[kDX] + detyz * fM[kDY] - detzz * fM[kDZ]);; 872 }; 873 ; 874 /**; 875 Return the inverse of the transformation.; 876 */; 877 Transform3D<T> Inverse() const; 878 {; 879 Transform3D<T> t(*this);; 880 t.Invert();; 881 return t;; 882 }; 883 ; 884 /**; 885 Equality operator. Check equality for each element; 886 To do: use T tolerance; 887 */; 888 bool operator==(const Transform3D<T> &rhs) const; 889 {; 890 return (fM[0] == rhs.fM[0] && fM[1] == rhs.fM[1] && fM[2] == rhs.fM[2] && fM[3] == rhs.fM[3] &&; 891 fM[4] == rhs.fM[4] && fM[5] == rhs.fM[5] && fM[6] == rhs.fM[6] && fM[7] == rhs.fM[7] &&; 892 fM[8] == rhs.fM[8] && fM[9] == rhs.fM[9] && fM[10] == rhs.fM[10] && fM[11] == rhs.fM[11]);; 893 }; 894 ; 895 /**; 896 Inequality operator. Check equality for each element; 897 To do: use T tolerance; 898 */; 899 bool operator!=(const Transform3D<T> &rhs) const { return !operator==(rhs); }; 900 ; 901protected:; 902 ; 903 /**; 904 make transformation from first a rotation then a translation; 905 */; 906 void AssignFrom(const Rotation3D &r, const Vector &v); 907 {; 908 // assignment from rotation + translation; 909 ; 910 T rotData[9];; 911 r.GetComponents(rotData, rotData + 9);; 912 // first raw; 913 for (int i = 0; i < 3; ++i) fM[i] = rotData[i];; 914 // second raw; 915 for (int i = 0; i < 3; ++i) fM[kYX + i] = rotData[3 + i];; 916 // third raw; 917 for (int i = 0; i < 3; ++i) fM[kZX + i] = rotData[6 + i];; 918 ; 919 // translation data; 920 T vecData[3];; 921 v.GetCoordinates(vecData, vecData + 3);; 922 fM[kDX] = vecData[0];; 923 fM[kDY] = vecData[1];; 924 fM[kDZ] = vecData[2];; 925 }; 926 ; 927 /**; 928 make transformation from only rotations (zero translation); 929 */; 930 void AssignFrom(const Rotation3D &r); 931 {; 932 // assign from only a rotation (null translation); 933 T rotData[9];; 934 r.GetComponents(rotData, rotData + 9);; 935 for (int i = 0; i < 3; ++i) {; 936 for (int j = 0; j < 3; ++j) fM[4 * i + j] = rotDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html:31344,toler,tolerance,31344,doc/master/GenVector_2Transform3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2Transform3D_8h_source.html,1,['toler'],['tolerance']
Availability,"] - 6.22 PyROOT seg faults when accessing array members; [#6675] - Jitted RDataFrame.Histo1D broken for vector<bool> types; [#6465] - ROOT signed-char conversion issue on AARCH64; [#6666] - TClass::GetListOfDataMembers returns an empty list even-though the information is available.; [#6725] - rootpcm does not record TEnum’s underlying type; [#6726] - TStreamerInfo::GenerateInfoForPair generates the wrong offset if an enum type is first.; [#6670] - segfault in TClass::InheritsFrom() depending on linking order; [#6443] - Spurrious auto-parsing (as seen with CMS file and libraries); [#6509] - [ROOT I/O] Warning: writing 1 byte into a region of size 0; [#6597] - pytest shipped in roottest is not compatible with py3.9; [#6677] - [bug] Clang builds ROOT libraries that emit FPEs; [#6784] - external nlohmann/json.hpp is not forwarded as dependency or should be linked PRIVATE?; [#6523] - TBufferMerger cannot handle TTree spanning over multiple files; [#6743] - ROOT crashes with no helpful error messages if a TApplication is not present and tree->StartViewer() is called; [#6840] - TClass for pair sometimes have the wrong offset/size; [#6839] - Compilation fails on macosx 11.0 with arm processor; [#6838] - build/unix/compiledata.sh assumes macOS will always have major version 10; [#6817] - macOS packaging broken in master; [#6856] - error when creating a python class inheriting from a ROOT class, 6.22/02; [#6797] - TCling::UpdateListOfLoadedSharedLibraries() Linux thread safety; [#6483] - [GUI] Crashes when creating TGClient in a standalone application; [#6563] - Test failures on MacOS with Xcode 12; [#6624] - TRandom: signature mismatch between getter and setter; [#6815] - PowerShell version of thisroot.bat; [#6853] - [DF] SaveGraph can be confused by shared upstream Defines; [#6731] - Compilation error on CentOS 7 of root V6.22.02 c++17; [#6974] - pyROOT doesn’t work with ipyparallel; [#6964] - [TTree] GetLeaf ignores the branchname arg if friend trees are present; [#6944] -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:41593,error,error,41593,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['error'],['error']
Availability,"] - BUG (See description note) PyDoubleBuffer tolist and numpy array cause segfault.; [ROOT-9313] - Crash in TFile::Close on Fedora, ROOT v6.10; [ROOT-9320] - Make GenVector data structures constexpr; [ROOT-9321] - Dictionary generation: type normalization issue in pcm file; [ROOT-9448] - libNew returns nullptr instead of implementing operator new, has many warnings; [ROOT-9983] - [DOC] hadd –help does not show description and epilogue; [ROOT-10033] - ROOT::EnableImplicitMT: Number of threads in scheduling environments; [ROOT-10231] - TMatrixD(a,TMatrixD::kInvMult,b) requires b.GetNcols() = a.GetNcols(); [ROOT-10320] - ROOT/meta does not support anonymous unions/structs; [ROOT-10425] - Missing symbols not reported as missing anymore; [ROOT-10546] - RDataFrame cannot be interrupted from PyROOT; [ROOT-10593] - Segmentation fault when calling a not-yet-defined function from ROOT interpreter; [ROOT-10607] - Several ROOT 7 tests fail when assertions are enabled; [ROOT-10613] - Configuration does not fail when fail-on-missing is ON and cudnn is not found; [ROOT-10621] - Segfault if TFile is used with TRint in teardown; [ROOT-10705] - The “x” and “x0” options in THnBase::PrintEntries misbehave; [ROOT-10789] - some cppyy examples do not work under ROOT; [ROOT-10827] - Missing contribution of extended term in the error Correction for extended weighted likelihood fits; [ROOT-10859] - std.make_shared[T] does not work on macOS; [ROOT-10866] - Numerical instabilities when calculating the derivatives for the asymptotically correct erros; [ROOT-10958] - jupyter notebook does not render geometries with new pyroot; [ROOT-10977] - Exit code 0 with failing C++ notebook in nbconvert; [ROOT-11006] - [TTreeReader] Crash when reading array branch. Release 6.32.02; Published on June 18, 2024; Items addressed in this release. [#7236] - Memory leak in TFile::WriteObjectAny, depending on data type; [#10075] - Difficult to configure Xrootd to use non-builtin openssl; [#14051] - [web graphics] W",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:41509,fault,fault,41509,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,2,"['error', 'fault']","['error', 'fault']"
Availability,"] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double y1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; TGraphErrors *graph1 = new TGraphErrors(5, x, y1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. TGraphErrors *graph1_sys = new TGraphErrors(5, x, y1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; TGraphErrors *graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. TGraphErrors *graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; return c43;; }; TGraphAsymmErrors; A TGraphAsymmErrors is like a TGraphErrors but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; TGraphAsymmErrors* gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; return c2;; }; TGraphBentErrors; A TGraphBentErrors is like a TGraphAsymmErrors.; An extra parameter allows to bent the error bars to better see them; when several graphs ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:9223,error,errors,9223,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['errors']
Availability,"] = {1, 2, 3, 4, 5};; double zero[5] = {0, 0, 0, 0, 0};. // data set (1) with stat and sys errors; double y1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};. // data set (2) with stat and sys errors; double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};. // Now draw data set (1). // We first have to draw it only with the stat errors; TGraphErrors *graph1 = new TGraphErrors(5, x, y1, zero, ey_stat1);; graph1->SetMarkerStyle(20);; graph1->Draw(""P"");. // Now we have to somehow depict the sys errors. TGraphErrors *graph1_sys = new TGraphErrors(5, x, y1, zero, ey_sys1);; graph1_sys->Draw(""[]"");. // Now draw data set (2). // We first have to draw it only with the stat errors; TGraphErrors *graph2 = new TGraphErrors(5, x, y2, zero, ey_stat2);; graph2->SetMarkerStyle(24);; graph2->Draw(""P"");. // Now we have to somehow depict the sys errors. TGraphErrors *graph2_sys = new TGraphErrors(5, x, y2, zero, ey_sys2);; graph2_sys->Draw(""[]"");; return c43;; }; TGraphAsymmErrors; A TGraphAsymmErrors is like a TGraphErrors but the errors; defined along X and Y are not symmetric: The left and right errors are; different along X and the bottom and up errors are different along Y. Picture; Source. {; TCanvas *c44 = new TCanvas(""c44"",""c44"",200,10,600,400);; double ax[] = {0, 1, 2, 3, 4};; double ay[] = {0, 2, 4, 1, 3};; double aexl[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double aexh[] = {0.5, 0.4, 0.3, 0.2, 0.1};; double aeyl[] = {1, 0.5, 1, 0.5, 1};; double aeyh[] = {0.5, 1, 0.5, 1, 0.5};; TGraphAsymmErrors* gae = new TGraphAsymmErrors(5, ax, ay, aexl, aexh, aeyl, aeyh);; gae->SetFillColor(2);; gae->SetFillStyle(3001);; gae->Draw(""a2"");; gae->Draw(""p"");; return c44;; }; TGraphBentErrors; A TGraphBentErrors is like a TGraphAsymmErrors.; An extra parameter allows to bent the error bars to better see them; when several gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphPainter.html:9468,error,errors,9468,root/html530/TGraphPainter.html,https://root.cern,https://root.cern/root/html530/TGraphPainter.html,3,['error'],['errors']
Availability,"] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};; 403 Double_t exl[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; 404 Double_t eyl[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};; 405 Double_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; 406 Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; 407 Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 408 Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; 409 Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; 410 Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; 411 auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; 412 gr->SetTitle(""A graph with bend errors"");; 413 gr->SetMarkerColor(4);; 414 gr->SetMarkerStyle(21);; 415 gr->Draw(""ALP"");; 416}; 417End_Macro; 418 ; 419 ; 420\anchor GrP3d; 421#### TGraphMultiErrors; 422A `TGraphMultiErrors` works basically the same way like a `TGraphAsymmErrors`.; 423It has the possibility to define more than one type / dimension of y-Errors.; 424This is useful if you want to plot statistic and systematic errors at once.; 425 ; 426To be able to define different drawing options for the multiple error dimensions; 427the option string can consist of multiple blocks separated by semicolons.; 428The painting method assigns these blocks to the error dimensions. The first block; 429is always used for the general draw options and options concerning the x-Errors.; 430In case there are less than NErrorDimensions + 1 blocks in the option string; 431the first block is also used for the first error dimension which is reserved for; 432statistical errors. The remaining blocks are assigned to the remaining dimensions.; 433 ; 434In addition to the draw options of options of `TGraphAsymmErrors` the following are possible:; 435 ; 436| Option | Block | Description |; 437|----------|----------------|-------------------------------------------------------------------|; 438| ""X0"" | First one only | Do not draw errors for points with x = 0 |; 439| ""Y0"" | First one only | Do not draw er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:16317,error,errors,16317,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['error'],['errors']
Availability,] PROGRESS:Generation -- RooMCStudy::run: sample 800; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 790; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 780; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 770; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 760; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-915.472) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.807508 a1=-0.34963 mean=5.09438 nbkg=142.436 nsig=172.312 sig1frac=0.886183; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 750; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-885.867) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.7962 a1=-0.414289 mean=5.07605 nbkg=135.514 nsig=167.164 sig1frac=0.927781; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-848.597) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.577138 a1=-0.518554 mean=5.09299 nbkg=144.203 nsig=156.938 sig1frac=0.54541; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 740; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 730; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 720; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 710; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 700; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-814.549) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.848973 a1=-0.489149 mean=5.08811 nbkg=132.911 nsig=150.647 sig1frac=0.826731; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:14289,error,errors,14289,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,4,['error'],"['error', 'errors']"
Availability,"] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TNetXNGSystem*fSystemUsed to access filesystem interface. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNetXNGFileStager(const char* url = """"); Constructor. param url: the URL of the entry-point server. ~TNetXNGFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if a file is staged. param path: the URL of the file. Int_t Locate(const char* path, TString& endpath); Get actual endpoint URL. param path: the entry-point URL; param endpath: the actual endpoint URL; returns: 0 in the case of success and 1 if any error occurred. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. param fc: collection of files to be located; param addDummyUrl: append a dummy noop URL if the file is not staged or; redirector == endpoint; returns: < 0 in case of errors, number of files processed; otherwise. Bool_t Matches(const char* s); Returns kTRUE if stager 's' is compatible with current stager. Avoids; multiple instantiations of the potentially the same TNetXNGFileStager. Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for a single file. param path: the path of the file to stage; param opt: defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue stage requests for multiple files. param pathlist: list of paths of files to stage; param opt: defines 'option' and 'priority' for 'Prepare': the; format is opt = ""option=o priority=p"". UChar_t ParseStagePriority(Option_t* opt); Get a staging priority value from an option string. TNetXNGFileStager(const char* url = """"). Bool_t IsValid() const; { return (fSystem ? kTRUE : kFALSE); }. » Last changed: root/netxng:$Id$ » ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFileStager.html:7125,error,errors,7125,root/html534/TNetXNGFileStager.html,https://root.cern,https://root.cern/root/html534/TNetXNGFileStager.html,2,['error'],['errors']
Availability,"] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. boolfAdaptiveSamplingcontrols use of adaptive sampling algorithm; RooStats::ConfidenceBelt*fConfBelt; boolfCreateBeltcontrols use if ConfidenceBelt should be saved to a TFile; RooAbsData*fDatadata set ; Bool_tfDoProfileConstructioninstead of full construction over nuisance parametrs, do profile; Bool_tfFluctuateDatatell ToyMCSampler to fluctuate number of entries in dataset; Int_tfNbinsnumber of samples per variable; RooArgSetfNuisParamsRooArgSet specifying nuisance parameters for interval; RooArgSetfPOIRooArgSet specifying parameters of interest for interval; RooAbsPdf*fPdfcommon PDF; RooAbsData*fPointsToTestpoints to perform the construction; boolfSaveBeltToFilecontrols use if ConfidenceBelt should be saved to a TFile; Double_tfSizesize of the test (eg. specified rate of Type I error); RooStats::ToyMCSampler*fTestStatSamplerthe test statistic sampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FeldmanCousins(); default constructor; fWS = new RooWorkspace(""FeldmanCousinsWS"");; fOwnsWorkspace = true;; fDataName = """";; fPdfName = """";. ~FeldmanCousins(); destructor; if(fOwnsWorkspace && fWS) delete fWS;. void SetModel(const RooStats::ModelConfig& ); set the model. void CreateTestStatSampler() const; specify the Test Statistic and create a ToyMC test statistic sampler. void CreateParameterPoints() const; specify the parameter points to perform the construction.; allow ability to profile on some nuisance paramters. ConfInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a RooStats::PointSetInterval. FeldmanCousins(). Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__FeldmanCousins.html:8390,error,error,8390,root/html526/RooStats__FeldmanCousins.html,https://root.cern,https://root.cern/root/html526/RooStats__FeldmanCousins.html,1,['error'],['error']
Availability,"]*t)"");; 206 tf.SetParameter(0, 1);; 207 tf.SetParameter(1, 0.5);; 208 ; 209 for (auto & event : events) {; 210 tf.Eval(event.t);; 211 }; 212 ```; 213 ; 214 The distinction between variables and parameters arose from the TFormula's; 215 application in fitting. There parameters are fitted to the data provided; 216 through variables. In other applications this distinction can go away.; 217 ; 218 Parameter values can be provided dynamically using `TFormula::EvalPar`; 219 instead of `TFormula::Eval`. In this way parameters can be used identically; 220 to variables. See below for an example that uses only parameters to model a; 221 function.; 222 ; 223 ```; 224 Int_t params[2] = {1, 2}; // {vel_x, vel_y}; 225 TFormula tf ("""", ""[vel_x]/sqrt(([vel_x + vel_y])**2)"");; 226 ; 227 tf.EvalPar(nullptr, params);; 228 ```; 229 ; 230 ### A note on operators; 231 ; 232 All operators of C/C++ are allowed in a TFormula with a few caveats.; 233 ; 234 The operators `|`, `&`, `%` can be used but will raise an error if used in; 235 conjunction with a variable or a parameter. Variables and parameters are treated; 236 as doubles internally for which these operators are not defined.; 237 This means the following command will run successfully; 238 ```root -l -q -e TFormula("""", ""x+(10%3)"").Eval(0)```; 239 but not; 240 ```root -l -q -e TFormula("""", ""x%10"").Eval(0)```.; 241 ; 242 The operator `^` is defined to mean exponentiation instead of the C/C++; 243 interpretation xor. `**` is added, also meaning exponentiation.; 244 ; 245 The operators `++` and `@` are added, and are shorthand for the a linear; 246 function. That means the expression `x@2` will be expanded to; 247 ```[n]*x + [n+1]*2``` where n is the first previously unused parameter number.; 248 ; 249 \class TFormulaFunction; 250 Helper class for TFormula; 251 ; 252 \class TFormulaVariable; 253 Another helper class for TFormula; 254 ; 255 \class TFormulaParamOrder; 256 Functor defining the parameter order; 257*/; 258 ; 259// prefix used f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:9047,error,error,9047,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['error'],['error']
Availability,"]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:8286,error,errors,8286,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If option contains ""y"" the y values and errors are scaled; 319/// If option contains ""z"" the z values and errors are scaled; 320/// If option contains ""xyz"" all three x, y and z values and errors are scaled; 321 ; 322void TGraph2DErrors::Scale(Double_t c1, Option_t *option); 323{; 324 TGraph2D::Scale(c1, option);; 325 TStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:8928,error,errors,8928,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"], &fEXlow[ibegin], n);; 328 memmove(&fEXhigh[obegin], &fEXhigh[ibegin], n);; 329 memmove(&fEYlow[obegin], &fEYlow[ibegin], n);; 330 memmove(&fEYhigh[obegin], &fEYhigh[ibegin], n);; 331 memmove(&fEXlowd[obegin], &fEXlowd[ibegin], n);; 332 memmove(&fEXhighd[obegin], &fEXhighd[ibegin], n);; 333 memmove(&fEYlowd[obegin], &fEYlowd[ibegin], n);; 334 memmove(&fEYhighd[obegin], &fEYhighd[ibegin], n);; 335 }; 336 return kTRUE;; 337 } else {; 338 return kFALSE;; 339 }; 340}; 341 ; 342 ; 343////////////////////////////////////////////////////////////////////////////////; 344/// Should be called from ctors after `fNpoints` has been set.; 345 ; 346Bool_t TGraphBentErrors::CtorAllocate(); 347{; 348 if (!fNpoints) {; 349 fEXlow = fEYlow = fEXhigh = fEYhigh = nullptr;; 350 fEXlowd = fEYlowd = fEXhighd = fEYhighd = nullptr;; 351 return kFALSE;; 352 }; 353 fEXlow = new Double_t[fMaxSize];; 354 fEYlow = new Double_t[fMaxSize];; 355 fEXhigh = new Double_t[fMaxSize];; 356 fEYhigh = new Double_t[fMaxSize];; 357 fEXlowd = new Double_t[fMaxSize];; 358 fEYlowd = new Double_t[fMaxSize];; 359 fEXhighd = new Double_t[fMaxSize];; 360 fEYhighd = new Double_t[fMaxSize];; 361 return kTRUE;; 362}; 363 ; 364////////////////////////////////////////////////////////////////////////////////; 365/// Protected function to perform the merge operation of a graph with asymmetric errors.; 366 ; 367Bool_t TGraphBentErrors::DoMerge(const TGraph *g); 368{; 369 if (g->GetN() == 0) return kFALSE;; 370 ; 371 Double_t *exl = g->GetEXlow();; 372 Double_t *exh = g->GetEXhigh();; 373 Double_t *eyl = g->GetEYlow();; 374 Double_t *eyh = g->GetEYhigh();; 375 ; 376 Double_t *exld = g->GetEXlowd();; 377 Double_t *exhd = g->GetEXhighd();; 378 Double_t *eyld = g->GetEYlowd();; 379 Double_t *eyhd = g->GetEYhighd();; 380 ; 381 if (!exl || !exh || !eyl || !eyh ||; 382 !exld || !exhd || !eyld || !eyhd) {; 383 if (g->IsA() != TGraph::Class() ); 384 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphBentErrors - error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:12157,error,errors,12157,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errors']
Availability,"],[ay,by]. ;  ; TF2 & operator= (const TF2 &rhs);  Operator =. ;  ; virtual void SetContour (Int_t nlevels=20, const Double_t *levels=nullptr);  Set the number and values of contour levels. ;  ; virtual void SetContourLevel (Int_t level, Double_t value);  Set value for one contour level. ;  ; virtual void SetNpy (Int_t npy=100);  Set the number of points used to draw the function. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Double_t Variance2X (Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon=0.000001);  ; virtual Double_t Variance2Y (Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon=0.000001);  ;  Public Member Functions inherited from TF1;  TF1 ();  TF1 default constructor. ;  ;  TF1 (const char *name, const char *formula, Double_t xmin, Double_t xmax, Option_t *option);  Same constructor as above (for TFormula based function) but passing an option strings available options VEC - vectorize the formula expressions (not possible for lambda based expressions) NL - function is not stores in the global list of functions GL - function will be always stored in the global list of functions , independently of the global setting of TF1::DefaultAddToGlobalList. ;  ;  TF1 (const char *name, const char *formula, Double_t xmin=0, Double_t xmax=1, EAddToList addToGlobList=EAddToList::kDefault, bool vectorize=false);  TF1 constructor using a formula definition. ;  ; template<class PtrObj , typename MemFn > ;  TF1 (const char *name, const PtrObj &p, MemFn memFn, Double_t xmin, Double_t xmax, Int_t npar, const char *, const char *, EAddToList addToGlobList=EAddToList::kDefault);  ; template<class PtrObj , typename MemFn > ;  TF1 (const char *name, const PtrObj &p, MemFn memFn, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault);  ;  TF1 (const char *name, Double_t xmin, Double_t xmax, Int_t npar, Int_t ndim=1, EAddToList addToGlobList=EAddToList::kDefault);  F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF3.html:14495,avail,available,14495,doc/master/classTF3.html,https://root.cern,https://root.cern/doc/master/classTF3.html,1,['avail'],['available']
Availability,"]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 302 ; 303 ; 304////////////////////////////////////////////////////////////////////////////////; 305/// Print 2D graph and errors values.; 306 ; 307void TGraph2DErrors::Print(Option_t *) const; 308{; 309 for (Int_t i = 0; i < fNpoints; i++) {; 310 printf(""x[%d]=%g, y[%d]=%g, z[%d]=%g, ex[%d]=%g, ey[%d]=%g, ez[%d]=%g\n"", i, fX[i], i, fY[i], i, fZ[i], i, fEX[i], i, fEY[i], i, fEZ[i]);; 311 }; 312}; 313 ; 314////////////////////////////////////////////////////////////////////////////////; 315/// Multiply the values and errors of a TGraph2DErrors by a constant c1.; 316///; 317/// If option contains ""x"" the x values and errors are scaled; 318/// If",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:8611,error,errors,8611,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"]. TEveMacro::TEveMacro ; (; const TEveMacro & ; m). Definition at line 34 of file TEveMacro.cxx. ◆ TEveMacro() [3/3]. TEveMacro::TEveMacro ; (; const char * ; name). Definition at line 39 of file TEveMacro.cxx. ◆ ~TEveMacro(). TEveMacro::~TEveMacro ; (; ). inlineoverride . Definition at line 27 of file TEveMacro.h. Member Function Documentation. ◆ Class(). static TClass * TEveMacro::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveMacro::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveMacro::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 33 of file TEveMacro.h. ◆ DeclFileName(). static const char * TEveMacro::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 33 of file TEveMacro.h. ◆ Exec(). Longptr_t TEveMacro::Exec ; (; const char * ; params = ""0"", . Int_t * ; error = nullptr . ). overridevirtual . Execute the macro. ; Reimplemented from TMacro.; Definition at line 62 of file TEveMacro.cxx. ◆ IsA(). TClass * TEveMacro::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 33 of file TEveMacro.h. ◆ ResetRoot(). void TEveMacro::ResetRoot ; (; ). Call gROOT->Reset() via interpreter. ; Definition at line 118 of file TEveMacro.cxx. ◆ Streamer(). void TEveMacro::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEveMacro::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 33 of file TEveMacro.h. Libraries for TEveMacro:. [legend]; The documentation for this class was generated from the following files:; graf3d/eve/inc/TEveMacro.h; graf3d/eve/src/TEveMacro.cxx. TEveMacro. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:39 (GVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveMacro.html:14506,error,error,14506,doc/master/classTEveMacro.html,https://root.cern,https://root.cern/doc/master/classTEveMacro.html,1,['error'],['error']
Availability,"]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::initializer_list< std::string > ; colNames, . F && ; expression, . const ColumnNames_t & ; inputColumns, . const std::vector< std::string > & ; variationTags, . std::string_view ; variationName . ). inline . Register systematic variations for multiple existing columns using custom variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]variationTagsnames for each of the varied values, e.g. ""up"" and ""down"". ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". colName is used if none is provided. NoteThis overload ensures that the ambiguity between C++20 string, vector<string> construction from init list is avoided.; See alsoThis Vary() overload for more information. ; Definition at line 972 of file RInterface.hxx. ◆ Vary() [6/11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::initializer_list< std::string > ; colNames, . F && ; expression, . const ColumnNames_t & ; inputColumns, . std::size_t ; nVariations, . std::string_view ; variationName . ). inline . Register systematic variations for for multiple existing columns using custom variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:145046,down,down,145046,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['down'],['down']
Availability,"]; where \(m\) is the quantity of parameters. Expanding left part of this equation over parameter increments and retaining only linear terms one gets; \[; \left(\frac{\partial \chi^{2}}{\theta_{i}}\right); _{\theta = \vec{\theta}^{0}} +; \sum_{k}; \left(\frac{\partial^{2} \chi^{2}}{\partial \theta_{i}; \partial \theta_{k}}\right); _{\theta = \vec{\theta}^{0}} . (\theta_{k} - \theta_{k}^{0}) = 0; \]; here \(\vec{\theta}^{0}\) is some initial value of parameters. In general case:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}; {\frac{\partial f_j}{\theta_i}} {\frac{\partial f_j}{\theta_k}} +; \sum^n_{j=1}{\frac{(f_j - F_j)}{\sigma^2_j}}\cdot; {\frac{\partial^2f_j}{\partial\theta_i\partial\theta_k}}; \]; In FUMILI algorithm for second derivatives of Chi-square approximate expression is used when last term in previous equation is discarded. It is often done, not always wittingly, and sometimes causes troubles, for example, if user wants to limit parameters with positive values by writing down \(\theta_i^2\) instead of \(\theta_i\). FUMILI will fail if one tries minimize \(\chi^2 = g^2(\vec\theta)\) where g is arbitrary function.; Approximate value is:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; \]; Then the equations for parameter increments are:; \[; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; \]; Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are qu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:228978,down,down,228978,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['down'],['down']
Availability,"];; 1143 if (fEYhigh) ehigh = fEYhigh[i];; 1144 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 1145}; 1146 ; 1147 ; 1148////////////////////////////////////////////////////////////////////////////////; 1149/// Get high error on X.; 1150 ; 1151Double_t TGraphAsymmErrors::GetErrorXhigh(Int_t i) const; 1152{; 1153 if (i<0 || i>fNpoints) return -1;; 1154 if (fEXhigh) return fEXhigh[i];; 1155 return -1;; 1156}; 1157 ; 1158 ; 1159////////////////////////////////////////////////////////////////////////////////; 1160/// Get low error on X.; 1161 ; 1162Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:40867,error,error,40867,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['error']
Availability,"];; 220 else; 221 fExH[i] = 0.;; 222 ; 223 for (Int_t j = 0; j < fNYErrors; j++) {; 224 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 225 fEyL[j][i] = eyL[j][i];; 226 else; 227 fEyL[j][i] = 0.;; 228 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 229 fEyH[j][i] = eyH[j][i];; 230 else; 231 fEyH[j][i] = 0.;; 232 }; 233 }; 234 ; 235 CalcYErrorsSum();; 236}; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors.; 258 ; 259TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, Int_t m); 262 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:9188,error,errors,9188,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"];; 2442 r = TMath::Sqrt(c*c + 1);; 2443 work[n + j] = s*work[n + i]*r;; 2444 s = 1 / r;; 2445 c /= r;; 2446 goto L190;; 2447L180:; 2448 c = work[n + i] / pt;; 2449 r = TMath::Sqrt(c*c + 1);; 2450 work[n + j] = s*pt*r;; 2451 s = c / r;; 2452 c = 1 / r;; 2453L190:; 2454 pt = c*work[i] - s*gl;; 2455 work[j] = h + s*(c*gl + s*work[i]);; 2456 for (k = 1; k <= n; ++k) {; 2457 h = a[k + j*ndima];; 2458 a[k + j*ndima] = s*a[k + i*ndima] + c*h;; 2459 a[k + i*ndima] = c*a[k + i*ndima] - s*h;; 2460 }; 2461 }; 2462 work[n + l] = s*pt;; 2463 work[l] = c*pt;; 2464 ; 2465 if (TMath::Abs(work[n + l]) > b) goto L160;; 2466 ; 2467L205:; 2468 work[l] += f;; 2469 }; 2470 for (i = 1; i <= n1; ++i) {; 2471 k = i;; 2472 pt = work[i];; 2473 i1 = i + 1;; 2474 for (j = i1; j <= n; ++j) {; 2475 if (work[j] >= pt) continue;; 2476 k = j;; 2477 pt = work[j];; 2478 }; 2479 ; 2480 if (k == i) continue;; 2481 ; 2482 work[k] = work[i];; 2483 work[i] = pt;; 2484 for (j = 1; j <= n; ++j) {; 2485 pt = a[j + i*ndima];; 2486 a[j + i*ndima] = a[j + k*ndima];; 2487 a[j + k*ndima] = pt;; 2488 }; 2489 }; 2490 ifault = 0;; 2491}; 2492 ; 2493////////////////////////////////////////////////////////////////////////////////; 2494/// Calculates the external error matrix from the internal matrix; 2495///; 2496/// Note that if the matrix is declared like Double_t matrix[5][5]; 2497/// in the calling program, one has to call mnemat with, eg; 2498///; 2499/// gMinuit->mnemat(&matrix[0][0],5);; 2500 ; 2501void TMinuit::mnemat(Double_t *emat, Int_t ndim); 2502{; 2503 /* System generated locals */; 2504 Int_t emat_dim1, emat_offset;; 2505 ; 2506 /* Local variables */; 2507 Double_t dxdi, dxdj;; 2508 Int_t i, j, k, npard, k2, kk, iz, nperln, kga, kgb;; 2509 TString ctemp;; 2510 ; 2511 /* Parameter adjustments */; 2512 emat_dim1 = ndim;; 2513 emat_offset = emat_dim1 + 1;; 2514 emat -= emat_offset;; 2515 ; 2516 /* Function Body */; 2517 if (fISW[1] < 1) return;; 2518 if (fISW[4] >= 2) {; 2519 Printf("" EXTERNAL ERROR MATRIX.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:81615,error,error,81615,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['error']
Availability,"];; 288 }; 289 ; 290 if (NULL != fCutMin) delete [] fCutMin;; 291 if (NULL != fCutMax) delete [] fCutMax;; 292 ; 293 if (NULL != fTmpCutMin) delete [] fTmpCutMin;; 294 if (NULL != fTmpCutMax) delete [] fTmpCutMax;; 295 ; 296 if (NULL != fBinaryTreeS) delete fBinaryTreeS;; 297 if (NULL != fBinaryTreeB) delete fBinaryTreeB;; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// define the options (their key words) that can be set in the option string.; 302///; 303/// know options:; 304/// - Method `<string>` Minimisation method. Available values are:; 305/// - MC Monte Carlo `<default>`; 306/// - GA Genetic Algorithm; 307/// - SA Simulated annealing; 308///; 309/// - EffMethod `<string>` Efficiency selection method. Available values are:; 310/// - EffSel `<default>`; 311/// - EffPDF; 312///; 313/// - VarProp `<string>` Property of variable 1 for the MC method (taking precedence over the; 314/// globale setting. The same values as for the global option are available. Variables 1..10 can be; 315/// set this way; 316///; 317/// - CutRangeMin/Max `<float>` user-defined ranges in which cuts are varied; 318 ; 319void TMVA::MethodCuts::DeclareOptions(); 320{; 321 DeclareOptionRef(fFitMethodS = ""GA"", ""FitMethod"", ""Minimisation Method (GA, SA, and MC are the primary methods to be used; the others have been introduced for testing purposes and are depreciated)"");; 322 AddPreDefVal(TString(""GA""));; 323 AddPreDefVal(TString(""SA""));; 324 AddPreDefVal(TString(""MC""));; 325 AddPreDefVal(TString(""MCEvents""));; 326 AddPreDefVal(TString(""MINUIT""));; 327 AddPreDefVal(TString(""EventScan""));; 328 ; 329 // selection type; 330 DeclareOptionRef(fEffMethodS = ""EffSel"", ""EffMethod"", ""Selection Method"");; 331 AddPreDefVal(TString(""EffSel""));; 332 AddPreDefVal(TString(""EffPDF""));; 333 ; 334 // cut ranges; 335 fCutRange.resize(GetNvar());; 336 fCutRangeMin = new Double_t[GetNvar()];; 337 fCutRangeMax = new Double_t[GetNvar()];; 338 for (UInt_t ivar=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:10847,avail,available,10847,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['avail'],['available']
Availability,"];; 3515 if (evalErrorList.second.size() >= 2048) {; 3516 // avoid overflowing the error list, so if there are very many, print; 3517 // the oldest one first, and pop it off the list; 3518 const EvalError& oee = evalErrorList.second.front();; 3519 // print to debug stream, since these would normally be suppressed, and; 3520 // we do not want to increase the error count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565//////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151384,error,error,151384,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,"]]; });; 682 std::generate(fEXlowdSorted.begin(), fEXlowdSorted.end(),; 683 [begin = low, &sorting_indices, this]() mutable { return fEXlowd[sorting_indices[begin++]]; });; 684 std::generate(fEXhighdSorted.begin(), fEXhighdSorted.end(),; 685 [begin = low, &sorting_indices, this]() mutable { return fEXhighd[sorting_indices[begin++]]; });; 686 ; 687 std::generate(fEYlowSorted.begin(), fEYlowSorted.end(),; 688 [begin = low, &sorting_indices, this]() mutable { return fEYlow[sorting_indices[begin++]]; });; 689 std::generate(fEYhighSorted.begin(), fEYhighSorted.end(),; 690 [begin = low, &sorting_indices, this]() mutable { return fEYhigh[sorting_indices[begin++]]; });; 691 std::generate(fEYlowdSorted.begin(), fEYlowdSorted.end(),; 692 [begin = low, &sorting_indices, this]() mutable { return fEYlowd[sorting_indices[begin++]]; });; 693 std::generate(fEYhighdSorted.begin(), fEYhighdSorted.end(),; 694 [begin = low, &sorting_indices, this]() mutable { return fEYhighd[sorting_indices[begin++]]; });; 695 ; 696 // Copy the sorted X and Y error values back to the original arrays; 697 std::copy(fEXlowSorted.begin(), fEXlowSorted.end(), fEXlow + low);; 698 std::copy(fEXhighSorted.begin(), fEXhighSorted.end(), fEXhigh + low);; 699 std::copy(fEXlowdSorted.begin(), fEXlowdSorted.end(), fEXlowd + low);; 700 std::copy(fEXhighdSorted.begin(), fEXhighdSorted.end(), fEXhighd + low);; 701 ; 702 std::copy(fEYlowSorted.begin(), fEYlowSorted.end(), fEYlow + low);; 703 std::copy(fEYhighSorted.begin(), fEYhighSorted.end(), fEYhigh + low);; 704 std::copy(fEYlowdSorted.begin(), fEYlowdSorted.end(), fEYlowd + low);; 705 std::copy(fEYhighdSorted.begin(), fEYhighdSorted.end(), fEYhighd + low);; 706 ; 707 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 708}; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:24046,error,error,24046,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['error']
Availability,"]ematrixhistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins. the array binMap is explained with the method GetOutput(). ; Definition at line 1276 of file TUnfoldSys.cxx. ◆ GetRhoItotal(). void TUnfoldSys::GetRhoItotal ; (; TH1 * ; rhoi, . const Int_t * ; binMap = nullptr, . TH2 * ; invEmat = nullptr . ). Get global correlatiocn coefficients, summing up all contributions. ; Parameters. [out]rhoihistogram which will be filled ; [in]binMap(default=nullptr) remapping of histogram bins ; [out]invEmat(default=nullptr) inverse of error matrix. return the global correlation coefficients, including all error sources. If invEmat is nonzero, the inverse of the error matrix is returned in that histogram ; the array binMap is explained with the method GetOutput(). ; Definition at line 1401 of file TUnfoldSys.cxx. ◆ GetSummedErrorMatrixXX(). TMatrixDSparse * TUnfoldSys::GetSummedErrorMatrixXX ; (; void ; ). protected . determine total error matrix on the vector x ; Definition at line 1331 of file TUnfoldSys.cxx. ◆ GetSummedErrorMatrixYY(). TMatrixDSparse * TUnfoldSys::GetSummedErrorMatrixYY ; (; void ; ). protected . determine total error matrix on the vector Ax ; Definition at line 1296 of file TUnfoldSys.cxx. ◆ GetSysSources(). TSortedList * TUnfoldSys::GetSysSources ; (; void ; ); const. Get a new list of all systematic uuncertainty sources. ; The user is responsible for deleting the list ; Definition at line 1512 of file TUnfoldSys.cxx. ◆ InitTUnfoldSys(). void TUnfoldSys::InitTUnfoldSys ; (; void ; ). private . Definition at line 618 of file TUnfoldSys.cxx. ◆ IsA(). TClass * TUnfoldSys::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TUnfold.; Definition at line 146 of file TUnfoldSys.h. ◆ PrepareCorrEmat(). TMatrixDSparse * TUnfoldSys::PrepareCorrEmat ; (; const TMatrixDSparse * ; m1, . const TMatrixDSparse * ; m2, . const TMatrixDSparse * ; dsys . ). protectedvirtual . propagate cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:43745,error,error,43745,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['error'],['error']
Availability,"]inputColumnsthe names of the columns to be passed to the callable. ; [in]variationTagsnames for each of the varied values, e.g. ""up"" and ""down"". ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". This overload of Vary takes a list of column names as first argument and requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each affected column. The variationTags are defined as {""down"", ""up""}.; Example usage: // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; auto nominal_hx =; df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; {""down"", ""up""}, // variation tags; ""ptAndEta"") // variation name; .Histo1D(""pt"", ""eta"");; ; auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; hx[""nominal""].Draw();; hx[""ptAndEta:down""].Draw(""SAME"");; hx[""ptAndEta:up""].Draw(""SAME"");; ROOT::RDF::RInterface::Histo1DRResultPtr<::TH1D > Histo1D(const TH1DModel &model={"""", """", 128u, 0., 0.}, std::string_view vName="""")Fill and return a one-dimensional histogram with the values of a column (lazy action).Definition RInterface.hxx:1804; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; See alsoThis Vary() overload for more information. ; Definition at line 950 of file RInterface.hxx. ◆ Vary() [2/11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; const std::vector< std::string > & ; colNames, . F && ; expression, . const ColumnNames_t & ; inputColumns, . std::size_t ; nVariations, . std::string_view ; variationNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:138265,down,down,138265,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['down'],['down']
Availability,"]w,h: Width and height of the pixmap . Reimplemented from TVirtualX.; Definition at line 1875 of file TGX11.cxx. ◆ ResizeWindow() [1/2]. void TGX11::ResizeWindow ; (; Int_t ; wid). overridevirtual . Resize the current window if necessary. ; Reimplemented from TVirtualX.; Definition at line 1919 of file TGX11.cxx. ◆ ResizeWindow() [2/2]. void TGX11::ResizeWindow ; (; Window_t ; id, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Resize the window. ; Reimplemented from TVirtualX.; Definition at line 317 of file GX11Gui.cxx. ◆ ScreenWidthMM(). UInt_t TGX11::ScreenWidthMM ; (; ); const. overridevirtual . Returns the width of the screen in millimeters. ; Reimplemented from TVirtualX.; Definition at line 2684 of file GX11Gui.cxx. ◆ SelectInput(). void TGX11::SelectInput ; (; Window_t ; id, . UInt_t ; evmask . ). overridevirtual . Defines which input events the window is interested in. ; By default events are propagated up the window stack. This mask can also be set at window creation time via the SetWindowAttributes_t::fEventMask attribute. ; Reimplemented from TVirtualX.; Definition at line 2198 of file GX11Gui.cxx. ◆ SelectWindow(). void TGX11::SelectWindow ; (; Int_t ; wid). overridevirtual . Select window to which subsequent output is directed. ; Reimplemented from TVirtualX.; Definition at line 1958 of file TGX11.cxx. ◆ SendEvent(). void TGX11::SendEvent ; (; Window_t ; id, . Event_t * ; ev . ). overridevirtual . Send event ev to window id. ; Reimplemented from TVirtualX.; Definition at line 1784 of file GX11Gui.cxx. ◆ SetCharacterUp(). void TGX11::SetCharacterUp ; (; Float_t ; chupx, . Float_t ; chupy . ). overridevirtual . Set character up vector. ; Reimplemented from TVirtualX.; Definition at line 1983 of file TGX11.cxx. ◆ SetClassHints(). void TGX11::SetClassHints ; (; Window_t ; id, . char * ; className, . char * ; resourceName . ). overridevirtual . Set the windows class and resource name. ; Reimplemented from TVirtualX.; Definition at line 1940 of file GX11Gu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:103499,mask,mask,103499,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['mask'],['mask']
Availability,"^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzE4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html:15675,toler,tolerance,15675,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzE4D_Double32_t___.html,1,['toler'],['tolerance']
Availability,"^2 } \f]. { return fCoordinates.Et2(); }. Scalar Et() const. return the transverse energy; \f[ e_t = \sqrt{ \frac{E^2 p_{\perp}^2 }{ |p|^2 } } X sign(E) \f]. { return fCoordinates.Et(); }. Scalar Phi() const. azimuthal Angle. { return fCoordinates.Phi();}. Scalar Theta() const. polar Angle. { return fCoordinates.Theta(); }. Scalar Eta() const. pseudorapidity; \f[ \eta = - \ln { \tan { \frac { \theta} {2} } } \f]. { return fCoordinates.Eta(); }. return operator*(const ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar& a) const; LorentzVector<CoordinateType> v(*this);; v.Negate();. Scalar Rapidity() const; ---- Relativistic Properties ----. Rapidity relative to the Z axis: .5 log [(E+Pz)/(E-Pz)]. Scalar ColinearRapidity() const. Rapidity in the direction of travel: atanh (|P|/E)=.5 log[(E+P)/(E-P)]. bool isTimelike() const. Determine if momentum-energy can represent a physical massive particle. bool isLightlike(ROOT::Math::LorentzVector<ROOT::Math::PxPyPzM4D<Double32_t> >::Scalar tolerance = 100*std::numeric_limits<Scalar>::epsilon()) const. Determine if momentum-energy can represent a massless particle. bool isSpacelike() const. Determine if momentum-energy is spacelike, and represents a tachyon. BetaVector BoostToCM() const. The beta vector for the boost that would bring this vector into; its center of mass frame (zero momentum). return - Vect() const; TODO - should attempt to Throw with msg about; boostVector computed for LorentzVector with t=0. Scalar Beta() const; beta and gamma. Return beta scalar value. Scalar Gamma() const. Return Gamma scalar value. Scalar x() const; Method providing limited backward name compatibility with CLHEP ----. { return fCoordinates.Px(); }. Scalar y() const; { return fCoordinates.Py(); }. Scalar z() const; { return fCoordinates.Pz(); }. Scalar t() const; { return fCoordinates.E(); }. Scalar px() const; { return fCoordinates.Px(); }. Scalar py() const; { return fCoordinates.Py(); }. Scalar pz() const; { return fCoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html:15675,toler,tolerance,15675,root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__LorentzVector_-p1PxPyPzM4D_Double32_t___.html,1,['toler'],['tolerance']
Availability,"_""); 7315 && !opt.Contains(""colz"")) {; 7316 hcounter++;; 7317 histName += ""__"";; 7318 histName += hcounter;; 7319 }; 7320 histName = gInterpreter-> MapCppName(histName);; 7321 const char *hname = histName.Data();; 7322 if (!strlen(hname)) hname = ""unnamed"";; 7323 TString savedName = GetName();; 7324 this->SetName(hname);; 7325 TString t(GetTitle());; 7326 t.ReplaceAll(""\\"",""\\\\"");; 7327 t.ReplaceAll(""\"""",""\\\"""");; 7328 out << hname << "" = new "" << ClassName() << ""("" << quote; 7329 << hname << quote << "","" << quote<< t.Data() << quote; 7330 << "","" << GetXaxis()->GetNbins();; 7331 if (nonEqiX); 7332 out << "", ""<<sxaxis;; 7333 else; 7334 out << "","" << GetXaxis()->GetXmin(); 7335 << "","" << GetXaxis()->GetXmax();; 7336 if (fDimension > 1) {; 7337 out << "","" << GetYaxis()->GetNbins();; 7338 if (nonEqiY); 7339 out << "", ""<<syaxis;; 7340 else; 7341 out << "","" << GetYaxis()->GetXmin(); 7342 << "","" << GetYaxis()->GetXmax();; 7343 }; 7344 if (fDimension > 2) {; 7345 out << "","" << GetZaxis()->GetNbins();; 7346 if (nonEqiZ); 7347 out << "", ""<<szaxis;; 7348 else; 7349 out << "","" << GetZaxis()->GetXmin(); 7350 << "","" << GetZaxis()->GetXmax();; 7351 }; 7352 out << "");"" << std::endl;; 7353 ; 7354 // save bin contents; 7355 Int_t bin;; 7356 for (bin=0;bin<fNcells;bin++) {; 7357 Double_t bc = RetrieveBinContent(bin);; 7358 if (bc) {; 7359 out<<"" ""<<hname<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 7360 }; 7361 }; 7362 ; 7363 // save bin errors; 7364 if (fSumw2.fN) {; 7365 for (bin=0;bin<fNcells;bin++) {; 7366 Double_t be = GetBinError(bin);; 7367 if (be) {; 7368 out<<"" ""<<hname<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 7369 }; 7370 }; 7371 }; 7372 ; 7373 TH1::SavePrimitiveHelp(out, hname, option);; 7374 this->SetName(savedName.Data());; 7375}; 7376 ; 7377////////////////////////////////////////////////////////////////////////////////; 7378/// Helper function for the SavePrimitive functions from TH1; 7379/// or classes derived from TH1, eg TProfile, TProfile2D.; 7380 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:287038,error,errors,287038,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"_); 19111 int on = 1;; 19112#endif; 19113 memset(&so, 0, sizeof(so));; 19114 ; 19115 if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)); 19116 == INVALID_SOCKET) {; 19117 } else if (check_acl(ctx, &so.rsa) != 1) {; 19118 sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);; 19119 mg_cry_ctx_internal(ctx,; 19120 ""%s: %s is not allowed to connect"",; 19121 __func__,; 19122 src_addr);; 19123 closesocket(so.sock);; 19124 } else {; 19125 /* Put so socket structure into the queue */; 19126 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19127 set_close_on_exec(so.sock, NULL, ctx);; 19128 so.is_ssl = listener->is_ssl;; 19129 so.ssl_redir = listener->ssl_redir;; 19130 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19131 mg_cry_ctx_internal(ctx,; 19132 ""%s: getsockname() failed: %s"",; 19133 __func__,; 19134 strerror(ERRNO));; 19135 }; 19136 ; 19137#if !defined(__ZEPHYR__); 19138 if ((so.lsa.sa.sa_family == AF_INET); 19139 || (so.lsa.sa.sa_family == AF_INET6)) {; 19140 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19141 * This is needed because if HTTP-level keep-alive; 19142 * is enabled, and client resets the connection, server won't get; 19143 * TCP FIN or RST and will keep the connection open forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:570257,alive,alive,570257,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['alive'],['alive']
Availability,"_); 19112 int on = 1;; 19113#endif; 19114 memset(&so, 0, sizeof(so));; 19115 ; 19116 if ((so.sock = accept(listener->sock, &so.rsa.sa, &len)); 19117 == INVALID_SOCKET) {; 19118 } else if (check_acl(ctx, &so.rsa) != 1) {; 19119 sockaddr_to_string(src_addr, sizeof(src_addr), &so.rsa);; 19120 mg_cry_ctx_internal(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:570290,alive,alive,570290,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['alive'],['alive']
Availability,"_,; 9796 strerror(ERRNO));; 9797 mg_send_http_error(; 9798 conn,; 9799 500,; 9800 ""%s"",; 9801 ""Error: Unable to access file at requested position."");; 9802 } else {; 9803 while (len > 0) {; 9804 /* Calculate how much to read from the file in the buffer */; 9805 to_read = sizeof(buf);; 9806 if ((int64_t)to_read > len) {; 9807 to_read = (int)len;; 9808 }; 9809 ; 9810 /* Read from file, exit the loop on error */; 9811 if ((num_read =; 9812 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9813 <= 0) {; 9814 break;; 9815 }; 9816 ; 9817 /* Send read bytes to the client, exit the loop on error */; 9818 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9819 != num_read) {; 9820 break;; 9821 }; 9822 ; 9823 /* Both read and were successful, adjust counters */; 9824 len -= num_written;; 9825 }; 9826 }; 9827 }; 9828}; 9829 ; 9830 ; 9831static int; 9832parse_range_header(const char *header, int64_t *a, int64_t *b); 9833{; 9834 return sscanf(header,; 9835 ""bytes=%"" INT64_FMT ""-%"" INT64_FMT,; 9836 a,; 9837 b); // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 9838 // to an integer value, but function will not report; 9839 // conversion errors; consider using 'strtol' instead; 9840}; 9841 ; 9842 ; 9843static void; 9844construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat); 9845{; 9846 if ((filestat != NULL) && (buf != NULL)) {; 9847 mg_snprintf(NULL,; 9848 NULL, /* All calls to construct_etag use 64 byte buffer */; 9849 buf,; 9850 buf_len,; 9851 ""\""%lx.%"" INT64_FMT ""\"""",; 9852 (unsigned long)filestat->last_modified,; 9853 filestat->size);; 9854 }; 9855}; 9856 ; 9857 ; 9858static void; 9859fclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn); 9860{; 9861 if (filep != NULL && filep->fp != NULL) {; 9862#if defined(_WIN32); 9863 (void)conn; /* Unused. */; 9864#else; 9865 if (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {; 9866 mg_cry_internal(conn,; 9867 ""%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s"",; 9868 __func__",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:281324,error,error,281324,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"_,; 9797 strerror(ERRNO));; 9798 mg_send_http_error(; 9799 conn,; 9800 500,; 9801 ""%s"",; 9802 ""Error: Unable to access file at requested position."");; 9803 } else {; 9804 while (len > 0) {; 9805 /* Calculate how much to read from the file in the buffer */; 9806 to_read = sizeof(buf);; 9807 if ((int64_t)to_read > len) {; 9808 to_read = (int)len;; 9809 }; 9810 ; 9811 /* Read from file, exit the loop on error */; 9812 if ((num_read =; 9813 (int)fread(buf, 1, (size_t)to_read, filep->access.fp)); 9814 <= 0) {; 9815 break;; 9816 }; 9817 ; 9818 /* Send read bytes to the client, exit the loop on error */; 9819 if ((num_written = mg_write(conn, buf, (size_t)num_read)); 9820 != num_read) {; 9821 break;; 9822 }; 9823 ; 9824 /* Both read and were successful, adjust counters */; 9825 len -= num_written;; 9826 }; 9827 }; 9828 }; 9829}; 9830 ; 9831 ; 9832static int; 9833parse_range_header(const char *header, int64_t *a, int64_t *b); 9834{; 9835 return sscanf(header,; 9836 ""bytes=%"" INT64_FMT ""-%"" INT64_FMT,; 9837 a,; 9838 b); // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 9839 // to an integer value, but function will not report; 9840 // conversion errors; consider using 'strtol' instead; 9841}; 9842 ; 9843 ; 9844static void; 9845construct_etag(char *buf, size_t buf_len, const struct mg_file_stat *filestat); 9846{; 9847 if ((filestat != NULL) && (buf != NULL)) {; 9848 mg_snprintf(NULL,; 9849 NULL, /* All calls to construct_etag use 64 byte buffer */; 9850 buf,; 9851 buf_len,; 9852 ""\""%lx.%"" INT64_FMT ""\"""",; 9853 (unsigned long)filestat->last_modified,; 9854 filestat->size);; 9855 }; 9856}; 9857 ; 9858 ; 9859static void; 9860fclose_on_exec(struct mg_file_access *filep, struct mg_connection *conn); 9861{; 9862 if (filep != NULL && filep->fp != NULL) {; 9863#if defined(_WIN32); 9864 (void)conn; /* Unused. */; 9865#else; 9866 if (fcntl(fileno(filep->fp), F_SETFD, FD_CLOEXEC) != 0) {; 9867 mg_cry_internal(conn,; 9868 ""%s: fcntl(F_SETFD FD_CLOEXEC) failed: %s"",; 9869 __func__",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:281356,error,error,281356,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=7.28945 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=7.28945 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=7.28945 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:33142,error,error,33142,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"_ARG2 ; (; VirtualX ; , . SetWMState ; , . Window_t ; , . id ; , . EInitialState ; , . state ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [1/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list VOID_METHOD_ARG3 ; (; VirtualX ; , . ChangeActivePointerGrab ; , . Window_t ; , . win ; , . UInt_t ; , . mask ; , . Cursor_t ; , . cur ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [2/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t VOID_METHOD_ARG3 ; (; VirtualX ; , . GetFontProperties ; , . FontStruct_t ; , . font ; , . Int_t & ; , . max_ascent ; , . Int_t & ; , . max_descent ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [3/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t VOID_METHOD_ARG3 ; (; VirtualX ; , . GetImageSize ; , . Drawable_t ; , . id ; , . UInt_t & ; , . width ; , . UInt_t & ; , . height ; , . 1 ;  . ). ◆ VOID_METHOD_ARG3() [4/11]. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:136503,mask,mask,136503,doc/master/TGWin32VirtualXProxy_8cxx.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html,2,['mask'],['mask']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGButton(const TGWindow* p = 0, Int_t id = -1, GContext_t norm = GetDefaultGC()(), UInt_t option = kRaisedFrame|kDoubleBorder); virtual~TGButton(); voidTObject::AbstractMethod(const char* method) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGButton.html:2205,avail,available,2205,root/html528/TGButton.html,https://root.cern,https://root.cern/root/html528/TGButton.html,6,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGCheckButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGCheckButton(const TGWindow* p = 0, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGCheckButton.html:2208,avail,available,2208,root/html528/TGCheckButton.html,https://root.cern,https://root.cern/root/html528/TGCheckButton.html,6,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGPictureButton(const TGWindow* p, const TGPicture* pic, Int_t id = -1, GContext_t norm = GetDefaultGC()(), UInt_t option = kRaisedFrame|kDoubleBorder); TGPictureButton(const TGWindow* p = 0, const char* pic ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGPictureButton.html:2210,avail,available,2210,root/html528/TGPictureButton.html,https://root.cern,https://root.cern/root/html528/TGPictureButton.html,6,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGRadioButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = 0); TGRadioButton(const TGWindow* p = 0, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGRadioButton.html:2208,avail,available,2208,root/html528/TGRadioButton.html,https://root.cern,https://root.cern/root/html528/TGRadioButton.html,6,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGSplitButton(const TGWindow* p, TGHotString* menulabel, TGPopupMenu* popmenu, Bool_t split = kTRUE, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t fontstruct = GetDefaultFontStruct(), UInt_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSplitButton.html:2208,avail,available,2208,root/html528/TGSplitButton.html,https://root.cern,https://root.cern/root/html528/TGSplitButton.html,6,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. TGTextButton(const TGWindow* p, TGHotString* s, Int_t id = -1, GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t option = kRaisedFrame|kDoubleBorder); TGTextButton(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextButton.html:2201,avail,available,2201,root/html528/TGTextButton.html,https://root.cern,https://root.cern/root/html528/TGTextButton.html,6,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidAllowStayDown(Bool_t a); virtual voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGButton.html:2205,avail,available,2205,root/html602/TGButton.html,https://root.cern,https://root.cern/root/html602/TGButton.html,4,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGCheckButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGCheckButton.html:2208,avail,available,2208,root/html602/TGCheckButton.html,https://root.cern,https://root.cern/root/html602/TGCheckButton.html,4,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGPictureButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGPictureButton.html:2210,avail,available,2210,root/html602/TGPictureButton.html,https://root.cern,https://root.cern/root/html602/TGPictureButton.html,4,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGRadioButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGRadioButton.html:2208,avail,available,2208,root/html602/TGRadioButton.html,https://root.cern,https://root.cern/root/html602/TGRadioButton.html,4,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGSplitButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGSplitButton.html:2208,avail,available,2208,root/html602/TGSplitButton.html,https://root.cern,https://root.cern/root/html602/TGSplitButton.html,4,['avail'],['available']
Availability,"_BUTTON, button id, user data. The purpose of TGCheckButton and TGRadioButton is for selecting; different options. Like text buttons, they have text or hot string; as a label. Radio buttons are grouped usually in logical sets of two or more; buttons to present mutually exclusive choices. Selecting a check button will generate the event:; kC_COMMAND, kCM_CHECKBUTTON, button id, user data. Selecting a radio button will generate the event:; kC_COMMAND, kCM_RADIOBUTTON, button id, user data. If a command string has been specified (via SetCommand()) then this; command string will be executed via the interpreter whenever a; button is selected. A command string can contain the macros:; $MSG -- kC_COMMAND, kCM[CHECK|RADIO]BUTTON packed message; (use GET_MSG() and GET_SUBMSG() to unpack); $PARM1 -- button id; $PARM2 -- user data pointer; Before executing these macros are expanded into the respective; Long_t's. TGSplitButton implements a button with added menu functionality.; There are 2 modes of operation available. If the button is split, a menu will popup when the menu area of the; button is clicked. Activating a menu item changes the functionality; of the button by having it emit a additional signal when it is; clicked. The signal emitted when the button is clicked, is the; ItemClicked(Int_t) signal with a different fixed value for the; Int_t that corresponds to the id of the activated menu entry. If the button is not split, clicking it will popup the menu and the; ItemClicked(Int_t) signal will be emitted when a menu entry is; acitvated. The value of the Int_t is again equal to the value of; the id of the activated menu entry. The mode of operation of a SplitButton can be changed on the fly; by calling the SetSplit(Bool_t) method. Function Members (Methods); public:. virtual~TGTextButton(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTGButton::AllowStayDown(Bool_t a); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextButton.html:2201,avail,available,2201,root/html602/TGTextButton.html,https://root.cern,https://root.cern/root/html602/TGTextButton.html,4,['avail'],['available']
Availability,"_Cache.C;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df019_Cache.py;   Cache a processed RDataFrame in memory for further usage. ;  ; file  df020_helpers.C;   Show usage of RDataFrame's helper tools, contained in ROOT/RDFHelpers.hxx. ;  ; file  df021_createTGraph.C;   Fill a TGraph using RDataFrame. ;  ; file  df021_createTGraph.py;   Fill a TGraph using RDataFrame. ;  ; file  df022_useKahan.C;   Implement a custom action that evaluates a Kahan sum. ;  ; file  df023_aggregate.C;   Use the Aggregate action to specify arbitrary data aggregations. ;  ; file  df024_Display.C;   Use the Display action to inspect entry values. ;  ; file  df024_Display.py;   Use the Display action to inspect entry values. ;  ; file  df025_RNode.C;   Manipulate RDF objects in functions, loops and conditional branches. ;  ; file  df026_AsNumpyArrays.py;   Read data from RDataFrame into Numpy arrays. ;  ; file  df027_SQliteDependencyOverVersion.C;   Plot the ROOT downloads based on the version reading a remote sqlite3 file. ;  ; file  df028_SQliteIPLocation.C;   Plot the location of ROOT downloads reading a remote sqlite3 file. ;  ; file  df029_SQlitePlatformDistribution.C;   Use RDataFrame to display data about ROOT downloads. ;  ; file  df030_SQliteVersionsOfROOT.C;   Read an sqlite3 databases with RDataFrame and plot statistics on ROOT downloads. ;  ; file  df031_Stats.C;   Use the Stats action to extract the statistics of a column. ;  ; file  df031_Stats.py;   Use the Stats action to extract the statistics of a column. ;  ; file  df032_RDFFromNumpy.py;   Read data from Numpy arrays into RDataFrame. ;  ; file  df033_Describe.py;   Get information about the dataframe with the convenience method Describe. ;  ; file  df034_SaveGraph.C;   Basic SaveGraph usage. ;  ; file  df034_SaveGraph.py;   Basic SaveGraph usage. ;  ; file  df035_RDFFromPandas.py;   Read data from Pandas Data Frame into RDataFrame. ;  ; file  df036_missingBranches.C;   ;  ; file  df037_TTreeEvent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__dataframe.html:5234,down,downloads,5234,doc/master/group__tutorial__dataframe.html,https://root.cern,https://root.cern/doc/master/group__tutorial__dataframe.html,1,['down'],['downloads']
Availability,"_ERROR(result));; 422 }; 423 ; 424 ntplWriter->Fill(*fEntry);; 425 ; 426 if (fProgressCallback); 427 fProgressCallback->Call(ctrZippedBytes->GetValueAsInt(), i);; 428 }; 429 if (fProgressCallback); 430 fProgressCallback->Finish(ctrZippedBytes->GetValueAsInt(), nEntries);; 431}; RError.hxx; R__FORWARD_ERROR#define R__FORWARD_ERROR(res)Short-hand to return an RResult<T> in an error state (i.e. after checking)Definition RError.hxx:294; R__FAIL#define R__FAIL(msg)Short-hand to return an RResult<T> in an error state; the RError is implicitly converted into RResult...Definition RError.hxx:290; RField.hxx; RNTupleImporter.hxx; RNTupleUtil.hxx; RNTupleWriteOptions.hxx; RNTupleWriter.hxx; RPageSinkBuf.hxx; RPageStorageFile.hxx; RPageStorage.hxx; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; TBranch.h; TChain.h; TClass.h; TDataType.h; kOther_t@ kOther_tDefinition TDataType.h:32; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html:18808,error,error,18808,doc/master/RNTupleImporter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleImporter_8cxx_source.html,1,['error'],['error']
Availability,"_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TSeqCollectionSequenceable collection abstract base class.Definition TSeqCollection.h:28; TSeqCollection::IndexOfvirtual Int_t IndexOf(const TObject *obj) constReturn index of object in collection.Definition TSeqCollection.cxx:30; TStringBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:242846,error,error,242846,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['error'],['error']
Availability,"_MACOSX; 3306 ; 3307#if defined (R__LINUX) || defined (R__FBSD); 3308 ; 3309////////////////////////////////////////////////////////////////////////////////; 3310/// Callback for dl_iterate_phdr(), see `man dl_iterate_phdr`.; 3311/// Collects opened libraries.; 3312 ; 3313static int callback_for_dl_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data); 3314{; 3315 // This function is called through UpdateListOfLoadedSharedLibraries() which is locked.; 3316 static std::unordered_set<decltype(info->dlpi_addr)> sKnownLoadedLibBaseAddrs;; 3317 ; 3318 auto newLibs = static_cast<std::vector<std::string>*>(data);; 3319 if (!sKnownLoadedLibBaseAddrs.count(info->dlpi_addr)) {; 3320 // Skip \0, """", and kernel pseudo-libs linux-vdso.so.1 or linux-gate.so.1; 3321 if (info->dlpi_name && info->dlpi_name[0]; 3322#if defined(R__FBSD); 3323 //skip the executable (with null addr); 3324 && info->dlpi_addr; 3325 //has no path; 3326 && strncmp(info->dlpi_name, ""[vdso]"", 6); 3327 //the linker does not like to be mmapped; 3328 //causes a crash in cling::DynamicLibraryManager::loadLibrary()); 3329 //with error message ""mmap of entire address space failed: Cannot allocate memory""; 3330 && strncmp(info->dlpi_name, ""/libexec/ld-elf.so.1"", 20); 3331#endif; 3332 && strncmp(info->dlpi_name, ""linux-vdso.so"", 13); 3333 && strncmp(info->dlpi_name, ""linux-vdso32.so"", 15); 3334 && strncmp(info->dlpi_name, ""linux-vdso64.so"", 15); 3335 && strncmp(info->dlpi_name, ""linux-gate.so"", 13)); 3336 newLibs->emplace_back(info->dlpi_name);; 3337 sKnownLoadedLibBaseAddrs.insert(info->dlpi_addr);; 3338 }; 3339 // No matter what the doc says, return != 0 means ""stop the iteration"".; 3340 return 0;; 3341}; 3342 ; 3343#endif // R__LINUX || R__FBSD; 3344 ; 3345 ; 3346////////////////////////////////////////////////////////////////////////////////; 3347 ; 3348void TCling::UpdateListOfLoadedSharedLibraries(); 3349{; 3350#if defined(R__WIN32) || defined(__CYGWIN__); 3351 HMODULE hModules[1024];; 3352 void *hPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:128765,error,error,128765,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,_MASK_UNDERFLOW) mask |= kUnderflow;; 956 if (oldmask & _MM_MASK_INEXACT ) mask |= kInexact;; 957#endif; 958 ; 959#if defined(R__MACOSX) && !defined(__SSE2__) && \; 960 (defined(__i386__) || defined(__x86_64__) || defined(__arm__) || defined(__arm64__)); 961 fenv_t oldenv;; 962 fegetenv(&oldenv);; 963 fesetenv(&oldenv);; 964#if defined(__arm__); 965 Int_t oldmask = ~oldenv.__fpscr;; 966#elif defined(__arm64__); 967 Int_t oldmask = ~oldenv.__fpcr;; 968#else; 969 Int_t oldmask = ~oldenv.__control;; 970#endif; 971 ; 972 if (oldmask & FE_INVALID ) mask |= kInvalid;; 973 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 974 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 975 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 976 if (oldmask & FE_INEXACT ) mask |= kInexact;; 977#endif; 978 ; 979#if defined(R__MACOSX) && !defined(__SSE2__) && !defined(__xlC__) && \; 980 !defined(__i386__) && !defined(__x86_64__) && !defined(__arm__) && \; 981 !defined(__arm64__); 982 Long64_t oldmask;; 983 fegetenvd(oldmask);; 984 ; 985 if (oldmask & FE_ENABLE_INVALID ) mask |= kInvalid;; 986 if (oldmask & FE_ENABLE_DIVBYZERO) mask |= kDivByZero;; 987 if (oldmask & FE_ENABLE_OVERFLOW ) mask |= kOverflow;; 988 if (oldmask & FE_ENABLE_UNDERFLOW) mask |= kUnderflow;; 989 if (oldmask & FE_ENABLE_INEXACT ) mask |= kInexact;; 990#endif; 991 ; 992 return mask;; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// Set which conditions trigger a floating point exception.; 997/// Return the previous set of conditions.; 998 ; 999Int_t TUnixSystem::SetFPEMask(Int_t mask); 1000{; 1001 if (mask) { } // use mask to avoid warning; 1002 ; 1003 Int_t old = GetFPEMask();; 1004 ; 1005#if defined(R__LINUX) && !defined(__powerpc__); 1006#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 1007 Int_t newm = 0;; 1008 if (mask & kInvalid ) newm |= FE_INVALID;; 1009 if (mask & kDivByZero) newm |= FE_DIVBYZERO;; 1010 if (mask & kOverflow ) new,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:29585,mask,mask,29585,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,11,['mask'],['mask']
Availability,"_Name()TGeoManagerstatic; Class_Version()TGeoManagerinlinestatic; ClassName() constTObjectvirtual; CleanGarbage()TGeoManager; Clear(Option_t *option="""") overrideTNamedvirtual; ClearAttributes()TGeoManager; ClearNavigators()TGeoManager; ClearOverlaps()TGeoManager; ClearPhysicalNodes(Bool_t mustdelete=kFALSE)TGeoManager; ClearShape(const TGeoShape *shape)TGeoManager; ClearThreadData() constTGeoManager; ClearThreadsMap()TGeoManagerstatic; ClearTracks()TGeoManagerinline; Clone(const char *newname="""") const overrideTNamedvirtual; CloseGeometry(Option_t *option=""d"")TGeoManager; Compare(const TObject *obj) const overrideTNamedvirtual; ConstPropMap_t typedefTGeoManagerprivate; ConvertReflections()TGeoManager; Copy(TObject &named) const overrideTNamedvirtual; CountLevels()TGeoManager; CountNodes(const TGeoVolume *vol=nullptr, Int_t nlevels=10000, Int_t option=0)TGeoManager; CreateParallelWorld(const char *name)TGeoManager; CreateThreadData() constTGeoManager; CrossBoundaryAndLocate(Bool_t downwards, TGeoNode *skipnode)TGeoManager; DeclFileName()TGeoManagerinlinestatic; DefaultAngles()TGeoManager; DefaultColors()TGeoManager; Delete(Option_t *option="""")TObjectvirtual; DisableInactiveVolumes()TGeoManagerinline; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; Division(const char *name, const char *mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed=0, Option_t *option="""")TGeoManager; DoBackupState()TGeoManager; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; DoRestoreState()TGeoManager; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; DrawCurrentPoint(Int_t color=2)TGeoManager; DrawPath(const char *path, Option_t *option="""")TGeoManager; DrawTracks(Option_t *option="""")TGeoManager; Dump() constTObjectvirtual; EDefaultUnits enum nameTGeoManager; EDeprecatedStatusBits enum nameTObject; Edit(Option_t *option="""")TGeoManagervirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager-members.html:3139,down,downwards,3139,doc/master/classTGeoManager-members.html,https://root.cern,https://root.cern/doc/master/classTGeoManager-members.html,1,['down'],['downwards']
Availability,"_OFF = 26; , kENTRY_NAMELEN_LEN = 2; , kENTRY_EXTRALEN_OFF = 28; , ;   kENTRY_EXTRALEN_LEN = 2; , kENTRY_HEADER_SIZE = 30; , kZIP64_EXTENDED_MAGIC_OFF = 0; , kZIP64_EXTENDED_MAGIC_LEN = 2; , ;   kZIP64_EXTENDED_SIZE_OFF = 2; , kZIP64_EXTENDED_SIZE_LEN = 2; , kZIP64_EXTENDED_USIZE_OFF = 4; , kZIP64_EXTENDED_USIZE_LEN = 8; , ;   kZIP64_EXTENTED_CSIZE_OFF = 12; , kZIP64_EXTENDED_CSIZE_LEN = 8; , kZIP64_EXTENDED_HDR_OFFSET_OFF = 20; , kZIP64_EXTENDED_HDR_OFFSET_LEN = 8; , ;   kZIP64_EXTENDED_DISK_OFF = 28; , kZIP64_EXTENDED_DISK_LEN = 4; , kZIP64_EXTENDED_SIZE = 32; , kSTORED = 0; , ;   kDEFLATED = 8. };  ZIP archive constants. More...;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions;  TZIPFile (const TZIPFile &)=delete;  ; Int_t DecodeZip64ExtendedExtraField (TZIPMember *m, Bool_t global=kTRUE);  Decode the Zip64 extended extra field. ;  ; Long64_t FindEndHeader ();  Find the end header of the ZIP archive. Returns 0 in case of error. ;  ; UInt_t Get (const void *buffer, Int_t bytes);  Read a ""bytes"" long little-endian integer value from ""buffer"". ;  ; ULong64_t Get64 (const void *buffer, Int_t bytes);  Read a 8 byte long little-endian integer value from ""buffer"". ;  ; TZIPFile & operator= (const TZIPFile &)=delete;  ; Int_t ReadDirectory ();  Read the directory of the ZIP archive. ;  ; Int_t ReadEndHeader (Long64_t pos);  Read the end header of the ZIP archive including the archive comment at the current file position. ;  ; Int_t ReadMemberHeader (TZIPMember *member);  Read the member header of the ZIP archive. ;  ; Long64_t ReadZip64EndLocator (Long64_t pos);  Read Zip64 end of central directory locator. ;  ; Int_t ReadZip64EndRecord (Long64_t pos);  Read Zip64 end of central directory record. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTZIPFile.html:16425,error,error,16425,doc/master/classTZIPFile.html,https://root.cern,https://root.cern/doc/master/classTZIPFile.html,1,['error'],['error']
Availability,"_OF_PEAKS2]; // calculated values of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate y positions of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 2D peaks, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 2D peaks; bool fix_amp[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate amplitudes of 2D peaks (not fit). However, they are present in the estimated functional; double amp_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_x1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double amp_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of 1D ridges amplitudes, input parameters; double amp_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values of fitted amplitudes of 1D ridges, output parameters; double amp_err_y1[MAX_NUMBER_OF_PEAKS2]; // amplitude errors of 1D ridges; bool fix_amp_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix the appropriate amplitudes of 1D ridges (not fit). However, they are present in the estimated functional; double volume[MAX_NUMBER_OF_PEAKS1]; // calculated volumes of peaks; double volume_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak volumes; double sigma_init_x; // sigma x parameter; double sigma_calc_x;; double sigma_err_x;; bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:50099,error,errors,50099,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,2,['error'],['errors']
Availability,"_RESULT(a) ((void)((a) && 1)); 292#endif; 293 ; 294 ; 295#if defined(__GNUC__) || defined(__MINGW32__); 296 ; 297/* GCC unused function attribute seems fundamentally broken.; 298 * Several attempts to tell the compiler ""THIS FUNCTION MAY BE USED; 299 * OR UNUSED"" for individual functions failed.; 300 * Either the compiler creates an ""unused-function"" warning if a; 301 * function is not marked with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-marked-unused"" warning - and; 305 * #pragma GCC diagnostic ignored ""-Wused-but-marked-unused""; 306 * raises error: unknown option after ""#pragma GCC diagnostic"".; 307 * Disable this warning completely, until the GCC guys sober up; 308 * again.; 309 */; 310 ; 311#pragma GCC diagnostic ignored ""-Wunused-function""; 312 ; 313#define FUNCTION_MAY_BE_UNUSED /* __attribute__((unused)) */; 314 ; 315#else; 316#define FUNCTION_MAY_BE_UNUSED; 317#endif; 318 ; 319 ; 320/* Some ANSI #includes are not available on Windows CE and Zephyr */; 321#if !defined(_WIN32_WCE) && !defined(__ZEPHYR__); 322#include <errno.h>; 323#include <fcntl.h>; 324#include <signal.h>; 325#include <stdlib.h>; 326#include <sys/stat.h>; 327#include <sys/types.h>; 328#endif /* !_WIN32_WCE */; 329 ; 330 ; 331#if defined(__clang__); 332/* When using -Weverything, clang does not accept it's own headers; 333 * in a release build configuration. Disable what is too much in; 334 * -Weverything. */; 335#pragma clang diagnostic ignored ""-Wdisabled-macro-expansion""; 336#endif; 337 ; 338#if defined(__GNUC__) || defined(__MINGW32__); 339/* Who on earth came to the conclusion, using __DATE__ should rise; 340 * an ""expansion of date or time macro is not reproducible""; 341 * warning. That's exactly what was intended by using this macro.; 342 * Just disable this nonsense warning. */; 343 ; 344/* And disabling them does not work either:; 345 * #pragma clang di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:11686,avail,available,11686,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['avail'],['available']
Availability,"_StreamerNVirtual_b). inline . Definition at line 81 of file TNetFile.h. ◆ SysClose(). Int_t TNetFile::SysClose ; (; Int_t ; fd). overrideprotectedvirtual . Close currently open file. ; Reimplemented from TFile.; Definition at line 144 of file TNetFile.cxx. ◆ SysOpen(). Int_t TNetFile::SysOpen ; (; const char * ; pathname, . Int_t ; flags, . UInt_t ; mode . ). overrideprotectedvirtual . Open a remote file. Requires fOption to be set correctly. ; Reimplemented from TFile.; Definition at line 109 of file TNetFile.cxx. ◆ SysStat(). Int_t TNetFile::SysStat ; (; Int_t ; fd, . Long_t * ; id, . Long64_t * ; size, . Long_t * ; flags, . Long_t * ; modtime . ). overrideprotectedvirtual . Return file stat information. ; The interface and return value is identical to TSystem::GetPathInfo(). ; Reimplemented from TFile.; Definition at line 156 of file TNetFile.cxx. ◆ WriteBuffer(). Bool_t TNetFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). overridevirtual . Write specified byte range to remote file via rootd daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 488 of file TNetFile.cxx. Member Data Documentation. ◆ fEndpointUrl. TUrl TNetFile::fEndpointUrl. protected . Definition at line 37 of file TNetFile.h. ◆ fErrorCode. Int_t TNetFile::fErrorCode. protected . Definition at line 41 of file TNetFile.h. ◆ fNetopt. Int_t TNetFile::fNetopt. protected . Definition at line 42 of file TNetFile.h. ◆ fProtocol. Int_t TNetFile::fProtocol. protected . Definition at line 40 of file TNetFile.h. ◆ fSocket. TSocket* TNetFile::fSocket. protected . Definition at line 39 of file TNetFile.h. ◆ fUser. TString TNetFile::fUser. protected . Definition at line 38 of file TNetFile.h. Libraries for TNetFile:. [legend]; The documentation for this class was generated from the following files:; net/net/inc/TNetFile.h; net/net/src/TNetFile.cxx. TNetFile. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:52371,error,error,52371,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['error'],['error']
Availability,"_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. TMVA::MsgLogger&Log() const. Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfAbsTolabsolute tolerance deviation; Double_t (*)(Double_t)fGetRootVal; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; Double_tfRootMaxmaximum root value; Double_tfRootMinminimum root value. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0); constructor. ~RootFinder( void ); destructor. Double_t Root(Double_t refValue); Root finding using Brents algorithm; taken from CERNLIB function RZERO. RootFinder(Double_t (*)(Double_t) rootVal, Double_t rootMin, Double_t rootMax, Int_t maxIterations = 100, Double_t absTolerance = 0.0). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__RootFinder.html:5360,toler,tolerance,5360,root/html534/TMVA__RootFinder.html,https://root.cern,https://root.cern/root/html534/TMVA__RootFinder.html,2,['toler'],['tolerance']
Availability,"_Title(MethodInfo_t* minfo) const; virtual TypeInfo_t*MethodInfo_Type(MethodInfo_t* minfo) const; virtual const char*MethodInfo_TypeName(MethodInfo_t* minfo) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t* minfo) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Long_tProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:14205,error,error,14205,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['error'],['error']
Availability,"_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 85 of file THtml.h. ◆ DeclFileName(). static const char * THtml::TFileDefinition::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 85 of file THtml.h. ◆ ExpandSearchPath(). void THtml::TFileDefinition::ExpandSearchPath ; (; TString & ; path); const. protected . Create all permutations of path and THtml's input path: path being PP/ and THtml's input being .:include/:src/ gives .:. ; /PP/:include:include/PP/:src/:src/PP ; Definition at line 206 of file THtml.cxx. ◆ GetDeclFileName(). bool THtml::TFileDefinition::GetDeclFileName ; (; const TClass * ; cl, . TString & ; out_filename, . TString & ; out_fsys, . TFileSysEntry ** ; fse = 0 . ); const. virtual . Determine cl's declaration file name. ; Usually it's just cl->GetDeclFileName(), but sometimes conversions need to be done like include/ to abc/cde/inc/. If no declaration file name is available, look for b/inc/C.h for class A::B::C. out_fsys will contain the file system's (i.e. local machine's) full path name to the file. The function returns false if the class's header file cannot be found.; If your software cannot be mapped into this scheme then derive your own class from TFileDefinition and pass it to THtml::SetFileDefinition(). ; Definition at line 262 of file THtml.cxx. ◆ GetFileName(). bool THtml::TFileDefinition::GetFileName ; (; const TClass * ; cl, . bool ; decl, . TString & ; out_filename, . TString & ; out_fsys, . TFileSysEntry ** ; fse = 0 . ); const. protectedvirtual . Common implementation for GetDeclFileName(), GetImplFileName() ; Definition at line 338 of file THtml.cxx. ◆ GetImplFileName(). bool THtml::TFileDefinition::GetImplFileName ; (; const TClass * ; cl, . TString & ; out_filename, . TString & ; out_fsys, . TFileSysEntry ** ; fse = 0 . ); const. virtual . Determine cl's implementation file name. ; Usually it's just cl->GetImplFileName(), but",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHtml_1_1TFileDefinition.html:13317,avail,available,13317,doc/master/classTHtml_1_1TFileDefinition.html,https://root.cern,https://root.cern/doc/master/classTHtml_1_1TFileDefinition.html,1,['avail'],['available']
Availability,"__________________; void ErrorIntegral() {; fitFunc = new TF1(""f"",f,0,1,NPAR);; TH1D * h1 = new TH1D(""h1"",""h1"",50,0,1);; ; double par[NPAR] = { 3.14, 1.};; fitFunc->SetParameters(par);; ; h1->FillRandom(""f"",1000); // fill histogram sampling fitFunc; fitFunc->SetParameter(0,3.); // vary a little the parameters; auto fitResult = h1->Fit(fitFunc,""S""); // fit the histogram and get fit result pointer; ; h1->Draw();; ; /* calculate the integral*/; double integral = fitFunc->Integral(0,1);; ; auto covMatrix = fitResult->GetCovarianceMatrix();; std::cout << ""Covariance matrix from the fit "";; covMatrix.Print();; ; // need to pass covariance matrix to fit result.; // Parameters values are are stored inside the function but we can also retrieve from TFitResult; double sigma_integral = fitFunc->IntegralError(0,1, fitResult->GetParams() , covMatrix.GetMatrixArray());; ; std::cout << ""Integral = "" << integral << "" +/- "" << sigma_integral; << std::endl;; ; // estimated integral and error analytically; ; double * p = fitFunc->GetParameters();; double ic = p[1]* (1-std::cos(p[0]) )/p[0];; double c0c = p[1] * (std::cos(p[0]) + p[0]*std::sin(p[0]) -1.)/p[0]/p[0];; double c1c = (1-std::cos(p[0]) )/p[0];; ; // estimated error with correlations; double sic = std::sqrt( c0c*c0c * covMatrix(0,0) + c1c*c1c * covMatrix(1,1); + 2.* c0c*c1c * covMatrix(0,1));; ; if ( std::fabs(sigma_integral-sic) > 1.E-6*sic ); std::cout << "" ERROR: test failed : different analytical integral : ""; << ic << "" +/- "" << sic << std::endl;; }; f#define f(i)Definition RSha256.hxx:104; TF1.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TH1D.h; TMath.h; TF11-Dim function classDefinition TF1.h:233; TF1::IntegralErrorvirtual Double_t IntegralError(Double_t a, Double_t b, const Double_t *params=nullptr, const Double_t *covmat=nullptr, Double_t epsilon=1.E-2)Return Error on Integral of a parametric function between a and b due to the parameter uncertainties ...Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ErrorIntegral_8C.html:3554,error,error,3554,doc/master/ErrorIntegral_8C.html,https://root.cern,https://root.cern/doc/master/ErrorIntegral_8C.html,1,['error'],['error']
Availability,"_____________________________________________________________________; 3579//; 3580// Command MIGRAD; 3581//; 3582 if( !strncmp(comd.Data(),""MIG"",3) ) {; 3583 Printf("" ***>MIGrad [maxcalls] [tolerance]"");; 3584 Printf("" Causes minimization of the function by the method of Migrad,"");; 3585 Printf("" the most efficient and complete single method, recommended"");; 3586 Printf("" for general functions (see also MINImize)."");; 3587 Printf("" The minimization produces as a by-product the error matrix"");; 3588 Printf("" of the parameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:115786,toler,tolerance,115786,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['toler'],['tolerance']
Availability,"____________________________________________________________________________; 3756//; 3757// Command SET; 3758//; 3759 if( !strncmp(comd.Data(),""SET"",3) ) {; 3760 Printf("" ***>SET <option_name>"");; 3761 Printf("" SET BATch"");; 3762 Printf("" Informs Minuit that it is running in batch mode."");; 3763 ; 3764 Printf("" "");; 3765 Printf("" SET EPSmachine <accuracy>"");; 3766 Printf("" Informs Minuit that the relative floating point arithmetic"");; 3767 Printf("" precision is <accuracy>. Minuit determines the nominal"");; 3768 Printf("" precision itself, but the SET EPSmachine command can be"");; 3769 Printf("" used to override Minuit own determination, when the user"");; 3770 Printf("" knows that the FCN function value is not calculated to"");; 3771 Printf("" the nominal machine accuracy. Typical values of <accuracy>"");; 3772 Printf("" are between 10**-5 and 10**-14."");; 3773 ; 3774 Printf("" "");; 3775 Printf("" SET ERRordef <up>"");; 3776 Printf("" Sets the value of UP (default value= 1.), defining parameter"");; 3777 Printf("" errors. Minuit defines parameter errors as the change"");; 3778 Printf("" in parameter value required to change the function value"");; 3779 Printf("" by UP. Normally, for chisquared fits UP=1, and for negative"");; 3780 Printf("" log likelihood, UP=0.5."");; 3781 ; 3782 Printf("" "");; 3783 Printf("" SET GRAdient [force]"");; 3784 Printf("" Informs Minuit that the user function is prepared to"");; 3785 Printf("" calculate its own first derivatives and return their values"");; 3786 Printf("" in the array GRAD when IFLAG=2 (see specs of FCN)."");; 3787 Printf("" If [force] is not specified, Minuit will calculate"");; 3788 Printf("" the FCN derivatives by finite differences at the current"");; 3789 Printf("" point and compare with the user calculation at that point,"");; 3790 Printf("" accepting the user values only if they agree."");; 3791 Printf("" If [force]=1, Minuit does not do its own derivative"");; 3792 Printf("" calculation, and uses the derivatives calculated in FCN."");; 3793 ; 3794 Printf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:124866,error,errors,124866,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['errors']
Availability,"_ateval. happens instead of this. root> G__at[TAB]; root> G__ateval(. because there are several overloaded versions of G__ateval().; (this could be fixed). Function Members (Methods); public:. virtual~TTabCom(); static Char_tAllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); static voidAppendListOfFilesInDirectory(const char[] dirName, TSeqCollection* pList); static TClass*Class(); voidClearAll(); voidClearClasses(); voidClearCppDirectives(); voidClearEnvVars(); voidClearFiles(); voidClearGlobalFunctions(); voidClearGlobals(); voidClearPragmas(); voidClearSysIncFiles(); voidClearUsers(); static TStringDetermineClass(const char[] varName); static Bool_tExcludedByFignore(TString s); const TSeqCollection*GetListOfClasses(); const TSeqCollection*GetListOfCppDirectives(); const TSeqCollection*GetListOfEnvVars(); const TSeqCollection*GetListOfFilesInPath(const char[] path); TCollection*GetListOfGlobalFunctions(); const TSeqCollection*GetListOfGlobals(); const TSeqCollection*GetListOfPragmas(); const TSeqCollection*GetListOfSysIncFiles(); const TSeqCollection*GetListOfUsers(); static TStringGetSysIncludePath(); Int_tHook(char* buf, int* pLoc, ostream& out); virtual TClass*IsA() const; static Bool_tIsDirectory(const char[] fileName); static TSeqCollection*NewListOfFilesInPath(const char[] path); static voidNoMsg(Int_t errorLevel); static Bool_tPathIsSpecifiedInFileName(const TString& fileName); voidRehashAll(); voidRehashClasses(); voidRehashCppDirectives(); voidRehashEnvVars(); voidRehashFiles(); voidRehashGlobalFunctions(); voidRehashGlobals(); voidRehashPragmas(); voidRehashSysIncFiles(); voidRehashUsers(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTabCom(). private:. Int_tComplete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char[] appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); voidCopyMatch(char[] de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:4407,error,errorLevel,4407,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,4,['error'],['errorLevel']
Availability,"_bkg2),; RooArgList(Asig2,Abkg2),; true);; ; // Construct the subsidiary poisson measurements constraining the statistical fluctuations; RooHistConstraint hc_sigbkg(""hc_sigbkg"",""hc_sigbkg"",RooArgSet(p_ph_sig2,p_ph_bkg2));; ; // Construct the joint model; RooProdPdf model2(""model2"",""model2"",hc_sigbkg, RooFit::Conditional(model2_tmp,x));; ; ; ; // ************ Fit all models to data and plot *********************; ; auto result0 = model0.fitTo(sumData, PrintLevel(0), Save());; auto result1 = model1.fitTo(sumData, PrintLevel(0), Save());; auto result2 = model2.fitTo(sumData, PrintLevel(0), Save());; ; ; TCanvas* can = new TCanvas(""can"", """", 1500, 600);; can->Divide(3,1);; ; TPaveText pt(-19.5, 1, -2, 25);; pt.SetFillStyle(0);; pt.SetBorderSize(0);; ; ; can->cd(1);; auto frame = x.frame(Title(""No template uncertainties""));; // Plot data to enable automatic determination of model0 normalisation:; sumData.plotOn(frame);; model0.plotOn(frame, LineColor(kBlue), VisualizeError(*result0));; // Plot data again to show it on top of model0 error bands:; sumData.plotOn(frame);; // Plot model components; model0.plotOn(frame, LineColor(kBlue));; model0.plotOn(frame, Components(p_h_sig), LineColor(kAzure));; model0.plotOn(frame, Components(p_h_bkg), LineColor(kRed));; model0.paramOn(frame);; ; sigData->plotOn(frame, MarkerColor(kBlue));; frame->Draw();; ; for (auto text : {; ""No template uncertainties"",; ""are taken into account."",; ""This leads to low errors"",; ""for the parameters A, since"",; ""the only source of errors"",; ""are the data statistics.""}) {; pt.AddText(text);; }; pt.DrawClone();; ; ; can->cd(2);; frame = x.frame(Title(""Barlow Beeston for Sig & Bkg separately""));; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue), VisualizeError(*result1));; // Plot data again to show it on top of error bands:; sumData.plotOn(frame);; model1.plotOn(frame, LineColor(kBlue));; model1.plotOn(frame, Components(p_ph_sig1), LineColor(kAzure));; model1.plotOn(frame, Components(p_ph_bkg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:5272,error,error,5272,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,1,['error'],['error']
Availability,"_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; static RooRealVarSharedProperties_nullPropNull property; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot rang",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:36139,error,error,36139,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,3,['error'],['error']
Availability,"_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnPdfBinding.html:41462,error,errors,41462,root/html602/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnPdfBinding.html,4,['error'],['errors']
Availability,"_domain_len < (server_domain_len + 2)) {; 17698 /* Request is directed to another server: The server name; 17699 * is longer than the request name.; 17700 * Drop this case here to avoid overflows in the; 17701 * following checks. */; 17702 return 0;; 17703 }; 17704 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17705 /* Request is directed to another server: It could be a; 17706 * substring; 17707 * like notmyserver.com */; 17708 return 0;; 17709 }; 17710 if (0; 17711 != memcmp(server_domain,; 17712 hostbegin + request_domain_len - server_domain_len,; 17713 server_domain_len)) {; 17714 /* Request is directed to another server:; 17715 * The server name is different. */; 17716 return 0;; 17717 }; 17718 }; 17719 }; 17720 ; 17721 return hostend;; 17722}; 17723 ; 17724 ; 17725static int; 17726get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17727{; 17728 if (ebuf_len > 0) {; 17729 ebuf[0] = '\0';; 17730 }; 17731 *err = 0;; 17732 ; 17733 reset_per_request_attributes(conn);; 17734 ; 17735 if (!conn) {; 17736 mg_snprintf(conn,; 17737 NULL, /* No truncation check for ebuf */; 17738 ebuf,; 17739 ebuf_len,; 17740 ""%s"",; 17741 ""Internal error"");; 17742 *err = 500;; 17743 return 0;; 17744 }; 17745 ; 17746 /* Set the time the request was received. This value should be used for; 17747 * timeouts. */; 17748 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17749 ; 17750 conn->request_len =; 17751 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17752 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17753 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17754 mg_snprintf(conn,; 17755 NULL, /* No truncation check for ebuf */; 17756 ebuf,; 17757 ebuf_len,; 17758 ""%s"",; 17759 ""Invalid message size"");; 17760 *err = 500;; 17761 return 0;; 17762 }; 17763 ; 17764 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17765 mg_snprintf(conn,; 17766 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:527260,error,error,527260,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"_domain_len < (server_domain_len + 2)) {; 17699 /* Request is directed to another server: The server name; 17700 * is longer than the request name.; 17701 * Drop this case here to avoid overflows in the; 17702 * following checks. */; 17703 return 0;; 17704 }; 17705 if (hostbegin[request_domain_len - server_domain_len - 1] != '.') {; 17706 /* Request is directed to another server: It could be a; 17707 * substring; 17708 * like notmyserver.com */; 17709 return 0;; 17710 }; 17711 if (0; 17712 != memcmp(server_domain,; 17713 hostbegin + request_domain_len - server_domain_len,; 17714 server_domain_len)) {; 17715 /* Request is directed to another server:; 17716 * The server name is different. */; 17717 return 0;; 17718 }; 17719 }; 17720 }; 17721 ; 17722 return hostend;; 17723}; 17724 ; 17725 ; 17726static int; 17727get_message(struct mg_connection *conn, char *ebuf, size_t ebuf_len, int *err); 17728{; 17729 if (ebuf_len > 0) {; 17730 ebuf[0] = '\0';; 17731 }; 17732 *err = 0;; 17733 ; 17734 reset_per_request_attributes(conn);; 17735 ; 17736 if (!conn) {; 17737 mg_snprintf(conn,; 17738 NULL, /* No truncation check for ebuf */; 17739 ebuf,; 17740 ebuf_len,; 17741 ""%s"",; 17742 ""Internal error"");; 17743 *err = 500;; 17744 return 0;; 17745 }; 17746 ; 17747 /* Set the time the request was received. This value should be used for; 17748 * timeouts. */; 17749 clock_gettime(CLOCK_MONOTONIC, &(conn->req_time));; 17750 ; 17751 conn->request_len =; 17752 read_message(NULL, conn, conn->buf, conn->buf_size, &conn->data_len);; 17753 DEBUG_ASSERT(conn->request_len < 0 || conn->data_len >= conn->request_len);; 17754 if ((conn->request_len >= 0) && (conn->data_len < conn->request_len)) {; 17755 mg_snprintf(conn,; 17756 NULL, /* No truncation check for ebuf */; 17757 ebuf,; 17758 ebuf_len,; 17759 ""%s"",; 17760 ""Invalid message size"");; 17761 *err = 500;; 17762 return 0;; 17763 }; 17764 ; 17765 if ((conn->request_len == 0) && (conn->data_len == conn->buf_size)) {; 17766 mg_snprintf(conn,; 17767 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:527293,error,error,527293,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"_eMinimizerType=MinimizerType::fSteepest, double _learningRate=1e-5, double _momentum=0.3, int _repetitions=3, bool _multithreading=true);  c'tor ;  ; virtual ~Settings ();  d'tor ;  ; void addPoint (std::string histoName, double x);  for monitoring ;  ; void addPoint (std::string histoName, double x, double y);  for monitoring ;  ; size_t batchSize () const;  mini-batch size ;  ; void clear (std::string histoName);  for monitoring ;  ; virtual void computeResult (const Net &, std::vector< double > &);  callback for monitoring and logging ;  ; size_t convergenceCount () const;  returns the current convergence count ;  ; size_t convergenceSteps () const;  how many steps until training is deemed to have converged ;  ; void create (std::string histoName, int bins, double min, double max);  for monitoring ;  ; void create (std::string histoName, int bins, double min, double max, int bins2, double min2, double max2);  for monitoring ;  ; virtual void cycle (double progress, TString text);  ; virtual void drawSample (const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double);  callback for monitoring and logging ;  ; const std::vector< double > & dropFractions () const;  ; size_t dropRepetitions () const;  ; virtual void endTestCycle ();  callback for monitoring and loggging ;  ; virtual void endTrainCycle (double);  callback for monitoring and logging ;  ; bool exists (std::string histoName);  for monitoring ;  ; double factorWeightDecay () const;  get the weight-decay factor ;  ; virtual bool hasConverged (double testError);  has this training converged already? ;  ; double learningRate () const;  get the learning rate ;  ; size_t maxConvergenceCount () const;  returns the max convergence count so far ;  ; size_t minError () const;  returns the smallest error so far ;  ; MinimizerType minimizerType () const;  which minimizer shall be used (e.g. SGD) ;  ; double momentum () const;  get the momentum (e.g. for SGD) ;  ; void pads (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:2452,error,error,2452,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['error'],['error']
Availability,"_fft_Mf' created with bounds [0,3.14159]; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x77ddb60 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7953590 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7b5fca0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0 from preexisting content.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(Mf_over_Mf_Int[psi]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_Mf_over_Mf_Int[psi]_MfData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7caf5a0 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi] for nset () with code 1 from preexisting content.; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::getCache(Mf) creating new cache 0x7ef8390 with pdf Tpsi_CONV_Rpsi_CACHE_Obs[psi]_NORM_psi for nset (psi) with code 0; [#1] INFO:NumericIntegration -- RooRealIntegral::init(Tpsi_Int[psi]) using numeric integrator RooIntegrator1D to calculate Int(psi); [#1] INFO:Caching -- RooAbsCachedPdf::g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf210__angularconv_8py.html:5079,error,error,5079,doc/master/rf210__angularconv_8py.html,https://root.cern,https://root.cern/doc/master/rf210__angularconv_8py.html,1,['error'],['error']
Availability,"_handleLocalErrors; RooArgList*_initConstParamList; RooArgList*_initFloatParamList; ofstream*_logfile; Double_t_maxFCN; Int_t_nPar; Int_t_numBadNLL; Bool_t_optConst; Int_t_printEvalErrors; Int_t_printLevel; Bool_t_profile; Int_t_status; static TVirtualFitter*_theFitter; TStopwatch_timer; Bool_t_verbose; Int_t_warnLevel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinuit(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinuit(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), expensive FCNs (2); and 'intermediate' FCNs (1). void setErrorLevel(Double_t level); Set the level for MINUIT error analysis to the given; value. This function overrides the default value; that is taken in the RooMinuit constructor from; the defaultErrorLevel() method of the input function. void setEps(Double_t eps); Change MINUIT epsilon. RooFitResult* fit(const char* options); Parse traditional RooAbsPdf::fitTo driver options. s - Run Hesse first to estimate initial step size; m - Run Migrad only; h - Run Hesse to estim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinuit.html:8453,error,errors,8453,root/html526/RooMinuit.html,https://root.cern,https://root.cern/root/html526/RooMinuit.html,6,['error'],['errors']
Availability,"_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t typeDefinition TGWin32VirtualXProxy.cxx:249; namechar name[80]Definition TGX11.cxx:110; Util.h; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::fMinosParamsstd::vector< unsigned int > fMinosParamsvector with the parameter indices for running MinosDefinition FitConfig.h:266; ROOT::Fit::FitConfig::FitConfigFitConfig(unsigned int npar=0)Default constructor.Definition FitConfig.cxx:40; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::fNormErrorsbool fNormErrorsflag for error normalizationDefinition FitConfig.h:259; ROOT::Fit::FitConfig::ParamsValuesstd::vector< double > ParamsValues() constreturn a vector of stored parameter values (i.e initial fit parameters)Definition FitConfig.cxx:262; ROOT::Fit::FitConfig::MinimizerAlgoTypeconst std::string & MinimizerAlgoType() constreturn type of minimizer algorithmsDefinition FitConfig.h:192; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::NParunsigned int NPar() constnumber of parameters settingsDefinition FitConfig.h:96; ROOT::Fit::FitConfig::SetParamsSettingsvoid SetParamsSettings(unsigned int npar, const double *params, const double *vstep=nullptr)set the parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:11398,error,error,11398,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['error'],['error']
Availability,"_intminuit.py;   'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ;  ; file  rf602_chi2fit.C;   Likelihood and minimization: setting up a chi^2 fit to a binned dataset ;  ; file  rf602_chi2fit.py;   'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #602 ;  ; file  rf603_multicpu.C;   Likelihood and minimization: setting up a multi-core parallelized unbinned maximum likelihood fit ;  ; file  rf603_multicpu.py;   Likelihood and minimization: setting up a multi-core parallelized unbinned maximum likelihood fit ;  ; file  rf604_constraints.C;   Likelihood and minimization: fitting with constraints ;  ; file  rf604_constraints.py;   Likelihood and minimization: fitting with constraints ;  ; file  rf605_profilell.C;   Likelihood and minimization: working with the profile likelihood estimator ;  ; file  rf605_profilell.py;   'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #605 ;  ; file  rf606_nllerrorhandling.C;   Likelihood and minimization: understanding and customizing error handling in likelihood evaluations ;  ; file  rf606_nllerrorhandling.py;   'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #606 ;  ; file  rf607_fitresult.C;   Likelihood and minimization: demonstration of options of the RooFitResult class ;  ; file  rf607_fitresult.py;   Likelihood and minimization: demonstration of options of the RooFitResult class ;  ; file  rf608_fitresultaspdf.C;   Likelihood and minimization: representing the parabolic approximation of the fit as a multi-variate Gaussian on the parameters of the fitted pdf ;  ; file  rf608_fitresultaspdf.py;   Likelihood and minimization: representing the parabolic approximation of the fit as a multi-variate Gaussian on the parameters of the fitted pdf ;  ; file  rf609_xychi2fit.C;   Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) ;  ; file  rf609_xychi2fit.py;   Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:16814,error,error,16814,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['error'],['error']
Availability,"_namePtr = nullptr;  Pointer to global cache manager for any expensive components created by this object. ;  ; OperMode _operMode = Auto;  ; RooArgSet * _ownedComponents = nullptr;  ; bool _prohibitServerRedirect = false;  Set of owned component. ;  ; RooRefArray _proxyList;  ; ProxyListCache _proxyListCache;  ; RefCountList_t _serverList;  ; bool _shapeDirty = true;  ; std::map< std::string, std::string > _stringAttrib;  ; bool _valueDirty = true;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Static Protected Attributes; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . Private Member Functions; double _DEBUG_getVal (const RooArgSet *normalisationSet) const;  Debug version of getVal(), which is slow and does error checking. ;  . Friends; class AddCacheElem;  ; class BatchInterfaceAccessor;  ; class RooAddHelpers;  ; class RooAddModel;  ; class RooAddPdf;  ; class RooFit::EvalContext;  ; class RooRealBinding;  ; class RooRealSumFunc;  ; class RooRealSumPdf;  ; class RooVectorDataStore;  . Additional Inherited Members;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . #include <RooAbsReal.h>. Inheritance diagram for RooAbsReal:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:59804,error,error,59804,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,"_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11898,error,error,11898,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['error'],['error']
Availability,"_p := Q(p) is defined as the value x_p such that the cumulative probability distribution Function F of variable X yields: ;  ; virtual Double_t GetRandom (TRandom *rng=nullptr) const;  Return a random number distributed according the histogram bin contents. ;  ; Double_t GetRMS (Int_t axis=1) const;  This function returns the Standard Deviation (Sigma) of the distribution not the Root Mean Square (RMS). ;  ; Double_t GetRMSError (Int_t axis=1) const;  ; virtual Double_t GetSkewness (Int_t axis=1) const;  ; EStatOverflows GetStatOverflows () const;  Get the behaviour adopted by the object about the statoverflows. See EStatOverflows for more information. ;  ; virtual void GetStats (Double_t *stats) const;  fill the array stats from the contents of this histogram The array stats must be correctly dimensioned in the calling program. ;  ; virtual Double_t GetStdDev (Int_t axis=1) const;  Returns the Standard Deviation (Sigma). ;  ; virtual Double_t GetStdDevError (Int_t axis=1) const;  Return error of standard deviation estimation for Normal distribution. ;  ; virtual Double_t GetSumOfWeights () const;  Return the sum of weights excluding under/overflows. ;  ; virtual TArrayD * GetSumw2 ();  ; virtual const TArrayD * GetSumw2 () const;  ; virtual Int_t GetSumw2N () const;  ; virtual Float_t GetTickLength (Option_t *axis=""X"") const;  Return the ""axis"" tick length. ;  ; virtual Style_t GetTitleFont (Option_t *axis=""X"") const;  Return the ""axis"" title font. ;  ; virtual Float_t GetTitleOffset (Option_t *axis=""X"") const;  Return the ""axis"" title offset. ;  ; virtual Float_t GetTitleSize (Option_t *axis=""X"") const;  Return the ""axis"" title size. ;  ; TAxis * GetXaxis ();  ; const TAxis * GetXaxis () const;  ; TAxis * GetYaxis ();  ; const TAxis * GetYaxis () const;  ; TAxis * GetZaxis ();  ; const TAxis * GetZaxis () const;  ; virtual Double_t Integral (Int_t binx1, Int_t binx2, Option_t *option="""") const;  Return integral of bin contents in range [binx1,binx2]. ;  ; virtual D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:37804,error,error,37804,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,8,['error'],['error']
Availability,"_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=14.3535, denominator=wrap_pdf_Int[pTV]=34082.1; getLogVal() top-leve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:14898,error,error,14898,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['error'],['error']
Availability,"_printLevel; Bool_t_profile; Int_t_status; static ROOT::Fit::Fitter*_theFitter; TStopwatch_timer; Bool_t_verbose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void cleanup(); Cleanup method called by atexit handler installed by RooSentinel; to delete all global heap objects when the program is terminated. RooMinimizer(RooAbsReal& function); Construct MINUIT interface to given function. Function can be anything,; but is typically a -log(likelihood) implemented by RooNLLVar or a chi^2; (implemented by RooChi2Var). Other frequent use cases are a RooAddition; of a RooNLLVar plus a penalty or constraint term. This class propagates; all RooFit information (floating parameters, their values and errors); to MINUIT before each MINUIT call and propagates all MINUIT information; back to the RooFit object at the end of each call (updated parameter; values, their (asymmetric errors) etc. The default MINUIT error level; for HESSE and MINOS error analysis is taken from the defaultErrorLevel(); value of the input function. ~RooMinimizer(); Destructor. void setStrategy(Int_t strat); Change MINUIT strategy to istrat. Accepted codes; are 0,1,2 and represent MINUIT strategies for dealing; most efficiently with fast FCNs (0), expensive FCNs (2); and 'intermediate' FCNs (1). void setErrorLevel(Double_t level); Set the level for MINUIT error analysis to the given; value. This function overrides the default value; that is taken in the RooMinimizer constructor from; the defaultErrorLevel() method of the input function. void setEps(Double_t eps); Change MINUIT epsilon. void setMinimizerType(const char* type); Choose the minimzer algorithm. RooFitResult* fit(const char* options); Parse traditional RooAbsPdf::fitTo driver options. m - Run Migrad only; h - Run Hesse to estimate errors; v - Verbose mode; l - Log parameters after each Minuit steps to file; t - Activate profile timer; r - Save fit result; 0 - Run Migrad with strategy 0. Int_t minimize(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinimizer.html:8271,error,error,8271,root/html526/RooMinimizer.html,https://root.cern,https://root.cern/root/html526/RooMinimizer.html,6,['error'],['error']
Availability,"_ptr< PrevNode_t > ; pd . ). inline . Definition at line 52 of file RRange.hxx. ◆ RRange() [2/2]. template<typename PrevNodeRaw > . ROOT::Detail::RDF::RRange< PrevNodeRaw >::RRange ; (; const RRange< PrevNodeRaw > & ; ). delete . ◆ ~RRange(). template<typename PrevNodeRaw > . ROOT::Detail::RDF::RRange< PrevNodeRaw >::~RRange ; (; ). inline . Definition at line 64 of file RRange.hxx. Member Function Documentation. ◆ AddFilterName(). template<typename PrevNodeRaw > . void ROOT::Detail::RDF::RRange< PrevNodeRaw >::AddFilterName ; (; std::vector< std::string > & ; filters). inlinefinalvirtual . This function must be defined by all nodes, but only the filters will add their name. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 115 of file RRange.hxx. ◆ CheckFilters(). template<typename PrevNodeRaw > . bool ROOT::Detail::RDF::RRange< PrevNodeRaw >::CheckFilters ; (; unsigned int ; slot, . Long64_t ; entry . ). inlinefinalvirtual . Ranges act as filters when it comes to selecting entries that downstream nodes should process. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 67 of file RRange.hxx. ◆ GetGraph(). template<typename PrevNodeRaw > . std::shared_ptr< RDFGraphDrawing::GraphNode > ROOT::Detail::RDF::RRange< PrevNodeRaw >::GetGraph ; (; std::unordered_map< void *, std::shared_ptr< RDFGraphDrawing::GraphNode > > & ; visitedMap). inlinefinalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 117 of file RRange.hxx. ◆ GetVariedFilter(). template<typename PrevNodeRaw > . std::shared_ptr< RNodeBase > ROOT::Detail::RDF::RRange< PrevNodeRaw >::GetVariedFilter ; (; const std::string & ; ). inlinefinalvirtual . Return a clone of this node that acts as a Filter working with values in the variationName ""universe"". ; Reimplemented from ROOT::Detail::RDF::RNodeBase.; Definition at line 151 of file RRange.hxx. ◆ IncrChildrenCount(). template<typename PrevNodeRaw > . void ROOT::Detail::RDF::RRange< PrevNodeRaw >::IncrChildrenCount ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RRange.html:5168,down,downstream,5168,doc/master/classROOT_1_1Detail_1_1RDF_1_1RRange.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RRange.html,1,['down'],['downstream']
Availability,"_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Bool_tTEveCaloData::Empty() const; voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Float_tTEveCaloData::EtaToTheta(Float_t eta); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveCaloData::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloDataHist.html:4659,error,error,4659,root/html528/TEveCaloDataHist.html,https://root.cern,https://root.cern/root/html528/TEveCaloDataHist.html,10,['error'],['error']
Availability,"_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Bool_tTEveCaloData::Empty() const; voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static Float_tTEveCaloData::EtaToTheta(Float_t eta); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveCaloData::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); voidFillSlice(Int_t slice, Float_t value); voidFillSlice(Int_t slice, Int_t tower, Float_t value); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& match",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCaloDataVec.html:4659,error,error,4659,root/html528/TEveCaloDataVec.html,https://root.cern,https://root.cern/root/html528/TEveCaloDataVec.html,10,['error'],['error']
Availability,"_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); voidEqualizeFrames()MENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveWindowPack.html:5101,error,error,5101,root/html528/TEveWindowPack.html,https://root.cern,https://root.cern/root/html528/TEveWindowPack.html,10,['error'],['error']
Availability,"_t * GetDrawOption() constGet option used by the graphics system to draw this object.Definition TObject.cxx:428; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::MayNotUsevoid MayNotUse(const char *method) constUse this method to signal that a method (defined in a base class) may not be called in a derived clas...Definition TObject.cxx:1046; TObject::DrawClonevirtual TObject * DrawClone(Option_t *option="""") constDraw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1).Definition TObject.cxx:305; TObject::ExecuteEventvirtual void ExecuteEvent(Int_t event, Int_t px, Int_t py)Execute action corresponding to an event at (px,py).Definition TObject.cxx:398; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Executevirtual void Execute(const char *method, const char *params, Int_t *error=nullptr)Execute method on this object with the given parameter string, e.g.Definition TObject.cxx:364; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::GetObjectInfovirtual char * GetObjectInfo(Int_t px, Int_t py) constReturns string containing info about the object at position (px,py).Definition TObject.cxx:473; TObject::SavePrimitivevirtual void SavePrimitive(std::ostream &out, Option_t *option="""")Save a primitive as a C++ statement(s) on output stream ""out"".Definition TObject.cxx:757; TObject::IsZombieR__ALWAYS_INLINE Bool_t IsZombie() constDefinition TObject.h:153; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::kOnlyPrepStep@ kOnlyPrepStepUsed to request that the class specific implementation of TObject::Write just prepare the objects to ...Definition TObject.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8h_source.html:26730,error,error,26730,doc/master/TObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TObject_8h_source.html,1,['error'],['error']
Availability,"_t *) const =0;  ; virtual const char * MethodInfo_Title (MethodInfo_t *) const;  ; virtual TypeInfo_t * MethodInfo_Type (MethodInfo_t *) const;  ; virtual const char * MethodInfo_TypeName (MethodInfo_t *) const;  ; virtual std::string MethodInfo_TypeNormalizedName (MethodInfo_t *) const;  ; virtual void PrintIntro ()=0;  ; virtual Longptr_t ProcessLine (const char *line, EErrorCode *error=nullptr)=0;  ; virtual Longptr_t ProcessLineSynch (const char *line, EErrorCode *error=nullptr)=0;  ; virtual void RegisterModule (const char *, const char **, const char **, const char *, const char *, void(*)(), const FwdDeclArgsToKeepCollection_t &fwdDeclArgsToKeep, const char **classesHeaders, Bool_t lateRegistration=false, Bool_t hasCxxModule=false)=0;  ; virtual bool RegisterPrebuiltModulePath (const std::string &FullPath, const std::string &ModuleMapName=""module.modulemap"") const =0;  ; virtual void RegisterTClassUpdate (TClass *oldcl, DictFuncPtr_t dict)=0;  ; virtual Int_t ReloadAllSharedLibraryMaps ()=0;  ; virtual void ReportDiagnosticsToErrorHandler (bool=true);  Report diagnostics to the ROOT error handler (see TError.h). ;  ; virtual Int_t RescanLibraryMap ()=0;  ; virtual void Reset ()=0;  ; virtual void ResetAll ()=0;  ; virtual void ResetGlobals ()=0;  ; virtual void ResetGlobalVar (void *obj)=0;  ; virtual void RewindDictionary ()=0;  ; virtual void SaveContext ()=0;  ; virtual void SaveGlobalsContext ()=0;  ; virtual void SetAlloclockfunc (void(*)()) const;  ; virtual void SetAllocunlockfunc (void(*)()) const;  ; virtual void * SetAutoLoadCallBack (void *);  ; int SetClassAutoloading (int a) const;  ; virtual int SetClassAutoLoading (int) const;  ; virtual int SetClassAutoparsing (int);  ; virtual void SetClassInfo (TClass *cl, Bool_t reload=kFALSE, Bool_t silent=kFALSE)=0;  ; virtual Int_t SetClassSharedLibs (const char *cls, const char *libs)=0;  ; virtual void SetDeclAttr (DeclId_t, const char *)=0;  ; virtual void SetErrmsgcallback (void *) const;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTInterpreter.html:21833,error,error,21833,doc/master/classTInterpreter.html,https://root.cern,https://root.cern/doc/master/classTInterpreter.html,1,['error'],['error']
Availability,"_t *, Axis_t xmin, Axis_t xmax); 527{; 528 char *linear = (char*)strstr(fname, ""++"");; 529 if (linear) {; 530 TF1 f1(fname, fname, xmin, xmax);; 531 return Fit(&f1,option,"""",xmin,xmax);; 532 }; 533 TF1 * f1 = (TF1*)gROOT->GetFunction(fname);; 534 if (!f1) { Printf(""Unknown function: %s"",fname); return -1; }; 535 ; 536 return Fit(f1,option,"""",xmin,xmax);; 537}; 538 ; 539 ; 540////////////////////////////////////////////////////////////////////////////////; 541/// Fit this multigraph with function f1.; 542///; 543/// In this function all graphs of the multigraph are fitted simultaneously; 544///; 545/// f1 is an already predefined function created by TF1.; 546/// Predefined functions such as gaus, expo and poln are automatically; 547/// created by ROOT.; 548///; 549/// The list of fit options is given in parameter `option`which may takes the; 550/// following values:; 551///; 552/// - ""W"" Ignore all the point errors; 553/// - ""U"" Use a User specified fitting algorithm (via SetFCN); 554/// - ""Q"" Quiet mode (minimum printing); 555/// - ""V"" Verbose mode (default is between Q and V); 556/// - ""B"" Use this option when you want to fix one or more parameters; 557/// and the fitting function is like ""gaus"",""expo"",""poln"",""landau"".; 558/// - ""R"" Use the Range specified in the function range; 559/// - ""N"" Do not store the graphics function, do not draw; 560/// - ""0"" Do not plot the result of the fit. By default the fitted function; 561/// is drawn unless the option""N"" above is specified.; 562/// - ""+"" Add this new fitted function to the list of fitted functions; 563/// (by default, any previous function is deleted); 564/// - ""C"" In case of linear fitting, not calculate the chisquare (saves time); 565/// - ""F"" If fitting a polN, switch to minuit fitter; 566/// - ""ROB"" In case of linear fitting, compute the LTS regression; 567/// coefficients (robust(resistant) regression), using; 568/// the default fraction of good points; 569/// - ""ROB=0.x"" - compute the LTS regression coefficie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMultiGraph_8cxx_source.html:16210,error,errors,16210,doc/master/TMultiGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html,1,['error'],['errors']
Availability,"_t *eyL)Set error e eyL values.Definition TGraphMultiErrors.cxx:1982; TGraphMultiErrors::fAttFillstd::vector< TAttFill > fAttFillThe AttFill attributes of the different errors.Definition TGraphMultiErrors.h:41; TGraphMultiErrors::UpdateArraysvoid UpdateArrays(const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) overrideUpdate the fX, fY, fExL, fExH, fEyL and fEyH arrays with the sorted values.Definition TGraphMultiErrors.cxx:885; TGraphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetLineColorvirtual void SetLineColor(Int_t e, Color_t lcolor)Set Line Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2073; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiError",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:86473,error,error,86473,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"_t *opt) overrideTTreeinlinevirtual; Draw(const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)TTreevirtual; Draw(const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)TTreevirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; DropBaskets()TTreevirtual; DropBranchFromCache(const char *bname, bool subbranches=false)TTreevirtual; DropBranchFromCache(TBranch *branch, bool subbranches=false)TTreevirtual; DropBuffers(Int_t nbytes)TTreevirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; ELockStatusBits enum nameTTreeprotected; EnableCache()TTree; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; ESetBranchAddressStatus enum nameTTree; EStatusBits enum nameTTree; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; fAliasesTTreeprotected; fAllocationCountTTreemutableprotected; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fAutoFlushTTreeprotected; fAutoSaveTTreeprotected; fBitsTObjectprivate; fBranchesTTreeprotected; fBranchRefTTreeprotected; fCacheDoAutoInitTTreeprotected; fCacheDoClusterPrefetchTTreeprotected; fCacheSizeTTreeprotected; fCacheUserSetTTreeprotected; fChainOffsetTTreeprotected; fClonesTTreeprotected; fClusterRangeEndTTreeprotected; fClusterSizeTTreeprotected; fDebugTTreeprotected; fDebugMaxTTreeprotected; fDebugMinTTreeprotected; fDefaultEntryOffsetLenTTreeprotected; fDirectoryTTreeprotected; fEntriesTTreeprotected; fEntryListTTreeprotected; fEstimateTTreeprotected; fEventListTTreeprotected; fExternalFriendsTTreeprotected; fFileNumberTTreeprotected; fFillColorTAttFillprotected; fFillStyleTAttFillprotected; fFlushedBytesTTreeprotected; fFriendLockStatusTT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree-members.html:5851,error,error,5851,doc/master/classTTree-members.html,https://root.cern,https://root.cern/doc/master/classTTree-members.html,2,['error'],['error']
Availability,"_t * ; a, . Int_t ; nb, . const Double_t * ; b, . Option_t * ; option . ). Statistical test whether two one-dimensional sets of points are compatible with coming from the same parent distribution, using the Kolmogorov test. ; That is, it is used to compare two experimental distributions of unbinned data. Input:; a,b: One-dimensional arrays of length na, nb, respectively. The elements of a and b must be given in ascending order. option is a character string to specify options ""D"" Put out a line of ""Debug"" printout ""M"" Return the Maximum Kolmogorov distance instead of prob. Output:; The returned value prob is a calculated confidence level which gives a statistical test for compatibility of a and b. Values of prob close to zero are taken as indicating a small probability of compatibility. For two point sets drawn randomly from the same parent distribution, the value of prob should be uniformly distributed between zero and one. in case of error the function return -1 If the 2 sets have a different number of points, the minimum of the two sets is used. Method:; The Kolmogorov test is used. The test statistic is the maximum deviation between the two integrated distribution functions, multiplied by the normalizing factor (rdmax*sqrt(na*nb/(na+nb)).; Code adapted by Rene Brun from CERNLIB routine TKOLMO (Fred James) (W.T. Eadie, D. Drijard, F.E. James, M. Roos and B. Sadoulet, Statistical Methods in Experimental Physics, (North-Holland, Amsterdam 1971) 269-271). Method Improvement by Jason A Detwiler (JADetwiler@lbl.gov); The nuts-and-bolts of the TMath::KolmogorovTest() algorithm is a for-loop over the two sorted arrays a and b representing empirical distribution functions. The for-loop handles 3 cases: when the next points to be evaluated satisfy a>b, a<b, or a=b:; for (Int_t i=0;i<na+nb;i++) {; if (a[ia-1] < b[ib-1]) {; rdiff -= sa;; ia++;; if (ia > na) {ok = kTRUE; break;}; } else if (a[ia-1] > b[ib-1]) {; rdiff += sb;; ib++;; if (ib > nb) {ok = kTRUE; break;}; } else {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:52047,error,error,52047,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['error'],['error']
Availability,"_t * ; option = """"); const. overridevirtual . Print information about this object. ; If option contains 'L' a long listing will be printed (on multiple lines). Otherwise one line is printed with the following information: current url, default tree name|class|entries, md5; the default tree name is passed via the option (""T:<default_tree>"") by the owning TFileCollection. ; Reimplemented from TObject.; Definition at line 478 of file TFileInfo.cxx. ◆ RemoveMetaData(). Bool_t TFileInfo::RemoveMetaData ; (; const char * ; meta = nullptr). Remove the metadata object. ; If meta is 0 remove all meta data objects. Returns kTRUE if successful, kFALSE otherwise. ; Definition at line 402 of file TFileInfo.cxx. ◆ RemoveUrl(). Bool_t TFileInfo::RemoveUrl ; (; const char * ; url). Remove an URL. Returns kTRUE if successful, kFALSE otherwise. ; Definition at line 321 of file TFileInfo.cxx. ◆ RemoveUrlAt(). Bool_t TFileInfo::RemoveUrlAt ; (; Int_t ; i). Remove URL at given position. Returns kTRUE on success, kFALSE on error. ; Definition at line 337 of file TFileInfo.cxx. ◆ ResetUrl(). void TFileInfo::ResetUrl ; (; ). inline . Definition at line 69 of file TFileInfo.h. ◆ SetCurrentUrl() [1/2]. Bool_t TFileInfo::SetCurrentUrl ; (; const char * ; url). Set 'url' as current URL, if in the list Return kFALSE if not in the list. ; Definition at line 355 of file TFileInfo.cxx. ◆ SetCurrentUrl() [2/2]. Bool_t TFileInfo::SetCurrentUrl ; (; TUrl * ; url). Set 'url' as current URL, if in the list Return kFALSE if not in the list. ; Definition at line 369 of file TFileInfo.cxx. ◆ SetIndex(). void TFileInfo::SetIndex ; (; Int_t ; idx). inline . Definition at line 100 of file TFileInfo.h. ◆ SetSize(). void TFileInfo::SetSize ; (; Long64_t ; size). inline . Definition at line 86 of file TFileInfo.h. ◆ SetUUID(). void TFileInfo::SetUUID ; (; const char * ; uuid). Set the UUID to the value associated to the string 'uuid'. ; This is useful to set the UUID to the one of the ROOT file during verificatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileInfo.html:20613,error,error,20613,doc/master/classTFileInfo.html,https://root.cern,https://root.cern/doc/master/classTFileInfo.html,1,['error'],['error']
Availability,"_t * GetPL0 () const;  ; Int_t GetStats (Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const override;  Return global fit parameters. ;  ; Double_t GetSumLog (Int_t) override;  Return Sum(log(i) i=0,n used by log-likelihood fits. ;  ; Double_t * GetZ () const;  ; void InvertZ (Int_t);  Inverts packed diagonal matrix Z by square-root method. ;  ; TClass * IsA () const override;  ; Bool_t IsFixed (Int_t ipar) const override;  Return kTRUE if parameter ipar is fixed, kFALSE otherwise) ;  ; Int_t Minimize ();  Main minimization procedure. ;  ; void PrintResults (Int_t k, Double_t p) const override;  Prints fit results. ;  ; void ReleaseParameter (Int_t ipar) override;  Releases parameter number ipar. ;  ; void SetData (Double_t *, Int_t, Int_t);  Sets pointer to data array provided by user. ;  ; void SetFitMethod (const char *name) override;  ret fit method (chisquare or log-likelihood) ;  ; Int_t SetParameter (Int_t ipar, const char *parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh) override;  Sets for parameter number ipar initial parameter value, name parname, initial error verr and limits vlow and vhigh. ;  ; void SetParNumber (Int_t ParNum);  ; Int_t SGZ ();  Evaluates objective function ( chi-square ), gradients and Z-matrix using data provided by user via TFumili::SetData. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TVirtualFitter;  TVirtualFitter ();  Default constructor. ;  ;  ~TVirtualFitter () override;  Cleanup virtual fitter. ;  ; virtual void GetConfidenceIntervals (Int_t n, Int_t ndim, const Double_t *x, Double_t *ci, Double_t cl=0.95);  return confidence intervals in array x of dimension ndim implemented in TFitter and TLinearFitter ;  ; virtual void GetConfidenceIntervals (TObject *obj, Double_t cl=0.95);  return confidence intervals in TObject obj implemented in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:7482,error,error,7482,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['error'],['error']
Availability,"_t >::~VGeneralLayer. virtual . Virtual Destructor. ; Definition at line 388 of file GeneralLayer.h. Member Function Documentation. ◆ AddWeightsXMLTo(). template<typename Architecture_t > . virtual void TMVA::DNN::VGeneralLayer< Architecture_t >::AddWeightsXMLTo ; (; void * ; parent). pure virtual . Writes the information and the weights about the layer in an XML node. ; Implemented in TMVA::DNN::TBatchNormLayer< Architecture_t >, TMVA::DNN::CNN::TConvLayer< Architecture_t >, TMVA::DNN::CNN::TMaxPoolLayer< Architecture_t >, TMVA::DNN::TDenseLayer< Architecture_t >, TMVA::DNN::TReshapeLayer< Architecture_t >, TMVA::DNN::RNN::TBasicGRULayer< Architecture_t >, TMVA::DNN::RNN::TBasicLSTMLayer< Architecture_t >, and TMVA::DNN::RNN::TBasicRNNLayer< Architecture_t >. ◆ Backward(). template<typename Architecture_t > . virtual void TMVA::DNN::VGeneralLayer< Architecture_t >::Backward ; (; Tensor_t & ; gradients_backward, . const Tensor_t & ; activations_backward . ). pure virtual . Backpropagates the error. ; Must only be called directly at the corresponding call to Forward(...). ; Implemented in TMVA::DNN::TBatchNormLayer< Architecture_t >, TMVA::DNN::CNN::TConvLayer< Architecture_t >, TMVA::DNN::CNN::TMaxPoolLayer< Architecture_t >, TMVA::DNN::TDenseLayer< Architecture_t >, TMVA::DNN::TReshapeLayer< Architecture_t >, TMVA::DNN::RNN::TBasicGRULayer< Architecture_t >, TMVA::DNN::RNN::TBasicLSTMLayer< Architecture_t >, and TMVA::DNN::RNN::TBasicRNNLayer< Architecture_t >. ◆ CopyBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::CopyBiases ; (; const std::vector< Matrix_t > & ; otherBiases). Copies the biases provided as an input. ; Definition at line 468 of file GeneralLayer.h. ◆ CopyParameters(). template<typename Architecture_t > . template<typename Arch > . void TMVA::DNN::VGeneralLayer< Architecture_t >::CopyParameters ; (; const VGeneralLayer< Arch > & ; layer). Copy all trainable weight and biases from another equivalent laye",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:11088,error,error,11088,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['error'],['error']
Availability,"_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Int_t ReadBufferViaCache(char* buf, Int_t len); Read buffer via cache. Returns 0 if the requested block is; not in the cache, 1 in case read via cache was successful,; 2 in case read via cache failed. void ReadFree(); Read the FREE linked list.; Every file has a linked list (fFree) of free segments.; This linked list has been written on the file via WriteFree; as a single data record. TProcessID * ReadProcessID(UShort_t pidf); The TProcessID with number pidf is read from this file.; If the object is not already entered in the gROOT list, it is added. Int_t Recover(); Attempt to recover file if not correctly closed.; The function returns the number of keys that have been recovered.; If no keys can be recovered, the file will be declared Zombie by; the calling function. This function is automatically called when; opening a file. If the file is open in read only mode, the file is not modified.; If open in update mode and the function finds something to recover,; a new directory header is written to the file. When opening the file gain; no message from Recover will be reported.; If keys have been recovered, the file is usable and you can safely; read the corresponding objects.; If the file is not usable (a zombie), you can test for this case; with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {file is unusable); If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; You can test if the file has been recovered with; if (f.TestBit(TFile::kRecovered)) {.. the file has been recovered}. When writing TTrees to a file, it is important to save the Tree header; at regular intervals (see TTree::Auto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:34608,recover,recovered,34608,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,10,['recover'],['recovered']
Availability,"_t RooAbsGenContext::defaultPrintContents ; (; Option_t * ; opt); const. overridevirtual . Define default contents when printing. ; Reimplemented from RooPrintable.; Definition at line 367 of file RooAbsGenContext.cxx. ◆ defaultPrintStyle(). RooPrintable::StyleOption RooAbsGenContext::defaultPrintStyle ; (; Option_t * ; opt); const. overridevirtual . Define default print style. ; Reimplemented from RooPrintable.; Definition at line 377 of file RooAbsGenContext.cxx. ◆ generate(). RooDataSet * RooAbsGenContext::generate ; (; double ; nEvents = 0, . bool ; skipInit = false, . bool ; extendedMode = false . ). virtual . Generate the specified number of events with nEvents>0 and and return a dataset containing the generated events. ; With nEvents<=0, generate the number of events in the prototype dataset, if available, or else the expected number of events, if non-zero. If extendedMode = true generate according to a Poisson(nEvents) The returned dataset belongs to the caller. Return zero in case of an error. Generation of individual events is delegated to a virtual generateEvent() method. A virtual initGenerator() method is also called just before the first call to generateEvent(). ; Reimplemented in RooSimSplitGenContext, and RooBinnedGenContext.; Definition at line 130 of file RooAbsGenContext.cxx. ◆ generateEvent(). virtual void RooAbsGenContext::generateEvent ; (; RooArgSet & ; theEvent, . Int_t ; remaining . ). pure virtual . Implemented in RooAddGenContext, RooBinnedGenContext, RooConvGenContext, RooEffGenContext, RooGenContext, RooProdGenContext, RooSimGenContext, and RooSimSplitGenContext. ◆ initGenerator(). void RooAbsGenContext::initGenerator ; (; const RooArgSet & ; theEvent). virtual . Interface function to initialize context for generation for given set of observables. ; Reimplemented in RooAddGenContext, RooBinnedGenContext, RooConvGenContext, RooEffGenContext, RooGenContext, RooProdGenContext, RooSimGenContext, and RooSimSplitGenContext.; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsGenContext.html:19009,error,error,19009,doc/master/classRooAbsGenContext.html,https://root.cern,https://root.cern/doc/master/classRooAbsGenContext.html,1,['error'],['error']
Availability,"_t TDavixFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 756 of file TDavixFile.cxx. ◆ ReadBufferAsync(). Bool_t TDavixFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented from TFile.; Definition at line 774 of file TDavixFile.cxx. ◆ ReadBuffers(). Bool_t TDavixFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 790 of file TDavixFile.cxx. ◆ Seek(). void TDavixFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos = kBeg . ). virtual . Set position from where to start reading. ; Reimplemented from TFile.; Definition at line 710 of file TDavixFile.cxx. ◆ setCACheck(). void TDavixFile::setCACheck ; (; Bool_t ; check). Enable or disable certificate authority check. ; Definition at line 827 of file TDavixFile.cxx. ◆ Streamer(). virtual void TDavixFile::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TDavixFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 128 of file TDavixFile.h. ◆ WriteBuffer(). Bool_t TDavixFile::WriteBuffer ; (; const char * ; buf, . Int_t ; len . ). virtual . Write a buffer to the file. ; This is the basic low level write operation. Returns kTRUE in case of failure. ; Reimplement",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:46899,failure,failure,46899,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['failure'],['failure']
Availability,"_t TPSocket::GetDescriptor ; (; ); const. overridevirtual . Return socket descriptor. ; Reimplemented from TSocket.; Definition at line 467 of file TPSocket.cxx. ◆ GetErrorCode(). Int_t TPSocket::GetErrorCode ; (; ); const. Returns error code. ; Meaning depends on context where it is called. If no error condition returns 0 else a value < 0. ; Definition at line 783 of file TPSocket.cxx. ◆ GetLocalInetAddress(). TInetAddress TPSocket::GetLocalInetAddress ; (; ). overridevirtual . Return internet address of local host to which the socket is bound. ; In case of error TInetAddress::IsValid() returns kFALSE. ; Reimplemented from TSocket.; Definition at line 451 of file TPSocket.cxx. ◆ GetOption() [1/2]. Option_t * TPSocket::GetOption ; (; ); const. inlineoverrideprivatevirtual . Reimplemented from TObject.; Definition at line 51 of file TPSocket.h. ◆ GetOption() [2/2]. Int_t TPSocket::GetOption ; (; ESockOptions ; opt, . Int_t & ; val . ). overridevirtual . Get socket options. Returns -1 in case of error. ; Reimplemented from TSocket.; Definition at line 768 of file TPSocket.cxx. ◆ GetSize(). Int_t TPSocket::GetSize ; (; ); const. inline . Definition at line 83 of file TPSocket.h. ◆ Init(). void TPSocket::Init ; (; Int_t ; tcpwindowsize, . TSocket * ; sock = nullptr . ). private . Create a parallel socket to the specified host. ; Definition at line 356 of file TPSocket.cxx. ◆ IsA(). TClass * TPSocket::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 85 of file TPSocket.h. ◆ IsValid(). Bool_t TPSocket::IsValid ; (; ); const. inlineoverridevirtual . Reimplemented from TSocket.; Definition at line 79 of file TPSocket.h. ◆ operator=(). void TPSocket::operator= ; (; const TPSocket & ; ). privatedelete . ◆ Recv() [1/4]. Int_t TPSocket::Recv ; (; char * ; str, . Int_t ; max . ). inlineoverridevirtual . Receive a character string message of maximum max length. ; The expected message must be of type",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:25163,error,error,25163,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['error'],['error']
Availability,"_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 240 of file TSQLFile.h. ◆ ReOpen(). Int_t TSQLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 719 of file TSQLFile.cxx. ◆ RequestSQLClassInfo() [1/2]. TSQLClassInfo * TSQLFile::RequestSQLClassInfo ; (; const char * ; clnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:85377,recover,recovered,85377,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Availability,"_t TUnixSystem::DynFindSymbol ; (; const char * ; module, . const char * ; entry . ). overridevirtual . dynamic linking of module ; Reimplemented from TSystem.; Definition at line 2814 of file TUnixSystem.cxx. ◆ Exec(). int TUnixSystem::Exec ; (; const char * ; shellcmd). overridevirtual . Execute a command. ; Reimplemented from TSystem.; Definition at line 2155 of file TUnixSystem.cxx. ◆ Exit(). void TUnixSystem::Exit ; (; int ; code, . Bool_t ; mode = kTRUE . ). overridevirtual . Exit the application. ; Reimplemented from TSystem.; Definition at line 2187 of file TUnixSystem.cxx. ◆ ExpandPathName() [1/2]. char * TUnixSystem::ExpandPathName ; (; const char * ; path). overridevirtual . Expand a pathname getting rid of special shell characaters like ~. ; $, etc. For Unix/Win32 compatibility use instead of $XXX when using environment variables in a pathname. If compatibility is not an issue you can use on Unix directly $XXX. The user must delete returned string. Returns the expanded pathname or 0 in case of error. The user must delete returned string (delete []). ; Reimplemented from TSystem.; Definition at line 1882 of file TUnixSystem.cxx. ◆ ExpandPathName() [2/2]. Bool_t TUnixSystem::ExpandPathName ; (; TString & ; path). overridevirtual . Expand a pathname getting rid of special shell characters like ~. ; $, etc. For Unix/Win32 compatibility use instead of $XXX when using environment variables in a pathname. If compatibility is not an issue you can use on Unix directly $XXX. Returns kFALSE in case of success or kTRUE in case of error. ; Reimplemented from TSystem.; Definition at line 1749 of file TUnixSystem.cxx. ◆ FillWithCwd(). void TUnixSystem::FillWithCwd ; (; char * ; cwd); const. private . Fill buffer with current working directory. ; Definition at line 1473 of file TUnixSystem.cxx. ◆ FindDynamicLibrary(). const char * TUnixSystem::FindDynamicLibrary ; (; TString & ; sLib, . Bool_t ; quiet = kFALSE . ). overridevirtual . Returns the path of a shared library (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:46070,error,error,46070,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability,"_t TXMLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented from TFile.; Definition at line 86 of file TXMLFile.h. ◆ ReOpen(). Int_t TXMLFile::ReOpen ; (; Option_t * ; mode). finalvirtual . Reopen a file with a different access mode, like from READ to See TFile::Open() for details. ; Reimplemented from TFile.; Definition at line 372 of file TXMLFile.cxx. ◆ ResetErrno(). void TXMLFile::ResetErrno ; (; ); const. inlinefinalvirtual . Method resetting the errn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:67428,recover,recovered,67428,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['recover'],['recovered']
Availability,"_t TypeInfo_IsValid(TypeInfo_t *) constDefinition TInterpreter.h:529; TInterpreter::CallFunc_IFacePtrvirtual CallFuncIFacePtr_t CallFunc_IFacePtr(CallFunc_t *) constDefinition TInterpreter.h:328; TInterpreter::BaseClassInfo_Factoryvirtual BaseClassInfo_t * BaseClassInfo_Factory(ClassInfo_t *) constDefinition TInterpreter.h:441; TInterpreter::GetFunctionOverloadsvirtual void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector< DeclId_t > &res) const =0; TInterpreter::GetDeclIdvirtual DeclId_t GetDeclId(MethodInfo_t *info) const =0; TInterpreter::RegisterTClassUpdatevirtual void RegisterTClassUpdate(TClass *oldcl, DictFuncPtr_t dict)=0; TInterpreter::ClassInfo_IsScopedEnumvirtual Bool_t ClassInfo_IsScopedEnum(ClassInfo_t *) constDefinition TInterpreter.h:418; TInterpreter::MethodInfo_Nextvirtual int MethodInfo_Next(MethodInfo_t *) constDefinition TInterpreter.h:496; TInterpreter::Calcvirtual Longptr_t Calc(const char *line, EErrorCode *error=nullptr)=0; TInterpreter::CallFunc_FactoryMethodvirtual MethodInfo_t * CallFunc_FactoryMethod(CallFunc_t *) constDefinition TInterpreter.h:324; TInterpreter::ReportDiagnosticsToErrorHandlervirtual void ReportDiagnosticsToErrorHandler(bool=true)Report diagnostics to the ROOT error handler (see TError.h).Definition TInterpreter.h:269; TInterpreter::BaseClassInfo_Offsetvirtual Longptr_t BaseClassInfo_Offset(BaseClassInfo_t *, void *=nullptr, bool=true) constDefinition TInterpreter.h:446; TInterpreter::DataMemberInfo_TypeTrueNamevirtual const char * DataMemberInfo_TypeTrueName(DataMemberInfo_t *) constDefinition TInterpreter.h:468; TInterpreter::CallFunc_SetArgvirtual void CallFunc_SetArg(CallFunc_t *, ULong_t) const =0; TInterpreter::TypeInfo_FactoryCopyvirtual TypeInfo_t * TypeInfo_FactoryCopy(TypeInfo_t *) constDefinition TInterpreter.h:527; TInterpreter::GenerateTClassvirtual TClass * GenerateTClass(ClassInfo_t *classinfo, Bool_t silent=kFALSE)=0; TInterpreter::ClassInfo_ClassPropertyvirtual Long_t ClassInfo_Cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8h_source.html:73932,error,error,73932,doc/master/TInterpreter_8h_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8h_source.html,1,['error'],['error']
Availability,"_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245; if option = ""a"" the list of blocks in the cache is printed ; Definition at line 7370 of file TTree.cxx. ◆ Process() [1/2]. Long64_t TTree::Process ; (; const char * ; filename, . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Process this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:187312,error,error,187312,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['error'],['error']
Availability,"_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:61651,error,error,61651,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['error'],['error']
Availability,"_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation ph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:70903,error,error,70903,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['error'],['error']
Availability,"_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:73061,error,error,73061,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['error'],['error']
Availability,"_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = kCheckROOT); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:73734,error,error,73734,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['error'],['error']
Availability,"_t average(Double_t lo, Double_t hi) const; Return average curve value in [xFirst,xLast] by integrating curve between points; and dividing by xLast-xFirst. Int_t findPoint(Double_t value, Double_t tolerance = 1.0E-10) const; Find the nearest point to xvalue. Return -1 if distance; exceeds tolerance. Double_t interpolate(Double_t x, Double_t tolerance = 1.0E-10) const; Return linearly interpolated value of curve at xvalue. If distance; to nearest point is less than tolerance, return nearest point value; instead. RooCurve* makeErrorBand(const vector<RooCurve*>& variations, Double_t Z = 1) const; Construct filled RooCurve represented error band that captures alpha% of the variations; of the curves passed through argument variations, where the percentage alpha corresponds to; the central interval fraction of a significance Z. RooCurve* makeErrorBand(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, const TMatrixD& V, Double_t Z = 1) const; Construct filled RooCurve represented error band represent the error added in quadrature defined by the curves arguments; plusVar and minusVar corresponding to one-sigma variations of each parameter. The resulting error band, combined used the correlation matrix C; is multiplied with the significance parameter Z to construct the equivalent of a Z sigma error band (in Gaussian approximation). void calcBandInterval(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, Int_t i, const TMatrixD& V, Double_t Z, Double_t& lo, Double_t& hi) const; Retrieve variation points from curves. void calcBandInterval(const vector<RooCurve*>& variations, Int_t i, Double_t Z, Double_t& lo, Double_t& hi, Bool_t approxGauss) const. Bool_t isIdentical(const RooCurve& other, Double_t tol = 9.9999999999999995E-7) const; Return true if curve is identical to other curve allowing for given; absolute tolerance on each point compared point. RooCurve(). void Print(Option_t* options = 0) const; Printing interface. » Last changed: Tue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCurve.html:24258,error,error,24258,root/html602/RooCurve.html,https://root.cern,https://root.cern/root/html602/RooCurve.html,8,['error'],['error']
Availability,"_t b, Double_t epsrel, Double_t epsabs, Double_t &error); 2622{; 2623 //Double_t *parameters = GetParameters();; 2624 TF1_EvalWrapper wf1(this, nullptr, fgAbsValue);; 2625 Double_t result = 0;; 2626 Int_t status = 0;; 2627 if (epsrel <= 0) epsrel = ROOT::Math::IntegratorOneDimOptions::DefaultRelTolerance();; 2628 if (epsabs <= 0) epsabs = ROOT::Math::IntegratorOneDimOptions::DefaultAbsTolerance();; 2629 if (ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType() == ROOT::Math::IntegrationOneDim::kGAUSS) {; 2630 ROOT::Math::GaussIntegrator iod(epsabs, epsrel);; 2631 iod.SetFunction(wf1);; 2632 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2633 result = iod.Integral(a, b);; 2634 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2635 result = iod.IntegralLow(b);; 2636 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2637 result = iod.IntegralUp(a);; 2638 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2639 result = iod.Integral();; 2640 error = iod.Error();; 2641 status = iod.Status();; 2642 } else {; 2643 ROOT::Math::IntegratorOneDim iod(wf1, ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType(), epsabs, epsrel);; 2644 if (a != - TMath::Infinity() && b != TMath::Infinity()); 2645 result = iod.Integral(a, b);; 2646 else if (a == - TMath::Infinity() && b != TMath::Infinity()); 2647 result = iod.IntegralLow(b);; 2648 else if (a != - TMath::Infinity() && b == TMath::Infinity()); 2649 result = iod.IntegralUp(a);; 2650 else if (a == - TMath::Infinity() && b == TMath::Infinity()); 2651 result = iod.Integral();; 2652 error = iod.Error();; 2653 status = iod.Status();; 2654 }; 2655 if (status != 0) {; 2656 std::string igName = ROOT::Math::IntegratorOneDim::GetName(ROOT::Math::IntegratorOneDimOptions::DefaultIntegratorType());; 2657 Warning(""IntegralOneDim"", ""Error found in integrating function %s in [%f,%f] using %s. Result = %f +/- %f - status = %d"", GetName(), a, b, igName.c_str(), result, error, status);; 2658 TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:97810,error,error,97810,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:53690,error,error,53690,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,6,['error'],['error']
Availability,"_t c2); 292{; 293 if (!h1 || !h2) {; 294 Error(""Add"",""Attempt to add a non-existing profile"");; 295 return kFALSE;; 296 }; 297 if (!h1->InheritsFrom(TProfile::Class())) {; 298 Error(""Add"",""Attempt to add a non-profile object"");; 299 return kFALSE;; 300 }; 301 if (!h2->InheritsFrom(TProfile::Class())) {; 302 Error(""Add"",""Attempt to add a non-profile object"");; 303 return kFALSE;; 304 }; 305 Bool_t ret = TProfileHelper::Add(this, h1, h2, c1, c2);; 306 if (c1 < 0 || c2 < 0); 307 ResetStats();; 308 return ret;; 309}; 310 ; 311 ; 312////////////////////////////////////////////////////////////////////////////////; 313/// Static function to set the fgApproximate flag.; 314///; 315///When the flag is true, the function GetBinError; 316/// will approximate the bin error with the average profile error on all bins; 317/// in the following situation only; 318///; 319/// - the number of bins in the profile is less than 1002; 320/// - the bin number of entries is small ( <5); 321/// - the estimated bin error is extremely small compared to the bin content; 322/// (see TProfile::GetBinError); 323 ; 324void TProfile::Approximate(Bool_t approx); 325{; 326 fgApproximate = approx;; 327}; 328 ; 329////////////////////////////////////////////////////////////////////////////////; 330/// Fill histogram with all entries in the buffer.; 331///; 332/// - action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); 333/// - action = 0 histogram is filled from the buffer; 334/// - action = 1 histogram is filled and buffer is deleted; 335/// The buffer is automatically deleted when the number of entries; 336/// in the buffer is greater than the number of entries in the histogram; 337 ; 338Int_t TProfile::BufferEmpty(Int_t action); 339{; 340 // do we need to compute the bin size?; 341 if (!fBuffer) return 0;; 342 Int_t nbentries = (Int_t)fBuffer[0];; 343 if (!nbentries) return 0;; 344 Double_t *buffer = fBuffer;; 345 if (nbentries < 0) {; 346 if (action == 0) retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:13391,error,error,13391,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,3,['error'],['error']
Availability,"_t count); virtual voidTObject::AppendPad(Option_t* option = """"); TObject*RooLinkedList::At(Int_t index) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidRooLinkedList::Clear(Option_t* o = 0); virtual TObject*RooLinkedList::Clone(const char* = 0) const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidRooLinkedList::Delete(Option_t* o = 0); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TObject*RooLinkedList::find(const char* name) const; RooAbsArg*RooLinkedList::findArg(const RooAbsArg*) const; virtual TObject*RooLinkedList::FindObject(const char* name) const; virtual TObject*RooLinkedList::FindObject(const TObject* obj) const; TObject*RooLinkedList::First() const; RooFIterRooLinkedList::fwdIterator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tRooLinkedList::getHashTableSize() const; virtual const char*TObject::GetIconName() const; virtual const char*RooLinkedList::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tRooLinkedList::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRefCountList.html:1842,error,error,1842,root/html534/RooRefCountList.html,https://root.cern,https://root.cern/root/html534/RooRefCountList.html,6,['error'],['error']
Availability,"_t doReplace = kFALSE); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; RooWorkspace::CodeRepoCodeRepo(RooWorkspace* wspace = 0); RooWorkspace::CodeRepoCodeRepo(const RooWorkspace::CodeRepo&); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tcompileClasses(); Bool_tcompiledOK() const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace__CodeRepo.html:2511,error,error,2511,root/html526/RooWorkspace__CodeRepo.html,https://root.cern,https://root.cern/root/html526/RooWorkspace__CodeRepo.html,5,['error'],['error']
Availability,"_t dstRow = 0, Long_t nRows = 0, Bool_t expand = kFALSE); virtual voidTTable::CopySet(TTable& array); virtual voidTTable::DeleteRows(Long_t indx, UInt_t nRows = 1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTTable::Draw(Option_t* opt); virtual TH1*TTable::Draw(TCut varexp, TCut selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); virtual TH1*TTable::Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; TIndexTable::iteratorend(); TIndexTable::iteratorend() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual voidTTable::Fit(const char* formula, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Int_t nentries = 1000000000, Int_t firstentry = 0)MENU ; void*TTable::GetArray() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual const Char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TIndexTable.html:3753,error,error,3753,root/html528/TIndexTable.html,https://root.cern,https://root.cern/root/html528/TIndexTable.html,10,['error'],['error']
Availability,"_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big());  ; static Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big());  ;  Static Public Member Functions inherited from TGeoShape; static Double_t Big ();  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Double_t ComputeEpsMch ();  Compute machine round-off double precision error as the smallest number that if added to 1.0 is different than 1.0. ;  ; static const char * DeclFileName ();  ; static Double_t DistToPhiMin (const Double_t *point, const Double_t *dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in=kTRUE);  compute distance from point (inside phi) to both phi planes. Return minimum. ;  ; static Double_t EpsMch ();  static function returning the machine round-off error ;  ; static TGeoMatrix * GetTransform ();  Returns current transformation matrix that applies to shape. ;  ; static Bool_t IsCloseToPhi (Double_t epsil, const Double_t *point, Double_t c1, Double_t s1, Double_t c2, Double_t s2);  True if point is closer than epsil to one of the phi planes defined by c1,s1 or c2,s2. ;  ; static Bool_t IsCrossingSemiplane (const Double_t *point, const Double_t *dir, Double_t cphi, Double_t sphi, Double_t &snext, Double_t &rxy);  Compute distance from POINT to semiplane defined by PHI angle along DIR. ;  ; static Bool_t IsInPhiRange (const Double_t *point, Double_t phi1, Double_t phi2);  Static method to check if a point is in the phi range (phi1, phi2) [degrees]. ;  ; static Bool_t IsSameWithinTolerance (Double_t a, Double_t b);  Check if two numbers differ with less than a tolerance. ;  ; static Bool_t IsSegCrossing (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t x3, Double_t y3, Double_t x4, Double_t y4);  Check if segments (A,B) and (C,D) are cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoArb8.html:18912,error,error,18912,doc/master/classTGeoArb8.html,https://root.cern,https://root.cern/doc/master/classTGeoArb8.html,26,['error'],['error']
Availability,"_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value (n1-n2)/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBin(Axis_t binCenter, Int_t n1, Int_t n2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 1e-6) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this histogram to the specified output stream. Standard: number of entries; Shape: error CL and maximum value; Verbose: print our bin contents and errors. void printName(ostream& os) const; Print name of RooHist. void printTitle(ostream& os) const; Print title of RooHist. void printClassName(ostream& os) const; Print class name of RooHist. RooHist* makeResidHist(const RooCurve& curve, bool normalize = false) const; Create and return RooHist containing residuals w.r.t to given curve.; If normalize is true, the residuals are normalized by the histogram; errors creating a RooHist with pull values. RooHist(). void Print(Option_t* options = 0) const; Printing interface. Double_t getNominalBinWidth() const; { return _nominalBinWidth; }. void setRawEntries(Double_t n); { _rawEntries = n ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHist.html:24825,toler,tolerance,24825,root/html526/RooHist.html,https://root.cern,https://root.cern/root/html526/RooHist.html,5,['toler'],['tolerance']
Availability,"_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value (n1-n2)/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBin(Axis_t binCenter, Int_t n1, Int_t n2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 1e-6) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this histogram to the specified output stream. Standard: number of entries; Shape: error CL and maximum value; Verbose: print our bin contents and errors. void printName(ostream& os) const; Print name of RooHist. void printTitle(ostream& os) const; Print title of RooHist. void printClassName(ostream& os) const; Print class name of RooHist. RooHist* makeResidHist(const RooCurve& curve, bool normalize = false, bool useAverage = false) const; Create and return RooHist containing residuals w.r.t to given curve.; If normalize is true, the residuals are normalized by the histogram; errors creating a RooHist with pull values. RooHist(). void Print(Option_t* options = 0) const; Printing interface. Double_t getNominalBinWidth() const; { return _nominalBinWidth; }. void setRawEntries(Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHist.html:24782,toler,tolerance,24782,root/html534/RooHist.html,https://root.cern,https://root.cern/root/html534/RooHist.html,2,['toler'],['tolerance']
Availability,"_t exh[n] = {.02,.08,.05,.05,.03,.03,.04,.05,.06,.03};; Double_t eyh[n] = {.6,.5,.4,.3,.2,.2,.3,.4,.5,.6};; Double_t exld[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyld[n] = {.0,.0,.05,.0,.0,.0,.0,.0,.0,.0};; Double_t exhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.0,.0};; Double_t eyhd[n] = {.0,.0,.0,.0,.0,.0,.0,.0,.05,.0};; auto gr = new TGraphBentErrors(n,x,y,exl,exh,eyl,eyh,exld,exhd,eyld,eyhd);; gr->SetTitle(""A graph with bend errors"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; }; Double_tdouble Double_tDefinition RtypesCore.h:59; TGraphBentErrorsA TGraphBentErrors is a TGraph with bent, asymmetric error bars.Definition TGraphBentErrors.h:25. TGraphMultiErrors; A TGraphMultiErrors works basically the same way like a TGraphAsymmErrors. It has the possibility to define more than one type / dimension of y-Errors. This is useful if you want to plot statistic and systematic errors at once.; To be able to define different drawing options for the multiple error dimensions the option string can consist of multiple blocks separated by semicolons. The painting method assigns these blocks to the error dimensions. The first block is always used for the general draw options and options concerning the x-Errors. In case there are less than NErrorDimensions + 1 blocks in the option string the first block is also used for the first error dimension which is reserved for statistical errors. The remaining blocks are assigned to the remaining dimensions.; In addition to the draw options of options of TGraphAsymmErrors the following are possible:. Option Block Description . ""X0"" First one only Do not draw errors for points with x = 0 . ""Y0"" First one only Do not draw errors for points with y = 0 . ""s=%f"" Any Scales the x-Errors with f similar to gStyle->SetErrorX(dx) but does not affect them directly (Useful when used in addition with box errors to make the box only half as wide as the x-Errors e.g. s=0.5) . ""S"" First one only Use individual TAttFill and TAttLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:15953,error,error,15953,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,1,['error'],['error']
Availability,"_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:34832,error,error,34832,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"_t eyL3=0., Double_t eyH3=0.);  Set ex and ey values for point pointed by the mouse. ;  ; virtual void SetPointError (Int_t i, Int_t ne, Double_t exL, Double_t exH, const Double_t *eyL, const Double_t *eyH);  Set ex and ey values for point i. ;  ; virtual void SetPointEX (Int_t i, Double_t exL, Double_t exH);  Set ex values for point i. ;  ; virtual void SetPointEXhigh (Int_t i, Double_t exH);  Set exH value for point i. ;  ; virtual void SetPointEXlow (Int_t i, Double_t exL);  Set exL value for point i. ;  ; virtual void SetPointEY (Int_t i, Int_t e, Double_t eyL, Double_t eyH);  Set error e ey values for point i. ;  ; virtual void SetPointEY (Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH);  Set ey values for point i. ;  ; virtual void SetPointEYhigh (Int_t i, Int_t e, Double_t eyH);  Set error e eyH value for point i. ;  ; virtual void SetPointEYhigh (Int_t i, Int_t ne, const Double_t *eyH);  Set eyH values for point i. ;  ; virtual void SetPointEYlow (Int_t i, Int_t e, Double_t eyL);  Set error e eyL value for point i. ;  ; virtual void SetPointEYlow (Int_t i, Int_t ne, const Double_t *eyL);  Set eyL values for point i. ;  ; virtual void SetSumErrorsMode (Int_t m);  Set the sum errors mode and recalculate summed errors. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TGraph. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGraph;  TGraph ();  Graph default constructor. ;  ;  TGraph (const char *filename, const char *format=""%lg %lg"", Option_t *option="""");  Graph constructor reading input from filename. ;  ;  TGraph (const TF1 *f, Option_t *option="""");  Graph constructor importing its parameters from the TF1 object passed as argument. ;  ;  TGraph (const TGraph &gr);  Copy constructor for this graph. ;  ;  TGraph (const TH1 *h);  Graph constructor importing its parameters from the TH1 object passed as argument. ;  ;  TGraph (const TVectorD &vx, const TVectorD &vy);  Gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:16538,error,error,16538,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,"_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tHandle(const char* dset, TObject* type); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofBenchDataSet.h 38091 2011-02-16 12:12:04Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchDataSet.html:5700,error,error,5700,root/html530/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html530/TProofBenchDataSet.html,1,['error'],['error']
Availability,"_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Int_tHandle(const char* dset, TObject* type); voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TProof*fProofproof. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchDataSet(TProof* proof = 0); Constructor. Int_t ReleaseCache(const char* dset); Release memory cache for dataset 'dset'; Return 0 on success, -1 on error. Int_t RemoveFiles(const char* dset); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. Int_t CopyFiles(const char* dset, const char* destdir); Copy the files of dataset 'dset' to another directory; Return 0 on success, -1 on error. Int_t Handle(const char* dset, TObject* type); Physically remove the dataset 'dset', i.e. remove the dataset and the files; it describes; Return 0 on success, -1 on error. TProofBenchDataSet(TProof* proof = 0). virtual ~TProofBenchDataSet(); { }. Bool_t IsProof(TProof* p); { return (p == fProof) ? kTRUE : kFALSE; }. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id: TProofBenchDataSet.h 38091 2011-02-16 12:12:04Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofBenchDataSet.html:5700,error,error,5700,root/html532/TProofBenchDataSet.html,https://root.cern,https://root.cern/root/html532/TProofBenchDataSet.html,2,['error'],['error']
Availability,"_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooArgusBG.html:28854,Error,ErrorLoggingMode,28854,root/html534/RooArgusBG.html,https://root.cern,https://root.cern/root/html534/RooArgusBG.html,54,['Error'],['ErrorLoggingMode']
Availability,"_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetOptions(TString options); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:29154,Error,ErrorLoggingMode,29154,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,1,['Error'],['ErrorLoggingMode']
Availability,"_t f); virtual voidRooAbsPdf::resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidsetNoRounding(bool flag = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPoisson.html:28698,Error,ErrorLoggingMode,28698,root/html534/RooPoisson.html,https://root.cern,https://root.cern/root/html534/RooPoisson.html,1,['Error'],['ErrorLoggingMode']
Availability,"_t filterType); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(Double_t*** source, const Double_t*** resp, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t numberIterations, Int_t numberRepetitions, Double_t boost); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TH1*GetHistogram() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; Int_tGetNPeaks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_t*GetPositionX() const; Double_t*GetPositionY() const; Double_t*GetPositionZ() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:3270,error,error,3270,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,4,['error'],['error']
Availability,"_t flag = kTRUE); When closing a file during the chain processing, the file; may be closed with option ""R"" if flag is set to kTRUE.; by default flag is kTRUE.; When closing a file with option ""R"", all TProcessIDs referenced by this; file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced objects of the file being closed; will not be referenced again, it is possible to minimize the size; of the TProcessID data structures in memory by forcing a delete of; the unused TProcessID. void CreatePackets(); -- Initialize the packet descriptor string. void DirectoryAutoAdd(TDirectory* ); Override the TTree::DirectoryAutoAdd behavior:; we never auto add. Long64_t Draw(const char* varexp, const TCut& selection, Option_t* option, Long64_t nentries, Long64_t firstentry); Draw expression varexp for selected entries.; Returns -1 in case of error or number of selected events in case of success. This function accepts TCut objects as arguments.; Useful to use the string operator +, example:; ntuple.Draw(""x"",cut1+cut2+cut3);. Long64_t Draw(const char* varexp, const char* selection, Option_t* option,Long64_t nentries, Long64_t firstentry); Process all entries in this chain and draw histogram corresponding to; expression varexp.; Returns -1 in case of error or number of selected events in case of success. TBranch* FindBranch(const char* name); -- See TTree::GetReadEntry(). TLeaf* FindLeaf(const char* name); -- See TTree::GetReadEntry(). const char* GetAlias(const char* aliasName) const; -- Returns the expanded value of the alias. Search in the friends if any. TBranch* GetBranch(const char* name); -- Return pointer to the branch name in the current tree. Bool_t GetBranchStatus(const char* branchname) const; -- See TTree::GetReadEntry(). Long64_t GetChainEntryNumber(Long64_t entry) const; -- Return absolute entry number in the chain.; The inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:33463,error,error,33463,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,1,['error'],['error']
Availability,"_t funcheck); virtual voidTObject::Browse(TBrowser* b); voidCatchTimeOut(); Bool_tCheckNetrc(TString& user, TString& passwd); Bool_tCheckNetrc(TString& user, TString& passwd, Bool_t& pwhash, Bool_t srppwd); static Bool_tCheckProofAuth(Int_t cSec, TString& det); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static Int_tDecodeRSAPublic(const char* rsapubexport, rsa_NUMBER& n, rsa_NUMBER& d, char** rsassl = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TList*GetAuthInfo(); static const char*GetAuthMethod(Int_t idx); static Int_tGetAuthMethodIdx(const char* meth); static Bool_tGetAuthReUse(); static Int_tGetClientProtocol(); static char*GetDefaultDetails(Int_t method, Int_t opt, const char* user); static const char*GetDefaultUser(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TDatimeGetGlobalExpDate(); static Bool_tGetGlobalPwHash(); static Bool_tGetGlobalSRPPwd(); static const char*GetGlobalUser(); s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TAuthenticate.html:1876,Error,Error,1876,root/html532/TAuthenticate.html,https://root.cern,https://root.cern/root/html532/TAuthenticate.html,4,['Error'],['Error']
Availability,"_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294////////////////////////////////////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:11210,error,errors,11210,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"_t i=0, const char *stringStack[]=nullptr);  Double_t template specialization of EvalInstance. ;  ; virtual Long64_t EvalInstance64 (Int_t i=0, const char *stringStack[]=nullptr);  Long64_t template specialization of EvalInstance. ;  ; virtual LongDouble_t EvalInstanceLD (Int_t i=0, const char *stringStack[]=nullptr);  LongDouble_t template specialization of EvalInstance. ;  ; virtual void * EvalObject (Int_t i=0);  Evaluate this treeformula. ;  ; virtual const char * EvalStringInstance (Int_t i=0);  Eval the instance as a string. ;  ; template<> ; LongDouble_t GetConstant (Int_t k);  ; virtual TLeaf * GetLeaf (Int_t n) const;  Return leaf corresponding to serial number n. ;  ; TFormLeafInfo * GetLeafInfo (Int_t code) const;  Return DataMember corresponding to code. ;  ; TTreeFormulaManager * GetManager () const;  ; TMethodCall * GetMethodCall (Int_t code) const;  Return methodcall corresponding to code. ;  ; virtual Int_t GetMultiplicity () const;  ; virtual Int_t GetNcodes () const;  ; virtual Int_t GetNdata ();  Return number of available instances in the formula. ;  ; virtual TTree * GetTree () const;  ; TClass * IsA () const override;  ; virtual bool IsInteger (bool fast=true) const;  Return TRUE if the formula corresponds to one single Tree leaf and this leaf is short, int or unsigned short, int When a leaf is of type integer or string, the generated histogram is forced to have an integer bin width. ;  ; bool IsQuickLoad () const;  ; virtual bool IsString () const;  Return TRUE if the formula is a string. ;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual char * PrintValue (Int_t mode, Int_t instance, const char *decform=""9.9"") const;  Return value of variable as a string. ;  ; virtual char * PrintValue (Int_t mode=0) const;  Return value of variable as a string. ;  ; virtual void ResetLoading ();  Tell the formula that we are going to request a new entry. ;  ; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:3622,avail,available,3622,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['avail'],['available']
Availability,"_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha1() const; Double_tGetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tGetBl1() const; Double_tGetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTrap.html:3864,error,error,3864,root/html528/TGeoTrap.html,https://root.cern,https://root.cern/root/html528/TGeoTrap.html,4,['error'],['error']
Availability,"_t id, EGEventType type, Event_t& ev); Check if there is for window ""id"" an event of type ""type"". If there; is it fills in the event structure and return true. If no such event; return false. void SendEvent(Window_t id, Event_t* ev); Specifies the event ""ev"" is to be sent to the window ""id"".; This function requires you to pass an event mask. void WMDeleteNotify(Window_t id); Tells WM to send message when window is closed via WM. void SetKeyAutoRepeat(Bool_t on = kTRUE); Turns key auto repeat on (kTRUE) or off (kFALSE). void GrabKey(Window_t id, Int_t keycode, UInt_t modifier, Bool_t grab = kTRUE); Establishes a passive grab on the keyboard. In the future, the; keyboard is actively grabbed, the last-keyboard-grab time is set; to the time at which the key was pressed (as transmitted in the; KeyPress event), and the KeyPress event is reported if all of the; following conditions are true:; - the keyboard is not grabbed and the specified key (which can; itself be a modifier key) is logically pressed when the; specified modifier keys are logically down, and no other; modifier keys are logically down;; - either the grab window ""id"" is an ancestor of (or is) the focus; window, or ""id"" is a descendant of the focus window and contains; the pointer;; - a passive grab on the same key combination does not exist on any; ancestor of grab_window. id - window id; keycode - specifies the KeyCode or AnyKey; modifier - specifies the set of keymasks or AnyModifier; the mask is; the bitwise inclusive OR of the valid keymask bits; grab - a switch between grab/ungrab key; grab = kTRUE grab the key and modifier; grab = kFALSE ungrab the key and modifier. void GrabButton(Window_t id, EMouseButton button, UInt_t modifier, UInt_t evmask, Window_t confine, Cursor_t cursor, Bool_t grab = kTRUE); Establishes a passive grab on a certain mouse button. That is, when a; certain mouse button is hit while certain modifier's (Shift, Control,; Meta, Alt) are active then the mouse will be grabed for windo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:48871,down,down,48871,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,8,['down'],['down']
Availability,"_t idx) const overrideDefinition TObjArray.h:164; TObjArray::RemoveAtTObject * RemoveAt(Int_t idx) overrideRemove object at index idx.Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TStri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoElement_8cxx_source.html:77950,error,error,77950,doc/master/TGeoElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html,1,['error'],['error']
Availability,"_t interleave, Bool_t verbose, Bool_t splitCutRange, RooDataHist::ErrorType etype); Constructor of a chi2 for given p.d.f. with respect given binned; dataset taking the observables specified in projDeps as projected; observables. If cutRange is specified the calculation of the chi2; is restricted to that named range. If addCoefRange is specified,; the interpretation of fractions for all component RooAddPdfs that; do not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooChi2Var(const RooChi2Var& other, const char* name = 0); Copy constructor. ~RooChi2Var(); Destructor. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. TObject* clone(const char* newname) const; { return new RooChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& dhist, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, Bool_t interleave = kFALSE, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. » Last changed: Mon Dec 7 13:47:09 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:41511,error,error,41511,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,2,['error'],['error']
Availability,"_t linidx) const; unsigned long long&At(ULong64_t linidx); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTNDArray::GetBin(const Int_t* idx) const; Long64_tTNDArray::GetCellSize(Int_t dim) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Long64_tTNDArray::GetNbins() const; Int_tTNDArray::GetNdimensions() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNDArrayT_ULong64_t_.html:2177,error,error,2177,root/html534/TNDArrayT_ULong64_t_.html,https://root.cern,https://root.cern/root/html534/TNDArrayT_ULong64_t_.html,2,['error'],['error']
Availability,"_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!CtorAllocate()); 472 return;; 473 ; 474 Int_t itvXL = tvX.GetLwb();; 475 Int_t itvYL = tvY.GetLwb();; 476 Int_t itvExLL = tvExL.GetLwb();; 477 Int_t itvExHL = tvExH.GetLwb();; 478 Int_t itvEyLL = tvEyL.GetLwb();; 479 Int_t itvEyHL = tvEyH.GetLwb();; 480 ; 481 for (Int_t i = 0; i < fNpoints; i++) {; 482 fX[i] = tvX(i + itvXL);; 483 fY[i] = tvY(i + itvYL);; 484 fExL[i] = tvExL(i + itvExLL);; 485 fExH[i] = tvExH(i + itvExHL);; 486 fEyL[0][i] = tvEyL(i + itvEyLL);; 487 fEyH[0][i] = tvEyH(i + itvEyHL);; 488 }; 489 ; 490 CalcYErrorsSum();; 491}; 492 ; 493////////////////////////////////////////////////////////////////////////////////; 494/// Constructor with multiple vectors of floats in input and multiple y error dimension.; 495/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 496/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL/H[yErrorDimension]`.; 497/// The number of points in the graph is the minimum of number of points; 498/// in `tvX` and `tvY`.; 499 ; 500TGraphMultiErrors::TGraphMultiErrors(Int_t ne, const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 501 const TVectorF &tvExH, const TVectorF *tvEyL, const TVectorF *tvEyH, Int_t m); 502 : fNYErrors(ne), fSumErrorsMode(m); 503{; 504 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 505 ; 506 if (!TGraph::CtorAllocate()); 507 return;; 508 ; 509 if (!CtorAllocate()); 510 return;; 511 ; 512 Int_t itvXL = tvX.GetLwb();; 513 Int_t itvYL = tvY.GetLwb();; 514 Int_t itvExLL = tvExL.GetLwb();; 515 Int_t itvExHL = tvExH.GetLwb();; 516 ; 517 for (Int_t i = 0; i < fNpoints; i++) {; 518 fX[i] = tvX(i + itvXL);; 519 fY[i] = tvY(i + itvYL);; 520 fExL[i] = tvExL(i + itvExLL);; 521 fExH[i] = tvExH(i + itvExHL);; 522 ; 523 for (Int_t j = 0; j < ne; j++) {; 524 fEyL[j][i] = tvEyL[j",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:18131,error,errors,18131,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"_t marker); virtual~TMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX() const; Double_tGetY() const; virtual Bool_tTObject::HandleTimer(TTi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMarker.html:1546,error,error,1546,root/html528/TMarker.html,https://root.cern,https://root.cern/root/html528/TMarker.html,4,['error'],['error']
Availability,"_t marker); virtual~TMarker(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& marker) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static voidDisplayMarkerTypes(); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMarker(Double_t x, Double_t y); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttMarker::GetMarkerColor() const; virtual Size_tTAttMarker::GetMarkerSize() const; virtual Style_tTAttMarker::GetMarkerStyle() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetX() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMarker.html:1565,error,error,1565,root/html534/TMarker.html,https://root.cern,https://root.cern/root/html534/TMarker.html,2,['error'],['error']
Availability,"_t maximum = -1111)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidSetNpy(Int_t npy = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF2.html:15060,error,error,15060,root/html528/TF2.html,https://root.cern,https://root.cern/root/html528/TF2.html,4,['error'],['error']
Availability,"_t maximum = -1111)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidSetNpy(Int_t npy = 100)MENU ; virtual voidTFormula::SetNumber(Int_t number); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFormula::SetParameter(const char* name, Double_t parvalue); virtual voidTFormula::SetParameter(Int_t ipar, Double_t parvalue); virtual voidTFormula::SetParameters(const Double_t* params); virtual voidTFormula::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTFormula::SetParName(Int_t ipar, const char* name); virtual voidTFormula::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF2.html:15674,error,error,15674,root/html534/TF2.html,https://root.cern,https://root.cern/root/html534/TF2.html,2,['error'],['error']
Availability,"_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLOrthoCamera(). Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZoomMax(max); }. void SetDollyToZoom(Bool_t x); { fDollyToZoom = x; }. Bool_t GetDollyToZoom() const; { return fDollyToZoom; }. void SetZoom(Double_t x); { fZoom = x; }. Double_t GetZoom() const; { return fZoom; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLOrthoCamera.html:16109,down,down,16109,root/html604/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html604/TGLOrthoCamera.html,2,['down'],['down']
Availability,"_t mod2); Rotate the camera - 'swivel round the view volume center'.; Returns kTRUE is redraw required (camera change), kFALSE otherwise. void Apply(const TGLBoundingBox& sceneBox, const TGLRect* pickRect = 0) const; Apply the camera to the current GL context, setting the viewport, projection; and modelview matricies. After this verticies etc can be directly entered; in the world frame. This also updates the cached frustum values, enabling; all the projection, overlap tests etc defined in TGLCamera to be used. Arguments are:; 'box' - view volume box - ignored for ortho camera. Assumed to be same; as one passed to Setup().; 'pickRect' - optional picking rect. If non-null, restrict drawing to this; viewport rect. void Configure(Double_t zoom, Double_t dolly, Double_t[3] center, Double_t hRotate, Double_t vRotate); Configure the camera state.; zoom - set directly (default = 0.78);; dolly - additional move along the camera forward direction;; center - new camera center (can be 0 for no change);; hRotate - additional ""up/down"" rotation in radians;; vRotate - additional ""left/right"" rotation in radians. TGLOrthoCamera(). Bool_t IsOrthographic() const; { return kTRUE; }. void SetEnableRotate(Bool_t x); { fEnableRotate = x; }. Bool_t GetEnableRotate() const; { return fEnableRotate; }. Double_t GetZoomMin() const; { return fZoomMin; }. Double_t GetZoomMax() const; { return fZoomMax; }. void SetZoomMinMax(Double_t min, Double_t max); { SetZoomMin(min); SetZoomMax(max); }. void SetDollyToZoom(Bool_t x); { fDollyToZoom = x; }. Bool_t GetDollyToZoom() const; { return fDollyToZoom; }. void SetZoom(Double_t x); { fZoom = x; }. Double_t GetZoom() const; { return fZoom; }. » Author: Richard Maunder 25/05/2005 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT suppor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLOrthoCamera.html:16109,down,down,16109,root/html602/TGLOrthoCamera.html,https://root.cern,https://root.cern/root/html602/TGLOrthoCamera.html,2,['down'],['down']
Availability,"_t np, Int_t kernel, Double_t bw); static voidBDRsmooth(Int_t n, Double_t* x, Double_t* y, Double_t* w, Double_t span, Int_t iper, Double_t vsmlsq, Double_t* smo, Double_t* acvr); static voidBDRsupsmu(Int_t n, Double_t* x, Double_t* y, Double_t* w, Int_t iper, Double_t span, Double_t alpha, Double_t* smo, Double_t* sc); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphSmooth.html:2135,Error,Error,2135,root/html532/TGraphSmooth.html,https://root.cern,https://root.cern/root/html532/TGraphSmooth.html,4,['Error'],['Error']
Availability,"_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector< TArrayF > eyL, std::vector< TArrayF > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with np points and ne y-errors. ;  ;  TGraphMultiErrors (Int_t np, Int_t ne=1);  TGraphMultiErrors normal constructor with np points and ne y-errors. ;  ;  ~TGraphMultiErrors () override;  TGraphMultiErrors default destructor. ;  ; virtual void AddYError (Int_t np, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr);  Add a new y error to the graph and fill it with the values from eyL and eyH ;  ; void Apply (TF1 *f) override;  Apply a function to all data points \( y = f(x,y) \). ;  ; virtual void BayesDivide (const TH1 *pass, const TH1 *total, Option_t *opt="""");  This function is only kept for backward compatibility. ;  ; void ComputeRange (Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const override;  Compute Range. ;  ; virtual void DeleteYError (Int_t e);  Deletes the y error with the index e. ;  ; void Divide (const TH1 *pass, const TH1 *total, Option_t *opt=""cp"");  This function was adapted from the TGraphAsymmErrors class. ;  ; virtual TAttFill * GetAttFill (Int_t e);  Get AttFill pointer for specified error dimension. ;  ; virtual TAttLine * GetAttLine (Int_t e);  Get AttLine pointer for specified error dimension. ;  ; Double_t GetErrorX (Int_t i) const override;  Get error on x coordinate for point i. ;  ; Double_t GetErrorXhigh (Int_t i) const override;  Get high error on x coordinate for point i. ;  ; Double_t GetErrorXlow (Int_t i) const override;  Get low error on x coordinate for point i. ;  ; Double_t GetErrorY (Int_t i) const override;  Get error on y coordinate for point i. ;  ; virtual Double_t GetErrorY (Int_t i, Int_t e) const;  Get error e on y coordinate for point i. ;  ; Double_t GetErrorYhigh (Int_t i) const override;  Get high error on y coordinate for point i. ;  ; virtual Double_t GetErrorYhigh (Int_t i, Int_t e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:10080,error,error,10080,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,"_t num = -1, const char* msd = 0, const char* dataset = 0); virtual~TDSetElement(); voidTObject::AbstractMethod(const char* method) const; voidAddAssocObj(TObject* assocobj); virtual voidAddFriend(TDSetElement* friendElement, const char* alias); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteFriends(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObject*GetAssocObj(Long64_t i, Bool_t isentry = kFALSE); const char*GetDataSet() const; const char*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntries(Bool_t istree = kTRUE, Bool_t openfile = kTRUE); TObject*GetEntryList() const; TFileInfo*GetFileInfo(const char* type = ""TTree""); const char*GetFileName() const; Long64_tGetFirst() const; virtual const char*TObject::GetIconName() const; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDSetElement.html:2327,Error,Error,2327,root/html532/TDSetElement.html,https://root.cern,https://root.cern/root/html532/TDSetElement.html,2,['Error'],['Error']
Availability,"_t numPoints); TImagePalette(Int_t ncolors, Int_t* colors); virtual~TImagePalette(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFindColor(UShort_t r, UShort_t g, UShort_t b); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_t*GetRootColors(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TImagePalette.html:3783,error,error,3783,root/html528/TImagePalette.html,https://root.cern,https://root.cern/root/html528/TImagePalette.html,6,['error'],['error']
Availability,"_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TQCommand*GetCommand(); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*GetName() const; Int_tGetNRargs() const; Int_tGetNUargs() const; void*GetObject() const; virtual char*TObject::GetObjectInfo(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:7689,error,error,7689,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['error'],['error']
Availability,"_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); static TQCommand*TQCommand::GetCommand(); TQCommand*GetCurrent() const; static TCollection*TCollection::GetCurrentCollection(); TQCommand*GetCursor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; UInt_tGetLimit() const; TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TQObject::GetListOfSignals() const; virtual const char*TQCommand::GetName() const; Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:7785,error,error,7785,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,4,['error'],['error']
Availability,"_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidExecuteMethod(); voidExecuteMethod(Long_t param); voidExecuteMethod(Long64_t param); voidExecuteMethod(Double_t param); voidExecuteMethod(const char* params); voidExecuteMethod(Int_t nargs, va_list va); voidExecuteMethod(Long_t* params, Int_t nparam = -1); voidExecuteMethod<>(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TList::FindObject(const char* name) const; virtual TObject*TList::FindObject(const TObject* obj) const; virtual TObject*TList::First() const; virtual TObjLink*TList::FirstLink() const; static voidTCollection::GarbageCollect(TObject* obj); const char*GetClassName() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQConnection.html:5013,error,error,5013,root/html602/TQConnection.html,https://root.cern,https://root.cern/root/html602/TQConnection.html,4,['error'],['error']
Availability,"_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExecMacro(); virtual Long_tTBrowserImp::ExecPlugin(const char*, const char*, const char*, Int_t, Int_t); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootBrowserLite.html:4953,error,error,4953,root/html602/TRootBrowserLite.html,https://root.cern,https://root.cern/root/html602/TRootBrowserLite.html,4,['error'],['error']
Availability,"_t phi, Double_t theta, Double_t psi); TGeoRotation(const char* name, Double_t theta1, Double_t phi1, Double_t theta2, Double_t phi2, Double_t theta3, Double_t phi3); virtual~TGeoRotation(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeterminant() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); voidFastRotZ(const Double_t* sincos); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAngles(Double_t& phi, Double_t& theta, Double_t& psi) const; voidGetAngles(Double_t& theta1, Double_t& phi1, Double_t& theta2, Double_t& phi2, Double_t& theta3, Double_t& phi3) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoRotation.html:8201,Error,Error,8201,root/html532/TGeoRotation.html,https://root.cern,https://root.cern/root/html532/TGeoRotation.html,2,['Error'],['Error']
Availability,"_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual Double_tGetSpecificActivity() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoElement.html:1936,error,error,1936,root/html534/TGeoElement.html,https://root.cern,https://root.cern/root/html534/TGeoElement.html,6,['error'],['error']
Availability,"_t relativeAbundance); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Int_tENDFCode() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); static TGeoElementTable*GetElementTable(); virtual const char*TObject::GetIconName() const; TGeoIsotope*GetIsotope(Int_t i) const; virtual const char*TNamed::GetName() const; Int_tGetNisotopes() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetRelativeAbundance(Int_t i) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; Bool_tHasIsotopes() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoElement.html:1936,error,error,1936,root/html528/TGeoElement.html,https://root.cern,https://root.cern/root/html528/TGeoElement.html,4,['error'],['error']
Availability,"_t sampleNum) const;  Return the given generated dataset. ;  ; bool generate (Int_t nSamples, Int_t nEvtPerSample=0, bool keepGenData=false, const char *asciiFilePat=nullptr);  Generate 'nSamples' samples of 'nEvtPerSample' events. ;  ; bool generateAndFit (Int_t nSamples, Int_t nEvtPerSample=0, bool keepGenData=false, const char *asciiFilePat=nullptr);  Generate and fit 'nSamples' samples of 'nEvtPerSample' events. ;  ; const RooDataSet * genParDataSet () const;  Return dataset with generator parameters for each toy. ;  ; TClass * IsA () const override;  ; RooPlot * plotError (const RooRealVar &param, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Plot the distribution of the fit errors for the specified parameter on a newly created frame. ;  ; RooPlot * plotError (const RooRealVar &param, double lo, double hi, Int_t nbins=100);  Create a RooPlot of the distribution of the fitted errors of the given parameter. ;  ; RooPlot * plotNLL (const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Plot the distribution of the -log(L) values on a newly created frame. ;  ; RooPlot * plotNLL (double lo, double hi, Int_t nBins=100);  Create a RooPlot of the -log(L) distribution in the range lo-hi with 'nBins' bins. ;  ; RooPlot * plotParam (const char *paramName, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Plot the distribution of the fitted value of the given parameter on a newly created frame. ;  ; RooPlot * plotParam (const RooRealVar &param, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:4606,error,errors,4606,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['error'],['errors']
Availability,"_t simCount); virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); Double_txErrorContribution(Double_t ydata) const. Data Members; public:. enum RooAbsTestStatistic::GOFOpMode { SimMaster; MPMaster; Slave; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:34260,Error,ErrorLoggingMode,34260,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,1,['Error'],['ErrorLoggingMode']
Availability,"_t stemax, Double_t deemax, Double_t epsil, Double_t stmin); virtual~TGeoMedium(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetId() const; TGeoMaterial*GetMaterial() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetParam(Int_t i) const; char*GetPointerName() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::Handl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMedium.html:1594,error,error,1594,root/html528/TGeoMedium.html,https://root.cern,https://root.cern/root/html528/TGeoMedium.html,6,['error'],['error']
Availability,"_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDumbStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Double_tFinalStepLength(TQpVar* iterate, TQpVar* step); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetArTol(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TQpLinSolverBase*GetLinearSystem(); Double_tGetMuTol(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpSolverBase.html:2368,Error,Error,2368,root/html532/TQpSolverBase.html,https://root.cern,https://root.cern/root/html532/TQpSolverBase.html,4,['Error'],['Error']
Availability,"_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-03-14 16:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPServerSocket.html:13305,error,error,13305,root/html534/TPServerSocket.html,https://root.cern,https://root.cern/root/html534/TPServerSocket.html,4,"['avail', 'error']","['available', 'error']"
Availability,"_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-02 16:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPServerSocket.html:13934,error,error,13934,root/html604/TPServerSocket.html,https://root.cern,https://root.cern/root/html604/TPServerSocket.html,4,"['avail', 'error']","['available', 'error']"
Availability,"_t tcpwindowsize = -1); Create a parallel server socket object for a named service. Set reuse; to true to force reuse of the server socket (i.e. do not wait for the; time out to pass). Using backlog one can set the desirable queue length; for pending connections.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TSocket * Accept(UChar_t Opt = kSrvNoAuth); Accept a connection on a parallel server socket. Returns a full-duplex; parallel communication TPSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and no connections are available -1 is returned. TPServerSocket(const TPServerSocket& ). void operator=(const TPServerSocket& ). virtual ~TPServerSocket(); { }. » Author: Fons Rademakers 19/1/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPServerSocket.html:13934,error,error,13934,root/html602/TPServerSocket.html,https://root.cern,https://root.cern/root/html602/TPServerSocket.html,4,"['avail', 'error']","['available', 'error']"
Availability,"_t trCounter, Int_t cls);  creates C++ code fragment of the PCA transform for inclusion in standalone C++ class ;  ; Bool_t PrepareTransformation (const std::vector< Event * > &);  calculate the principal components using the ROOT class TPrincipal and the normalization ;  ; virtual void ReadFromXML (void *trfnode);  Read the transformation matrices from the xml node. ;  ; void ReadTransformationFromStream (std::istream &, const TString &);  Read mean values from input stream. ;  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual const Event * Transform (const Event *const, Int_t cls) const;  apply the principal component analysis ;  ; void WriteTransformationToStream (std::ostream &) const;  write mean values to stream ;  ;  Public Member Functions inherited from TMVA::VariableTransformBase;  VariableTransformBase (DataSetInfo &dsi, Types::EVariableTransform tf, const TString &trfName);  standard constructor ;  ; virtual ~VariableTransformBase (void);  ; virtual void CountVariableTypes (UInt_t &nvars, UInt_t &ntgts, UInt_t &nspcts) const;  count variables, targets and spectators ;  ; virtual Bool_t GetInput (const Event *event, std::vector< Float_t > &input, std::vector< Char_t > &mask, Bool_t backTransform=kFALSE) const;  select the values from the event ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; TString GetShortName () const;  ; virtual std::vector< TString > * GetTransformationStrings (Int_t cls) const;  TODO --> adapt to variable,target,spectator selection default transformation output --> only indicate that transformation occurred. ;  ; Types::EVariableTransform GetVariableTransform () const;  ; Bool_t IsCreated () const;  ; Bool_t IsEnabled () const;  ; Bool_t IsNormalised () const;  ; MsgLogger & Log () const;  ; virtual void PrintTransformation (std::ostream &);  ; virtual void SelectInput (const TString &inputVariables, Bool_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html:2519,mask,mask,2519,doc/master/classTMVA_1_1VariablePCATransform.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariablePCATransform.html,1,['mask'],['mask']
Availability,"_t ub, Int_t x); Long_tRange(Long_t lb, Long_t ub, Long_t x); ULong_tRange(ULong_t lb, ULong_t ub, ULong_t x); Double_tRange(Double_t lb, Double_t ub, Double_t x); Double_tRgair(); Double_tRMS(Long64_t n, const short* a); Double_tRMS(Long64_t n, const int* a); Double_tRMS(Long64_t n, const float* a); Double_tRMS(Long64_t n, const double* a); Double_tRMS(Long64_t n, const long* a); Double_tRMS(Long64_t n, const long long* a); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMath.html:10442,down,down,10442,root/html530/TMath.html,https://root.cern,https://root.cern/root/html530/TMath.html,3,['down'],['down']
Availability,"_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedReal::setInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttrib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:24752,Error,ErrorLoggingMode,24752,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,3,['Error'],['ErrorLoggingMode']
Availability,"_t winID, UInt_t wMin, UInt_t hMin, UInt_t wMax, UInt_t hMax, UInt_t wInc, UInt_t hInc) override;  Gives the window manager minimum and maximum size hints of the window ""id"". ;  ; void SetWMState (Window_t winID, EInitialState state) override;  Sets the initial state of the window ""id"": either kNormalState or kIconicState. ;  ; void SetWMTransientHint (Window_t winID, Window_t mainWinID) override;  Tells window manager that the window ""id"" is a transient window of the window ""main_id"". ;  ; void ShapeCombineMask (Window_t wid, Int_t x, Int_t y, Pixmap_t mask) override;  The Non-rectangular Window Shape Extension adds non-rectangular windows to the System. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void SubtractRegion (Region_t rega, Region_t regb, Region_t result) override;  Subtracts regb from rega and stores the results in result. ;  ; Int_t SupportsExtension (const char *extensionName) const override;  Returns 1 if window system server supports extension given by the argument, returns 0 in case extension is not supported and returns -1 in case of error (like server not initialized). ;  ; void Sync (Int_t mode) override;  Set synchronisation on or off. ;  ; Int_t TextWidth (FontStruct_t font, const char *s, Int_t len) override;  Return length of the string ""s"" in pixels. Size depends on font. ;  ; void TranslateCoordinates (Window_t src, Window_t dest, Int_t src_x, Int_t src_y, Int_t &dest_x, Int_t &dest_y, Window_t &child) override;  Translates coordinates in one window to the coordinate space of another window. ;  ; void UnionRectWithRegion (Rectangle_t *rect, Region_t src, Region_t dest) override;  Updates the destination region from a union of the specified rectangle and the specified source region. ;  ; void UnionRegion (Region_t rega, Region_t regb, Region_t result) override;  Computes the union of two regions. ;  ; void UnmapWindow (Window_t wid) override;  Unmaps the specified window ""id"". ;  ; void Update (Int_t mode) override; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGQuartz.html:29898,error,error,29898,doc/master/classTGQuartz.html,https://root.cern,https://root.cern/doc/master/classTGQuartz.html,1,['error'],['error']
Availability,"_t x); Double_tRgair(); Double_tRMS(Long64_t n, const short* a); Double_tRMS(Long64_t n, const int* a); Double_tRMS(Long64_t n, const float* a); Double_tRMS(Long64_t n, const double* a); Double_tRMS(Long64_t n, const long* a); Double_tRMS(Long64_t n, const long long* a); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMath.html:10599,down,down,10599,root/html530/TMath.html,https://root.cern,https://root.cern/root/html530/TMath.html,3,['down'],['down']
Availability,"_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t R = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Int_t Nint(Float_t x); Round to nearest integer. Rounds half integers to the nearest; even integer. Int_t Nint(Double_t x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the norma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:12275,error,error,12275,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,2,['error'],['error']
Availability,"_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_t kappa, Double_t beta2); Double_tVavilovI(Double_t x, Double_t kappa, Double_t beta2); Double_tVoigt(Double_t x, Double_t sigma, Double_t lg, Int_t r = 4). Class Charts; Function documentation; Long_t Hypot(Long_t x, Long_t y). Double_t Hypot(Double_t x, Double_t y). Double_t ASinH(Double_t ). Double_t ACosH(Double_t ). Double_t ATanH(Double_t ). Double_t Log2(Double_t x). Int_t Nint(Float_t x); Round to nearest integer. Rounds half integers to the nearest; even integer. Int_t Nint(Double_t x); Round to nearest integer. Rounds half integers to the nearest; even integer. Double_t DiLog(Double_t x); The DiLogarithm function; Code translated by R.Brun from CERNLIB DILOG function C332. Double_t Erf(Double_t x); Computation of the error function erf(x).; Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x. Double_t Erfc(Double_t x); Compute the complementary error function erfc(x).; Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity. Double_t ErfInverse(Double_t x); returns the inverse error function; x must be <-1<x<1. Double_t ErfcInverse(Double_t x); returns the inverse of the complementary error function; x must be 0<x<2; implement using the quantile of the normal distribution; instead of ErfInverse for better numerical precision for large x. Double_t Factorial(Int_t i); Compute factorial(n). Double_t Freq(Double_t x); Computation of the normal frequency function freq(x).; Freq(x) = (1/sqrt(2pi)) Integral(exp(-t^2/2))dt between -infinity and x. Translated from CERNLIB C300 by Rene Brun. Double_t Gamma(Double_t z); Computation of gamma(z) for all z. C.Lanczos, SIAM Journal of Numerical Analysis B1 (1964), 86. Double_t Gamma(Double_t a, Double_t x); Computation of the norma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMath.html:12375,error,error,12375,root/html532/TMath.html,https://root.cern,https://root.cern/root/html532/TMath.html,2,['error'],['error']
Availability,"_t x1, Double_t y1, Double_t x2, Double_t y2); virtual~TBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBox.html:1573,Error,Error,1573,root/html532/TBox.html,https://root.cern,https://root.cern/root/html532/TBox.html,1,['Error'],['Error']
Availability,"_t x1, Double_t y1, Double_t x2, Double_t y2); virtual~TBox(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& box) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBox.html:1592,Error,Error,1592,root/html534/TBox.html,https://root.cern,https://root.cern/root/html534/TBox.html,1,['Error'],['Error']
Availability,"_t x1, Int_t y1, Int_t x2, Int_t y2); virtual voidDrawPolyLine(Int_t n, TPoint* xy); virtual voidDrawPolyMarker(Int_t n, TPoint* xy); virtual voidDrawRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidDrawSegments(Drawable_t id, GContext_t gc, Segment_t* seg, Int_t nseg); virtual voidDrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); virtual voidDrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); virtual voidTObject::Dump() constMENU ; TQtEmitter*Emitter(); virtual Bool_tEmptyRegion(Region_t reg); virtual Bool_tEqualRegion(Region_t rega, Region_t regb); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEventsPending(); virtual UInt_tExecCommand(TGWin32Command* code); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(Window_t id, GContext_t gc, Point_t* points, Int_t npnt); virtual voidFillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Window_tFindRWindow(Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd); virtual voidTVirtualX::FlushOpenGLBuffer(Handle_t ctx); virtual voidFreeColor(Colormap_t cmap, ULong_t pixel); virtual voidFreeFontNames(char** fontlist); virtual voidFreeFontStruct(FontStruct_t fs); virtual Float_tGetAlpha(Int_t cindex); virtual voidGetCharacterUp(Float_t& chupx, Float_t& chupy); virtual unsigned char*GetColorBits(Drawable_t wid, Int_t x = 0, Int_t y = 0, UInt_t w = 0, UInt_t h =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:6012,error,error,6012,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,4,['error'],['error']
Availability,"_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLinearFitter.html:23476,error,errors,23476,root/html602/TLinearFitter.html,https://root.cern,https://root.cern/root/html602/TLinearFitter.html,4,['error'],['errors']
Availability,"_t xncols, Double_t* x, Double_t* y, Double_t* e = 0); This function is to use when you already have all the data in arrays; and don't want to copy them into the fitter. In this function, the Use() method; of TVectorD and TMatrixD is used, so no bytes are physically moved around.; First parameter - number of points to fit; Second parameter - number of variables in the model; Third parameter - the variables of the model, stored in the following way:; (x0(0), x1(0), x2(0), x3(0), x0(1), x1(1), x2(1), x3(1),... void AddToDesign(Double_t* x, Double_t y, Double_t e); Add a point to the AtA matrix and to the Atb vector. void AddTempMatrices(). void Clear(Option_t* option = """"); Clears everything. Used in TH1::Fit and TGraph::Fit(). void ClearPoints(); To be used when different sets of points are fitted with the same formula. void Chisquare(); Calculates the chisquare. void ComputeTValues(); Computes parameters' t-values and significance. Int_t Eval(); Perform the fit and evaluate the parameters; Returns 0 if the fit is ok, 1 if there are errors. void FixParameter(Int_t ipar); Fixes paramter #ipar at its current value. void FixParameter(Int_t ipar, Double_t parvalue); Fixes parameter #ipar at value parvalue. void ReleaseParameter(Int_t ipar); Releases parameter #ipar. void GetAtbVector(TVectorD& v); Get the Atb vector - a vector, used for internal computations. Double_t GetChisquare(); Get the Chisquare. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.95); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95. NOTE, that this method can only be used when the fitting function inherits from a TF1,; so it's not possible when the fitting function was set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:22839,error,errors,22839,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['error'],['errors']
Availability,"_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tTPoints3DABC::DistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Int_tGetLastPosition() const; virtual Int_tTPoints3DABC::GetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; virtual Float_t*TPoints3DABC::GetP() const; virtual void*GetTable(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Float_tGetX(Int_t idx) const; virtual const Float_t*TPoints3DABC::GetXYZ(Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTablePoints.html:2324,error,error,2324,root/html528/TTablePoints.html,https://root.cern,https://root.cern/root/html528/TTablePoints.html,10,['error'],['error']
Availability,"_t y0, Double_t sigmax, Double_t sigmay, Double_t ro);  This function calculates second derivative of 2D peaks shape function (see manual) according to x position of 2D peak. ;  ; Double_t Derderj02 (Double_t x, Double_t y, Double_t a, Double_t x0, Double_t y0, Double_t sigmax, Double_t sigmay, Double_t ro);  This function calculates second derivative of 2D peaks shape function (see manual) according to y position of 2D peak. ;  ; Double_t Derdersigmax (Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t *parameter, Double_t sigmax, Double_t sigmay, Double_t ro);  This function calculates second derivative of peaks shape function (see manual) according to sigmax of peaks. ;  ; Double_t Derdersigmay (Int_t numOfFittedPeaks, Double_t x, Double_t y, const Double_t *parameter, Double_t sigmax, Double_t sigmay, Double_t ro);  This function calculates second derivative of peaks shape function (see manual) according to sigmay of peaks. ;  ; Double_t Derfc (Double_t x);  This function calculates derivative of error function of x. ;  ; Double_t Deri01 (Double_t x, Double_t ax, Double_t x0, Double_t sigmax, Double_t tx, Double_t sx, Double_t bx);  This function calculates derivative of 2D peaks shape function (see manual) according to x position of 1D ridge. ;  ; Double_t Deri02 (Double_t x, Double_t y, Double_t a, Double_t x0, Double_t y0, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t txy, Double_t sxy, Double_t bx, Double_t by);  This function calculates derivative of 2D peaks shape function (see manual) according to x position of 2D peak. ;  ; Double_t Derj02 (Double_t x, Double_t y, Double_t a, Double_t x0, Double_t y0, Double_t sigmax, Double_t sigmay, Double_t ro, Double_t txy, Double_t sxy, Double_t bx, Double_t by);  This function calculates derivative of 2D peaks shape function (see manual) according to y position of 2D peak Function parameters: ;  ; Double_t Derpa2 (Double_t sx, Double_t sy, Double_t ro);  This function calculates derivative of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:18292,error,error,18292,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['error']
Availability,"_t y1, Int_t x2, Int_t y2); virtual voidDrawPolyLine(Int_t n, TPoint* xy); virtual voidDrawPolyMarker(Int_t n, TPoint* xy); virtual voidDrawRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidDrawSegments(Drawable_t id, GContext_t gc, Segment_t* seg, Int_t nseg); virtual voidDrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); virtual voidDrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); virtual voidDrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const wchar_t* text, TVirtualX::ETextMode mode); virtual voidTObject::Dump() constMENU ; virtual Bool_tEmptyRegion(Region_t reg); virtual Bool_tEqualRegion(Region_t rega, Region_t regb); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tEventsPending(); virtual UInt_tExecCommand(TGWin32Command* code); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillPolygon(Window_t id, GContext_t gc, Point_t* points, Int_t npnt); virtual voidFillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Window_tFindRWindow(Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd); virtual voidFlushOpenGLBuffer(Handle_t ctx); virtual voidFreeColor(Colormap_t cmap, ULong_t pixel); virtual voidFreeFontNames(char** fontlist); virtual voidFreeFontStruct(FontStruct_t fs); virtual voidGetCharacterUp(Float_t& chupx, Float_t& chupy); virtual unsigned char*GetColorBits(Drawable_t wid, Int_t x = 0, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualX.html:6134,error,error,6134,root/html534/TVirtualX.html,https://root.cern,https://root.cern/root/html534/TVirtualX.html,6,['error'],['error']
Availability,"_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. TGNumberEntry(const TGNumberEntry& ). TGNumberEntry& operator=(const TGNumberEntry& ). void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = TGNumberFormat::kNEAAnyNumber); Set the numerical format. void SetNumStyle(TGNumberFormat::EStyle style). void SetNumAttr(TGNumberFormat::EAttribute attr = kNEAAnyNumber). void SetNumLimits(TGNumberFormat::ELimit limits = kNELNoLimits). void SetLimitValues(Double_t min = 0, Double_t max = 1). TGNumberEntryField * GetNumberEntry() const; Get the number entry field. TGButton * GetButtonUp() const; Get the up button. TGButton * GetButtonDown() const; Get the down button. UInt_t GetDefaultHeight() const; { return fNumericEntry->GetDefaultHeight(); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGNumberEntry.html:28333,down,down,28333,root/html528/TGNumberEntry.html,https://root.cern,https://root.cern/root/html528/TGNumberEntry.html,1,['down'],['down']
Availability,"_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. TGNumberEntry(const TGNumberEntry& ). TGNumberEntry& operator=(const TGNumberEntry& ). void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = TGNumberFormat::kNEAAnyNumber); Set the numerical format. void SetNumStyle(TGNumberFormat::EStyle style). void SetNumAttr(TGNumberFormat::EAttribute attr = kNEAAnyNumber). void SetNumLimits(TGNumberFormat::ELimit limits = kNELNoLimits). void SetLimitValues(Double_t min = 0, Double_t max = 1). TGNumberEntryField * GetNumberEntry() const; Get the number entry field. TGButton * GetButtonUp() const; Get the up button. TGButton * GetButtonDown() const; Get the down button. UInt_t GetDefaultHeight() const; { return fNumericEntry->GetDefaultHeight(); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGNumberEntry.html:28433,down,down,28433,root/html530/TGNumberEntry.html,https://root.cern,https://root.cern/root/html530/TGNumberEntry.html,1,['down'],['down']
Availability,"_t year, Int_t month, Int_t day). void SetHexNumber(ULong_t val). void SetText(const char* text, Bool_t emit = kTRUE). Double_t GetNumber() const. Long_t GetIntNumber() const. void GetTime(Int_t& hour, Int_t& min, Int_t& sec) const. void GetDate(Int_t& year, Int_t& month, Int_t& day) const. ULong_t GetHexNumber() const. void IncreaseNumber(TGNumberFormat::EStepSize step = kNSSSmall, Int_t sign = 1, Bool_t logstep = kFALSE). void SetLimits(TGNumberFormat::ELimit limits = TGNumberFormat::kNELNoLimits, Double_t min = 0, Double_t max = 1). EStyle GetNumStyle() const; Get the numerical style. EAttribute GetNumAttr() const; Get the numerical attribute. ELimit GetNumLimits() const; Get the numerialc limit attribute. Double_t GetNumMin() const; Get the lower limit. Double_t GetNumMax() const; Get the upper limit. Bool_t IsLogStep() const; Is log step enabled?. Bool_t IsEditable() const; { return kFALSE; }. TGNumberEntry(const TGNumberEntry& ). TGNumberEntry& operator=(const TGNumberEntry& ). void SetFormat(TGNumberFormat::EStyle style, TGNumberFormat::EAttribute attr = TGNumberFormat::kNEAAnyNumber); Set the numerical format. void SetNumStyle(TGNumberFormat::EStyle style). void SetNumAttr(TGNumberFormat::EAttribute attr = kNEAAnyNumber). void SetNumLimits(TGNumberFormat::ELimit limits = kNELNoLimits). void SetLimitValues(Double_t min = 0, Double_t max = 1). TGNumberEntryField * GetNumberEntry() const; Get the number entry field. TGButton * GetButtonUp() const; Get the up button. TGButton * GetButtonDown() const; Get the down button. UInt_t GetDefaultHeight() const; { return fNumericEntry->GetDefaultHeight(); }. » Author: Daniel Sigg 03/09/2001 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGNumberEntry.h 25233 2008-08-25 16:48:47Z bellenot $ » Last generated: 2011-11-03 20:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGNumberEntry.html:28433,down,down,28433,root/html532/TGNumberEntry.html,https://root.cern,https://root.cern/root/html532/TGNumberEntry.html,2,['down'],['down']
Availability,"_t zapOnError = kFALSE); TStringgetPunctuation() const; virtual TClass*IsA() const; Bool_tisPunctChar(char c) const; RooStreamParser&operator=(const RooStreamParser&); Bool_treadDouble(Double_t& value, Bool_t zapOnError = kFALSE); Bool_treadInteger(Int_t& value, Bool_t zapOnError = kFALSE); TStringreadLine(); Bool_treadString(TString& value, Bool_t zapOnError = kFALSE); TStringreadToken(); voidsetPunctuation(const TString& punct); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidzapToEnd(Bool_t inclContLines = kFALSE). Data Members; protected:. Bool_t_atEOF; Bool_t_atEOL; istream*_is; TString_prefix; TString_punct. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooStreamParser(istream& is); Construct parser on given input stream. RooStreamParser(istream& is, const TString& errPrefix); Construct parser on given input stream. Use given errorPrefix to; prefix any parsing error messages. ~RooStreamParser(); Destructor. Bool_t atEOL(); If true, parser is at end of line in stream. void setPunctuation(const TString& punct); Change list of characters interpreted as punctuation. Bool_t isPunctChar(char c) const; Check if given char is considered punctuation. TString readToken(); Read one token separated by any of the know punctuation characters; This function recognizes and handles comment lines in the istream (those; starting with '#', quoted strings ("""") the content of which is not tokenized; and '+-.' characters that are part of a floating point numbers and are exempt; from being interpreted as a token separator in case '+-.' are defined as; token separators. TString readLine(); Read an entire line from the stream and return as TString; This method recognizes the use of '\\' in the istream; as line continuation token. void zapToEnd(Bool_t inclContLines = kFALSE); Eat all characters up to and including then end of the; current line. If inclC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStreamParser.html:2508,error,errorPrefix,2508,root/html534/RooStreamParser.html,https://root.cern,https://root.cern/root/html534/RooStreamParser.html,4,['error'],"['error', 'errorPrefix']"
Availability,"_t& changed, Bool_t& touched, Bool_t& disappeared); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual Int_tClearCache(const char* uri = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TStringTDataSetManager::CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static Int_tTDataSetManager::FillMetaData(TFileInfo* fi, TDirectory* d, const char* rdir = ""/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tTDataSetManager::GetAvgFileSize() const; virtual TFileCollection*GetDataSet(const char* uri, const char* srv = 0); TFileCollection*GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0); virtual TMap*GetDataSets(const char* uri, UInt_t option = TDataSetManager::kExport); TMap*GetDataSets(const char* group, const char* user, const char* dsName = 0, UInt_t option = 0); static TList*TDataSetManager::GetDataSetSrvMaps(); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManagerFile.html:2080,error,error,2080,root/html534/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html534/TDataSetManagerFile.html,6,['error'],['error']
Availability,"_t&,pict_mask,PictureAttributes_t&,attr); 233RETURN_METHOD_ARG5(VirtualX,Bool_t,CreatePictureFromData,Drawable_t,id,char**,data,Pixmap_t&,pict,Pixmap_t&,pict_mask,PictureAttributes_t&,attr); 234RETURN_METHOD_ARG2(VirtualX,Bool_t,ReadPictureDataFromFile,const char*,filename,char***,ret_data); 235RETURN_METHOD_ARG2(VirtualX,Int_t,SetTextFont,char*,fontname,TVirtualX::ETextSetMode,mode); 236RETURN_METHOD_ARG3(VirtualX,Pixmap_t,CreatePixmap,Drawable_t,wid,UInt_t,w,UInt_t,h); 237RETURN_METHOD_ARG1(VirtualX,ULong_t,GetPixel,Color_t,cindex); 238RETURN_METHOD_ARG5(VirtualX,unsigned char*,GetColorBits,Drawable_t,wid,Int_t,x,Int_t,y,UInt_t,width,UInt_t,height); 239RETURN_METHOD_ARG3(VirtualX,Pixmap_t,CreatePixmapFromData,unsigned char*,bits,UInt_t,width,UInt_t,height); 240RETURN_METHOD_ARG3(VirtualX,Int_t,AddWindow,ULongptr_t,qwid,UInt_t,w,UInt_t,h); 241VOID_METHOD_ARG1(VirtualX,RemoveWindow,ULongptr_t,qwid,1); 242VOID_METHOD_ARG4(VirtualX,ShapeCombineMask,Window_t,id,Int_t,x,Int_t,y,Pixmap_t,mask,1); 243 ; 244VOID_METHOD_ARG2(VirtualX,DeleteProperty,Window_t,win,Atom_t&,prop,1); 245RETURN_METHOD_ARG11(VirtualX,Int_t,GetProperty,Window_t,win,Atom_t,prop,Long_t,offset,Long_t,length,Bool_t,del,Atom_t,req_type,Atom_t*,act_type,Int_t*,act_format,ULong_t*,nitems,ULong_t*,bytes,unsigned char**,prop_list); 246VOID_METHOD_ARG3(VirtualX,ChangeActivePointerGrab,Window_t,win,UInt_t,mask,Cursor_t,cur,1); 247VOID_METHOD_ARG5(VirtualX,ConvertSelection,Window_t,win,Atom_t&,sel,Atom_t&,target,Atom_t&,prop,Time_t&,stamp,1); 248RETURN_METHOD_ARG2(VirtualX,Bool_t,SetSelectionOwner,Window_t,win,Atom_t&,prop); 249VOID_METHOD_ARG6(VirtualX,ChangeProperties,Window_t,id,Atom_t,property,Atom_t,type,Int_t,format,UChar_t*,data,Int_t,len,1); 250VOID_METHOD_ARG2(VirtualX,SetDNDAware,Window_t,id,Atom_t*,typelist,1); 251VOID_METHOD_ARG3(VirtualX,SetTypeList,Window_t,win,Atom_t,prop,Atom_t*,typelist,1);; 252RETURN_METHOD_ARG6(VirtualX,Window_t,FindRWindow,Window_t,win,Window_t,dragwin,Window_t,input,int,x,in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html:17286,mask,mask,17286,doc/master/TGWin32VirtualXProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx_source.html,1,['mask'],['mask']
Availability,"_t)Returns the area hyperbolic tangent of x.Definition TMath.cxx:95; TMath::BesselI0Double_t BesselI0(Double_t x)Integer order modified Bessel function K_n(x)Definition TMath.cxx:1426; TMath::VavilovSetvoid VavilovSet(Double_t rkappa, Double_t beta2, Bool_t mode, Double_t *WCM, Double_t *AC, Double_t *HC, Int_t &itype, Int_t &npt)Internal function, called by Vavilov and VavilovI.Definition TMath.cxx:2854; TMath::Log10Double_t Log10(Double_t x)Returns the common (base-10) logarithm of x.Definition TMath.h:762; TMath::StudentIDouble_t StudentI(Double_t T, Double_t ndf)Calculates the cumulative distribution function of Student's t-distribution second parameter stands f...Definition TMath.cxx:2646; TMath::StudentQuantileDouble_t StudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail=kTRUE)Computes quantiles of the Student's t-distribution 1st argument is the probability,...Definition TMath.cxx:2674; TMath::BesselY1Double_t BesselY1(Double_t x)Bessel function Y0(x) for positive x.Definition TMath.cxx:1739; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::GammaDistDouble_t GammaDist(Double_t x, Double_t gamma, Double_t mu=0, Double_t beta=1)Computes the density function of Gamma distribution at point x.Definition TMath.cxx:2347; TMath::HCconstexpr Double_t HC()inDefinition TMath.h:233; TMath::ErfcInverseDouble_t ErfcInverse(Double_t x)Returns the inverse of the complementary error function.Definition TMath.cxx:242; TMath::EvenBool_t Even(Long_t a)Returns true if a is even.Definition TMathBase.h:113; v@ vDefinition rootcling_impl.cxx:3699; TMath::LimitsDefinition TMath.h:407; TMath::Limits::Epsilonstatic T Epsilon()Returns minimum double representation.Definition TMath.h:941; mTMarker mDefinition textangle.C:8; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. mathmathcoresrcTMath.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:41 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:131263,error,error,131263,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,"_t)in % 4) == 0) {; 12945 /* Convert in 32 bit words, if data is 4 byte aligned */; 12946 while (i < (in_len - 3)) {; 12947 *(uint32_t *)(void *)(out + i) =; 12948 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12949 i += 4;; 12950 }; 12951 }; 12952 if (i != in_len) {; 12953 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12954 while (i < in_len) {; 12955 *(uint8_t *)(void *)(out + i) =; 12956 *(uint8_t *)(void *)(in + i); 12957 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12958 i++;; 12959 }; 12960 }; 12961}; 12962 ; 12963 ; 12964int; 12965mg_websocket_client_write(struct mg_connection *conn,; 12966 int opcode,; 12967 const char *data,; 12968 size_t dataLen); 12969{; 12970 int retval = -1;; 12971 char *masked_data =; 12972 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12973 uint32_t masking_key = 0;; 12974 ; 12975 if (masked_data == NULL) {; 12976 /* Return -1 in an error case */; 12977 mg_cry_internal(conn,; 12978 ""%s"",; 12979 ""Cannot allocate buffer for masked websocket response: ""; 12980 ""Out of memory"");; 12981 return -1;; 12982 }; 12983 ; 12984 do {; 12985 /* Get a masking key - but not 0 */; 12986 masking_key = (uint32_t)get_random();; 12987 } while (masking_key == 0);; 12988 ; 12989 mask_data(data, dataLen, masking_key, masked_data);; 12990 ; 12991 retval = mg_websocket_write_exec(; 12992 conn, opcode, masked_data, dataLen, masking_key);; 12993 mg_free(masked_data);; 12994 ; 12995 return retval;; 12996}; 12997 ; 12998 ; 12999static void; 13000handle_websocket_request(struct mg_connection *conn,; 13001 const char *path,; 13002 int is_callback_resource,; 13003 struct mg_websocket_subprotocols *subprotocols,; 13004 mg_websocket_connect_handler ws_connect_handler,; 13005 mg_websocket_ready_handler ws_ready_handler,; 13006 mg_websocket_data_handler ws_data_handler,; 13007 mg_websocket_close_handler ws_close_handler,; 13008 void *cbData); 13009{; 13010 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13011 const char *v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:377873,mask,masked,377873,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['mask'],['masked']
Availability,"_t)in % 4) == 0) {; 12946 /* Convert in 32 bit words, if data is 4 byte aligned */; 12947 while (i < (in_len - 3)) {; 12948 *(uint32_t *)(void *)(out + i) =; 12949 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12950 i += 4;; 12951 }; 12952 }; 12953 if (i != in_len) {; 12954 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12955 while (i < in_len) {; 12956 *(uint8_t *)(void *)(out + i) =; 12957 *(uint8_t *)(void *)(in + i); 12958 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12959 i++;; 12960 }; 12961 }; 12962}; 12963 ; 12964 ; 12965int; 12966mg_websocket_client_write(struct mg_connection *conn,; 12967 int opcode,; 12968 const char *data,; 12969 size_t dataLen); 12970{; 12971 int retval = -1;; 12972 char *masked_data =; 12973 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12974 uint32_t masking_key = 0;; 12975 ; 12976 if (masked_data == NULL) {; 12977 /* Return -1 in an error case */; 12978 mg_cry_internal(conn,; 12979 ""%s"",; 12980 ""Cannot allocate buffer for masked websocket response: ""; 12981 ""Out of memory"");; 12982 return -1;; 12983 }; 12984 ; 12985 do {; 12986 /* Get a masking key - but not 0 */; 12987 masking_key = (uint32_t)get_random();; 12988 } while (masking_key == 0);; 12989 ; 12990 mask_data(data, dataLen, masking_key, masked_data);; 12991 ; 12992 retval = mg_websocket_write_exec(; 12993 conn, opcode, masked_data, dataLen, masking_key);; 12994 mg_free(masked_data);; 12995 ; 12996 return retval;; 12997}; 12998 ; 12999 ; 13000static void; 13001handle_websocket_request(struct mg_connection *conn,; 13002 const char *path,; 13003 int is_callback_resource,; 13004 struct mg_websocket_subprotocols *subprotocols,; 13005 mg_websocket_connect_handler ws_connect_handler,; 13006 mg_websocket_ready_handler ws_ready_handler,; 13007 mg_websocket_data_handler ws_data_handler,; 13008 mg_websocket_close_handler ws_close_handler,; 13009 void *cbData); 13010{; 13011 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13012 const char *v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:377906,mask,masked,377906,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['mask'],['masked']
Availability,"_t* a, Int_t* iw, Int_t& j1, Int_t& j2, const Int_t itop, const Int_t ireal, Int_t& ncmpbr, Int_t& ncmpbi); Help routine for factorization. void Solve_sub1(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, Int_t& latop, Int_t* icntl); Help routine for solving. void Solve_sub2(const Int_t n, Double_t* a, Int_t* iw, Double_t* w, Double_t* rhs, Int_t* iw2, const Int_t nblk, const Int_t latop, Int_t* icntl); Help routine for solving. void Print(Option_t* opt = """") const; Print class members. TDecompSparse & operator=(const TDecompSparse& source); Assignment operator. void Solve(const Int_t n, TArrayD& Aa, TArrayI& Aiw, TArrayD& Aw, const Int_t maxfrt, TVectorD& b, TArrayI& Aiw1, const Int_t nsteps, Int_t* icntl, Int_t* info). Int_t IDiag(Int_t ix, Int_t iy); { return ((iy-1)*(2*ix-iy+2))/2; }. Int_t IError(); { return fInfo[2]; }. Int_t MinRealWorkspace(); { return fInfo[5]; }. Int_t MinIntWorkspace(); { return fInfo[6]; }. Int_t ErrorFlag(); { return fInfo[1]; }. Double_t GetThresholdPivoting(); Takes values in the range [0,1]. Larger values enforce greater stability in; the factorization as they insist on larger pivots. Smaller values preserve; sparsity at the cost of using smaller pivots. { return fCntl[1]; }. Double_t GetTreatAsZero(); { return fCntl[3]; }. void SetThresholdPivoting(Double_t piv); The factorization will not accept a pivot whose absolute value is less than fCntl[3] as; a 1x1 pivot or as the off-diagonal in a 2x2 pivot. { fCntl[1] = piv; }. void SetTreatAsZero(Double_t tol); { fCntl[3] = tol; }. const TMatrixDBase & GetDecompMatrix() const; { MayNotUse(""GetDecompMatrix()""); return fA; }. virtual ~TDecompSparse(); {}. void SetVerbose(Int_t v). Int_t GetNrows() const; { return fA.GetNrows(); }. Int_t GetNcols() const; { return fA.GetNcols(); }. Bool_t Solve(TVectorD& b). Bool_t TransSolve(TVectorD& b); { return Solve(b); }. TVectorD TransSolve(const TVectorD& b, Bool_t& ok); { TVectorD x = b; ok = Solve(x); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompSparse.html:15963,Error,ErrorFlag,15963,root/html532/TDecompSparse.html,https://root.cern,https://root.cern/root/html532/TDecompSparse.html,4,['Error'],['ErrorFlag']
Availability,"_t* binMap = 0) const; get unfolding result, folded back trough the matrix; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetProbabilityMatrix(TH2* A, TUnfold::EHistMap histmap) const; retreive matrix of probabilities; histmap: on which axis to arrange the input/output vector; A: histogram to store the probability matrix. void GetInput(TH1* inputData, const Int_t* binMap = 0) const; retreive input distribution; out: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first bin, ...; binMap[0] : destination of underflow bin; binMap[1] : destination of first bin. void GetInputInverseEmatrix(TH2* ematrix); calculate the inverse of the contribution to the error matrix; corresponding to the input data. void GetLsquared(TH2* lsquared) const; retreive matrix of regularisation conditions squared; out: prebooked matrix. void GetL(TH2* l) const; retreive matrix of regularisation conditions; out: prebooked matrix. void SetConstraint(TUnfold::EConstraint constraint); set type of constraint for the next unfolding. Double_t GetTau(void); return regularisation parameter. Double_t GetChi2L(void); return chi**2 contribution from regularisation conditions. Int_t GetNpar(void); return number of parameters. Double_t GetLcurveX(void); return value on x axis of L curve. Double_t GetLcurveY(void); return value on y axis of L curve. void GetOutput(TH1* output, const Int_t* binMap = 0) const; get output distribution, cumulated over several bins; output: output histogram; binMap: for each bin of the original output distribution; specify the destination bin. A value of -1 means that the bin; is discarded. 0 means underflow bin, 1 first ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:28623,error,error,28623,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,6,['error'],['error']
Availability,"_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUnixService(int port, int backlog); Open a socket, bind to it and start listening for Unix domain connections; to it. Returns socket fd or -1. int UnixUnixService(const char* sockpath, int backlog); Open a socket on path 'sockpath', bind to it and start listening for Unix; domain connections to it. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:39124,error,error,39124,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,2,['error'],['error']
Availability,"_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoBBox::DistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidTGeoBBox::DistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveGeoPolyShape.html:3717,Error,Error,3717,root/html534/TEveGeoPolyShape.html,https://root.cern,https://root.cern/root/html534/TEveGeoPolyShape.html,3,['Error'],['Error']
Availability,"_t* dminfo) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCint.html:7901,error,error,7901,root/html528/TCint.html,https://root.cern,https://root.cern/root/html528/TCint.html,4,['error'],['error']
Availability,"_t* event); Handle double click event in the list tree (only for kButton1). Bool_t HandleCrossing(Event_t* event); Handle mouse crossing event. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. void DataDropped(TGListTreeItem* item, TDNDData* data); Emit DataDropped() signal. Bool_t HandleMotion(Event_t* event); Handle mouse motion event. Used to set tool tip, to emit; MouseOver() signal and for DND handling. Bool_t HandleKey(Event_t* event); The key press event handler converts a key press to some line editor; action. void MouseOver(TGListTreeItem* entry); Signal emitted when pointer is over entry. void MouseOver(TGListTreeItem* entry, UInt_t mask); Signal emitted when pointer is over entry. void KeyPressed(TGListTreeItem* entry, UInt_t keysym, UInt_t mask); Signal emitted when keyboard key pressed. entry - selected item; keysym - defined in ""KeySymbols.h""; mask - modifier key mask, defined in ""GuiTypes.h"". const Mask_t kKeyShiftMask = BIT(0);; const Mask_t kKeyLockMask = BIT(1);; const Mask_t kKeyControlMask = BIT(2);; const Mask_t kKeyMod1Mask = BIT(3); // typically the Alt key; const Mask_t kButton1Mask = BIT(8);; const Mask_t kButton2Mask = BIT(9);; const Mask_t kButton3Mask = BIT(10);; const Mask_t kButton4Mask = BIT(11);; const Mask_t kButton5Mask = BIT(12);; const Mask_t kAnyModifier = BIT(15);. void ReturnPressed(TGListTreeItem* entry); Emit ReturnPressed() signal. void Checked(TObject* obj, Bool_t check); Emit Checked() signal. void Clicked(TGListTreeItem* entry, Int_t btn); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, Int_t x, Int_t y); Emit Clicked() signal. void Clicked(TGListTreeItem* entry, Int_t btn, UInt_t mask, Int_t x, Int_t y); Emit Clicked() signal. void DoubleClicked(TGListTreeIte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGListTree.html:32395,mask,mask,32395,root/html528/TGListTree.html,https://root.cern,https://root.cern/root/html528/TGListTree.html,10,['mask'],['mask']
Availability,"_t* free); We try to read a buffer that has already been unzipped; Returns -1 in case of read failure, 0 in case it's not in the; cache and n>0 in case read from cache (number of bytes copied).; pos and len are the original values as were passed to ReadBuffer; but instead we will return the inflated buffer.; Note!! : If *buf == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer. void SetUnzipRelBufferSize(Float_t relbufferSize); static function: Sets the unzip relatibe buffer size; FABRIZIO: PLEASE DOCUMENT and also in TTree::Set... void SetUnzipBufferSize(Long64_t bufferSize); Sets the size for the unzipping cache... by default it should be; two times the size of the prefetching cache. Int_t UnzipBuffer(char** dest, char* src); UNzips a ROOT specific buffer... by reading the header at the beginning.; returns the size of the inflated buffer or -1 if error; Note!! : If *dest == 0 we will allocate the buffer and it will be the; responsability of the caller to free it... it is useful for example; to pass it to the creator of TBuffer; src is the original buffer with the record (header+compressed data); *dest is the inflated buffer (including the header). Int_t UnzipCache(Int_t& startindex, Int_t& locbuffsz, char*& locbuff); This inflates all the buffers in the cache.. passing the data to a new; buffer that will only wait there to be read...; We can not inflate all the buffers in the cache so we will try to do; it until the cache gets full... there is a member called fUnzipBufferSize which will; tell us the max size we can allocate for this cache. note that we will unzip in the order they were put into the cache not; the order of the transference so it has to be read in that order or the; pre-unzipping will be useless. startindex is used as start index to check for blks to be unzipped. returns 0 in normal conditions or -1 if error, 1 if it would like to sleep. This fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:17476,error,error,17476,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,10,['error'],['error']
Availability,"_t* id, Long_t* bsize, Long_t* blocks, Long_t* bfree); Get info about a file system: id, bsize, bfree, blocks.; Id is file system type (machine dependend, see statfs()); Bsize is block size of file system; Blocks is total number of blocks in file system; Bfree is number of free blocks in file system; The function returns 0 in case of success and 1 if the file system could; not be stat'ed. int UnixWaitchild(); Wait till child is finished. int UnixTcpConnect(const char* hostname, int port, int tcpwindowsize); Open a TCP/IP connection to server and connect to a service (i.e. port).; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUdpConnect(const char* hostname, int port); Creates a UDP socket connection; Is called via the TSocket constructor. Returns -1 in case of error. int UnixUnixConnect(int port); Connect to a Unix domain socket. int UnixUnixConnect(const char* path); Connect to a Unix domain socket. Returns -1 in case of error. int UnixTcpService(int port, Bool_t reuse, int backlog, int tcpwindowsize); Open a socket, bind to it and start listening for TCP/IP connections; on the port. If reuse is true reuse the address, backlog specifies; how many sockets can be waiting to be accepted. If port is 0 a port; scan will be done to find a free port. This option is mutual exlusive; with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Returns socket fd or -1 if socket() failed, -2 if bind() failed; or -3 if listen() failed. int UnixUdpService(int port, int backlog); Open a socket, bind to it and start listening for UDP connections; on the port. If reuse is true reu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnixSystem.html:39531,error,error,39531,root/html532/TUnixSystem.html,https://root.cern,https://root.cern/root/html532/TUnixSystem.html,8,['error'],['error']
Availability,"_t* info = 0, TClass* cl = 0); virtual~TBaseClass(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetClassPointer(Bool_t load = kTRUE); Int_tGetDelta() const; static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBaseClass.html:1607,error,error,1607,root/html534/TBaseClass.html,https://root.cern,https://root.cern/root/html534/TBaseClass.html,2,['error'],['error']
Availability,"_t* minfo) const; virtual const char*MethodInfo_TypeName(MethodInfo_t* minfo) const; virtual stringMethodInfo_TypeNormalizedName(MethodInfo_t* minfo) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual voidPrintIntro(); virtual Long_tProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Long_tProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Long_tProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); virtual Int_tTObject::Read(const char* name); virtual voidRecursiveRemove(TObject* obj); virtual Int_tReloadAllSharedLibraryMaps(); virtual Int_tRescanLibraryMap(); virtual voidReset(); virtual voidResetAll(); voidTObject::ResetBit(UInt_t f); virtual voidResetGlobals(); virtual voidResetGlobalVar(void* obj); virtual voidRewindDictionary(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidSaveContext(); virtual voidSaveGlobalsContext(); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidSetAlloclockfunc(void (*)()) const; virtual voidSetAllocunlockfunc(void (*)()) const; voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual intSetClassAutoloading(int) const; virtual voidSetClassInfo(TClass* cl, Bool_t reload = kFALSE); virtual Int_tSetClassSharedLibs(const char* cls, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:14285,error,error,14285,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['error'],['error']
Availability,"_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); intConnectService(const char* server, int port, int tcpwindowsize, const char* protocol = ""tcp""); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); voidDispatchSignals(ESignals sig); Bool_tDispatchTimers(Bool_t mode); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tExpandPathName(TString& patbuf); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnixSystem.html:3199,Error,Error,3199,root/html532/TUnixSystem.html,https://root.cern,https://root.cern/root/html532/TUnixSystem.html,2,['Error'],['Error']
Availability,"_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); virtual Bool_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp = 0); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TNetSystem.html:5245,Error,Error,5245,root/html532/TNetSystem.html,https://root.cern,https://root.cern/root/html532/TNetSystem.html,2,['Error'],['Error']
Availability,"_t* opt = """", const char* library_name = """", const char* build_dir = """", UInt_t dirmode = 0); virtual char*TSystem::ConcatFileName(const char* dir, const char* name); virtual Bool_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetSystem.html:3514,Error,Error,3514,root/html532/TXNetSystem.html,https://root.cern,https://root.cern/root/html532/TXNetSystem.html,3,['Error'],['Error']
Availability,"_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSelect(TList* active, Long_t timeout); virtual Int_tSelect(TFileHandler* fh, Long_t timeout); virtual intSendBuf(int sock, const void* buffer, int length); virtual intSendRaw(int sock, const void* buffer, int length, int flag); virtual voidTSystem::SetAclicMode(TSystem::EAclicMode mode); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTSystem::SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); virtual voidSetDisplay(); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetDynamicPath(const char* lib); virtual voidSetenv(const char* name, const char* value); voidTSystem::SetErrorStr(const char* errstr); virtual voidTSystem::SetFlagsDebug(const char*); virtual voidTSystem::SetFlagsOpt(const char*); virtual Int_tSetFPEMask(Int_t mask = kDefaultMask); virtual voidTSystem::SetIncludePath(const char* includePath); virtual voidTSystem::SetLinkdefSuffix(const char* suffix); virtual voidTSystem::SetLinkedLibs(const char* linkedLibs); virtual voidTSystem::SetMakeExe(const char* directives); virtual voidTSystem::SetMakeSharedLib(const char* directives); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:11723,mask,mask,11723,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,1,['mask'],['mask']
Availability,"_t* option = """"); -*-*Reset contents of a Profile2D histogram; *-* =======================================. void RebinAxis(Double_t x, TAxis* axis); Profile histogram is resized along axis such that x is in the axis range.; The new axis limits are recomputed by doubling iteratively; the current axis range until the specified value x is within the limits.; The algorithm makes a copy of the histogram, then loops on all bins; of the old histogram to fill the rebinned histogram.; Takes into account errors (Sumw2) if any.; The bit kCanRebin must be set before invoking this function.; Ex: h->SetBit(TH1::kCanRebin);. TProfile2D * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together*-*-*-*-. if newname is not blank a new profile hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to be merged into one bin of hnew; If the original profile has errors stored (via Sumw2), the resulting; profile has new errors correctly calculated. examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins; hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; // Carefull: previous contents of hpxpy are lost; hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; // Carefull: previous contents of hpxpy are lost; hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; TProfile2D *hnew = hpxpy->RebinY(5,""hnew""); // creates a new profile hnew; // merging 5 bins of hpxpy along the yaxis in one bin. NOTE : If nxgroup/nygroup is not an exact divider of the number of bins,; along the xaxis/yaxis the top limit(s) of the rebinned profile; is changed to the upper edge of the xbin=newxbins*nxgroup resp.; ybin=newybins*nygroup and the remaining bins are added to; the overflow bin.; Statistics will be recomputed from the ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:42125,error,errors,42125,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,12,['error'],['errors']
Availability,"_t* option = """"); static UInt_tAssignID(TObject* obj); virtual voidTObject::Browse(TBrowser* b); voidCheckInit(); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidCleanup(); virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tDecrementCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; static UInt_tGetNProcessIDs(); static UInt_tGetObjectCount(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObjArray*GetObjects() const; static Bool_tTObject::GetObjectStat(); TObject*GetObjectWithID(UInt_t uid); virtual Option_t*TObject::GetOption() const; static TProcessID*GetPID(); static TObjArray*GetPIDs(); static TProcessID*GetProcessID(UShort_t pid); static TProcessID*GetProcessWithUID(const TObject* obj); static TProcessID*GetProcessWithUID(UInt_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProcessID.html:3021,error,error,3021,root/html528/TProcessID.html,https://root.cern,https://root.cern/root/html528/TProcessID.html,10,['error'],['error']
Availability,"_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual TObject*Convert1D(Int_t id); virtual TObject*Convert2D(Int_t id); virtual TFile*Convert2root(const char* rootname = """", Int_t lrecl = 0, Option_t* option = """")MENU ; virtual TObject*ConvertCWN(Int_t id); virtual TObject*ConvertProfile(Int_t id); virtual TObject*ConvertRWN(Int_t id); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteID(Int_t id); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; TObject*Get(Int_t id); const char*GetCurDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntry(Int_t entry, Int_t id, Int_t atype, Float_t* x); Int_tGetEntryBranch(Int_t entry, Int_t id); virtual const char*TObject::GetIconName() const; TList*GetList() const; TList*GetListOfKeys() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetSize() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookFile.html:2438,error,error,2438,root/html528/THbookFile.html,https://root.cern,https://root.cern/root/html528/THbookFile.html,10,['error'],['error']
Availability,"_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProofMgr::Close(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTProofMgr::Cp(const char*, const char* = 0, const char* = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTProofMgr::DetachSession(Int_t, Option_t* = """"); virtual voidTProofMgr::DetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTProofMgr::Find(const char* = ""~/"", const char* = 0, const char* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTProofMgr::GetFile(const char*, const char*, const char* = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMgrLite.html:1910,Error,Error,1910,root/html532/TProofMgrLite.html,https://root.cern,https://root.cern/root/html532/TProofMgrLite.html,1,['Error'],['Error']
Availability,"_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProofMgr::Close(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tTProofMgr::Cp(const char*, const char* = 0, const char* = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTProofMgr::DetachSession(Int_t, Option_t* = """"); virtual voidTProofMgr::DetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTProofMgr::Find(const char* = ""~/"", const char* = 0, const char* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTProofMgr::GetFile(const char*, const char*, const char* = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*TProofMgr::GetMssUrl(Bool_t = kFALSE); virtual const char*TNamed::GetName() const; virtual char*TObject::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofMgrLite.html:1910,Error,Error,1910,root/html534/TProofMgrLite.html,https://root.cern,https://root.cern/root/html534/TProofMgrLite.html,3,['Error'],['Error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; RooPlot*contour(RooRealVar& var1, RooRealVar& var2, Double_t n1 = 1, Double_t n2 = 2, Double_t n3 = 0, Double_t n4 = 0, Double_t n5 = 0, Double_t n6 = 0); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooFitResult*fit(const char* options); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; Int_thesse(); Int_timprove(); virtual voidTObject::Info(const char* method, const char* msgfmt) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMinimizer.html:2414,error,error,2414,root/html526/RooMinimizer.html,https://root.cern,https://root.cern/root/html526/RooMinimizer.html,7,['error'],['error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Double_tCLb() const; Double_tCLbError() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Double_tCLs() const; Double_tCLsError() const; virtual Double_tCLsplusb() const; Double_tCLsplusbError() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::SamplingDistribution*GetAltDistribution() const; Bool_tGetBackGroundIsAlt() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; RooStats::SamplingDistribution*GetNullDistribution() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetPValueIsRightTail() const; Double_tGetTestStatisticData() const; virtual const char*TNamed::GetTitle() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestResult.html:2201,error,error,2201,root/html530/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestResult.html,3,['error'],['error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Double_tCLb() const; Double_tCLbError() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Double_tCLs() const; Double_tCLsError() const; virtual Double_tCLsplusb() const; Double_tCLsplusbError() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooStats::SamplingDistribution*GetAltDistribution() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; RooStats::SamplingDistribution*GetNullDistribution() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Bool_tGetPValueIsRightTail() const; Double_tGetTestStatisticData() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestResult.html:2201,error,error,2201,root/html528/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestResult.html,1,['error'],['error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Double_tCLb() const; Double_tCLbError() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Double_tCLs() const; Double_tCLsError() const; virtual Double_tCLsplusb() const; Double_tCLsplusbError() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const RooArgList*GetAllTestStatisticsData() const; RooDataSet*GetAltDetailedOutput() const; RooStats::SamplingDistribution*GetAltDistribution() const; Bool_tGetBackGroundIsAlt() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); RooDataSet*GetFitInfo() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; RooDataSet*GetNullDetailedOutput() const; RooStats::SamplingDistribution*GetNullDistribution() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectSta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestResult.html:2201,error,error,2201,root/html534/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestResult.html,6,['error'],['error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Bool_tEval(Long64_t evtidx, TParallelCoordSelect* select); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Bool_tGetBarHisto(); Bool_tGetBoxPlot(); Double_tGetCurrentAverage() const; Double_tGetCurrentMax() const; Double_tGetCurrentMin() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetEntryWeight(Long64_t evtidx); voidGetEntryXY(Long64_t n, Double_t& x, Double_t& y); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; Int_tGetHistBinning() const; Double_tGetHistHeight(); Int_tGetHistLineWidth(); TH1F*GetHistogram(); virtual const char*TObject::GetIconName() const; Int_tGetId(); virtual Color_tTAttLine::GetLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoordVar.html:2315,error,error,2315,root/html530/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html530/TParallelCoordVar.html,9,['error'],['error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpLinSolverBase.html:1663,error,error,1663,root/html528/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html,10,['error'],['error']
Availability,"_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidBuild(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDistance(const double* point, int ind, Int_t type = 2) const; voidDistanceToNode(const double* point, int inode, double& min, double& max, Int_t type = 2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFindBNodeA(double* point, double* delta, Int_t& inode); voidFindInRange(double* point, double range, vector<int>& res); voidFindNearestNeighbors(const double* point, Int_t k, int* ind, double* dist); intFindNode(const double* point) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindPoint(double* point, int& index, Int_t& iter); double*GetBoundaries(); double*GetBoundariesExact(); double*GetBoundary(const Int_t node); double*GetBoundaryExact(const Int_t node); intGetBucketSize(); Int_tGetCrossNode(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; int*GetIndPoints(); Int_tGetLeft",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDTree_int_double_.html:11211,error,error,11211,root/html528/TKDTree_int_double_.html,https://root.cern,https://root.cern/root/html528/TKDTree_int_double_.html,10,['error'],['error']
Availability,"_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Rectangle_tTPad:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInspectCanvas.html:5968,Error,Error,5968,root/html602/TInspectCanvas.html,https://root.cern,https://root.cern/root/html602/TInspectCanvas.html,2,['Error'],['Error']
Availability,"_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDialogCanvas.html:6333,Error,Error,6333,root/html602/TDialogCanvas.html,https://root.cern,https://root.cern/root/html602/TDialogCanvas.html,2,['Error'],['Error']
Availability,"_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountNodes(Int_t nlevels = 1000, Int_t option = 0); static voidCreateDummyMedium(); virtual voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """")MENU ; static TGeoMedium*DummyMedium(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tExport(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tFindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFindOverlaps() const; virtual Int_tGetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*GetField() const; virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoPatternFinder*GetFinder() const; TGeoExtension*GetFWExtension() const; TGeoManager*GetGeoManager() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:19850,error,error,19850,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,6,['error'],['error']
Availability,"_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetAlpha() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:2935,Error,Error,2935,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,1,['Error'],['Error']
Availability,"_t* point, Double_t* dir) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; Double_tGetDx1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTrd1.html:2755,Error,Error,2755,root/html532/TGeoTrd1.html,https://root.cern,https://root.cern/root/html532/TGeoTrd1.html,2,['Error'],['Error']
Availability,"_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoPcon::DistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&TGeoPcon::Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoPcon::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoPcon::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tTGeoPcon::GetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPgon.html:3136,error,error,3136,root/html528/TGeoPgon.html,https://root.cern,https://root.cern/root/html528/TGeoPgon.html,4,['error'],['error']
Availability,"_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*TGeoBBox::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawPolygon(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoBBox::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidTGeoBBox::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoBBox::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoXtru.html:4765,Error,Error,4765,root/html534/TGeoXtru.html,https://root.cern,https://root.cern/root/html534/TGeoXtru.html,3,['Error'],['Error']
Availability,"_t* w = 0); Double_tRMS(Long64_t n, const float* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const double* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long* a, const Double_t* w = 0); Double_tRMS(Long64_t n, const long long* a, const Double_t* w = 0); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSignalingNaN(); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_t ndf); Double_tStudentI(Double_t T, Double_t ndf); Double_tStudentQuantile(Double_t p, Double_t ndf, Bool_t lower_tail = kTRUE); Double_tTan(Double_t x); Double_tTanH(Double_t x); Double_tTwoPi(); Double_tVavilov(Double_t x, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMath.html:11003,down,down,11003,root/html534/TMath.html,https://root.cern,https://root.cern/root/html534/TMath.html,2,['down'],['down']
Availability,"_t* x, Double_t* y, Int_t n, Double_t& xs, Double_t& ys, Int_t nleft, Int_t nright, Double_t* w, Bool_t userw, Double_t* rw, Bool_t& ok); virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; static voidPsort(Double_t* x, Int_t n, Int_t k); static voidRank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static Int_tRcmp(Double_t x, Double_t y); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; voidSmoothin(TGraph* grin); TGraph*SmoothKern(TGraph* grin, Option_t* option = ""normal"", Double_t band",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphSmooth.html:4766,down,down,4766,root/html602/TGraphSmooth.html,https://root.cern,https://root.cern/root/html602/TGraphSmooth.html,4,['down'],['down']
Availability,"_t> fCanSplit; //!Indicates whether this class can be split or not. Values are -1, 0, 1, 2; 246 ; 247 // Bit field; 248 /// Indicates whether this class represents a pair and was not created from a dictionary nor interpreter info but has; 249 /// compiler compatible offset and size (and all the info is in the StreamerInfo per se); 250 Bool_t fIsSyntheticPair : 1; //!; 251 ; 252 /// @brief The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer.; 253 Bool_t fHasCustomStreamerMember : 1; //!; 254 ; 255 mutable std::atomic<Long_t> fProperty; //!Property See TClass::Property() for details; 256 mutable Long_t fClassProperty; //!C++ Property of the class (is abstract, has virtual table, etc.); 257 ; 258 // fHasRootPcmInfo needs to be atomic as long as GetListOfBases needs to modify it.; 259 std::atomic<Bool_t> fHasRootPcmInfo; //!Whether info was loaded from a root pcm.; 260 mutable std::atomic<Bool_t> fCanLoadClassInfo; //!Indicates whether the ClassInfo is supposed to be available.; 261 mutable std::atomic<Bool_t> fIsOffsetStreamerSet; //!saved remember if fOffsetStreamer has been set.; 262 mutable std::atomic<Bool_t> fVersionUsed; //!Indicates whether GetClassVersion has been called; 263 ; 264 enum class ERuntimeProperties : UChar_t {; 265 kNotInitialized = 0,; 266 kSet = BIT(0),; 267 // kInconsistent when kSet & !kConsistent.; 268 kConsistentHash = BIT(1); 269 };; 270 friend bool operator&(UChar_t l, ERuntimeProperties r) {; 271 return l & static_cast<UChar_t>(r);; 272 }; 273 mutable std::atomic<UChar_t> fRuntimeProperties; //! Properties that can only be evaluated at run-time; 274 ; 275 mutable Longptr_t fOffsetStreamer; //!saved info to call Streamer; 276 Int_t fStreamerType; //!cached of the streaming method to use; 277 EState fState; //!Current 'state' of the class (Emulated,Interpreted,Loaded); 278 mutable std::atomic<TVirtualStreamerInfo*> fCurrentInfo; //!cached current streamer info.; 279 mutabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:11799,avail,available,11799,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['avail'],['available']
Availability,"_tCanBypassStreamer() const; Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClonesArray.html:6552,Error,Error,6552,root/html602/TClonesArray.html,https://root.cern,https://root.cern/root/html602/TClonesArray.html,2,['Error'],['Error']
Availability,"_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; static Int_tCleanUp(); static Int_tCleanUpPop(Int_t exe = 0); static Int_tCleanUpPush(void* free, void* arg = 0); virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* option = """"); static Int_tDelete(TThread*& th); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Int_tExists(); static Int_tExit(void* ret = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Long_tGetId() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TThread::EPriorityGetPriority() const; TThread::EStateGetState() const; static TThread*GetThread(Long_t id); static TThread*GetThread(const char* name); static Int_tGetTime(ULong_t* absSec, ULong_t* absNanoSec); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThread.html:1969,error,error,1969,root/html528/TThread.html,https://root.cern,https://root.cern/root/html528/TThread.html,10,['error'],['error']
Availability,"_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp = 0); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNetSystem.html:5302,error,error,5302,root/html528/TNetSystem.html,https://root.cern,https://root.cern/root/html528/TNetSystem.html,6,['error'],['error']
Availability,"_tConsistentWith(const char* path, void* dirptr); virtual voidTNamed::Copy(TObject& named) const; virtual intTSystem::CopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*TSystem::DirName(const char* pathname); virtual voidTSystem::DispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual char*TSystem::DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tTSystem::DynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTSystem::Exec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTSystem::Exit(int code, Bool_t mode = kTRUE); virtual voidTSystem::ExitLoop(); virtual Bool_tTSystem::ExpandPathName(TString& path); virtual char*TSystem::ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*TSystem::FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeTSystem::GetAclicMode() const; virtual Int_tTSystem::GetAclicProperties() const; voidTSystem::GetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*TSystem::GetBuildArch() const; virtual const char*TSyste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetSystem.html:3571,error,error,3571,root/html528/TXNetSystem.html,https://root.cern,https://root.cern/root/html528/TXNetSystem.html,8,['error'],['error']
Availability,"_tDistFromOutside(const Double_t* point, const Double_t* dir, Double_t dx, Double_t dy, Double_t dz, const Double_t* origin, Double_t stepmax = TGeoShape::Big()); virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetDX() const; virtual Double_tGetDY() const; virtual Double_tGetDZ() const; virtual Double_tGetFacetArea(Int_t index = 0) const; virtual Int_tGetFittingBox(const TGeoBBox* parambox, TGeoM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoBBox.html:5448,error,error,5448,root/html534/TGeoBBox.html,https://root.cern,https://root.cern/root/html534/TGeoBBox.html,6,['error'],['error']
Availability,"_tGetEffSForEffBof(Double_t effBref, Double_t& effSerr); TH1*GetMvaBpdf(); TH1*GetMvaSpdf(); TH1*GetPurity(Int_t nStot, Int_t nBtot); TH1D*GetROC(); Double_tGetROCIntegral(); Double_tGetSignalReferenceCut(); TH1*GetSignificance(Int_t nStot, Int_t nBtot); TMVA::ROCCalc&operator=(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(const TMVA::ROCCalc&); TMVA::ROCCalcROCCalc(TH1* mvaS, TH1* mvaB). private:. Double_tGetEffForRoot(Double_t theCut); TMVA::MsgLogger&Log() const; Double_tRoot(Double_t). Data Members; private:. Double_tfAbsTolabsolute tolerance deviation; Int_tfCutOrientation+1 if larger mva value means more signal like, -1 otherwise; TMVA::MsgLogger*fLogger! message logger; Int_tfMaxItermaximum number of iterations; UInt_tfNbins; Double_tfNevtSnumber of signal events (used in error calculation); TH1*fPurity; Double_tfSignalCutMVA cut value for last demanded background rejection or signal efficiency; TH1*fSignificance; TSpline*fSplB; TSpline*fSplS; TSpline*fSpleffBvsS; TSpline*fSplmvaCumBspline of cumulated mva distributions; TSpline*fSplmvaCumSspline of cumulated mva distributions; Bool_tfUseSplines; Float_tfXmaxmin and max of the mva distribution; Float_tfXminmin and max of the mva distribution; TH1*fmvaBthe input mva distributions; TH1*fmvaBcumul; TH1*fmvaBpdfthe normalized (and rebinned) input mva distributions; TH1*fmvaSthe input mva distributions; TH1*fmvaScumul; TH1*fmvaSpdfthe normalized (and rebinned) input mva distributions; Int_tfnBtot; Int_tfnStot. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ROCCalc(TH1* mvaS, TH1* mvaB). void ApplySignalAndBackgroundStyle(TH1* sig, TH1* bkg, TH1* any = 0); Int_t c_Canvas = TColor::GetColor( ""#f0f0f0"" );; Int_t c_FrameFill = TColor::GetColor( ""#fffffd"" );; Int_t c_TitleBox = TColor::GetColor( ""#5D6B7D"" );; Int_t c_TitleBorder = TColor::GetColor( ""#7D8B9D"" );; Int_t c_TitleText = TColor::GetColor( ""#FFFFFF"" );. ~ROCCalc(); destructor. TH1D* GetROC(); get the ROC curve. Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__ROCCalc.html:941,toler,tolerance,941,root/html602/TMVA__ROCCalc.html,https://root.cern,https://root.cern/root/html602/TMVA__ROCCalc.html,8,"['error', 'toler']","['error', 'tolerance']"
Availability,"_tNbPols() const; UInt_tNbSegs() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); Bool_tSectionsValid(UInt_t mask) const; voidSetAABoundingBox(const Double_t[3] origin, const Double_t[3] halfLengths); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetLocalMasterIdentity(); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRawSizes(UInt_t reqPnts, UInt_t reqPntsCapacity, UInt_t reqSegs, UInt_t reqSegsCapacity, UInt_t reqPols, UInt_t reqPolsCapacity); voidSetSectionsValid(UInt_t mask); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; TBuffer3D(Int_t type, UInt_t reqPnts = 0, UInt_t reqPntsCapacity = 0, UInt_t reqSegs = 0, UInt_t reqSegsCapacity = 0, UInt_t reqPols = 0, UInt_t reqPolsCapacity = 0); Bool_tTObject::TestBit(UInt_t f) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBuffer3D.html:12639,mask,mask,12639,root/html602/TBuffer3D.html,https://root.cern,https://root.cern/root/html602/TBuffer3D.html,4,['mask'],['mask']
Availability,"_tPointInRegion(Int_t x, Int_t y, Region_t reg); virtual Region_tPolygonRegion(Point_t* points, Int_t np, Bool_t winding); virtual voidTObject::Pop(); static voidPostQtEvent(QObject* receiver, QEvent* event); virtual voidTNamed::Print(Option_t* option = """") const; static voidPrintEvent(Event_t&); virtual Int_tprocessQtEvents(Int_t maxtime = 300); virtual voidPutByte(Byte_t b); virtual voidPutImage(Drawable_t id, GContext_t gc, Drawable_t img, Int_t dx, Int_t dy, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidPutPixel(Drawable_t id, Int_t x, Int_t y, ULong_t pixel); TQtClientFilter*QClientFilter() const; QColorQtColor(ULong_t pixel); static QStringQtFileFormat(const char* selector); static QStringQtFileFormat(const QString& selector); virtual voidQueryColor(Colormap_t cmap, ColorStruct_t& color); virtual voidQueryPointer(Int_t& ix, Int_t& iy); virtual voidQueryPointer(Window_t id, Window_t& rootw, Window_t& childw, Int_t& root_x, Int_t& root_y, Int_t& win_x, Int_t& win_y, UInt_t& mask); virtual voidRaiseWindow(Window_t id); virtual Int_tTObject::Read(const char* name); virtual Pixmap_tReadGIF(Int_t x0, Int_t y0, const char* file, Window_t id = 0); virtual Bool_tReadPictureDataFromFile(const char* filename, char*** ret_data); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemoveWindow(ULong_t qwid); virtual voidReparentWindow(Window_t id, Window_t pid, Int_t x, Int_t y); virtual Int_tRequestLocator(Int_t mode, Int_t ctyp, Int_t& x, Int_t& y); virtual Int_tRequestString(Int_t x, Int_t y, char* text); virtual voidRescaleWindow(Int_t wid, UInt_t w, UInt_t h); virtual voidTAttFill::ResetAttFill(Option_t* option = """"); virtual voidTAttLine::ResetAttLine(Option_t* option = """"); virtual voidTAttMarker::ResetAttMarker(Option_t* toption = """"); virtual voidTAttText::ResetAttText(Option_t* toption = """"); voidTObject::ResetBit(UInt_t f); virtual Int_tResizePixmap(Int_t wid, UInt_t w, UInt_t h); virtual voidResizeWindow(Int_t wid); virtual voidResizeWindow(Wind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGQt.html:14475,mask,mask,14475,root/html602/TGQt.html,https://root.cern,https://root.cern/root/html602/TGQt.html,4,['mask'],['mask']
Availability,"_tR(); Double_tRadToDeg(); Short_tRange(Short_t lb, Short_t ub, Short_t x); Int_tRange(Int_t lb, Int_t ub, Int_t x); Long_tRange(Long_t lb, Long_t ub, Long_t x); ULong_tRange(ULong_t lb, ULong_t ub, ULong_t x); Double_tRange(Double_t lb, Double_t ub, Double_t x); Double_tRgair(); Double_tRMS(Long64_t n, const short* a); Double_tRMS(Long64_t n, const int* a); Double_tRMS(Long64_t n, const float* a); Double_tRMS(Long64_t n, const double* a); Double_tRMS(Long64_t n, const long* a); Double_tRMS(Long64_t n, const long long* a); Bool_tRootsCubic(const Double_t* coef, Double_t& a, Double_t& b, Double_t& c); Double_tRUncertainty(); Double_tSigma(); Double_tSigmaUncertainty(); Short_tSign(Short_t a, Short_t b); Int_tSign(Int_t a, Int_t b); Long_tSign(Long_t a, Long_t b); Long64_tSign(Long64_t a, Long64_t b); Float_tSign(Float_t a, Float_t b); Double_tSign(Double_t a, Double_t b); Double_tSin(Double_t x); Double_tSinH(Double_t x); voidSort(long long n, const short* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const int* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const float* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const double* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long* a, long long* index, Bool_t down = kTRUE); voidSort(long long n, const long long* a, long long* index, Bool_t down = kTRUE); voidSort(int n, const short* a, int* index, Bool_t down = kTRUE); voidSort(int n, const int* a, int* index, Bool_t down = kTRUE); voidSort(int n, const float* a, int* index, Bool_t down = kTRUE); voidSort(int n, const double* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long* a, int* index, Bool_t down = kTRUE); voidSort(int n, const long long* a, int* index, Bool_t down = kTRUE); Double_tSqrt(Double_t x); Double_tSqrt2(); Double_tStruveH0(Double_t x); Double_tStruveH1(Double_t x); Double_tStruveL0(Double_t x); Double_tStruveL1(Double_t x); Double_tStudent(Double_t T, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMath.html:10302,down,down,10302,root/html528/TMath.html,https://root.cern,https://root.cern/root/html528/TMath.html,1,['down'],['down']
Availability,"_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); voidsetCallWarning(Int_t threshold = 2000); voidsetConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:31436,Error,ErrorLoggingMode,31436,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,3,['Error'],['ErrorLoggingMode']
Availability,"_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooArgSet*_curNormSet!; Double_t_cutOffCutoff parameter for running product; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Int_t_extendedIndexIndex of extended PDF (if any) ; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAICRegistry_genCode! Registry of composite direct generator codes; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:39320,error,errors,39320,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['error'],['errors']
Availability,"_tTApplication::NoLogoOpt() const; Bool_tTApplication::NoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidTApplication::Open(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TObject&TObject::operator=(const TObject& rhs); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); Int_tReceiveFile(const char* file, Bool_t bin, Long64_t size); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidReleaseWorker(const char*); virtual voidTApplication::RemoveIdleTimer(); voidReset(const char* dir); voidTObject::ResetBit(UInt_t f); static voidResolveKeywords(TString& fname, const char* path = 0); voidRestartComputeTime(); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Int_tSendAsynMessage(const char* msg, Bool_t lf = kTRUE); virtual voidSendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); voidSendParallel(Bool_t async = kFALSE);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:9882,error,error,9882,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['error'],['error']
Availability,"_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t i) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tTSeqCollection::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject*) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TBtree.html:9164,Error,Error,9164,root/html532/TBtree.html,https://root.cern,https://root.cern/root/html532/TBtree.html,2,['Error'],['Error']
Availability,"_tTEveProjection::fPastFixZScalerelative scaling beyond fFixZ; vector<TEveProjection::PreScaleEntry_t,allocator<TEveProjection::PreScaleEntry_t> >TEveProjection::fPreScales[3]scaling before the distortion; Float_tTEveProjection::fScaleRscale factor to keep projected radius at fFixR fixed; Float_tTEveProjection::fScaleZscale factor to keep projected z-coordinate at fFixZ fixed; TEveProjection::EPType_eTEveProjection::fTypetype; Bool_tTEveProjection::fUsePreScaleuse pre-scaling. private:. TEveVectorfProjectedCenterprojected center of distortion. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveRhoZProjection(); Constructor. void ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, TEveProjection::EPProc_e proc = kPP_Full); Project point. void SetCenter(TEveVector& v); Set center of distortion (virtual method). void SetDirectionalVector(Int_t screenAxis, TEveVector& vec); Get direction in the unprojected space for axis index in the; projected space.; This is virtual method from base-class TEveProjection. Bool_t AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const; Check if segment of two projected points is valid. Move slightly one of the points if by shifting it by no more than; tolearance the segment can become acceptable. Int_t SubSpaceId(const TEveVector& v) const; Return sub-space id for the point.; 0 - upper half-space; 1 - lowwer half-space. Bool_t IsOnSubSpaceBoundrary(const TEveVector& v) const; Checks if point is on sub-space boundrary. Bool_t Is2D() const. Bool_t Is3D() const. Float_t* GetProjectedCenter(). Bool_t HasSeveralSubSpaces() const; { return kFALSE; }. TEveRhoZProjection(). virtual ~TEveRhoZProjection(); {}. » Last changed: root/eve:$Id: TEveProjections.h 39679 2011-06-11 00:05:06Z matevz $ » Last generated: 2011-11-03 20:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveRhoZProjection.html:6220,toler,tolerance,6220,root/html532/TEveRhoZProjection.html,https://root.cern,https://root.cern/root/html532/TEveRhoZProjection.html,2,['toler'],['tolerance']
Availability,"_tTEveProjection::fPastFixZScalerelative scaling beyond fFixZ; vector<TEveProjection::PreScaleEntry_t,allocator<TEveProjection::PreScaleEntry_t> >TEveProjection::fPreScales[3]scaling before the distortion; Float_tTEveProjection::fScaleRscale factor to keep projected radius at fFixR fixed; Float_tTEveProjection::fScaleZscale factor to keep projected z-coordinate at fFixZ fixed; TEveProjection::EPType_eTEveProjection::fTypetype; Bool_tTEveProjection::fUsePreScaleuse pre-scaling. private:. TEveVectorfProjectedCenterprojected center of distortion. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveRhoZProjection(); Constructor. void ProjectPoint(Float_t& x, Float_t& y, Float_t& z, Float_t d, TEveProjection::EPProc_e proc = kPP_Full); Project point. void SetCenter(TEveVector& v); Set center of distortion (virtual method). void SetDirectionalVector(Int_t screenAxis, TEveVector& vec); Get direction in the unprojected space for axis index in the; projected space.; This is virtual method from base-class TEveProjection. Bool_t AcceptSegment(TEveVector& v1, TEveVector& v2, Float_t tolerance) const; Check if segment of two projected points is valid. Move slightly one of the points if by shifting it by no more than; tolearance the segment can become acceptable. Int_t SubSpaceId(const TEveVector& v) const; Return sub-space id for the point.; 0 - upper half-space; 1 - lowwer half-space. Bool_t IsOnSubSpaceBoundrary(const TEveVector& v) const; Checks if point is on sub-space boundrary. Bool_t Is2D() const. Bool_t Is3D() const. Float_t* GetProjectedCenter(). Bool_t HasSeveralSubSpaces() const; { return kFALSE; }. TEveRhoZProjection(). virtual ~TEveRhoZProjection(); {}. » Last changed: root/eve:$Id: TEveProjections.h 39682 2011-06-11 05:37:08Z matevz $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEveRhoZProjection.html:6220,toler,tolerance,6220,root/html530/TEveRhoZProjection.html,https://root.cern,https://root.cern/root/html530/TEveRhoZProjection.html,1,['toler'],['tolerance']
Availability,"_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; TGCompositeFrame*TGeoTrapEditor::fDFrameFrame containing Delayed draw; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*TGeoTrapEditor::fDelayedCheck button for delayed draw; Double_tTGeoTrapEditor::fDziInitial Dz; TGNumberEntry*TGeoTrapEditor::fEAlpha1Number entry for Alpha1; TGNumberEntry*TGeoTrapEditor::fEBl1Number entry for Bl1; TGNumberEntry*TGeoTrapEditor::fEDzNumber entry for DZ; TGNumberEntry*TGeoTrapEditor::fEH1Number entry for H1; TGNumberEntry*TGeoTrapEditor::fEPhiNumber entry for Theta; TGNumberEntry*TGeoTrapEditor::fESc1Number entry for lower scale; TGNumberEntry*TGeoTrapEditor::fESc2Number entry for upper scale; TGNumberEntry*TGeoTrapEditor::fEThetaNumber entry for Theta; TGNumberEntry*TGeoTrapEditor::fETl1Number entry for Tl1; TGNumberEntry*fETwistNumber entry for H1; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; Double_tTGeoTrapEditor::fH1iInitial half length in y at low z; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGeoTrapEditor::fIsModifiedFlag that volume was modified; Bool_tTGeoTrapEditor::fIsShapeEditableFlag that the shape can be changed; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoGtraEditor.html:19737,mask,mask,19737,root/html602/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html602/TGeoGtraEditor.html,4,['mask'],['mask']
Availability,"_tTGeoBBox::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoGtra.html:3860,Error,Error,3860,root/html532/TGeoGtra.html,https://root.cern,https://root.cern/root/html532/TGeoGtra.html,1,['Error'],['Error']
Availability,"_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(const char*, Double_t); Int_tFill(Double_t, const char*, Double_t); Int_tFill(const char*, Double_t, Double_t); Int_tFill(const char*, const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tFill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tFill(const char* namex, Double_t y, const char* namez, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH3.html:2943,Error,Error,2943,root/html532/TH3.html,https://root.cern,https://root.cern/root/html532/TH3.html,1,['Error'],['Error']
Availability,"_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidCopy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH1::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(Double_t x, const char* namey, Double_t w); virtual Int_tFill(const char* namex, Double_t y, Double_t w); virtual Int_tFill(const char* namex, const char* namey, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidFillN(Int_t ntimes, const Double_t* x, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2.html:2690,Error,Error,2690,root/html532/TH2.html,https://root.cern,https://root.cern/root/html532/TH2.html,1,['Error'],['Error']
Availability,"_tTNamed::Compare(const TObject* obj) const; virtual Double_tTH1::ComputeIntegral(); virtual voidTH2::Copy(TObject& hnew) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTH1::Divide(const TH1* h1); virtual voidTH1::Divide(TF1* f1, Double_t c1 = 1); virtual voidTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(const char* name, Double_t w); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(Double_t, const char*, Double_t); virtual Int_tFill(const char*, Double_t, Double_t); virtual Int_tFill(const char*, const char*, Double_t); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH2Poly.html:7809,Error,Error,7809,root/html532/TH2Poly.html,https://root.cern,https://root.cern/root/html532/TH2Poly.html,1,['Error'],['Error']
Availability,"_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& color) const; static voidCreateColorsCircle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorsGray(); static voidCreateColorsRectangle(Int_t offset, const char* name, UChar_t* rgb); static voidCreateColorWheel(); static Int_tCreateGradientColorTable(UInt_t Number, Double_t* Stops, Double_t* Red, Double_t* Green, Double_t* Blue, UInt_t NColors); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Float_tGetAlpha() const; Float_tGetBlue() const; static Int_tGetColor(const char* hexcolor); static Int_tGetColor(ULong_t pixel); static Int_tGetColor(Float_t r, Float_t g, Float_t b); static Int_tGetColor(Int_t r, Int_t g, Int_t b); static Int_tGetColorBright(Int_t color); static Int_tGetColorDark(Int_t color); static Int_tGetColorPalette(Int_t i); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Float_tGetGrayscale() const; Float_tGetGreen() const; virtual voidGetHLS(Float_t& h, Float_t& l, Float_t& s) const; Float_tGetHue() const; virtual const char*TObject::GetIconName() const; Float_tGetLight() const; virtual const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TColor.html:9161,error,error,9161,root/html526/TColor.html,https://root.cern,https://root.cern/root/html526/TColor.html,5,['error'],['error']
Availability,"_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = NULL); voidDrawChainScatter(RooRealVar& xVar, RooRealVar& yVar); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawNLLHist(Option_t* options = NULL); voidDrawNLLVsTime(); voidDrawParameterVsTime(RooRealVar& param); voidDrawWeightHist(Option_t* options = NULL); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__MCMCIntervalPlot.html:2148,error,error,2148,root/html528/RooStats__MCMCIntervalPlot.html,https://root.cern,https://root.cern/root/html528/RooStats__MCMCIntervalPlot.html,6,['error'],['error']
Availability,"_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt); virtual Long64_tDraw(const char* varexp, const TCut& selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual Long64_tDraw(const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBaskets(); virtual Int_tDropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); virtual Int_tDropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); virtual voidDropBuffers(Int_t nbytes); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tFill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TBranch*FindBranch(const char* name); virtual TLeaf*FindLeaf(const char* name); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Option_t* goption = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0)MENU ; virtual Int_tFlushBaskets() const; virtual const char*GetAlias(const char* aliasName) const; virtual Long64_tGetAutoFlush() const; virtual Long64_tGetAutoSave() const; virtual TBranch*GetBranch(const char* name); virtual TBranchRef*GetBranchRef() const; virtual Bool_tGetBranchStatus(const char* branchname) const; static Int_tGetBranchStyle(); virtual Long64_tGetCacheSiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:16014,error,error,16014,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['error'],['error']
Availability,"_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TProofServLite&operator=(const TProofServLite&); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTProofServ::Print(Option_t* option = """") const; virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); Int_tTProofServ::ReceiveFile(const char* file, Bool_t bin, Long64_t size); virtual voidTObject::RecursiveRemove(TObject* obj); static Int_tTProofServ::RegisterDataSets(TList* in, TList* out, TDataSetManager* dsm, TString& e); virtual voidTProofServ::ReleaseWorker(const char*); virtual voidTApplication::RemoveIdleTimer(); voidTProofServ::Reset(const char* dir); voidTObject::ResetBit(UInt_t f); static voidTProofServ::ResolveKeywords(TString& fname, const char* path = 0); voidTProofServ::RestartComputeTime(); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidTProofServ::Run(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Int_tTProofServ::SendAsynMessage(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofServLite.html:10893,error,error,10893,root/html602/TProofServLite.html,https://root.cern,https://root.cern/root/html602/TProofServLite.html,4,['error'],['error']
Availability,"_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. Double_tfDEDw! the derivative of the total error wrt the synapse weight; TNeuron*fpostthe neuron after the synapse; TNeuron*fprethe neuron before the synapse; Double_tfweightthe weight of the synapse. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSynapse(); Default constructor. TSynapse(TNeuron* , TNeuron* , Double_t w = 1); Constructor that connects two neurons. void SetPre(TNeuron* pre); Sets the pre-neuron. void SetPost(TNeuron* post); Sets the post-neuron. Double_t GetValue() const; Returns the value: weithted input. Double_t GetDeDw() const; Computes the derivative of the error wrt the synapse weight. void SetWeight(Double_t w); Sets the weight of the synapse.; This weight is the multiplying factor applied on the; output of a neuron in the linear combination given as input; of another neuron. void SetDEDw(Double_t in); Sets the derivative of the total error wrt the synapse weight. TSynapse(). virtual ~TSynapse(); {}. TNeuron* GetPre() const; { return fpre; }. TNeuron* GetPost() const; { return fpost; }. Double_t GetWeight() const; { return fweight; }. Double_t GetDEDw() const; { return fDEDw; }. » Author: Christophe.Delaere@cern.ch 20/07/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/mlp:$Id$ » Last generated: 2015-03-14 16:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSynapse.html:6199,error,error,6199,root/html534/TSynapse.html,https://root.cern,https://root.cern/root/html534/TSynapse.html,4,['error'],['error']
Availability,"_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications; static Long64_tTProofServ::fgLastEntryLast entry before exception; static TStringTProofServ::fgLastMsgMessage about status before exception. private:. TXSocketHandler*fInputHandler; TXProofServInterruptHandler*fInterruptHandler; TStringfSockPath; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void Rele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofServ.html:18046,alive,alive,18046,root/html534/TXProofServ.html,https://root.cern,https://root.cern/root/html534/TXProofServ.html,2,['alive'],['alive']
Availability,"_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions; static TProofDraw::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofDraw(); Constructor. ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). TProofDraw(). int Version() const; { return 1; }. » Author: Maarten Ballintijn 24/09/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-03 17:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofDraw.html:9227,error,error,9227,root/html604/TProofDraw.html,https://root.cern,https://root.cern/root/html604/TProofDraw.html,2,['error'],['error']
Availability,"_tTSelector::fStatusSelector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions; static TProofDraw::(anonymous)kWarn. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofDraw(); Constructor. ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles each variable from fTreeDrawArgsParser for the tree fTree.; Return kFALSE if any of the variable is not compilable. void DoFill(Long64_t entry, Double_t w, const Double_t* v). void DefVar(). TProofDraw(). int Version() const; { return 1; }. » Author: Maarten Ballintijn 24/09/2003 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 15:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofDraw.html:9227,error,error,9227,root/html602/TProofDraw.html,https://root.cern,https://root.cern/root/html602/TProofDraw.html,2,['error'],['error']
Availability,"_tTWebFile::fSizefile size; TSocket*TWebFile::fSocketsocket for HTTP/1.1 (stays alive between calls); Double_tTFile::fSum2BufferSum of squares of buffer sizes of objects written so far; Double_tTFile::fSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; TUrlTWebFile::fUrlOrgsave original url in case of temp redirection; Bool_tfUseMultiRangeIs the S3 server capable of serving multirange requests?; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static TUrlTWebFile::fgProxyglobally set proxy URL; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TDirectory. ←",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TS3WebFile.html:25567,alive,alive,25567,root/html602/TS3WebFile.html,https://root.cern,https://root.cern/root/html602/TS3WebFile.html,4,['alive'],['alive']
Availability,"_t_reMinLow edge of real dimension of CERF-LUT; static Double_t_reRangeRange in real dimension of CERF-LUT; static Double_t_reStepGrid spacing in real dimension of CERF-LUT. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooComplex FastComplexErrFunc(const RooComplex& z). Double_t FastComplexErrFuncRe(const RooComplex& z). Double_t FastComplexErrFuncIm(const RooComplex& z). void cacheCERF(Bool_t flag = kTRUE). RooComplex ComplexErrFunc(Double_t re, Double_t im = 0); Return CERNlib complex error function for Z(re,im). RooComplex ComplexErrFunc(const RooComplex& z); Return CERNlib complex error function. This code is translated from the fortran version in the CERN mathlib.; (see ftp://asisftp.cern.ch/cernlib/share/pro/src/mathlib/gen/c/cwerf64.F). void initFastCERF(Int_t reBins = 800, Double_t reMin = -4.0, Double_t reMax = 4.0, Int_t imBins = 1000, Double_t imMin = -4.0, Double_t imMax = 6.0); Allocate and initialize lookup table for interpolated complex error function; for given grid parameters. void cleanup(). RooComplex ITPComplexErrFunc(const RooComplex& z, Int_t nOrder); Return complex error function interpolated from lookup tabel created; by initFastCERF(). Interpolation is performed in Im and Re plane; to specified order. Double_t ITPComplexErrFuncRe(const RooComplex& z, Int_t nOrder); Return real component of complex error function interpolated from; lookup table created by initFastCERF(). Interpolation is performed in; Im and Re plane to specified order. This functions is noticably faster; than ITPComplexErrrFunc().re() because only the real lookup table; is interpolated. Double_t ITPComplexErrFuncIm(const RooComplex& z, Int_t nOrder); Return real component of complex error function interpolated from; lookup table created by initFastCERF(). Interpolation is performed in; Im and Re plane to specified order. This functions is noticably faster; than ITPComplexErrrFunc().im() because only the imaginary lookup table; is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMath.html:3378,error,error,3378,root/html526/RooMath.html,https://root.cern,https://root.cern/root/html526/RooMath.html,5,['error'],['error']
Availability,"_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; CallEndOfProcessCleanupsstatic void CallEndOfProcessCleanups()Definition TApplication.cxx:79; FOOTNOTE#define FOOTNOTE; gApplicationTApplication * gApplicationDefinition TApplication.cxx:53; TApplication.h; gApplicationR__EXTERN TApplication * gApplicationDefinition TApplication.h:170; TBrowser.h; TClassEdit.h; TClassTable.h; gClassTableR__EXTERN TClassTable * gClassTableDefinition TClassTable.h:104; TColor.h; TDataMember.h; kIsInlined@ kIsInlinedDefinition TDictionary.h:131; kIsConstexpr@ kIsConstexprDefinition TDictionary.h:93; kIsStruct@ kIsStructDefinition TDictionary.h:66; kIsVirtual@ kIsVirtualDefinition TDictionary.h:72; kIsNamespace@ kIsNamespaceDefinition TDictionary.h:95; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TException.h; gExceptionR__EXTERN ExceptionContext_t * gExceptionDefinition TException.h:69; ThrowR__EXTERN void Throw(int code)If an exception context has been set (using the TRY and RETRY macros) jump back to where it was set.Definition TException.cxx:27; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32Vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:81837,error,error,81837,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"_tfOrderfor Polynomial Kernel ( polynomial order ); TMVA::SVKernelFunction*fSVKernelFunctionkernel function; vector<TMVA::SVEvent*>*fSupportVectorscontains support vectors; TStringfTheKernelkernel name; Float_tfThetafor Sigmoidal Kernel; Float_tfTolerancetolerance parameter; TMVA::SVWorkingSet*fWgSetsvm working set . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(). void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Marcin Wolter, Andrzej Zemla » Copyright (c) 200",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodSVM.html:16863,avail,available,16863,root/html528/TMVA__MethodSVM.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodSVM.html,4,['avail'],['available']
Availability,"_tfOrderfor Polynomial Kernel ( polynomial order ); TMVA::SVKernelFunction*fSVKernelFunctionkernel function; vector<TMVA::SVEvent*>*fSupportVectorscontains support vectors; TStringfTheKernelkernel name; Float_tfThetafor Sigmoidal Kernel; Float_tfTolerancetolerance parameter; TMVA::SVWorkingSet*fWgSetsvm working set . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodSVM(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodSVM(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); constructor from weight file. ~MethodSVM(); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); SVM can handle classification with 2 classes and regression with one regression-target. void Init(); default initialisation. void DeclareOptions(); declare options available for this method. void DeclareCompatibilityOptions(); options that are used ONLY for the READER to ensure backward compatibility. void ProcessOptions(); option post processing (if necessary). void Train(); Train SVM. void AddWeightsXMLTo(void* parent) const; write configuration to xml file. void ReadWeightsFromXML(void* wghtnode). void WriteWeightsToStream(TFile& fout) const; TODO write IT; write training sample (TTree) to file. void ReadWeightsFromStream(istream& istr). void ReadWeightsFromStream(TFile& fFin); TODO write IT. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". const Ranking* CreateRanking(); ranking of input variable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodSVM.html:17456,avail,available,17456,root/html534/TMVA__MethodSVM.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodSVM.html,2,['avail'],['available']
Availability,"_tfSigcntNumber of pending signals; TSeqCollection*fSignalHandlerList of signal handlers; TFdSet*fSignals!Signals that were trapped; TStringfSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*fStdExceptionHandlerList of std::exception handlers; TSeqCollection*fTimersList of timers; TStringTNamed::fTitleobject title; TStringfWdpathWorking directory; TFdSet*fWritemask!Files that should be checked for write events; TFdSet*fWriteready!Files with writes waiting. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSystem(const char* name = ""Generic"", const char* title = ""Generic System""); Create a new OS interface. ~TSystem(); Delete the OS interface. Bool_t Init(); Initialize the OS interface. void SetProgname(const char* name); Set the application name (from command line, argv[0]) and copy it in; gProgName. void SetDisplay(); Set DISPLAY environment variable based on utmp entry. Only for UNIX. void SetErrorStr(const char* errstr); Set the system error string. This string will be used by GetError().; To be used in case one does not want or can use the system error; string (e.g. because error is generated by a third party POSIX like; library that does not use standard errno). const char * GetError(); Return system error string. Int_t GetErrno(); Static function returning system error number. void ResetErrno(); Static function resetting system error number. void RemoveOnExit(TObject* obj); Objects that should be deleted on exit of the OS interface. const char * HostName(); Return the system's host name. void NotifyApplicationCreated(); Hook to tell TSystem that the TApplication object has been created. void Beep(Int_t freq = -1, Int_t duration = -1, Bool_t setDefault = kFALSE); Beep for duration milliseconds with a tone of freqency freq.; Defaults to printing the '\a' character to stdout.; If freq or duration is <0 respectively, use default value.; If setDefault is set, only set the frequency and duration as; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:17854,error,error,17854,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,8,['error'],['error']
Availability,"_tfStatestate of scrollbar element (button up or down); UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGScrollBarElement(const TGWindow* p = 0, const TGPicture* pic = 0, UInt_t w = 1, UInt_t h = 1, UInt_t options = kRaisedFrame|kDoubleBorder, Pixel_t back = GetDefaultFrameBackground()); Constructor. ~TGScrollBarElement(); destructor. void SetState(Int_t state); Change state of scrollbar element (either up or down). void SetEnabled(Bool_t on = kTRUE); Enable/Disable scroll bar button chaging the state. void DrawBorder(); Draw border around scollbar element. TGScrollBarElement(const TGScrollBarElement& ). TGScrollBarElement& operator=(const TGScrollBarElement& ). Bool_t IsEnabled() const; { return !(fState & kButtonDisabled); }. » Author: Fons Rademakers 10/01/98 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGScrollBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGScrollBarElement.html:18062,down,down,18062,root/html528/TGScrollBarElement.html,https://root.cern,https://root.cern/root/html528/TGScrollBarElement.html,1,['down'],['down']
Availability,"_tmp = ROOT.RooRealSumPdf(""sp_ph"", ""sp_ph"", [p_ph_sig1, p_ph_bkg1], [Asig1, Abkg1], True); ; # Construct the subsidiary poisson measurements constraining the histogram parameters; # These ensure that the bin contents of the histograms are only allowed to vary within; # the statistical uncertainty of the Monte Carlo.; hc_sig = ROOT.RooHistConstraint(""hc_sig"", ""hc_sig"", p_ph_sig1); hc_bkg = ROOT.RooHistConstraint(""hc_bkg"", ""hc_bkg"", p_ph_bkg1); ; # Construct the joint model with template PDFs and constraints; model1 = ROOT.RooProdPdf(""model1"", ""model1"", {hc_sig, hc_bkg}, Conditional=(model_tmp, x)); ; ; # Case 2 - 'Barlow Beeston' light (one parameter per bin for all samples); ; # Construct the histogram shapes, using the same parameters for signal and background; # This requires passing the first histogram to the second, so that their common parameters; # can be re-used.; # The first ParamHistFunc will create one parameter per bin, such as `p_ph_sig2_gamma_bin_0`.; # This allows bin 0 to fluctuate up and down.; # Then, the SAME parameters are connected to the background histogram, so the bins fluctuate; # synchronously. This reduces the number of parameters.; p_ph_sig2 = ROOT.RooParamHistFunc(""p_ph_sig2"", ""p_ph_sig2"", dh_sig, x); p_ph_bkg2 = ROOT.RooParamHistFunc(""p_ph_bkg2"", ""p_ph_bkg2"", dh_bkg, x, p_ph_sig2, True); ; Asig2 = ROOT.RooRealVar(""Asig"", ""Asig"", 1, 0.01, 5000); Abkg2 = ROOT.RooRealVar(""Abkg"", ""Abkg"", 1, 0.01, 5000); ; # As before, construct the sum of signal2 and background2; model2_tmp = ROOT.RooRealSumPdf(""sp_ph"", ""sp_ph"", [p_ph_sig2, p_ph_bkg2], [Asig2, Abkg2], True); ; # Construct the subsidiary poisson measurements constraining the statistical fluctuations; hc_sigbkg = ROOT.RooHistConstraint(""hc_sigbkg"", ""hc_sigbkg"", {p_ph_sig2, p_ph_bkg2}); ; # Construct the joint model; model2 = ROOT.RooProdPdf(""model2"", ""model2"", hc_sigbkg, Conditional=(model2_tmp, x)); ; ; # ************ Fit all models to data and plot *********************; ; result0 = model0.fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:3194,down,down,3194,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,1,['down'],['down']
Availability,"_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins . ). inlineoverrideprivatevirtual . Redefine x and y axis parameters with variable bin sizes. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1 ; Reimplemented from TH1.; Definition at line 70 of file TProfile.h. ◆ SetBins() [5/7]. void TProfile::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins, . Int_t ; nz, . const Double_t * ; zBins . ). inlineoverrideprivatevirtual . Redefine x, y and z axis parameters with variable bin sizes. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented from TH1.; Definition at line 74 of file TProfile.h. ◆ SetBins() [6/7]. void TProfile::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax . ). inlineoverrideprivatevirtual . Redefine x and y axis parameters. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented from TH1.; Definition at line 68 of file TProfile.h. ◆ SetBins() [7/7]. void TProfile::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax, . Int_t ; nz, . Double_t ; zmin, . Double_t ; zmax . ). inlineoverrideprivatevirtual . Redefine x, y and z axis parameters. ; The X, Y and Z axis paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:86068,error,errors,86068,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,2,['error'],['errors']
Availability,"_t GetVisLevel () const;  ; Int_t GetVisOption () const;  ; TClass * IsA () const override;  ; void NodeVisChanged (TGeoNode *node);  Callback for propagating node visibility changes. ;  ; void Paint (Option_t *option="""") override;  Paint the enclosed TGeo hierarchy with visibility level and option given in data-members. ;  ; void SetMaxVisNodes (Int_t mvn);  ; void SetVisLevel (Int_t vl);  ; void SetVisOption (Int_t vo);  ; Bool_t SingleRnrState () const override;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UseNodeTrans ();  Use transformation matrix from the TGeoNode. ;  ; void VolumeColChanged (TGeoVolume *volume);  Callback for propagating volume parameter changes. ;  ; void VolumeVisChanged (TGeoVolume *volume);  Callback for propagating volume visibility changes. ;  ;  Public Member Functions inherited from TEveGeoNode;  TEveGeoNode (TGeoNode *node);  Constructor. ;  ; Bool_t CanEditMainColor () const override;  Can edit main-color – not available for assemblies. ;  ; Bool_t CanEditMainTransparency () const override;  Can edit main transparency – not available for assemblies. ;  ; void ExpandIntoListTree (TGListTree *ltree, TGListTreeItem *parent) override;  Checks if child-nodes have been imported ... imports them if not. ;  ; virtual void ExpandIntoListTrees ();  Expand children into all list-trees. ;  ; virtual void ExpandIntoListTreesRecursively ();  Expand children into all list-trees recursively. ;  ; const char * GetElementName () const override;  Return name, taken from geo-node. Used via TEveElement. ;  ; const char * GetElementTitle () const override;  Return title, taken from geo-node. Used via TEveElement. ;  ; Char_t GetMainTransparency () const override;  Get transparency – it is taken from the geo node. ;  ; const char * GetName () const override;  Return name, taken from geo-node. Used via TObject. ;  ; TGeoNode * GetNode () const;  ; TObject * GetObject (const TEveException &) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveGeoTopNode.html:2260,avail,available,2260,doc/master/classTEveGeoTopNode.html,https://root.cern,https://root.cern/doc/master/classTEveGeoTopNode.html,1,['avail'],['available']
Availability,"_t HandleKey (Event_t *event) override;  The key press event handler converts a key press to some line editor action. ;  ; virtual void Home (Bool_t select=kFALSE);  Move to upper-left corner of container. ;  ; virtual void InvertSelection ();  Invert the selection, all selected items become unselected and vice versa. ;  ; virtual void KeyPressed (TGFrame *, UInt_t keysym, UInt_t mask);  Signal emitted when keyboard key pressed. ;  ; virtual void LineDown (Bool_t select=kFALSE);  Move one line down. ;  ; virtual void LineLeft (Bool_t select=kFALSE);  Move current position one column left. ;  ; virtual void LineRight (Bool_t select=kFALSE);  Move current position one column right. ;  ; virtual void LineUp (Bool_t select=kFALSE);  Make current position first line in window by scrolling up. ;  ; virtual Int_t NumItems () const;  ; virtual Int_t NumSelected () const;  ; virtual void OnMouseOver (TGFrame *);  Signal emitted when pointer is over entry. ;  ; virtual void PageDown (Bool_t select=kFALSE);  Move position one page down. ;  ; virtual void PageUp (Bool_t select=kFALSE);  Move position one page up. ;  ; virtual void RemoveItem (TGFrame *item);  Remove item from container. ;  ; virtual void ReturnPressed (TGFrame *);  Signal emitted when Return/Enter key pressed. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a canvas container as a C++ statement(s) on output stream out. ;  ; virtual void Search (Bool_t close=kTRUE);  Invokes search dialog. Looks for item with the entered name. ;  ; virtual void SelectAll ();  Select all items in the container. ;  ; virtual void SetDragPixmap (const TGPicture *pic);  Set drag window pixmaps and hotpoint. ;  ; virtual void SetHsbPosition (Int_t newPos);  set new hor. position ;  ; virtual void SetPageDimension (const TGDimension &dim);  Set page dimension. ;  ; virtual void SetPageDimension (UInt_t w, UInt_t h);  Set page dimension. ;  ; virtual void SetPagePosition (const TGPosition &pos);  Set pag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLBContainer.html:6656,down,down,6656,doc/master/classTGLBContainer.html,https://root.cern,https://root.cern/doc/master/classTGLBContainer.html,1,['down'],['down']
Availability,"_t IsArchive () const;  ; Bool_t IsBinary () const;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:7820,recover,recover,7820,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['recover'],['recover']
Availability,"_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:48495,error,error,48495,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability,"_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:47180,error,error,47180,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,"_t fCurrentColor;  currently selected color value ;  ; TGGC fCursorGC;  color lightness slider cursor GC ;  ; Int_t fCx;  x position in hs colormap ;  ; Int_t fCy;  y position in hs colormap ;  ; Int_t fCz;  position in lightness slider ;  ; Pixmap_t fHSimage;  hue / saturation colormap pixmap ;  ; Pixmap_t fLimage;  color lightness slider pixmap ;  ; Int_t fNColors;  number of color samples ;  ; Rectangle_t fSliderRect;  color lightness slider rectangle ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Protected Attributes inherited from TGWidget; TString fCommand;  command to be executed ;  ; const TGWindow * fMsgWindow;  window which handles widget events ;  ; Int_t fWidgetFlags;  widget status flags (OR of EWidgetStatus) ;  ; Int_t fWidgetId;  the widget id (used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGColorPick.html:25777,mask,mask,25777,doc/master/classTGColorPick.html,https://root.cern,https://root.cern/doc/master/classTGColorPick.html,1,['mask'],['mask']
Availability,"_t fDepth;  depth of window ;  ; UInt_t fHeight;  height of picture ;  ; Mask_t fMask;  mask specifying which attributes are defined ;  ; UInt_t fNpixels;  number of used color pixels ;  ; ULong_t * fPixels;  list of used color pixels (if set use delete[]) ;  ; UInt_t fWidth;  width of picture ;  ; UInt_t fXHotspot;  picture x hotspot coordinate ;  ; UInt_t fYHotspot;  picture y hotspot coordinate ;  . #include <GuiTypes.h>; Member Data Documentation. ◆ fCloseness. UInt_t PictureAttributes_t::fCloseness. allowable RGB deviation ; Definition at line 332 of file GuiTypes.h. ◆ fColormap. Colormap_t PictureAttributes_t::fColormap. colormap to use ; Definition at line 324 of file GuiTypes.h. ◆ fDepth. Int_t PictureAttributes_t::fDepth. depth of window ; Definition at line 325 of file GuiTypes.h. ◆ fHeight. UInt_t PictureAttributes_t::fHeight. height of picture ; Definition at line 327 of file GuiTypes.h. ◆ fMask. Mask_t PictureAttributes_t::fMask. mask specifying which attributes are defined ; Definition at line 333 of file GuiTypes.h. ◆ fNpixels. UInt_t PictureAttributes_t::fNpixels. number of used color pixels ; Definition at line 331 of file GuiTypes.h. ◆ fPixels. ULong_t* PictureAttributes_t::fPixels. list of used color pixels (if set use delete[]) ; Definition at line 330 of file GuiTypes.h. ◆ fWidth. UInt_t PictureAttributes_t::fWidth. width of picture ; Definition at line 326 of file GuiTypes.h. ◆ fXHotspot. UInt_t PictureAttributes_t::fXHotspot. picture x hotspot coordinate ; Definition at line 328 of file GuiTypes.h. ◆ fYHotspot. UInt_t PictureAttributes_t::fYHotspot. picture y hotspot coordinate ; Definition at line 329 of file GuiTypes.h. Collaboration diagram for PictureAttributes_t:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; The documentation for this struct was generated from the following file:; core/gui/inc/GuiTypes.h. PictureAttributes_t. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structPictureAttributes__t.html:1348,mask,mask,1348,doc/master/structPictureAttributes__t.html,https://root.cern,https://root.cern/doc/master/structPictureAttributes__t.html,1,['mask'],['mask']
Availability,"a & GetFitData () const;  Get reference to Fit Data object (NOTE: it will be invalid when class is deleted) ;  ; const ROOT::Fit::FitResult & GetFitResult () const;  Get reference to Fit Result object (NOTE: it will be invalid when class is deleted) ;  ; ROOT::Math::Minimizer * GetMinimizer () const;  Return a pointer to the minimizer. ;  ; Int_t GetNumberFreeParameters () const override;  ; Int_t GetNumberTotalParameters () const override;  Number of total parameters. ;  ; ROOT::Math::IMultiGenFunction * GetObjFunction () const;  Return a pointer to the objective function (FCN) If fitting directly using TBackCompFitter the pointer is managed by the class, which has been set previously when calling SetObjFunction or SetFCN Otherwise if the class is used in the backward compatible mode (e.g. ;  ; Double_t GetParameter (Int_t ipar) const override;  Parameter value. ;  ; Int_t GetParameter (Int_t ipar, char *name, Double_t &value, Double_t &verr, Double_t &vlow, Double_t &vhigh) const override;  Get all parameter info (name, value, errors) ;  ; Double_t GetParError (Int_t ipar) const override;  Parameter error. ;  ; const char * GetParName (Int_t ipar) const override;  Return name of parameter ipar. ;  ; Int_t GetStats (Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const override;  Get fit statistical information. ;  ; Double_t GetSumLog (Int_t i) override;  Sum of log (un-needed) ;  ; TFitResult * GetTFitResult () const;  Get a copy of the Fit result returning directly a new TFitResult. ;  ; TClass * IsA () const override;  ; Bool_t IsFixed (Int_t ipar) const override;  Query if parameter ipar is fixed. ;  ; void PrintResults (Int_t level, Double_t amin) const override;  Print the fit result. ;  ; void ReCreateMinimizer ();  Recreate a minimizer instance using the function and data set objective function in minimizers function to re-create FCN from stored data object and fit options. ;  ; void ReleaseParameter (Int_t ipar) override;  Rel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBackCompFitter.html:6203,error,errors,6203,doc/master/classTBackCompFitter.html,https://root.cern,https://root.cern/doc/master/classTBackCompFitter.html,2,['error'],"['error', 'errors']"
Availability,"a (Int_t n, TPoint *xy) override;  Fills area described by the polygon. ;  ; void DrawLine (Drawable_t id, GContext_t gc, Int_t x1, Int_t y1, Int_t x2, Int_t y2) override;  Uses the components of the specified GC to draw a line between the specified set of points (x1, y1) and (x2, y2). ;  ; void DrawLine (Int_t x1, Int_t y1, Int_t x2, Int_t y2) override;  Draws a line. ;  ; void DrawPolyLine (Int_t n, TPoint *xy) override;  Draws a line through all points in the list. ;  ; void DrawPolyMarker (Int_t n, TPoint *xy) override;  Draws ""n"" markers with the current attributes at position [x,y]. ;  ; void DrawRectangle (Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ;  ; void DrawSegments (Drawable_t id, GContext_t gc, Segment_t *seg, Int_t nseg) override;  Draws multiple line segments. ;  ; void DrawString (Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char *s, Int_t len) override;  Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ;  ; void DrawText (Int_t x, Int_t y, Float_t angle, Float_t mgn, const char *text, ETextMode mode) override;  Draws a text string using current font. ;  ; void DrawText (Int_t, Int_t, Float_t, Float_t, const wchar_t *, ETextMode) override;  Draws a text string using current font. ;  ; Bool_t EmptyRegion (Region_t reg) override;  Returns kTRUE if the region reg is empty. ;  ; Bool_t EqualRegion (Region_t rega, Region_t regb) override;  Returns kTRUE if the two regions have the same offset, size, and shape. ;  ; Int_t EventsPending () override;  Return number of pending events. ;  ; void FillPolygon (Window_t id, GContext_t gc, Point_t *points, Int_t npnt) override;  Fills the region closed by the specified path. ;  ; void FillRectangle (Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h) override;  Fills the specified rectangle defined by [x,y] [x+w,y] [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:8109,mask,mask,8109,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,1,['mask'],['mask']
Availability,"a 2D Profile histogram. In case of a 3-Dim expression, one can generate a TProfile2D histogram; instead of a TH3F histogram by specifying option=prof or option=profs.; The option=prof is automatically selected in case of z:y:x>>pf; where pf is an existing TProfile2D histogram. Making a 5-D plot with GL. When the option ""gl5d"" is specified and the dimension of the query is 5; a 5-d plot is created using GL, eg; T->Draw(""x:y:z:u:w"","""",""gl5d""). Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Normalizing the ouput histogram to 1. When option contains ""norm"" the output histogram is normalized to 1. Saving the result of Draw to a TEventList or a TEntryList. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTree::Draw); yplus.Print(""all""); to print the list of entry numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To contin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:33760,error,error,33760,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['error'],['error']
Availability,"a 2D plot (not so much in a 3D surfaces).; 363 ; 364The `kCMYK` palette, is also not great because it's dark, then lighter, then; 365half-dark again. Some others, like `kAquamarine`, have almost no contrast therefore it would; 366be almost impossible (for a color blind person) to see something with a such palette.; 367 ; 368Therefore the palettes are classified in two categories: those which are Colour Vision Deficiency; 369friendly and those which are not.; 370 ; 371An easy way to classify the palettes is to turn them into grayscale using TCanvas::SetGrayscale().; 372The grayscale version of a palette should be as proportional as possible, and monotonously; 373increasing or decreasing.; 374 ; 375Unless it is symmetrical, then it is fine to have white in the; 376borders and black in the centre (for example an axis that goes between; 377-40 degrees and +40 degrees, the 0 has a meaning in the perceptualcolormap.C example).; 378 ; 379A full set of colour-vision deficiency friendly and perceptually uniform colour maps can be; 380[downloaded](https://doi.org/10.5281/zenodo.4491293) and used with ROOT (since 6.26) via:; 381`gStyle->SetPalette(""filename.txt"")` or `TColor::CreateColorTableFromFile(""filename.txt"")`.; 382Remember to increase the number of contours for a smoother result, e.g.:; 383`gStyle->SetNumberContours(99)` if you are drawing with ""surf1z"" or `gStyle->SetNumberContours(256)`; 384if with ""colz"".; 385 ; 386\anchor C06a; 387### Colour Vision Deficiency (CVD) friendly palettes; 388 ; 389<table border=0>; 390<tr><td>; 391Begin_Macro; 392{; 393 auto c = new TCanvas(""c"",""c"",0,0,300,300);; 394 auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.002,0.999,3.002);; 395 f2->SetContour(99); gStyle->SetPalette(kBird);; 396 f2->Draw(""surf2Z""); f2->SetTitle(""kBird (default)"");; 397}; 398End_Macro; 399</td><td>; 400Begin_Macro; 401{; 402 auto c = new TCanvas(""c"",""c"",0,0,300,300);; 403 auto f2 = new TF2(""f2"",""0.1+(1-(x-2)*(x-2))*(1-(y-2)*(y-2))"",0.999,3.0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:14810,down,downloaded,14810,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['down'],['downloaded']
Availability,"a C++ macro (static method). Can be used; while TApplication is not yet created. void Run(Bool_t retrn = kFALSE); Main application eventloop. Calls system dependent eventloop via gSystem. void SetIdleTimer(UInt_t idleTimeInSec, const char* command); Set the command to be executed after the system has been idle for; idleTimeInSec seconds. Normally called via TROOT::Idle(...). void RemoveIdleTimer(); Remove idle timer. Normally called via TROOT::Idle(0). void StartIdleing(); Called when system starts idleing. void StopIdleing(); Called when system stops idleing. void Terminate(Int_t status = 0); Terminate the application by call TSystem::Exit() unless application has; been told to return from Run(), by a call to SetReturnFromRun(). void LineProcessed(const char* line); Emit signal when a line has been processed. void KeyPressed(Int_t key); Emit signal when console keyboard key was pressed. void ReturnPressed(char* text); Emit signal when return key was pressed. void SetEchoMode(Bool_t mode); Set console echo mode:. mode = kTRUE - echo input symbols; mode = kFALSE - noecho input symbols. void CreateApplication(); Static function used to create a default application environment. TApplication * Open(const char* url, Int_t debug, const char* script); Static function used to attach to an existing remote application; or to start one. void Close(TApplication* app); Static function used to close a remote application. void ls(Option_t* option = """") const; Show available sessions. TList * GetApplications(); Static method returning the list of available applications. TApplication(const TApplication& ). TApplication& operator=(const TApplication& ). void SetSignalHandler(TSignalHandler* sh); { fSigHandler = sh; }. TApplication * Open(const char* url, Int_t debug, const char* script). TSignalHandler * GetSignalHandler() const; { return fSigHandler; }. Bool_t HandleTermInput(); { return kFALSE; }. void Init(); { fAppImp->Init(); }. const char * GetIdleCommand() const; { return fIdle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplication.html:18074,echo,echo,18074,root/html526/TApplication.html,https://root.cern,https://root.cern/root/html526/TApplication.html,2,['echo'],['echo']
Availability,"a Profile histogram (no weights). ;  ; virtual Int_t Fill (const char *namex, Double_t y, Double_t w);  Fill a Profile histogram with weights. ;  ; Int_t Fill (Double_t x, Double_t y) override;  Fill a Profile histogram (no weights). ;  ; virtual Int_t Fill (Double_t x, Double_t y, Double_t w);  Fill a Profile histogram with weights. ;  ; void FillN (Int_t ntimes, const Double_t *x, const Double_t *y, const Double_t *w, Int_t stride=1) override;  Fill a Profile histogram with weights. ;  ; Double_t GetBinContent (Int_t bin) const override;  Return bin content of a Profile histogram. ;  ; Double_t GetBinContent (Int_t bin, Int_t) const override;  ; Double_t GetBinContent (Int_t bin, Int_t, Int_t) const override;  ; virtual Double_t GetBinEffectiveEntries (Int_t bin) const;  Return bin effective entries for a weighted filled Profile histogram. ;  ; virtual Double_t GetBinEntries (Int_t bin) const;  Return bin entries of a Profile histogram. ;  ; Double_t GetBinError (Int_t bin) const override;  Return bin error of a Profile histogram. ;  ; Double_t GetBinError (Int_t bin, Int_t) const override;  ; Double_t GetBinError (Int_t bin, Int_t, Int_t) const override;  ; virtual TArrayD * GetBinSumw2 ();  ; virtual const TArrayD * GetBinSumw2 () const;  ; Option_t * GetErrorOption () const;  Return option to compute profile errors. ;  ; void GetStats (Double_t *stats) const override;  fill the array stats from the contents of this profile. ;  ; virtual Double_t GetYmax () const;  ; virtual Double_t GetYmin () const;  ; TClass * IsA () const override;  ; void LabelsDeflate (Option_t *axis=""X"") override;  Reduce the number of bins for this axis to the number of bins having a label. ;  ; void LabelsInflate (Option_t *axis=""X"") override;  Double the number of bins for axis. ;  ; void LabelsOption (Option_t *option=""h"", Option_t *axis=""X"") override;  Set option(s) to draw axis with labels. ;  ; Long64_t Merge (TCollection *list) override;  Merge all histograms in the collection in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile.html:6885,error,error,6885,doc/master/classTProfile.html,https://root.cern,https://root.cern/doc/master/classTProfile.html,1,['error'],['error']
Availability,"a Profile histogram to a new profile histogram.Definition TProfile.cxx:423; TProfile::GetYminvirtual Double_t GetYmin() constDefinition TProfile.h:115; TProfile::SetBinsvoid SetBins(Int_t, Double_t, Double_t, Int_t, Double_t, Double_t) overrideRedefine x and y axis parameters.Definition TProfile.h:68; TProfile::SetBinsvoid SetBins(Int_t, const Double_t *, Int_t, const Double_t *) overrideRedefine x and y axis parameters with variable bin sizes.Definition TProfile.h:70; TProfile::GetBinSumw2virtual const TArrayD * GetBinSumw2() constDefinition TProfile.h:112; TProfile::fYmaxDouble_t fYmaxUpper limit in Y (if set)Definition TProfile.h:42; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::ProjectionXTH1D * ProjectionX(const char *name=""_px"", Option_t *option=""e"") constProject this profile into a 1-D histogram along X.Definition TProfile.cxx:1283; TProfile::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile errors.Definition TProfile.cxx:1777; TProfile::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile.cxx:1612; TProfile::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile histogram.Definition TProfile.cxx:837; TProfile::LabelsDeflatevoid LabelsDeflate(Option_t *axis=""X"") overrideReduce the number of bins for this axis to the number of bins having a label.Definition TProfile.cxx:973; TProfile::GetB2Double_t * GetB2()Definition TProfile.h:65; TProfile::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile.cxx:1729; TProfile::Scalevoid Scale(Double_t c1=1, Option_t *option="""") overrideMultiply this profile by a constant c1.Definition TProfile.cxx:1692; TProfile::TProfileTProfile()Default constructor for Profile histograms.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8h_source.html:12917,error,errors,12917,doc/master/TProfile_8h_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8h_source.html,1,['error'],['errors']
Availability,"a Profile2D histogram*-*-; *-* ===========================================. Double_t GetBinEntries(Int_t bin) const; Return bin entries of a Profile2D histogram*-*-; *-* ===========================================. Double_t GetBinEffectiveEntries(Int_t bin); Return bin effective entries for a weighted filled Profile histogram.; In case of an unweighted profile, it is equivalent to the number of entries per bin; The effective entries is defined as the square of the sum of the weights divided by the; sum of the weights square.; TProfile::Sumw2() must be called before filling the profile with weights.; Only by calling this method the sum of the square of the weights per bin is stored. *-* =========================================. Double_t GetBinError(Int_t bin) const; *-*-*-*-*-*-*Return bin error of a Profile2D histogram*-*-*-*-*-*-*-*-*. Computing errors: A moving field. The computation of errors for a TProfile2D has evolved with the versions; of ROOT. The difficulty is in computing errors for bins with low statistics.; - prior to version 3.10, we had no special treatment of low statistic bins.; As a result, these bins had huge errors. The reason is that the; expression eprim2 is very close to 0 (rounding problems) or 0.; - The algorithm is modified/protected for the case; when a TProfile2D is projected (ProjectionX). The previous algorithm; generated a N^2 problem when projecting a TProfile2D with a large number of; bins (eg 100000).; - in version 3.10/02, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation.; (see also comments in TProfile::GetBinError). Option_t * GetErrorOption() const; -*-*Return option to compute profile2D errors; *-* =========================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:36506,error,errors,36506,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,10,['error'],['errors']
Availability,"a Profile3D histogram*-*-; *-* ===========================================. Double_t GetBinEntries(Int_t bin) const; Return bin entries of a Profile3D histogram*-*-; *-* ===========================================. Double_t GetBinEffectiveEntries(Int_t bin); Return bin effective entries for a weighted filled Profile histogram.; In case of an unweighted profile, it is equivalent to the number of entries per bin; The effective entries is defined as the square of the sum of the weights divided by the; sum of the weights square.; TProfile::Sumw2() must be called before filling the profile with weights.; Only by calling this method the sum of the square of the weights per bin is stored. *-* =========================================. Double_t GetBinError(Int_t bin) const; *-*-*-*-*-*-*Return bin error of a Profile3D histogram*-*-*-*-*-*-*-*-*. Computing errors: A moving field. The computation of errors for a TProfile3D has evolved with the versions; of ROOT. The difficulty is in computing errors for bins with low statistics.; - prior to version 3.10, we had no special treatment of low statistic bins.; As a result, these bins had huge errors. The reason is that the; expression eprim2 is very close to 0 (rounding problems) or 0.; - The algorithm is modified/protected for the case; when a TProfile3D is projected (ProjectionX). The previous algorithm; generated a N^2 problem when projecting a TProfile3D with a large number of; bins (eg 100000).; - in version 3.10/02, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation.; (see also comments in TProfile::GetBinError). Option_t * GetErrorOption() const; -*-*Return option to compute profile2D errors; *-* =========================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile3D.html:35548,error,errors,35548,root/html528/TProfile3D.html,https://root.cern,https://root.cern/root/html528/TProfile3D.html,10,['error'],['errors']
Availability,"a ROOT session. One simply adds the name of the script(s) after the ROOT command. Be warned: after finishing the execution of the script, ROOT will normally enter a new session.; -q process command line script files and exit. For example if you would like to run a script myMacro.C in the background, redirect the output into a file myMacro.log, and exit after the script execution, use the following syntax:; root -b -q myMacro.C > myMacro.log; If you need to pass a parameter to the script use:; root -b -q 'myMacro.C(3)' > myMacro.log; Be mindful of the quotes, i.e. if you need to pass a string as a parameter, the syntax is:; root -b -q 'myMacro.C(""text"")' > myMacro.log; You can build a shared library with ACLiC and then use this shared library on the command line for a quicker execution (i.e. the compiled speed rather than the interpreted speed). See also “Cling the C++ Interpreter”.; root -b -q myMacro.so > myMacro.log; ROOT has a powerful C/C++ interpreter giving you access to all available ROOT classes, global variables, and functions via the command line. By typing C++ statements at the prompt, you can create objects, call functions, execute scripts, etc. For example:; root[] 1+sqrt(9); (const double)4.00000000000000000e+00; root[] for (int i = 0; i<4; i++) cout << ""Hello"" << i << endl; Hello 0; Hello 1; Hello 2; Hello 3; root[] .q; To exit the ROOT session, type .q.; root[] .q; 2.3 Using the GUI; The basic whiteboard on which an object is drawn in ROOT is called a canvas (defined by the class TCanvas). Every object in the canvas is a graphical object in the sense that you can grab it, resize it, and change some characteristics using the mouse. The canvas area can be divided in several sub areas, so-called pads (the class TPad). A pad is a canvas sub area that can contain other pads or graphical objects. At any one time, just one pad is the so-called active pad. Any object at the moment of drawing will be drawn in the active pad. The obvious question is: what is th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:34658,avail,available,34658,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"a RooAbsReal and a RooArgSet as arguments. ; Definition at line 280 of file RooFactoryWSTool.cxx. ◆ createCategory(). RooCategory * RooFactoryWSTool::createCategory ; (; const char * ; name, . const char * ; stateNameList = nullptr . ). Low-level factory interface for creating a RooCategory with a given list of state names. ; The State name list can be of the form name1,name2,name3 or of the form name1=id1,name2=id2,name3=id3 ; Definition at line 150 of file RooFactoryWSTool.cxx. ◆ createVariable(). RooRealVar * RooFactoryWSTool::createVariable ; (; const char * ; name, . double ; xmin, . double ; xmax . ). Low-level factory interface for creating a RooRealVar with a given range and initial value. ; Definition at line 126 of file RooFactoryWSTool.cxx. ◆ DeclFileName(). static const char * RooFactoryWSTool::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 199 of file RooFactoryWSTool.h. ◆ errorCount(). Int_t RooFactoryWSTool::errorCount ; (; ). inlineprotected . Definition at line 193 of file RooFactoryWSTool.h. ◆ hooks(). std::map< std::string, RooFactoryWSTool::IFace * > & RooFactoryWSTool::hooks ; (; ). staticprotected . Definition at line 1900 of file RooFactoryWSTool.cxx. ◆ IsA(). TClass * RooFactoryWSTool::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 199 of file RooFactoryWSTool.h. ◆ logError(). void RooFactoryWSTool::logError ; (; ). inline . Definition at line 153 of file RooFactoryWSTool.h. ◆ of(). RooFactoryWSTool * RooFactoryWSTool::of ; (; ). staticprotected . Definition at line 2195 of file RooFactoryWSTool.cxx. ◆ process(). RooAbsArg * RooFactoryWSTool::process ; (; const char * ; expr). Create a RooFit object from the given expression. . Creating variables . x[-10,10] Create variable x with given range and put it in workspace . x[3,-10,10] Create variable x with given range and initial value and put it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:31814,error,errorCount,31814,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['error'],['errorCount']
Availability,"a Root file ;  double32.C Tutorial illustrating use and precision of the Double32_t data type You must run this tutorial with ACLIC: a dictionary will be automatically created ;  fildir.C This macro displays the ROOT Directory data structure ;  file.C This macro displays the physical ROOT file structure ;  hadd.C Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ;  importCode.C Example of script showing how to create a ROOT file with subdirectories ;  loopdir.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  mergeSelective.C Merge only part of the content of a set of files ;  readCode.C Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory ;  testMergeCont.C Macro demonstrating the merging of containers ;  ► math;  Bessel.C Show the different kinds of Bessel functions available in ROOT To execute the macro type in: ;  binomial.C tutorial illustrating the use of TMath::Binomial can be run with: ;  ChebyshevPol.C Example of Chebyshev polynomials using new TFormula pre-defined definitions of chebyshev polynomials ;  chi2test.C Example to use chi2 test for comparing two histograms One unweighted histogram is compared with a weighted histogram ;  CrystalBall.C Example of CrystalBall Function and its distribution (pdf and cdf) ;  exampleFunctor.C Tutorial illustrating how creating a TF1 class using functor or class member functions ;  exampleMultiRoot.C Example of using multiroot finder based on GSL algorithm ;  exampleTKDE.C Example of using the TKDE class (kernel density estimator) ;  FeldmanCousins.C Example macro of using the TFeldmanCousins class in root ;  GammaFun.C Example showing the usage of the major special math functions (gamma, beta, erf) in ROOT To execute the macro type in: ;  goftest.C GoFTest tutorial macro ;  kdTreeBinning.C kdTreeBinning tuto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:127112,avail,available,127112,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,2,['avail'],['available']
Availability,"a backend. (see https://sft.its.cern.ch/jira/browse/ROOT-6561); Interactive update of TText position did not work in NDC mode. (se https://sft.its.cern.ch/jira/browse/ROOT-7284). TLegend. Use the new TStyle global attribute gStyle->GetLegendTextSize() to set the legend item text size. If this value is 0 and if the text size directly set on the TLegend object is also 0, then the text size is automatically computed to fit the legend box. If gStyle->GetLegendTextSize() is non equal to 0 and if text size directly set on the TLegend object is 0, then the gStyle value is used to draw the legend text. If the text size directly set on the TLegend object is not null, then it is used to draw the legend text. TTexDump. The hollow fill style was not rendered correctly. (see https://sft.its.cern.ch/jira/browse/ROOT-6841); Better line width matching with screen and pdf output.; Text color was ignored. It was always black.; Text color was ignored. It was always black.; The underscore _ produced an error outside the TeX math context.; Fix an issue with transparent pads.; Implement transparent colors using TiKZ “opacity”.; Implement TStyle::SetLineScalePS() to control le global basic line width.; Offer 0 as line width option. Useful to make a line invisible. TPostScript. Small fix for fill patterns 1, 2 and 3.; With TMathtext, only the fonts really used are now loaded in the PostScript file. Typically it reduces the file size by a factor 10 (compare to the previous implementation) for normal plots with math formulae and greek characters.; Offer 0 as line width option. Useful to make a line invisible. TPDF. When a text size was equal or smaller than 0 the PDF file was corrupted.; Small fix for fill patterns 1, 2 and 3.; When printing a coloured 2D histograms (with option COLZ) into a PDF or PostScript file, the preview on screen using many standard PDF previewer tools showed very thin white lines between the bins as well as in the color palette. This made very ugly the final output. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:21734,error,error,21734,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['error'],['error']
Availability,"a bar-chart in a normal pad.; . void PaintBarH(Option_t* option). Draw a bar char in a rotated pad (X vertical, Y horizontal).; . void PaintBoxes(Option_t* option). Control function to draw a 2D histogram as a box plot.; . void PaintCandlePlot(Option_t* option). Control function to draw a 2D histogram as a candle (box) plot.; . void PaintViolinPlot(Option_t* option). Control function to draw a 2D histogram as a violin plot.; . void PaintColorLevels(Option_t* option). Control function to draw a 2D histogram as a color plot.; . void PaintContour(Option_t* option). Control function to draw a 2D histogram as a contour plot.; . Int_t PaintContourLine(Double_t elev1, Int_t icont1, Double_t x1, Double_t y1, Double_t elev2, Int_t icont2, Double_t x2, Double_t y2, Double_t* xarr, Double_t* yarr, Int_t* itarr, Double_t* levels). Fill the matrix XARR YARR for Contour Plot.; ; . void PaintErrors(Option_t* option). Draw 1D histograms error bars.; . void Paint2DErrors(Option_t* option). Draw 2D histograms errors.; ; . void PaintFrame(). Calculate range and clear pad (canvas).; ; . void PaintFunction(Option_t* option). Paint functions associated to an histogram.; . void PaintHist(Option_t* option). Control routine to draw 1D histograms.; . void PaintH3(Option_t* option = """"). Control function to draw a 3D histograms.; . Int_t PaintInit(). Compute histogram parameters used by the drawing routines.; ; . Int_t PaintInitH(). Compute histogram parameters used by the drawing routines for a rotated pad.; ; . void PaintH3Iso(). Control function to draw a 3D histogram with Iso Surfaces.; . void PaintLego(Option_t* option). Control function to draw a 2D histogram as a lego plot.; . void PaintLegoAxis(TGaxis* axis, Double_t ang). Draw the axis for legos and surface plots.; ; . void PaintPalette(). Paint the color palette on the right side of the pad.; . void PaintScatterPlot(Option_t* option). Control function to draw a 2D histogram as a scatter plot.; . void PaintSpecialObjects(const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:90801,error,errors,90801,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,6,['error'],['errors']
Availability,"a box filled with a color CI function of the cell content. if the cell content is N, the color CI used will be the color number in colors[N],etc. If the maximum cell content is > ncolors, all cell contents are scaled to ncolors.; if ncolors <= 0 a default palette (see below) of 50 colors is defined. The colors defined in this palette are OK for coloring pads, labels.; index 0->9 : grey colors from light to dark grey; index 10->19 : ""brown"" colors; index 20->29 : ""blueish"" colors; index 30->39 : ""redish"" colors; index 40->49 : basic colors; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; if ncolors == 1 && colors == 0, a Rainbow Color map is created with 50 colors. It is kept for backward compatibility. Better palettes like kBird are recommended.; High quality predefined palettes with 255 colors are available when colors == 0. The following value of ncolors give access to:; if ncolors = 51 and colors=0, a Deep Sea palette is used.; if ncolors = 52 and colors=0, a Grey Scale palette is used.; if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; if ncolors = 54 and colors=0, a Two-Color Hue palette is used.(dark blue through neutral gray to bright yellow); if ncolors = 55 and colors=0, a Rain Bow palette is used.; if ncolors = 56 and colors=0, an Inverted Dark Body Radiator palette is used.; if ncolors = 57 and colors=0, a monotonically increasing L value palette is used.; if ncolors = 58 and colors=0, a Cubehelix palette is used; (Cf. Dave Green's ""cubehelix"" colour scheme at http://www.mrao.cam.ac.uk/~dag/CUBEHELIX/); if ncolors = 59 and colors=0, a Green Red Violet palette is used.; if ncolors = 60 and colors=0, a Blue Red Yellow palette is used.; if ncolors = 61 and colors=0, an Ocean palette is used.; if ncolors = 62 and colors=0, a Color Printable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:68106,avail,available,68106,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['avail'],['available']
Availability,"a cell has N data points all with the same value T (especially; possible when dealing with integers), the spread in T for that cell; is zero, and the uncertainty assigned is also zero, and the cell is; ignored in making subsequent fits. If SQRT(T) was the correct error; in the case above, then SQRT(T)/SQRT(N) would be the correct error here.; In fact, any cell with non-zero number of entries N but with zero spread; should have an uncertainty SQRT(T)/SQRT(N). Now, is SQRT(T)/SQRT(N) really the correct uncertainty?; that it is only in the case where the T variable is some sort; of counting statistics, following a Poisson distribution. This should; probably be set as the default case. However, T can be any variable; from an original NTUPLE, not necessarily distributed ""Poissonly"".; The computation of errors is based on the parameter option:; option:; ' ' (Default) Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" SQRT(T)/SQRT(N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; 's' Errors are Spread for Spread.ne.0. ,; "" "" SQRT(T) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; 'i' Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" 1./SQRT(12.*N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0. The third case above corresponds to Integer T values for which the; uncertainty is +-0.5, with the assumption that the probability that T; takes any value between T-0.5 and T+0.5 is uniform (the same argument; goes for T uniformly distributed between T and T+1); this would be; useful if T is an ADC measurement, for example. Other, fancier options; would be possible, at the cost of adding one more parameter to the PROFILE2D; For example, if all T variables are distributed according to some; known Gaussian of standard deviation Sigma, then:; 'G' Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" Sigma/SQRT(N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; For example, this would be useful when all T's are experimental quantities; measured with the same instrument with precision Sigma. TProfile3D(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile3D.html:31530,Error,Errors,31530,root/html532/TProfile3D.html,https://root.cern,https://root.cern/root/html532/TProfile3D.html,1,['Error'],['Errors']
Availability,"a cell has N data points all with the same value Z (especially; possible when dealing with integers), the spread in Z for that cell; is zero, and the uncertainty assigned is also zero, and the cell is; ignored in making subsequent fits. If SQRT(Z) was the correct error; in the case above, then SQRT(Z)/SQRT(N) would be the correct error here.; In fact, any cell with non-zero number of entries N but with zero spread; should have an uncertainty SQRT(Z)/SQRT(N). Now, is SQRT(Z)/SQRT(N) really the correct uncertainty?; that it is only in the case where the Z variable is some sort; of counting statistics, following a Poisson distribution. This should; probably be set as the default case. However, Z can be any variable; from an original NTUPLE, not necessarily distributed ""Poissonly"".; The computation of errors is based on the parameter option:; option:; ' ' (Default) Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" SQRT(Z)/SQRT(N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; 's' Errors are Spread for Spread.ne.0. ,; "" "" SQRT(Z) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; 'i' Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" 1./SQRT(12.*N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0. The third case above corresponds to Integer Z values for which the; uncertainty is +-0.5, with the assumption that the probability that Z; takes any value between Z-0.5 and Z+0.5 is uniform (the same argument; goes for Z uniformly distributed between Z and Z+1); this would be; useful if Z is an ADC measurement, for example. Other, fancier options; would be possible, at the cost of adding one more parameter to the PROFILE2D; For example, if all Z variables are distributed according to some; known Gaussian of standard deviation Sigma, then:; 'G' Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" Sigma/SQRT(N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; For example, this would be useful when all Z's are experimental quantities; measured with the same instrument with precision Sigma. TProfile2D(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile2D.html:31983,Error,Errors,31983,root/html532/TProfile2D.html,https://root.cern,https://root.cern/root/html532/TProfile2D.html,1,['Error'],['Errors']
Availability,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TEnvRec::HashULong_t Hash() const overrideReturn hash value for this object.Definition TEnv.h:113; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 113 of file TEnv.h. ◆ IsA(). TClass * TEnvRec::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 115 of file TEnv.h. ◆ Streamer(). void TEnvRec::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEnvRec::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 115 of file TEnv.h. Friends And Related Symbol Documentation. ◆ TEnv. friend class TEnv. friend . Definition at line 88 of file TEnv.h. ◆ TEnvParser. friend class TEnvParser. friend . Definition at line 89 of file TEnv.h. ◆ TReadEnvParser. friend class TReadEnvParser. friend . Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnvRec.html:14140,error,error,14140,doc/master/classTEnvRec.html,https://root.cern,https://root.cern/doc/master/classTEnvRec.html,1,['error'],['error']
Availability,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:987; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TXNetFile, TXNetSystem, ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchemaRule::TSources, TStreamerElement, TStreamerBase, TStreamerBasicPointer, TStreamerLoop, TStreamerBasicType, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTNamed.html:19597,error,error,19597,doc/v632/classTNamed.html,https://root.cern,https://root.cern/doc/v632/classTNamed.html,1,['error'],['error']
Availability,"a derived class, this derived class should also add ROOT::CallRecursiveRemoveIfNeeded(*this); ROOT::CallRecursiveRemoveIfNeededvoid CallRecursiveRemoveIfNeeded(TObject &obj)call RecursiveRemove for obj if gROOT is valid and obj.TestBit(kMustCleanup) is true.Definition TROOT.h:395; Otherwise, when RecursiveRemove is called (by ~TObject or example) for this type of object, the transversal of THashList and THashTable containers will will have to be done without call Hash (and hence be linear rather than logarithmic complexity). You will also see warnings like Error in <ROOT::Internal::TCheckHashRecursiveRemoveConsistency::CheckRecursiveRemove>: The class SomeName overrides TObject::Hash but does not call TROOT::RecursiveRemove in its destructor.; TNamed::HashULong_t Hash() const overrideReturn hash value for this object.Definition TNamed.h:49; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TROOT::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from the list of Cleanups.Definition TROOT.cxx:2498. Reimplemented from TObject.; Definition at line 49 of file TNamed.h. ◆ IsA(). TClass * TNamed::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in ROOT::Experimental::XRooFit::xRooHypoSpace, TMVA::TSpline1, TMVA::TSpline2, TMVA::VariableImportance, TMVA::VariableInfo, TRadialGradient, TProcessID, TProcessUUID, TQClass, TRemoteObject, TROOT, TStyle, TSystem, TSystemDirectory, TSystemFile, TTask, TVirtualMonitoringWriter, TVirtualMonitoringReader, TVirtualPS, TVirtualX, TToggle, TToggleGroup, TProtoClass, ROOT::TSchemaRule::TSources, TStreamerElement, TStreamerBase, TStreamerBasicPointer, TStreamerLoop, TStreamerBasicType, TStreamerObject, TStreamerObjectAny, TStreamerObjectPointer, TStreamerObjectAnyPointer, TStreamerStrin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNamed.html:19520,error,error,19520,doc/master/classTNamed.html,https://root.cern,https://root.cern/doc/master/classTNamed.html,1,['error'],['error']
Availability,"a dictionary will be automatically created ;  fildir.C This macro displays the ROOT Directory data structure ;  file.C This macro displays the physical ROOT file structure ;  hadd.C Macro to add histogram files This macro is kept for didactical purposes only: use instead the executable $ROOTSYS/bin/hadd ! ;  importCode.C Example of script showing how to create a ROOT file with subdirectories ;  loopdir.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  loopdir11.C Example of script to loop on all the objects of a ROOT file directory and print on Postscript all TH1 derived objects ;  mergeSelective.C Merge only part of the content of a set of files ;  readCode.C Example of script showing how to navigate in a ROOT file with sub-directories and read the objects in each sub-directory ;  testMergeCont.C Macro demonstrating the merging of containers ;  ► math;  Bessel.C Show the different kinds of Bessel functions available in ROOT To execute the macro type in: ;  binomial.C tutorial illustrating the use of TMath::Binomial can be run with: ;  ChebyshevPol.C Example of Chebyshev polynomials using new TFormula pre-defined definitions of chebyshev polynomials ;  chi2test.C Example to use chi2 test for comparing two histograms One unweighted histogram is compared with a weighted histogram ;  CrystalBall.C Example of CrystalBall Function and its distribution (pdf and cdf) ;  exampleFunctor.C Tutorial illustrating how creating a TF1 class using functor or class member functions ;  exampleMultiRoot.C Example of using multiroot finder based on GSL algorithm ;  exampleTKDE.C Example of using the TKDE class (kernel density estimator) ;  FeldmanCousins.C Example macro of using the TFeldmanCousins class in root ;  GammaFun.C Example showing the usage of the major special math functions (gamma, beta, erf) in ROOT To execute the macro type in: ;  goftest.C GoFTest tutorial macro ;  kdTreeBinning.C kdTreeBinning tuto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:128980,avail,available,128980,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['avail'],['available']
Availability,"a event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option; or set the bin count to the weights in case of weighted data. void Draw(const Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1., Double_t xMax = 0.). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.94999999999999996); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TKDE.html:16656,error,errors,16656,root/html604/TKDE.html,https://root.cern,https://root.cern/root/html604/TKDE.html,5,"['Error', 'error']","['Errors', 'errors']"
Availability,"a free function pointer. double IntegralUp(ROOT::Math::GSLFuncPointer f, void* p, double a). evaluate the Integral of a function f over the semi-infinite interval (a,+inf) passing a free function pointer. double IntegralLow(ROOT::Math::GSLFuncPointer f, void* p, double b). evaluate the Integral of a function f over the over the semi-infinite interval (-inf,b) passing a free function pointer. double Integral(ROOT::Math::GSLFuncPointer f, void* p, const vector<double>& pts). evaluate the Integral of a function f with knows singular points over the over a defined interval passing a free function pointer. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetIntegrationRule(ROOT::Math::Integration::GKRule ). set the integration rule (Gauss-Kronrod rule).; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetOptions(const ROOT::Math::IntegratorOneDimOptions& opt); set the options. IntegrationOneDim::Type GetType() const; get type name. { return fType; }. const char * GetTypeName() const. return the name. bool CheckFunction(); internal method to check validity of GSL function pointer. » Last changed: root/mathmore:$Id: GSLIntegrator.h 36764 2010-11-19 10:02:00Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:12824,Error,Error,12824,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,2,['Error'],['Error']
Availability,"a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. Int_t GetEntryNumberFriend(const TTree* T); returns the entry number in this friend Tree corresponding to entry in; the master Tree T.; In case this friend Tree and T do not share an index with the same; major and minor name, the entry serial number in the friend tree; and in the master Tree are assumed to be the same. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; Return entry number corresponding to major and minor number; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeIndex.html:9232,failure,failure,9232,root/html528/TTreeIndex.html,https://root.cern,https://root.cern/root/html528/TTreeIndex.html,1,['failure'],['failure']
Availability,"a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeIndex.html:9319,failure,failure,9319,root/html530/TTreeIndex.html,https://root.cern,https://root.cern/root/html530/TTreeIndex.html,3,['failure'],['failure']
Availability,"a friend Tree TF, the following cases are supported:; CASE 1: T->GetEntry(entry) is called; In this case, the serial number entry is used to retrieve; the data in both Trees.; CASE 2: T->GetEntry(entry) is called, TF has a TreeIndex; the expressions given in major/minorname of TF are used; to compute the value pair major,minor with the data in T.; TF->GetEntryWithIndex(major,minor) is then called (tricky case!); CASE 3: T->GetEntryWithIndex(major,minor) is called.; It is assumed that both T and TF have a TreeIndex built using; the same major and minor name. Saving the TreeIndex. Once the index is built, it can be saved with the TTree object; with tree.Write(); (if the file has been open in ""update"" mode). The most convenient place to create the index is at the end of; the filling process just before saving the Tree header.; If a previous index was computed, it is redefined by this new call. Note that this function can also be applied to a TChain. The return value is the number of entries in the Index (< 0 indicates failure). It is possible to play with different TreeIndex in the same Tree.; see comments in TTree::SetTreeIndex. ~TTreeIndex(); Destructor. void Append(const TVirtualIndex* , Bool_t delaySort = kFALSE); Append 'add' to this index. Entry 0 in add will become entry n+1 in this.; If delaySort is true, do not sort the value, then you must call; Append(0,kFALSE);. bool ConvertOldToNew(); conversion from old 64bit indexes; return true if index was converted. Long64_t GetEntryNumberFriend(const TTree* parent); Returns the entry number in this (friend) Tree corresponding to entry in; the master Tree 'parent'.; In case this (friend) Tree and 'master' do not share an index with the same; major and minor name, the entry serial number in the (friend) tree; and in the master Tree are assumed to be the same. Long64_t FindValues(Long64_t major, Long64_t minor) const; find position where major|minor values are in the IndexValues tables; this is the index in IndexValues ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeIndex.html:9568,failure,failure,9568,root/html534/TTreeIndex.html,https://root.cern,https://root.cern/root/html534/TTreeIndex.html,6,['failure'],['failure']
Availability,"a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:62434,error,errors,62434,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,2,['error'],['errors']
Availability,"a function such as in the code below, it will be deleted when it goes out of scope.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; }; As soon as the function foohas finished executing, the variable f is deleted. When a TFile object is deleted an implicit call to TFile::Close is made. This will save only the file descriptor to disk. It contains the file header, the StreamerInfolist, the key list, the free segment list, and the end address. See “The Physical Layout of ROOT Files”. The TFile::Close does not make a call to Write(), which means that the objects in memory will not be saved in the file. You need to explicitly call TFile::Write() to save the object in memory to file before the exit of the function.; void foo() {; TFile f(""AFile.root"",""RECREATE"");; ... stuff ...; f.Write();; }; To prevent an object in a function from being deleted when it goes out of scope, you can create it on the heap instead of on the stack. This will create a TFile object f, that is available on a global scope, and it will still be available when exiting the function.; void foo() {; TFile *f = new TFile(""AFile.root"",""RECREATE"");; }; 11.2.9 Retrieving Objects from Disk; If you have a ROOT session running, please quit and start fresh.; We saw that multiple versions of an object with the same name could be in a ROOT file. In our example, we saved a modified histogram hpx to the file, which resulted in two hpx's uniquely identified by the cycle number: hpx;1 and hpx;2. The question is how we can retrieve the right version of hpx. When opening the file and using hpx, Cling retrieves the one with the highest cycle number. To read the hpx;1 into memory, rather than the hpx:2 we would get by default, we have to explicitly get it and assign it to a variable.; root[] TFile *f1 = new TFile(""hsimple.root""); root[] TH1F *hpx1; f1->GetObject(""hpx;1"",hpx); root[] hpx1->Draw(); 11.2.10 Subdirectories and Navigation; The TDirectory class lets you organize its contents into subdirectories, and TFile be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:460211,avail,available,460211,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['avail'],['available']
Availability,"a is drawn through the end points of the vertical error bars. . ""E0"" Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping . ""E5"" Like E3 but ignore the bins with 0 contents. . ""E6"" Like E4 but ignore the bins with 0 contents. . ""X0"" When used with one of the ""E"" option, it suppress the error bar along X as gStyle->SetErrorX(0) would do. . {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; }; TStyle::SetEndErrorSizevoid SetEndErrorSize(Float_t np=2)Set the size (in pixels) of the small lines drawn at the end of the error bars (TH1 or TGraphErrors).Definition TStyle.cxx:1340; TStyle::SetErrorXvoid SetErrorX(Float_t errorx=0.5)Definition TStyle.h:340. The options ""E3"" and ""E4"" draw an error band through the end points of the vertical error bars. With ""E4"" the error band is smoothed. Because of the smoothing algorithm used some artefacts may appear at the end of the band like in the following example. In such cases ""E3"" should be used instead of ""E4"".; {; auto ce4 = new TCanvas(""ce4"",""ce4"",600,400);; ce4->Divide(2,1);; auto he4 = new TH1F(""he4"",""Distribution drawn with option E4"",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he4->Fill(gRandom->Gaus(0,1));; he4->SetFillColor(kRed);; he4->GetXaxis()->SetRange(40,48);; ce4->cd(1);; he4->Draw(""E4"");; ce4->cd(2);; auto he3 = (TH1F*)he4->DrawClone(""E3"");; he3->SetTitle(""Distribution drawn option E3"");; }. 2D histograms can be drawn with error bars as shown is the following example:; {; auto c2e = new TCanvas(""c2e"",""c2e"",600,400);; auto h2e = new TH2F(""h2e"",""TH2 drawn with option E"",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; h2e->Fill(px,5*py);; }; h2e->Draw(""E"");; }. The bar chart op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:29041,error,error,29041,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,2,['error'],['error']
Availability,"a members; class charts. ROOT; » GRAF3D; » GL; » TGLPlotCoordinates. class TGLPlotCoordinates. Helper class for plot-painters holding information about axis; ranges, numbers of bins and flags if certain axis is logartihmic. Function Members (Methods); public:. TGLPlotCoordinates(); virtual~TGLPlotCoordinates(); static TClass*Class(); EGLCoordTypeGetCoordType() const; Double_tGetFactor() const; Int_tGetFirstXBin() const; Int_tGetFirstYBin() const; Int_tGetFirstZBin() const; Int_tGetLastXBin() const; Int_tGetLastYBin() const; Int_tGetLastZBin() const; Int_tGetNXBins() const; Int_tGetNYBins() const; Int_tGetNZBins() const; const Rgl::BinRange_t&GetXBins() const; Double_tGetXLength() const; Bool_tGetXLog() const; const Rgl::Range_t&GetXRange() const; const Rgl::Range_t&GetXRangeScaled() const; Double_tGetXScale() const; const Rgl::BinRange_t&GetYBins() const; Double_tGetYLength() const; Bool_tGetYLog() const; const Rgl::Range_t&GetYRange() const; const Rgl::Range_t&GetYRangeScaled() const; Double_tGetYScale() const; const Rgl::BinRange_t&GetZBins() const; Double_tGetZLength() const; Bool_tGetZLog() const; const Rgl::Range_t&GetZRange() const; const Rgl::Range_t&GetZRangeScaled() const; Double_tGetZScale() const; virtual TClass*IsA() const; Bool_tModified() const; voidResetModified(); voidSetCoordType(EGLCoordType type); Bool_tSetRanges(TH2Poly* hist); Bool_tSetRanges(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRanges(const TAxis* xAxis, const TAxis* yAxis, const TAxis* zAxis); voidSetXLog(Bool_t xLog); voidSetYLog(Bool_t yLog); voidSetZLog(Bool_t zLog); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TGLPlotCoordinates(const TGLPlotCoordinates&); TGLPlotCoordinates&operator=(const TGLPlotCoordinates&); Bool_tSetRangesCartesian(const TH1* hist, Bool_t errors = kFALSE, Bool_t zBins = kFALSE); Bool_tSetRangesCylindrical(const TH1* hist); Bool_tSetR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPlotCoordinates.html:1614,error,errors,1614,root/html534/TGLPlotCoordinates.html,https://root.cern,https://root.cern/root/html534/TGLPlotCoordinates.html,2,['error'],['errors']
Availability,"a model function.; Create always new parameter setting list from a given model function. void SetParamsSettings(unsigned int npar, const double* params, const double* vstep = 0). set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter setting from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitConfig.html:4446,error,errors,4446,root/html530/ROOT__Fit__FitConfig.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitConfig.html,1,['error'],['errors']
Availability,"a nop for TClonesArray. void Sort(Int_t upto = kMaxInt); If objects in array are sortable (i.e. IsSortable() returns true; for all objects) then sort array. void Streamer(TBuffer& b); Write all objects in array to the I/O buffer. ATTENTION: empty slots; are also stored (using one byte per slot). If you don't want this; use a TOrdCollection or TList. TObject *& operator[](Int_t idx); Return pointer to reserved area in which a new object of clones; class can be constructed. This operator should not be used for; lefthand side assignments, like a[2] = xxx. Only like,; new (a[2]) myClass, or xxx = a[2]. Of course right hand side usage; is only legal after the object has been constructed via the; new operator or via the New() method. To remove elements from; the clones array use Remove() or RemoveAt(). TObject * operator[](Int_t idx); Return the object at position idx. Returns 0 if idx is out of bounds. TObject * New(Int_t idx); Create an object of type fClass with the default ctor at the specified; index. Returns 0 in case of error. TObject * AddrAt(Int_t idx). TClass * GetClass() const; { return fClass; }. void AddFirst(TObject* ); { MayNotUse(""AddFirst""); }. void AddLast(TObject* ); { MayNotUse(""AddLast""); }. void AddAt(TObject* , Int_t ); { MayNotUse(""AddAt""); }. void AddAtAndExpand(TObject* , Int_t ); { MayNotUse(""AddAtAndExpand""); }. Int_t AddAtFree(TObject* ); { MayNotUse(""AddAtFree""); return 0; }. void AddAfter(const TObject* , TObject* ); { MayNotUse(""AddAfter""); }. void AddBefore(const TObject* , TObject* ); { MayNotUse(""AddBefore""); }. Bool_t CanBypassStreamer() const; { return TestBit(kBypassStreamer); }. » Author: Rene Brun 11/02/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/cont:$Id: TClonesArray.h 30124 2009-09-13 16:07:19Z brun $ » Last generated: 2009-12-07 15:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClonesArray.html:18208,error,error,18208,root/html526/TClonesArray.html,https://root.cern,https://root.cern/root/html526/TClonesArray.html,1,['error'],['error']
Availability,"a point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). . ""2"" Error rectangles are drawn. . ""3"" A filled area is drawn through the end points of the vertical error bars. . ""4"" A smoothed filled area is drawn through the end points of the vertical error bars. . ""5"" Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. . gStyle->SetErrorX(dx) controls the size of the error along x. dx = 0 removes the error along x.; gStyle->SetEndErrorSize(np) controls the size of the lines at the end of the error bars (when option 1 is used). By default np=1. (np represents the number of pixels).; TGraphErrors; A TGraphErrors is a TGraph with error bars. The errors are defined along X and Y and are symmetric: The left and right errors are the same along X and the bottom and up errors are the same along Y.; {; auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; auto ge = new TGraphErrors(5, x, y, ex, ey);; ge->SetTitle(""A graph with errors"");; ge->Draw(""ap"");; }; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; eyDouble_t ey[n]Definition legend1.C:17; exDouble_t ex[n]Definition legend1.C:17. The option ""0"" shows the error bars for data points outside range.; {; auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; float x[] = {1,2,3};; float err_x[] = {0,0,0};; float err_y[] = {5,5,5};; float y[] = {1,4,9};; auto tg = new TGraphErrors(3,x,y,err_x,err_y);; c48->Divide(2,1);; c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; }; gPad#define gPadDefinition TVirtualPad.h:308. The option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter.html:10116,error,errors,10116,doc/master/classTGraphPainter.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter.html,3,['error'],['errors']
Availability,"a pthread. Returns 0 on success, otherwise an error number will; be returned. Int_t Join(TThread* th, void** ret); Join suspends the execution of the calling thread until the; thread identified by th terminates, either by calling pthread_exit; or by being cancelled. Returns 0 on success, otherwise an error number will; be returned. Int_t Exit(void* ret); Terminates the execution of the calling thread. Return 0. Int_t Kill(TThread* th); Cancellation is the mechanism by which a thread can terminate the; execution of another thread. Returns 0 on success, otherwise an error; number will be returned. Int_t SetCancelOff(); Turn off the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelOn(); Turn on the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Set the cancellation response type of the calling thread to; asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Set the cancellation response type of the calling thread to; deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Introduce an explicit cancellation point. Returns 0. Int_t CleanUpPush(void** main, void* free, void* arg); Add thread cleanup function. Int_t CleanUpPop(void** main, Int_t exe); Pop thread cleanup function from stack. Int_t CleanUp(void** main); Default thread cleanup routine. Long_t SelfId(); Return the thread identifier for the calling thread. TPosixThread(); { }. ~TPosixThread(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPosixThread.html:6994,error,error,6994,root/html534/TPosixThread.html,https://root.cern,https://root.cern/root/html534/TPosixThread.html,2,['error'],['error']
Availability,"a pthread. Returns 0 on success, otherwise an error number will; be returned. Int_t Join(TThread* th, void** ret); Join suspends the execution of the calling thread until the; thread identified by th terminates, either by calling pthread_exit; or by being cancelled. Returns 0 on success, otherwise an error number will; be returned. Int_t Exit(void* ret); Terminates the execution of the calling thread. Return 0. Int_t Kill(TThread* th); Cancellation is the mechanism by which a thread can terminate the; execution of another thread. Returns 0 on success, otherwise an error; number will be returned. Int_t SetCancelOff(); Turn off the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelOn(); Turn on the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Set the cancellation response type of the calling thread to; asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Set the cancellation response type of the calling thread to; deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Introduce an explicit cancellation point. Returns 0. Int_t CleanUpPush(void** main, void* free, void* arg); Add thread cleanup function. Int_t CleanUpPop(void** main, Int_t exe); Pop thread cleanup function from stack. Int_t CleanUp(void** main); Default thread cleanup routine. Long_t SelfId(); Return the thread identifier for the calling thread. TPosixThread(); { }. ~TPosixThread(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-02 16:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPosixThread.html:7455,error,error,7455,root/html604/TPosixThread.html,https://root.cern,https://root.cern/root/html604/TPosixThread.html,2,['error'],['error']
Availability,"a pthread. Returns 0 on success, otherwise an error number will; be returned. Int_t Join(TThread* th, void** ret); Join suspends the execution of the calling thread until the; thread identified by th terminates, either by calling pthread_exit; or by being cancelled. Returns 0 on success, otherwise an error number will; be returned. Int_t Exit(void* ret); Terminates the execution of the calling thread. Return 0. Int_t Kill(TThread* th); Cancellation is the mechanism by which a thread can terminate the; execution of another thread. Returns 0 on success, otherwise an error; number will be returned. Int_t SetCancelOff(); Turn off the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelOn(); Turn on the cancellation state of the calling thread. Returns 0 on; success, otherwise an error number will be returned. Int_t SetCancelAsynchronous(); Set the cancellation response type of the calling thread to; asynchronous, i.e. cancel as soon as the cancellation request; is received. Int_t SetCancelDeferred(); Set the cancellation response type of the calling thread to; deferred, i.e. cancel only at next cancellation point.; Returns 0 on success, otherwise an error number will be returned. Int_t CancelPoint(); Introduce an explicit cancellation point. Returns 0. Int_t CleanUpPush(void** main, void* free, void* arg); Add thread cleanup function. Int_t CleanUpPop(void** main, Int_t exe); Pop thread cleanup function from stack. Int_t CleanUp(void** main); Default thread cleanup routine. Long_t SelfId(); Return the thread identifier for the calling thread. TPosixThread(); { }. ~TPosixThread(); { }. » Author: Fons Rademakers 02/07/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/thread:$Id$ » Last generated: 2015-06-30 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPosixThread.html:7455,error,error,7455,root/html602/TPosixThread.html,https://root.cern,https://root.cern/root/html602/TPosixThread.html,2,['error'],['error']
Availability,"a remote file. ; Anonymous users may not delete files. Returns 0 in case of success and -1 in case of failure. ; Definition at line 821 of file TFTP.cxx. ◆ FreeDirectory(). void TFTP::FreeDirectory ; (; Bool_t ; print = kFALSE). Free a remotely open directory via rootd. ; Definition at line 956 of file TFTP.cxx. ◆ get(). void TFTP::get ; (; const char * ; file, . const char * ; localName = nullptr . ). inline . Definition at line 112 of file TFTP.h. ◆ GetBlockSize(). Int_t TFTP::GetBlockSize ; (; ); const. inline . Definition at line 80 of file TFTP.h. ◆ GetDirEntry(). const char * TFTP::GetDirEntry ; (; Bool_t ; print = kFALSE). Get directory entry via rootd. ; Returns 0 in case no more entries or in case of error. ; Definition at line 988 of file TFTP.cxx. ◆ GetFile(). Long64_t TFTP::GetFile ; (; const char * ; file, . const char * ; localName = nullptr . ). Transfer file from remote host. ; Returns number of bytes received or < 0 in case of error. Error -1 connection is still open, error -2 connection has been closed. In case of failure fRestartAt is set to the number of bytes correclty transfered. Calling GetFile() immediately afterwards will restart at fRestartAt. If this is not desired call SetRestartAt(0) before calling GetFile(). If rootd reports that the file is locked, and you are sure this is not the case (e.g. due to a crash), you can force unlock it by prepending the file name with a '-'. ; Definition at line 406 of file TFTP.cxx. ◆ GetMode(). Int_t TFTP::GetMode ; (; ); const. inline . Definition at line 83 of file TFTP.h. ◆ GetPathInfo(). Int_t TFTP::GetPathInfo ; (; const char * ; path, . FileStat_t & ; buf, . Bool_t ; print = kFALSE . ). Get info about a file. ; Info is returned in the form of a FileStat_t structure (see TSystem.h). The function returns 0 in case of success and 1 if the file could not be stat'ed. ; Definition at line 1029 of file TFTP.cxx. ◆ GetRestartAt(). Long64_t TFTP::GetRestartAt ; (; ); const. inline . Definition at line 82 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFTP.html:18196,error,error,18196,doc/master/classTFTP.html,https://root.cern,https://root.cern/doc/master/classTFTP.html,1,['error'],['error']
Availability,"a s. Used to; avoid double opening when an attempt via TXSlave found a remote proofd. ~TSlave(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. Int_t Compare(const TObject* obj) const; Used to sort slaves by performance index. void Print(Option_t* option = """") const; Printf info about slave. void SetInputHandler(TFileHandler* ih); Adopt and register input handler for this slave. Handler will be deleted; by the slave. Int_t OldAuthSetup(Bool_t master, TString wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TSlave * Create(const char* url, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Static method returning the appropriate TSlave object for the remote; server. Int_t Ping(); Ping the remote master or slave servers.; Returns 0 if ok, -1 in case of error. void Interrupt(Int_t type); Send interrupt OOB byte to master or slave servers.; Returns 0 if ok, -1 in case of error. void StopProcess(Bool_t abort, Int_t timeout); Sent stop/abort request to PROOF server. TObjString * SendCoordinator(Int_t kind, const char* msg = 0, Int_t int2 = 0); Send message to intermediate coordinator. Only meaningful when there is one,; i.e. in XPD framework. void SetAlias(const char* alias); Set an alias for this session. If reconnection is supported, the alias; will be communicated to the remote coordinator so that it can be recovered; when reconnecting. void SetTXSlaveHook(TSlave_t xslavehook); Set hook to TXSlave ctor. TSlave(const TSlave& s); { }. void operator=(const TSlave& ); { }. void FlushSocket(); { }. Int_t SendGroupPriority(const char* , Int_t ); { return 0; }. void SetSocket(TSocket* s); { fSocket = s; }. void SetStatus(Int_t st); { fStatus = st; }. Bool_t IsSortable() const; { return kTRUE; }. const char * GetName() const; { return fName; }. const char * GetImage() const; { return fImage; }. const char * GetProofWorkDir() const; { return fProo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlave.html:9974,error,error,9974,root/html528/TSlave.html,https://root.cern,https://root.cern/root/html528/TSlave.html,6,['error'],['error']
Availability,"a separated lists. Bool_t import(RooAbsData& data, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg()); Import a dataset (RooDataSet or RooDataHist) into the work space. The workspace will contain a copy of the data; The dataset and its variables can be renamed upon insertion with the options below. Accepted arguments. Rename(const char* suffix) -- Rename dataset upon insertion; RenameVariable(const char* inputName, const char* outputName) -- Change names of observables in dataset upon insertion. Bool_t defineSet(const char* name, const RooArgSet& aset, Bool_t importMissing = kFALSE); Define a named RooArgSet with given constituents. If importMissing is true, any constituents; of aset that are not in the workspace will be imported, otherwise an error is returned; for missing components. Bool_t defineSet(const char* name, const char* contentList); Define a named set in the work space through a comma separated list of; names of objects already in the workspace. Bool_t extendSet(const char* name, const char* newContents); Define a named set in the work space through a comma separated list of; names of objects already in the workspace. const RooArgSet* set(const char* name); Return pointer to previously defined named set with given nmame; If no such set is found a null pointer is returned. Bool_t renameSet(const char* name, const char* newName); Rename set to a new name. Bool_t removeSet(const char* name); Remove a named set from the workspace. Bool_t startTransaction(); Open an import transaction operations. Returns kTRUE if successful, kFALSE; if there is already an ongoing transaction. Bool_t cancelTransaction(); Cancel an ongoing import transaction. All objects imported since startTransacti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooWorkspace.html:17469,error,error,17469,root/html534/RooWorkspace.html,https://root.cern,https://root.cern/root/html534/RooWorkspace.html,6,['error'],['error']
Availability,"a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; RooStats::HypoTestCalculatorHypoTestCalculator(); RooStats::HypoTestCalculatorHypoTestCalculator(const RooStats::HypoTestCalculator&); virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HypoTestCalculator.html:1581,avail,available,1581,root/html602/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__HypoTestCalculator.html,4,['avail'],['available']
Availability,"a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonModel(const RooStats::ModelConfig& model); Set a common model for both the null and alternate, add to the the workspace if not already there. SetNullModel(const RooSta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestCalculator.html:1579,avail,available,1579,root/html528/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestCalculator.html,4,['avail'],['available']
Availability,"a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector& insp, char* parent); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonModel(const RooStats::ModelConfig& model); Set a common model for both the null and alternate, add to the the workspace if not already there. SetNullMode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestCalculator.html:1579,avail,available,1579,root/html526/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestCalculator.html,1,['avail'],['available']
Availability,"a set of parameters of which specify the null (including values and const/non-const status), and ; a set of parameters of which specify the alternate (including values and const/non-const status). The interface allows one to pass the model, data, and parameters via a workspace and then specify them with names.; The interface will be extended so that one does not need to use a workspace. After configuring the calculator, one only needs to ask GetHypoTest, which will return a HypoTestResult pointer. The concrete implementations of this interface should deal with the details of how the nuisance parameters are; dealt with (eg. integration vs. profiling) and which test-statistic is used (perhaps this should be added to the interface). The motivation for this interface is that we hope to be able to specify the problem in a common way for several concrete calculators. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~HypoTestCalculator(); static TClass*Class(); virtual RooStats::HypoTestResult*GetHypoTest() const; virtual TClass*IsA() const; RooStats::HypoTestCalculator&operator=(const RooStats::HypoTestCalculator&); virtual voidSetAlternateModel(const RooStats::ModelConfig& model); virtual voidSetCommonModel(const RooStats::ModelConfig& model); virtual voidSetData(RooAbsData& data); virtual voidSetNullModel(const RooStats::ModelConfig& model); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~HypoTestCalculator(); {}. HypoTestResult* GetHypoTest() const; main interface to get a HypoTestResult, pure virtual. void SetCommonModel(const RooStats::ModelConfig& model); Set a common model for both the null and alternate, add to the the workspace if not already there. SetNul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestCalculator.html:1581,avail,available,1581,root/html534/RooStats__HypoTestCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestCalculator.html,2,['avail'],['available']
Availability,"a socket. The socket will adopt previously opened Unix socket with; descriptor desc. The sockpath arg is for info purposes only. Use; this method to adopt e.g. a socket created via socketpair(). TUDPSocket(const TUDPSocket& s); TUDPSocket copy ctor. void Close(Option_t* opt = """"); Close the socket. If option is ""force"", calls shutdown(id,2) to; shut down the connection. This will close the connection also; for the parent of this process. Also called via the dtor (without; option ""force"", call explicitly Close(""force"") if this is desired). TInetAddress GetLocalInetAddress(); Return internet address of local host to which the socket is bound.; In case of error TInetAddress::IsValid() returns kFALSE. Int_t GetLocalPort(); Return the local port # to which the socket is bound.; In case of error return -1. Int_t Select(Int_t interest = kRead, Long_t timeout = -1); Waits for this socket to change status. If interest=kRead,; the socket will be watched to see if characters become available for; reading; if interest=kWrite the socket will be watched to; see if a write will not block.; The argument 'timeout' specifies a maximum time to wait in millisec.; Default no timeout.; Returns 1 if a change of status of interest has been detected within; timeout; 0 in case of timeout; < 0 if an error occured. Int_t Send(Int_t kind); Send a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an acknowledgement, making the sending process synchronous. Int_t Send(Int_t status, Int_t kind); Send a status and a single message opcode. Use kind (opcode) to set the; TMessage ""what"" field. Returns the number of bytes that were sent; (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has; been or'ed with kMESS_ACK, the call will only return after having; received an ackno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUDPSocket.html:13047,avail,available,13047,root/html534/TUDPSocket.html,https://root.cern,https://root.cern/root/html534/TUDPSocket.html,6,['avail'],['available']
Availability,"a solution . Since doubles are stored with 15; digits, we can expect the accuracy to be as small as 3 digits . Det(Double_t &d1,Double_t &d2); The determinant is d1*TMath::Power(2.,d2); Expressing the determinant this way makes under/over-flow very; unlikely . Decompose(); Here the actually decomposition is performed . One can change the; matrix A after the decomposition constructor has been called; without effecting the decomposition result. Solve(TVectorD &b); Solve A x = b . x is supplied through the argument and replaced with; the solution . TransSolve(TVectorD &b); Solve A^T x = b . x is supplied through the argument and replaced; with the solution . MultiSolve(TMatrixD &B); Solve A X = B . where X and are now matrices . X is supplied through; the argument and replaced with the solution . Invert(TMatrixD &inv); This is of course just a call to MultiSolve with as input argument; the unit matrix . Note that for a matrix a(m,n) with m > n a; pseudo-inverse is calculated . Tolerances and Scaling. The tolerance parameter (which is a member of this base class) plays; a crucial role in all operations of the decomposition classes . It; gives the user a powerful tool to monitor and steer the operations; Its default value is sqrt(epsilon) where 1+epsilon = 1. If you do not want to be bothered by the following considerations,; like in most other linear algebra packages, just set the tolerance; with SetTol to an arbitrary small number . The tolerance number is used by each decomposition method to decide; whether the matrix is near singular, except of course SVD which can; handle singular matrices .; For each decomposition this will be checked in a different way; in LU; the matrix is considered singular when, at some point in the; decomposition, a diagonal element < fTol . Therefore, we had to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompBase.html:2386,Toler,Tolerances,2386,root/html532/TDecompBase.html,https://root.cern,https://root.cern/root/html532/TDecompBase.html,4,['Toler'],['Tolerances']
Availability,"a subset of the data set by applying the given cut on the data points.; The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. RooAbsData* reduce(const RooArgSet& varSubset, const char* cut = 0); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The cut expression can refer to any variable in the data set. For cuts involving; other variables, such as intermediate formula objects, use the equivalent; reduce method specifying the as a RooFormulVar reference. RooAbsData* reduce(const RooArgSet& varSubset, const RooFormulaVar& cutVar); Create a subset of the data set by applying the given cut on the data points; and reducing the dimensions to the specified set. The 'cutVar' formula variable is used to select the subset of data points to be; retained in the reduced data collection. Double_t weightError(RooAbsData::ErrorType etype = Poisson) const; Return error on current weight (dummy implementation returning zero). void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; Return asymmetric error on weight. (Dummy implementation returning zero). RooPlot* plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Plot dataset on specified frame. By default an unbinned dataset will use the default binning of; the target frame. A binned dataset will by default retain its intrinsic binning. The following optional named arguments can be used to modify the default behavior. Data representation options. Asymmetry(const RooCategory& c) -- Show the asymmetry of the daya in given two-state category",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:17157,error,error,17157,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,12,"['Error', 'error']","['ErrorType', 'error']"
Availability,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-03-13 19:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFITSHDU.html:12941,error,error,12941,root/html534/TFITSHDU.html,https://root.cern,https://root.cern/root/html534/TFITSHDU.html,2,['error'],['error']
Availability,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-06-02 15:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFITSHDU.html:13538,error,error,13538,root/html604/TFITSHDU.html,https://root.cern,https://root.cern/root/html604/TFITSHDU.html,2,['error'],['error']
Availability,"a table HDU given its name. TVectorD* GetTabRealVectorColumn(Int_t colnum); Get a real number-typed column from a table HDU given its column index (>=0). TVectorD* GetTabRealVectorColumn(const char* colname); Get a real number-typed column from a table HDU given its name. Bool_t Change(const char* filter); Change to another HDU given by ""filter"".; The parameter ""filter"" will be appended to the; FITS file's base path. For example:; hduObject.Change(""[EVENTS][TIME > 5]"");; Please, see documentation of TFITSHDU(const char *filepath_with_filter) constructor; for further information. Bool_t Change(Int_t extension_number); Change to another HDU given by extension_number. TObjArray * GetTabRealVectorCells(Int_t colnum); Get a collection of real vectors embedded in cells along a given column from a table HDU. colnum >= 0. TObjArray * GetTabRealVectorCells(const char* colname); Get a collection of real vectors embedded in cells along a given column from a table HDU by name. TVectorD * GetTabRealVectorCell(Int_t rownum, Int_t colnum); Get a real vector embedded in a cell given by (row>=0, column>=0). TVectorD * GetTabRealVectorCell(Int_t rownum, const char* colname); Get a real vector embedded in a cell given by (row>=0, column name). const TString& GetColumnName(Int_t colnum); Get the name of a column given its index (column>=0).; In case of error the column name is """". TFITSHDU(const char* filepath_with_filter). Int_t GetRecordNumber() const; Metadata access methods. { return fNRecords; }. struct HDURecord * GetRecord(const char* keyword). Int_t GetTabNColumns() const; Table readers. { return fNColumns; }. Int_t GetTabNRows() const; { return fNRows; }. » Author: Claudi Martinez, July 19th 2010 » Copyright (C) 1995-2010, Rene Brun and Fons Rademakers. *; » Last changed: root/graf2d:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFITSHDU.html:13538,error,error,13538,root/html602/TFITSHDU.html,https://root.cern,https://root.cern/root/html602/TFITSHDU.html,2,['error'],['error']
Availability,"a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3408 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:120585,error,error,120585,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,"a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121915,error,error,121915,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability,"a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintOverlaps() prints the list of overlaps.; 18.6.2 Graphical Checking Methods. Safety computation checking. In order to check a given point, CheckPoint(x,y,z) method of TGeoManager draws the daughters of the volume containing the point one level down, printing the path to the deepest physical node holding this point. It also computes the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1003542,down,down,1003542,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['CheckPoint', 'down']","['CheckPoint', 'down']"
Availability,"a(), 0, 1001);; 1744 fAttLine[j].SaveLineAttributes(out, TString::Format(""tgme->GetAttLine(%d)"", j).Data(), 1, 1, 1);; 1745 }; 1746 ; 1747 for (Int_t i = 0; i < fNpoints; i++) {; 1748 out << "" tgme->SetPoint("" << i << "", "" << fX[i] << "", "" << fY[i] << "");"" << std::endl;; 1749 out << "" tgme->SetPointEX("" << i << "", "" << fExL[i] << "", "" << fExH[i] << "");"" << std::endl;; 1750 ; 1751 for (Int_t j = 0; j < fNYErrors; j++); 1752 out << "" tgme->SetPointEY("" << i << "", "" << j << "", "" << fEyL[j][i] << "", "" << fEyH[j][i] << "");""; 1753 << std::endl;; 1754 }; 1755 ; 1756 SaveHistogramAndFunctions(out, ""tgme"", frameNumber, option);; 1757}; 1758 ; 1759////////////////////////////////////////////////////////////////////////////////; 1760/// Multiply the values and errors of a TGraphMultiErrors by a constant c1.; 1761///; 1762/// If option contains ""x"" the x values and errors are scaled; 1763/// If option contains ""y"" the y values and (multiple) errors are scaled; 1764/// If option contains ""xy"" both x and y values and (multiple) errors are scaled; 1765 ; 1766void TGraphMultiErrors::Scale(Double_t c1, Option_t *option); 1767{; 1768 TGraph::Scale(c1, option);; 1769 TString opt = option; opt.ToLower();; 1770 if (opt.Contains(""x"") && GetEXlow()) {; 1771 for (Int_t i=0; i<GetN(); i++); 1772 GetEXlow()[i] *= c1;; 1773 }; 1774 if (opt.Contains(""x"") && GetEXhigh()) {; 1775 for (Int_t i=0; i<GetN(); i++); 1776 GetEXhigh()[i] *= c1;; 1777 }; 1778 if (opt.Contains(""y"")) {; 1779 for (size_t d=0; d<fEyL.size(); d++); 1780 for (Int_t i=0; i<fEyL[d].GetSize(); i++); 1781 fEyL[d][i] *= c1;; 1782 for (size_t d=0; d<fEyH.size(); d++); 1783 for (Int_t i=0; i<fEyH[d].GetSize(); i++); 1784 fEyH[d][i] *= c1;; 1785 }; 1786}; 1787 ; 1788////////////////////////////////////////////////////////////////////////////////; 1789/// Set ex and ey values for point pointed by the mouse.; 1790///; 1791/// Up to 3 y error dimensions possible.; 1792 ; 1793void TGraphMultiErrors::SetPointError(Double_t exL, Double_t e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:60078,error,errors,60078,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,3,['error'],['errors']
Availability,"a(data, &obj, &f1);; 1050 if (data.Size() == 0 ) {; 1051 Warning(""Chisquare"",""data set is empty - return -1"");; 1052 return -1;; 1053 }; 1054 ROOT::Math::WrappedMultiTF1 wf1(f1);; 1055 if (type == ROOT::Fit::EChisquareType::kPLikeRatio) {; 1056 // use the poisson log-lokelihood (Baker-Cousins chi2); 1057 ROOT::Fit::PoissonLLFunction nll(data, wf1);; 1058 return 2.* nll( f1.GetParameters() ) ;; 1059 }; 1060 ROOT::Fit::Chi2Function chi2(data, wf1);; 1061 return chi2(f1.GetParameters() );; 1062 ; 1063}; BinData.h; Chi2FCN.h; FitConfig.h; Fitter.h; HFitInterface.h; MinimizerOptions.h; Minimizer.h; PoissonLikelihoodFCN.h; g#define g(i)Definition RSha256.hxx:105; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TBackCompFitter.h; kIterBackwardconst Bool_t kIterBackwardDefinition TCollection.h:43; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; TF1.h; TF2.h; TF3.h; TFitResultPtr.h; TFitResult.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; lenOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:40998,error,error,40998,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['error'],['error']
Availability,"a(n, 1, x, y, e);; lf->Eval(); //looking at the parameter significance, you see,; // that maybe the fit will improve, if you take out; // the constant term; lf->SetFormula(""x++x*x"");; lf->Eval();. 2.3.2 If the input data is not stored, the fitter will have to be; cleared and the data will have to be added again to try a; different formula. 3.Accessing the fit results; 3.1 There are methods in the fitter to access all relevant information:; --GetParameters, GetCovarianceMatrix, etc; --the t-values of parameters and their significance can be reached by; GetParTValue() and GetParSignificance() methods; 3.2 If fitting with a pre-defined TF123, the fit results are also; written into this function. 4.Robust fitting - Least Trimmed Squares regression (LTS); Outliers are atypical(by definition), infrequant observations; data points; which do not appear to follow the characteristic distribution of the rest; of the data. These may reflect genuine properties of the underlying; phenomenon(variable), or be due to measurement errors or anomalies which; shouldn't be modelled. (StatSoft electronic textbook). Even a single gross outlier can greatly influence the results of least-; squares fitting procedure, and in this case use of robust(resistant) methods; is recommended. The method implemented here is based on the article and algorithm:; ""Computing LTS Regression for Large Data Sets"" by; P.J.Rousseeuw and Katrien Van Driessen; The idea of the method is to find the fitting coefficients for a subset; of h observations (out of n) with the smallest sum of squared residuals.; The size of the subset h should lie between (npoints + nparameters +1)/2; and n, and represents the minimal number of good points in the dataset.; The default value is set to (npoints + nparameters +1)/2, but of course; if you are sure that the data contains less outliers it's better to change; h according to your data. To perform a robust fit, call EvalRobust() function instead of Eval() after; adding the points a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:5792,error,errors,5792,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,10,['error'],['errors']
Availability,a) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; const TUnfoldBinning * fConstInputBins;  binning scheme for the input (detector level) ;  ; const TUnfoldBinning * fConstOutputBins;  binning scheme for the output (truth level) ;  ; TUnfoldBinning * fOwnedInputBins;  pointer to input binning scheme if owned by this class ;  ; TUnfoldBinning * fOwnedOutputBins;  pointer to output binning scheme if owned by this class ;  ; TUnfoldBinning * fRegularisationConditions;  binning scheme for the regularisation conditions ;  ;  Protected Attributes inherited from TUnfoldSys; TMatrixD * fAoutside;  Input: underflow/overflow bins. ;  ; TMap * fBgrErrScaleIn;  Input: background sources correlated error. ;  ; TMap * fBgrErrUncorrInSq;  Input: uncorr error squared from bgr sources. ;  ; TMap * fBgrIn;  Input: size of background sources. ;  ; TMatrixD * fDAinColRelSq;  Input: normalized column err.sq. (inp.matr.) ;  ; TMatrixDSparse * fDAinRelSq;  Input: normalized errors from input matrix. ;  ; TMap * fDeltaCorrAx;  Result: syst.shift from fSysIn on fAx. ;  ; TMap * fDeltaCorrX;  Result: syst.shift from fSysIn on fX. ;  ; TMatrixDSparse * fDeltaSysTau;  Result: systematic shift from tau. ;  ; Double_t fDtau;  Input: error on tau. ;  ; TMatrixDSparse * fEmatUncorrAx;  Result: syst.error from fDA2 on fAx. ;  ; TMatrixDSparse * fEmatUncorrX;  Result: syst.error from fDA2 on fX. ;  ; TMap * fSysIn;  Input: correlated errors. ;  ; TMatrixDSparse * fVyyData;  Input: error on fY prior to bgr subtraction. ;  ; TMatrixD * fYData;  Input: fY prior to bgr subtraction. ;  ;  Protected Attributes inherited from TUnfold; TMatrixDSparse * fA;  response matrix A ;  ; Double_t fBiasScale;  scale factor for the bias ;  ; EConstraint fConstraint;  type of constraint to use for the unfolding ;  ; TArrayI fHistToX;  mapping of histogram bins to matrix indices ;  ; TMatrixDSparse * fL;  regularisation conditions L ;  ; ERegMode fRegMode;  type of regul,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:37851,error,errors,37851,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['error'],['errors']
Availability,"a.cxx:127; ROOT::Fit::AreaComparer::IsThereAreabool IsThereArea()Definition SparseData.cxx:136; ROOT::Fit::AreaComparer::AreaComparerAreaComparer(vector< double >::iterator iter)Definition SparseData.cxx:121; ROOT::Fit::AreaComparer::fItervector< double >::iterator fIterDefinition SparseData.cxx:140; ROOT::Fit::AreaComparer::fLimitdouble fLimitDefinition SparseData.cxx:141; ROOT::Fit::AreaComparer::fThereIsAreabool fThereIsAreaDefinition SparseData.cxx:139; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::BinData::AddBinUpEdgevoid AddBinUpEdge(const double *xup)add the bin width data, a pointer to an array with the bin upper edge information.Definition BinData.cxx:613; ROOT::Fit::BinData::Addvoid Add(double x, double y)add one dim data with only coordinate and valuesDefinition BinData.cxx:408; ROOT::Fit::BinData::Initializevoid Initialize(unsigned int newPoints, unsigned int dim=1, ErrorType err=kValueError)Preallocate a data set with given size, dimension and error type.Definition BinData.h:122; ROOT::Fit::BoxContainerDefinition SparseData.cxx:78; ROOT::Fit::BoxContainer::operator()bool operator()(const Box &b1)Definition SparseData.cxx:86; ROOT::Fit::BoxContainer::fBoxconst Box & fBoxDefinition SparseData.cxx:80; ROOT::Fit::BoxContainer::BoxContainerBoxContainer(const Box &b)Definition SparseData.cxx:84; ROOT::Fit::BoxDefinition SparseData.cxx:37; ROOT::Fit::Box::fValdouble fValDefinition SparseData.cxx:70; ROOT::Fit::Box::fMinvector< double > fMinDefinition SparseData.cxx:68; ROOT::Fit::Box::fMaxvector< double > fMaxDefinition SparseData.cxx:69; ROOT::Fit::Box::GetMaxconst vector< double > & GetMax() constDefinition SparseData.cxx:55; ROOT::Fit::Box::AddValvoid AddVal(const double value)Definition SparseData.cxx:62; ROOT::Fit::Box::operator<<friend ostream & operator<<(ostream &os, const Box &b)Definition SparseData.cxx:374; ROOT::Fit::Box::GetValdouble Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:13762,error,error,13762,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['error'],['error']
Availability,"a1"", ""a1"", 0.2, 0., 1.);; RooChebychev bkg1(""bkg1"", ""Background 1"", x, RooArgSet(a0, a1));; ; // Build expontential pdf; RooRealVar alpha(""alpha"", ""alpha"", -1);; RooExponential bkg2(""bkg2"", ""Background 2"", x, alpha);; ; // Sum the background components into a composite background pdf; RooRealVar bkg1frac(""sig1frac"", ""fraction of component 1 in background"", 0.2, 0., 1.);; RooAddPdf bkg(""bkg"", ""Signal"", RooArgList(bkg1, bkg2), sig1frac);; ; // Sum the composite signal and background; RooRealVar bkgfrac(""bkgfrac"", ""fraction of background"", 0.5, 0., 1.);; RooAddPdf model(""model"", ""g1+g2+a"", RooArgList(bkg, sig), bkgfrac);; ; // M a k e l i s t o f p a r a m e t e r s b e f o r e a n d a f t e r f i t; // ----------------------------------------------------------------------------------------; ; // Make list of model parameters; std::unique_ptr<RooArgSet> params{model.getParameters(x)};; ; // Save snapshot of prefit parameters; std::unique_ptr<RooArgSet> initParams{static_cast<RooArgSet *>(params->snapshot())};; ; // Do fit to data, to obtain error estimates on parameters; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; model.fitTo(*data, PrintLevel(-1));; ; // P r i n t l a t ex t a b l e o f p a r a m e t e r s o f p d f; // --------------------------------------------------------------------------; ; // Print parameter list in LaTeX for (one column with names, one column with values); params->printLatex();; ; // Print parameter list in LaTeX for (names values|names values); params->printLatex(Columns(2));; ; // Print two parameter lists side by side (name values initvalues); params->printLatex(Sibling(*initParams));; ; // Print two parameter lists side by side (name values initvalues|name values initvalues); params->printLatex(Sibling(*initParams), Columns(2));; ; // Write LaTex table to file; params->printLatex(Sibling(*initParams), OutputFile(""rf407_latextables.tex""));; }; RooAddPdf.h; RooChebychev.h; RooDataSet.h; RooExponential.h; RooGaussian.h; RooPlo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf407__latextables_8C.html:2460,error,error,2460,doc/master/rf407__latextables_8C.html,https://root.cern,https://root.cern/doc/master/rf407__latextables_8C.html,1,['error'],['error']
Availability,"a1=-1.484, ; prevFCN = 1899.958577 a1=-1.485, ; prevFCN = 1899.959183 a1=-1.484, ; prevFCN = 1899.958511 a1=-1.485, ; prevFCN = 1899.960007 a1=-1.485, y=0.0003051, ; prevFCN = 1899.958806 y=-0.0003051, ; prevFCN = 1899.958806 a1=-1.484, y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 y=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; y=0, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C++ version) ; Definition in file rf315_projectpdf.py. tutorialsroofitrf315_projectpdf.py. ROOT master - Reference Guide Generated on T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8py.html:4932,error,error,4932,doc/master/rf315__projectpdf_8py.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8py.html,2,"['avail', 'error']","['available', 'error']"
Availability,"a1=-1.484, ; prevFCN = 1899.958577 a1=-1.485, ; prevFCN = 1899.959183 a1=-1.484, ; prevFCN = 1899.958511 a1=-1.485, ; prevFCN = 1899.960007 a1=-1.485, y=0.0003051, ; prevFCN = 1899.958806 y=-0.0003051, ; prevFCN = 1899.958806 a1=-1.484, y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0, ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 y=0, [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for a1: using 0.4; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for y: using 0.4; ; prevFCN = 1899.958497 a1=-1.483, ; prevFCN = 1899.958952 a1=-1.485, ; prevFCN = 1899.95895 a1=-1.484, y=0.003051, ; prevFCN = 1899.958497 y=-0.003051, ; prevFCN = 1899.958497 y=0.03051, ; prevFCN = 1899.958497 y=-0.03051, ; prevFCN = 1899.958497 y=0.3039, ; prevFCN = 1899.958497 y=-0.3039, ; prevFCN = 1899.958497 y=0.9764, ; prevFCN = 1899.958497 y=-0.9764, ; prevFCN = 1899.958497 [#0] ERROR:Minimization -- RooMinimizer::calculateHessErrors() Error when calculating Hessian; y=0, [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init([gaussy_NORM[y]_X_gaussx_NORM[x]]_Int[y]) using numeric integrator RooIntegrator1D to calculate Int(y); DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf315_projectpdf.C. tutorialsroofitrf315_projectpdf.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf315__projectpdf_8C.html:9359,error,error,9359,doc/master/rf315__projectpdf_8C.html,https://root.cern,https://root.cern/doc/master/rf315__projectpdf_8C.html,2,"['avail', 'error']","['available', 'error']"
Availability,"aData>* fieldMetaData); virtual~TOracleRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetField(Int_t field); virtual ULong_tGetFieldLength(Int_t field); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleRow.html:1393,error,error,1393,root/html528/TOracleRow.html,https://root.cern,https://root.cern/root/html528/TOracleRow.html,1,['error'],['error']
Availability,"aFrame(std::string_view datasetName, const std::vector<std::string> &fileNameGlobs,; 1610 const ColumnNames_t &defaultColumns); 1611 : RInterface(ROOT::Detail::RDF::CreateLMFromFile(datasetName, fileNameGlobs, defaultColumns)); 1612{; 1613}; 1614#else; 1615RDataFrame::RDataFrame(std::string_view datasetName, const std::vector<std::string> &fileNameGlobs,; 1616 const ColumnNames_t &defaultColumns); 1617 : RInterface(ROOT::Detail::RDF::CreateLMFromTTree(datasetName, fileNameGlobs, defaultColumns)); 1618{; 1619}; 1620#endif; 1621 ; 1622////////////////////////////////////////////////////////////////////////////; 1623/// \brief Build the dataframe.; 1624/// \param[in] tree The tree or chain to be studied.; 1625/// \param[in] defaultColumns Collection of default column names to fall back to when none is specified.; 1626///; 1627/// The default columns are looked at in case no column is specified in the; 1628/// booking of actions or transformations.; 1629/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1630RDataFrame::RDataFrame(TTree &tree, const ColumnNames_t &defaultColumns); 1631 : RInterface(std::make_shared<RDFDetail::RLoopManager>(&tree, defaultColumns)); 1632{; 1633}; 1634 ; 1635//////////////////////////////////////////////////////////////////////////; 1636/// \brief Build a dataframe that generates numEntries entries.; 1637/// \param[in] numEntries The number of entries to generate.; 1638///; 1639/// An empty-source dataframe constructed with a number of entries will; 1640/// generate those entries on the fly when some action is triggered,; 1641/// and it will do so for all the previously-defined columns.; 1642/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1643RDataFrame::RDataFrame(ULong64_t numEntries); 1644 : RInterface(std::make_shared<RDFDetail::RLoopManager>(numEntries)); 1645 ; 1646{; 1647}; 1648 ; 1649//////////////////////////////////////////////////////////////////////////; 1650/// \brief",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:91485,avail,available,91485,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"aFrame(std::string_view datasetName, const std::vector<std::string> &fileNameGlobs,; 1787 const ColumnNames_t &defaultColumns); 1788 : RInterface(ROOT::Detail::RDF::CreateLMFromFile(datasetName, fileNameGlobs, defaultColumns)); 1789{; 1790}; 1791#else; 1792RDataFrame::RDataFrame(std::string_view datasetName, const std::vector<std::string> &fileNameGlobs,; 1793 const ColumnNames_t &defaultColumns); 1794 : RInterface(ROOT::Detail::RDF::CreateLMFromTTree(datasetName, fileNameGlobs, defaultColumns)); 1795{; 1796}; 1797#endif; 1798 ; 1799////////////////////////////////////////////////////////////////////////////; 1800/// \brief Build the dataframe.; 1801/// \param[in] tree The tree or chain to be studied.; 1802/// \param[in] defaultColumns Collection of default column names to fall back to when none is specified.; 1803///; 1804/// The default columns are looked at in case no column is specified in the; 1805/// booking of actions or transformations.; 1806/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1807RDataFrame::RDataFrame(TTree &tree, const ColumnNames_t &defaultColumns); 1808 : RInterface(std::make_shared<RDFDetail::RLoopManager>(&tree, defaultColumns)); 1809{; 1810}; 1811 ; 1812//////////////////////////////////////////////////////////////////////////; 1813/// \brief Build a dataframe that generates numEntries entries.; 1814/// \param[in] numEntries The number of entries to generate.; 1815///; 1816/// An empty-source dataframe constructed with a number of entries will; 1817/// generate those entries on the fly when some action is triggered,; 1818/// and it will do so for all the previously-defined columns.; 1819/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1820RDataFrame::RDataFrame(ULong64_t numEntries); 1821 : RInterface(std::make_shared<RDFDetail::RLoopManager>(numEntries)); 1822 ; 1823{; 1824}; 1825 ; 1826//////////////////////////////////////////////////////////////////////////; 1827/// \brief",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:99324,avail,available,99324,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"aPrimitive::TFunc0 fpointer); TFormulaPrimitive(const char* name, const char* formula, TFormulaPrimitive::GenFuncG fpointer, Int_t npar); ~TFormulaPrimitive(); voidTObject::AbstractMethod(const char* method) const; static Int_tAddFormula(TFormulaPrimitive* formula); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEval(Double_t* x); Double_tEval(TObject* o, Double_t* x); Double_tEval(Double_t* x, Double_t* param); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static TFormulaPrimitive*FindFormula(const char* name); static TFormulaPrimitive*FindFormula(const char* name, const char* args); static TFormulaPrimitive*FindFormula(const char* name, UInt_t nargs); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFormulaPrimitive.html:2332,Error,Error,2332,root/html532/TFormulaPrimitive.html,https://root.cern,https://root.cern/root/html532/TFormulaPrimitive.html,2,['Error'],['Error']
Availability,"aSet(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGL5DPainter*GetRealPainter() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const Rgl::Range_t&GetV4Range() const; TAxis*GetXAxis() const; const Rgl::Range_t&GetXRange() const; TAxis*GetYAxis() const; const Rgl::Range_t&GetYRange() const; TAxis*GetZAxis() const; const Rgl::Range_t&GetZRange() const; virtual Bool_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGL5DDataSet.html:1371,error,error,1371,root/html528/TGL5DDataSet.html,https://root.cern,https://root.cern/root/html528/TGL5DDataSet.html,10,['error'],['error']
Availability,"aSet*. { return fChain->GetAsDataSet(whichVars); }. const RooDataSet* GetChainAsConstDataSet(); Get the markov chain on which this interval is based; as a RooDataSet. You do not own the returned RooDataSet*. { return fChain->GetAsConstDataSet(); }. RooDataHist* GetChainAsDataHist(RooArgSet* whichVars = __null); Get a clone of the markov chain on which this interval is based; as a RooDataHist. You own the returned RooDataHist*. { return fChain->GetAsDataHist(whichVars); }. THnSparse* GetChainAsSparseHist(RooArgSet* whichVars = __null); Get a clone of the markov chain on which this interval is based; as a THnSparse. You own the returned THnSparse*. { return fChain->GetAsSparseHist(whichVars); }. RooRealVar* GetNLLVar() const; Get a clone of the NLL variable from the markov chain. { return fChain->GetNLLVar(); }. RooRealVar* GetWeightVar() const; Get a clone of the weight variable from the markov chain. { return fChain->GetWeightVar(); }. void SetEpsilon(Double_t epsilon); set the acceptable level or error for Keys interval determination. void SetIntervalType(enum IntervalType intervalType); Set the type of interval to find. This will only have an effect for; 1-D intervals. If is more than 1 parameter of interest, then a; ""shortest"" interval will always be used, since it generalizes directly; to N dimensions. { fIntervalType = intervalType; }. enum IntervalType GetIntervalType(); Return the type of this interval. { return fIntervalType; }. void SetLeftSideTailFraction(Double_t a); set the left-side tail fraction for a tail-fraction interval. { fLeftSideTF = a; }. void SetDelta(Double_t delta); kbelasco: The inner-workings of the class really should not be exposed; like this in a comment, but it seems to be the only way to give; the user any control over this process, if they desire it. Set the fraction delta such that; topCutoff (a) is considered == bottomCutoff (b) iff; (TMath::Abs(a - b) < TMath::Abs(fDelta * (a + b)/2)); when determining the confidence interval by K",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__MCMCInterval.html:18406,error,error,18406,root/html602/RooStats__MCMCInterval.html,https://root.cern,https://root.cern/root/html602/RooStats__MCMCInterval.html,4,['error'],['error']
Availability,"aUtils::GetFuncWithProto(llvm::dyn_cast<clang::Decl>(cl->getDeclContext()), what, proto, interp,; 737 false /*diags*/);; 738 if (!method) {; 739 // This intended to find the global scope.; 740 clang::TranslationUnitDecl *TU =; 741 cl->getASTContext().getTranslationUnitDecl();; 742 method = ROOT::TMetaUtils::GetFuncWithProto(TU, what, proto, interp,; 743 false /*diags*/);; 744 }; 745 bool has_input_error = false;; 746 if (method != nullptr && (method->getAccess() == clang::AS_public || method->getAccess() == clang::AS_none)) {; 747 std::string filename = ROOT::TMetaUtils::GetFileName(*method, interp);; 748 if (strstr(filename.c_str(), ""TBuffer.h"") != nullptr ||; 749 strstr(filename.c_str(), ""Rtypes.h"") != nullptr) {; 750 ; 751 has_input_error = true;; 752 }; 753 } else {; 754 has_input_error = true;; 755 }; 756 if (has_input_error) {; 757 // We don't want to generate duplicated error messages in several dictionaries (when generating temporaries); 758 const char *maybeconst = """";; 759 const char *mayberef = ""&"";; 760 if (what[strlen(what) - 1] == '<') {; 761 maybeconst = ""const "";; 762 mayberef = """";; 763 }; 764 ROOT::TMetaUtils::Error(nullptr,; 765 ""in this version of ROOT, the option '!' used in a linkdef file\n""; 766 "" implies the actual existence of customized operators.\n""; 767 "" The following declaration is now required:\n""; 768 "" TBuffer &%s(TBuffer &,%s%s *%s);\n"", what, maybeconst, fullname.c_str(), mayberef);; 769 }; 770 return has_input_error;; 771 ; 772}; 773 ; 774////////////////////////////////////////////////////////////////////////////////; 775/// Check if the operator>> has been properly declared if the user has; 776/// requested a custom version.; 777 ; 778bool CheckInputOperator(const clang::RecordDecl *cl, cling::Interpreter &interp); 779{; 780 string fullname;; 781 ROOT::TMetaUtils::GetQualifiedName(fullname, *cl);; 782 int ncha = fullname.length() + 13;; 783 char *proto = new char[ncha];; 784 snprintf(proto, ncha, ""TBuffer&,%s*&"", fullname.c_str(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:25965,error,error,25965,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['error'],['error']
Availability,"a_beta = beta;; 3351 else; 3352 Warning(""SetBetaBeta(Double_t)"",""invalid shape parameter %.2lf"",beta);; 3353}; 3354 ; 3355////////////////////////////////////////////////////////////////////////////////; 3356/// Sets different shape parameter &alpha; and &beta;; 3357/// for the prior distribution for each bin. By default the global parameter are used if they are not set; 3358/// for the specific bin; 3359/// The prior probability of the efficiency is given by the beta distribution:; 3360/// \f[; 3361/// f(\varepsilon;\alpha;\beta) = \frac{1}{B(\alpha,\beta)} \varepsilon^{\alpha-1} (1 - \varepsilon)^{\beta-1}; 3362/// \f]; 3363///; 3364/// Note:; 3365/// - both shape parameters have to be positive (i.e. > 0); 3366/// - bin gives the global bin number (cf. GetGlobalBin); 3367 ; 3368void TEfficiency::SetBetaBinParameters(Int_t bin, Double_t alpha, Double_t beta); 3369{; 3370 if (!fPassedHistogram || !fTotalHistogram) return;; 3371 TH1 * h1 = fTotalHistogram;; 3372 // doing this I get h1->fN which is available only for a TH1D; 3373 UInt_t n = h1->GetBin(h1->GetNbinsX()+1, h1->GetNbinsY()+1, h1->GetNbinsZ()+1 ) + 1;; 3374 ; 3375 // in case vector is not created do with default alpha, beta params; 3376 if (fBeta_bin_params.size() != n ); 3377 fBeta_bin_params = std::vector<std::pair<Double_t, Double_t> >(n, std::make_pair(fBeta_alpha, fBeta_beta) );; 3378 ; 3379 // vector contains also values for under/overflows; 3380 fBeta_bin_params[bin] = std::make_pair(alpha,beta);; 3381 SetBit(kUseBinPrior,true);; 3382 ; 3383}; 3384 ; 3385////////////////////////////////////////////////////////////////////////////////; 3386/// Set the bins for the underlined passed and total histograms; 3387/// If the class have been already filled the previous contents will be lost; 3388 ; 3389Bool_t TEfficiency::SetBins(Int_t nx, Double_t xmin, Double_t xmax); 3390{; 3391 if (GetDimension() != 1) {; 3392 Error(""SetBins"",""Using wrong SetBins function for a %d-d histogram"",GetDimension());; 3393 retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:133330,avail,available,133330,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['avail'],['available']
Availability,a_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=7.28945 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=7.28945 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_g,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:22521,error,error,22521,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,a_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=7.28945 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=7.28945 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:23338,error,error,23338,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,a_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=7.28945 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=7.28945 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized functi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:24972,error,error,24972,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,a_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=7.28945 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=7.28945 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Re,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:26606,error,error,26606,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"a_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initial; # fit parameters, final fit parameters, complete correlation; # matrix, EDM, minimized FCN , last MINUIT status code and; # the number of times the ROOT.RooFit function object has indicated evaluation; # problems (e.g. zero probabilities during likelihood evaluation); r = m.save(); ; # Make contour plot of mx vs sx at 1,2, sigma; frame = m.contour(frac, sigma_g2, 1, 2, 3); frame.SetTitle(""Contour plot""); ; # Print the fit result snapshot; r.Print(""v""); ; # Change parameter values, plotting; # -----------------------------------------------------------------; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:1706,error,error,1706,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,2,['error'],['error']
Availability,"abel) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidDrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPave::GetOption() const; Int_tTPave::GetShadowColor() const; virtual Short_tTAttText::GetTex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPaveLabel.html:2061,error,error,2061,root/html528/TPaveLabel.html,https://root.cern,https://root.cern/root/html528/TPaveLabel.html,4,['error'],['error']
Availability,"abel) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidDrawPaveLabel(Double_t x1, Double_t y1, Double_t x2, Double_t y2, const char* label, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; const char*GetLabel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Option_t*TPave::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TPave::GetOption() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveLabel.html:2061,error,error,2061,root/html534/TPaveLabel.html,https://root.cern,https://root.cern/root/html534/TPaveLabel.html,6,['error'],['error']
Availability,"abel”.; Prompt() - Transfer the interactive prompt to Python.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first with gSystem->Load() before use. Refer back to the other example of the use of TPython that was given in “Access to Python from ROOT”.; To show in detail how Python access can be used, an example Python module is needed, as follows:; print('creating class MyPyClass ... '); class MyPyClass:; def __init__(self):; print('in MyPyClass.__init__'); self._browser = None; def gime(self, what):; return what; This module can now be loaded into a Cling session, the class used to instantiate objects, and their member functions called for showing how different types can cross:; root[] TPython::LoadMacro(""MyPyClass.py"");; creating class MyPyClass ...; root[] MyPyClass m;; in MyPyClass.__init__; root[] char* s = m.gime(""aap"");; root[] s; (char* 0x41ee7754)""aap""; Note that the LoadMacro() call makes the class automatically available, such that it can be used directly. Otherwise, a gROOT->GetClass() call is required first.; 19.1.5.5 Callbacks; The simplest way of setting a callback to Python from Cling, e.g. for a button, is by providing the execution string. See for example tutorials/pyroot/demo.py that comes with the ROOT installation:; # [..]; bar = ROOT.TControlBar('vertical','Demos'); bar.AddButton('Help on Demos',r'TPython::Exec(""execfile('demoshelp.py')"");','Click Here For Help on Running the Demos'); bar.AddButton('browser',r'TPython::Exec(""b = Tbrowser()"");','Start the ROOT browser'); # [..]; Here, the callback is a string that will be interpreted by Cling to call TPython::Exec(), which will, in turn, interpret and execute the string given to it. Note the use of raw strings (the ‘r’ in front of the second argument string), in order to remove the need of escaping the backslashes.; 19.1.5.6 Cling Commands; In interactive mode, the Python exception hook is used to mim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1058863,avail,available,1058863,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"ability of MINUIT's error estimates, and their statistical interpretation, assuming they are accurate. Statistical interpretation:; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. Reliability of MINUIT error estimates.; MINUIT always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. MINUIT, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least MINUIT believes the errors are accurate, although there is always a small chance that MINUIT has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly parameterised so that individual errors are not very meaningful because they are so highly cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:8188,error,error,8188,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,2,"['error', 'reliab']","['error', 'reliable']"
Availability,"abilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc /*itInvActFnc*/, double patternWeight); 413 {; 414 bool hasDeltas = (itDelta != itDeltaEnd);; 415 ; 416 double errorSum = 0.0;; 417 for (ItProbability itProbability = itProbabilityBegin; itProbability != itProbabilityEnd; ++itProbability); 418 {; 419 double probability = *itProbability;; 420 double truth = *itTruthBegin;; 421 /* truth = truth < 0.1 ? 0.1 : truth; */; 422 /* truth = truth > 0.9 ? 0.9 : truth; */; 423 truth = truth < 0.5 ? 0.1 : 0.9;; 424 if (hasDeltas); 425 {; 426 double delta = probability - truth;; 427 (*itDelta) = delta*patternWeight;; 428// (*itDelta) = (*itInvActFnc)(probability) * delta * patternWeight;; 429 ++itDelta;; 430 }; 431 double error (0);; 432 if (probability == 0) // protection against log (0); 433 {; 434 if (truth >= 0.5); 435 error += 1.0;; 436 }; 437 else if (probability == 1); 438 {; 439 if (truth < 0.5); 440 error += 1.0;; 441 }; 442 else; 443 error += - (truth * log (probability) + (1.0-truth) * log (1.0-probability)); // cross entropy function; 444 errorSum += error * patternWeight;; 445 ; 446 }; 447 return errorSum;; 448 }; 449 ; 450 ; 451 ; 452 ; 453/*! \brief soft-max-cross-entropy error function (for mutual exclusive cross-entropy); 454 *; 455 *; 456 */; 457 template <typename ItOutput, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 458 double softMaxCrossEntropy (ItOutput itProbabilityBegin, ItOutput itProbabilityEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc /*itInvActFnc*/, double patternWeight); 459 {; 460 double errorSum = 0.0;; 461 ; 462 bool hasDeltas = (itDelta != itDeltaEnd);; 463 // output - truth; 464 ItTruth itTruth = itTruthBegin;; 465 for (auto itProbability = itProbabilityBegin; itProbability != itProbabilityEnd; ++itProbability, ++itTruth); 466 {; 467// assert (itTruth != itTruthEnd);; 468 double probabili",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:12973,error,error,12973,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['error'],['error']
Availability,"able bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); -*-*-*-*-*-*-*Redefine x, y and z axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); -*-*-*-*-*-*-*Redefine x, y and z axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:114454,error,errors,114454,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,12,['error'],['errors']
Availability,"able product we generally keep at least three versions of the system available for download. The development, production and old versions.; Production release; This is a version we feel comfortable with to exposing to a large audience for serious work. We may issue patch releases of production versions with bug fixes. We release about two production versions per year. The old version is the previous production version that people might need for some time before switching to the new version.; Release candidate; A Release Candidate is a preview of the next production release. It allows users to make their code ready for the new production release, and to provide early feedback.; Development release; Use this to get access to the latest and greatest, but as a side effect there might be some instabilities. However, by trying out the development version you can help us converge much more quickly to a stable version that can then become the new production version.; Nightlies; You can download nightly snapshots of ROOT. That's useful to check whether a bug fix actually fixes an issue you reported, or to see the newest feature you heard about. It helps us tremendously to get feedback from you on nightlies: please try them out and report back to us!; Using binaries; After unpacking / installing the binary, and before using ROOT you should use a special script distributed with ROOT:; source <pathname>/root/bin/thisroot.sh (there are versions for [t]csh and fish, too.); where <pathname> is the location where you unpacked the ROOT distribution.; Typically add these lines to your .profile or .login files. Docker (Experimental); We also provide ROOT in Docker containers, for more information see Docker Hub.; The following recent versions are available for download:. Latest ROOT Releases. ; Pro ; Release 6.20/04 - 2020-04-01 ; . Old ; Release 6.18/04 - 2019-09-11 ; ; ; . Version 6 ; ; Release 6.20/06 - 2020-06-10. Release 6.20/04 - 2020-04-01. Release 6.20/02 - 2020-03-15. Release",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/downloading-root.html:3025,down,download,3025,d/downloading-root.html,https://root.cern,https://root.cern/d/downloading-root.html,1,['down'],['download']
Availability,"able that this frame belongs to. ;  ; Int_t fX0;  X coordinate of the header frame. ;  ; Int_t fY0;  Y coordinate of the header frame. ;  ;  Protected Attributes inherited from TGCompositeFrame; Bool_t fLayoutBroken;  no layout manager is used ;  ; TGLayoutManager * fLayoutManager;  layout manager ;  ; TList * fList;  container of frame elements ;  ; Bool_t fMapSubwindows;  kTRUE - map subwindows ;  ; Int_t fMustCleanup;  cleanup mode (see EFrameCleanup) ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Additional Inherited Members;  Public Types inherited from TGWindow; enum  EEditMode { ;   kEditEnable = 0; , kEditDisable = (1ULL << ( 0 )); , kEditDisableEvents = (1ULL << ( 1 )); , kEditDisableGrab = (1ULL << ( 2 )); , ;   kEditDisableLayout = (1ULL << ( 3 )); , kEd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTableHeaderFrame.html:25321,mask,mask,25321,doc/master/classTGTableHeaderFrame.html,https://root.cern,https://root.cern/doc/master/classTGTableHeaderFrame.html,1,['mask'],['mask']
Availability,"able values in given set. Consult RooFit plotting tutorial for further explanation of meaning & use of this technique. ProjWData(const RooArgSet& s, const RooAbsData& d) As above but only consider subset 's' of observables in dataset 'd' for projection through data averaging. ProjectionRange(const char* rn) Override default range of projection integrals to a different range specified by given range name. This technique allows you to project a finite width slice in a real-valued observable. NumCPU(Int_t ncpu) Number of CPUs to use simultaneously to calculate data-weighted projections (only in combination with ProjWData). Misc content control . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per curve. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. EvalErrorValue(double value) Set curve points at which (pdf) evaluation errors occur to specified value. By default the function value is plotted. Normalization(double scale, ScaleType code) Adjust normalization by given scale factor. Interpretation of number depends on code:; Relative: relative adjustment factor for a normalized function,; NumEvent: scale to match given number of events.; Raw: relative adjustment factor for an un-normalized function. Name(const chat* name) Give curve specified name in frame. Useful if curve is to be referenced later. Asymmetry(const RooCategory& c) Show the asymmetry of the PDF in given two-state category [F(+)-F(-)] / [F(+)+F(-)] rather than the PDF projection. Category must have two states with indices -1 and +1 or three states with indices -1,0 and +1. ShiftToZero(bool flag) Shift entire curve such that lowest visible point is at exactly zero. Mostly useful when plotting \( -\log(L) \) or \( \chi^2 \) distributions. AddTo(const char* name, double_t wgtSelf, double_t wgtOther) Add constructed project",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:132528,error,errors,132528,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['error'],['errors']
Availability,"able {; 65 ; 66 public:; 67 ; 68 // without prior specification of variables; 69 Reader( const TString& theOption="""", Bool_t verbose = 0 );; 70 ; 71 // STL types; 72 Reader( std::vector<std::string>& varNames, const TString& theOption = """", Bool_t verbose = 0 );; 73 Reader( const std::string& varNames, const TString& theOption, Bool_t verbose = 0 ); // format: ""var1:var2:...""; 74 ; 75 // Root types; 76 Reader( std::vector<TString>& varNames, const TString& theOption = """", Bool_t verbose = 0 );; 77 Reader( const TString& varNames, const TString& theOption, Bool_t verbose = 0 ); // format: ""var1:var2:...""; 78 ; 79 virtual ~Reader( void );; 80 ; 81 // book MVA method via weight file; 82 IMethod* BookMVA( const TString& methodTag, const TString& weightfile );; 83 IMethod* BookMVA( TMVA::Types::EMVA methodType, const char* xmlstr );; 84 IMethod* FindMVA( const TString& methodTag );; 85 ; 86 // returns the MVA response for given event; 87 Double_t EvaluateMVA( const std::vector<Float_t> &, const TString& methodTag, Double_t aux = 0 );; 88 Double_t EvaluateMVA( const std::vector<Double_t>&, const TString& methodTag, Double_t aux = 0 );; 89 Double_t EvaluateMVA( MethodBase* method, Double_t aux = 0 );; 90 Double_t EvaluateMVA( const TString& methodTag, Double_t aux = 0 );; 91 ; 92 // returns error on MVA response for given event; 93 // NOTE: must be called AFTER ""EvaluateMVA(...)"" call !; 94 Double_t GetMVAError() const { return fMvaEventError; }; 95 Double_t GetMVAErrorLower() const { return fMvaEventError; }; 96 Double_t GetMVAErrorUpper() const { return fMvaEventErrorUpper; }; 97 ; 98 // regression response; 99 const std::vector< Float_t >& EvaluateRegression( const TString& methodTag, Double_t aux = 0 );; 100 const std::vector< Float_t >& EvaluateRegression( MethodBase* method, Double_t aux = 0 );; 101 Float_t EvaluateRegression( UInt_t tgtNumber, const TString& methodTag, Double_t aux = 0 );; 102 ; 103 // multiclass response; 104 const std::vector< Float_t >& EvaluateM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8h_source.html:3741,error,error,3741,doc/master/Reader_8h_source.html,https://root.cern,https://root.cern/doc/master/Reader_8h_source.html,1,['error'],['error']
Availability,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tFillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*GetBranch() const; TClass*GetClassType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*GetIconName() const; TList*GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TVirtualBranchBrowsable*GetParent() const; voidGetScope(TString& scope) const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:3289,error,error,3289,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,10,['error'],['error']
Availability,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); static Int_tTVirtualBranchBrowsable::FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TBranch*TVirtualBranchBrowsable::GetBranch() const; static Int_tGetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); TClass*TVirtualBranchBrowsable::GetClassType() const; const char*GetDraw() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TVirtualBranchBrowsable::GetIconName() const; TList*TVirtualBranchBrowsable::GetLeaves() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionPropertyBrowsable.html:3336,error,error,3336,root/html526/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionPropertyBrowsable.html,11,['error'],['error']
Availability,"able(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__THnSparseBrowsable.html:2097,error,error,2097,root/html532/ROOT__THnSparseBrowsable.html,https://root.cern,https://root.cern/root/html532/ROOT__THnSparseBrowsable.html,8,['error'],['error']
Availability,"able(const TMVA::Configurable&); TMVA::ConvergenceTestTMVA::ConvergenceTest::ConvergenceTest(); TMVA::ConvergenceTestTMVA::ConvergenceTest::ConvergenceTest(const TMVA::ConvergenceTest&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*TMVA::MethodANNBase::CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tTMVA::MethodANNBase::Debug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Float_tTMVA::ConvergenceTest::GetCurrentValue(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodMLP.html:2430,Error,Error,2430,root/html602/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodMLP.html,2,['Error'],['Error']
Availability,"able(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetBoostNum(); TMVA::Types::EBoostStageGetBoostStage(); const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; TMVA::IMethod*TMVA::MethodCompositeBase::GetCurrentMethod(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBoost.html:2520,error,error,2520,root/html528/TMVA__MethodBoost.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBoost.html,4,['error'],['error']
Availability,"able(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; Int_tGetClass(Int_t ivar) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; Double_tGetData(Int_t isel, Int_t ivar) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ET",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html:3618,error,error,3618,root/html528/TMVA__MethodCFMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN.html,6,['error'],['error']
Availability,"able(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; TMVA::IMethod*GetCurrentMethod(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCompositeBase.html:2568,error,error,2568,root/html528/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html,4,['error'],['error']
Availability,"able(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; TMVA::IMethod*TMVA::MethodCompositeBase::GetCurrentMethod(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCategory.html:2581,error,error,2581,root/html528/TMVA__MethodCategory.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCategory.html,4,['error'],['error']
Availability,"able(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt) const; const TMVA::Event*TMVA::MethodBase::GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&TMVA::MethodBase::GetEventCollec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html:2245,error,error,2245,root/html528/TMVA__MethodBayesClassifier.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBayesClassifier.html,34,['error'],['error']
Availability,"able(unsigned int ivar, const string& name, double val, double step, double lower, double upper); virtual boolROOT::Math::Minimizer::SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); voidROOT::Math::Minimizer::SetMaxFunctionCalls(unsigned int maxfcn); voidROOT::Math::Minimizer::SetMaxIterations(unsigned int maxiter); voidROOT::Math::Minimizer::SetOptions(const ROOT::Math::MinimizerOptions& opt); voidROOT::Math::Minimizer::SetPrecision(double prec); voidROOT::Math::Minimizer::SetPrintLevel(int level); voidROOT::Math::Minimizer::SetStrategy(int strategyLevel); voidROOT::Math::Minimizer::SetTolerance(double tol); virtual boolROOT::Math::Minimizer::SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); voidROOT::Math::Minimizer::SetValidError(bool on); virtual boolSetVariable(unsigned int, const string&, double, double); virtual boolROOT::Math::Minimizer::SetVariableInitialRange(unsigned int, double, double); virtual boolROOT::Math::Minimizer::SetVariableLimits(unsigned int ivar, double lower, double upper); virtual boolROOT::Math::Minimizer::SetVariableLowerLimit(unsigned int ivar, double lower); virtual boolROOT::Math::Minimizer::SetVariableStepSize(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableUpperLimit(unsigned int ivar, double upper); virtual boolROOT::Math::Minimizer::SetVariableValue(unsigned int ivar, double value); virtual boolROOT::Math::Minimizer::SetVariableValues(const double* x); virtual voidShowMembers(TMemberInspector&); intROOT::Math::Minimizer::Status() const; intROOT::Math::Minimizer::Strategy() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); doubleROOT::Math::Minimizer::Tolerance() const; virtual intROOT::Math::Minimizer::VariableIndex(const string& name) const; virtual stringROOT::Math::Minimizer::VariableName(unsigned int ivar) const; virtual const double*X() const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLinearMinimizer.html:5124,Toler,Tolerance,5124,root/html534/TLinearMinimizer.html,https://root.cern,https://root.cern/root/html534/TLinearMinimizer.html,1,['Toler'],['Tolerance']
Availability,"able, are more versatile because the names of the arguments are not hard coded. ; Definition at line 30 of file RooFormulaVar.h. Public Member Functions;  RooFormulaVar ();  ;  RooFormulaVar (const char *name, const char *title, const char *formula, const RooArgList &dependents, bool checkVariables=true);  Constructor with formula expression and list of input variables. ;  ;  RooFormulaVar (const char *name, const char *title, const RooArgList &dependents, bool checkVariables=true);  Constructor with formula expression, title and list of input variables. ;  ;  RooFormulaVar (const RooFormulaVar &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooFormulaVar () override;  ; std::list< double > * binBoundaries (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; TObject * clone (const char *newname) const override;  ; double defaultErrorLevel () const override;  Return the default error level for MINUIT error analysis If the formula contains one or more RooNLLVars and no RooChi2Vars, return the defaultErrorLevel() of RooNLLVar. ;  ; const RooArgList & dependents () const;  ; void doEval (RooFit::EvalContext &ctx) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; void dumpFormula ();  Dump the formula to stdout. ;  ; double evaluate () const override;  Calculate current value of object from internal formula. ;  ; const char * expression () const;  ; RooAbsArg * getParameter (const char *name) const;  Return pointer to parameter with given name. ;  ; RooAbsArg * getParameter (Int_t index) const;  Return pointer to parameter at given index. ;  ; TClass * IsA () const override;  ; size_t nParameters () const;  Return the number of parameters. ;  ; bool ok () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Forward the plot sampling hint from the p.d.f. that defines the observable obs. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFormulaVar.html:2841,error,error,2841,doc/master/classRooFormulaVar.html,https://root.cern,https://root.cern/doc/master/classRooFormulaVar.html,2,['error'],['error']
Availability,"able. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the system error string. ; This string will be used by GetError(). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno). ; Definition at line 245 of file TSystem.cxx. ◆ SetFlagsDebug(). void TSystem::SetFlagsDebug ; (; const char * ; flags). virtual . FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ; Definition at line 4056 of file TSystem.cxx. ◆ SetFlagsOpt(). void TSystem::SetFlagsOpt ; (; const char * ; flags). virtual . FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ; Definition at line 4065 of file TSystem.cxx. ◆ SetFPEMask(). Int_t TSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). virtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 642 of file TSystem.cxx. ◆ SetIncludePath(). void TSystem::SetIncludePath ; (; const char * ; includePath). virtual . IncludePath should contain the list of compiler flags to indicate where to find user defined header files. ; It is used to expand $IncludePath in the directives given to SetMakeSharedLib() and SetMakeExe(), e.g.: gSystem->SetInclude(""-I$ROOTSYS/include -Imydirectory/include"");; the default value of IncludePath on Unix is: ""-I$ROOTSYS/include ""; and on Windows: ""/I%ROOTSYS%/include "". Definition at line 4194 of file TSystem.cxx. ◆ SetLinkdefSuffix(). void TSystem::SetLinkdefSuffix ; (; const char * ; suffix). virtual . The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual additional linkdef information that ACLiC shoul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:85541,mask,mask,85541,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['mask'],['mask']
Availability,"able.Definition TSystem.cxx:3992; TSystem::Beepvoid Beep(Int_t freq=-1, Int_t duration=-1, Bool_t setDefault=kFALSE)Beep for duration milliseconds with a tone of frequency freq.Definition TSystem.cxx:324; TSystem::InControlBool_t InControl() constDefinition TSystem.h:367; TSystem::fBeepDurationInt_t fBeepDurationDefinition TSystem.h:288; TSystem::IgnoreInterruptvirtual void IgnoreInterrupt(Bool_t ignore=kTRUE)If ignore is true ignore the interrupt signal, else restore previous behaviour.Definition TSystem.cxx:602; TSystem::Syslogvirtual void Syslog(ELogLevel level, const char *mess)Send mess to syslog daemon.Definition TSystem.cxx:1686; TSystem::Symlinkvirtual int Symlink(const char *from, const char *to)Create a symbolic link from file1 to file2.Definition TSystem.cxx:1368; TSystem::SetAclicModevirtual void SetAclicMode(EAclicMode mode)AclicMode indicates whether the library should be built in debug mode or optimized.Definition TSystem.cxx:4077; TSystem::ResetErrnostatic void ResetErrno()Static function resetting system error number.Definition TSystem.cxx:284; TSystem::LoadAllLibrariesvirtual UInt_t LoadAllLibraries()Load all libraries known to ROOT via the rootmap system.Definition TSystem.cxx:1970; TSystem::GetDirPtrvirtual void * GetDirPtr() constDefinition TSystem.h:416; TSystem::SetObjExtvirtual void SetObjExt(const char *objExt)Set object files extension, should be either .o, .obj, etc.Definition TSystem.cxx:4244; TSystem::SetLinkdefSuffixvirtual void SetLinkdefSuffix(const char *suffix)The 'suffix' will be appended to the name of a script loaded by ACLiC and used to locate any eventual...Definition TSystem.cxx:4227; TSystem::fHelpersTSeqCollection * fHelpersDefinition TSystem.h:321; TSystem::ExpandPathNamevirtual Bool_t ExpandPathName(TString &path)Expand a pathname getting rid of special shell characters like ~.Definition TSystem.cxx:1274; TSystem::GetListOfStdExceptionHandlersvirtual TSeqCollection * GetListOfStdExceptionHandlers() constDefinition TSystem.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:39731,error,error,39731,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['error'],['error']
Availability,"able; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGVerticalFrame*fCenterFrameparent frame for distortion center; TEveGValuator*fCenterXcenter x value widget; TEveGValuator*fCenterYcenter y value widget; TEveGValuator*fCenterZcenter z value widget; TGClient*TGObject::fClientConnection to display server; TEveGValuator*fCurrentDepthTEveProjection z-coordinate widget; Int_tTGFrame::fDNDStateEDNDFlags; TEveGValuator*fDistortionTEveProjection distortion widget; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TEveGValuator*fFixRTEveProjection fixed-radius widget; TEveGValuator*fFixZTEveProjection fixed-z widget; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveProjectionManager*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; TEveGValuator*fMaxTrackStepTEveProjection relative scale after FixZ; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveProjectionManagerEditor.html:17865,mask,mask,17865,root/html528/TEveProjectionManagerEditor.html,https://root.cern,https://root.cern/root/html528/TEveProjectionManagerEditor.html,6,['mask'],['mask']
Availability,"ableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Pixel_tTGFrame::fBackgroundframe background color; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TGHorizontalFrame*fBotFrameBottom horizontal frame; TBrowser*TBrowserImp::fBrowserTBrowser associated with this implementation; const TGPicture*fCachedPicCached picture; TStringfCachedPicNameCached picture name; TGCanvas*fCanvasCanvas for the list tree; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; Long_tfCntCounters for keys inside a Root file; TContextMenu*fContextMenupointer to context menu; TGListTreeItem*fCurrentDirCurrent (list tree) directory; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; Bool_tfDblClickkTRUE if user double-clicked on a list tree item; TSystemDirectory*fDirActual (selected) system directory; TGComboBox*fDrawOptionDraw options combobox; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TSystemFile*fFileActual (selected) system file; const TGPicture*fFileIconSystem files icon; TGComboBox*fFileTypeFile type combobox; TRegexp*fFilterRegular expression used to filter files; TGPictureButton*fFilterButton""Filter"" button ; TStringfFilterStrFilter expression string; map<TGListTreeItem*,const char*>fFilteredItemsList of filtered list-tree items.; Int_tfGroupSizetotal number of items when icon box switched to ""global view"" mode; Bool_tfGroupedkTRUE if Root file content (keys) is grouped; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGFileBrowser.html:21163,mask,mask,21163,root/html532/TGFileBrowser.html,https://root.cern,https://root.cern/root/html532/TGFileBrowser.html,4,['mask'],['mask']
Availability,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCompound.html:4661,error,error,4661,root/html528/TEveCompound.html,https://root.cern,https://root.cern/root/html528/TEveCompound.html,10,['error'],['error']
Availability,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveCompound::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCompoundProjected.html:4656,error,error,4656,root/html528/TEveCompoundProjected.html,https://root.cern,https://root.cern/root/html528/TEveCompoundProjected.html,10,['error'],['error']
Availability,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); static Int_tFindConvexHull(const TEveShape::vVector2_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveShape.html:5287,error,error,5287,root/html528/TEveShape.html,https://root.cern,https://root.cern/root/html528/TEveShape.html,10,['error'],['error']
Availability,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); static Int_tTEveShape::FindConvexHull(const TEveShape:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveBox.html:5337,error,error,5337,root/html528/TEveBox.html,https://root.cern,https://root.cern/root/html528/TEveBox.html,60,['error'],['error']
Availability,"ableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCalo2D.html:5089,error,error,5089,root/html528/TEveCalo2D.html,https://root.cern,https://root.cern/root/html528/TEveCalo2D.html,170,['error'],['error']
Availability,"able_t ; id, . GContext_t ; gc, . Segment_t * ; seg, . Int_t ; nseg . ). virtual . Draws multiple line segments. ; Each line is specified by a pair of points.; Parameters. [in]idDrawable identifier ; [in]gcgraphics context ; [in]*segspecifies an array of segments ; [in]nsegspecifies the number of segments in the array. GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, and dash-list. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1935 of file TVirtualX.cxx. ◆ DrawString(). void TVirtualX::DrawString ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . const char * ; s, . Int_t ; len . ). virtual . Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ; Parameters. [in]idthe drawable ; [in]gcthe GC ; [in]x,ycoordinates, which are relative to the origin of the specified drawable and define the origin of the first character ; [in]sthe character string ; [in]lenthe number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, and tile-stipple-y-origin. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1808 of file TVirtualX.cxx. ◆ DrawText() [1/2]. void TVirtualX::DrawText ; (; Int_t ; x, . Int_t ; y, . Float_t ; angle, . Float_t ; mgn, . const char * ; text, . ETextMode ; mode . ). virtual . Draws a text string using current font. ; Parameters. [in]x,ytext position ; [in]angletext angle ; [in]mgnmagnifi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:75359,mask,mask,75359,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['mask'],['mask']
Availability,"ables_t>fgGeneratorslist of MethodCreateListOfBrowsables_t called by CreateListOfBrowsables; static Bool_tfgGeneratorsSethave we set the generators yet? empty is not good enough - user might have removed them. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualBranchBrowsable(const TBranch* b, TClass* type, Bool_t typeIsPointer, const TVirtualBranchBrowsable* parent = 0); constructor setting all members according to parameters. ~TVirtualBranchBrowsable(); Destructor. Delete our leaves. void Browse(TBrowser* b); Calls TTree::Draw on the method if return type is not a class;; otherwise expands returned object's ""folder"". Int_t FillListOfBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); Askes all registered generators to fill their browsables into; the list. The browsables are generated for a given parent,; or (if 0), for a given branch. The branch is passed down to; leaves of TVirtualBranchBrowsable, too, as we need to access; the branch's TTree to be able to traw. TClass* GetCollectionContainedType(const TBranch* b, const TVirtualBranchBrowsable* parent, TClass*& contained); Check whether the branch (or the parent) contains a collection.; If it does, set ""contained"" to the contained type (if we can; retrieve it) and return the TClass for the collection. Set; ""contained"" to the branch's (or parent's) contained object's; class for non-collections, returning 0. Only one of ""branch"" or ""parent"" can ge given (depending on whether; we are creating browsable objects for a branch or for another; browsable object). TList* GetLeaves() const; Return list of leaves. If not set up yet we'll create them. void GetScope(TString& scope) const; Returns the full name for TTree::Draw to draw *this.; Recursively appends, starting at the top TBranch,; all method / object names with proper reference operators (->, .); depending on fTypeIsPointer. void RegisterDefaultGenerators(); Adds the default genera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:9520,down,down,9520,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,6,['down'],['down']
Availability,"abold(n);; 1083 for (i = 0; i < n; i++); 1084 labold[i] = nullptr;; 1085 TIter nextold(labels);; 1086 TObject *obj;; 1087 while ((obj=nextold())) {; 1088 Int_t bin = obj->GetUniqueID();; 1089 R__ASSERT(bin <= n);; 1090 labold[bin - 1] = obj;; 1091 }; 1092 // order now labold according to bin content; 1093 ; 1094 labels->Clear();; 1095 if (sort > 0) {; 1096 //---sort by values of bins; 1097 for (i=1;i<=n;i++) {; 1098 a[i-1] = i-1;; 1099 sumw[i-1] = fArray[i];; 1100 errors[i-1] = fSumw2.fArray[i];; 1101 ent[i-1] = fBinEntries.fArray[i];; 1102 if (fBinSumw2.fN) binsw2[i - 1] = fBinSumw2.fArray[i];; 1103 if (fBinEntries.fArray[i] == 0) cont[i-1] = 0;; 1104 else cont[i-1] = fArray[i]/fBinEntries.fArray[i];; 1105 }; 1106 if (sort ==1); 1107 TMath::Sort(n,cont.data(),a.data(),kTRUE); //sort by decreasing values; 1108 else; 1109 TMath::Sort(n,cont.data(),a.data(),kFALSE); //sort by increasing values; 1110 for (i=1;i<=n;i++) {; 1111 fArray[i] = sumw[a[i-1]];; 1112 fSumw2.fArray[i] = errors[a[i-1]];; 1113 fBinEntries.fArray[i] = ent[a[i-1]];; 1114 if (fBinSumw2.fN); 1115 fBinSumw2.fArray[i] = binsw2[a[i-1]];; 1116 }; 1117 for (i=0 ;i < n; i++) {; 1118 obj = labold[a[i]];; 1119 labels->Add(obj);; 1120 obj->SetUniqueID(i+1);; 1121 }; 1122 } else {; 1123 ; 1124 //---alphabetic sort; 1125 // sort labels using vector of strings and TMath::Sort; 1126 // I need to array because labels order in list is not necessary that of the bins; 1127 std::vector<std::string> vecLabels(n);; 1128 for (i = 0; i < n; i++) {; 1129 vecLabels[i] = labold[i]->GetName();; 1130 a[i] = i;; 1131 sumw[i] = fArray[i+1];; 1132 errors[i] = fSumw2.fArray[i+1];; 1133 ent[i] = fBinEntries.fArray[i+1];; 1134 if (fBinSumw2.fN); 1135 binsw2[i] = fBinSumw2.fArray[i+1];; 1136 }; 1137 // sort in ascending order for strings; 1138 TMath::Sort(n, vecLabels.data(), a.data(), kFALSE);; 1139 // set the new labels; 1140 for (i = 0; i < n; i++) {; 1141 TObject *labelObj = labold[a[i]];; 1142 labels->Add(labelObj);; 1143 // set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:40908,error,errors,40908,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['errors']
Availability,"according to chosen configurationDefinition FitConfig.cxx:173; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::fMinosErrorsbool fMinosErrorsdo full error analysis using MinosDefinition FitConfig.h:261; ROOT::Fit::FitConfig::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)static function to control default minimizer type and algorithmDefinition FitConfig.cxx:252; ROOT::Fit::FitConfig::SetFromFitResultvoid SetFromFitResult(const FitResult &rhs)Definition FitConfig.cxx:80; ROOT::Fit::FitConfig::CreateParamsSettingsvoid CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl< T > &func)set the parameter settings from a model function.Definition FitConfig.h:109; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer packageDefinition FitConfig.h:187; ROOT::Fit::FitConfig::fWeightCorrbool fWeightCorrapply correction to errors for weights fitsDefinition FitConfig.h:263; ROOT::Fit::FitConfig::ParSettingsconst ParameterSettings & ParSettings(unsigned int i) constget the parameter settings for the i-th parameter (const method)Definition FitConfig.h:76; ROOT::Fit::FitConfig::fUpdateAfterFitbool fUpdateAfterFitupdate the configuration after a fit using the resultDefinition FitConfig.h:262; ROOT::Fit::FitConfig::operator=FitConfig & operator=(const FitConfig &rhs)Definition FitConfig.cxx:62; ROOT::Fit::FitConfig::MinimizerOptionsROOT::Math::MinimizerOptions & MinimizerOptions()access to the minimizer control parameter (non const method)Definition FitConfig.h:167; ROOT::Fit::FitConfig::MinosErrorsbool MinosErrors() constdo minos errors analysis on the parametersDefinition FitConfig.h:208; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::ParameterSettingsClass, describing value, limits a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8h_source.html:15145,error,errors,15145,doc/master/FitConfig_8h_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html,1,['error'],['errors']
Availability,"according to fSumErrorsMode. ;  ; virtual Double_t * GetEYlow (Int_t e);  Get all low errors e on y coordinates as an array. ;  ; virtual Color_t GetFillColor () const;  Return the fill area color. ;  ; virtual Color_t GetFillColor (Int_t e) const;  Get Fill Color for specified error e (-1 = Global and x errors). ;  ; virtual Style_t GetFillStyle () const;  Return the fill area style. ;  ; virtual Style_t GetFillStyle (Int_t e) const;  Get Fill Style for specified error e (-1 = Global and x errors). ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Color_t GetLineColor (Int_t e) const;  Get Line Color for specified error e (-1 = Global and x errors). ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Style_t GetLineStyle (Int_t e) const;  Get Line Style for specified error e (-1 = Global and x errors). ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual Width_t GetLineWidth (Int_t e) const;  Get Line Width for specified error e (-1 = Global and x errors). ;  ; Int_t GetNYErrors () const;  ; Int_t GetSumErrorsMode () const;  ; TClass * IsA () const override;  ; TGraphMultiErrors & operator= (const TGraphMultiErrors &tgme);  TGraphMultiErrors assignment operator. ;  ; void Print (Option_t *chopt="""") const override;  Print graph and errors values. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; void Scale (Double_t c1=1., Option_t *option=""y"") override;  Multiply the values and errors of a TGraphMultiErrors by a constant c1. ;  ; virtual void SetAttFill (Int_t e, TAttFill *taf);  Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors). ;  ; virtual void SetAttLine (Int_t e, TAttLine *tal);  Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors). ;  ; virtual void SetEY (Int_t e, Int_t np, const Double_t *eyL, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:12761,error,error,12761,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,2,['error'],"['error', 'errors']"
Availability,"ace to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  ;  Protected Member Functions inherited from TGWidget;  TGWidget (const TGWidget &tgw);  ; Int_t ClearFlags (Int_t flags);  ; TGWidget & operator= (const TGWidget &tgw);  ; Int_t SetFlags (Int_t flags);  . Protected Attributes; Int_t fXp;  horizontal slider x position in pixel coordinates ;  ;  Protected Attributes inherited from TGDoubleSlider; Bool_t fMarkEnds;  lines marking where stretch zones begin ;  ; Int_t fMove;  1: move min value 2: move max value 3: move min and max value 0: don't move any value ;  ; Double_t fPos;  logical position between fVmin and fVmax ;  ; Int_t fPressPoint;  mouse position at button press event ;  ; Double_t fPressSmax;  logical max position at button press event ;  ; Double_t fPressSmin;  logical min position at button press event ;  ; Int_t fRelPos;  slider position in pixel coordinates ;  ; Bool_t fReversedScale;  reverse which end is min and max ;  ; Int_t fScale;  tick mark scale ;  ; Int_t fScaleType;  tick mark scale type (no, downright, both) ;  ; const TGPicture * fSliderPic;  picture to draw slider ends ;  ; Double_t fSmax;  logical position of max value of Slider ;  ; Double_t fSmin;  logical position of min value of Slider ;  ; Double_t fVmax;  logical upper limit of slider ;  ; Double_t fVmin;  logical lower limit of slider ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDoubleHSlider.html:27173,down,downright,27173,doc/master/classTGDoubleHSlider.html,https://root.cern,https://root.cern/doc/master/classTGDoubleHSlider.html,1,['down'],['downright']
Availability,"ace"" the entire; 4294 // streaming of this STL container if the container; 4295 // is a set/multiset/map/multimap (what we do not; 4296 // know here).; 4297 // For vector/list/deque Allocate == Resize; 4298 // and Commit == noop.; 4299 // TODO: Exception safety a la TPushPop; 4300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split this stuff, so we need to create the pointers; 4334 /////////////////////////////////////////////////////////////////////////////; 4335 ; 4336 if( proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ); 4337 {; 4338 TClass *elClass = proxy->GetValueClass();; 4339 ; 4340 //--------------------------------------------------------------------; 4341 // The allocation is done in this strange way because ReadLeaves; 4342 // is being called many times by TTreeFormula!!!; 4343 ///////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:159934,failure,failure,159934,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['failure'],['failure']
Availability,"ace& w); RooStudyManager(const char* studyPackFileName); RooStudyManager(RooWorkspace& w, RooAbsStudy& study); ~RooStudyManager(); voidTObject::AbstractMethod(const char* method) const; voidaddStudy(RooAbsStudy& study); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; static voidcloseProof(Option_t* option = ""s""); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStudyManager.html:1513,Error,Error,1513,root/html532/RooStudyManager.html,https://root.cern,https://root.cern/root/html532/RooStudyManager.html,2,['Error'],['Error']
Availability,"ace& w, RooAbsStudy& study); ~RooStudyManager(); voidTObject::AbstractMethod(const char* method) const; voidaddStudy(RooAbsStudy& study); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStudyManager.html:1595,error,error,1595,root/html526/RooStudyManager.html,https://root.cern,https://root.cern/root/html526/RooStudyManager.html,2,['error'],['error']
Availability,"ace. list<TObject*> allGenericObjects() const; Return list of all generic objects in the workspace. Bool_t makeDir(); Create transient TDirectory representation of this workspace. This directory; will appear as a subdirectory of the directory that contains the workspace; and will have the name of the workspace suffixed with ""Dir"". The TDirectory; interface is read-only. Any attempt to insert objects into the workspace; directory representation will result in an error message. Note that some; ROOT object like TH1 automatically insert themselves into the current directory; when constructed. This will give error messages when done in a workspace; directory. Bool_t import(TObject& object, Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container. Imported; object can be retrieved by name through the obj() method. The object is cloned upon; importation and the input argument does not need to live beyond the import call. Returns kTRUE if an error has occurred. Bool_t import(TObject& object, const char* aliasName, Bool_t replaceExisting = kFALSE); Import a clone of a generic TObject into workspace generic object container.; The imported object will be stored under the given alias name rather than its; own name. Imported object can be retrieved its alias name through the obj() method.; The object is cloned upon importation and the input argument does not need to live beyond the import call; This method is mostly useful for importing objects that do not have a settable name such as TMatrix. Returns kTRUE if an error has occurred. Bool_t addStudy(RooAbsStudy& study); Insert RooStudyManager module. void clearStudies(); Remove all RooStudyManager modules. TObject* obj(const char* name) const; Return any type of object (RooAbsArg, RooAbsData or generic object) with given name). TObject* genobj(const char* name) const; Return generic object with given name. Bool_t cd(const char* path = 0). Bool_t writeToFile(const char* fileName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace.html:20284,error,error,20284,root/html526/RooWorkspace.html,https://root.cern,https://root.cern/root/html526/RooWorkspace.html,11,['error'],['error']
Availability,"aceFactoryFast;  CHistRefInternal class wrapping an histogram and managing its content ;  CLinInterpVarRooAbsReal that does piecewise-linear interpolations ;  CMeasurementThe RooStats::HistFactory::Measurement class can be used to construct a model by combining multiple RooStats::HistFactory::Channel objects ;  CNormFactorConfiguration for an un- constrained overall systematic to scale sample normalisations ;  COverallSysConfiguration for a constrained overall systematic to scale sample normalisations ;  CPreprocessFunction;  ►CRooBarlowBeestonLLClass RooBarlowBeestonLL implements the profile likelihood estimator for a given likelihood and set of parameters of interest ;  CBarlowCache;  CSample;  CShapeFactorUnconstrained bin-by-bin variation of affected histogram ;  CShapeSysConstrained bin-by-bin variation of affected histogram ;  CStatErrorStatistical error of Monte Carlo predictions ;  CStatErrorConfigConfiguration to automatically assign nuisance parameters for the statistical error of the Monte Carlo simulations ;  CAcceptanceRegion;  CAsymptoticCalculatorHypothesis Test Calculator based on the asymptotic formulae for the profile likelihood ratio ;  CBayesianCalculatorBayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregatorThis class is designed to aid in the construction of RooDataSets and RooArgSets, particularly those naturally arising in fitting opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:6547,error,error,6547,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['error'],['error']
Availability,"aceFactoryFast;  CHistRefInternal class wrapping an histogram and managing its content ;  CLinInterpVarRooAbsReal that does piecewise-linear interpolations ;  CMeasurementThe RooStats::HistFactory::Measurement class can be used to construct a model by combining multiple RooStats::HistFactory::Channel objects ;  CNormFactorConfiguration for an un- constrained overall systematic to scale sample normalisations ;  COverallSysConfiguration for a constrained overall systematic to scale sample normalisations ;  CPreprocessFunction;  ►CRooBarlowBeestonLLClass RooBarlowBeestonLL implements the profile likelihood estimator for a given likelihood and set of parameters of interest ;  CBarlowCache;  CSample;  CShapeFactorUnconstrained bin-by-bin variation of affected histogram ;  CShapeSysConstrained bin-by-bin variation of affected histogram ;  CStatErrorStatistical error of Monte Carlo predictions ;  CStatErrorConfigConfiguration to automatically assign nuisance parameters for the statistical error of the Monte Carlo simulations ;  NNumberCountingUtils;  CAcceptanceRegion;  CAsymptoticCalculatorHypothesis Test Calculator based on the asymptotic formulae for the profile likelihood ratio ;  CBayesianCalculatorBayesianCalculator is a concrete implementation of IntervalCalculator, providing the computation of a credible interval using a Bayesian method ;  CBernsteinCorrectionBernsteinCorrection is a utility in RooStats to augment a nominal PDF with a polynomial correction term ;  CCombinedCalculatorCombinedCalculator is an interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals ;  CConfidenceBeltConfidenceBelt is a concrete implementation of the ConfInterval interface ;  CConfIntervalConfInterval is an interface class for a generic interval in the RooStats framework ;  CDebuggingSampler;  CDebuggingTestStat;  CDetailedOutputAggregatorThis class is designed to aid in the construction of RooDataSets and RooArgSets, particularly those naturally a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/namespaces.html:9424,error,error,9424,doc/v616/namespaces.html,https://root.cern,https://root.cern/doc/v616/namespaces.html,1,['error'],['error']
Availability,"ace_Binding.h:15; ROOT::Internal::THnBaseBinIterIterator over THnBase bins (internal implementation).Definition THnBase.h:315; ROOT::Internal::THnBaseBinIter::GetCoordvirtual Int_t GetCoord(Int_t dim) const =0; ROOT::Internal::THnBaseBinIter::Nextvirtual Long64_t Next(Int_t *coord=nullptr)=0; TAxisClass to manage histogram axis.Definition TAxis.h:31; TAxis::kAxisRange@ kAxisRangeDefinition TAxis.h:65; TAxis::GetLastInt_t GetLast() constReturn last bin on the axis i.e.Definition TAxis.cxx:469; TAxis::GetNbinsInt_t GetNbins() constDefinition TAxis.h:125; TAxis::GetFirstInt_t GetFirst() constReturn first bin on the axis i.e.Definition TAxis.cxx:458; THnBaseMultidimensional histogram base.Definition THnBase.h:43; THnBase::GetListOfAxesTObjArray * GetListOfAxes()Definition THnBase.h:128; THnBase::GetNdimensionsInt_t GetNdimensions() constDefinition THnBase.h:140; THnBase::GetCalculateErrorsBool_t GetCalculateErrors() constDefinition THnBase.h:141; THnBase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnMultidimensional histogram.Definition THn.h:30; THn::AllocCoordBufvoid AllocCoordBuf() constCreate the coordinate buffer.Definition THn.cxx:232; THn::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THn.cxx:240; THn::~THn~THn() overrideDestruct a THn.Definition THn.cxx:199; THn::fCoordBufstd::vector< Int_t > fCoordBufDefinition THn.h:181; THn::fSumw2TNDArrayT< Double_t > fSumw2Definition THn.h:180; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8cxx_source.html:11655,error,errors,11655,doc/master/THn_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html,1,['error'],['errors']
Availability,"ach bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:25339,error,error,25339,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['error'],['error']
Availability,"ache(). void TProof::ClearDataSetCache ; (; const char * ; dataset = 0). virtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented in TProofLite.; Definition at line 10896 of file TProof.cxx. ◆ ClearFeedback(). void TProof::ClearFeedback ; (; ). Clear feedback list. ; Definition at line 10012 of file TProof.cxx. ◆ ClearInput(). void TProof::ClearInput ; (; ). Clear input object list. ; Definition at line 9742 of file TProof.cxx. ◆ ClearInputData() [1/2]. void TProof::ClearInputData ; (; const char * ; name). Remove obj 'name' form the input data list;. ; Definition at line 9572 of file TProof.cxx. ◆ ClearInputData() [2/2]. void TProof::ClearInputData ; (; TObject * ; obj = 0). Remove obj form the input data list; if obj is null (default), clear the input data info. ; Definition at line 9538 of file TProof.cxx. ◆ ClearPackage(). Int_t TProof::ClearPackage ; (; const char * ; package). Remove a specific package. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 7857 of file TProof.cxx. ◆ ClearPackages(). Int_t TProof::ClearPackages ; (; ). Remove all packages. ; Returns 0 in case of success and -1 in case of error. ; Definition at line 7840 of file TProof.cxx. ◆ Close(). void TProof::Close ; (; Option_t * ; opt = """"). Close all open slave servers. ; Client can decide to shutdown the remote session by passing option is 'S' or 's'. Default for clients is detach, if supported. Masters always shutdown the remote counterpart. ; Definition at line 1798 of file TProof.cxx. ◆ CloseProgressDialog(). void TProof::CloseProgressDialog ; (; ). Close progress dialog. ; Definition at line 9283 of file TProof.cxx. ◆ Collect() [1/4]. Int_t TProof::Collect ; (; const TSlave * ; sl, . Long_t ; timeout = -1, . Int_t ; endtype = -1, . Bool_t ; deactonfail = kFALSE . ). private . Collect responses from slave sl. ; Returns the number of slaves that responded (=1). If timeout >= 0, wait at most timeout seconds (timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:76233,error,error,76233,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,"acheCheck(Bool_t flag); Activate cache validation mode. Int_t getMaxVal(const RooArgSet& vars) const; Advertise capability to determine maximum value of function for given set of; observables. If no direct generator method is provided, this information; will assist the accept/reject generator to operate more efficiently as; it can skip the initial trial sampling phase to empirically find the function; maximum. Double_t maxVal(Int_t code) const; Return maximum value for set of observables identified by code assigned; in getMaxVal. void logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString = 0); Interface to insert remote error logging messages received by RooRealMPFE into current error loggin stream. void logEvalError(const char* message, const char* serverValueString = 0) const; Log evaluation error message. Evaluation errors may be routed through a different; protocol than generic RooFit warning message (which go straight through RooMsgService); because evaluation errors can occur in very large numbers in the use of likelihood; evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); messages reported through this function are not printed but all stored in a list,; along with server values at the time of reporting. Error messages logged in this; way can be printed in a structured way, eliminating duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:61580,error,errors,61580,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,20,['error'],['errors']
Availability,"acheReadCalls(Int_t reads); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidTFileCacheRead::Close(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDisable(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidEnable(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; virtual Long64_tTFileCacheRead::GetBytesRead() const; virtual Long64_tTFileCacheRead::GetBytesReadExtra() const; const TObjArray*GetCachedBranches() const; TTreeCache::EPrefillTypeGetConfiguredPrefillType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual Int_tGetEntryMax() const; virtual Int_tGetEntryMin() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:10621,Error,Error,10621,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['Error'],['Error']
Availability,"acheableDefinition TDictionary.h:87; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnumConstant.h; TEnum.h; TEnv.h; kEnvUser@ kEnvUserDefinition TEnv.h:71; kEnvGlobal@ kEnvGlobalDefinition TEnv.h:70; kEnvLocal@ kEnvLocalDefinition TEnv.h:72; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; kWarningconstexpr Int_t kWarningDefinition TError.h:46; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; TFunctionTemplate.h; N#define N; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; cursorOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t cursorDefinition TGWin32VirtualXProxy.cxx:160; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:387372,error,error,387372,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"ack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tTParticle::Beauty() const; virtual voidTObject::Browse(TBrowser* b); Int_tTParticle::Charm() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTParticle::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; Double_tTParticle::Energy() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTParticle::Eta() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTParticle::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTParticle::GetCalcMass() const; Int_tTParticle::GetDaughter(Int_t i) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTParticle::GetFirstDaughter() const; Int_tTParticle::GetFirstMother() const; virtual const char*TObject::GetIconName() const; Int_tTParticle::GetLastDaughter() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveMCTrack.html:1411,Error,Error,1411,root/html532/TEveMCTrack.html,https://root.cern,https://root.cern/root/html532/TEveMCTrack.html,4,['Error'],['Error']
Availability,"acked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), so triggering a full; re-build. The option if effective only for PROOF protocol > 8 .; The lab 'dirlab' (e.g. 'G0') indicates that the package is to uploaded to; an alternative global directory for global usage. This may require special; privileges.; If download is kTRUE and the package is not found locally, then it is downloaded; from the master repository.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; Additional files to be uploaded (or updated, if needed) can be specified; after a comma, e.g. ""mymacro.C+,thisheader.h,thatheader.h"".; If existing in the same directory, a header basename(macro).h or .hh, is also; uploaded.; The default is to load the macro also on the client; notOnClient can be used; to avoid loading on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:68191,error,error,68191,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,9,['error'],['error']
Availability,"acked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), so triggering a full; re-build. The option if effective only for PROOF protocol > 8 .; The lab 'dirlab' (e.g. 'G0') indicates that the package is to uploaded to; an alternative global directory for global usage. This may require special; privileges.; If download is kTRUE and the package is not found locally, then it is downloaded; from the master repository.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackageOnClient(const char* package, TProof::EUploadPackageOpt opt, TMD5* md5); Upload a package on the client in ~/.proof/packages.; The 'opt' allows to specify whether the .PAR should be just unpacked; in the existing dir (opt = kUntar, default) or a remove of the existing; directory should be executed (opt = kRemoveOld), thereby triggering a full; re-build. This option if effective only for PROOF protocol > 8.; Returns 0 in case of success and -1 in case of error. Int_t Load(const char* macro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Load the specified macro on master, workers and, if notOnClient is; kFALSE, on the client. The macro file is uploaded if new or updated.; If existing, the corresponding header basename(macro).h or .hh, is also; uploaded. The default is to load the macro also on the client.; On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers; only, and collection is not done; if uniqueWorkers is kFALSE, collection; from the previous request is done, and broadcasting + collection from the; other workers is done.; The wrks arg can be used on the master to limit the set of workers.; Returns 0 in case of success and -1 in case of error. Int_t AddDynamicPath(const char* libpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'libpath' to the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:67642,error,error,67642,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['error'],['error']
Availability,"ackground color of headers. void SetOddRowBackground(Pixel_t pixel); Set the background color for all odd numbered rows. void SetEvenRowBackground(Pixel_t pixel); Set the background color for all even numbered rows. void SetHeaderBackground(Pixel_t pixel); Set the background color for the headers. void SetDefaultColors(); Set the background color for all rows and headers to their defaults. void MoveTable(Int_t rows, Int_t columns); Move and layout the table to the specified range. void GotoTableRange(Int_t xtl, Int_t ytl, Int_t xbr, Int_t ybr); Move and resize the table to the specified range. TGTableCell * operator()(UInt_t row, UInt_t column); Operator for easy cell acces. void ScrollCHeaders(Int_t xpos); Scroll the column headers horizontally. void ScrollRHeaders(Int_t ypos); Scroll the row headers vertically. void NextChunk(); Move the table to the next chunk of the data set with the same size. void PreviousChunk(); Move the table to the previous chunk of the data set with the same size. void Goto(); Slot used by the Goto button and whenever return is pressed in; on of the text entries in the range frame. void UserRangeChange(); Slot used when the text in one of the range frame text entries changes. void Update(); Update the range of the available data and refresh the current view. TGTable(const TGWindow* p = 0, Int_t id = 0, TVirtualTableInterface* interface = 0, UInt_t nrows = 50, UInt_t ncolumns = 20). TVirtualTableInterface * GetInterface(); { return fInterface; }. TGCanvas * GetCanvas(); { return fCanvas; }. const TGTableHeaderFrame * GetRHdrFrame(); { return fRHdrFrame; }. const TGTableHeaderFrame * GetCHdrFrame(); { return fCHdrFrame; }. » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 2 15:57:29 2015 » Last generated: 2015-06-02 15:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTable.html:32244,avail,available,32244,root/html604/TGTable.html,https://root.cern,https://root.cern/root/html604/TGTable.html,2,['avail'],['available']
Availability,"acks class; TGeoTransientPanel List-Tree based dialog; TGeoTranslation translation class; TGeoTranslationEditor TGeoTranslation editor; TGeoTrap G3 TRAP shape; TGeoTrapEditor TGeoTrap editor; TGeoTrd1 TRD1 shape class; TGeoTrd1Editor TGeoTrd1 editor; TGeoTrd2 TRD2 shape class; TGeoTrd2Editor TGeoTrd2 editor; TGeoTreeDialog List-Tree based dialog; TGeoTube cylindrical tube class; TGeoTubeEditor TGeoTube editor; TGeoTubeSeg cylindrical tube segment class ; TGeoTubeSegEditor TGeoTubeSeg editor; TGeoUniformMagField Uniform magnetic field ; TGeoUnion union node; TGeoVolume geometry volume descriptor; TGeoVolumeAssembly an assembly of volumes; TGeoVolumeDialog List-Tree based volume dialog; TGeoVolumeEditor TGeoVolume editor; TGeoVolumeMulti class to handle multiple volumes in one step; TGeoVoxelFinder voxel finder class; TGeoXtru extruded polygon class ; TGeometry Structure for Matrices, Shapes and Nodes; TGlobal Global variable class; TGondzioSolver Gondzio Qp Solver class; TGraph Graph graphics class; TGraph2D Set of n x[i],y[i],z[i] points with 3-d graphics including Delaunay triangulation; TGraph2DErrors A 2D graph with error bars; TGraph2DPainter TGraph2D painter; TGraphAsymmErrors A graph with asymmetric error bars; TGraphBentErrors A graph with bent, asymmetric error bars; TGraphDelaunay Delaunay triangulation; TGraphEditor graph editor; TGraphErrors A graph with error bars; TGraphPainter TGraph painter; TGraphPolar Polar graph; TGraphPolargram Polar axis; TGraphQQ to create and to draw quantile-quantile plots; TGraphSmooth Graph Smoother; TGrid ABC defining interface to GRID services; TGridCollection ABC managing collection of files on the Grid; TGridJDL ABC defining interface JDL generator; TGridJob ABC defining interface to a GRID job; TGridJobStatus ABC defining status of a Grid job; TGridJobStatusList ABC defining interface to a list of GRID jobs; TGridResult ABC defining interface to GRID result set; TGroupButton A user interface button in a group of buttons.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:86447,error,error,86447,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,4,['error'],['error']
Availability,"acro::Checksum ; (; ). virtual . Returns checksum of the current content. ; The returned TMD5 object must be deleted by the user. Returns 0 in case of error. ; Definition at line 192 of file TMacro.cxx. ◆ Class(). static TClass * TMacro::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMacro::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMacro::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 59 of file TMacro.h. ◆ DeclFileName(). static const char * TMacro::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 59 of file TMacro.h. ◆ Exec(). Longptr_t TMacro::Exec ; (; const char * ; params = nullptr, . Int_t * ; error = nullptr . ). virtual . Execute this macro with params, if params is 0, default parameters (set via SetParams) are used. ; error is set to an TInterpreter::EErrorCode by TApplication::ProcessLine(). Returns the result of the macro (return value or value of the last expression), cast to a Long_t. ; Reimplemented in TEveMacro.; Definition at line 262 of file TMacro.cxx. ◆ GetLineWith(). TObjString * TMacro::GetLineWith ; (; const char * ; text); const. virtual . Search the first line containing text. ; Definition at line 297 of file TMacro.cxx. ◆ GetListOfLines(). TList * TMacro::GetListOfLines ; (; ); const. inline . Definition at line 51 of file TMacro.h. ◆ IsA(). TClass * TMacro::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 59 of file TMacro.h. ◆ Load(). Bool_t TMacro::Load ; (; ); const. virtual . Load the macro into the interpreter. ; Return true in case the loading was successful. ; Definition at line 244 of file TMacro.cxx. ◆ operator=(). TMacro & TMacro::operator= ; (; const TMacro & ; macro). Copy constructor. ; Definition at line 120 of file TMacr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMacro.html:17697,error,error,17697,doc/master/classTMacro.html,https://root.cern,https://root.cern/doc/master/classTMacro.html,1,['error'],['error']
Availability,"act = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual voidDistFromOutside_v(const Double_t* points, const Double_t* dirs, Double_t* dists, Int_t vecsize, Double_t* step) const; static Double_tTGeoShape::DistToPhiMin(const Double_t* point, const Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToPlane(const Double_t* point, const Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetClosestEdge(const Double_t* point, Double_t* vert, Int_t& isegment) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; Double_tGetDz() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoArb8.html:4235,error,error,4235,root/html534/TGeoArb8.html,https://root.cern,https://root.cern/root/html534/TGeoArb8.html,6,['error'],['error']
Availability,"actBinCoord * GetCompactCoord() constReturn THnSparseCompactBinCoord object.Definition THnSparse.cxx:838; THnSparse::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THnSparse.cxx:646; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const TH1 *h1, Int_t chunkSize=1024 *16)Definition THnSparse.h:77; THnSparse::GetBinError2Double_t GetBinError2(Long64_t linidx) const overrideGet square of the error of bin addressed by linidx as If errors are not enabled (via Sumw2() or Calc...Definition THnSparse.cxx:771; THnSparse::THnSparseTHnSparse(const THnSparse &)=delete; THnSparse::THnSparseTHnSparse()Construct an empty THnSparse.Definition THnSparse.cxx:589; THnSparse::AddChunkTHnSparseArrayChunk * AddChunk()Create a new chunk of bin content.Definition THnSparse.cxx:634; THnSparse::GenerateArrayvirtual TArray * GenerateArray() const =0; THnSparse::SetBinError2void SetBinError2(Long64_t bin, Double_t e2) overrideSet error of bin with index ""bin"" to ""e"", enable errors if needed.Definition THnSparse.cxx:914; THnSparse::FillExMapvoid FillExMap()We have been streamed; set up fBins.Definition THnSparse.cxx:655; THnSparse::RebinTHnSparse * Rebin(const Int_t *group) constDefinition THnSparse.h:162; THnSparse::ProjectionTH2D * Projection(Int_t yDim, Int_t xDim, Option_t *option="""") constForwards to THnBase::Projection().Definition THnSparse.h:141; THnSparse::~THnSparse~THnSparse() overrideDestruct a THnSparse.Definition THnSparse.cxx:616; THnSparse::FillBinvoid FillBin(Long64_t bin, Double_t w) overrideIncrement the bin content of ""bin"" by ""w"", return the bin index.Definition THnSparse.h:67; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8h_source.html:16290,error,error,16290,doc/master/THnSparse_8h_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html,2,['error'],"['error', 'errors']"
Availability,"actMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizerFile.html:1567,Error,Error,1567,root/html602/TPacketizerFile.html,https://root.cern,https://root.cern/root/html602/TPacketizerFile.html,2,['Error'],['Error']
Availability,"actMethod(const char* method) const; virtual Int_tTVirtualPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTVirtualPacketizer::AssignWork(TDSet*, Long64_t, Long64_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tGetEntriesProcessed(TSlave* sl) const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPacketizer.html:1841,Error,Error,1841,root/html602/TPacketizer.html,https://root.cern,https://root.cern/root/html602/TPacketizer.html,1,['Error'],['Error']
Availability,"actMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Long64_tGetPrefetchedBlocks() const; virtual TFilePrefetch*GetPrefetchObj(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char**, Long64_t, Int_t, Bool_t*); virtual Bool_tTObject::HandleTimer(TTimer* timer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFileCacheRead.html:1998,error,error,1998,root/html530/TFileCacheRead.html,https://root.cern,https://root.cern/root/html530/TFileCacheRead.html,3,['error'],['error']
Availability,"actMethod(const char* method) const; virtual voidAddBranch(TBranch*, Bool_t = kFALSE); virtual voidAddBranch(const char*, Bool_t = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetBufferSize() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Int_tGetUnzipBuffer(char**, Long64_t, Int_t, Bool_t*); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:1998,error,error,1998,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['error'],['error']
Availability,"actMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventDist(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFileDist(Bool_t writedet = kFALSE); voidFileProcPlot(const char* fn, const char* out = 0); voidFileRatePlot(const char* fns = 0); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetAverages(Double_t& evtmax, Double_t& mbmax, Double_t& evt, Double_t& mb) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEvtRateAvg() const; Double_tGetEvtRateAvgMax() const; virtual const char*TObject::GetIconName() const; Double_tGetMBRateAvg() const; Double_tGetMBRateAvgMax() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPerfAnalysis.html:1610,error,error,1610,root/html534/TProofPerfAnalysis.html,https://root.cern,https://root.cern/root/html534/TProofPerfAnalysis.html,6,['error'],['error']
Availability,"actMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TMapFile*Create(const char* name, Option_t* option = ""READ"", Int_t size = kDefaultMapSize, const char* title = """"); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TObject*Get(const char* name, TObject* retObj = 0); void*GetBaseAddr() const; void*GetBreakval() const; TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tGetFd() const; TMapRec*GetFirst() const; virtual const char*TObject::GetIconName() const; TMapRec*GetLast() const; void*GetMmallocDesc() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMapFile.html:3528,Error,Error,3528,root/html532/TMapFile.html,https://root.cern,https://root.cern/root/html532/TMapFile.html,4,['Error'],['Error']
Availability,"actMethod(const char* method) const; voidAddUnpack(const char* tname, const char* value); voidAddUnpackInt(const char* tname, Int_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*GetBlobPrefixName() const; const char*GetBlobTypeName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TSQLClassInfo*GetInfo() const; const char*GetLocatedField() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Long64_tGetObjId() const; virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue() const; virtual Bool_tTObject::Handl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLObjectData.html:1923,error,error,1923,root/html530/TSQLObjectData.html,https://root.cern,https://root.cern/root/html530/TSQLObjectData.html,9,['error'],['error']
Availability,"activate the storage of the sum of squares of errors, ie TH1::Sumw2 is automatically called. ; Definition at line 6703 of file TH1.cxx. ◆ SetDirectory(). void TH1::SetDirectory ; (; TDirectory * ; dir). virtual . By default, when a histogram is created, it is added to the list of histogram objects in the current directory in memory. ; Remove reference to this histogram from current directory and add reference to new directory dir. dir can be 0 in which case the histogram does not belong to any directory.; Note that the directory is not a real property of the histogram and it will not be copied when the histogram is copied or cloned. If the user wants to have the copied (cloned) histogram in the same directory, he needs to set again the directory using SetDirectory to the copied histograms ; Definition at line 8937 of file TH1.cxx. ◆ SetEntries(). virtual void TH1::SetEntries ; (; Double_t ; n). inlinevirtual . Definition at line 391 of file TH1.h. ◆ SetError(). void TH1::SetError ; (; const Double_t * ; error). virtual . Replace bin errors by values in array error. ; Definition at line 8951 of file TH1.cxx. ◆ SetHighlight(). void TH1::SetHighlight ; (; Bool_t ; set = kTRUE). virtual . Set highlight (enable/disable) mode for the histogram by default highlight mode is disable. ; Definition at line 4482 of file TH1.cxx. ◆ SetLabelColor(). void TH1::SetLabelColor ; (; Color_t ; color = 1, . Option_t * ; axis = ""X"" . ). virtual . Set axis labels color. ; axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 226 of file Haxis.cxx. ◆ SetLabelFont(). void TH1::SetLabelFont ; (; Style_t ; font = 62, . Option_t * ; axis = ""X"" . ). virtual . Set font number used to draw axis labels. ; font : Text font code = 10*fontnumber + precision Font numbers must be between 1 and 14 precision = 1 fast hardware fonts (steps in the size) precision = 2 scalable and rotatable hardware fonts; The default font number is 62. axis specifies which ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:212266,error,error,212266,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"activate the sub-branches of ""parent"". You should do:; T.SetBranchStatus(""parent*"",1);. Without the trailing dot in the branch creation you have no choice but to; call SetBranchStatus explicitly for each of the sub branches. An alternative to this function is to read directly and only; the interesting branches. Example:; TBranch *brc = T.GetBranch(""c"");; TBranch *bre = T.GetBranch(""e"");; brc->GetEntry(i);; bre->GetEntry(i);. If found is not 0, the number of branch(es) found matching the regular; expression is returned in *found AND the error message 'unknown branch'; is suppressed. void SetBranchStyle(Int_t style = 1); Set the current branch style. (static function). style = 0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:133534,error,error,133534,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['error'],['error']
Availability,"active in parallel mode. ; Returns 0 in case there are no active slaves. Returns -1 in case of error. ; Definition at line 2304 of file TProof.cxx. ◆ GetParameter() [1/6]. TObject * TProof::GetParameter ; (; const char * ; par); const. Get specified parameter. ; A parameter set via SetParameter() is either a TParameter or a TNamed or 0 in case par is not defined. ; Definition at line 9918 of file TProof.cxx. ◆ GetParameter() [2/6]. Int_t TProof::GetParameter ; (; TCollection * ; c, . const char * ; par, . Double_t & ; value . ). static . Get the value from the specified parameter from the specified collection. ; Returns -1 in case of error (i.e. list is 0, parameter does not exist or value type does not match), 0 otherwise. ; Definition at line 11995 of file TProof.cxx. ◆ GetParameter() [3/6]. Int_t TProof::GetParameter ; (; TCollection * ; c, . const char * ; par, . Int_t & ; value . ). static . Get the value from the specified parameter from the specified collection. ; Returns -1 in case of error (i.e. list is 0, parameter does not exist or value type does not match), 0 otherwise. ; Definition at line 11941 of file TProof.cxx. ◆ GetParameter() [4/6]. Int_t TProof::GetParameter ; (; TCollection * ; c, . const char * ; par, . Long64_t & ; value . ). static . Get the value from the specified parameter from the specified collection. ; Returns -1 in case of error (i.e. list is 0, parameter does not exist or value type does not match), 0 otherwise. ; Definition at line 11977 of file TProof.cxx. ◆ GetParameter() [5/6]. Int_t TProof::GetParameter ; (; TCollection * ; c, . const char * ; par, . Long_t & ; value . ). static . Get the value from the specified parameter from the specified collection. ; Returns -1 in case of error (i.e. list is 0, parameter does not exist or value type does not match), 0 otherwise. ; Definition at line 11959 of file TProof.cxx. ◆ GetParameter() [6/6]. Int_t TProof::GetParameter ; (; TCollection * ; c, . const char * ; par, . TString & ; value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:101928,error,error,101928,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,"active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance Chart:. TObject. ←; TSlave. ←; TSlaveLite. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); Create a PROOF slave object. Called via the TProof ctor. void Init(); Init a PROOF worker object. Called via the TSlaveLite ctor. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlaveLite ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TSlaveLite(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. void Print(Option_t* option = """") const; Printf info about slave. TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1). » Author: G. Ganis Mar 2008 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:33; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TSlaveLite.html:9375,Error,ErrorHandler,9375,root/html604/TSlaveLite.html,https://root.cern,https://root.cern/root/html604/TSlaveLite.html,1,['Error'],['ErrorHandler']
Availability,"active slaves; Int_tTSlave::fPerfIdxrelative CPU performance index; Int_tTSlave::fPortslave's port number; TProof*TSlave::fProofproof cluster to which slave belongs; TStringTSlave::fProofWorkDirbase proofserv working directory (info obtained from slave); Int_tTSlave::fProtocolslave's protocol level; TStringTSlave::fROOTVersROOT version run by worker; Float_tTSlave::fRealTimereal time spent executing commands (info obtained from slave); TStringTSlave::fSessionTagunique tag for ths worker process; TSlave::ESlaveTypeTSlave::fSlaveTypetype of slave (either kMaster or kSlave); TSocket*TSlave::fSocketsocket to slave; Int_tTSlave::fStatusremote return status; TStringTSlave::fUserslave's user id; TStringTSlave::fWorkDirslave's working directory (info obtained from slave). private:. TSignalHandler*fIntHandlerinterrupt signal handler (ctrl-c); Bool_tfValid. Class Charts. Inheritance Chart:. TObject. ←; TSlave. ←; TSlaveLite. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1); Create a PROOF slave object. Called via the TProof ctor. void Init(); Init a PROOF worker object. Called via the TSlaveLite ctor. Int_t SetupServ(Int_t stype, const char* conffile); Init a PROOF slave object. Called via the TSlaveLite ctor.; The Init method is technology specific and is overwritten by derived; classes. ~TSlaveLite(); Destroy slave. void Close(Option_t* opt = """"); Close slave socket. void Print(Option_t* option = """") const; Printf info about slave. TSlaveLite(const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd, Int_t = 1). » Author: G. Ganis Mar 2008 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:30; This page has been automati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSlaveLite.html:9375,Error,ErrorHandler,9375,root/html602/TSlaveLite.html,https://root.cern,https://root.cern/root/html602/TSlaveLite.html,1,['Error'],['ErrorHandler']
Availability,"ad ; (; Option_t * ; option = """"). pure virtual . Implemented in TPad. ◆ SaveAs(). void TVirtualPad::SaveAs ; (; const char * ; filename = """", . Option_t * ; option = """" . ); const. overridepure virtual . Save this object in the file specified by filename. . if ""filename"" contains "".root"" the object is saved in filename as root binary file.; if ""filename"" contains "".xml"" the object is saved in filename as a xml ascii file.; if ""filename"" contains "".cc"" the object is saved in filename as C code independant from ROOT. The code is generated via SavePrimitive(). Specific code should be implemented in each object to handle this option. Like in TF1::SavePrimitive().; otherwise the object is written to filename as a CINT/C++ script. The C++ code to rebuild this object is generated via SavePrimitive(). The ""option"" parameter is passed to SavePrimitive. By default it is an empty string. It can be used to specify the Draw option in the code generated by SavePrimitive.; The function is available via the object context menu. . Reimplemented from TObject.; Implemented in TPad. ◆ SetAttFillPS(). virtual void TVirtualPad::SetAttFillPS ; (; Color_t ; color, . Style_t ; style . ). pure virtual . Implemented in TPad. ◆ SetAttLinePS(). virtual void TVirtualPad::SetAttLinePS ; (; Color_t ; color, . Style_t ; style, . Width_t ; lwidth . ). pure virtual . Implemented in TPad. ◆ SetAttMarkerPS(). virtual void TVirtualPad::SetAttMarkerPS ; (; Color_t ; color, . Style_t ; style, . Size_t ; msize . ). pure virtual . Implemented in TPad. ◆ SetAttTextPS(). virtual void TVirtualPad::SetAttTextPS ; (; Int_t ; align, . Float_t ; angle, . Color_t ; color, . Style_t ; font, . Float_t ; tsize . ). pure virtual . Implemented in TPad. ◆ SetBatch(). virtual void TVirtualPad::SetBatch ; (; Bool_t ; batch = kTRUE). pure virtual . Implemented in TCanvas, and TPad. ◆ SetBorderMode(). virtual void TVirtualPad::SetBorderMode ; (; Short_t ; bordermode). pure virtual . Implemented in TButton, TDialogCanvas, an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualPad.html:56646,avail,available,56646,doc/master/classTVirtualPad.html,https://root.cern,https://root.cern/doc/master/classTVirtualPad.html,1,['avail'],['available']
Availability,"ad = 1; , kWrite = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofServLogHandler (const char *cmd, TSocket *s, const char *pfx="""");  Execute 'cmd' in a pipe and handle output messages from the related file. ;  ;  TProofServLogHandler (FILE *f, TSocket *s, const char *pfx="""");  Handle available message from the open file 'f'. ;  ;  ~TProofServLogHandler () override;  Handle available message in the open file. ;  ; Bool_t IsValid ();  ; Bool_t Notify () override;  Handle available message in the open file. ;  ; Bool_t ReadNotify () override;  Notify when something can be read from the descriptor associated with this handler. ;  ;  Public Member Functions inherited from TFileHandler;  TFileHandler (int fd, int mask);  Create a file descriptor event handler. ;  ; virtual ~TFileHandler ();  ; void Add () override;  Add file event handler to system file handler list. ;  ; int GetFd () const;  ; virtual Bool_t HasReadInterest ();  True if handler is interested in read events. ;  ; virtual Bool_t HasWriteInterest ();  True if handler is interested in write events. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsReadReady () const;  ; virtual Bool_t IsWriteReady () const;  ; void Remove () override;  Remove file event handler from system file handler list. ;  ; virtual void ResetReadyMask ();  ; void SetFd (int fd);  ; virtual void SetInterest (In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLogHandler.html:1519,avail,available,1519,doc/master/classTProofServLogHandler.html,https://root.cern,https://root.cern/doc/master/classTProofServLogHandler.html,1,['avail'],['available']
Availability,"ad default to nullptr, as it is for single-thread programs.; 495 ///; 496 /// The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different; 497 /// canvases from different threads (and analogous operations such as invoking `Draw` on a `TObject`) is not thread-safe.; 498 ///; 499 /// Note that there is no `DisableThreadSafety()`. ROOT's thread-safety features cannot be disabled once activated.; 500 // clang-format on; 501 void EnableThreadSafety(); 502 {; 503 static void (*sym)() = (void(*)())Internal::GetSymInLibImt(""ROOT_TThread_Initialize"");; 504 if (sym); 505 sym();; 506 }; 507 ; 508 ////////////////////////////////////////////////////////////////////////////////; 509 /// @param[in] numthreads Number of threads to use. If not specified or; 510 /// set to zero, the number of threads is automatically; 511 /// decided by the implementation. Any other value is; 512 /// used as a hint.; 513 ///; 514 /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.; 515 /// The following objects and methods automatically take advantage of; 516 /// multi-threading if a call to `EnableImplicitMT` has been made before usage:; 517 ///; 518 /// - RDataFrame internally runs the event-loop by parallelizing over clusters of entries; 519 /// - TTree::GetEntry reads multiple branches in parallel; 520 /// - TTree::FlushBaskets writes multiple baskets to disk in parallel; 521 /// - TTreeCacheUnzip decompresses the baskets contained in a TTreeCache in parallel; 522 /// - THx::Fit performs in parallel the evaluation of the objective function over the data; 523 /// - TMVA::DNN trains the deep neural networks in parallel; 524 /// - TMVA::BDT trains the classifier in parallel and multiclass BDTs are evaluated in parallel; 525 ///; 526 /// EnableImplicitMT calls in turn EnableThreadSafety.; 527 /// The 'numthreads' parameter allows to control the number of threads to; 528 /// be used by the implicit multi-threa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:18765,avail,available,18765,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avail'],['available']
Availability,"ad in c++11.; 439 const double* GetPoint( unsigned int ipoint, double & value, double & invError ) const; 440 {; 441 assert( ipoint < fMaxPoints );; 442 assert( fErrorType == kNoError || fErrorType == kValueError );; 443 ; 444 double e = Error( ipoint );; 445 ; 446 if (fWrapped); 447 invError = e;; 448 else; 449 invError = ( e != 0.0 ) ? 1.0/e : 1.0;; 450 ; 451 return GetPoint( ipoint, value );; 452 }; 453 ; 454 /**; 455 Retrieve the errors on the point (coordinate and value) for the given fit point; 456 It must be called only when the coordinate errors are stored otherwise it will produce an; 457 assert.; 458 */; 459 // not threadsafe, to be replaced with never constructs!; 460 // for example: just return std::array or std::vector, there's; 461 // is going to be only minor overhead in c++11.; 462 const double* GetPointError(unsigned int ipoint, double & errvalue) const; 463 {; 464 assert( ipoint < fMaxPoints );; 465 assert( fErrorType == kCoordError || fErrorType == kAsymError );; 466 ; 467 errvalue = Error( ipoint );; 468 return CoordErrors( ipoint );; 469 }; 470 ; 471 /**; 472 Get errors on the point (coordinate errors and asymmetric value errors) for the; 473 given fit point.; 474 It must be called only when the coordinate errors and asymmetric errors are stored; 475 otherwise it will produce an assert.; 476 */; 477 // not threadsafe, to be replaced with never constructs!; 478 // for example: just return std::array or std::vector, there's; 479 // is going to be only minor overhead in c++11.; 480 const double* GetPointError(unsigned int ipoint, double & errlow, double & errhigh) const; 481 {; 482 assert( ipoint < fMaxPoints );; 483 assert( fErrorType == kAsymError );; 484 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 485 assert( fDataError.empty() );; 486 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 487 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 488 assert( fDataErrorL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:16570,error,errors,16570,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,3,['error'],['errors']
Availability,"ad of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 148| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 149 ; 150 ; 151### Queries; 152 ; 153These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object.; 154 ; 155| **Operation** | **Description** |; 156|---------------------|-----------------|; 157| Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; 158| GetColumnNames() | Get the names of all the available columns of the dataset. |; 159| GetColumnType() | Return the type of a given column as a string. |; 160| GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; 161| GetDefinedColumnNames() | Get the names of all the defined columns. |; 162| GetFilterNames() | Return the names of all filters in the computation graph. |; 163| GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; 164| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 165| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 166 ; 167\anchor introduction; 168## Introduction; 169Users define their analysis as a sequence of operations to be performed on the dataframe object; the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:11825,avail,available,11825,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"ad of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case `slot` will always be `0`. |; 152| Snapshot() | Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made *lazy* setting the appropriate flag in the snapshot options.|; 153 ; 154 ; 155### Queries; 156 ; 157These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object.; 158 ; 159| **Operation** | **Description** |; 160|---------------------|-----------------|; 161| Describe() | Get useful information describing the dataframe, e.g. columns and their types. |; 162| GetColumnNames() | Get the names of all the available columns of the dataset. |; 163| GetColumnType() | Return the type of a given column as a string. |; 164| GetColumnTypeNamesList() | Return the list of type names of columns in the dataset. |; 165| GetDefinedColumnNames() | Get the names of all the defined columns. |; 166| GetFilterNames() | Return the names of all filters in the computation graph. |; 167| GetNRuns() | Return the number of event loops run by this RDataFrame instance so far. |; 168| GetNSlots() | Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). |; 169| SaveGraph() | Store the computation graph of an RDataFrame in [DOT format (graphviz)](https://en.wikipedia.org/wiki/DOT_(graph_description_language)) for easy inspection. See the [relevant section](\ref representgraph) for details. |; 170 ; 171\anchor introduction; 172## Introduction; 173Users define their analysis as a sequence of operations to be performed on the dataframe object; the f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:12267,avail,available,12267,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"ad to set in; the example above of the (10x10) Hilbert, which is near singular, the; tolerance on 10e-12 . (The fact that we have to set the tolerance <; sqrt(epsilon) is a clear indication that we are losing precision .). If the matrix is flagged as being singular, operations with the; decomposition will fail and will return matrices/vectors that are; invalid . The observant reader will notice that by scaling the complete matrix; by some small number the decomposition will detect a singular matrix .; In this case the user will have to reduce the tolerance number by this; factor . (For CPU time saving we decided not to make this an automatic; procedure) . Code for this could look as follows:; const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TDecompBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDecompBase.html:4216,avail,available,4216,root/html528/TDecompBase.html,https://root.cern,https://root.cern/root/html528/TDecompBase.html,10,['avail'],['available']
Availability,"ad(Option_t* option = """"); virtual voidApply(const TGLBoundingBox& box, const TGLRect* pickRect = 0) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidConfigure(Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTGLCamera::Dolly(Int_t delta, Bool_t mod1, Bool_t mod2); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGLCamera::DrawDebugAids() const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TGLVector3TGLCamera::EyeDirection() const; TGLVertex3TGLCamera::EyePoint() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLVertex3TGLCamera::FrustumCenter() const; Rgl::EOverlapTGLCamera::FrustumOverlap(const TGLBoundingBox& box) const; const TGLPlane&TGLCamera::FrustumPlane(TGLCamera::EFrustumPlane plane) const; const TGLMatrix&TGLCamera::GetCamBase() const; const TGLMatrix&TGLCamera::GetCamTrans() const; Double_t*TGLCamera::GetCenterVec(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tTGLCamera::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLPerspectiveCamera.html:1920,Error,Error,1920,root/html534/TGLPerspectiveCamera.html,https://root.cern,https://root.cern/root/html534/TGLPerspectiveCamera.html,1,['Error'],['Error']
Availability,"ad(Option_t* option = """"); virtual voidBeforeNextChild(Int_t lvl, Int_t nchld, Int_t); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseNode(Int_t lvl, Int_t numchilds); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCreateNode(Int_t lvl, const char* nodename); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TClass*TRootSnifferStore::GetResClass() const; TDataMember*TRootSnifferStore::GetResMember() const; Int_tTRootSnifferStore::GetResNumChilds() const; void*TRootSnifferStore::GetResPtr() const; Int_tTRootSnifferStore::GetResRestrict() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootSnifferStoreXml.html:1668,error,error,1668,root/html534/TRootSnifferStoreXml.html,https://root.cern,https://root.cern/root/html534/TRootSnifferStoreXml.html,4,['error'],['error']
Availability,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Int_tCountKey(Float_t& keyvalue); Int_tCountKey(Long_t& keyvalue); Int_tCountKey(Int_t& keyvalue); Int_tCountKey(Short_t& keyvalue); Int_tCountKey(Double_t& keyvalue); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNRows() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableIter.html:1777,error,error,1777,root/html528/TTableIter.html,https://root.cern,https://root.cern/root/html528/TTableIter.html,10,['error'],['error']
Availability,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPerfStats.html:1580,error,error,1580,root/html528/TPerfStats.html,https://root.cern,https://root.cern/root/html528/TPerfStats.html,1,['error'],['error']
Availability,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; static voidGetMemValues(Long_t& vmax, Long_t& rmax); virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPerfStats.html:1549,error,error,1549,root/html532/TPerfStats.html,https://root.cern,https://root.cern/root/html532/TPerfStats.html,2,['error'],['error']
Availability,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*TVirtualPerfStats::EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const char* filename, Double_t start); virtual voidFileReadEvent(TFile* file, Int_t len, Double_t start); virtual voidFileUnzipEvent(TFile* file, Long64_t pos, Double_t start, Int_t complen, Int_t objlen); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Long64_tGetBytesRead() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual Long64_tGetNumEvents() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPerfStats.html:1549,error,error,1549,root/html530/TPerfStats.html,https://root.cern,https://root.cern/root/html530/TPerfStats.html,1,['error'],['error']
Availability,"ad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; voidComputeLogs(Int_t npoints, Int_t opt); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual char*GetObjectInfoHelper(TGraph* theGraph, Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TVirtualGraphPainter*TVirtualGraphPainter::GetPainter(); virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:13437,error,error,13437,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,10,['error'],['error']
Availability,"ad.; To create a copy of the histogram when drawing it, one can use; TH1::DrawClone(). This will clone the histogram and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; The Y-axis is drawn on the right side of the plot. Options supported for 1D histograms. "" ""; Default. ""AH""; Draw histogram without axis. ""A""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:4903,error,errors,4903,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,8,['error'],"['error', 'errors']"
Availability,"ad.ne.0. ,; "" "" SQRT(Y)/SQRT(N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; 's' Errors are Spread for Spread.ne.0. ,; "" "" SQRT(Y) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0; 'i' Errors are Spread/SQRT(N) for Spread.ne.0. ,; "" "" 1./SQRT(12.*N) for Spread.eq.0,N.gt.0 ,; "" "" 0. for N.eq.0. The third case above corresponds to Integer Y values for which the; uncertainty is +-0.5, with the assumption that the probability that Y; takes any value between Y-0.5 and Y+0.5 is uniform (the same argument; goes for Y uniformly distributed between Y and Y+1); this would be; useful if Y is an ADC measurement, for example.; Other, fancier options; would be possible, at the cost of adding one more parameter to the PROFILE; command. For example, if all Y variables are distributed according to some; known Gaussian of standard deviation Sigma (which can be different for each measurement),; and the profile has been filled with a weight equal to 1/Sigma**2,; then one cam use the following option:. 'G' Errors are 1./SQRT(Sum(1/sigma**2)); For example, this would be useful when all Y's are experimental quantities; measured with different precision Sigma_Y. TProfile(const TProfile& profile); Copy constructor. void Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1. void Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1. void Add(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1); -*-*Replace contents of this profile by the addition of h1 and h2; *-* =============================================================. this = c1*h1 + c2*h2. c1 and c2 are considered as weights applied to the two summed profiles.; The operation acts therefore like merging the two profiles with a weight c1 and c2. void Approximate(Bool_t approx = kTRUE); static function; set the fgApproximate flag. When the flag is true, the function GetBinError; will approximate the bin error with the average profile error on all bins; in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile.html:30485,Error,Errors,30485,root/html532/TProfile.html,https://root.cern,https://root.cern/root/html532/TProfile.html,1,['Error'],['Errors']
Availability,"ad.release(1);. // ... and minimize with all three parameters; // (still with limits!); FunctionMinimum min2 = migrad();. // output; std::cout<<""minimum2: ""<<min2<<std::endl;. // remove all limits on parameters...; migrad.removeLimits(""mean"");; migrad.removeLimits(""sigma"");. // ... and minimize again with all three parameters; // (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:86582,error,errors,86582,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['error'],['errors']
Availability,"ad.release(4);; MnScan scan(...);; std::vector<std::pair<double, double> > points = scan(4);; where \(\mbox{SCAN}\) gives you a picture of \(\mbox{FCN}\) as a function of parameter four alone, the others being fixed at their current best values. If you suspect the difficulty is due to parameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69532,Error,Errors,69532,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['Error'],['Errors']
Availability,"adBuffer(const char* file, Long64_t ofs, Int_t len); Read, via the coordinator, 'len' bytes from offset 'ofs' of 'file'.; Returns a TObjString with the content or 0, in case of failure. TObjString * ReadBuffer(const char* file, const char* pattern); Read, via the coordinator, 'fin' filtered. If 'pattern' starts with '|',; it represents a command filtering the output. Elsewhere, it is a grep; pattern. Returns a TObjString with the content or 0 in case of failure. void ShowROOTVersions(); Display what ROOT versions are available on the cluster. Int_t SetROOTVersion(const char* tag); Set the default ROOT version to be used. Int_t SendMsgToUsers(const char* msg, const char* usr = 0); Send a message to connected users. Only superusers can do this.; The first argument specifies the message or the file from where to take; the message.; The second argument specifies the user to which to send the message: if; empty or null the message is send to all the connected users.; return 0 in case of success, -1 in case of error. void Grep(const char* what, const char* how = 0, const char* where = 0); Run 'grep' on the nodes. void Find(const char* what = ""~/"", const char* how = ""-type f"", const char* where = 0); Run 'find' on the nodes. void Ls(const char* what = ""~/"", const char* how = 0, const char* where = 0); Run 'ls' on the nodes. void More(const char* what, const char* how = 0, const char* where = 0); Run 'more' on the nodes. Int_t Rm(const char* what, const char* how = 0, const char* where = 0); Run 'rm' on the nodes. The user is prompted before removal, unless 'how'; contains ""--force"" or a combination of single letter options including 'f',; e.g. ""-fv"". void Tail(const char* what, const char* how = 0, const char* where = 0); Run 'tail' on the nodes. Int_t Md5sum(const char* what, TString& sum, const char* where = 0); Run 'md5sum' on one of the nodes. Int_t Stat(const char* what, FileStat_t& st, const char* where = 0); Run 'stat' on one of the nodes. TObjString * Exec(Int_t act",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:14571,error,error,14571,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,6,['error'],['error']
Availability,"adExecutor >; using InvokeResult_t = ROOT::TypeTraits::InvokeResult_t< F, Args... >;  ; using validMapReturnCond = std::enable_if_t<!std::is_reference< InvokeResult_t< F, T... > >::value &&!std::is_void< InvokeResult_t< F, T... > >::value >;  type definition used in templated functions for not allowing mapping functions that return references or void. ;  . #include <ROOT/TThreadExecutor.hxx>. Inheritance diagram for ROOT::TThreadExecutor:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TThreadExecutor() [1/2]. ROOT::TThreadExecutor::TThreadExecutor ; (; UInt_t ; nThreads = 0u). explicit . Class constructor. ; If the scheduler is active (e.g. because another TThreadExecutor is in flight, or ROOT::EnableImplicitMT() was called), work with the current pool of threads. If not, initialize the pool of threads, spawning nThreads. nThreads' default value, 0, initializes the pool with as many logical threads as are available in the system (see NLogicalCores in RTaskArenaWrapper.cxx).; At construction time, TThreadExecutor automatically enables ROOT's thread-safety locks as per calling ROOT::EnableThreadSafety(). ; Definition at line 149 of file TThreadExecutor.cxx. ◆ TThreadExecutor() [2/2]. ROOT::TThreadExecutor::TThreadExecutor ; (; const TThreadExecutor & ; ). delete . Member Function Documentation. ◆ Foreach() [1/5]. template<class F , class T > . void ROOT::TThreadExecutor::Foreach ; (; F ; func, . const std::vector< T > & ; args, . unsigned ; nChunks = 0 . ). Execute a function in parallel over the elements of a immutable vector, dividing the execution in nChunks. ; Parameters. funcFunction to be executed on the elements of the vector passed as second parameter. ; argsImmutable vector of elements passed as an argument to func. ; nChunksNumber of chunks to split the input data for processing. . Definition at line 231 of file TThreadExecutor.hxx. ◆ Foreach() [2/5]. template<class F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html:16033,avail,available,16033,doc/v632/classROOT_1_1TThreadExecutor.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TThreadExecutor.html,2,['avail'],['available']
Availability,"adLibStorage.push_back(libs);; 7313 return fAutoLoadLibStorage.back().c_str();; 7314 }; 7315 }; 7316 ; 7317 if (!fMapfile || !lib || !lib[0]) {; 7318 return nullptr;; 7319 }; 7320 TString libname(lib);; 7321 Ssiz_t idx = libname.Last('.');; 7322 if (idx != kNPOS) {; 7323 libname.Remove(idx);; 7324 }; 7325 TEnvRec* rec;; 7326 TIter next(fMapfile->GetTable());; 7327 size_t len = libname.Length();; 7328 while ((rec = (TEnvRec*) next())) {; 7329 const char* libs = rec->GetValue();; 7330 if (!strncmp(libs, libname.Data(), len) && strlen(libs) >= len; 7331 && (!libs[len] || libs[len] == ' ' || libs[len] == '.')) {; 7332 return libs;; 7333 }; 7334 }; 7335 return nullptr;; 7336}; 7337 ; 7338////////////////////////////////////////////////////////////////////////////////; 7339/// If error messages are disabled, the interpreter should suppress its; 7340/// failures and warning messages from stdout.; 7341 ; 7342Bool_t TCling::IsErrorMessagesEnabled() const; 7343{; 7344#if defined(R__MUST_REVISIT); 7345#if R__MUST_REVISIT(6,2); 7346 Warning(""IsErrorMessagesEnabled"", ""Interface not available yet."");; 7347#endif; 7348#endif; 7349 return kTRUE;; 7350}; 7351 ; 7352////////////////////////////////////////////////////////////////////////////////; 7353/// If error messages are disabled, the interpreter should suppress its; 7354/// failures and warning messages from stdout. Return the previous state.; 7355 ; 7356Bool_t TCling::SetErrorMessages(Bool_t enable); 7357{; 7358#if defined(R__MUST_REVISIT); 7359#if R__MUST_REVISIT(6,2); 7360 Warning(""SetErrorMessages"", ""Interface not available yet."");; 7361#endif; 7362#endif; 7363 return TCling::IsErrorMessagesEnabled();; 7364}; 7365 ; 7366////////////////////////////////////////////////////////////////////////////////; 7367/// Refresh the list of include paths known to the interpreter and return it; 7368/// with -I prepended.; 7369 ; 7370const char* TCling::GetIncludePath(); 7371{; 7372 R__LOCKGUARD(gInterpreterMutex);; 7373 ; 7374 fIncludePat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:287220,avail,available,287220,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avail'],['available']
Availability,"adPainter ;  polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  hlGraph1.CThis tutorial demonstrates how to use the highlight mode on graph ;  hlGraph2.CThis tutorial demonstrates how to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:118340,error,error,118340,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['error'],['error']
Availability,"adPainter ;  polytest2.C This macro is testing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:114543,error,error,114543,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['error'],['error']
Availability,"adResults.end(), 0);; 1259 }; 1260 ; 1261 // Called by RDataFrame to retrieve the name of this action.; 1262 std::string GetActionName() const { return ""MyCounter""; }; 1263};; 1264 ; 1265int main() {; 1266 ROOT::RDataFrame df(10);; 1267 ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; 1268 // The GetValue call triggers the event loop; 1269 std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; 1270}; 1271~~~; 1272 ; 1273See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1274for a more complete example.; 1275 ; 1276#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1277 ; 1278Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1279executes the callable on the values of those columns for each event that passes all upstream selections.; 1280It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1281evaluates the root mean square of column ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:74239,avail,available,74239,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"adResults.end(), 0);; 1299 }; 1300 ; 1301 // Called by RDataFrame to retrieve the name of this action.; 1302 std::string GetActionName() const { return ""MyCounter""; }; 1303};; 1304 ; 1305int main() {; 1306 ROOT::RDataFrame df(10);; 1307 ROOT::RDF::RResultPtr<int> resultPtr = df.Book<>(MyCounter{df.GetNSlots()}, {});; 1308 // The GetValue call triggers the event loop; 1309 std::cout << ""Number of processed entries: "" << resultPtr.GetValue() << std::endl;; 1310}; 1311~~~; 1312 ; 1313See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1314for a more complete example.; 1315 ; 1316#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1317 ; 1318Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1319executes the callable on the values of those columns for each event that passes all upstream selections.; 1320It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1321evaluates the root mean square of column ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:75919,avail,available,75919,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"adata"": {; 1475 ""lumi"": 10000.0, ; 1476 ""xsec"": 1.0,; 1477 ""sample_category"" = ""data""; 1478 }; 1479 },; 1480 ""sampleB"": {; 1481 ""trees"": [""tree3"", ""tree4""],; 1482 ""files"": [""file3.root"", ""file4.root""],; 1483 ""metadata"": {; 1484 ""lumi"": 0.5, ; 1485 ""xsec"": 1.5,; 1486 ""sample_category"" = ""MC_background""; 1487 }; 1488 }; 1489 }; 1490}; 1491~~~; 1492 ; 1493The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1494For example, to access luminosity information (stored as a double):; 1495 ; 1496~~~{.python}; 1497df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1498~~~; 1499 ; 1500or sample_category information (stored as a string):; 1501 ; 1502~~~{.python}; 1503df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1504~~~; 1505 ; 1506or directly the filename:; 1507 ; 1508~~~{.python}; 1509df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1510~~~; 1511 ; 1512An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1513provides a corresponding exemplary JSON file for the dataset specification.; 1514 ; 1515\anchor progressbar; 1516### Adding a progress bar ; 1517 ; 1518A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1519The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1520and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1521n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1522 ; 1523ProgressBar is added after creating the dataframe object (df):; 1524~~~{.cpp}; 1525ROOT::RDataFrame df(""tree"", ""file.root"");; 1526ROOT::RDF::Experimental::AddProgressBar(df);; 1527~~~; 1528 ; 1529Alternatively, RDataFrame can be cast to an RNode first, giving ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:85358,avail,available,85358,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"adata"": {; 1515 ""lumi"": 10000.0, ; 1516 ""xsec"": 1.0,; 1517 ""sample_category"" = ""data""; 1518 }; 1519 },; 1520 ""sampleB"": {; 1521 ""trees"": [""tree3"", ""tree4""],; 1522 ""files"": [""file3.root"", ""file4.root""],; 1523 ""metadata"": {; 1524 ""lumi"": 0.5, ; 1525 ""xsec"": 1.5,; 1526 ""sample_category"" = ""MC_background""; 1527 }; 1528 }; 1529 }; 1530}; 1531~~~; 1532 ; 1533The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1534For example, to access luminosity information (stored as a double):; 1535 ; 1536~~~{.python}; 1537df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1538~~~; 1539 ; 1540or sample_category information (stored as a string):; 1541 ; 1542~~~{.python}; 1543df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1544~~~; 1545 ; 1546or directly the filename:; 1547 ; 1548~~~{.python}; 1549df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1550~~~; 1551 ; 1552An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1553provides a corresponding exemplary JSON file for the dataset specification.; 1554 ; 1555\anchor progressbar; 1556### Adding a progress bar ; 1557 ; 1558A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1559The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1560and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1561n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1562 ; 1563ProgressBar is added after creating the dataframe object (df):; 1564~~~{.cpp}; 1565ROOT::RDataFrame df(""tree"", ""file.root"");; 1566ROOT::RDF::Experimental::AddProgressBar(df);; 1567~~~; 1568 ; 1569Alternatively, RDataFrame can be cast to an RNode first, giving ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:87038,avail,available,87038,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. void SetData(const char* name); specify the name of the dataset in the workspace to be used. {fDataName = name;}. void SetPdf(const char* name); specify the name of the PDF in the workspace to be used. {fPdfName = name;}. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. {}. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. {fNullPOI = (RooArgSet*)nullpoi.snapshot();}. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams = &set;}. void SetObservables(const RooArgSet& set); specify the observables in the dataset (needed to evaluate the test statistic). {fObservables = &set;}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* testStat); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ToyMCSamplerOld.h 37403 2010-12-08 15:59:22Z moneta $ » Last generated: 2010-12-08 17:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCSamplerOld.html:6285,error,error,6285,root/html528/RooStats__ToyMCSamplerOld.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCSamplerOld.html,1,['error'],['error']
Availability,"add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. void SetData(const char* name); specify the name of the dataset in the workspace to be used. {fDataName = name;}. void SetPdf(const char* name); specify the name of the PDF in the workspace to be used. {fPdfName = name;}. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. {}. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. {fNullPOI = (RooArgSet*)nullpoi.snapshot();}. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams = &set;}. void SetObservables(const RooArgSet& set); specify the observables in the dataset (needed to evaluate the test statistic). {fObservables = &set;}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* testStat); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ToyMCSamplerOld.h 40096 2011-07-01 10:08:17Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html:6287,error,error,6287,root/html530/RooStats__ToyMCSamplerOld.html,https://root.cern,https://root.cern/root/html530/RooStats__ToyMCSamplerOld.html,1,['error'],['error']
Availability,"add to the the workspace if not already there. void SetPdf(RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. void SetData(const char* name); specify the name of the dataset in the workspace to be used. {fDataName = name;}. void SetPdf(const char* name); specify the name of the PDF in the workspace to be used. {fPdfName = name;}. void SetPriorNuisance(RooAbsPdf* ); How to randomize the prior. Set to NULL to deactivate randomization. {}. void SetParametersForTestStat(const RooArgSet& nullpoi); specify the values of parameters used when evaluating test statistic. {fNullPOI = (RooArgSet*)nullpoi.snapshot();}. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisParams = &set;}. void SetObservables(const RooArgSet& set); specify the observables in the dataset (needed to evaluate the test statistic). {fObservables = &set;}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* testStat); Set the TestStatistic (want the argument to be a function of the data & parameter points. void SetSamplingDistName(const char* name); Set the name of the sampling distribution used for plotting. { if(name) fSamplingDistName = name; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ToyMCSamplerOld.h 42339 2011-11-30 23:54:18Z moneta $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSamplerOld.html:6287,error,error,6287,root/html532/RooStats__ToyMCSamplerOld.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSamplerOld.html,2,['error'],['error']
Availability,"added to the histogram list of functions (fFunctions). If the histogram is made persistent, the list of associated functions is also persistent. Given a histogram h, one can retrieve an associated function with:; TF1 *myfunc = h->GetFunction(""myfunc"");; or by quering directly the list obtained by calling TH1::GetListOfFunctions. Fit status; The status of the fit is obtained converting the TFitResultPtr to an integer independently if the fit option ""S"" is used or not:; TFitResultPtr r = h->Fit(myFunc,opt);; Int_t fitStatus = r;. status = 0 : the fit has been performed successfully (i.e no error occurred).; status < 0 : there is an error not connected with the minimization procedure, for example when a wrong function is used.; status > 0 : return status from Minimizer, depends on used Minimizer. For example for TMinuit and Minuit2 we have:; status = migradStatus + 10*minosStatus + 100*hesseStatus + 1000*improveStatus. TMinuit returns 0 (for migrad, minos, hesse or improve) in case of success and 4 in case of error (see the documentation of TMinuit::mnexcm). For example, for an error only in Minos but not in Migrad a fitStatus of 40 will be returned. Minuit2 returns 0 in case of success and different values in migrad,minos or hesse depending on the error. See in this case the documentation of Minuit2Minimizer::Minimize for the migrad return status, Minuit2Minimizer::GetMinosError for the minos return status and Minuit2Minimizer::Hesse for the hesse return status. If other minimizers are used see their specific documentation for the status code returned. For example in the case of Fumili, see TFumili::Minimize. Fitting in a range; In order to fit in a sub-range of the histogram you have two options:; pass to this function the lower (xxmin) and upper (xxmax) values for the fitting range;; define a specific range in the fitted function and use the fitting option ""R"". For example, if your histogram has a defined range between -4 and 4 and you want to fit a gaussian only in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:137184,error,error,137184,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"address where the data ends.. When a file is closed, it writes a linked list of keys at the end of the file. This is what we see in the third to the last entry. In our example, the list of keys is stored in 732 bytes beginning at byte# 8244.; 20010404/092347 At:8244 N=732 KeysList; 20010404/092347 At:8976 N=53 FreeSegments; 20010404/092347 At:9029 N=1 END; The second to last entry is a list of free segments. In our case, this starts 8976 and is not very long, only 53 bytes, since we have not deleted any objects. The last entry is the address of the last byte in the file.; 11.1.6 File Recovery; A file may become corrupted or it may be impossible to write it to disk and close it properly. For example if the file is too large and exceeds the disk quota, or the job crashes or a batch job reaches its time limit before the file can be closed. In these cases, it is imperative to recover and retain as much information as possible. ROOT provides an intelligent and elegant file recovery mechanism using the redundant directory information in the record header.; If a file that has been not properly closed is opened again, it is scanned and rebuilt according to the information in the record header. The recovery algorithm reads the file and creates the saved objects in memory according to the header information. It then rebuilds the directory and file structure. If the file is opened in write mode, the recovery makes the correction on disk when the file is closed; however if the file is opened in read mode, the correction can not be written to disk. You can also explicitly invoke the recovery procedure by calling the TFile::Recover() method. You can recover the directory structure, but you cannot save what you recovered to the file on disk. In the following example, we interrupted and aborted the previous ROOT session, causing the file not to be closed. When we start a new session and attempt to open the file, it gives us an explanation and status on the recovery attempt.; root[] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:440518,recover,recovery,440518,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,"['recover', 'redundant']","['recovery', 'redundant']"
Availability,"aded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(char *(*)(const char* prompt) getlineFunc, void (*)(char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; the current macro. This function is typically called after SEGV or; ctlr-C after doing a longjmp back to the prompt. Int_t DeleteGlobal(void* obj); De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:21333,error,error,21333,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,2,['error'],['error']
Availability,"aded(const char* filename) const; Return true if the file has already been loaded by cint. Int_t Load(const char* filenam, Bool_t system = kFALSE); Load a library file in CINT's memory.; if 'system' is true, the library is never unloaded. void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0); Load a macro file in CINT's memory. Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line.; If the command is executed and the result of G__process_cmd is 0,; the return value is the int value corresponding to the result of the command; (float and double return values will be truncated). Long_t ProcessLineAsynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line asynch. Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0); Let CINT process a command line synchronously, i.e we are waiting; it will be finished. Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0); Directly execute an executable statement (e.g. ""func()"", ""3+5"", etc.; however not declarations, like ""Int_t x;""). void PrintIntro(); Print CINT introduction and help message. void SetGetline(const char *(*)(const char* prompt) getlineFunc, void (*)(const char* line) histaddFunc); Set a getline function to call when input is needed. void RecursiveRemove(TObject* obj); Delete object from CINT symbol table so it can not be used anymore.; CINT objects are always on the heap. void Reset(); Reset the CINT state to the state saved by the last call to; TCint::SaveContext(). void ResetAll(); Reset the CINT state to its initial state. void ResetGlobals(); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void ResetGlobalVar(void* obj); Reset the CINT global object state to the state saved by the last; call to TCint::SaveGlobalsContext(). void RewindDictionary(); Rewind CINT dictionary to the point where it was before executing; th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TCint.html:21437,error,error,21437,root/html530/TCint.html,https://root.cern,https://root.cern/root/html530/TCint.html,5,['error'],['error']
Availability,"ader file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. » Author: Magdalena Slawinska 10/2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2009-12-07 13:44",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__VirtualIntegrator.html:1119,avail,available,1119,root/html526/ROOT__Math__VirtualIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__VirtualIntegrator.html,1,['avail'],['available']
Availability,"ader file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » ROOT::Math::VirtualIntegrator. class ROOT::Math::VirtualIntegrator. Abstract class for all numerical integration methods (1D and multi-dim); Interface defining the common methods for the; numerical integrator classes of one and multi dimensions; The derived class VirtualIntegratorOneDim defines the methods; for one-dimensional integration.; The derived class VirtualIntegratorMultiDim defines the method for; multi-dimensional integration.; The concrete classes for one dimension (e.g. GSLIntegrator) or; multi-dimension (e.g. GSLMCIntegrator) can be created using the; plug-in manager.; Users should not use directly this class but the concrete classes ROOT::Math::IntegratorOneDim or; ROOT::Math::IntegratorMultiDim. @ingroup Integration. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VirtualIntegrator(); virtual doubleError() const; virtual intNEval() const; ROOT::Math::VirtualIntegrator&operator=(const ROOT::Math::VirtualIntegrator&); virtual doubleResult() const; virtual voidSetAbsTolerance(double); virtual voidSetRelTolerance(double); virtual intStatus() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~VirtualIntegrator(); destructor: no operation. {}. void SetRelTolerance(double ). set the desired relative Error. void SetAbsTolerance(double ). set the desired absolute Error. double Result() const. return the Result of the last Integral calculation. double Error() const. return the estimate of the absolute Error of the last Integral calculation. int Status() const. return the Error Status of the last Integral calculation. int NEval() const. return number of function evaluations in calculating the integral; (if integrator do not implement this function retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__VirtualIntegrator.html:1119,avail,available,1119,root/html528/ROOT__Math__VirtualIntegrator.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__VirtualIntegrator.html,1,['avail'],['available']
Availability,"ader file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:1090,error,errors,1090,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,2,['error'],['errors']
Availability,"ader length (%lld) or incorrect end of file length (%lld)"",; 733 GetName(),fBEGIN,fEND);; 734 delete [] header;; 735 goto zombie;; 736 }; 737 fSeekDir = fBEGIN;; 738 //*-*-------------Read Free segments structure if file is writable; 739 if (fWritable) {; 740 fFree = new TList;; 741 if (fSeekFree > fBEGIN) {; 742 ReadFree(); // NOLINT: silence clang-tidy warnings; 743 } else {; 744 Warning(""Init"",""file %s probably not closed, cannot read free segments"",GetName());; 745 }; 746 }; 747 //*-*-------------Read directory info; 748 // buffer_keyloc is the start of the key record.; 749 char *buffer_keyloc = nullptr;; 750 ; 751 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 752 if ( (nbytes + fBEGIN) > fEND) {; 753 // humm fBEGIN is wrong ....; 754 Error(""Init"",""file %s has an incorrect header length (%lld) or incorrect end of file length (%lld)"",; 755 GetName(),fBEGIN+nbytes,fEND);; 756 delete [] header;; 757 goto zombie;; 758 }; 759 if (nbytes+fBEGIN > kBEGIN+200) {; 760 delete [] header;; 761 header = new char[nbytes];; 762 buffer = header;; 763 Seek(fBEGIN); // NOLINT: silence clang-tidy warnings; 764 if (ReadBuffer(buffer,nbytes)) { // NOLINT: silence clang-tidy warnings; 765 // ReadBuffer returns kTRUE in case of failure.; 766 Error(""Init"",""%s failed to read the file header information at %lld (size=%d)"",; 767 GetName(),fBEGIN,nbytes);; 768 delete [] header;; 769 goto zombie;; 770 }; 771 buffer = header+fNbytesName;; 772 buffer_keyloc = header;; 773 } else {; 774 buffer = header+fBEGIN+fNbytesName;; 775 buffer_keyloc = header+fBEGIN;; 776 }; 777 Version_t version,versiondir;; 778 frombuf(buffer,&version); versiondir = version%1000;; 779 fDatimeC.ReadBuffer(buffer);; 780 fDatimeM.ReadBuffer(buffer);; 781 frombuf(buffer, &fNbytesKeys);; 782 frombuf(buffer, &fNbytesName);; 783 if (version > 1000) {; 784 frombuf(buffer, &fSeekDir);; 785 frombuf(buffer, &fSeekParent);; 786 frombuf(buffer, &fSeekKeys);; 787 } else {; 788 Int_t sdir,sparent,skeys;; 789 frombuf(buffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:27923,failure,failure,27923,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['failure'],['failure']
Availability,"ader_len = 0;; 12482 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12483 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12484 len = buf[1] & 127;; 12485 mask_len = (buf[1] & 128) ? 4 : 0;; 12486 if ((len < 126) && (body_len >= mask_len)) {; 12487 /* inline 7-bit length field */; 12488 data_len = len;; 12489 header_len = 2 + mask_len;; 12490 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12491 /* 16-bit length field */; 12492 header_len = 4 + mask_len;; 12493 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12494 } else if (body_len >= (10 + mask_len)) {; 12495 /* 64-bit length field */; 12496 uint32_t l1, l2;; 12497 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12498 memcpy(&l2, &buf[6], 4);; 12499 header_len = 10 + mask_len;; 12500 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12501 ; 12502 if (data_len > (uint64_t)0x7FFF0000ul) {; 12503 /* no can do */; 12504 mg_cry_internal(; 12505 conn,; 12506 ""%s"",; 12507 ""websocket out of memory; closing connection"");; 12508 break;; 12509 }; 12510 }; 12511 }; 12512 ; 12513 if ((header_len > 0) && (body_len >= header_len)) {; 12514 /* Allocate space to hold websocket payload */; 12515 unsigned char *data = mem;; 12516 ; 12517 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12518 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12519 conn->phys_ctx);; 12520 if (data == NULL) {; 12521 /* Allocation failed, exit the loop and then close the; 12522 * connection */; 12523 mg_cry_internal(; 12524 conn,; 12525 ""%s"",; 12526 ""websocket out of memory; closing connection"");; 12527 break;; 12528 }; 12529 }; 12530 ; 12531 /* Copy the mask before we shift the queue and destroy it */; 12532 if (mask_len > 0) {; 12533 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12534 } else {; 12535 memset(mask, 0, sizeof(mask));; 12536 }; 12537 ; 12538 /* Read frame payload from the first message in the queue into; 12539 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:363843,mask,mask,363843,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,5,['mask'],['mask']
Availability,"ader_len = 0;; 12483 DEBUG_ASSERT(conn->data_len >= conn->request_len);; 12484 if ((body_len = (size_t)(conn->data_len - conn->request_len)) >= 2) {; 12485 len = buf[1] & 127;; 12486 mask_len = (buf[1] & 128) ? 4 : 0;; 12487 if ((len < 126) && (body_len >= mask_len)) {; 12488 /* inline 7-bit length field */; 12489 data_len = len;; 12490 header_len = 2 + mask_len;; 12491 } else if ((len == 126) && (body_len >= (4 + mask_len))) {; 12492 /* 16-bit length field */; 12493 header_len = 4 + mask_len;; 12494 data_len = ((((size_t)buf[2]) << 8) + buf[3]);; 12495 } else if (body_len >= (10 + mask_len)) {; 12496 /* 64-bit length field */; 12497 uint32_t l1, l2;; 12498 memcpy(&l1, &buf[2], 4); /* Use memcpy for alignment */; 12499 memcpy(&l2, &buf[6], 4);; 12500 header_len = 10 + mask_len;; 12501 data_len = (((uint64_t)ntohl(l1)) << 32) + ntohl(l2);; 12502 ; 12503 if (data_len > (uint64_t)0x7FFF0000ul) {; 12504 /* no can do */; 12505 mg_cry_internal(; 12506 conn,; 12507 ""%s"",; 12508 ""websocket out of memory; closing connection"");; 12509 break;; 12510 }; 12511 }; 12512 }; 12513 ; 12514 if ((header_len > 0) && (body_len >= header_len)) {; 12515 /* Allocate space to hold websocket payload */; 12516 unsigned char *data = mem;; 12517 ; 12518 if ((size_t)data_len > (size_t)sizeof(mem)) {; 12519 data = (unsigned char *)mg_malloc_ctx((size_t)data_len,; 12520 conn->phys_ctx);; 12521 if (data == NULL) {; 12522 /* Allocation failed, exit the loop and then close the; 12523 * connection */; 12524 mg_cry_internal(; 12525 conn,; 12526 ""%s"",; 12527 ""websocket out of memory; closing connection"");; 12528 break;; 12529 }; 12530 }; 12531 ; 12532 /* Copy the mask before we shift the queue and destroy it */; 12533 if (mask_len > 0) {; 12534 memcpy(mask, buf + header_len - mask_len, sizeof(mask));; 12535 } else {; 12536 memset(mask, 0, sizeof(mask));; 12537 }; 12538 ; 12539 /* Read frame payload from the first message in the queue into; 12540 * data and advance the queue by moving the memory in place.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:363876,mask,mask,363876,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,5,['mask'],['mask']
Availability,"adient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 146 of file Minuit2Minimizer.h. ◆ Minimize(). bool ROOT::Minuit2::Minuit2Minimizer::Minimize ; (; ). overridevirtual . method to perform the minimization. ; Return false in case the minimization did not converge. In this case a status code different than zero is set (retrieved by the derived method Minimizer::Status() )""; status = 1 : Covariance was made pos defined status = 2 : Hesse is invalid status = 3 : Edm is above max status = 4 : Reached call limit status = 5 : Any other failure ; Implements ROOT::Math::Minimizer.; Definition at line 465 of file Minuit2Minimizer.cxx. ◆ MinosStatus(). int ROOT::Minuit2::Minuit2Minimizer::MinosStatus ; (; ); const. inlineoverridevirtual . MINOS status code of last Minos run status & 1 > 0 : invalid lower error status & 2 > 0 : invalid upper error status & 4 > 0 : invalid because maximum number of function calls exceeded status & 8 > 0 : a new minimum has been found status & 16 > 0 : error is truncated because parameter is at lower/upper limit. ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 234 of file Minuit2Minimizer.h. ◆ MinValue(). double ROOT::Minuit2::Minuit2Minimizer::MinValue ; (; ); const. inlineoverridevirtual . return minimum function value ; Implements ROOT::Math::Minimizer.; Definition at line 137 of file Minuit2Minimizer.h. ◆ NCalls(). unsigned int ROOT::Minuit2::Minuit2Minimizer::NCalls ; (; ); const. inlineoverridevirtual . number of function calls to reach the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 149 of file Minuit2Minimizer.h. ◆ NDim(). unsigned int ROOT::Minuit2::Minuit2Minimizer::NDim ; (; ); const. inlineoverridevirtual . this is <= Function().NDim() which is the total number of variables (free+ constrained ones) ; Implements ROOT::Math::Minimizer.; Definition at line 153 of file Minuit2Minimizer.h. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:21010,error,error,21010,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,3,['error'],['error']
Availability,"adientFunctionMultiDim>(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&); ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&operator=(const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>&). Data Members; public:. enum ROOT::Math::BasicFitMethodFunction::Type_t { kUndefined; kLeastSquare; kLogLikelihood; };. private:. const ROOT::Fit::UnBinData&fData; const ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::IModelFunction&fFunc; vector<double>fGradfor derivatives; boolfIsExtendedflag for indicating if likelihood is extended; unsigned intfNEffPointsnumber of effective points used in the fit ; intfWeightflag to indicate if needs to evaluate using weight or weight squared (default weight = 0). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseFunction * Clone() const; clone the function (need to return Base for Windows). { return new LogLikelihoodFCN(fData,fFunc,fWeight,fIsExtended); }. unsigned int NFitPoints() const; using BaseObjFunction::operator();; effective points used in the fit. { return fNEffPoints; }. double DataElement(const double* x, unsigned int i, double* g) const; i-th likelihood contribution and its gradient. void Gradient(const double* x, double* g) const; need to be virtual to be instantited. void UseSumOfWeightSquare(bool on = true); Use sum of the weight squared in evaluating the likelihood; (this is needed for calculating the errors). double DoEval(const double* x) const. Evaluation of the function (required by interface). double DoDerivative(const double* x, unsigned int icoord) const; for derivatives. » Author: L. Moneta Fri Aug 17 14:29:24 2007 » Copyright (c) 2007 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html:4309,error,errors,4309,root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__LogLikelihoodFCN_-p0Math__IGradientFunctionMultiDim_.html,2,['error'],['errors']
Availability,"ading...; Searching...; No Matches. rf609_xychi2fit.C File ReferenceTutorials » RooFit Tutorials. Detailed Description; Likelihood and minimization: setting up a chi^2 fit to an unbinned dataset with X,Y,err(Y) values (and optionally err(X) values) . ; #include ""RooRealVar.h""; #include ""RooDataSet.h""; #include ""RooPolyVar.h""; #include ""TCanvas.h""; #include ""TAxis.h""; #include ""RooPlot.h""; #include ""TRandom.h""; ; using namespace RooFit;; ; void rf609_xychi2fit(); {; // C r e a t e d a t a s e t w i t h X a n d Y v a l u e s; // -------------------------------------------------------------------; ; // Make weighted XY dataset with asymmetric errors stored; // The StoreError() argument is essential as it makes; // the dataset store the error in addition to the values; // of the observables. If errors on one or more observables; // are asymmetric, one can store the asymmetric error; // using the StoreAsymError() argument; ; RooRealVar x(""x"", ""x"", -11, 11);; RooRealVar y(""y"", ""y"", -10, 200);; RooDataSet dxy(""dxy"", ""dxy"", {x, y}, StoreError({x, y}));; ; // Fill an example dataset with X,err(X),Y,err(Y) values; for (int i = 0; i <= 10; i++) {; ; // Set X value and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf609__xychi2fit_8C.html:906,error,errors,906,doc/master/rf609__xychi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html,3,['error'],"['error', 'errors']"
Availability,"adlener, DESY,; Lorenzo Moneta, CERN/EP-SFT,; Alja Mrak Tadel, UCSD/CMS,; Axel Naumann, CERN/EP-SFT,; Dante Niewenhuis, VU Amsterdam; Luis Antonio Obis Aparicio, University of Zaragoza, Ianna Osborne, Princeton University,; Vincenzo Eduardo Padulano, CERN/EP-SFT,; Danilo Piparo, CERN/EP-SFT,; Fons Rademakers, CERN/IT,; Jonas Rembser, CERN/EP-SFT,; Andrea Rizzi, University of Pisa,; Andre Sailer, CERN/EP-SFT,; Garima Singh, ETH,; Juraj Smiesko, CERN/RCS-PRJ-FC, Pavlo Svirin, National Technical University of Ukraine,; Maciej Szymanski, Argonne,; Christian Tacke, Darmstadt University,; Matevz Tadel, UCSD/CMS,; Alvaro Tolosa Delgado, CERN/RCS-PRJ-FC,; Devajith Valaparambil Sreeramaswamy, CERN/EP-SFT,; Peter Van Gemmeren, Argonne,; Vassil Vassilev, Princeton/CMS,; Wouter Verkerke, NIKHEF/ATLAS, Stefan Wunsch; Deprecation and Removal. The RooFit legacy iterators are deprecated and will be removed in ROOT 6.34 (see section “RooFit libraries”); Some memory-unsafe RooFit interfaces were removed; Some redundant RooDataSet constructors are deprecated and will be removed in ROOT 6.34. Please use the RooDataSet constructors that take RooFit command arguments instead; ROOT does not longer support Python 2. The minimum required Python version to build ROOT is 3.8.; Support for wildcard imports like from ROOT import * is dropped from PyROOT; Support for external (ie. non-builtin) libAfterImage is now deprecated and it will be removed in next release 6.34.; The TList::TList(TObject*) constructor is deprecated and will be removed in ROOT 6.34; The deprecated TProofOutputList::TProofOutputList(TObject *o) constructor was removed. Core Libraries; The Cling interpreter now relies on LLVM version 16.; I/O Libraries; hadd respects compression settings; Fixed a bug that was previously changing the compression settings to a single digit number instead of the full value (by default 101).; TTree Libraries; Add files from subdirectories with TChain::Add globbing; It is now possible to add file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:3604,redundant,redundant,3604,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['redundant'],['redundant']
Availability,"admin interface. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TFileStager. ←; TXNetFileStager. Function documentation; TXNetFileStager(const char* stager = """"); Constructor. Init a TXNetSystem instance to the XRD system. ~TXNetFileStager(); Destructor. Bool_t IsStaged(const char* path); Check if the file defined by 'path' is ready to be used. Bool_t Stage(TCollection* pathlist, Option_t* opt = 0); Issue a stage request for file defined by 'path'. The string 'opt'; defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". Bool_t Stage(const char* path, Option_t* opt = 0); Issue a stage request for file defined by 'path'. The string 'opt'; defines 'option' and 'priority' for 'Prepare': the format is; opt = ""option=o priority=p"". void GetPrefix(const char* url, TString& pfx); Isolate prefix in url. void Print(Option_t* option = """") const; Print basic info about this stager. Int_t Locate(const char* path, TString& endpath); Get actual end-point url for a path; Returns 0 in case of success and 1 if any error occured. Int_t LocateCollection(TFileCollection* fc, Bool_t addDummyUrl = kFALSE); Bulk locate request for a collection of files. A noop prepare command is; issued beforehand to fill redirector's cache, then Locate() is issued on; each file. Results are saved back to the input collection: when a file is; found, the staged bit is set to on, and its endpoint URL is added, if; different from the redirector's URL. If a file is not found, the staged; bit is set to off.; If addDummyUrl is kTRUE, in case file is not staged or redirector is; identical to endpoint URL, a dummy URL is prepended, respectively:; ""noop://redir"" and ""noop://none"".; If the collection contains URLs with ""anchors"" (i.e., #fileName.root),; they are ignored by xrootd.; The Locate() command preserves anchors, but needs single paths to be full; URLs beginning with root://.; Returns < 0 in case of errors, and the number of files processed in case; of success. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFileStager.html:7782,error,error,7782,root/html602/TXNetFileStager.html,https://root.cern,https://root.cern/root/html602/TXNetFileStager.html,2,['error'],['error']
Availability,"af::GetLenStaticvirtual Int_t GetLenStatic() constReturn the fixed length of this leaf.Definition TLeaf.h:132; TLeaf::GetOffsetvirtual Int_t GetOffset() constDefinition TLeaf.h:137; TLeaf::ReadBasketvirtual void ReadBasket(TBuffer &)Definition TLeaf.h:152; TLeaf::fLeafCountValuesLeafCountValues * fLeafCountValues! Cache of collection/array sizesDefinition TLeaf.h:79; TLeaf::GenerateOffsetArrayvirtual Int_t * GenerateOffsetArray(Int_t base, Int_t events)Definition TLeaf.h:115; TLeaf::SetRangevirtual void SetRange(bool range=true)Definition TLeaf.h:165; TLeaf::Counts_tstd::vector< Int_t > Counts_tDefinition TLeaf.h:65; TLeaf::Importvirtual void Import(TClonesArray *, Int_t)Definition TLeaf.h:147; TLeaf::PrintValuevirtual void PrintValue(Int_t i=0) constDefinition TLeaf.h:184; TLeaf::IsRangevirtual bool IsRange() constDefinition TLeaf.h:149; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TStringBasic string class.Definition TString.h:139; double; int; TLeaf::GetValueHelper< Long64_t >::Execstatic Long64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:173; TLeaf::GetValueHelper< LongDouble_t >::Execstatic LongDouble_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:179; TLeaf::GetValueHelper< ULong64_t >::Execstatic ULong64_t Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:176; TLeaf::GetValueHelperDefinition TLeaf.h:84; TLeaf::GetValueHelper::Execstatic T Exec(const TLeaf *leaf, Int_t i=0)Definition TLeaf.h:85; TLeaf::LeafCountValuesDefinition TLeaf.h:66; TLeaf::LeafCountValues::fValuesCounts_t fValuesDefinition TLeaf.h:67; TLeaf::LeafCountValues::fStartEntryLong64_t fStartEntry! entry number of corresponding to element 0 of the vector.Definition TLeaf.h:68. treetreeincTLeaf.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:04 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8h_source.html:18805,error,error,18805,doc/master/TLeaf_8h_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8h_source.html,1,['error'],['error']
Availability,after a fit using the FitResult. ; Definition at line 243 of file FitConfig.h. ◆ SetWeightCorrection(). void ROOT::Fit::FitConfig::SetWeightCorrection ; (; bool ; on = true). inline . apply the weight correction for error matrix computation ; Definition at line 232 of file FitConfig.h. ◆ UpdateAfterFit(). bool ROOT::Fit::FitConfig::UpdateAfterFit ; (; ); const. inline . Update configuration after a fit using the FitResult. ; Definition at line 211 of file FitConfig.h. ◆ UseWeightCorrection(). bool ROOT::Fit::FitConfig::UseWeightCorrection ; (; ); const. inline . Apply Weight correction for error matrix computation. ; Definition at line 214 of file FitConfig.h. Member Data Documentation. ◆ fMinimizerOpts. ROOT::Math::MinimizerOptions ROOT::Fit::FitConfig::fMinimizerOpts. private . minimizer control parameters including name and algo type ; Definition at line 268 of file FitConfig.h. ◆ fMinosErrors. bool ROOT::Fit::FitConfig::fMinosErrors. private . do full error analysis using Minos ; Definition at line 261 of file FitConfig.h. ◆ fMinosParams. std::vector<unsigned int> ROOT::Fit::FitConfig::fMinosParams. private . vector with the parameter indices for running Minos ; Definition at line 266 of file FitConfig.h. ◆ fNormErrors. bool ROOT::Fit::FitConfig::fNormErrors. private . flag for error normalization ; Definition at line 259 of file FitConfig.h. ◆ fParabErrors. bool ROOT::Fit::FitConfig::fParabErrors. private . get correct parabolic errors estimate (call Hesse after minimizing) ; Definition at line 260 of file FitConfig.h. ◆ fSettings. std::vector<ROOT::Fit::ParameterSettings> ROOT::Fit::FitConfig::fSettings. private . vector with the parameter settings ; Definition at line 265 of file FitConfig.h. ◆ fUpdateAfterFit. bool ROOT::Fit::FitConfig::fUpdateAfterFit. private . update the configuration after a fit using the result ; Definition at line 262 of file FitConfig.h. ◆ fWeightCorr. bool ROOT::Fit::FitConfig::fWeightCorr. private . apply correction to errors for wei,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html:12252,error,error,12252,doc/master/classROOT_1_1Fit_1_1FitConfig.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitConfig.html,1,['error'],['error']
Availability,"ag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ←; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). {fLevel = level;}. void SetMode(double mode). set the mode. void SetArea(double area). set the area. » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-02 14:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuranSampler.html:4012,error,error,4012,root/html602/TUnuranSampler.html,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html,2,['error'],['error']
Availability,"ag to indicate if a mode is set; intfLeveldebug level; doublefModemode of dist; boolfOneDimflag to indicate if the function is 1 dimension; TUnuran*fUnuranunuran engine class. Class Charts. Inheritance Chart:. ROOT::Math::DistSampler. ←; TUnuranSampler. Function documentation; TUnuranSampler(). ~TUnuranSampler(). bool Init(const char* algo = """"); initialize unuran classes using the given algorithm. bool Init(const ROOT::Math::DistSamplerOptions& opt); default initialization with algorithm name. bool DoInit1D(const char* algo); initilize for 1D sampling; need to create 1D interface from Multidim one; (to do: use directly 1D functions ??). bool DoInitDiscrete1D(const char* algo); initilize for 1D sampling of discrete distributions. bool DoInitND(const char* algo); initilize for 1D sampling. void SetFunction(TF1* pdf); set function from a TF1 pointer. void SetRandom(TRandom* r); set random generator (must be called before Init to have effect). void SetSeed(unsigned int seed); set random generator seed (must be called before Init to have effect). TRandom * GetRandom(); get random generator used. double Sample1D(); sample 1D distributions. bool Sample(double* x); sample multi-dim distributions. bool SampleBin(double prob, double& value, double* error = 0); sample a bin according to Poisson statistics. TUnuranSampler(); default constructor. void SetFunction(const ROOT::Math::IGenFunction& func); set the parent function distribution to use for random sampling (one dim case). void SetPrintLevel(int level). Set the print level; (if level=-1 use default). {fLevel = level;}. void SetMode(double mode). set the mode. void SetArea(double area). set the area. » Author: L. Moneta Fri Sep 22 15:06:47 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnuranSampler.html:4012,error,error,4012,root/html604/TUnuranSampler.html,https://root.cern,https://root.cern/root/html604/TUnuranSampler.html,2,['error'],['error']
Availability,"ag will rotate the view;; Some keys can be pressed when the view canvas is selected: J/K zoom/un-zoom, U/I move up/down, L/H move left/right. The coordinate axes display as well as changing top or side viewpoints can be activated from the TView context menu: right-click on the picture when no object is selected;. Q: “Every line is black! I cannot figure out what is what…”; A: Volumes can have different colors (those known by ROOT of course). Think at using them after each volume creation: myvolume->SetLineColor(Int_t color); otherwise everything is by default black.; Q: “The top volume of my geometry is a box but I see only its content.”; A: By default the drawn volume is not displayed just because we do not want to hide its content when changing the view to HLR or solid mode. In order to see it in the default wire frame picture one has to call TGeoManager::SetTopVisible().; Q: “I do not see all volumes in my tree but just something inside.”; A: By default, TGeoVolume::Draw() paints the content of a given volume three levels down. You can change this by using: gGeoManager::SetVisLevel(n);; Not only that, but none of the volumes at intermediate levels (0-2) are visible on the drawing unless they are final ‘leaves’ on their branch (e.g. have no other volumes positioned inside). This behavior is the default one and corresponds to ‘leaves’ global visualization mode (TGeoManager::fVisOption = 1). In order to see on the screen the intermediate containers, one can change this mode: gGeoManager->SetVisOption(0).; Q: “Volumes are highlighted when moving the mouse over their vertices. What does it mean?”; A: Indeed, moving the mouse close to some volume vertices selects it. By checking the Event Status entry in the root canvas Options menu, you will see exactly which is the selected node in the bottom right. Right-clicking when a volume is selected will open its context menu where several actions can be performed (e.g. drawing it).; Q: “OK, but now I do not want to see all th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1007358,down,down,1007358,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['down'],['down']
Availability,"age has to be enqueued.; Returns 0 otherwise. Bool_t AcceptResults(Int_t connections, TVirtualProofPlayer* mergerPlayer); Accept and merge results from a set of workers. void HandleUrgentData(); Handle Out-Of-Band data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore (i.e. when kKeepAlive; has failed). Bool_t IsParallel() const; True if in parallel mode. void Print(Option_t* option = """") const; Print status of slave server. void RedirectOutput(const char* dir = 0, const char* mode = ""w""); Redirect stdout to a log file. This log file will be flushed to the; client or master after each command. void Reset(const char* dir); Reset PROOF environment to be ready for execution of next command. Int_t ReceiveFile(const char* file, Bool_t bin, Long64_t size); Receive a file, either sent by a client or a master server.; If bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void Run(Bool_t retrn = kFALSE); Main server eventloop. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. void SendStatistics(); Send statistics of slave server to master or client. void SendParallel(Bool_t async = kFALSE); Send number of parallel nodes to master or client. Int_t UnloadPackage(const char* package); Removes link to package in working directory,; removes entry from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup pha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:23333,error,error,23333,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,10,['error'],['error']
Availability,"age size>{G,g,M,m,K,k}. Long64_t ToBytes(const char* size = 0); Static utility function to gt the number of bytes from a string; representation in the form ""<digit><sfx>"" with <sfx> = {"""", ""k"", ""M"", ""G"",; ""T"", ""P""} (case insensitive).; Returns -1 if the format is wrong. TFileCollection * GetDataSet(const char* uri, const char* server = 0); Utility function used in various methods for user dataset upload. Bool_t RemoveDataSet(const char* uri); Removes the indicated dataset. Bool_t ExistsDataSet(const char* uri); Checks if the indicated dataset exits. TMap * GetDataSets(const char* uri, UInt_t = TDataSetManager::kExport). Returns all datasets for the <group> and <user> specified by <uri>.; If <user> is 0, it returns all datasets for the given <group>.; If <group> is 0, it returns all datasets.; The returned TMap contains:; <group> --> <map of users> --> <map of datasets> --> <dataset> (TFileCollection). The unsigned int 'option' is forwarded to GetDataSet and BrowseDataSet.; Available options (to be .or.ed):; kShowDefault a default selection is shown that include the ones from; the current user, the ones from the group and the common ones; kPrint print the dataset content; kQuotaUpdate update quotas; kExport use export naming. NB1: options ""kPrint"", ""kQuoatUpdate"" and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t ScanDataSet(const char* uri, const char* opt); Scans the dataset indicated by 'uri' following the 'opts' directives. The 'opts' string contains up to 4 directive fields separated by ':'. 'selection' field :; A, allfiles: process all files; D, staged: process only staged (on Disk) files (if 'allfiles:' is not specified; the default is to process only files marked as non-staged); 'pre-action field':; O, open: open the files marked as staged when processing only files; marked as non-staged; T, touch: open and touch the files marked as staged when processing; only files marked as non-staged; I, nostagedcheck:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDataSetManager.html:11459,Avail,Available,11459,root/html532/TDataSetManager.html,https://root.cern,https://root.cern/root/html532/TDataSetManager.html,4,['Avail'],['Available']
Availability,"age(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR file is downloaded in the current directory or in the directory; specified by 'dstdir'. If a package with the same name already exists; at destination, a check on the MD5 sum is done and the user warned or; prompted for action, depending is the file is equal or different.; Returns 0 in case of success and -1 in case of error. Int_t UploadPackage(const char* par, TProof::EUploadPackageOpt opt = kUntar); Upload a PROOF archive (PAR file). A PAR file is a compressed; tar file with one special additional directory, PROOF-INF; (blatantly copied from Java's jar format). It must have the extension; .par. A PAR file can be directly a binary or a source with a build; procedure. In the PROOF-INF directory there can be a build script:; BUILD.sh to be called to build the package, in case of a binary PAR; file don't specify a bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:65432,error,error,65432,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['error'],['error']
Availability,"age); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:71563,error,error,71563,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['error'],['error']
Availability,"age. ; It is a special case of the generic Echo() that works with TObjects. Returns -1 on error, the number of workers that received the message on success. ; Definition at line 7042 of file TProof.cxx. ◆ Echo() [2/2]. Int_t TProof::Echo ; (; const TObject * ; obj). virtual . Sends an object to master and workers and expect them to send back a message with the output of its TObject::Print(). ; Returns -1 on error, the number of workers that received the objects on success. ; Definition at line 7028 of file TProof.cxx. ◆ EnablePackage() [1/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. If specified, enables packages only on the specified workers. Returns 0 in case of success and -1 in case of error. Provided for backward compatibility. ; Definition at line 8175 of file TProof.cxx. ◆ EnablePackage() [2/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . const char * ; loadopts, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. It is is possible to specify options for the loading step via 'loadopts'; the string will be passed passed as argument to SETUP. Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control plugin version checking during building: possible choices are: off no check; failure may occur at loading on check ROOT version [default] svn check ROOT version and Git commit SHA1. (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.) If specified, enables packages",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:86254,error,error,86254,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,"age. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error.; Provided for backward compatibility. Int_t EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify options for the loading step via 'loadopts';; the string will be passed passed as argument to SETUP.; Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control; plugin version checking during building: possible choices are:; off no check; failure may occur at loading; on check ROOT version [default]; svn check ROOT version and SVN revision number.; (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.); If specified, enables packages only on the specified workers.; Returns 0 in case of success and -1 in case of error. Int_t EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Enable specified package. Executes the PROOF-INF/BUILD.sh; script if it exists followed by the PROOF-INF/SETUP.C script.; In case notOnClient = true, don't enable the package on the client.; The default is to enable packages also on the client.; It is is possible to specify a list of objects to be passed to the SETUP; functions via 'loadopts'; the objects must be streamable.; Returns 0 in case of success and -1 in case of error. Int_t DownloadPackage(const char* par, const char* dstdir = 0); Download a PROOF archive (PAR file) from the master package repository.; The PAR fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:75002,failure,failure,75002,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['failure'],['failure']
Availability,"ager; GetName() const overrideTNamedinlinevirtual; GetNextNode() constTGeoManagerinline; GetNmany() constTGeoManagerinline; GetNNodes()TGeoManagerinline; GetNode(Int_t level) constTGeoManagerinline; GetNodeId() constTGeoManagerinline; GetNormal() constTGeoManagerinline; GetNproperties() constTGeoManagerinline; GetNregions() constTGeoManagerinline; GetNsegments() constTGeoManager; GetNtracks() constTGeoManagerinline; GetNumThreads()TGeoManagerstatic; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOpticalSurface(const char *name) constTGeoManager; GetOption() constTObjectinlinevirtual; GetPainter() constTGeoManagerinline; GetPaintVolume() constTGeoManagerinline; GetParallelWorld() constTGeoManagerinline; GetParentTrackOfId(Int_t id) constTGeoManager; GetParticleName() constTGeoManagerinline; GetPath() constTGeoManager; GetPdgName(Int_t pdg) constTGeoManager; GetPhysicalNode(Int_t i) constTGeoManagerinline; GetProperty(const char *name, Bool_t *error=nullptr) constTGeoManager; GetProperty(size_t i, TString &name, Bool_t *error=nullptr) constTGeoManager; GetRegion(int i)TGeoManagerinline; GetRTmode() constTGeoManagerinline; GetSafeDistance() constTGeoManagerinline; GetSafeLevel() constTGeoManager; GetSkinSurface(const char *name) constTGeoManager; GetStackLevel() constTGeoManagerinline; GetStep() constTGeoManagerinline; GetTitle() const overrideTNamedinlinevirtual; GetTmax() constTGeoManagerinline; GetTminTmax(Double_t &tmin, Double_t &tmax) constTGeoManager; GetTopNode() constTGeoManagerinline; GetTopVolume() constTGeoManagerinline; GetTrack(Int_t index)TGeoManagerinline; GetTrackIndex(Int_t id) constTGeoManager; GetTrackOfId(Int_t id) constTGeoManager; GetUID(const char *volname) constTGeoManager; GetUniqueID() constTObjectvirtual; GetUserPaintVolume() constTGeoManagerinline; GetVerboseLevel()TGeoManagerstatic; GetVirtualLevel()TGeoManager; GetVisDensity() constTGeoManagerinline; GetVisLevel() constTGeoManager; GetVisOption() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager-members.html:12373,error,error,12373,doc/master/classTGeoManager-members.html,https://root.cern,https://root.cern/doc/master/classTGeoManager-members.html,1,['error'],['error']
Availability,"ages from the related file. ; Definition at line 240 of file TProofServ.cxx. ◆ TProofServLogHandler() [2/2]. TProofServLogHandler::TProofServLogHandler ; (; FILE * ; f, . TSocket * ; s, . const char * ; pfx = """" . ). Handle available message from the open file 'f'. ; Definition at line 268 of file TProofServ.cxx. ◆ ~TProofServLogHandler(). TProofServLogHandler::~TProofServLogHandler ; (; ). override . Handle available message in the open file. ; Definition at line 286 of file TProofServ.cxx. Member Function Documentation. ◆ GetCmdRtn(). Int_t TProofServLogHandler::GetCmdRtn ; (; ). static . Static method to get the return code from the execution of a command via the pipe. ; This is always 0 when the log handler is not used with a pipe ; Definition at line 344 of file TProofServ.cxx. ◆ IsValid(). Bool_t TProofServLogHandler::IsValid ; (; ). inline . Definition at line 390 of file TProofServ.h. ◆ Notify(). Bool_t TProofServLogHandler::Notify ; (; ). overridevirtual . Handle available message in the open file. ; Reimplemented from TFileHandler.; Definition at line 303 of file TProofServ.cxx. ◆ ReadNotify(). Bool_t TProofServLogHandler::ReadNotify ; (; ). inlineoverridevirtual . Notify when something can be read from the descriptor associated with this handler. ; Reimplemented from TFileHandler.; Definition at line 393 of file TProofServ.h. ◆ SetDefaultPrefix(). void TProofServLogHandler::SetDefaultPrefix ; (; const char * ; pfx). static . Static method to set the default prefix. ; Definition at line 336 of file TProofServ.cxx. Member Data Documentation. ◆ fFile. FILE* TProofServLogHandler::fFile. private . Definition at line 378 of file TProofServ.h. ◆ fgCmdRtn. Int_t TProofServLogHandler::fgCmdRtn = 0. staticprivate . Definition at line 382 of file TProofServ.h. ◆ fgPfx. TString TProofServLogHandler::fgPfx = """". staticprivate . Definition at line 381 of file TProofServ.h. ◆ fPfx. TString TProofServLogHandler::fPfx. private . Definition at line 379 of file TProofServ.h.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLogHandler.html:18763,avail,available,18763,doc/master/classTProofServLogHandler.html,https://root.cern,https://root.cern/doc/master/classTProofServLogHandler.html,1,['avail'],['available']
Availability,"ages the return object ;  ; TClass * IsA () const override;  ; bool IsInInterval (const RooArgSet &) const override;  check if given point is in the interval ;  ; double LowerLimit (const RooRealVar &param);  return the lower bound of the interval on a given parameter ;  ; double LowerLimit (const RooRealVar &param, bool &status);  Compute lower limit, check first if limit has been computed status is a boolean flag which will b set to false in case of error and is true if calculation is successful in case of error return also a lower limit value of zero. ;  ; void SetConfidenceLevel (double cl) override;  set the confidence level for the interval (e.g 0.682 for a 1-sigma interval) ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; double UpperLimit (const RooRealVar &param);  return the upper bound of the interval on a given parameter ;  ; double UpperLimit (const RooRealVar &param, bool &status);  Compute upper limit, check first if limit has been computed status is a boolean flag which will b set to false in case of error and is true if calculation is successful in case of error return also a lower limit value of zero. ;  ;  Public Member Functions inherited from RooStats::ConfInterval;  ConfInterval (const char *name=nullptr);  constructor given name and title ;  ; ConfInterval & operator= (const ConfInterval &other);  operator= ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html:3998,error,error,3998,doc/master/classRooStats_1_1LikelihoodInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1LikelihoodInterval.html,2,['error'],['error']
Availability,"aget axes will be; kept, but only bins inside the selected range will be filled. The option can also be used to specify the projected profile error type.; Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProfileX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProfileX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts ("","" means logical AND):; myhist->ProfileX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TProfile named ""name"" exists in the current directory or pad with; a compatible axis the profile is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the profile. NOTE that the default under- / overflow behavior differs from what ProjectionX; does! Profiles take the bin center into account, so here the under- and overflow; bins are ignored by default. TProfile * ProfileY(const char* name = ""_pfy"", Int_t firstxbin = 1, Int_t lastxbin = -1, Option_t* option = """") const; *-*-*-*-*Project a 2-D histogram into a profile histogram along Y*-*-*-*-*-*; *-* ========================================================. The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, bins 1 to nx are included; When all bins are included, the number of entries in the projection; is set to the number of entries of the 2-D histogram, otherwise; the number of entries is incremented by 1 for all non empty cells. if option ""d"" is specified, the profile is drawn in the current pad. if opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:44348,error,error,44348,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,4,['error'],['error']
Availability,"agging in combination with boost on/off ;  ; Bool_t fBaggedGradBoost;  turn bagging in combination with grad boost on/off ;  ; Double_t fBaggedSampleFraction;  relative size of bagged event sample to original sample size ;  ; TString fBoostType;  string specifying the boost type ;  ; Double_t fBoostWeight;  ntuple var: boost weight ;  ; std::vector< double > fBoostWeights;  the weights applied in the individual boosts ;  ; Double_t fCbb;  Cost factor. ;  ; Double_t fCss;  Cost factor. ;  ; Double_t fCtb_ss;  Cost factor. ;  ; Double_t fCts_sb;  Cost factor. ;  ; Bool_t fDoBoostMonitor;  create control plot with ROC integral vs tree number ;  ; Bool_t fDoPreselection;  do or do not perform automatic pre-selection of 100% eff. cuts ;  ; Double_t fErrorFraction;  ntuple var: misclassification error fraction ;  ; std::vector< const TMVA::Event * > fEventSample;  the training events ;  ; std::vector< DecisionTree * > fForest;  the collection of decision trees ;  ; Double_t fFValidationEvents;  fraction of events to use for pruning ;  ; std::vector< Double_t > fHighBkgCut;  ; std::vector< Double_t > fHighSigCut;  ; Bool_t fHistoricBool;  ; Double_t fHuberQuantile;  the option string determining the quantile for the Huber Loss Function in BDT regression. ;  ; Bool_t fInverseBoostNegWeights;  boost ev. with neg. weights with 1/boostweight rather than boostweight ;  ; std::vector< Bool_t > fIsHighBkgCut;  ; std::vector< Bool_t > fIsHighSigCut;  ; std::vector< Bool_t > fIsLowBkgCut;  ; std::vector< Bool_t > fIsLowSigCut;  ; Int_t fITree;  ntuple var: ith tree ;  ; std::map< const TMVA::Event *, LossFunctionEventInfo > fLossFunctionEventInfo;  map event to true value, predicted value, and weight used by different loss functions for BDT regression ;  ; std::vector< Double_t > fLowBkgCut;  ; std::vector< Double_t > fLowSigCut;  ; UInt_t fMaxDepth;  max depth ;  ; Double_t fMinLinCorrForFisher;  the minimum linear correlation between two variables demanded for use in fisher criter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:35025,error,error,35025,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['error'],['error']
Availability,"ails. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Saving the result of Draw to a TEventList or a TEntryList. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTree::Draw); yplus.Print(""all""); to print the list of entry numbers in the list.; tree.Draw("">>yplus"", ""y>0"", ""entrylist""); will create a TEntryList object names ""yplus"" in the current directory. By default, the specified entry list is reset.; To continue to append data to an existing list, use ""+"" in front; of the list name;; tree.Draw("">>+yplus"",""y>0""); wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:77475,error,error,77475,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['error'],['error']
Availability,"ailure. ;  ; void ResetSignal (ESignals sig, Bool_t reset=kTRUE) override;  If reset is true reset the signal handler for the specified signal to the default handler, else restore previous behaviour. ;  ; void ResetSignals () override;  Reset signals handlers to previous behaviour. ;  ; Int_t Select (TFileHandler *fh, Long_t timeout) override;  Select on the file descriptor related to file handler h. ;  ; Int_t Select (TList *active, Long_t timeout) override;  Select on file descriptors. The timeout to is in millisec. ;  ; int SendBuf (int sock, const void *buffer, int length) override;  Send a buffer headed by a length indicator. ;  ; int SendRaw (int sock, const void *buffer, int length, int flag) override;  Send exactly length bytes from buffer. ;  ; void SetDynamicPath (const char *path) override;  Set the dynamic path to a new value. ;  ; void Setenv (const char *name, const char *value) override;  Set environment variable. ;  ; Int_t SetFPEMask (Int_t mask=kDefaultMask) override;  Set which conditions trigger a floating point exception. ;  ; void SetGUIThreadMsgHandler (ThreadMsgFunc_t func);  Set the (static part of) the event handler func for GUI messages. ;  ; int SetNonBlock (int fd);  Make descriptor fd non-blocking. ;  ; void SetProgname (const char *name) override;  Set the application name (from command line, argv[0]) and copy it in gProgName. ;  ; int SetSockOpt (int sock, int opt, int val) override;  Set socket option. ;  ; void Sleep (UInt_t milliSec) override;  Sleep milliSec milli seconds. ;  ; void StackTrace () override;  Print a stack trace, if gEnv entry ""Root.Stacktrace"" is unset or 1, and if the image helper functions can be found (see InitImagehlpFunctions()). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Symlink (const char *from, const char *to) override;  Create a symlink from file1 to file2. ;  ; const char * TempDirectory () const o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:11903,mask,mask,11903,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['mask'],['mask']
Availability,"ain with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH1D* QuantilesX(Double_t prob = 0.5, const char* name = ""_qx"") const; Compute the X distribution of quantiles in the other variable Y; name is the name of the returned histogram; prob is the probability content for the quantile (0.5 is the default for the median); An approximate error for the quantile is computed assuming that the distribution in; the other variable is normal. TH1D* QuantilesY(Double_t prob = 0.5, const char* name = ""_qy"") const; Compute the Y distribution of quantiles in the other variable X; name is the name of the returned histogram; prob is the probability content for the quantile (0.5 is the default for the median); An approximate error for the quantile is computed assuming that the distribution in; the other variable is normal. TH1D* DoQuantiles(bool onX, const char* name, Double_t prob) const; Implementation of quantiles for x or y. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc. void SetBinContent(Int_t bin, Double_t content); Set bin content. void SetShowProjectionX(Int_t nbins = 1); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins = 1); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""same""); This funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH2.html:55359,error,error,55359,root/html602/TH2.html,https://root.cern,https://root.cern/root/html602/TH2.html,4,['error'],['error']
Availability,"ain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual Long64_t Scan (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over tree entries and print entries passing selection. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TBranch **ptr=nullptr);  Change branch address, dealing with clone trees properly. ;  ; virtual Int_t SetBranchAddress (const char *bname, void *add, TClass *realClass, EDataType datatype, bool isptr);  Verify the validity of the type of addr before calling SetBranchAddress. ;  ; virtual void SetBranchStatus (const char *bname, bool s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:20015,recover,recover,20015,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['recover'],['recover']
Availability,"ain; 166/// function, but in the inherited class the function makes no sense.; 167 ; 168void MayNotUse(const char *method); 169{; 170 Warning(method, ""may not use this method"");; 171}; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// Use this function to declare a function obsolete. Specify as of which version; 175/// the method is obsolete and as from which version it will be removed.; 176 ; 177void Obsolete(const char *function, const char *asOfVers, const char *removedFromVers); 178{; 179 Warning(function, ""obsolete as of %s and will be removed from %s"", asOfVers, removedFromVers);; 180}; 181 ; 182////////////////////////////////////////////////////////////////////////////////; 183/// Use this function in case an error occurred.; 184 ; 185void Error(const char *location, const char *fmt, ...); 186{; 187 std::va_list ap;; 188 va_start(ap, fmt);; 189 ErrorHandler(kError, location, fmt, ap);; 190 va_end(ap);; 191}; 192 ; 193////////////////////////////////////////////////////////////////////////////////; 194/// Use this function in case a system (OS or GUI) related error occurred.; 195 ; 196void SysError(const char *location, const char *fmt, ...); 197{; 198 std::va_list ap;; 199 va_start(ap, fmt);; 200 ErrorHandler(kSysError, location, fmt, ap);; 201 va_end(ap);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:6668,error,error,6668,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability,"ainIndex(); TChainIndex(const TChainIndex&); TChainIndex(const TTree* T, const char* majorname, const char* minorname); virtual~TChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Int_t major, Int_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Int_t major, Int_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; virtual TTreeFo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TChainIndex.html:1358,Error,Error,1358,root/html532/TChainIndex.html,https://root.cern,https://root.cern/root/html532/TChainIndex.html,1,['Error'],['Error']
Availability,"ainIndex(); TChainIndex(const TChainIndex&); TChainIndex(const TTree* T, const char* majorname, const char* minorname); virtual~TChainIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntryNumberFriend(const TTree* parent); virtual Long64_tGetEntryNumberWithBestIndex(Long64_t major, Long64_t minor) const; virtual Long64_tGetEntryNumberWithIndex(Long64_t major, Long64_t minor) const; virtual const char*TObject::GetIconName() const; virtual TTreeFormula*GetMajorFormulaParent(const TTree* parent); virtual const char*GetMajorName() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChainIndex.html:1358,Error,Error,1358,root/html534/TChainIndex.html,https://root.cern,https://root.cern/root/html534/TChainIndex.html,1,['Error'],['Error']
Availability,"ained only to variable parameters. int CovMatrixStatus() const. return the status of the covariance matrix. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int i) const. get global correlation coefficient for the variable i. This is a number between zero and one which gives; the correlation between the i-th variable and that linear combination of all other variables which; is most strongly correlated with i.; If the variable is fixed or const the return value is zero. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0). get the minos error for parameter i, return false if Minos failed; A minimizaiton must be performed befre, return false if no minimization has been done; In case of Minos failed the status error is updated as following; status += 10 * minosStatus where the minos status is:; status = 1 : maximum number of function calls exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:9217,error,error,9217,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,14,"['error', 'failure']","['error', 'failure']"
Availability,"aining = useForTraining;; 1212 requestedTesting = useForTesting;; 1213 }; 1214 ; 1215 else if (requestedTesting == 0){; 1216 // case B; 1217 useForTraining = TMath::Max(requestedTraining,availableTraining);; 1218 if (allAvailable < useForTraining) {; 1219 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested for training (""; 1220 << requestedTraining << "") than available (""; 1221 << allAvailable << "")!"" << Endl;; 1222 }; 1223 useForTesting = allAvailable - useForTraining; // the rest; 1224 requestedTesting = useForTesting;; 1225 }; 1226 ; 1227 else if (requestedTraining == 0){ // case B); 1228 useForTesting = TMath::Max(requestedTesting,availableTesting);; 1229 if (allAvailable < useForTesting) {; 1230 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested for testing (""; 1231 << requestedTesting << "") than available (""; 1232 << allAvailable << "")!"" << Endl;; 1233 }; 1234 useForTraining= allAvailable - useForTesting; // the rest; 1235 requestedTraining = useForTraining;; 1236 }; 1237 ; 1238 else {; 1239 // Case A; 1240 // requestedTraining R and requestedTesting S >0; 1241 // free events: Nfree = u-Thet(R-r)-Thet(S-s); 1242 // nR = Max(R,r) + 0.5 * Nfree; 1243 // nS = Max(S,s) + 0.5 * Nfree; 1244 Int_t stillNeedForTraining = TMath::Max(requestedTraining-availableTraining,0);; 1245 Int_t stillNeedForTesting = TMath::Max(requestedTesting-availableTesting,0);; 1246 ; 1247 int NFree = availableUndefined - stillNeedForTraining - stillNeedForTesting;; 1248 if (NFree <0) NFree = 0;; 1249 useForTraining = TMath::Max(requestedTraining,availableTraining) + NFree/2;; 1250 useForTesting= allAvailable - useForTraining; // the rest; 1251 }; 1252 ; 1253 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select training sample from=""<<useForTraining<<Endl;; 1254 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select test sample from=""<<useForTestin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:53753,avail,available,53753,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['avail'],['available']
Availability,"aining streamer infos. ; In case the message contains streamer infos they are imported, the message will be deleted and the method returns kTRUE. ; Definition at line 928 of file TSocket.cxx. ◆ Select(). Int_t TSocket::Select ; (; Int_t ; interest = kRead, . Long_t ; timeout = -1 . ). virtual . Waits for this socket to change status. ; If interest=kRead, the socket will be watched to see if characters become available for reading; if interest=kWrite the socket will be watched to see if a write will not block. The argument 'timeout' specifies a maximum time to wait in millisec. Default no timeout. Returns 1 if a change of status of interest has been detected within timeout; 0 in case of timeout; < 0 if an error occured. ; Definition at line 443 of file TSocket.cxx. ◆ Send() [1/4]. Int_t TSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). virtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 500 of file TSocket.cxx. ◆ Send() [2/4]. Int_t TSocket::Send ; (; const TMessage & ; mess). virtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). support for streaming TStreamerInfo added by Rene Brun May 2008 support for streaming TProcessID added by Rene Brun June 2008 ; Reimplemented in TServerSocket, TPSocket, and TSSLSocket.; Definition at line 522 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:35030,error,error,35030,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['error'],['error']
Availability,"aining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction3Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Sep 8 17:42:05 2015 » Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html:46482,ERROR,ERROR,46482,root/html604/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html604/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,1,['ERROR'],['ERROR']
Availability,"aining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction3Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Sep 8 17:42:07 2015 » Last generated: 2015-09-08 17:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html:46482,ERROR,ERROR,46482,root/html604/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html604/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,1,['ERROR'],['ERROR']
Availability,"ains the k_th element; 1422 }; 1423 }; 1424}; 1425 ; 1426#endif; IsNaN#define IsNaN(a)Definition HypoTestResult.cxx:69; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; LongDouble_tlong double LongDouble_tDefinition RtypesCore.h:61; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; CrossTGLVector3 Cross(const TGLVector3 &v1, const TGLVector3 &v2)Definition TGLUtil.h:323; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; npOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:50924,error,error,50924,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['error'],['error']
Availability,"ait forever). Int_t CollectInput(); Collect and analyze available input from the socket.; Returns 0 on success, -1 if any failure occurs. void RecvLogFile(Int_t size); Receive the log file from the server. Int_t SendObject(const TObject* obj); Send object to server.; Return 0 on success, -1 in case of error. Bool_t CheckFile(const char* file, Long_t modtime); Check if a file needs to be send to the server. Use the following; algorithm:; - check if file appears in file map; - if yes, get file's modtime and check against time in map,; if modtime not same get md5 and compare against md5 in map,; if not same return kTRUE.; - if no, get file's md5 and modtime and store in file map, ask; slave if file exists with specific md5, if yes return kFALSE,; if no return kTRUE.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = kAscii, const char* rfile = 0); Send a file to the server. Return 0 on success, -1 in case of error.; If defined, the full path of the remote path will be rfile.; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run). void Terminate(Int_t status = 0); Terminate this session. void SetPortParam(Int_t lower = -1, Int_t upper = -1, Int_t attempts = -1); Set port parameters for tunnelling. A value of -1 means unchanged. Long_t ProcessLine(const char* line, Bool_t = kFALSE, Int_t* error = 0); Parse a single command line and forward the request to the remote server; where it will be processed. The line is either a C++ statement or an; interpreter command starting with a ""."".; Return the return value of the command casted to a long. void Print(Option_t* option = """") const; Print some info about this instanc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationRemote.html:15698,error,error,15698,root/html526/TApplicationRemote.html,https://root.cern,https://root.cern/root/html526/TApplicationRemote.html,11,['error'],['error']
Availability,"ake an extra unsigned int slot as its first parameter. slot will take a different value, 0 to nThreads - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach() actions when using RDataFrame after ROOT::EnableImplicitMT(). ForeachSlot() works just as well with single-thread execution: in that case slot will always be 0. . Snapshot() Write the processed dataset to disk, in a new TTree and TFile. Custom columns can be saved as well, filtered entries are not saved. Users can specify which columns to save (default is all). Snapshot, by default, overwrites the output file if it already exists. Snapshot() can be made lazy setting the appropriate flag in the snapshot options. . Queries; These operations do not modify the dataframe or book computations but simply return information on the RDataFrame object. Operation Description . Describe() Get useful information describing the dataframe, e.g. columns and their types. . GetColumnNames() Get the names of all the available columns of the dataset. . GetColumnType() Return the type of a given column as a string. . GetColumnTypeNamesList() Return the list of type names of columns in the dataset. . GetDefinedColumnNames() Get the names of all the defined columns. . GetFilterNames() Return the names of all filters in the computation graph. . GetNRuns() Return the number of event loops run by this RDataFrame instance so far. . GetNSlots() Return the number of processing slots that RDataFrame will use during the event loop (i.e. the concurrency level). . SaveGraph() Store the computation graph of an RDataFrame in DOT format (graphviz) for easy inspection. See the relevant section for details. . Introduction; Users define their analysis as a sequence of operations to be performed on the dataframe object; the framework takes care of the management of the loop over entries as well as low-level details such as I/O and parallelization. RDataFrame provides methods to perform most common operations requ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:9174,avail,available,9174,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['avail'],['available']
Availability,"akes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of his \(\mbox{FCN}\) means, and also that he is interested in parameter errors, the user can change the error definition which allows him to define what he means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-deviation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:18377,error,errors,18377,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"akes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by changing one parameter by one “error”. If the \(\mbox{FCN}\) is the usual chisquare function (defined below) and if the user wants the usual one-standard-de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14347,error,errors,14347,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"aks, input parameters; �� Double_t; *fPositionCalcX;���������������� //[fNPeaks] array of calculated values of x; positions of 2D peaks, output parameters; �� Double_t; *fPositionErrX;����������������� //[fNPeaks] array of error values of x; positions of 2D peaks, output parameters; �� Double_t; *fPositionInitY;���������������� //[fNPeaks] array of initial values of y; positions of 2D peaks, input parameters; �� Double_t; *fPositionCalcY;���������������� //[fNPeaks] array of calculated values of y; positions of 2D peaks, output parameters; �� Double_t; *fPositionErrY;����������������� //[fNPeaks] array of error values of y; positions of 2D peaks, output parameters; �� Double_t; *fPositionInitX1;��������������� //[fNPeaks] array of initial x positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcX1;��������������� //[fNPeaks] array of calculated x positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrX1;���������������� //[fNPeaks] array of x positions errors of 1D; ridges, output parameters; �� Double_t; *fPositionInitY1;��������������� //[fNPeaks] array of initial y positions of 1D; ridges, input parameters; �� Double_t; *fPositionCalcY1;��������������� //[fNPeaks] array of calculated y positions of; 1D ridges, output parameters; �� Double_t; *fPositionErrY1;���������������� //[fNPeaks] array of y positions errors of 1D; ridges, output parameters; �� Double_t; *fAmpInit;���������������������� //[fNPeaks] array of initial values of; amplitudes of 2D peaks, input parameters; �� Double_t; *fAmpCalc;���������������������� //[fNPeaks] array of calculated values of; amplitudes of 2D peaks, output parameters; �� Double_t; *fAmpErr;����������������������� //[fNPeaks] array of amplitudes errors of 2D; peaks, output parameters; �� Double_t; *fAmpInitX1;�������������������� //[fNPeaks] array of initial values of; amplitudes of 1D ridges in x direction, input parameters; �� Double_t; *fAmpCalcX1;�������������������� //[fNPeaks] array of calculated",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:40669,error,errors,40669,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,10,['error'],['errors']
Availability,"aks, output parameters; double position_err_x[MAX_NUMBER_OF_PEAKS2]; // x position errors of 2D peaks; bool fix_position_x[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_y[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 2D peaks, input parameters; double position_calc_y[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 2D peaks, output parameters; double position_err_y[MAX_NUMBER_OF_PEAKS2]; // y position errors of 2D peaks; bool fix_position_y[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // y positions of 2D peaks (not fit).; // However they are present in the estimated functional; double position_init_x1[MAX_NUMBER_OF_PEAKS2]; // initial values of x; // positions of 1D ridges, input parameters; double position_calc_x1[MAX_NUMBER_OF_PEAKS2]; // calculated values of; // fitted x positions of 1D ridges, output parameters; double position_err_x1[MAX_NUMBER_OF_PEAKS2]; // x position errors of 1D ridges; bool fix_position_x1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix appropriate; // x positions of 1D ridges (not fit).; // However they are present in the estimated functional; double position_init_y1[MAX_NUMBER_OF_PEAKS2]; // initial values of y; // positions of 1D ridges, input parameters; double position_calc_y1[MAX_NUMBER_OF_PEAKS2]; // calculated values; // of fitted y positions of 1D ridges, output parameters; double position_err_y1[MAX_NUMBER_OF_PEAKS2]; // y position errors of 1D ridges; bool fix_position_y1[MAX_NUMBER_OF_PEAKS2]; // logical vector which allows to fix; // appropriate y positions of 1D ridges (not fit).; // However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS2]; // initial values of 2D peaks; // amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS2]; // calculated values of; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:47929,error,errors,47929,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['error'],['errors']
Availability,"al . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file read, try to determine the corresponding branch. ; Given a particular IO description (offset / length) representing a 'miss' of the TTreeCache's primary cache, calculate all the corresponding IO that should be performed.; all indicates that this function should search the set of all branches in this TTree. When set to false, we only search through branches that have previously incurred a miss.; Returns:; TBranch pointer corresponding to the basket that will be retrieved by this IO operation.; If no corresponding branch could be found (or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:35712,error,error,35712,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['error'],['error']
Availability,"al . Protected function to perform the merge operation of a graph with asymmetric errors. ; Reimplemented from TGraph.; Definition at line 367 of file TGraphBentErrors.cxx. ◆ FillZero(). void TGraphBentErrors::FillZero ; (; Int_t ; begin, . Int_t ; end, . Bool_t ; from_ctor = kTRUE . ). overrideprotectedvirtual . Set zero values for point arrays in the range [begin, end] ; Reimplemented from TGraph.; Definition at line 474 of file TGraphBentErrors.cxx. ◆ GetErrorX(). Double_t TGraphBentErrors::GetErrorX ; (; Int_t ; bin); const. overridevirtual . It returns the error along X at point i. ; Reimplemented from TGraph.; Definition at line 402 of file TGraphBentErrors.cxx. ◆ GetErrorXhigh(). Double_t TGraphBentErrors::GetErrorXhigh ; (; Int_t ; bin); const. overridevirtual . Get high error on X[i]. ; Reimplemented from TGraph.; Definition at line 430 of file TGraphBentErrors.cxx. ◆ GetErrorXlow(). Double_t TGraphBentErrors::GetErrorXlow ; (; Int_t ; bin); const. overridevirtual . Get low error on X[i]. ; Reimplemented from TGraph.; Definition at line 441 of file TGraphBentErrors.cxx. ◆ GetErrorY(). Double_t TGraphBentErrors::GetErrorY ; (; Int_t ; bin); const. overridevirtual . It returns the error along Y at point i. ; Reimplemented from TGraph.; Definition at line 416 of file TGraphBentErrors.cxx. ◆ GetErrorYhigh(). Double_t TGraphBentErrors::GetErrorYhigh ; (; Int_t ; bin); const. overridevirtual . Get high error on Y[i]. ; Reimplemented from TGraph.; Definition at line 452 of file TGraphBentErrors.cxx. ◆ GetErrorYlow(). Double_t TGraphBentErrors::GetErrorYlow ; (; Int_t ; bin); const. overridevirtual . Get low error on Y[i]. ; Reimplemented from TGraph.; Definition at line 463 of file TGraphBentErrors.cxx. ◆ GetEXhigh(). Double_t * TGraphBentErrors::GetEXhigh ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 81 of file TGraphBentErrors.h. ◆ GetEXhighd(). Double_t * TGraphBentErrors::GetEXhighd ; (; ); const. inlineoverridevirtual . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphBentErrors.html:40266,error,error,40266,doc/master/classTGraphBentErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphBentErrors.html,1,['error'],['error']
Availability,"al ; (; const RooFitResult & ; other, . double ; tol = 1e-6, . double ; tolCorr = 1e-4, . bool ; verbose = true . ); const. Return true if this fit result is identical to other within tolerances. ; Parameters. [in]otherFit result to test against. ; [in]tolRelative tolerance for parameters and NLL. ; [in]tolCorrabsolute tolerance for correlation coefficients. ; [in]verboseIf this function will log to the standard output when comparisons fail. As the relative tolerance for the parameter errors, the default value of 1e-3 will be used. ; Definition at line 863 of file RooFitResult.cxx. ◆ isIdenticalNoCov(). bool RooFitResult::isIdenticalNoCov ; (; const RooFitResult & ; other, . double ; tol = 1e-6, . double ; tolErr = 1e-3, . bool ; verbose = true . ); const. Return true if this fit result is identical to other within tolerances, ignoring the correlation matrix. ; Parameters. [in]otherFit result to test against. ; [in]tolRelative tolerance for parameters and NLL. ; [in]tolErrRelative tolerance for parameter errors. ; [in]verboseIf this function will log to the standard output when comparisons fail. . Definition at line 801 of file RooFitResult.cxx. ◆ lastMinuitFit(). RooFitResult * RooFitResult::lastMinuitFit ; (; const RooArgList & ; varList = RooArgList()). static . Import the results of the last fit performed by gMinuit, interpreting the fit parameters as the given varList of parameters. ; Definition at line 917 of file RooFitResult.cxx. ◆ minNll(). double RooFitResult::minNll ; (; ); const. inline . Return minimized -log(L) value. ; Definition at line 99 of file RooFitResult.h. ◆ numInvalidNLL(). Int_t RooFitResult::numInvalidNLL ; (; ); const. inline . Return number of NLL evaluations with problems. ; Definition at line 91 of file RooFitResult.h. ◆ numStatusHistory(). UInt_t RooFitResult::numStatusHistory ; (; ); const. inline . Definition at line 82 of file RooFitResult.h. ◆ plotOn() [1/2]. RooPlot * RooFitResult::plotOn ; (; RooPlot * ; frame, . const RooAbsArg &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:30493,toler,tolerance,30493,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,2,"['error', 'toler']","['errors', 'tolerance']"
Availability,"al Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual voidTApplication::Open(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidPrintLogo(Bool_t lite = kFALSE); virtual Long_tTApplication::ProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tTApplication::ProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tTApplication::QuitOpt() const; virtual voidTApplication::Raise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidTApplication::RemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tTApplication::ReturnFromRun() const; virtual voidTApplication::ReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEchoMode(Bool_t mode); virtual voidTApplication::SetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); virtual const char*SetPrompt(const char* newPrompt); voidTApplication::SetReturnFromRu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRint.html:7970,error,error,7970,root/html602/TRint.html,https://root.cern,https://root.cern/root/html602/TRint.html,4,['error'],['error']
Availability,"al Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:8123,error,error,8123,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,2,['error'],['error']
Availability,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, TGListTreeItem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCompound.html:4745,error,error,4745,root/html528/TEveCompound.html,https://root.cern,https://root.cern/root/html528/TEveCompound.html,10,['error'],['error']
Availability,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveCompound::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCompoundProjected.html:4740,error,error,4740,root/html528/TEveCompoundProjected.html,https://root.cern,https://root.cern/root/html528/TEveCompoundProjected.html,10,['error'],['error']
Availability,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); static Int_tFindConvexHull(const TEveShape::vVector2_t& pin, TEveShape::vVector2_t& pout, TEveElement* caller = 0); virtual TEveElement::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveShape.html:5371,error,error,5371,root/html528/TEveShape.html,https://root.cern,https://root.cern/root/html528/TEveShape.html,10,['error'],['error']
Availability,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); static Int_tTEveShape::FindConvexHull(const TEveShape::vVector2_t& pin, TEveShape::vVector2_t& pout, TEveElement* caller = 0); virtual TEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveBox.html:5421,error,error,5421,root/html528/TEveBox.html,https://root.cern,https://root.cern/root/html528/TEveBox.html,60,['error'],['error']
Availability,"al Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; TEveProjectable::ProjList_iTEveProjectable::EndProjecteds(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* cls = 0); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree); virtual TEveElement::sLTI_iTEveElement::FindItem(TGListTree* ltree, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveCalo2D.html:5173,error,error,5173,root/html528/TEveCalo2D.html,https://root.cern,https://root.cern/root/html528/TEveCalo2D.html,200,['error'],['error']
Availability,"al Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerFile.html:1794,error,error,1794,root/html534/TPacketizerFile.html,https://root.cern,https://root.cern/root/html534/TPacketizerFile.html,2,['error'],['error']
Availability,"al Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tGetEstEntriesProcessed(Float_t f, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPacketizer::GetInitTime() const; virtual const char*TObject::GetName() const; virtual TDSetElement*GetNextPacket(TSlave* wrk, TMes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerMulti.html:2004,error,error,2004,root/html534/TPacketizerMulti.html,https://root.cern,https://root.cern/root/html534/TPacketizerMulti.html,2,['error'],['error']
Availability,"al Long64_t THnBase::GetBin ; (; const char * ; name[], . Bool_t ; = kTRUE . ). pure virtual . Implemented in THnSparse, and THn. ◆ GetBin() [3/6]. virtual Long64_t THnBase::GetBin ; (; const Double_t * ; x); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetBin() [4/6]. virtual Long64_t THnBase::GetBin ; (; const Double_t * ; x, . Bool_t ; = kTRUE . ). pure virtual . Implemented in THnSparse, and THn. ◆ GetBin() [5/6]. virtual Long64_t THnBase::GetBin ; (; const Int_t * ; idx); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetBin() [6/6]. virtual Long64_t THnBase::GetBin ; (; const Int_t * ; idx, . Bool_t ; = kTRUE . ). pure virtual . Implemented in THnSparse, and THn. ◆ GetBinCenter(). std::vector< Double_t > THnBase::GetBinCenter ; (; const std::vector< Int_t > & ; idx); const. THnBase::GetBinCenter. ; Parameters. idxan array of bin index in each dimension. . Returnsvector of bin centers in each dimension; empty in case of error. ; NoteThrows error if size is different from nDimensions. ; See alsoGetAxis(dim)::GetBinCenter(idx) as an alternative ; Definition at line 534 of file THnBase.cxx. ◆ GetBinContent() [1/2]. Double_t THnBase::GetBinContent ; (; const Int_t * ; idx); const. inline . Definition at line 197 of file THnBase.h. ◆ GetBinContent() [2/2]. virtual Double_t THnBase::GetBinContent ; (; Long64_t ; bin, . Int_t * ; idx = nullptr . ); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetBinError() [1/2]. Double_t THnBase::GetBinError ; (; const Int_t * ; idx); const. inline . Definition at line 187 of file THnBase.h. ◆ GetBinError() [2/2]. Double_t THnBase::GetBinError ; (; Long64_t ; linidx); const. inline . Definition at line 188 of file THnBase.h. ◆ GetBinError2(). virtual Double_t THnBase::GetBinError2 ; (; Long64_t ; linidx); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetCalculateErrors(). Bool_t THnBase::GetCalculateErrors ; (; ); const. inline . Definition at line 141 of file THnBase.h. ◆ GetEntri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnBase.html:31121,error,error,31121,doc/master/classTHnBase.html,https://root.cern,https://root.cern/doc/master/classTHnBase.html,1,['error'],['error']
Availability,"al RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasFilledCache() const; virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsDataStore.html:2622,error,error,2622,root/html532/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html532/RooAbsDataStore.html,1,['error'],['error']
Availability,"al RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_thasFilledCache() const; virtual ULong_tTNamed::Hash() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsDataStore.html:2655,error,error,2655,root/html534/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html,6,['error'],['error']
Availability,"al TGeoVolume*CloneVolume() const; virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTGeoVolume::Contains(Double_t* point) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoVolume::CountNodes(Int_t nlevels = 1000, Int_t option = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTGeoVolume::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Divide(TGeoVolume* cell, TGeoPatternFinder* pattern, Option_t* option = ""spacedout""); virtual TGeoVolume*Divide(const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); virtual voidTGeoVolume::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t*); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoVolume::ExecuteEvent(Int_t event, Int_t px, Int_t py); Int_tTGeoVolume::Export(const char* filename, const char* name = """", Option_t* option = """"); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); Bool_tTGeoVolume::FindMatrixOfDaughterVolume(TGeoVolume* vol) const; TGeoNode*TGeoVolume::FindNode(const char* name) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidTGeoVolume::FindOverlaps() const; virtual Int_tTGeoVolume::GetByteCount() const; virtual Int_tGetCurrentNodeIndex() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TObject*TGeoVolume::GetField() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoVolumeAssembly.html:10686,Error,Error,10686,root/html532/TGeoVolumeAssembly.html,https://root.cern,https://root.cern/root/html532/TGeoVolumeAssembly.html,1,['Error'],['Error']
Availability,"al TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidCompress(); TObject*ConstructedAt(Int_t idx); TObject*ConstructedAt(Int_t idx, Option_t* clear_options); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExpand(Int_t newSize); virtual voidExpandCreate(Int_t n); virtual voidExpandCreateFast(Int_t n); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); TClass*GetClass() const; static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClonesArray.html:6914,error,error,6914,root/html532/TClonesArray.html,https://root.cern,https://root.cern/root/html532/TClonesArray.html,4,['error'],['error']
Availability,"al TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*Data() const; TMVA::DataSetInfo&DataInfo() const; virtual voidDeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tDoMulticlass() const; Bool_tDoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeGetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tGetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*GetEvent() const; const TMVA::Event*GetEvent(const TMVA::Event* ev) const; const TMVA::Event*GetEvent(Long64_t ievt) const; const TMVA::Event*GetEvent(Long64_t ievt, TMVA::Types::ETreeType type) const; const vector<TMVA::Event*>&GetEventCollection(TMVA::Types::ETreeType type); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:3552,error,error,3552,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,6,['error'],['error']
Availability,"al TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TMVA::Types::EAnalysisTypeTMVA::MethodBase::GetAnalysisType() const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTMVA::MethodBase::GetEfficiency(const TString&, TMVA::Types::ETreeType, Double_t& err); const TMVA::Event*TMVA::MethodBase::GetEvent() const; const TMVA::Event*TMVA::MethodBase::GetEvent(const TMVA::Event* ev) const; const TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodANNBase.html:2204,Error,Error,2204,root/html532/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodANNBase.html,2,['Error'],['Error']
Availability,"al TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tCosTheta() const; TVector3Cross(const TVector3&) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Double_tDeltaPhi(const TVector3&) const; Double_tDeltaR(const TVector3&) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Double_tDot(const TVector3&) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; Double_tDrEtaPhi(const TVector3&) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEta() const; TVector2EtaPhiVector() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; voidGetXYZ(Double_t* carray) const; voidGetXYZ(Float_t* carray) const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVector3.html:5650,error,error,5650,root/html602/TVector3.html,https://root.cern,https://root.cern/root/html602/TVector3.html,4,['error'],['error']
Availability,"al UInt_tTObject::GetUniqueID() const; const char*TSocket::GetUrl() const; Int_tTXSocket::GetXrdProofdVersion() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; virtual Bool_tTSocket::IsAuthenticated() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; Bool_tTObject::IsOnHeap() const; Bool_tTXSocket::IsServProofd(); virtual Bool_tTNamed::IsSortable() const; virtual Bool_tTXSocket::IsValid() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidTSocket::NetError(const char* where, Int_t error); virtual Bool_tTObject::Notify(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TXSocket&TXSocket::operator=(const TXSocket& xs); virtual voidTObject::Paint(Option_t* option = """"); Bool_tTXSocket::Ping(const char* ord = 0); virtual voidTObject::Pop(); virtual voidTNamed::Print(Option_t* option = """") const; virtual UnsolRespProcResultTXSocket::ProcessUnsolicitedMsg(XrdClientUnsolMsgSender* s, XrdClientMessage* msg); virtual Int_tTObject::Read(const char* name); virtual Int_tReconnect(); virtual voidTObject::RecursiveRemove(TObject* obj); virtual Int_tTXSocket::Recv(TMessage*& mess); virtual Int_tTXSocket::Recv(Int_t& status, Int_t& kind); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXUnixSocket.html:4895,error,error,4895,root/html528/TXUnixSocket.html,https://root.cern,https://root.cern/root/html528/TXUnixSocket.html,1,['error'],['error']
Availability,"al and background trees; ; **/; ; TString inputFileName = ""Higgs_data.root"";; TString inputFileLink = ""http://root.cern/files/"" + inputFileName;; ; TFile *inputFile = nullptr;; ; if (!gSystem->AccessPathName(inputFileName)) {; // file exists; inputFile = TFile::Open( inputFileName );; }; ; if (!inputFile) {; // download file from Cernbox location; Info(""TMVA_Higgs_Classification"",""Download Higgs_data.root file"");; TFile::SetCacheFileDir(""."");; inputFile = TFile::Open(inputFileLink, ""CACHEREAD"");; if (!inputFile) {; Error(""TMVA_Higgs_Classification"",""Input file cannot be downloaded - exit"");; return;; }; }; ; // --- Register the training and test trees; ; TTree *signalTree = (TTree*)inputFile->Get(""sig_tree"");; TTree *backgroundTree = (TTree*)inputFile->Get(""bkg_tree"");; ; signalTree->Print();; ; /***; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; ***/; ; TMVA::DataLoader * loader = new TMVA::DataLoader(""dataset"");; ; loader->AddVariable(""m_jj"");; loader->AddVariable(""m_jjj"");; loader->AddVariable(""m_lv"");; loader->AddVariable(""m_jlv"");; loader->AddVariable(""m_bb"");; loader->AddVariable(""m_wbb"");; loader->AddVariable(""m_wwbb"");; ; /// We set now the input data trees in the TMVA DataLoader class; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader->AddSignalTree ( signalTree, signalWeight );; loader->AddBackgroundTree( backgroundTree, backgroundWeight );; ; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""we",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:59340,down,downloaded,59340,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['down'],['downloaded']
Availability,"al and the user should not have to see it.; 9.5.1 Axis Title; The axis title is set, as with all named objects, by; axis->SetTitle(""Whatever title you want"");; When the axis is embedded into a histogram or a graph, one has to first extract the axis object:; h->GetXaxis()->SetTitle(""Whatever title you want""); 9.5.2 Axis Options and Characteristics; The axis options are most simply set with the styles. The available style options controlling specific axis options are the following:; TAxis *axis = histo->GetXaxis();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; The getters corresponding to the described setters are also available. The general options, not specific to axis, as for instance SetTitleTextColor() are valid and do have an effect on axis characteristics.; 9.5.3 Setting the Number of Divisions; Use TAxis::SetNdivisions(ndiv,optim) to set the number of divisions for an axis. The ndiv and optim are as follows:. ndiv = N1 + 100*N2 + 10000*N3; N1 = number of first divisions.; N2 = number of secondary divisions.; N3 = number of tertiary divisions.; optim = kTRUE (default), the divisions’ number will be optimized around the specified value.; optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. For example:; ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions; ndiv = -10: exactly 10 primary divisions; 9.5.4 Zooming the Axis; You can use TAxis::SetRange or TAxis::SetRangeUser to zoom the axis.; TAxis::SetRange(Int_t binfirst,Int_t binlast); The SetRange m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:336590,avail,available,336590,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"al as calculated (numerically) by the MathCore Richardson derivator class. More...;  ; class  RooDirItem;  Utility base class for RooFit objects that are to be attached to ROOT directories. More...;  ; class  RooDLLSignificanceMCSModule;  Add-on module to RooMCStudy that calculates the significance of a signal by comparing the likelihood of a fit fit with a given parameter floating with a fit with that given parameter fixed to a nominal value (usually zero). More...;  ; class  RooDouble;  Minimal implementation of a TObject holding a double value. More...;  ; class  RooEffGenContext;  Specialized generator context for p.d.fs represented by class RooEffProd, which are p.d.fs multiplied with an efficiency function. More...;  ; class  RooEfficiency;  A PDF helper class to fit efficiencies parameterized by a supplied function F. More...;  ; class  RooEllipse;  Two-dimensional ellipse that can be used to represent an error contour. More...;  ; class  RooErrorVar;  Auxiliary class that represents the error of a RooRealVar as a separate object. More...;  ; class  RooExpensiveObjectCache;  Singleton class that serves as repository for objects that are expensive to calculate. More...;  ; class  RooExtendedTerm;  A p.d.f with no observables that only introduces an extended ML term for a given number of expected events term when an extended ML is constructed. More...;  ; class  RooFactoryWSTool;  Implementation detail of the RooWorkspace. More...;  ; class  RooFFTConvPdf;  PDF for the numerical (FFT) convolution of two PDFs. More...;  ; class  RooFirstMoment;  ; class  RooFoamGenerator;  Generic Monte Carlo toy generator that implement the TFOAM sampling technique on any positively valued function. More...;  ; class  RooFormula;  Internally uses ROOT's TFormula to compute user-defined expressions of RooAbsArgs. More...;  ; class  RooFracRemainder;  Calculates the remainder fraction of a sum of RooAbsReal fraction, i.e (1 - sum_i a_i). More...;  ; class  RooFunctor;  Lightweight",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:9696,error,error,9696,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['error'],['error']
Availability,"al bin. Note: - The estimated efficiency depends on the chosen statistic option:; for frequentist ones:; ; for bayesian ones the expectation value of the resulting posterior; distribution is returned:; ; If the bit kPosteriorMode is set (or the method TEfficiency::UsePosteriorMode() has been called ) the; mode (most probable value) of the posterior is returned:; . - If the denominator is equal to 0, an efficiency of 0 is returned.; - When or the above; formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1. Double_t GetEfficiencyErrorLow(Int_t bin) const; returns the lower error on the efficiency in the given global bin. The result depends on the current confidence level fConfLevel and the; chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; more details. Note: If the histograms are filled with weights, only bayesian methods and the; normal approximation are supported. Double_t GetEfficiencyErrorUp(Int_t bin) const; returns the upper error on the efficiency in the given global bin. The result depends on the current confidence level fConfLevel and the; chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; more details. Note: If the histograms are filled with weights, only bayesian methods and the; normal approximation are supported. Int_t GetGlobalBin(Int_t binx, Int_t biny = 0, Int_t binz = 0) const; returns the global bin number which can be used as argument for the; following functions:. - GetEfficiency(bin), GetEfficiencyErrorLow(bin), GetEfficiencyErrorUp(bin); - GetPassedEvents(bin), SetPassedEvents(bin), GetTotalEvents(bin),; SetTotalEvents(bin). see TH1::GetBin() for conventions on numbering bins. TList* GetListOfFunctions(). Long64_t Merge(TCollection* list); merges the TEfficiency objects in the given list to the given; TEfficiency object using the operator+=(TEfficiency&). The merged result is stored in the current object. The statistic options and; the confidence level are",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEfficiency.html:57853,error,error,57853,root/html532/TEfficiency.html,https://root.cern,https://root.cern/root/html532/TEfficiency.html,2,['error'],['error']
Availability,"al bin. Note: - The estimated efficiency depends on the chosen statistic option:; for frequentist ones:; ; for bayesian ones the expectation value of the resulting posterior; distribution is returned:; ; If the bit kPosteriorMode is set (or the method TEfficiency::UsePosteriorMode() has been called ) the; mode (most probable value) of the posterior is returned:; . - If the denominator is equal to 0, an efficiency of 0 is returned.; - When or the above; formula for the mode is not valid. In these cases values the estimated efficiency is 0 or 1. Double_t GetEfficiencyErrorLow(Int_t bin) const; returns the lower error on the efficiency in the given global bin. The result depends on the current confidence level fConfLevel and the; chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; more details. Note: If the histograms are filled with weights, only bayesian methods and the; normal approximation are supported. Double_t GetEfficiencyErrorUp(Int_t bin) const; returns the upper error on the efficiency in the given global bin. The result depends on the current confidence level fConfLevel and the; chosen statistic option fStatisticOption. See SetStatisticOption(Int_t) for; more details. Note: If the histograms are filled with weights, only bayesian methods and the; normal approximation are supported. Int_t GetGlobalBin(Int_t binx, Int_t biny = 0, Int_t binz = 0) const; returns the global bin number which can be used as argument for the; following functions:. - GetEfficiency(bin), GetEfficiencyErrorLow(bin), GetEfficiencyErrorUp(bin); - SetPassedEvents(bin), SetTotalEvents(bin). see TH1::GetBin() for conventions on numbering bins. TList* GetListOfFunctions(). Long64_t Merge(TCollection* list); merges the TEfficiency objects in the given list to the given; TEfficiency object using the operator+=(TEfficiency&). The merged result is stored in the current object. The statistic options and; the confidence level are taken from the current object. This functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEfficiency.html:60307,error,error,60307,root/html534/TEfficiency.html,https://root.cern,https://root.cern/root/html534/TEfficiency.html,6,['error'],['error']
Availability,"al bool HasColumn(std::string_view colName) const =0Checks if the dataset has a certain column.; ROOT::RDF::RDataSource::GetColumnReadersstd::vector< T ** > GetColumnReaders(std::string_view columnName)Called at most once per column by RDF.Definition RDataSource.hxx:154; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::VecOps::RVecA ""std::vector""-like collection of values implementing handy operation to analyse them.Definition RVec.hxx:1529; R; TH1::kAllAxes@ kAllAxesDefinition TH1.h:76; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; double; int; ROOT::VecOps::SumT Sum(const RVec< T > &v, const T zero=T(0))Sum elements of an RVec.Definition RVec.hxx:1954; F#define F(x, y, z); ROOT::Detail::RDFDefinition RooAbsDataHelper.h:80; ROOT::Internal::RDF::SelectColumnsconst ColumnNames_t SelectColumns(unsigned int nRequiredNames, const ColumnNames_t &names, const ColumnNames_t &defaultNames)Choose between local column names or default column names, throw in case of errors.Definition RDFInterfaceUtils.cxx:586; ROOT::Internal::RDF::CheckForNoVariationsvoid CheckForNoVariations(const std::string &where, std::string_view definedColView, const RColumnRegister &colRegister)Throw if the column has systematic variations attached.Definition RDFInterfaceUtils.cxx:548; ROOT::Internal::RDF::ParseTreePathParsedTreePath ParseTreePath(std::string_view fullTreeName)Definition RDFInterfaceUtils.cxx:635; ROOT::Internal::RDF::CheckForRedefinitionvoid CheckForRedefinition(const std::string &where, std::string_view definedColView, const RColumnRegister &colRegister, const ColumnNames_t &treeColumns, const ColumnNames_t &dataSourceColumns)Throw if column definedColView is already there.Definition RDFInterfaceUtils.cxx:486; ROOT::Internal::RDF::CheckForDefinitionvoid CheckForDefinition(const std::string &where, std::string_view definedColView, const RCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:39792,error,errors,39792,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['error'],['errors']
Availability,"al calculation. void SetRelTolerance(double relTolerance); setter for control Parameters (getters are not needed so far ). set the desired relative Error. void SetAbsTolerance(double absTolerance). set the desired absolute Error. void SetGenerator(ROOT::Math::GSLRngWrapper* r). 	 to be added later as options for basic MC methods; The possible rules are defined in the Integration::GKRule enumeration.; The integration rule can be modified only for ADAPTIVE type integrations. void SetIntegrationRule(Integration::GKRule );. 	 set random number generator. void SetType(ROOT::Math::IntegrationMultiDim::Type type). 	 set integration method. void SetMode(ROOT::Math::MCIntegration::Mode mode). 	 set integration mode for VEGAS method; The possible MODE are :; MCIntegration::kIMPORTANCE (default) : VEGAS will use importance sampling; MCIntegration::kSTRATIFIED : VEGAS will use stratified sampling if certain condition are satisfied; MCIntegration::kIMPORTANCE_ONLY : VEGAS will always use importance smapling. void SetParameters(const VegasParameters &p). 	 set default parameters for VEGAS method. void SetParameters(const MiserParameters &p). 	 set default parameters for MISER method. double Sigma(). 	 set parameters for PLAIN method. void SetPParameters(const PlainParameters &p);. 	 returns the error sigma from the last iteration of the Vegas algorithm. double ChiSqr(). 	 returns chi-squared per degree of freedom for the estimate of the integral in the Vegas algorithm. bool CheckFunction(); internal method to check validity of GSL function pointer. void DoInitialize(); set internally the type of integration method. » Author: Magdalena Slawinska 08/2007 » Copyright (c) 2007 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMCIntegrator.h 26307 2008-11-20 09:51:19Z moneta $ » Last generated: 2009-12-07 13:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html:6509,error,error,6509,root/html526/ROOT__Math__GSLMCIntegrator.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__GSLMCIntegrator.html,1,['error'],['error']
Availability,"al const char*DataMemberInfo_TypeName(DataMemberInfo_t* dminfo) const; virtual Long_tDataMemberInfo_TypeProperty(DataMemberInfo_t* dminfo) const; virtual intDataMemberInfo_TypeSize(DataMemberInfo_t* dminfo) const; virtual const char*DataMemberInfo_TypeTrueName(DataMemberInfo_t* dminfo) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t* dminfo) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCint.html:7646,Error,Error,7646,root/html534/TCint.html,https://root.cern,https://root.cern/root/html534/TCint.html,1,['Error'],['Error']
Availability,"al const double*X() const. protected:. voidGetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. Data Members; protected:. intROOT::Math::Minimizer::fDebugprint level; TMVA::IFitterTarget*fFitness; unsigned intROOT::Math::Minimizer::fMaxCallsmax number of function calls ; unsigned intROOT::Math::Minimizer::fMaxItermax number or iterations used to find the minimum; ROOT::Math::GeneticMinimizerParametersfParameters; doubleROOT::Math::Minimizer::fPrecprecision; vector<TMVA::Interval*>fRanges; vector<double>fResult; intROOT::Math::Minimizer::fStatusstatus of minimizer ; intROOT::Math::Minimizer::fStrategyminimizer strategy; doubleROOT::Math::Minimizer::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; GeneticMinimizer(int = 0). virtual ~GeneticMinimizer(). void Clear(). void SetFunction(const ROOT::Math::IMultiGenFunction& func). bool SetLimitedVariable(unsigned int , const string& , double , double , double , double ). bool SetVariable(unsigned int ivar, const string& name, double val, double step). bool Minimize(). double MinValue() const. double Edm() const. const double * X() const. const double * MinGradient() const. unsigned int NCalls() const. unsigned int NDim() const. unsigned int NFree() const. bool ProvidesError() const. const double * Errors() const. double CovMatrix(unsigned int i, unsigned int j) const. void SetParameters(const ROOT::Math::GeneticMinimizerParameters& params). void SetOptions(const ROOT::Math::MinimizerOptions& opt). void GetGeneticOptions(ROOT::Math::MinimizerOptions& opt) const. » Last changed: root/mathcore:$Id » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html:5221,Error,Errors,5221,root/html532/ROOT__Math__GeneticMinimizer.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GeneticMinimizer.html,1,['Error'],['Errors']
Availability,"al intDisplayClass(FILE* fout, char* name, int base, int start) const; virtual intDisplayIncludePath(FILE* fout) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEnableWrappers(bool value = true); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* method, const char* params); virtual void*GetInterfaceMethodWithPrototype(TClass* cl, const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCint.html:8103,error,error,8103,root/html526/TCint.html,https://root.cern,https://root.cern/root/html526/TCint.html,1,['error'],['error']
Availability,"al method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3464 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3408 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2903 of file RooAbsReal.cxx. ◆ matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgProxy & ; a . ); const. protected . Utility function for use in getAnalyticalIntegral(). ; If the content of proxy 'a' occurs in set 'allDeps' then the argument held in 'a' is copied from allDeps to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:121207,error,error,121207,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,2,['error'],['error']
Availability,"al method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition at line 3545 of file RooAbsReal.cxx. ◆ logEvalError() [2/2]. void RooAbsReal::logEvalError ; (; const RooAbsReal * ; originator, . const char * ; origName, . const char * ; message, . const char * ; serverValueString = nullptr . ). static . Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ; Definition at line 3490 of file RooAbsReal.cxx. ◆ makeProjectionSet(). void RooAbsReal::makeProjectionSet ; (; const RooAbsArg * ; plotVar, . const RooArgSet * ; allVars, . RooArgSet & ; projectedVars, . bool ; silent . ); const. protected . Utility function for plotOn() that constructs the set of observables to project when plotting ourselves as function of 'plotVar'. ; 'allVars' is the list of variables that must be projected, but may contain variables that we do not depend on. If 'silent' is cleared, warnings about inconsistent input parameters will be printed. ; Definition at line 2988 of file RooAbsReal.cxx. ◆ matchArgs() [1/5]. bool RooAbsReal::matchArgs ; (; const RooArgSet & ; allDeps, . RooArgSet & ; analDeps, . const RooArgProxy & ; a . ); const. protected . Utility function for use in getAnalyticalIntegral(). ; If the content of proxy 'a' occurs in set 'allDeps' then the argument held in 'a' is copied from allDeps to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:122537,error,error,122537,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,2,['error'],['error']
Availability,"al range of an existing variable. bool Minimize(); method to perform the minimization. double MinValue() const; return minimum function value. const double * X() const; return pointer to X values at the minimum. double Edm() const; return expected distance reached from the minimum (re-implement if minimizer provides it. { return -1; }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return NULL; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NIterations() const; number of iterations to reach the minimum. { return NCalls(); }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; (re-implement if minimizer supports bounded parameters). { return NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. { return NULL; }. double CovMatrix(unsigned int ivar, unsigned int jvar) const; return covariance matrices element for variables ivar,jvar; if the variable is fixed the return value is zero; The ordering of the variables is the same as in the parameter and errors vectors. bool GetCovMatrix(double* covMat) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. bool GetHessianMatrix(double* hMat) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:8463,error,error,8463,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,12,['error'],['error']
Availability,"al shapes which are using it. Display list information is also stored here, possibly per LOD; level. Most classes does not support LOD (only sphere and tube) and; therefore reasonable defaults are encoded in the following virtual; functions:. * ELODAxes SupportedLODAxes() { return kLODAxesNone; }; * Int_t DLCacheSize() { return 1; }; * UInt_t DLOffset(lod); // Transform lod into DL offset.; * Short_t QuantizeShapeLOD(); // Quantize lod. Classes that have per-LOD display-lists than override these functions.; 'UShort_t fDLValid' is used as a bit-field determining validity of; each quantized LOD-level; hopefully one will not have more than 16; LOD levels per class.; See also: TGLPhysicalShape::CalculateShapeLOD() where LOD is calculated. See base/src/TVirtualViewer3D for description of common external 3D; viewer architecture and how external viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLLogicalShape.html:2197,avail,available,2197,root/html528/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html528/TGLLogicalShape.html,2,['avail'],['available']
Availability,"al value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t * GetCovarianceMatrix() const; return a pointer to the covariance matrix. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; return element i,j from the covariance matrix. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t GetNumberTotalParameters() const; return the total number of parameters (free + fixed). Int_t GetNumberFreeParameters() const; return the number of free parameters. Double_t GetParError(Int_t ipar) const; return error of parameter ipar. Double_t GetParameter(Int_t ipar) const; return current value of parameter ipar. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; return current values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter; WARNING! parname must be suitably dimensionned in the calling function. const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t i); return Sum(log(i) i=0,n; used by log likelihood fits. Bool_t IsFixed(Int_t ipar) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitter.html:13340,error,error,13340,root/html528/TFitter.html,https://root.cern,https://root.cern/root/html528/TFitter.html,10,['error'],['error']
Availability,"al void ApplyX(TF1 *f);; 61 static Int_t CalculateScanfFields(const char *fmt);; 62 void ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const override;; 63 Double_t GetErrorX(Int_t bin) const override;; 64 Double_t GetErrorY(Int_t bin) const override;; 65 Double_t GetErrorXhigh(Int_t bin) const override;; 66 Double_t GetErrorXlow(Int_t bin) const override;; 67 Double_t GetErrorYhigh(Int_t bin) const override;; 68 Double_t GetErrorYlow(Int_t bin) const override;; 69 Double_t *GetEX() const override {return fEX;}; 70 Double_t *GetEY() const override {return fEY;}; 71 Int_t Merge(TCollection* list) override;; 72 void Print(Option_t *chopt="""") const override;; 73 void SavePrimitive(std::ostream &out, Option_t *option = """") override;; 74 void Scale(Double_t c1=1., Option_t *option=""y"") override; // *MENU*; 75 virtual void SetPointError(Double_t ex, Double_t ey); // *MENU; 76 virtual void SetPointError(Int_t i, Double_t ex, Double_t ey);; 77 ; 78 ClassDefOverride(TGraphErrors,3) //A graph with error bars; 79};; 80 ; 81inline Double_t **TGraphErrors::Allocate(Int_t size) {; 82 return AllocateArrays(4, size);; 83}; 84 ; 85#endif; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8h_source.html:3648,error,error,3648,doc/master/TGraphErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html,1,['error'],['error']
Availability,"al voidAddBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidAddBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDropBranch(TBranch* b, Bool_t subbranches = kFALSE); virtual voidDropBranch(const char* branch, Bool_t subbranches = kFALSE); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Bool_tFillBuffer(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTFileCacheRead::GetBufferSize() const; const TObjArray*GetCachedBranches() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEfficiency() const; Double_tGetEfficiencyRel() const; virtual const char*TObject::GetIconName() const; static Int_tGetLearnEntries(); virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:10171,Error,Error,10171,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['Error'],['Error']
Availability,"al voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; static TSocket*TSocket::CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); static TSocket*TSocket::CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tTSocket::GetBytesRecv() const; UInt_tTSocket::GetBytesSent() const; static Int_tTSocket::GetClientProtocol(); Int_tTSocket::GetCompressionAlgorithm() const; Int_tTSocket::GetCompressionLevel() const; Int_tTSocket::GetCompressionSettings() const; virtual Int_tTSocket::GetDescriptor() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Int_tTSocket::GetErrorCode() const; virtual const char*TObject::GetIconName() const; TInetAddressTSocket::GetInetAddress() const; TTimeStampTSocket::GetLastUsage(); virtual TInetAddressTSocket::GetLocalInetAddress(); virtual Int_tTSocket::GetLocalPort(); virtual const char*TNamed::GetName() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSSLSocket.html:2154,error,error,2154,root/html532/TSSLSocket.html,https://root.cern,https://root.cern/root/html532/TSSLSocket.html,8,['error'],['error']
Availability,"al voidComputeBBox(Double_t& dx, Double_t& dy, Double_t& dz, Double_t* origin); virtual voidComputeNormal(const Double_t* point, const Double_t* dir, Double_t* norm); virtual Bool_tContains(const Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; voidTGeoBoolNode::CreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistanceToPrimitive(Int_t px, Int_t py); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Double_tDistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual Double_tDistFromOutside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = 0, Double_t* safe = 0) const; virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TGeoBoolNode::EGeoBoolTypeGetBooleanOperator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TGeoMatrix*TGeoBoolNode::GetLeftMatrix() const; TGeoShape*TGeoBoolNode::GetLeftShape() const; virtual const char*TObject::GetName() const; virtual Int_tGetNpoints(); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoIntersection.html:2894,Error,Error,2894,root/html534/TGeoIntersection.html,https://root.cern,https://root.cern/root/html534/TGeoIntersection.html,9,['Error'],['Error']
Availability,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLFontManager.html:2199,avail,availabe,2199,root/html528/TGLFontManager.html,https://root.cern,https://root.cern/root/html528/TGLFontManager.html,3,['avail'],"['availabe', 'available']"
Availability,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLFontManager.html:2199,avail,availabe,2199,root/html530/TGLFontManager.html,https://root.cern,https://root.cern/root/html530/TGLFontManager.html,3,['avail'],"['availabe', 'available']"
Availability,"al voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. static voidInitStatics(). private:. TGLFontManager(const TGLFontManager&); TGLFontManager&operator=(const TGLFontManager&). Data Members; protected:. map<TGLFont,int>fFontMapmap of created fonts; list<const TGLFont*>fFontTrashfonts to purge; static TObjArrayfgFontFileArraymap font-id to ttf-font-file; static vector<int>fgFontSizeArraymap of valid font-size; static Bool_tfgStaticInitDoneglobal initialization flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TGLFontManager(); Destructor. void RegisterFont(Int_t size, Int_t file, TGLFont::EMode mode, TGLFont& out); Provide font with given size, file and FTGL class. void RegisterFont(Int_t size, const char* name, TGLFont::EMode mode, TGLFont& out); Get mapping from ttf id to font names. Table taken from TTF.cxx. void ReleaseFont(TGLFont& font); Release font with given attributes. Returns false if font has; not been found in the managers font set. TObjArray* GetFontFileArray(); Get id to file name map. Int_t GetFontSize(Int_t ds); Get availabe font size. Int_t GetFontSize(Int_t ds, Int_t min, Int_t max); Get availabe font size. const char* GetFontNameFromId(Int_t ); Get font name from TAttAxis font id. void InitStatics(); Create a list of available font files and allowed font sizes. void ClearFontTrash(); Delete FTFFont objects registered for destruction. TGLFont& operator=(const TGLFontManager& ). TGLFontManager(const TGLFontManager& ). TGLFontManager(); {}. FontSizeVec_t* GetFontSizeArray(). » Author: Alja Mrak-Tadel 2008 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLFontManager.h 30425 2009-09-24 19:45:11Z matevz $ » Last generated: 2011-11-03 20:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLFontManager.html:2199,avail,availabe,2199,root/html532/TGLFontManager.html,https://root.cern,https://root.cern/root/html532/TGLFontManager.html,6,['avail'],"['availabe', 'available']"
Availability,"al voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidTDataSet::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTDataSet::Delete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFileSet.html:1906,Error,Error,1906,root/html532/TFileSet.html,https://root.cern,https://root.cern/root/html532/TFileSet.html,4,['Error'],['Error']
Availability,"al voidTEveElement::DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); virtual voidTEveElement::DestroyMainTrans(); virtual voidTEveElement::DestroyOrWarn(); voidTEveElement::DisableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidExportToCINT(char* var_name); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, TPRegexp& regexp, const TClass* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveElementObjectPtr.html:4481,Error,Error,4481,root/html532/TEveElementObjectPtr.html,https://root.cern,https://root.cern/root/html532/TEveElementObjectPtr.html,4,['Error'],['Error']
Availability,"al voidTEveElement::DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); virtual voidTEveElement::DestroyMainTrans(); virtual voidTEveElement::DestroyOrWarn(); voidTEveElement::DisableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tFill(Double_t x, Double_t y, Double_t z, Double_t quant); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSetArray.html:5062,Error,Error,5062,root/html532/TEvePointSetArray.html,https://root.cern,https://root.cern/root/html532/TEvePointSetArray.html,4,['Error'],['Error']
Availability,"al voidTEveElement::DestroyListSubTree(TGListTree* ltree, TGListTreeItem* parent); virtual voidTEveElement::DestroyMainTrans(); virtual voidTEveElement::DestroyOrWarn(); voidTEveElement::DisableListElements(Bool_t rnr_self = kFALSE, Bool_t rnr_children = kFALSE)MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidTEveElement::DumpSourceObject() constMENU ; virtual voidTEveElement::ElementChanged(Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); voidTEveElement::EnableListElements(Bool_t rnr_self = kTRUE, Bool_t rnr_children = kTRUE)MENU ; TEveElement::List_iTEveElement::EndChildren(); TEveElement::List_ciTEveElement::EndChildren() const; TEveElement::List_iTEveElement::EndParents(); TEveElement::List_ciTEveElement::EndParents() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTEveElement::ExpandIntoListTree(TGListTree* ltree, TGListTreeItem* parent); voidTEveElement::ExportSourceObjectToCINT(char* var_name) constMENU ; virtual voidTEveElement::ExportToCINT(char* var_name)MENU ; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTEveElement::FillImpliedSelectedSet(TEveElement::Set_t& impSelSet); TEveElement*TEveElement::FindChild(const TString& name, const TClass* cls = 0); TEveElement*TEveElement::FindChild(TPRegexp& regexp, const TClass* cls = 0); Int_tTEveElement::FindChildren(TEveElement::List_t& matches, const TString& name, const TClass* cls = 0); Int_tTEveElement::FindChildr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEveArrow.html:4451,Error,Error,4451,root/html532/TEveArrow.html,https://root.cern,https://root.cern/root/html532/TEveArrow.html,16,['Error'],['Error']
Availability,"al voidTH1::DirectoryAutoAdd(TDirectory*); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTH1::Divide(const TH1* h1); virtual Bool_tTH1::Divide(TF1* f1, Double_t c1 = 1); virtual Bool_tTH1::Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*TH3C::DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z); virtual Int_tTH3::Fill(Double_t x, Double_t y, Double_t z, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, Double_t y, const char* namez, Double_t w); virtual Int_tTH3::Fill(const char* namex, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, const char* namez, Double_t w); virtual Int_tTH3::Fill(Double_t x, const char* namey, Double_t z, Double_t w); virtual Int_tTH3::Fill(Double_t x, Double_t y, const char* namez, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t nt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLTH3Composition.html:3072,error,error,3072,root/html534/TGLTH3Composition.html,https://root.cern,https://root.cern/root/html534/TGLTH3Composition.html,2,['error'],['error']
Availability,"al voidTNamed::Clear(Option_t* option = """"); voidclearStudies(); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tcommitTransaction(); virtual Int_tTNamed::Compare(const TObject* obj) const; TIterator*componentIterator() const; const RooArgSet&components() const; virtual voidTNamed::Copy(TObject& named) const; RooAbsData*data(const char* name) const; Bool_tdefineSet(const char* name, const char* contentList); Bool_tdefineSet(const char* name, const RooArgSet& aset, Bool_t importMissing = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&expensiveObjectCache(); voidexportToCint(const char* namespaceName = 0); Bool_textendSet(const char* name, const char* newContents); RooFactoryWSTool&factory(); RooAbsArg*factory(const char* expr); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; RooAbsReal*function(const char* name) const; RooAbsArg*fundArg(const char* name) const; TObject*genobj(const char* name) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooWorkspace.html:3399,error,error,3399,root/html526/RooWorkspace.html,https://root.cern,https://root.cern/root/html526/RooWorkspace.html,5,['error'],['error']
Availability,"al voidTObject::AppendPad(Option_t* option = """"); Double_tArea() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tContains(Double_t* point) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFinishPolygon(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; Int_tGetNvert() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_t*GetX(); Double_t*GetY(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPolygon.html:2898,error,error,2898,root/html528/TGeoPolygon.html,https://root.cern,https://root.cern/root/html528/TGeoPolygon.html,4,['error'],['error']
Availability,"al voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; voidEnhance(const Double_t* source, Double_t* destVector); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFilterZonal(const Double_t* source, Double_t* destVector); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:2471,error,error,2471,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,4,['error'],['error']
Availability,"al voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voiddecreaseRefCount(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; voidincreaseRefCount(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooSharedProperties.html:1699,error,error,1699,root/html532/RooSharedProperties.html,https://root.cern,https://root.cern/root/html532/RooSharedProperties.html,2,['error'],['error']
Availability,"al voidTObject::Browse(TBrowser* b); voidcd() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLevel() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TGeoHMatrix*GetMatrix(Int_t level = -1) const; TGeoNode*GetMother(Int_t levup = 1) const; virtual const char*TNamed::GetName() const; TGeoNode*GetNode(Int_t level = -1) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TGeoHMatrix*GetOriginalMatrix() const; TGeoShape*GetShap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPhysicalNode.html:3232,error,error,3232,root/html528/TGeoPhysicalNode.html,https://root.cern,https://root.cern/root/html528/TGeoPhysicalNode.html,10,['error'],['error']
Availability,"al voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& polyline) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; static voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidDrawPolyLine(Int_t n, Float_t* p, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Int_tGetLastPoint() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; Int_tGetN() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*GetOption() const; Float_t*GetP() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPolyLine3D.html:3188,error,error,3188,root/html528/TPolyLine3D.html,https://root.cern,https://root.cern/root/html528/TPolyLine3D.html,10,['error'],['error']
Availability,"al voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveText::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetFitFormat() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TList*TPaveText::GetListOfLines() const; Float_tTPaveText::GetMargin() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPaveStats.html:6790,error,error,6790,root/html528/TPaveStats.html,https://root.cern,https://root.cern/root/html528/TPaveStats.html,4,['error'],['error']
Availability,"al voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveText::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetFitFormat() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; virtual TLis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:7701,error,error,7701,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,6,['error'],['error']
Availability,"al voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EProcStatus { kNotOk; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Int_tfExitStatusQuery exit status ((Int_t)TVirtualProofPlayer::EExitStatus or -1);; THashListfInfoMsgslist of info messages; TIterfIter!iterator in messages; TListfMsgslist of error messages; Long_tfResMaxMstMax resident memory used by the master; Long_tfResMemMaxMax resident memory used by the worker; Long_tfVirtMaxMstMax virtual memory used by the master; Long_tfVirtMemMaxMax virtual memory used by the worker. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TStatus(); Default constructor. void Add(const char* mesg); Add an error message. void AddInfo(const char* mesg); Add an info message. Int_t Merge(TCollection* list); PROOF Merge() function. void Print(Option_t* option = """") const; Standard print function. void Reset(); Reset the iterator on the messages. const char * NextMesg(); Return the next message or 0. void SetMemValues(Long_t vmem = -1, Long_t rmem = -1, Bool_t master = kFALSE); Set max memory values. void Streamer(TBuffer& ); Stream an object of class TStatus. virtual ~TStatus(); { }. Bool_t IsOk() const; { return TestBit(kNotOk) ? kFALSE : kTRUE; }. Int_t GetExitStatus() const; { return fExitStatus; }. Long_t GetResMemMax(Bool_t ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatus.html:6205,error,error,6205,root/html534/TStatus.html,https://root.cern,https://root.cern/root/html534/TStatus.html,2,['error'],['error']
Availability,"al voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveText::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetFitFormat() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual TText*TPaveText::GetLineWith(const char* text) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPaveStats.html:6706,error,error,6706,root/html528/TPaveStats.html,https://root.cern,https://root.cern/root/html528/TPaveStats.html,4,['error'],['error']
Availability,"al voidTPave::ConvertNDCtoPad(); virtual voidTPave::Copy(TObject& pave) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteText(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTPave::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTPaveText::Draw(Option_t* option = """"); virtual TBox*TBox::DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTPaveText::DrawFile(const char* filename, Option_t* option = """"); virtual voidTPave::DrawPave(Double_t x1, Double_t y1, Double_t x2, Double_t y2, Int_t bordersize = 4, Option_t* option = ""br""); virtual voidTObject::Dump() constMENU ; virtual voidEditText(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPave::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTBox::GetBBox(); virtual TPointTBox::GetBBoxCenter(); Int_tTPave::GetBorderSize() const; Double_tTPave::GetCornerRadius() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*GetFitFormat() const; virtual const char*TObject::GetIconName() const; const char*TPaveText::GetLabel() const; virtual TText*TPaveText::GetLine(Int_t number) const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:7617,error,error,7617,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,6,['error'],['error']
Availability,"al voidcd(Int_t); virtual TGeoNode*CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; voidCreateThreadData(Int_t nthreads); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t*, const Double_t* = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetCurrent(); virtual Int_tGetDivAxis(); Int_tGetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tGetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*GetMatrix(); virtual const char*TObject::GetName() const; Int_tGetNdiv() const; Int_tGetNext() const; TGeoNode*GetNodeOffset(Int_t idiv); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tGetStart() const; Double_tGetStep() const; TGeoPatternFinder::ThreadData_t&GetThreadData() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPatternFinder.html:2614,error,error,2614,root/html534/TGeoPatternFinder.html,https://root.cern,https://root.cern/root/html534/TGeoPatternFinder.html,6,['error'],['error']
Availability,"al void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1AbsComposition.html:2650,error,error,2650,doc/master/classTF1AbsComposition.html,https://root.cern,https://root.cern/doc/master/classTF1AbsComposition.html,4,['error'],['error']
Availability,"al void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  ;  Protected Member Functions inherited from TGWidget;  TGWidget (const TGWidget &tgw);  ; Int_t ClearFlags (Int_t flags);  ; TGWidget & operator= (const TGWidget &tgw);  ; Int_t SetFlags (Int_t flags);  . Protected Attributes; FontStruct_t fFontStruct;  ; Bool_t fHasOwnFont;  ; Int_t fHKeycode;  ; TGHotString * fLabel;  ; Int_t fMBottom;  ; Int_t fMLeft;  ; Int_t fMRight;  ; Int_t fMTop;  ; Bool_t fPrevStateOn;  ; Bool_t fStateOn;  ; TGTextLayout * fTLayout;  ; Int_t fTMode;  ; Int_t fWrapLength;  ;  Protected Attributes inherited from TGButton; Pixel_t fBgndColor;  actual background color ;  ; TGButtonGroup * fGroup;  button group this button belongs to ;  ; Pixel_t fHighColor;  highlight color ;  ; GContext_t fNormGC;  graphics context used for drawing button ;  ; EButtonState fState;  button state ;  ; Bool_t fStayDown;  true if button has to stay down ;  ; UInt_t fStyle;  button style (modern or classic) ;  ; UInt_t fTHeight;  button height ;  ; TGToolTip * fTip;  tool tip associated with button ;  ; UInt_t fTWidth;  button width ;  ; void * fUserData;  pointer to user data structure ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextButton.html:29048,down,down,29048,doc/master/classTGTextButton.html,https://root.cern,https://root.cern/doc/master/classTGTextButton.html,1,['down'],['down']
Availability,"al void FitChisquare (Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  Minimization function for H1s using a Chisquare method. ;  ; virtual void FitChisquareI (Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  Minimization function for H1s using a Chisquare method. ;  ; virtual void FitLikelihood (Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  Minimization function for H1s using a Likelihood method. ;  ; virtual void FitLikelihoodI (Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);  Minimization function for H1s using a Likelihood method. ;  ; void FixParameter (Int_t ipar) override;  Fixes parameter number ipar. ;  ; Double_t * GetCovarianceMatrix () const override;  Return a pointer to the covariance matrix. ;  ; Double_t GetCovarianceMatrixElement (Int_t i, Int_t j) const override;  Return element i,j from the covariance matrix. ;  ; Int_t GetErrors (Int_t ipar, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &globcc) const override;  Return errors after MINOs not implemented. ;  ; Int_t GetNumberFreeParameters () const override;  Return the number of free parameters. ;  ; Int_t GetNumberTotalParameters () const override;  Return the total number of parameters (free + fixed) ;  ; Double_t GetParameter (Int_t ipar) const override;  Return current value of parameter ipar. ;  ; Int_t GetParameter (Int_t ipar, char *name, Double_t &value, Double_t &verr, Double_t &vlow, Double_t &vhigh) const override;  Get various ipar parameter attributes: ;  ; Double_t GetParError (Int_t ipar) const override;  Return error of parameter ipar. ;  ; const char * GetParName (Int_t ipar) const override;  Return name of parameter ipar. ;  ; Double_t * GetPL0 () const;  ; Int_t GetStats (Double_t &amin, Double_t &edm, Double_t &errdef, Int_t &nvpar, Int_t &nparx) const override;  Return global fit parameters. ;  ; Double_t GetSumLog (Int_t) override;  Return Sum(log(i) i=0,n used by log-likelihood fit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:5651,error,errors,5651,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['error'],['errors']
Availability,"al"". That is, we create an ""efficiency"" graph, where each entry is; between 0 and 1, inclusive. If the histograms are not filled with unit weights, the number of effective; entries is used to normalise the bin contents which might lead to wrong results.; . The points are assigned a x value at the center of each histogram bin.; The y values are for all options except for the; bayesian methods where the result depends on the chosen option. If the denominator becomes 0 or pass > total, the corresponding bin is; skipped. 2) calculating ratios of two Poisson means (option 'pois'):. The two histograms are interpreted as independent Poisson processes and the ratio; ; The histogram 'pass' is interpreted as n_{1} and the total histogram; is used for n_{2}. The (asymmetric) uncertainties of the Poisson ratio are linked to the uncertainties; of efficiency by a parameter transformation:; . The x errors span each histogram bin (lowedge ... lowedge+width); The y errors depend on the chosen statistic methode which can be determined; by the options given below. For a detailed description of the used statistic; calculations please have a look at the corresponding functions!. Options:; - v : verbose mode: prints information about the number of used bins; and calculated efficiencies with their errors; - cl=x : determine the used confidence level (0<x<1) (default is 0.683); - cp : Clopper-Pearson interval (see TEfficiency::ClopperPearson); - w : Wilson interval (see TEfficiency::Wilson); - n : normal approximation propagation (see TEfficiency::Normal); - ac : Agresti-Coull interval (see TEfficiency::AgrestiCoull); - fc : Feldman-Cousins interval (see TEfficiency::FeldmanCousinsInterval); - b(a,b): bayesian interval using a prior probability ~Beta(a,b); a,b > 0; (see TEfficiency::Bayesian); - mode : use mode of posterior for Bayesian interval (default is mean); - shortest: use shortest interval (done by default if mode is set); - central: use central interval (done by default if mode is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGraphAsymmErrors.html:19571,error,errors,19571,root/html532/TGraphAsymmErrors.html,https://root.cern,https://root.cern/root/html532/TGraphAsymmErrors.html,8,['error'],['errors']
Availability,"al(const char* name, const char* title, RooAbsReal& _x, RooAbsReal& _c); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExponential.html:28693,Error,ErrorLoggingMode,28693,root/html602/RooExponential.html,https://root.cern,https://root.cern/root/html602/RooExponential.html,2,['Error'],['ErrorLoggingMode']
Availability,"al(ctx,; 19120 ""%s: %s is not allowed to connect"",; 19121 __func__,; 19122 src_addr);; 19123 closesocket(so.sock);; 19124 } else {; 19125 /* Put so socket structure into the queue */; 19126 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19127 set_close_on_exec(so.sock, NULL, ctx);; 19128 so.is_ssl = listener->is_ssl;; 19129 so.ssl_redir = listener->ssl_redir;; 19130 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19131 mg_cry_ctx_internal(ctx,; 19132 ""%s: getsockname() failed: %s"",; 19133 __func__,; 19134 strerror(ERRNO));; 19135 }; 19136 ; 19137#if !defined(__ZEPHYR__); 19138 if ((so.lsa.sa.sa_family == AF_INET); 19139 || (so.lsa.sa.sa_family == AF_INET6)) {; 19140 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19141 * This is needed because if HTTP-level keep-alive; 19142 * is enabled, and client resets the connection, server won't get; 19143 * TCP FIN or RST and will keep the connection open forever. With; 19144 * TCP keep-alive, next keep-alive handshake will figure out that; 19145 * the client is down and will close the server end.; 19146 * Thanks to Igor Klopov who suggested the patch. */; 19147 if (setsockopt(so.sock,; 19148 SOL_SOCKET,; 19149 SO_KEEPALIVE,; 19150 (SOCK_OPT_TYPE)&on,; 19151 sizeof(on)); 19152 != 0) {; 19153 mg_cry_ctx_internal(; 19154 ctx,; 19155 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19156 __func__,; 19157 strerror(ERRNO));; 19158 }; 19159 }; 19160#endif; 19161 ; 19162 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19163 * to effectively fill up the underlying IP packet payload and; 19164 * reduce the overhead of sending lots of small buffers. However; 19165 * this hurts the server's throughput (ie. operations per second); 19166 * when HTTP 1.1 persistent connections are used and the responses; 19167 * are relatively small (eg. less than 1400 bytes).; 19168 */; 19169 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19170 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19171 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:570515,alive,alive,570515,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,3,"['alive', 'down']","['alive', 'down']"
Availability,"al(ctx,; 19121 ""%s: %s is not allowed to connect"",; 19122 __func__,; 19123 src_addr);; 19124 closesocket(so.sock);; 19125 } else {; 19126 /* Put so socket structure into the queue */; 19127 DEBUG_TRACE(""Accepted socket %d"", (int)so.sock);; 19128 set_close_on_exec(so.sock, NULL, ctx);; 19129 so.is_ssl = listener->is_ssl;; 19130 so.ssl_redir = listener->ssl_redir;; 19131 if (getsockname(so.sock, &so.lsa.sa, &len) != 0) {; 19132 mg_cry_ctx_internal(ctx,; 19133 ""%s: getsockname() failed: %s"",; 19134 __func__,; 19135 strerror(ERRNO));; 19136 }; 19137 ; 19138#if !defined(__ZEPHYR__); 19139 if ((so.lsa.sa.sa_family == AF_INET); 19140 || (so.lsa.sa.sa_family == AF_INET6)) {; 19141 /* Set TCP keep-alive for TCP sockets (IPv4 and IPv6).; 19142 * This is needed because if HTTP-level keep-alive; 19143 * is enabled, and client resets the connection, server won't get; 19144 * TCP FIN or RST and will keep the connection open forever. With; 19145 * TCP keep-alive, next keep-alive handshake will figure out that; 19146 * the client is down and will close the server end.; 19147 * Thanks to Igor Klopov who suggested the patch. */; 19148 if (setsockopt(so.sock,; 19149 SOL_SOCKET,; 19150 SO_KEEPALIVE,; 19151 (SOCK_OPT_TYPE)&on,; 19152 sizeof(on)); 19153 != 0) {; 19154 mg_cry_ctx_internal(; 19155 ctx,; 19156 ""%s: setsockopt(SOL_SOCKET SO_KEEPALIVE) failed: %s"",; 19157 __func__,; 19158 strerror(ERRNO));; 19159 }; 19160 }; 19161#endif; 19162 ; 19163 /* Disable TCP Nagle's algorithm. Normally TCP packets are coalesced; 19164 * to effectively fill up the underlying IP packet payload and; 19165 * reduce the overhead of sending lots of small buffers. However; 19166 * this hurts the server's throughput (ie. operations per second); 19167 * when HTTP 1.1 persistent connections are used and the responses; 19168 * are relatively small (eg. less than 1400 bytes).; 19169 */; 19170 if ((ctx->dd.config[CONFIG_TCP_NODELAY] != NULL); 19171 && (!strcmp(ctx->dd.config[CONFIG_TCP_NODELAY], ""1""))) {; 19172 if",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:570548,alive,alive,570548,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,3,"['alive', 'down']","['alive', 'down']"
Availability,"al(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, const char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual voidFuncTempInfo_Delete(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_tFuncTempInfo_IsValid(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Name(FuncTempInfo_t*, TString& name) const; virtual Long_tFuncTempInfo_Property(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_TemplateMinReqArgs(FuncTempInfo_t*) const; virtual UInt_tFuncTempInfo_TemplateNargs(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Title(FuncTempInfo_t*, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:10210,error,error,10210,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,4,['error'],['error']
Availability,"al); voidTQObject::Emit(const char* signal, Long_t* paramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEndPopup(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorPopup.html:4599,Error,Error,4599,root/html602/TGColorPopup.html,https://root.cern,https://root.cern/root/html602/TGColorPopup.html,6,['Error'],['Error']
Availability,"al, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEncodeText(TGString* str, const char* z); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGHtmlElement*FindEndNest(TGHtmlElement* sp, int en, TGHtmlElement* lp); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual intFormAction(TGHtmlForm*, int); virtual intFormCreate(TGHtmlForm*, const char*, const char*); virtual Pixel_tTGFrame::GetBackground() const; const char*GetBaseUri() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:4594,error,error,4594,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,6,['error'],['error']
Availability,"al, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnable(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; Int_tTGTextButton::GetBottomMargin() const; TGClient*TGObject::GetClient() const; Pixel_tGetColor() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); static FontStruct_tTGCheckButton::GetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&TGCheckButton::GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGColorSelect.html:4883,error,error,4883,root/html602/TGColorSelect.html,https://root.cern,https://root.cern/root/html602/TGColorSelect.html,4,['error'],['error']
Availability,"al, Float_t rmin, Float_t rmax, Float_t themin, Float_t themax, Float_t phimin, Float_t phimax); virtual~TSPHE(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Float_tGetAspectRatio() const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSPHE.html:1722,Error,Error,1722,root/html532/TSPHE.html,https://root.cern,https://root.cern/root/html532/TSPHE.html,2,['Error'],['Error']
Availability,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TInspectCanvas.html:6175,error,error,6175,root/html534/TInspectCanvas.html,https://root.cern,https://root.cern/root/html534/TInspectCanvas.html,2,['error'],['error']
Availability,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; TButton*GetBackward() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInspectCanvas.html:6033,error,error,6033,root/html528/TInspectCanvas.html,https://root.cern,https://root.cern/root/html528/TInspectCanvas.html,4,['error'],['error']
Availability,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDialogCanvas.html:6673,error,error,6673,root/html534/TDialogCanvas.html,https://root.cern,https://root.cern/root/html534/TDialogCanvas.html,2,['error'],['error']
Availability,"al, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTCanvas::EnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTCanvas::FeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidTCanvas::Flush(); voidTCanvas::ForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tTCanvas::GetAutoExec() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTCanvas::GetCanvasID() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDialogCanvas.html:6561,error,error,6561,root/html528/TDialogCanvas.html,https://root.cern,https://root.cern/root/html528/TDialogCanvas.html,4,['error'],['error']
Availability,"al::RLogChannel & RGeomLog ();  Log channel for Geomviewer diagnostics. ;  ; template<class RootClass > ; Short_t SetClassVersion (RootClass *);  ; std::vector< std::string > Split (std::string_view str, std::string_view delims, bool skipEmpty);  Splits a string at each character in delims. ;  ; static void StrReplace (std::string &proc, const std::string &pat, const std::string &tr);  Replace all accurances of given string with other string. ;  ; template<typename value_type > ; void ToHumanReadableSize (value_type bytes, Bool_t si, Double_t *coeff, const char **units);  Return the size expressed in 'human readable' format. ;  ; static Bool_t ValidateRule (const std::map< std::string, std::string > &rule, std::string &error_string);  Validate if the user specified rules are correct. ;  ; ROOT::Experimental::RLogChannel & WebGUILog ();  Log channel for WebGUI diagnostics. ;  ; static void WriteAutoVariables (const std::list< std::string > &target, const SourceTypeList_t &source, MembersTypeMap_t &members, std::string &className, std::string &mappedName, std::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  ; int Use the overload accepting RCompressionSetting::EAlgorithm instead;  ; struct ROOT::RQt5Crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:18322,down,down,18322,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,1,['down'],['down']
Availability,"al::RLogChannel & RGeomLog ();  Log channel for Geomviewer diagnostics. ;  ; template<class RootClass > ; Short_t SetClassVersion (RootClass *);  ; std::vector< std::string > Split (std::string_view str, std::string_view delims, bool skipEmpty);  Splits a string at each character in delims. ;  ; static void StrReplace (std::string &proc, const std::string &pat, const std::string &tr);  Replace all accurances of given string with other string. ;  ; template<typename value_type > ; void ToHumanReadableSize (value_type bytes, Bool_t si, Double_t *coeff, const char **units);  Return the size expressed in 'human readable' format. ;  ; static Bool_t ValidateRule (const std::map< std::string, std::string > &rule, std::string &error_string);  Validate if the user specified rules are correct. ;  ; ROOT::Experimental::RLogChannel & WebGUILog ();  Log channel for WebGUI diagnostics. ;  ; static void WriteAutoVariables (const std::list< std::string > &target, const SourceTypeList_t &source, MembersTypeMap_t &members, std::string &className, std::string &mappedName, std::ostream &output);  Write down the sources. ;  ; void WriteReadRawRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for ReadRaw rule, the function name is being written to rule[""funcname""]. ;  ; void WriteReadRuleFunc (SchemaRuleMap_t &rule, int index, std::string &mappedName, MembersTypeMap_t &members, std::ostream &output);  Write the conversion function for Read rule, the function name is being written to rule[""funcname""]. ;  ; void WriteSchemaList (std::list< SchemaRuleMap_t > &rules, const std::string &listName, std::ostream &output);  Write schema rules. ;  . Variables; R__EXTERN TVirtualRWMutex * gCoreMutex = nullptr;  ; R__EXTERN SchemaRuleClassMap_t gReadRawRules;  ; R__EXTERN SchemaRuleClassMap_t gReadRules;  ; struct ROOT::RQt5CreatorReg newRQt5CreatorReg;  ; struct ROOT::RQt6CreatorReg newRQt6CreatorReg;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v630/namespaceROOT.html:18232,down,down,18232,doc/v630/namespaceROOT.html,https://root.cern,https://root.cern/doc/v630/namespaceROOT.html,2,['down'],['down']
Availability,"al::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; RooListProxy_mu; TVectorD_muVec! Do not persist; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiVarGaussian.html:40798,error,errors,40798,root/html534/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html534/RooMultiVarGaussian.html,2,['error'],['errors']
Availability,"al::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction1Ref<VO,VI> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registered name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction1Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Mar 10 17:14:45 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1Binding_double_int_.html:36862,ERROR,ERROR,36862,root/html534/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1Binding_double_int_.html,1,['ERROR'],['ERROR']
Availability,"al::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction4Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Sep 8 17:03:03 2015 » Last generated: 2015-09-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html:44283,ERROR,ERROR,44283,root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4PdfBinding_double_double_double_double_bool_.html,1,['ERROR'],['ERROR']
Availability,"al::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction4Ref<double,double,double,double,bool>funcFunction pointer reference; RooRealProxywArgument reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction4Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 30 14:31:48 2015 » Last generated: 2015-06-30 14:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html:46451,ERROR,ERROR,46451,root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4PdfBinding_double_double_double_double_bool_.html,1,['ERROR'],['ERROR']
Availability,"al::analyticalIntegralWN() for further information).; 359///; 360/// This function applies the normalization specified by `normSet` to the integral returned; 361/// by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; 362/// to return a normalized answer.; 363 ; 364double RooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 365{; 366 cxcoutD(Eval) << ""RooAbsPdf::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normset = "" << (normSet?*normSet:RooArgSet()) << endl ;; 367 ; 368 ; 369 if (code==0) return getVal(normSet) ;; 370 if (normSet) {; 371 return analyticalIntegral(code,rangeName) / getNorm(normSet) ;; 372 } else {; 373 return analyticalIntegral(code,rangeName) ;; 374 }; 375}; 376 ; 377 ; 378 ; 379////////////////////////////////////////////////////////////////////////////////; 380/// Check that passed value is positive and not 'not-a-number'. If; 381/// not, print an error, until the error counter reaches its set; 382/// maximum.; 383 ; 384bool RooAbsPdf::traceEvalPdf(double value) const; 385{; 386 // check for a math error or negative value; 387 bool error(false) ;; 388 if (TMath::IsNaN(value)) {; 389 logEvalError(Form(""p.d.f value is Not-a-Number (%f), forcing value to zero"",value)) ;; 390 error=true ;; 391 }; 392 if (value<0) {; 393 logEvalError(Form(""p.d.f value is less than zero (%f), forcing value to zero"",value)) ;; 394 error=true ;; 395 }; 396 ; 397 // do nothing if we are no longer tracing evaluations and there was no error; 398 if(!error) return error ;; 399 ; 400 // otherwise, print out this evaluations input values and result; 401 if(++_errorCount <= 10) {; 402 cxcoutD(Tracing) << ""*** Evaluation Error "" << _errorCount << "" "";; 403 if(_errorCount == 10) cxcoutD(Tracing) << ""(no more will be printed) "";; 404 }; 405 else {; 406 return error ;; 407 }; 408 ; 409 Print() ;; 410 return error ;; 411}; 412 ; 413 ; 414//////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:14262,error,error,14262,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['error'],['error']
Availability,"al; Browse(TBrowser *b)TObjectvirtual; CheckedHash()TObjectinline; Class()TFreestatic; Class_Name()TFreestatic; Class_Version()TFreeinlinestatic; ClassName() constTObjectvirtual; Clear(Option_t *="""")TObjectinlinevirtual; Clone(const char *newname="""") constTObjectvirtual; Compare(const TObject *obj) constTObjectvirtual; Copy(TObject &object) constTObjectvirtual; DeclFileName()TFreeinlinestatic; Delete(Option_t *option="""")TObjectvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fFirstTFreeprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TFreevirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fLastTFreeprotected; fUniqueIDTObjectprivate; GetBestFree(TList *lfree, Int_t nbytes)TFree; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetFirst() constTFreeinline; GetIconName() constTObjectvirtual; GetLast() constTFreeinline; GetName() constTObjectvirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetTitle() constTObjectvirtual; GetUniqueID() constTObjectvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() constTObjectvirtual; HasInconsistentHash()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFree-members.html:1347,error,error,1347,doc/master/classTFree-members.html,https://root.cern,https://root.cern/doc/master/classTFree-members.html,2,['error'],['error']
Availability,"al; CheckedHash()TObjectinline; Class()TNamedstatic; Class_Name()TNamedstatic; Class_Version()TNamedinlinestatic; ClassName() constTObjectvirtual; Clear(Option_t *option="""") overrideTNamedvirtual; Clone(const char *newname="""") const overrideTNamedvirtual; Compare(const TObject *obj) const overrideTNamedvirtual; Copy(TObject &named) const overrideTNamedvirtual; DeclFileName()TNamedinlinestatic; Delete(Option_t *option="""")TObjectvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fNameTNamedprotected; fTitleTNamedprotected; fUniqueIDTObjectprivate; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetIconName() constTObjectvirtual; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetTitle() const overrideTNamedinlinevirtual; GetUniqueID() constTObjectvirtual; HandleTimer(TTimer *timer)TObjectvirtual; Hash() const overrideTNamedinlinevirtual; HasInconsistentHash() constTObjectinline; Info(const char *method, const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNamed-members.html:1325,error,error,1325,doc/master/classTNamed-members.html,https://root.cern,https://root.cern/doc/master/classTNamed-members.html,2,['error'],['error']
Availability,"al; Compare(const TObject *obj) constTObjectvirtual; ComputeLogs(Int_t npoints, Int_t opt)TGraphPainter; Copy(TObject &object) constTObjectvirtual; DeclFileName()TGraphPainterinlinestatic; Delete(Option_t *option="""")TObjectvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DistancetoPrimitiveHelper(TGraph *theGraph, Int_t px, Int_t py) overrideTGraphPaintervirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; DrawPanelHelper(TGraph *theGraph) overrideTGraphPaintervirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; ExecuteEventHelper(TGraph *theGraph, Int_t event, Int_t px, Int_t py) overrideTGraphPaintervirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fgDtorOnlyTObjectprivatestatic; fgMaxPointsPerLineTGraphPainterprotectedstatic; fgObjectStatTObjectprivatestatic; fgPainterTVirtualGraphPainterprivatestatic; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fUniqueIDTObjectprivate; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetHighlightPoint(TGraph *theGraph) constTGraphPaintervirtual; GetIconName() constTObjectvirtual; GetName() constTObjectvirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectInfoHelper(TGraph *theGraph, Int_t px, Int_t py) const overrideTGraphPaintervirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetPainter()TVirtualGraphPainterstatic; GetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPainter-members.html:1546,error,error,1546,doc/master/classTGraphPainter-members.html,https://root.cern,https://root.cern/doc/master/classTGraphPainter-members.html,2,['error'],['error']
Availability,"al; }. unsigned int NCalls() const; Number of function calls to find minimum. { return fNCalls; }. double Edm() const; Expected distance from minimum. { return fEdm; }. unsigned int NTotalParameters() const; get total number of parameters. { return fParams.size(); }. unsigned int NPar() const; total number of parameters (abbreviation). { return NTotalParameters(); }. unsigned int NFreeParameters() const; get total number of free parameters. { return fNFree; }. int Status() const; minimizer status code. { return fStatus; }. int CovMatrixStatus() const; covariance matrix status code; using Minuit convention : =0 not calculated, =1 approximated, =2 made pos def , =3 accurate. { return fCovStatus; }. const IModelFunction * FittedFunction() const; fitting quantities ; Return pointer to model (fit) function with fitted parameter values.; Pointer is managed internally. I must not be deleted. const BinData * FittedBinData() const; return BinData used in the fit (return a nullptr in case a different fit is done; or the data are not available; Pointer is managed internally, it must not be deleted. double Chi2() const; Chi2 fit value; in case of likelihood must be computed ?. { return fChi2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; paramete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__FitResult.html:7927,avail,available,7927,root/html604/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__FitResult.html,2,['avail'],['available']
Availability,"al;  number of function evaluation ;  ; double fRelError;  Relative error. ;  ; double fRelTol;  relative tolerance ;  ; double fResult;  last integration result ;  ; unsigned int fSize;  max size of working array (explode with dimension) ;  ; int fStatus;  status of algorithm (error if not zero) ;  . #include <Math/AdaptiveIntegratorMultiDim.h>. Inheritance diagram for ROOT::Math::AdaptiveIntegratorMultiDim:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ AdaptiveIntegratorMultiDim() [1/2]. ROOT::Math::AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim ; (; double ; absTol = 0.0, . double ; relTol = 1E-9, . unsigned int ; maxpts = 100000, . unsigned int ; size = 0 . ). explicit . Construct given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ; The integration will stop when the absolute error is less than the absolute tolerance OR when the relative error is less than the relative tolerance. The absolute tolerance by default is not used (it is equal to zero). The size of working array represents the number of sub-division used for calculating the integral. Higher the dimension, larger sizes are required for getting the same accuracy. The size must be larger than \( (2n + 3) (1 + maxpts/(2^n + 2n(n + 1) + 1))/2) \). For smaller value passed, the minimum allowed will be used ; Definition at line 17 of file AdaptiveIntegratorMultiDim.cxx. ◆ AdaptiveIntegratorMultiDim() [2/2]. ROOT::Math::AdaptiveIntegratorMultiDim::AdaptiveIntegratorMultiDim ; (; const IMultiGenFunction & ; f, . double ; absTol = 0.0, . double ; relTol = 1E-9, . unsigned int ; maxcall = 100000, . unsigned int ; size = 0 . ). explicit . Construct with a reference to the integrand function and given optionally tolerance (absolute and relative), maximum number of function evaluation (maxpts) and size of the working array. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:6724,error,error,6724,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,4,"['error', 'toler']","['error', 'tolerance']"
Availability,"alClass(); ; Definition at line 3659 of file TTreeFormula.cxx. ◆ EvalStringInstance(). const char * TTreeFormula::EvalStringInstance ; (; Int_t ; i = 0). virtual . Eval the instance as a string. ; Definition at line 3710 of file TTreeFormula.cxx. ◆ FindLeafForExpression(). Int_t TTreeFormula::FindLeafForExpression ; (; const char * ; expression, . TLeaf *& ; leaf, . TString & ; leftover, . bool & ; final, . UInt_t & ; paran_level, . TObjArray & ; castqueue, . std::vector< std::string > & ; aliasUsed, . bool & ; useLeafCollectionObject, . const char * ; fullExpression . ). protected . Look for the leaf corresponding to the start of expression. ; It returns the corresponding leaf if any. It also modify the following arguments:. leftover: contain from expression that was not used to determine the leaf; final:; paran_level: number of un-matched open parenthesis; cast_queue: list of cast to be done; aliases: list of aliases used. Return <0 in case of failure; Return 0 if a leaf has been found; Return 2 if info about the TTree itself has been requested. . Definition at line 2188 of file TTreeFormula.cxx. ◆ GetConstant() [1/2]. template<typename T > . T TTreeFormula::GetConstant ; (; Int_t ; k). inlineprivate . Definition at line 3946 of file TTreeFormula.cxx. ◆ GetConstant() [2/2]. template<> . Long64_t TTreeFormula::GetConstant ; (; Int_t ; k). inline . Definition at line 3947 of file TTreeFormula.cxx. ◆ GetLeaf(). TLeaf * TTreeFormula::GetLeaf ; (; Int_t ; n); const. virtual . Return leaf corresponding to serial number n. ; Definition at line 4465 of file TTreeFormula.cxx. ◆ GetLeafInfo(). TFormLeafInfo * TTreeFormula::GetLeafInfo ; (; Int_t ; code); const. Return DataMember corresponding to code. ; function called by TLeafObject::GetValue with the value of fLookupType computed in TTreeFormula::DefinedVariable ; Definition at line 4456 of file TTreeFormula.cxx. ◆ GetLeafWithDatamember(). TLeaf * TTreeFormula::GetLeafWithDatamember ; (; const char * ; topchoice, . const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:39641,failure,failure,39641,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['failure'],['failure']
Availability,"alErrors()); 275 {; 276 }; 277 ; 278 /// Construct the scoped count for any diagnostic, whatever its channel.; 279 RLogScopedDiagCount() : RLogScopedDiagCount(RLogManager::Get()) {}; 280 ; 281 /// Get the number of warnings that the RLogDiagCount has emitted since construction of *this.; 282 long long GetAccumulatedWarnings() const { return fCounter->GetNumWarnings() - fInitialWarnings; }; 283 ; 284 /// Get the number of errors that the RLogDiagCount has emitted since construction of *this.; 285 long long GetAccumulatedErrors() const { return fCounter->GetNumErrors() - fInitialErrors; }; 286 ; 287 /// Get the number of errors that the RLogDiagCount has emitted since construction of *this.; 288 long long GetAccumulatedFatalErrors() const { return fCounter->GetNumFatalErrors() - fInitialFatalErrors; }; 289 ; 290 /// Whether the RLogDiagCount has emitted a warnings since construction time of *this.; 291 bool HasWarningOccurred() const { return GetAccumulatedWarnings(); }; 292 ; 293 /// Whether the RLogDiagCount has emitted an error (fatal or not) since construction time of *this.; 294 bool HasErrorOccurred() const { return GetAccumulatedErrors() + GetAccumulatedFatalErrors(); }; 295 ; 296 /// Whether the RLogDiagCount has emitted an error or a warning since construction time of *this.; 297 bool HasErrorOrWarningOccurred() const { return HasWarningOccurred() || HasErrorOccurred(); }; 298};; 299 ; 300namespace Internal {; 301 ; 302inline RLogChannel &GetChannelOrManager(); 303{; 304 return RLogManager::Get();; 305}; 306inline RLogChannel &GetChannelOrManager(RLogChannel &channel); 307{; 308 return channel;; 309}; 310 ; 311} // namespace Internal; 312 ; 313inline ELogLevel RLogChannel::GetEffectiveVerbosity(const RLogManager &mgr) const; 314{; 315 if (fVerbosity == ELogLevel::kUnset); 316 return mgr.GetVerbosity();; 317 return fVerbosity;; 318}; 319 ; 320} // namespace Experimental; 321} // namespace ROOT; 322 ; 323#if defined(_MSC_VER); 324#define R__LOG_PRETTY_FUNCTION _",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:10960,error,error,10960,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['error']
Availability,"alPacketizer::AddProcessed(TSlave*, TProofProgressStatus*, Double_t, TList**); virtual Int_tTVirtualPacketizer::AddWorkers(TList* workers); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetActiveWorkers(); Long64_tTVirtualPacketizer::GetBytesRead() const; TList*TVirtualPacketizer::GetConfigParams(Bool_t steal = kFALSE); Double_tTVirtualPacketizer::GetCumProcTime() const; virtual Float_tGetCurrentRate(Bool_t& all); Double_tGetCurrentTime(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Long64_tTVirtualPacketizer::GetEntriesProcessed() const; virtual Int_tTVirtualPacketizer::GetEstEntriesProcessed(Float_t, Long64_t& ent, Long64_t& bytes, Long64_t& calls); TList*TVirtualPacketizer::GetFailedPackets(); virtual const char*TObject::GetIconName() const; Float_tTVirtualPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPacketizerFile.html:1710,error,error,1710,root/html534/TPacketizerFile.html,https://root.cern,https://root.cern/root/html534/TPacketizerFile.html,2,['error'],['error']
Availability,"alPar(x, params);; 825 } else; 826 return TF1::EvalPar((double *)x, params);; 827}; 828 ; 829////////////////////////////////////////////////////////////////////////////////; 830/// Eval for vectorized functions; 831// template <class T>; 832// T TF1::Eval(T x, T y, T z, T t) const; 833// {; 834// if (fType == EFType::kFormula); 835// return fFormula->Eval(x, y, z, t);; 836 ; 837// T xx[] = {x, y, z, t};; 838// Double_t *pp = (Double_t *)fParams->GetParameters();; 839// return ((TF1 *)this)->EvalPar(xx, pp);; 840// }; 841 ; 842// Internal to TF1. Evaluates Templated interfaces; 843template <class T>; 844inline T TF1::EvalParTempl(const T *data, const Double_t *params); 845{; 846 assert(fType == EFType::kTemplScalar || fType == EFType::kTemplVec);; 847 if (!params) params = (Double_t *)fParams->GetParameters();; 848 if (fFunctor); 849 return ((TF1FunctorPointerImpl<T> *)fFunctor.get())->fImpl(data, params);; 850 ; 851 // this should throw an error; 852 // we nned to implement a vectorized GetSave(x); 853 return TMath::SignalingNaN();; 854}; 855 ; 856#ifdef R__HAS_VECCORE; 857// Internal to TF1. Evaluates Vectorized TF1 on data of type Double_v; 858inline double TF1::EvalParVec(const Double_t *data, const Double_t *params); 859{; 860 assert(fType == EFType::kTemplVec);; 861 std::vector<ROOT::Double_v> d(fNdim);; 862 ROOT::Double_v res;; 863 ; 864 for(auto i=0; i<fNdim; i++) {; 865 d[i] = ROOT::Double_v(data[i]);; 866 }; 867 ; 868 if (fFunctor) {; 869 res = ((TF1FunctorPointerImpl<ROOT::Double_v> *) fFunctor.get())->fImpl(d.data(), params);; 870 } else {; 871 // res = GetSave(x);; 872 return TMath::SignalingNaN();; 873 }; 874 return vecCore::Get<ROOT::Double_v>(res, 0);; 875}; 876#endif; 877 ; 878inline void TF1::SetRange(Double_t xmin, Double_t, Double_t xmax, Double_t); 879{; 880 TF1::SetRange(xmin, xmax);; 881}; 882inline void TF1::SetRange(Double_t xmin, Double_t, Double_t, Double_t xmax, Double_t, Double_t); 883{; 884 TF1::SetRange(xmin, xmax);; 885}; 886 ; 887temp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8h_source.html:36475,error,error,36475,doc/master/TF1_8h_source.html,https://root.cern,https://root.cern/doc/master/TF1_8h_source.html,1,['error'],['error']
Availability,"alVar for the variable. ~HypoTestInverter(); destructor. void CreateResults(); create a new HypoTestInverterResult to hold all computed results. bool RunAutoScan(double xMin, double xMax, double target, double epsilon = 0.005, unsigned int numAlgorithm = 0); Search for the value of the parameter of interest (vary the; hypothesis being tested) in the specified range [xMin,xMax]; until the confidence level is compatible with the target value; within one time the estimated error (and the estimated error; should also become smaller than the specified parameter epsilon). bool RunFixedScan(int nBins, double xMin, double xMax); Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX); run only one point. HypoTestInverter(); default constructor (used only for I/O). HypoTestInverterResult* GetInterval() const; { return fResults; }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetData(RooAbsData& ); { }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 31798 2009-12-10 14:57:15Z moneta $ » Last generated: 2009-12-14 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__HypoTestInverter.html:9102,error,error,9102,root/html526/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html526/RooStats__HypoTestInverter.html,2,['error'],['error']
Availability,"alVar for the variable. ~HypoTestInverter(); destructor. void CreateResults(); create a new HypoTestInverterResult to hold all computed results. bool RunAutoScan(double xMin, double xMax, double target, double epsilon = 0.005, unsigned int numAlgorithm = 0); Search for the value of the parameter of interest (vary the; hypothesis being tested) in the specified range [xMin,xMax]; until the confidence level is compatible with the target value; within one time the estimated error (and the estimated error; should also become smaller than the specified parameter epsilon). bool RunFixedScan(int nBins, double xMin, double xMax); Run a Fixed scan in npoints between min and max. bool RunOnePoint(double thisX); run only one point. HypoTestInverter(); default constructor (used only for I/O). HypoTestInverterResult* GetInterval() const; { return fResults; }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetData(RooAbsData& ); { }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 31798 2009-12-10 14:57:15Z moneta $ » Last generated: 2010-09-23 20:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HypoTestInverter.html:9078,error,error,9078,root/html528/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html528/RooStats__HypoTestInverter.html,2,['error'],['error']
Availability,"alVdouble getValV(const RooArgSet *set=nullptr) const overrideReturn current value, normalized by integrating over the observables in nset.Definition RooAbsPdf.cxx:319; RooAbsPdf::fitToImplvirtual std::unique_ptr< RooFitResult > fitToImpl(RooAbsData &data, const RooLinkedList &cmdList)Protected implementation of the likelihood fitting routine.Definition RooAbsPdf.cxx:1072; RooAbsPdf::generateEventvirtual void generateEvent(Int_t code)Interface for generation of an event using the algorithm corresponding to the specified code.Definition RooAbsPdf.cxx:1544; RooAbsPdf::createScanCdfRooFit::OwningPtr< RooAbsReal > createScanCdf(const RooArgSet &iset, const RooArgSet &nset, Int_t numScanBins, Int_t intOrder)Definition RooAbsPdf.cxx:2545; RooAbsPdf::setGeneratorConfigvoid setGeneratorConfig()Remove the specialized numeric MC generator configuration associated with this object.Definition RooAbsPdf.cxx:2675; RooAbsPdf::resetErrorCountersvirtual void resetErrorCounters(Int_t resetValue=10)Reset error counter to given value, limiting the number of future error messages for this pdf to 'res...Definition RooAbsPdf.cxx:586; RooAbsPdf::verboseEvalstatic int verboseEval()Return global level of verbosity for p.d.f. evaluations.Definition RooAbsPdf.cxx:2418; RooAbsPdf::createCdfRooFit::OwningPtr< RooAbsReal > createCdf(const RooArgSet &iset, const RooArgSet &nset=RooArgSet())Create a cumulative distribution function of this p.d.f in terms of the observables listed in iset.Definition RooAbsPdf.cxx:2468; RooAbsPdf::isActiveNormSetbool isActiveNormSet(RooArgSet const *normSet) constChecks if normSet is the currently active normalization set of this PDF, meaning is exactly the same ...Definition RooAbsPdf.h:299; RooAbsPdf::expectedEventsvirtual double expectedEvents(const RooArgSet *nset) constReturn expected number of events to be used in calculation of extended likelihood.Definition RooAbsPdf.cxx:2398; RooAbsPdf::binnedGenContextvirtual RooAbsGenContext * binnedGenContext(const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:144858,error,error,144858,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['error'],['error']
Availability,"alculates roots of polynomial of 3rd order a*x^3 + b*x^2 + c*x + d, where.Definition TMath.cxx:1107; TMath::ChisquareQuantileDouble_t ChisquareQuantile(Double_t p, Double_t ndf)Evaluate the quantiles of the chi-squared probability distribution function.Definition TMath.cxx:2193; TMath::SinDouble_t Sin(Double_t)Returns the sine of an angle of x radians.Definition TMath.h:588; TMath::FDistDouble_t FDist(Double_t F, Double_t N, Double_t M)Computes the density function of F-distribution (probability function, integral of density,...Definition TMath.cxx:2277; TMath::SignalingNaNDouble_t SignalingNaN()Returns a signaling NaN as defined by IEEE 754](http://en.wikipedia.org/wiki/NaN#Signaling_NaN).Definition TMath.h:910; TMath::BreitWignerRelativisticDouble_t BreitWignerRelativistic(Double_t x, Double_t median=0, Double_t gamma=1)Calculates a Relativistic Breit Wigner function with median and gamma.Definition TMath.cxx:452; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::CrossT * Cross(const T v1[3], const T v2[3], T out[3])Calculates the Cross Product of two vectors: out = [v1 x v2].Definition TMath.h:1197; TMath::BubbleLowvoid BubbleLow(Int_t Narr, Double_t *arr1, Int_t *arr2)Opposite ordering of the array arr2[] to that of BubbleHigh.Definition TMath.cxx:1353; TMath::BesselKDouble_t BesselK(Int_t n, Double_t x)Integer order modified Bessel function I_n(x)Definition TMath.cxx:1561; TMath::Naconstexpr Double_t Na()Avogadro constant (Avogadro's Number) in .Definition TMath.h:284; TMath::MaxElementT MaxElement(Long64_t n, const T *a)Returns maximum of array a of length n.Definition TMath.h:968; TMath::BesselJ1Double_t BesselJ1(Double_t x)Bessel function J0(x) for any real x.Definition TMath.cxx:1669; TMath::BetaIncompleteDouble_t BetaIncomplete(Double_t x, Double_t a, Double_t b)Calculates the incomplete Beta-function.Definition TMath.cxx:21",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:70022,down,down,70022,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['down'],['down']
Availability,alculating the integral ; Reimplemented from ROOT::Math::VirtualIntegrator.; Definition at line 152 of file AdaptiveIntegratorMultiDim.h. ◆ Options(). ROOT::Math::IntegratorMultiDimOptions ROOT::Math::AdaptiveIntegratorMultiDim::Options ; (; ); const. overridevirtual . get the option used for the integration ; Implements ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 390 of file AdaptiveIntegratorMultiDim.cxx. ◆ RelError(). double ROOT::Math::AdaptiveIntegratorMultiDim::RelError ; (; ); const. inline . return relative error ; Definition at line 137 of file AdaptiveIntegratorMultiDim.h. ◆ Result(). double ROOT::Math::AdaptiveIntegratorMultiDim::Result ; (; ); const. inlineoverridevirtual . return result of integration ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 131 of file AdaptiveIntegratorMultiDim.h. ◆ SetAbsTolerance(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetAbsTolerance ; (; double ; absTol). overridevirtual . set absolute tolerance ; Implements ROOT::Math::VirtualIntegrator.; Definition at line 73 of file AdaptiveIntegratorMultiDim.cxx. ◆ SetFunction(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetFunction ; (; const IMultiGenFunction & ; f). overridevirtual . set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim) ; Implements ROOT::Math::VirtualIntegratorMultiDim.; Definition at line 63 of file AdaptiveIntegratorMultiDim.cxx. ◆ SetMaxPts(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetMaxPts ; (; unsigned int ; n). inline . set max points ; Definition at line 167 of file AdaptiveIntegratorMultiDim.h. ◆ SetMinPts(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetMinPts ; (; unsigned int ; n). inline . set min points ; Definition at line 164 of file AdaptiveIntegratorMultiDim.h. ◆ SetOptions(). void ROOT::Math::AdaptiveIntegratorMultiDim::SetOptions ; (; const ROOT::Math::IntegratorMultiDimOptions & ; opt). overridevirtual . set the options ; Reimplemented from ROOT::Math::V,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html:10267,toler,tolerance,10267,doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1AdaptiveIntegratorMultiDim.html,1,['toler'],['tolerance']
Availability,"ale(Double_t c1=1., Option_t *option=""y"") overrideMultiply the values and errors of a TGraphMultiErrors by a constant c1.Definition TGraphMultiErrors.cxx:1766; TGraphMultiErrors::SetLineColorAlphavirtual void SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha)Set Line Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2084; TGraphMultiErrors::SetFillColorvirtual void SetFillColor(Int_t e, Color_t fcolor)Set Fill Color of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2040; TGraphMultiErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphMultiErrors.h:141; TGraphMultiErrors::CalcYErrorsSumvoid CalcYErrorsSum() constRecalculates the summed y error arrays.Definition TGraphMultiErrors.cxx:822; TGraphMultiErrors::~TGraphMultiErrors~TGraphMultiErrors() overrideTGraphMultiErrors default destructor.Definition TGraphMultiErrors.cxx:697; TGraphMultiErrors::SetAttLinevirtual void SetAttLine(Int_t e, TAttLine *tal)Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2029; TGraphMultiErrors::fEyHSumDouble_t * fEyHSum! Array of summed Y high errors for fittingDefinition TGraphMultiErrors.h:40; TGraphMultiErrors::GetEYlowDouble_t * GetEYlow() const overrideGet all low errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1577; TGraphMultiErrors::DeleteYErrorvirtual void DeleteYError(Int_t e)Deletes the y error with the index e.Definition TGraphMultiErrors.cxx:1422; TGraphMultiErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphMultiErrors.cxx:951; TGraphMultiErrors::SetFillStylevirtual void SetFillStyle(Int_t e, Style_t fstyle)Set Fill Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2062; TGraphMultiErrors::SetEYhighvirtual void SetEYhigh(Int_t e, Int_t np, const Double_t *eyH)Set error e eyH values.Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:84013,error,error,84013,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"ale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse* delta, const Int_t* binMap); sum over bins of *delta, as defined in binMap,fXToHist; hist_delta: histogram to return summed vector; delta: vector to sum and remap. TUnfoldSys(const TUnfoldSys& ). TMatrixDSparse * PrepareCorrEmat(const TMatrixDSparse* m1, const TMatrixDSparse* m2, const TMatrixDSparse* dsys). void ScaleColumnsByVector(TMatrixDSparse* m, const TMatrixTBase<Double_t>* v) const. void GetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE). » Last changed: root/hist:$Id: TUnfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:26320,error,error,26320,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,12,['error'],"['error', 'errors']"
Availability,"ale(const char* name, Double_t sx, Double_t sy, Double_t sz); virtual~TGeoScale(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoScale.html:8131,error,error,8131,root/html528/TGeoScale.html,https://root.cern,https://root.cern/root/html528/TGeoScale.html,6,['error'],['error']
Availability,"aleFactor_PILEUP * mcWeight * {} / {} * {}"".format(xsecs[s], sumws[s], lumi)); ; # Compute transverse mass of the W boson using the lepton and the missing transverse energy and make a histogram; ROOT.gInterpreter.Declare(""""""; float ComputeTransverseMass(float met_et, float met_phi, float lep_pt, float lep_eta, float lep_phi, float lep_e); {; ROOT::Math::PtEtaPhiEVector met(met_et, 0, met_phi, met_et);; ROOT::Math::PtEtaPhiEVector lep(lep_pt, lep_eta, lep_phi, lep_e);; return (met + lep).Mt() / 1000.0;; }; """"""); ; histos = {}; for s in samples:; df[s] = df[s].Define(""mt_w"", ""ComputeTransverseMass(met_et, met_phi, lep_pt[idx], lep_eta[idx], lep_phi[idx], lep_E[idx])""); histos[s] = df[s].Histo1D(ROOT.RDF.TH1DModel(s, ""mt_w"", 24, 60, 180), ""mt_w"", ""weight""); ; # Run the event loop and merge histograms of the respective processes; ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([histos[s] for s in samples]); ; def merge_histos(label):; h = None; for i, d in enumerate(files[label]):; t = histos[d[1]].GetValue(); if i == 0: h = t.Clone(); else: h.Add(t); h.SetNameTitle(label, label); return h; ; data = merge_histos(""data""); wjets = merge_histos(""wjets""); zjets = merge_histos(""zjets""); ttbar = merge_histos(""ttbar""); diboson = merge_histos(""diboson""); singletop = merge_histos(""singletop""); ; # Create the plot; ; # Set styles; ROOT.gROOT.SetStyle(""ATLAS""); ; # Create canvas; c = ROOT.TCanvas(""c"", """", 600, 600); c.SetTickx(0); c.SetTicky(0); c.SetLogy(); ; # Draw stack with MC contributions; stack = ROOT.THStack(); for h, color in zip(; [singletop, diboson, ttbar, zjets, wjets],; [(208, 240, 193), (195, 138, 145), (155, 152, 204), (248, 206, 104), (222, 90, 106)]):; h.SetLineWidth(1); h.SetLineColor(1); h.SetFillColor(ROOT.TColor.GetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:5954,avail,available,5954,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,2,['avail'],['available']
Availability,"algorithm that determines the interval, so call this after initializing all other aspects of this IntervalCalculator Also, calling this function again with a different confidence level re-triggers the calculation of the interval ; Implements RooStats::ConfInterval.; Definition at line 226 of file MCMCInterval.cxx. ◆ SetDelta(). virtual void RooStats::MCMCInterval::SetDelta ; (; double ; delta). inlinevirtual . kbelasco: The inner-workings of the class really should not be exposed like this in a comment, but it seems to be the only way to give the user any control over this process, if they desire it ; Set the fraction delta such that topCutoff (a) is considered == bottomCutoff (b) iff (std::abs(a - b) < std::abs(fDelta * (a + b)/2)) when determining the confidence interval by Keys ; Definition at line 264 of file MCMCInterval.h. ◆ SetEpsilon(). virtual void RooStats::MCMCInterval::SetEpsilon ; (; double ; epsilon). inlinevirtual . set the acceptable level or error for Keys interval determination ; Definition at line 229 of file MCMCInterval.h. ◆ SetHistStrict(). virtual void RooStats::MCMCInterval::SetHistStrict ; (; bool ; isHistStrict). inlinevirtual . whether the specified confidence level is a floor for the actual confidence level (strict), or a ceiling (not strict) ; Definition at line 82 of file MCMCInterval.h. ◆ SetIntervalType(). virtual void RooStats::MCMCInterval::SetIntervalType ; (; enum IntervalType ; intervalType). inlinevirtual . Set the type of interval to find. ; This will only have an effect for 1-D intervals. If is more than 1 parameter of interest, then a ""shortest"" interval will always be used, since it generalizes directly to N dimensions ; Definition at line 243 of file MCMCInterval.h. ◆ SetLeftSideTailFraction(). virtual void RooStats::MCMCInterval::SetLeftSideTailFraction ; (; double ; a). inlinevirtual . set the left-side tail fraction for a tail-fraction interval ; Definition at line 251 of file MCMCInterval.h. ◆ SetNumBurnInSteps(). virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1MCMCInterval.html:37748,error,error,37748,doc/master/classRooStats_1_1MCMCInterval.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1MCMCInterval.html,1,['error'],['error']
Availability,"alidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfErrorCodeerror code of last operation; TStringfErrorMsgerror message of last operation; Bool_tfErrorOutenable error output. Class Charts. Inheritance Chart:. TObject. ←; TSQLStatement. ←. TMySQLStatement. Function documentation; Int_t GetErrorCode() const; returns error code of last operation; if res==0, no error; Each specific implementation of TSQLStatement provides its own error coding. const char* GetErrorMsg() const; returns error message of last operation; if no errors, return 0; Each specific implementation of TSQLStatement provides its own error messages. void ClearError(); reset error fields. void SetError(Int_t code, const char* msg, const char* method = 0); set new values for error fields; if method specified, displays error message. Bool_t SetDate(Int_t , const TDatime& ); set only date value for specified parameter from TDatime object. Bool_t SetTime(Int_t , const TDatime& ); set only time value for specified parameter from TDatime object. Bool_t SetDatime(Int_t , const TDatime& ); set date & time value for specified parameter from TDatime object. Bool_t SetTimestamp(Int_t , const TDatime& ); set timestamp value for specified parameter from TDatime object. TDatime GetDatime(Int_t ); return value of parameter in form of TDatime; Be aware, that TDatime does not allow dates before 1995-01-01. Int_t GetYear(Int_t ); return year value for parameter (if applicable). Int_t GetMonth(Int_t ); return month value for parameter (if applicable). Int_t GetDa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLStatement.html:19369,error,error,19369,root/html602/TSQLStatement.html,https://root.cern,https://root.cern/root/html602/TSQLStatement.html,12,['error'],"['error', 'errors']"
Availability,"alidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TNDArrayT<ULong64_t>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum(anonymous)THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension; static THnBase::(anonymous)THnBase::kInvalidInt; static THnBase::(anonymous)THnBase::kNoInt; static THnBase::(anonymous)THnBase::kValidInt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THn& operator=(const THn&). GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:12; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THnT_ULong64_t_.html:11735,error,error,11735,root/html602/THnT_ULong64_t_.html,https://root.cern,https://root.cern/root/html602/THnT_ULong64_t_.html,4,['error'],"['error', 'errors']"
Availability,"alidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TNDArrayT<ULong64_t>fArraybin content; TObjArrayTHnBase::fAxesaxes of the histogram; TObjArrayTHnBase::fBrowsables! browser-helpers for each axis; Int_t*THn::fCoordBuf! Temporary buffer; Double_tTHnBase::fEntriesnumber of entries, spread over chunks; Double_t*THnBase::fIntegral! array with bin weight sums; enum(anonymous)THnBase::fIntegralStatus! status of integral; TStringTNamed::fNameobject identifier; Int_tTHnBase::fNdimensionsnumber of dimensions; TNDArrayT<Double_t>THn::fSumw2bin error, lazy allocation happens in TNDArrayT; TStringTNamed::fTitleobject title; Double_tTHnBase::fTsumwtotal sum of weights; Double_tTHnBase::fTsumw2total sum of weights squared; -1 if no errors are calculated; TArrayDTHnBase::fTsumwxtotal sum of weight*X for each dimension; TArrayDTHnBase::fTsumwx2total sum of weight*X*X for each dimension; static THnBase::(anonymous)THnBase::kInvalidInt; static THnBase::(anonymous)THnBase::kNoInt; static THnBase::(anonymous)THnBase::kValidInt. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THn& operator=(const THn&). GetArray(); Increment the bin content of ""bin"" by ""w"",; return the bin index. return GetArray(). » Author: Axel Naumann, Nov 2011 » Copyright (C) 1995-2012, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-09-08 17:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THnT_ULong64_t_.html:11735,error,error,11735,root/html604/THnT_ULong64_t_.html,https://root.cern,https://root.cern/root/html604/THnT_ULong64_t_.html,4,['error'],"['error', 'errors']"
Availability,"alien; ON; AliEn support, requires libgapiUI from ALICE. all; OFF; Enable all optional components. asimage; ON; Image processing support, requires libAfterImage. astiff; ON; Include tiff support in image processing. bonjour; ON; Bonjour support, requires libdns_sd and/or Avahi. builtin_afterimage; ON; Built included libAfterImage, or use system libAfterImage. builtin_fftw3; OFF; Built the FFTW3 library internally (downloading tarfile from the Web) (ROOT 6 only). builtin_ftgl; ON; Built included libFTGL, or use system libftgl. builtin_freetype; OFF; Built included libfreetype, or use system libfreetype. builtin_glew; ON; Built included libGLEW, or use system libGLEW. builtin_pcre; OFF; Built included libpcre, or use system libpcre. builtin_zlib; OFF; Built included libz, or use system libz. builtin_lzma; OFF; Built included liblzma, or use system liblzma. builtin_davix; OFF; Built the Davix library internally (downloading tarfile from the Web). builtin_gsl; OFF; Built the GSL library internally (downloading tarfile from the Web). builtin_cfitsio; OFF; Built the FITSIO library internally (downloading tarfile from the Web). builtin_xrootd; OFF; Built the XROOTD internally (downloading tarfile from the Web). builtin_llvm; ON; Built the LLVM internally. builtin_tbb; OFF; Built the TBB internally. cxx11; ON; Build using C++11 compatible mode, requires gcc > 4.7.x or clang. cxx14; OFF; Build using C++14 compatible mode, requires gcc > 4.9.x or clang. cxx17; OFF; Build using C++17 compatible mode, requires gcc > 7.1.x or clang. libcxx; OFF; Build using libc++, requires cxx11 option (MacOS X only, for the time being). castor; ON; CASTOR support, requires libshift from CASTOR >= 1.5.2. ccache; OFF; Enable ccache usage for speeding up builds. chirp; ON; Chirp support (Condor remote I/O), requires libchirp_client. cling; ON; Enable new CLING C++ interpreter. cocoa; *; Use native Cocoa/Quartz graphics backend (MacOS X only). davix; *; DavIx library for HTTP/WEBDAV access. dcache;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:8123,down,downloading,8123,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['down'],['downloading']
Availability,"alingFitter(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__SimulatedAnnealingFitter.html:1453,Error,Error,1453,root/html532/TMVA__SimulatedAnnealingFitter.html,https://root.cern,https://root.cern/root/html532/TMVA__SimulatedAnnealingFitter.html,2,['Error'],['Error']
Availability,"alisation term needed to normalise the raw values returned by getVal(). ;  ; const RooAbsReal * getNormIntegral (const RooArgSet &nset) const;  ; virtual const RooAbsReal * getNormObj (const RooArgSet *set, const RooArgSet *iset, const TNamed *rangeName=nullptr) const;  Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range rangeName, optionally taking the integrand normalized over observables nset. ;  ; double getValV (const RooArgSet *set=nullptr) const override;  Return current value, normalized by integrating over the observables in nset. ;  ; virtual void initGenerator (Int_t code);  Interface for one-time initialization to setup the generator for the specified code. ;  ; bool mustBeExtended () const;  If true PDF must provide extended likelihood term. ;  ; const char * normRange () const;  ; virtual RooPlot * paramOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={});  Add a box with parameter values (and errors) to the specified frame. ;  ; RooPlot * plotOn (RooPlot *frame, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={}, const RooCmdArg &arg9={}, const RooCmdArg &arg10={}) const override;  Helper calling plotOn(RooPlot*, RooLinkedList&) const. ;  ; RooPlot * plotOn (RooPlot *frame, RooLinkedList &cmdList) const override;  Plot (project) PDF on specified frame. ;  ; GenSpec * prepareMultiGen (const RooArgSet &whatVars, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={});  Prepare GenSpec configuration object for efficient generation of multiple datasets from identical specificatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDecay.html:15828,error,errors,15828,doc/master/classRooDecay.html,https://root.cern,https://root.cern/doc/master/classRooDecay.html,2,['error'],['errors']
Availability,"ality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of his \(\mbox{FCN}\) means, and also that he is interested in parameter errors, the user can change the error definition which allows him to define what he means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be caused by ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:18286,error,errors,18286,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"ality. Value 0 (low) indicates to M that it should economize function calls; it is intended for cases where there are many variable parameters and/or the function takes a long time to calculate and/or the user is not interested in very precise values for parameter errors. On the other hand, value 2 (high) indicates that M is allowed to waste function calls in order to be sure that all values are precise; it is intended for cases where the function is evaluated in a relatively short time and/or where the parameter errors must be calculated reliably. In addition all constants set in MnStrategy can be changed individually by the user, e.g. the number of iteration cycles in the numerical gradient.; 2.5 Parameter errors; M is usually used to find the “best” values of a set of parameters, where “best” is defined as those values which minimize a given function, \(\mbox{FCN}\). The width of the function minimum, or more generally, the shape of the function in some neighbourhood of the minimum, gives information about the uncertainty in the best parameter values, often called by physicists the parameter errors. An important feature of M is that it offers several tools to analyze the parameter errors.; 2.5.1 \(\mbox{FCN}\) normalization and the error definition; Whatever method is used to calculate the parameter errors, they will depend on the overall (multiplicative) normalization of \(\mbox{FCN}\), in the sense that if the value of \(\mbox{FCN}\) is everywhere multiplied by a constant \(\beta\), then the errors will be decreased by a factor \(\sqrt{\beta}\). Additive constants do not change the parameter errors, but may imply a different goodness-of-fit confidence level.; Assuming that the user knows what the normalization of their \(\mbox{FCN}\) means, and also that they are interested in parameter errors, the user can change the error definition which allows them to define what they means by one “error”, in terms of the change in the \(\mbox{FCN}\) value which should be ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:14256,error,errors,14256,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"alize a TFile object. ; Parameters. [in]createCreate a new file. TFile implementations providing asynchronous open functionality need to override this method to run the appropriate checks before calling this standard initialization part. See TNetXNGFile::Init for an example. ; Reimplemented from TFile.; Definition at line 677 of file TDavixFile.cxx. ◆ IsA(). virtual TClass * TDavixFile::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 128 of file TDavixFile.h. ◆ ReadBuffer() [1/2]. Bool_t TDavixFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). virtual . Read specified byte range from remote file via HTTP. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 737 of file TDavixFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TDavixFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Read a buffer from the file at the offset 'pos' in the file. ; Returns kTRUE in case of failure. Compared to ReadBuffer(char*, Int_t), this routine does not change the cursor on the physical file representation (fD) if the data is in this TFile's cache. ; Reimplemented from TFile.; Definition at line 756 of file TDavixFile.cxx. ◆ ReadBufferAsync(). Bool_t TDavixFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented from TFile.; Definition at line 774 of file TDavixFile.cxx. ◆ ReadBuffers(). Bool_t TDavixFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 790 of file TDavixFile.cxx. ◆ Seek(). void TDavixFile::Seek ; (; Long64_t ; offset, . ERelativeTo ; pos ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDavixFile.html:46070,failure,failure,46070,doc/master/classTDavixFile.html,https://root.cern,https://root.cern/doc/master/classTDavixFile.html,1,['failure'],['failure']
Availability,"all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:61247,error,error,61247,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['error'],['error']
Availability,"all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:70499,error,error,70499,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['error'],['error']
Availability,"all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:72657,error,error,72657,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['error'],['error']
Availability,"all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:73330,error,error,73330,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['error'],['error']
Availability,"all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:60705,error,error,60705,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['error'],['error']
Availability,"all boolean and string properties of the original object. ; Transient properties and client-server links are not copied ; Definition at line 135 of file RooAbsArg.cxx. Member Function Documentation. ◆ addOwnedComponents() [1/4]. bool RooAbsArg::addOwnedComponents ; (; const RooAbsCollection & ; comps). Take ownership of the contents of 'comps'. ; Definition at line 2258 of file RooAbsArg.cxx. ◆ addOwnedComponents() [2/4]. bool RooAbsArg::addOwnedComponents ; (; RooAbsCollection && ; comps). Take ownership of the contents of 'comps'. ; Different from the overload that taked the RooArgSet by const&, this version can also take an owning RooArgSet without error, because the ownership will not be ambiguous afterwards. ; Definition at line 2272 of file RooAbsArg.cxx. ◆ addOwnedComponents() [3/4]. bool RooAbsArg::addOwnedComponents ; (; RooArgList && ; comps). Take ownership of the contents of 'comps'. ; Different from the overload that taked the RooArgSet by const&, this version can also take an owning RooArgSet without error, because the ownership will not be ambiguous afterwards. ; Definition at line 2284 of file RooAbsArg.cxx. ◆ addOwnedComponents() [4/4]. template<typename... Args_t> . bool RooAbsArg::addOwnedComponents ; (; std::unique_ptr< Args_t >... ; comps). inline . Definition at line 516 of file RooAbsArg.h. ◆ addParameters(). void RooAbsArg::addParameters ; (; RooAbsCollection & ; params, . const RooArgSet * ; nset = nullptr, . bool ; stripDisconnected = true . ); const. private . Add all parameters of the function and its daughters to params. ; Parameters. [in]paramsCollection that stores all parameters. Add all new parameters to this. ; [in]nsetNormalisation set (optional). If a value depends on this set, it's not a parameter. ; [in]stripDisconnectedPassed on to getParametersHook(). . Definition at line 582 of file RooAbsArg.cxx. ◆ addServer(). void RooAbsArg::addServer ; (; RooAbsArg & ; server, . bool ; valueProp = true, . bool ; shapeProp = false, . std::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:43832,error,error,43832,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['error'],['error']
Availability,"all failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. TServerSocket(Int_t port, Bool_t reuse = kFALSE, Int_t backlog = kDefaultBacklog, Int_t tcpwindowsize = -1); Create a server socket object on a specified port. Set reuse to true; to force reuse of the server socket (i.e. do not wait for the time; out to pass). Using backlog one can set the desirable queue length; for pending connections. If port is 0 a port scan will be done to; find a free port. This option is mutual exlusive with the reuse option.; Use tcpwindowsize to specify the size of the receive buffer, it has; to be specified here to make sure the window scale option is set (for; tcpwindowsize > 65KB and for platforms supporting window scaling).; Use IsValid() to check the validity of the; server socket. In case server socket is not valid use GetErrorCode(); to obtain the specific error value. These values are:; 0 = no error (socket is valid); -1 = low level socket() call failed; -2 = low level bind() call failed; -3 = low level listen() call failed; Every valid server socket is added to the TROOT sockets list which; will make sure that any open sockets are properly closed on; program termination. ~TServerSocket(); Destructor: cleanup authentication stuff (if any) and close. TSocket * Accept(UChar_t Opt = 0); Accept a connection on a server socket. Returns a full-duplex; communication TSocket object. If no pending connections are; present on the queue and nonblocking mode has not been enabled; with SetOption(kNoBlock,1) the call blocks until a connection is; present. The returned socket must be deleted by the user. The socket; is also added to the TROOT sockets list which will make sure that; any open sockets are properly closed on program termination.; In case of error 0 is returned and in case non-blocking I/O is; enabled and n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TServerSocket.html:12013,error,error,12013,root/html528/TServerSocket.html,https://root.cern,https://root.cern/root/html528/TServerSocket.html,10,['error'],['error']
Availability,"all graphs with errors from the collection to this graph. ; Returns the total number of points in the result or -1 in case of an error. ; Reimplemented from TGraph.; Definition at line 682 of file TGraphErrors.cxx. ◆ operator=(). TGraphErrors & TGraphErrors::operator= ; (; const TGraphErrors & ; gr). TGraphErrors assignment operator. ; Definition at line 184 of file TGraphErrors.cxx. ◆ Print(). void TGraphErrors::Print ; (; Option_t * ; chopt = """"); const. overridevirtual . Print graph and errors values. ; Reimplemented from TGraph.; Definition at line 711 of file TGraphErrors.cxx. ◆ SavePrimitive(). void TGraphErrors::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save primitive as a C++ statement(s) on output stream out. ; Reimplemented from TGraph.; Definition at line 722 of file TGraphErrors.cxx. ◆ Scale(). void TGraphErrors::Scale ; (; Double_t ; c1 = 1., . Option_t * ; option = ""y"" . ). overridevirtual . Multiply the values and errors of a TGraphErrors by a constant c1. ; If option contains ""x"" the x values and errors are scaled If option contains ""y"" the y values and errors are scaled If option contains ""xy"" both x and y values and errors are scaled ; Reimplemented from TGraph.; Definition at line 752 of file TGraphErrors.cxx. ◆ SetPointError() [1/2]. void TGraphErrors::SetPointError ; (; Double_t ; ex, . Double_t ; ey . ). virtual . Set ex and ey values for point pointed by the mouse. ; Definition at line 769 of file TGraphErrors.cxx. ◆ SetPointError() [2/2]. void TGraphErrors::SetPointError ; (; Int_t ; i, . Double_t ; ex, . Double_t ; ey . ). virtual . Set ex and ey values for point number i. ; Definition at line 802 of file TGraphErrors.cxx. ◆ Streamer(). void TGraphErrors::Streamer ; (; TBuffer & ; b). overridevirtual . Stream an object of class TGraphErrors. ; Reimplemented from TGraph.; Reimplemented in TGraphPolar.; Definition at line 817 of file TGraphErrors.cxx. ◆ StreamerNVirtual(). void TGraphErrors::Stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:44662,error,errors,44662,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['error'],['errors']
Availability,"all selection rules are used!\n"");; 4877 }; 4878 ; 4879 if (!gOptGeneratePCH){; 4880 rootclingRetCode += CheckForUnsupportedClasses(scan.fSelectedClasses);; 4881 if (rootclingRetCode) return rootclingRetCode;; 4882 }; 4883 ; 4884 // SELECTION LOOP; 4885 // Check for error in the class layout before doing anything else.; 4886 for (auto const & annRcd : scan.fSelectedClasses) {; 4887 if (ROOT::TMetaUtils::ClassInfo__HasMethod(annRcd, ""Streamer"", interp)) {; 4888 if (annRcd.RequestNoInputOperator()) {; 4889 int version = ROOT::TMetaUtils::GetClassVersion(annRcd, interp);; 4890 if (version != 0) {; 4891 // Only Check for input operator is the object is I/O has; 4892 // been requested.; 4893 has_input_error |= CheckInputOperator(annRcd, interp);; 4894 }; 4895 }; 4896 }; 4897 has_input_error |= !CheckClassDef(*annRcd, interp);; 4898 }; 4899 ; 4900 if (has_input_error) {; 4901 // Be a little bit makefile friendly and remove the dictionary in case of error.; 4902 // We could add an option -k to keep the file even in case of error.; 4903 exit(1);; 4904 }; 4905 ; 4906 //---------------------------------------------------------------------------; 4907 // Write all the necessary #include; 4908 /////////////////////////////////////////////////////////////////////////////; 4909 if (!gDriverConfig->fBuildingROOTStage1) {; 4910 for (auto &&includedFromLinkdef : filesIncludedByLinkdef) {; 4911 includeForSource += ""#include \"""" + includedFromLinkdef + ""\""\n"";; 4912 }; 4913 }; 4914 ; 4915 if (!gOptGeneratePCH) {; 4916 if (!gOptIgnoreExistingDict) {; 4917 GenerateNecessaryIncludes(dictStream, includeForSource, extraIncludes);; 4918 if (gOptSplit) {; 4919 GenerateNecessaryIncludes(*splitDictStream, includeForSource, extraIncludes);; 4920 }; 4921 }; 4922 if (!gOptNoGlobalUsingStd) {; 4923 // ACLiC'ed macros might have relied on `using namespace std` in front of user headers; 4924 if (!isACLiC) {; 4925 AddNamespaceSTDdeclaration(dictStream);; 4926 if (gOptSplit) {; 4927 AddNamespaceSTDdecl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:200287,error,error,200287,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['error'],['error']
Availability,"all the calculation of the pruning sequence, the tree quality and alike.. ; Implements TMVA::IPruneTool.; Definition at line 98 of file CostComplexityPruneTool.cxx. ◆ InitTreePruningMetaData(). void CostComplexityPruneTool::InitTreePruningMetaData ; (; DecisionTreeNode * ; n). private . initialise ""meta data"" for the pruning, like the ""costcomplexity"", the critical alpha, the minimal alpha down the tree, etc... for each node!! ; Definition at line 181 of file CostComplexityPruneTool.cxx. ◆ Log(). MsgLogger & TMVA::CostComplexityPruneTool::Log ; (; ); const. inlineprivate . output stream to save logging information ; Definition at line 87 of file CostComplexityPruneTool.h. ◆ Optimize(). void CostComplexityPruneTool::Optimize ; (; DecisionTree * ; dt, . Double_t ; weights . ). private . after the critical \( \alpha \) values (at which the corresponding nodes would be pruned away) had been established in the ""InitMetaData"" we need now: automatic pruning: ; find the value of \( \alpha \) for which the test sample gives minimal error, on the tree with all nodes pruned that have \( \alpha_{critical} < \alpha \), fixed parameter pruning ; Definition at line 236 of file CostComplexityPruneTool.cxx. Member Data Documentation. ◆ fLogger. MsgLogger* TMVA::CostComplexityPruneTool::fLogger. mutableprivate . Definition at line 86 of file CostComplexityPruneTool.h. ◆ fOptimalK. Int_t TMVA::CostComplexityPruneTool::fOptimalK. private . ! the optimal index of the prune sequence ; Definition at line 77 of file CostComplexityPruneTool.h. ◆ fPruneSequence. std::vector<DecisionTreeNode*> TMVA::CostComplexityPruneTool::fPruneSequence. private . ! map of weakest links (i.e., branches to prune) -> pruning index ; Definition at line 73 of file CostComplexityPruneTool.h. ◆ fPruneStrengthList. std::vector<Double_t> TMVA::CostComplexityPruneTool::fPruneStrengthList. private . ! map of alpha -> pruning index ; Definition at line 74 of file CostComplexityPruneTool.h. ◆ fQualityIndexList. std::ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CostComplexityPruneTool.html:5484,error,error,5484,doc/master/classTMVA_1_1CostComplexityPruneTool.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CostComplexityPruneTool.html,1,['error'],['error']
Availability,"all the options ; Definition at line 216 of file MinimizerOptions.cxx. ◆ PrintDefault(). void ROOT::Math::MinimizerOptions::PrintDefault ; (; const char * ; name = nullptr, . std::ostream & ; os = std::cout . ). static . Print all the default options including the extra one specific for a given minimizer name. ; If no minimizer name is given, all the extra default options, which have been set and configured will be printed ; Definition at line 244 of file MinimizerOptions.cxx. ◆ PrintLevel(). int ROOT::Math::MinimizerOptions::PrintLevel ; (; ); const. inline . non-static methods for retrieving options ; set print level ; Definition at line 174 of file MinimizerOptions.h. ◆ ResetToDefaultOptions(). void ROOT::Math::MinimizerOptions::ResetToDefaultOptions ; (; ). non-static methods for setting options ; Definition at line 174 of file MinimizerOptions.cxx. ◆ SetDefaultErrorDef(). void ROOT::Math::MinimizerOptions::SetDefaultErrorDef ; (; double ; up). static . Set the default level for computing the parameter errors. ; For example for 1-sigma parameter errors; up = 1 for a chi-squared function; up = 0.5 for a negative log-likelihood function. The value will be used also by Minos when computing the confidence interval ; Definition at line 51 of file MinimizerOptions.cxx. ◆ SetDefaultExtraOptions(). void ROOT::Math::MinimizerOptions::SetDefaultExtraOptions ; (; const IOptions * ; extraoptions). static . Set additional minimizer options as pair of (string,value). ; Extra option defaults can be configured for a specific algorithm and then if a matching with the correct option name exists it will be used whenever creating a new minimizer instance. For example for changing the default number of steps of the Genetic minimizer from 100 to 500 do auto extraOpt = ROOT::Math::MinimizerOptions::Default(""Genetic""); extraOpts.SetValue(""Steps"",500);; and when creating the Genetic minimizer you will have the new value for the option: auto gmin = ROOT::Math::Factory::CreateMinimizer(""G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:10352,error,errors,10352,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['error'],['errors']
Availability,"allelCoord, TParallelCoordRange, TParallelCoordVar, TGeoManager, TGeoNode, TGeoShape, TGeoVolume, TGeoOverlap, TGeoTrack, TASImage, TASPaletteEditor::LimitLine, TButton, TCanvas, TGroupButton, TPad, TSliderBox, TBox, TCrown, TCurlyArc, TCurlyLine, TDiamond, TEllipse, TFrame, TGraphPolargram, TLine, TLink, TMarker, TPave, TPolyLine, TText, TWbox, TGraphEdge, TGraphNode, TAxis3D, TMarker3DBox, TNode, TPolyLine3D, TPolyMarker3D, TView3D, TGL5DDataSet, TGLEventHandler, TGLHistPainter, TGLParametricEquation, TGLTH3Composition, TGLViewer, TAxis, TEfficiency, TF1, TF2, TF3, TGraph, TGraph2D, TH1, TPolyMarker, TScatter, TSpline, THistPainter, TPaletteAxis, TGenerator, TParticle, TPrimary, TFileDrawMap, TTreePerfStats, TSpider, TView, TVirtualHistPainter, TPie, and TGLScenePad.; Definition at line 393 of file TObject.cxx. ◆ Fatal(). void TObject::Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue fatal error message. ; Use ""location"" to specify the method where the fatal error occurred. Accepts standard printf formatting arguments. ; Definition at line 1015 of file TObject.cxx. ◆ FindObject() [1/2]. TObject * TObject::FindObject ; (; const char * ; name); const. virtual . Must be redefined in derived classes. ; This function is typically used with TCollections, but can also be used to find an object by name inside this object. ; Reimplemented in TListOfEnums, TMap, TDirectory, TFolder, TROOT, TListOfTypes, TListOfTypes, TBtree, TCollection, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, TPad, TGeometry, THbookFile, TGraph, TGraph2D, TH1, RooAbsCollection, and RooLinkedList.; Definition at line 403 of file TObject.cxx. ◆ FindObject() [2/2]. TObject * TObject::FindObject ; (; const TObject * ; obj); const. virtual . Must be redefined in derived classes. ; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:35669,error,error,35669,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['error'],['error']
Availability,"allelCoord, TParallelCoordRange, TParallelCoordVar, TGeoManager, TGeoNode, TGeoShape, TGeoVolume, TGeoOverlap, TGeoTrack, TASImage, TASPaletteEditor::LimitLine, TButton, TCanvas, TGroupButton, TPad, TSliderBox, TBox, TCrown, TCurlyArc, TCurlyLine, TDiamond, TEllipse, TFrame, TGraphPolargram, TLine, TLink, TMarker, TPave, TPolyLine, TText, TWbox, TGraphEdge, TGraphNode, TAxis3D, TMarker3DBox, TNode, TPolyLine3D, TPolyMarker3D, TView3D, TGL5DDataSet, TGLEventHandler, TGLHistPainter, TGLParametricEquation, TGLTH3Composition, TGLViewer, TAxis, TEfficiency, TF1, TF2, TF3, TGraph, TGraph2D, TH1, TPolyMarker, TScatter, TSpline, THistPainter, TPaletteAxis, TGenerator, TParticle, TPrimary, TFileDrawMap, TTreePerfStats, TSpider, TView, TVirtualHistPainter, TPie, and TGLScenePad.; Definition at line 398 of file TObject.cxx. ◆ Fatal(). void TObject::Fatal ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue fatal error message. ; Use ""location"" to specify the method where the fatal error occurred. Accepts standard printf formatting arguments. ; Definition at line 1021 of file TObject.cxx. ◆ FindObject() [1/2]. TObject * TObject::FindObject ; (; const char * ; name); const. virtual . Must be redefined in derived classes. ; This function is typically used with TCollections, but can also be used to find an object by name inside this object. ; Reimplemented in TListOfEnums, TMap, TDirectory, TFolder, TROOT, TListOfTypes, TListOfTypes, TBtree, TCollection, THashList, THashTable, TList, TObjArray, TListOfDataMembers, TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, TListOfFunctionTemplates, TViewPubDataMembers, TViewPubFunctions, TPad, TGeometry, THbookFile, TGraph, TGraph2D, TH1, RooAbsCollection, and RooLinkedList.; Definition at line 408 of file TObject.cxx. ◆ FindObject() [2/2]. TObject * TObject::FindObject ; (; const TObject * ; obj); const. virtual . Must be redefined in derived classes. ; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:35382,error,error,35382,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['error'],['error']
Availability,"allows specifying if the step is limited by geometrical reasons (a boundary crossing) or is an arbitrary step. The flag cross can be used in case the step is made on a boundary and specifies if user wants to cross or not the boundary. The returned node represents the new current node after the step was made. Making a geometrically contained step with boundary crossing (is_geom=kTRUE, cross=kTRUE) - This is the default method behavior. In this case, the step size is supposed to be already set by a previous TGeoManager::FindNextBoundary() call. Due to floating-point boundary uncertainties, making a step corresponding exactly to the distance to next boundary does not insure boundary crossing. If the method is called with this purpose, an extra small step will be made in order to make the crossing the most probable event (epsil=10-6cm). Even with this extra small step cannot insure 100% boundary crossing for specific crossed shapes at big incident angles. After such a step is made, additional cross-checks become available:. gGeoManager->FindNextBoundary(pstep);; Double_t snext = gGeoManager->GetStep();; // The geometrical step is taken; TGeoNode *newNode = gGeoManager->Step();; // The step=snext+epsil is made; Bool_t hasCrossed = gGeoManager->IsEntering();; // Is the boundary crossed or not?; Bool_t isOnBoundary = gGeoManager->IsOnBoundary(); // The proposed; // geometrically limited step to be made was smaller; // than epsil value.; Bool_t isOutside = gGeoManager->IsOutside();; //Did we exit geometry ?; In case the desired end-point of the step should be in the same starting volume, the input flag cross should be set to kFALSE. In this case, the epsil value will be subtracted from the current step. Making a step of arbitrary value (is_geom=kFALSE, cross=no matter). In this case, the step to be made can be either resulting from a next computation, either set by hand:. gGeoManager->SetStep(stepvalue);; gGeoManager->Step(kFALSE);; The step value in this case will exactly ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:990039,avail,available,990039,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Bool_t ChangeDirectory(const char* path); Change directory. Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnixSystem.html:23566,error,error,23566,root/html602/TUnixSystem.html,https://root.cern,https://root.cern/root/html602/TUnixSystem.html,4,['error'],['error']
Availability,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if children have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:23182,error,error,23182,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,2,['error'],['error']
Availability,"alls(). Int_t GetFPEMask(); Return the bitmap of conditions that trigger a floating point exception. Int_t SetFPEMask(Int_t mask = kDefaultMask); Set which conditions trigger a floating point exception.; Return the previous set of conditions. void DispatchOneEvent(Bool_t pendingOnly = kFALSE); Dispatch a single event. void Sleep(UInt_t milliSec); Sleep milliSec milliseconds. Int_t Select(TList* active, Long_t timeout); Select on file descriptors. The timeout to is in millisec. Returns; the number of ready descriptors, or 0 in case of timeout, or < 0 in; case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; the errno has been reset and the method can be called again. Returns; -4 in case the list did not contain any file handlers or file handlers; with file descriptor >= 0. Int_t Select(TFileHandler* fh, Long_t timeout); Select on the file descriptor related to file handler h.; The timeout to is in millisec. Returns the number of ready descriptors,; or 0 in case of timeout, or < 0 in case of an error, with -2 being EINTR; and -3 EBADF. In case of EINTR the errno has been reset and the method; can be called again. Returns -4 in case the file handler is 0 or does; not have a file descriptor >= 0. void DispatchSignals(ESignals sig); Handle and dispatch signals. Bool_t CheckSignals(Bool_t sync); Check if some signals were raised and call their Notify() member. void CheckChilds(); Check if childs have finished. Bool_t CheckDescriptors(); Check if there is activity on some file descriptors and call their; Notify() member. int MakeDirectory(const char* name); Make a Unix file system directory. Returns 0 in case of success and; -1 if the directory could not be created. void * OpenDirectory(const char* name); Open a Unix file system directory. Returns 0 if directory does not exist. void FreeDirectory(void* dirp); Close a Unix file system directory. const char * GetDirEntry(void* dirp); Get next Unix file system directory entry. Returns 0 if no more entries. Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnixSystem.html:22844,error,error,22844,root/html528/TUnixSystem.html,https://root.cern,https://root.cern/root/html528/TUnixSystem.html,4,['error'],['error']
Availability,"ally on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1046594,avail,available,1046594,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"ally. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. TSocket * CreateAuthSocket(const char* user, const char* host, Int_t port, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0, Int_t* err = 0); Creates a socket or a parallel socket and authenticates to the; remote server specified in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:23562,error,error,23562,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,9,['error'],['error']
Availability,"als"";; 12116 cors4 = cors_cred_cfg;; 12117 } else {; 12118 cors3 = cors4 = """";; 12119 }; 12120 ; 12121 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12122 /* File exists (precondition for calling this function),; 12123 * but can not be opened by the server. */; 12124 mg_send_http_error(conn,; 12125 500,; 12126 ""Error: Cannot read file\nfopen(%s): %s"",; 12127 path,; 12128 strerror(ERRNO));; 12129 } else {; 12130 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12131 * content length */; 12132 conn->must_close = 1;; 12133 gmt_time_string(date, sizeof(date), &curtime);; 12134 fclose_on_exec(&filep->access, conn);; 12135 ; 12136 /* 200 OK response */; 12137 mg_response_header_start(conn, 200);; 12138 send_no_cache_header(conn);; 12139 send_additional_header(conn);; 12140 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12141 if (cors1[0]) {; 12142 mg_response_header_add(conn, cors1, cors2, -1);; 12143 }; 12144 if (cors3[0]) {; 12145 mg_response_header_add(conn, cors3, cors4, -1);; 12146 }; 12147 mg_response_header_send(conn);; 12148 ; 12149 /* Header sent, now send body */; 12150 send_ssi_file(conn, path, filep, 0);; 12151 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12152 }; 12153}; 12154#endif /* NO_FILESYSTEMS */; 12155 ; 12156 ; 12157#if !defined(NO_FILES); 12158static void; 12159send_options(struct mg_connection *conn); 12160{; 12161 if (!conn) {; 12162 return;; 12163 }; 12164 ; 12165 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12166 * Since browsers do not send an OPTIONS request, we can not test the; 12167 * effect anyway. */; 12168 ; 12169 mg_response_header_start(conn, 200);; 12170 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12171 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12172 /* Use the same as before */; 12173 mg_response_header_add(; 12174 conn,; 12175 ""Allow"",; 12176 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:351669,error,errors,351669,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['errors']
Availability,"als"";; 12117 cors4 = cors_cred_cfg;; 12118 } else {; 12119 cors3 = cors4 = """";; 12120 }; 12121 ; 12122 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 12123 /* File exists (precondition for calling this function),; 12124 * but can not be opened by the server. */; 12125 mg_send_http_error(conn,; 12126 500,; 12127 ""Error: Cannot read file\nfopen(%s): %s"",; 12128 path,; 12129 strerror(ERRNO));; 12130 } else {; 12131 /* Set ""must_close"" for HTTP/1.x, since we do not know the; 12132 * content length */; 12133 conn->must_close = 1;; 12134 gmt_time_string(date, sizeof(date), &curtime);; 12135 fclose_on_exec(&filep->access, conn);; 12136 ; 12137 /* 200 OK response */; 12138 mg_response_header_start(conn, 200);; 12139 send_no_cache_header(conn);; 12140 send_additional_header(conn);; 12141 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12142 if (cors1[0]) {; 12143 mg_response_header_add(conn, cors1, cors2, -1);; 12144 }; 12145 if (cors3[0]) {; 12146 mg_response_header_add(conn, cors3, cors4, -1);; 12147 }; 12148 mg_response_header_send(conn);; 12149 ; 12150 /* Header sent, now send body */; 12151 send_ssi_file(conn, path, filep, 0);; 12152 (void)mg_fclose(&filep->access); /* Ignore errors for readonly files */; 12153 }; 12154}; 12155#endif /* NO_FILESYSTEMS */; 12156 ; 12157 ; 12158#if !defined(NO_FILES); 12159static void; 12160send_options(struct mg_connection *conn); 12161{; 12162 if (!conn) {; 12163 return;; 12164 }; 12165 ; 12166 /* We do not set a ""Cache-Control"" header here, but leave the default.; 12167 * Since browsers do not send an OPTIONS request, we can not test the; 12168 * effect anyway. */; 12169 ; 12170 mg_response_header_start(conn, 200);; 12171 mg_response_header_add(conn, ""Content-Type"", ""text/html"", -1);; 12172 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 12173 /* Use the same as before */; 12174 mg_response_header_add(; 12175 conn,; 12176 ""Allow"",; 12177 ""GET, POST, HEAD, CONNECT, PUT, DELETE, OPTIONS, PROPFIND, MKCOL"",; 121",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:351702,error,errors,351702,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['errors']
Availability,"als; static TList*TApplication::fgApplicationsList of available applications. private:. Bool_tfInterruptflag interrupt state; Bool_tfIsValidflag validity; FILE*fLogFilelog file; Int_tfLogFileDeslog file descriptor; TStringfLogFilePathPath to log file; Int_tfProtocoluser protocol version number; Bool_tfRealTimeLogTRUE if log messages should be send back in real-time; TList*fSentCanvasesList of canvases already sent; TStringfSessIdIdentifier for this session; TSocket*fSocketsocket connection to user; TUrlfUrluser's url; TStringfWorkDirWorking dir; TRemoteObject*fWorkingDirWorking (remote) directory. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TApplicationServer(Int_t* argc, char** argv, FILE* flog, const char* logfile); Main constructor. Create an application environment. The TApplicationServer; environment provides an eventloop via inheritance of TApplication. Int_t Setup(); Print the Remote Server logo on standard output.; Return 0 on success, -1 on failure. ~TApplicationServer(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void GetOptions(Int_t* argc, char** argv); Get and handle command line options. Fixed format:; ""protocol url"". void Run(Bool_t retrn = kFALSE); Main server eventloop. void HandleSocketInput(); Handle input coming from the client or from the master server. void HandleUrgentData(); Handle Out-Of-Band data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore (i.e. when kKeepAlive; has failed). void Reset(const char* dir); Reset environment to be ready for execution of next command. Int_t ReceiveFile(const char* file, Bool_t bin, Long64_t size); Receive a file, either sent by a client or a master server.; If bin is true it is a binary file, other wise it is an ASCII; file and we need to check for Windows \r tokens. Returns -1 in; case of error, 0 otherwise. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplicationServer.html:13395,failure,failure,13395,root/html526/TApplicationServer.html,https://root.cern,https://root.cern/root/html526/TApplicationServer.html,11,['failure'],['failure']
Availability,"alse),; 40 fErrors1(false),; 41 fExpErrors(false),; 42 fCoordErrors(true),; 43 fAsymErrors(true); 44 {}; 45 ; 46 ; 47 bool fIntegral; ///< use integral of bin content instead of bin center (default is false); 48 bool fBinVolume; ///< normalize data by the bin volume (it is used in the Poisson likelihood fits); 49 bool fNormBinVolume; ///< normalize data by a normalized the bin volume (bin volume divided by a reference value); 50 bool fUseEmpty; ///< use empty bins (default is false) with a fixed error of 1; 51 bool fUseRange; ///< use the function range when creating the fit data (default is false); 52 bool fErrors1; ///< use all errors equal to 1, i.e. fit without errors (default is false); 53 bool fExpErrors; ///< use expected errors from the function and not from the data; 54 bool fCoordErrors; ///< use errors on the x coordinates when available (default is true); 55 bool fAsymErrors; ///< use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); 56 ; 57 ; 58};; 59 ; 60 } // end namespace Fit; 61 ; 62} // end namespace ROOT; 63 ; 64 ; 65#endif /* ROOT_Fit_DataOptions */; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ROOT::Fit::DataOptions::fErrors1bool fErrors1use all errors equal to 1, i.e. fit without errors (default is false)Definition DataOptions.h:52; ROOT::Fit::DataOptions::fAsymErrorsbool fAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residua...Definition DataOptions.h:55; ROOT::Fit::DataOptions::fNormBinVolumebool fNormBinVo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataOptions_8h_source.html:1789,error,errors,1789,doc/master/DataOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/DataOptions_8h_source.html,6,"['avail', 'error']","['available', 'errors']"
Availability,"alse; // Multi Layer Perceptron (old TMVA NN implementation); bool useBDT = true; // Boosted Decision Tree; bool useDL = true; // TMVA Deep learning ( CPU or GPU); bool useKeras = true; // Keras Deep learning; bool usePyTorch = true; // PyTorch Deep learning; ; TMVA::Tools::Instance();; ; #ifdef R__HAS_PYMVA; gSystem->Setenv(""KERAS_BACKEND"", ""tensorflow"");; // for using Keras; TMVA::PyMethodBase::PyInitialize();; #else; useKeras = false;; usePyTorch = false;; #endif; ; auto outputFile = TFile::Open(""Higgs_ClassificationOutput.root"", ""RECREATE"");; ; TMVA::Factory factory(""TMVA_Higgs_Classification"", outputFile,; ""!V:ROC:!Silent:Color:AnalysisType=Classification"" );; ; /**; ; ## Setup Dataset(s); ; Define now input data file and signal and background trees; ; **/; ; TString inputFileName = ""Higgs_data.root"";; TString inputFileLink = ""http://root.cern/files/"" + inputFileName;; ; TFile *inputFile = nullptr;; ; if (!gSystem->AccessPathName(inputFileName)) {; // file exists; inputFile = TFile::Open( inputFileName );; }; ; if (!inputFile) {; // download file from Cernbox location; Info(""TMVA_Higgs_Classification"",""Download Higgs_data.root file"");; TFile::SetCacheFileDir(""."");; inputFile = TFile::Open(inputFileLink, ""CACHEREAD"");; if (!inputFile) {; Error(""TMVA_Higgs_Classification"",""Input file cannot be downloaded - exit"");; return;; }; }; ; // --- Register the training and test trees; ; TTree *signalTree = (TTree*)inputFile->Get(""sig_tree"");; TTree *backgroundTree = (TTree*)inputFile->Get(""bkg_tree"");; ; signalTree->Print();; ; /***; ## Declare DataLoader(s); ; The next step is to declare the DataLoader class that deals with input variables; ; Define the input variables that shall be used for the MVA training; note that you may also use variable expressions, which can be parsed by TTree::Draw( ""expression"" )]; ; ***/; ; TMVA::DataLoader * loader = new TMVA::DataLoader(""dataset"");; ; loader->AddVariable(""m_jj"");; loader->AddVariable(""m_jjj"");; loader->AddVariable(""m_lv"");; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:59076,down,download,59076,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,1,['down'],['download']
Availability,"also protected and private; ones).; - loop over all base classes and add only those methods not already in the; list (also protected and private ones).; - once finished, loop over resulting list and remove all private and; protected methods. TList * GetListOfAllPublicDataMembers(Bool_t load = kTRUE); Returns a list of all public data members of this class and its base; classes. Refers to a subset of the data members in GetListOfDatamembers(); so don't do GetListOfAllPublicDataMembers()->Delete(). void GetMenuItems(TList* listitems); Returns list of methods accessible by context menu. Bool_t HasDictionary(); Check whether a class has a dictionary or not.; This is equivalent to ask if a class is coming from a bootstrapping; procedure initiated during the loading of a library. Bool_t HasDictionarySelection(const char* clname); Check whether a class has a dictionary or ROOT can load one.; This is equivalent to ask HasDictionary() or whether a library is known; where it can be loaded from, or whether a Dictionary function is; available because the class's dictionary library was already loaded. void GetMissingDictionariesForBaseClasses(TCollection& result, TCollection& visited, bool recurse); Verify the base classes always. void GetMissingDictionariesForMembers(TCollection& result, TCollection& visited, bool recurse); Verify the Data Members. void GetMissingDictionariesForPairElements(TCollection& result, TCollection& visited, bool recurse); Pair is a special case and we have to check its elements for missing dictionaries; Pair is a transparent container so we should always look at its. void GetMissingDictionariesWithRecursionCheck(TCollection& result, TCollection& visited, bool recurse); From the second level of recursion onwards it is different state check. void GetMissingDictionaries(THashTable& result, bool recurse = false); Get the classes that have a missing dictionary starting from this one.; With recurse = false the classes checked for missing dictionaries are:; th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:39547,avail,available,39547,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['avail'],['available']
Availability,"aluateint Evaluate(const char *, TInterpreterValue &) finalGet the interpreter value corresponding to the statement.Definition TCling.cxx:7678; TCling::MakeInterpreterValuestd::unique_ptr< TInterpreterValue > MakeInterpreterValue() const finalDefinition TCling.cxx:7663; TCling::UpdateListOfLoadedSharedLibrariesvoid UpdateListOfLoadedSharedLibraries()Definition TCling.cxx:3348; TCling::TypedefInfo_Titleconst char * TypedefInfo_Title(TypedefInfo_t *tinfo) const finalDefinition TCling.cxx:9530; TCling::CallFunc_SetFuncProtovoid CallFunc_SetFuncProto(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *proto, Longptr_t *Offset, ROOT::EFunctionMatchMode mode=ROOT::kConversionMatch) const finalInterface to cling function.Definition TCling.cxx:8065; TCling::InitRootmapFilevoid InitRootmapFile(const char *name)Create a resource table and read the (possibly) three resource files, i.e.Definition TCling.cxx:5655; TCling::AutoParseInt_t AutoParse(const char *cls) finalParse the headers relative to the class Returns 1 in case of success, 0 in case of failure.Definition TCling.cxx:6523; TCling::FunctionDeclId_IsMethodbool FunctionDeclId_IsMethod(DeclId_t fdeclid) constDefinition TCling.cxx:9595; TCling::LoadPCMvoid LoadPCM(std::string pcmFileNameFullPath)Tries to load a rdict PCM, issues diagnostics if it fails.Definition TCling.cxx:1811; TCling::UpdateListOfMethodsvoid UpdateListOfMethods(TClass *cl) const finalUpdate the list of pointers to method for TClass cl This is now a nop.Definition TCling.cxx:4507; TCling::~TClingvirtual ~TCling()Destroy the interpreter interface.Definition TCling.cxx:1618; TCling::AddFriendToClassvoid AddFriendToClass(clang::FunctionDecl *, clang::CXXRecordDecl *) constInject function as a friend into klass.Definition TCling.cxx:7767; TCling::PrintIntrovoid PrintIntro() finalNo-op; see TRint instead.Definition TCling.cxx:2648; TCling::fCxxModulesEnabledBool_t fCxxModulesEnabledDefinition TCling.h:128; TCling::BaseClassInfo_Nextint BaseC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:424505,failure,failure,424505,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['failure'],['failure']
Availability,"alue (TLeaf *leaf);  Return the size of the underlying array for the current entry in the TTree. ;  ; virtual void * GetLocalValuePointer (char *from, Int_t instance=0);  returns the address of the value pointed to by the TFormLeafInfo. ;  ; virtual void * GetLocalValuePointer (TLeaf *leaf, Int_t instance=0);  returns the address of the value pointed to by the TFormLeafInfo. ;  ; Int_t GetMultiplicity ();  Reminder of the meaning of fMultiplicity: ;  ; virtual Int_t GetNdata ();  Get the number of element in the entry. ;  ; Int_t GetNdata (TLeaf *leaf);  ; char * GetObjectAddress (TLeafElement *leaf, Int_t &instance);  Returns the location of the object pointed to. ;  ; virtual Int_t GetPrimaryIndex ();  Method for multiple variable dimensions. ;  ; virtual Int_t GetSize (Int_t index);  For the current entry, and the value 'index' for the main array, return the size of the secondary variable dimension of the 'array'. ;  ; virtual Int_t GetSumOfSizes ();  Total all the elements that are available for the current entry for the secondary variable dimension. ;  ; template<typename T > ; T GetTypedValue (TLeaf *leaf, Int_t instance=0);  ; virtual Double_t GetValue (TLeaf *leaf, Int_t instance=0);  ; template<typename T > ; T GetValueImpl (TLeaf *leaf, Int_t instance=0);  Return result of a leafobject method. ;  ; virtual Long64_t GetValueLong64 (TLeaf *leaf, Int_t instance=0);  ; virtual LongDouble_t GetValueLongDouble (TLeaf *leaf, Int_t instance=0);  ; virtual void * GetValuePointer (char *from, Int_t instance=0);  returns the address of the value pointed to by the TFormLeafInfo. ;  ; virtual void * GetValuePointer (TLeaf *leaf, Int_t instance=0);  returns the address of the value pointed to by the serie of TFormLeafInfo. ;  ; virtual Int_t GetVarDim ();  Return the index of the dimension which varies for each elements of an enclosing array (typically a TClonesArray) ;  ; virtual Int_t GetVirtVarDim ();  Return the virtual index (for this expression) of the dimension w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFormLeafInfo.html:3687,avail,available,3687,doc/master/classTFormLeafInfo.html,https://root.cern,https://root.cern/doc/master/classTFormLeafInfo.html,1,['avail'],['available']
Availability,"alue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 443 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 424 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooAbsTestStatistic, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, and RooProjectedPdf.; Definition at line 4550 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 384 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented in RooAddModel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:144954,error,error,144954,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability,"alue ; (; std::ostream & ; os); const. overridevirtual . Print object value. ; Reimplemented from RooPrintable.; Reimplemented in RooRealVar.; Definition at line 445 of file RooAbsReal.cxx. ◆ readFromStream(). bool RooAbsReal::readFromStream ; (; std::istream & ; is, . bool ; compact, . bool ; verbose = false . ). overridevirtual . Read object contents from stream (dummy for now) ; Implements RooAbsArg.; Reimplemented in RooAbsRealLValue, RooErrorVar, RooFormulaVar, RooGenericPdf, RooLinearVar, and RooRealVar.; Definition at line 426 of file RooAbsReal.cxx. ◆ redirectServersHook(). bool RooAbsReal::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursiveStep . ). overrideprotectedvirtual . Function that is called at the end of redirectServers(). ; Can be overloaded to inject some class-dependent behavior after server redirection, e.g. resetting of caches. The return value is meant to be an error flag, so in case something goes wrong the function should return true. If you overload this function, don't forget to also call the function of the base class.; See alsoredirectServers() For a detailed explanation of the function parameters. ; Reimplemented from RooAbsArg.; Reimplemented in RooAddPdf, RooDerivative, RooProdPdf, RooProfileLL, RooFormulaVar, RooGenericPdf, RooNumConvolution, RooRealIntegral, RooResolutionModel, RooAbsTestStatistic, and RooProjectedPdf.; Definition at line 4474 of file RooAbsReal.cxx. ◆ selectComp(). void RooAbsReal::selectComp ; (; bool ; flag). inline . Definition at line 377 of file RooAbsReal.h. ◆ selectNormalization(). void RooAbsReal::selectNormalization ; (; const RooArgSet * ; depSet = nullptr, . bool ; force = false . ). protectedvirtual . Interface function to force use of a given set of observables to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented in RooAddModel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:143117,error,error,143117,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,"alue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); voidsetDefNormSet(const RooArgSet& nset); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetSelfNormalized(Bool_t flag); voidRooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:30718,Error,ErrorLoggingMode,30718,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['Error'],['ErrorLoggingMode']
Availability,"alue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidselectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); voidsetDefNormSet(const RooArgSet& nset); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetSelfNormalized(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:29750,Error,ErrorLoggingMode,29750,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,1,['Error'],['ErrorLoggingMode']
Availability,"alue and errors (= fDim + 2 for error in only Y ) ; doublefRefVolumereference bin volume - used to normalize the bins in case of variable bins data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; unsigned int GetPointSize(ROOT::Fit::BinData::ErrorType err, unsigned int dim). ErrorType GetErrorType() const. explicit BinData(unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from dimension of point and max number of points (to pre-allocate vector); Give a zero value and then use Initialize later one if the size is not known. explicit BinData(const ROOT::Fit::DataOptions& opt, unsigned int maxpoints = 0, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). constructor from option and default range. BinData(const DataOptions & opt, const DataRange & range, unsigned int maxpoints = 0, unsigned int dim = 1, ErrorType err = kValueError ). constructor from options and range; efault is 1D and value errors. BinData(unsigned int n, const double * dataX, const double * val, const double * ex , const double * eval ); constructurs using external data . constructor from external data for 1D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* val, const double* ex, const double* ey, const double* eval). constructor from external data for 2D with errors on coordinate and value. BinData(unsigned int n, const double* dataX, const double* dataY, const double* dataZ, const double* val, const double* ex, const double* ey, const double* ez, const double* eval). constructor from external data for 3D with errors on coordinate and value. BinData(const ROOT::Fit::BinData& ). copy constructor. BinData & operator=(const ROOT::Fit::BinData& ). assignment operator. virtual ~BinData(). destructor. void Initialize(unsigned int maxpoints, unsigned int dim = 1, ROOT::Fit::BinData::ErrorType err = kValueError). preal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Fit__BinData.html:6416,error,errors,6416,root/html526/ROOT__Fit__BinData.html,https://root.cern,https://root.cern/root/html526/ROOT__Fit__BinData.html,1,['error'],['errors']
Availability,"alue gets closer to one of the limits (expressed as the distance; to nearest limit divided by distance between limits). The user must; therefore be aware of the fact that, for example, if they put limits of; (0,10^10 ) on a parameter, then the values 0.0 and 1. 0 will be; indistinguishable to the accuracy of most machines. The transformation also affects the parameter error matrix, of course, so; MINUIT does a transformation of the error matrix (and the ``parabolic''; parameter errors) when there are parameter limits. Users should however; realize that the transformation is only a linear approximation, and that; it cannot give a meaningful result if one or more parameters is very close; to a limit, where partial Pext /partial Pint #0. Therefore, it is; recommended that:. Limits on variable parameters should be used only when needed in order; to prevent the parameter from taking on unphysical values.; When a satisfactory minimum has been found using limits, the limits; should then be removed if possible, in order to perform or re-perform the; error analysis without limits. How to get the right answer from MINUIT. MINUIT offers the user a choice of several minimization algorithms. The; MIGRAD algorithm is in general the best minimizer for; nearly all functions. It is a variable-metric method with inexact line; search, a stable metric updating scheme, and checks for; positive-definiteness. Its main weakness is that it depends heavily on; knowledge of the first derivatives, and fails miserably if they are very; inaccurate. If parameter limits are needed, in spite of the side effects, then the; user should be aware of the following techniques to alleviate problems; caused by limits:. Getting the right minimum with limits. If MIGRAD converges normally to a point where no parameter is near one of; its limits, then the existence of limits has probably not prevented MINUIT; from finding the right minimum. On the other hand, if one or more; parameters is near its limit at the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMinuit.html:4799,error,error,4799,root/html602/TMinuit.html,https://root.cern,https://root.cern/root/html602/TMinuit.html,4,['error'],['error']
Availability,"alue when e1=0 AND e2=0; 1045 fSumw2.fArray[bin] = err2;; 1046 }; 1047 } else { // normal case of addition between histograms; 1048 AddBinContent(bin, c1 * factor * h1->RetrieveBinContent(bin));; 1049 if (fSumw2.fN) fSumw2.fArray[bin] += c1sq * factsq * h1->GetBinErrorSqUnchecked(bin);; 1050 }; 1051 }; 1052 ; 1053 // update statistics (do here to avoid changes by SetBinContent); 1054 if (resetStats) {; 1055 // statistics need to be reset in case coefficient are negative; 1056 ResetStats();; 1057 }; 1058 else {; 1059 for (Int_t i=0;i<kNstat;i++) {; 1060 if (i == 1) s1[i] += c1*c1*s2[i];; 1061 else s1[i] += c1*s2[i];; 1062 }; 1063 PutStats(s1);; 1064 SetEntries(entries);; 1065 }; 1066 return kTRUE;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:42630,error,errors,42630,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['errors']
Availability,"alue);  Binary search in an array of n pointers to branch arrays, to locate value. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGeoBranchArray * MakeCopy (const TGeoBranchArray &other);  Make a copy of a branch array at the location (if indicated) ;  ; static TGeoBranchArray * MakeCopyAt (const TGeoBranchArray &other, void *addr);  Make a copy of a branch array at the location (if indicated) ;  ; static TGeoBranchArray * MakeInstance (size_t maxlevel);  Make an instance of the class which allocates the node array. ;  ; static TGeoBranchArray * MakeInstanceAt (size_t maxlevel, void *addr);  Make an instance of the class which allocates the node array. ;  ; static void ReleaseInstance (TGeoBranchArray *obj);  Releases the space allocated for the object. ;  ; static size_t SizeOf (size_t maxlevel);  ; static size_t SizeOfInstance (size_t maxlevel);  ; static void Sort (Int_t n, TGeoBranchArray **array, Int_t *index, Bool_t down=kTRUE);  Sorting of an array of branch array pointers. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Attributes; TGeoNode ** fArray;  ; Int_t fLevel;  ; TGeoHMatrix fMatrix;  ; Int_t fMaxLevel;  ; TGeoNode * fRealArray [1];  [fMaxLevel+1] Array of nodes ;  . Private Member Functions;  TGeoBranchArray (const TGeoBranchArray &);  Copy constructor. Not callable anymore. Use TGeoBranchArray::MakeCopy instead. ;  ;  TGeoBranchArray (Int_t level);  Cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBranchArray.html:12660,down,down,12660,doc/master/classTGeoBranchArray.html,https://root.cern,https://root.cern/doc/master/classTGeoBranchArray.html,1,['down'],['down']
Availability,"alue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Int_t_arrSizeSize of the weight array; Bool_t*_binValid! Valid bins with current range definition; Double_t*_binv[_arrSize] Bin volume array ; TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; Int_t_curIndexCurrent index; Double_t_curSumW2Current sum of weights^2; Double_t_curVolumeVolume of bin enclosing current coordinate; Double_t_curWeightWeight associated with the current coordinate; Double_t_curWgtErrHiError on weight associated with the current coordinate; Double_t_curWgtErrLoError on weight associated with the current coordinate; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; Double_t*_errHi[_arrSize] High-side error on weight array; Double_t*_errLo[_arrSize] Low-side error on weight array; vector<Int_t>_idxMultMultiplier jump table for index calculation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; list<const RooAbsBinning*>_lvbins! List of used binnings associated with lvalues; list<RooAbsLValue*>_lvvars! List of observables casted as RooAbsLValue; static Int_tRooPrintable::_nameLength; vector<Double_t>*_pbinv! Partial bin volume array; RooCacheManager<std::vector<Double_t> >_pbinvCacheMgr! Cache manager for arrays of partial bin volumes; TIterator*_realIter! Iterator over realVars; RooArgSet_realVarsReal dimensions of the dataset ; Double_t*_sumw2[_arrSize] Sum of weights^2; RooArgSetRooAbsData::_varsDimensions of this data set; Double_t*_wgt[_arrSize] Weight array; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataHist(); Default constructor. RooDataHist(const char* name, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataHist.html:17293,error,error,17293,root/html526/RooDataHist.html,https://root.cern,https://root.cern/root/html526/RooDataHist.html,4,['error'],['error']
Availability,"aluePtrHelper() [2/2]. template<typename T > . void * ROOT::Internal::RDF::GetValuePtrHelper ; (; std::vector< ROOT::RVec< T > > & ; v, . std::size_t ; colIdx, . std::size_t ; varIdx . ). Definition at line 122 of file RVariation.hxx. ◆ GetVectorAddress(). template<typename dtype > . ULong64_t ROOT::Internal::RDF::GetVectorAddress ; (; std::vector< dtype > & ; p). Definition at line 25 of file PyROOTHelpers.hxx. ◆ InterpreterCalc(). Long64_t ROOT::Internal::RDF::InterpreterCalc ; (; const std::string & ; code, . const std::string & ; context = """" . ). Jit code in the interpreter with TInterpreter::Calc, throw in case of errors. ; The optional context parameter, if present, is mentioned in the error message. The pointer returned by the call to TInterpreter::Calc is returned in case of success. ; Definition at line 345 of file RDFUtils.cxx. ◆ InterpreterDeclare(). void ROOT::Internal::RDF::InterpreterDeclare ; (; const std::string & ; code). Declare code in the interpreter via the TInterpreter::Declare method, throw in case of errors. ; Definition at line 333 of file RDFUtils.cxx. ◆ IsInternalColumn(). bool ROOT::Internal::RDF::IsInternalColumn ; (; std::string_view ; colName). Whether custom column with name colName is an ""internal"" column such as rdfentry_ or rdfslot_. ; Definition at line 381 of file RDFUtils.cxx. ◆ IsStrInVec(). bool ROOT::Internal::RDF::IsStrInVec ; (; const std::string & ; str, . const std::vector< std::string > & ; vec . ). Definition at line 439 of file RDFUtils.cxx. ◆ JitBuildAction(). std::string ROOT::Internal::RDF::JitBuildAction ; (; const ColumnNames_t & ; cols, . std::shared_ptr< RDFDetail::RNodeBase > * ; prevNode, . const std::type_info & ; helperArgType, . const std::type_info & ; at, . void * ; helperArgOnHeap, . TTree * ; tree, . const unsigned int ; nSlots, . const RColumnRegister & ; colRegister, . RDataSource * ; ds, . std::weak_ptr< RJittedAction > * ; jittedActionOnHeap, . const bool ; vector2RVec . ). Definition at line 849 of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:35698,error,errors,35698,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['error'],['errors']
Availability,"alues TMVA::DNN::operator|= ; (; ModeOutputValues & ; lhs, . ModeOutputValues ; rhs . ). inline . Definition at line 193 of file NeuralNet.h. ◆ randomInt(). int TMVA::DNN::randomInt ; (; int ; maxValue). Definition at line 52 of file NeuralNet.cxx. ◆ regularization(). template<typename Architecture_t > . auto TMVA::DNN::regularization ; (; const typename Architecture_t::Matrix_t & ; A, . ERegularization ; R . ); -> decltype(Architecture_t::L1Regularization(A)). inline . Evaluate the regularization functional for a given weight matrix. ; Definition at line 238 of file Functions.h. ◆ softMaxCrossEntropy(). template<typename ItOutput , typename ItTruth , typename ItDelta , typename ItInvActFnc > . double TMVA::DNN::softMaxCrossEntropy ; (; ItOutput ; itProbabilityBegin, . ItOutput ; itProbabilityEnd, . ItTruth ; itTruthBegin, . ItTruth ; , . ItDelta ; itDelta, . ItDelta ; itDeltaEnd, . ItInvActFnc ; , . double ; patternWeight . ). soft-max-cross-entropy error function (for mutual exclusive cross-entropy) ; Definition at line 458 of file NeuralNet.icc. ◆ studenttDouble(). double TMVA::DNN::studenttDouble ; (; double ; distributionParameter). Definition at line 60 of file NeuralNet.cxx. ◆ sumOfSquares() [1/2]. template<typename ItOutput , typename ItTruth , typename ItDelta , typename ItInvActFnc > . double TMVA::DNN::sumOfSquares ; (; ItOutput ; itOutputBegin, . ItOutput ; itOutputEnd, . ItTruth ; itTruthBegin, . ItTruth ; itTruthEnd, . ItDelta ; itDelta, . ItDelta ; itDeltaEnd, . ItInvActFnc ; itInvActFnc, . double ; patternWeight . ). ◆ sumOfSquares() [2/2]. template<typename ItOutput , typename ItTruth , typename ItDelta , typename InvFnc > . double TMVA::DNN::sumOfSquares ; (; ItOutput ; itOutputBegin, . ItOutput ; itOutputEnd, . ItTruth ; itTruthBegin, . ItTruth ; , . ItDelta ; itDelta, . ItDelta ; itDeltaEnd, . InvFnc ; invFnc, . double ; patternWeight . ). sum of squares error function ; Definition at line 382 of file NeuralNet.icc. ◆ uniformDouble() [1/2]. templa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html:32809,error,error,32809,doc/master/namespaceTMVA_1_1DNN.html,https://root.cern,https://root.cern/doc/master/namespaceTMVA_1_1DNN.html,2,['error'],['error']
Availability,"alues for point arrays in the range [begin, end]. ; Reimplemented from TGraph.; Definition at line 598 of file TGraphErrors.cxx. ◆ GetErrorX(). Double_t TGraphErrors::GetErrorX ; (; Int_t ; bin); const. overridevirtual . It returns the error along X at point i. ; Reimplemented from TGraph.; Definition at line 612 of file TGraphErrors.cxx. ◆ GetErrorXhigh(). Double_t TGraphErrors::GetErrorXhigh ; (; Int_t ; i); const. overridevirtual . It returns the error along X at point i. ; For TGraphErrors this method is the same as GetErrorX. ; Reimplemented from TGraph.; Definition at line 635 of file TGraphErrors.cxx. ◆ GetErrorXlow(). Double_t TGraphErrors::GetErrorXlow ; (; Int_t ; i); const. overridevirtual . It returns the error along X at point i. ; For TGraphErrors this method is the same as GetErrorX. ; Reimplemented from TGraph.; Definition at line 647 of file TGraphErrors.cxx. ◆ GetErrorY(). Double_t TGraphErrors::GetErrorY ; (; Int_t ; bin); const. overridevirtual . It returns the error along Y at point i. ; Reimplemented from TGraph.; Definition at line 623 of file TGraphErrors.cxx. ◆ GetErrorYhigh(). Double_t TGraphErrors::GetErrorYhigh ; (; Int_t ; i); const. overridevirtual . It returns the error along Y at point i. ; For TGraphErrors this method is the same as GetErrorY. ; Reimplemented from TGraph.; Definition at line 659 of file TGraphErrors.cxx. ◆ GetErrorYlow(). Double_t TGraphErrors::GetErrorYlow ; (; Int_t ; i); const. overridevirtual . It returns the error along Y at point i. ; For TGraphErrors this method is the same as GetErrorY. ; Reimplemented from TGraph.; Definition at line 671 of file TGraphErrors.cxx. ◆ GetEX(). Double_t * TGraphErrors::GetEX ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 69 of file TGraphErrors.h. ◆ GetEY(). Double_t * TGraphErrors::GetEY ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 70 of file TGraphErrors.h. ◆ IsA(). TClass * TGraphErrors::IsA ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphErrors.html:42399,error,error,42399,doc/master/classTGraphErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphErrors.html,1,['error'],['error']
Availability,"alues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general assymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:22785,error,error,22785,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['error']
Availability,"alues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to al",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18763,error,error,18763,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['error'],['error']
Availability,"alues stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other fits on the same function do; func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );. Double_t IntegralError(Int_t n, const Double_t* a, const Double_t* b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); Return Error on Integral of a parameteric function with dimension larger tan one; between a[] and b[] due to the parameters uncertainties.; For a TF1 with dimension larger than 1 (for example a TF2 or TF3); TF1::IntegralMultiple is used for the integral calculation. A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat) can be optionally passed.; By default (i.e. when a zero pointer is passed) the current stored parameter values are used to estimate the integral error; together with the covariance matrix from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:57303,Error,Error,57303,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['Error'],['Error']
Availability,"alues; 1708df_filtered.Display({""twice""})->Print();; 1709\endcode; 1710 ; 1711#### Further considerations; 1712 ; 1713Note that working with missing values is currently supported with a TTree-based; 1714data source. Support of this functionality for other data sources may come in; 1715the future.; 1716 ; 1717*/; 1718// clang-format on; 1719 ; 1720namespace ROOT {; 1721 ; 1722using ROOT::RDF::ColumnNames_t;; 1723using ColumnNamesPtr_t = std::shared_ptr<const ColumnNames_t>;; 1724 ; 1725////////////////////////////////////////////////////////////////////////////; 1726/// \brief Build the dataframe.; 1727/// \param[in] treeName Name of the tree contained in the directory; 1728/// \param[in] dirPtr TDirectory where the tree is stored, e.g. a TFile.; 1729/// \param[in] defaultColumns Collection of default columns.; 1730///; 1731/// The default columns are looked at in case no column is specified in the; 1732/// booking of actions or transformations.; 1733/// \see ROOT::RDF::RInterface for the documentation of the methods available.; 1734RDataFrame::RDataFrame(std::string_view treeName, TDirectory *dirPtr, const ColumnNames_t &defaultColumns); 1735 : RInterface(std::make_shared<RDFDetail::RLoopManager>(nullptr, defaultColumns)); 1736{; 1737 if (!dirPtr) {; 1738 auto msg = ""Invalid TDirectory!"";; 1739 throw std::runtime_error(msg);; 1740 }; 1741 const std::string treeNameInt(treeName);; 1742 auto tree = static_cast<TTree *>(dirPtr->Get(treeNameInt.c_str()));; 1743 if (!tree) {; 1744 auto msg = ""Tree \"""" + treeNameInt + ""\"" cannot be found!"";; 1745 throw std::runtime_error(msg);; 1746 }; 1747 GetProxiedPtr()->SetTree(std::shared_ptr<TTree>(tree, [](TTree *) {}));; 1748}; 1749 ; 1750////////////////////////////////////////////////////////////////////////////; 1751/// \brief Build the dataframe.; 1752/// \param[in] treeName Name of the tree contained in the directory; 1753/// \param[in] filenameglob TDirectory where the tree is stored, e.g. a TFile.; 1754/// \param[in] defaul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:95645,avail,available,95645,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,"always run them with both, the interpreter and with ACLiC. To do so, do not use the Cling extensions and program around the Cling limitations. When it is not possible or desirable to program around the Cling limitations, you can use the C preprocessor symbols defined for Cling and rootcling.; The preprocessor symbol __CLING__ is defined for both ROOT and rootcling. The symbol __ROOTCLING__ (and __MAKECINT__ for backward compatibility) is only defined in rootcling.; Use !defined(__CLING__) || defined(__ROOTCLING__) to bracket code that needs to be seen by the compiler and rootcling, but will be invisible to the interpreter.; Use !defined(__CLING__)to bracket code that should be seen only by the compiler and not by Cling nor rootcling.For example, the following will hide the declaration and initialization of the array gArray from both Cling and rootcling.; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #endif; Because ACLiC calls rootcling to build a dictionary, the declaration of gArray will not be included in the dictionary, and consequently, gArray will not be available at the command line even if ACLiC is used. Cling and rootcling will ignore all statements between the ""#if !defined (__CLING__)"" and ""#endif"". If you want to use gArray in the same script as its declaration, you can do so. However, if you want use the script in the interpreter you have to bracket the usage of gArray between #if's, since the definition is not visible. If you add the following preprocessor statements:; #if !defined(__CLING__); int gArray[] = { 2, 3, 4};; #elif defined(__ROOTCLING__); int gArray[];; #endif; gArray will be visible to rootcling but still not visible to Cling. If you use ACLiC, gArray will be available at the command line and be initialized properly by the compiled code.; We recommend you always write scripts with the needed include statements. In most cases, the script will still run with the interpreter. However, a few header files are not handled very well by Clin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:277234,avail,available,277234,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"always stays set.; 1959 ; 1960void TCanvas::SetBatch(Bool_t batch); 1961{; 1962 if (gROOT->IsBatch() || IsWeb()); 1963 fBatch = kTRUE;; 1964 else; 1965 fBatch = batch;; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Set Width and Height of canvas to ww and wh respectively. If ww and/or wh; 1970/// are greater than the current canvas window a scroll bar is automatically; 1971/// generated. Use this function to zoom in a canvas and navigate via; 1972/// the scroll bars. The Width and Height in this method are different from those; 1973/// given in the TCanvas constructors where these two dimension include the size; 1974/// of the window decoration whereas they do not in this method.; 1975/// When both ww==0 and wh==0, auto resize mode will be enabled again and; 1976/// canvas drawing area will automatically fit available window size; 1977 ; 1978void TCanvas::SetCanvasSize(UInt_t ww, UInt_t wh); 1979{; 1980 if (fCanvasImp) {; 1981 fCw = ww;; 1982 fCh = wh;; 1983 fCanvasImp->SetCanvasSize(ww, wh);; 1984 TContext ctxt(this, kTRUE);; 1985 ResizePad();; 1986 }; 1987}; 1988 ; 1989////////////////////////////////////////////////////////////////////////////////; 1990/// Set cursor.; 1991 ; 1992void TCanvas::SetCursor(ECursor cursor); 1993{; 1994 if (!IsBatch() && !IsWeb()); 1995 gVirtualX->SetCursor(fCanvasID, cursor);; 1996}; 1997 ; 1998////////////////////////////////////////////////////////////////////////////////; 1999/// Set Double Buffer On/Off.; 2000 ; 2001void TCanvas::SetDoubleBuffer(Int_t mode); 2002{; 2003 if (IsBatch() || IsWeb()); 2004 return;; 2005 fDoubleBuffer = mode;; 2006 gVirtualX->SetDoubleBuffer(fCanvasID, mode);; 2007 ; 2008 // depending of the buffer mode set the drawing window to either; 2009 // the canvas pixmap or to the canvas on-screen window; 2010 if (fDoubleBuffer) {; 2011 if (fPixmapID != -1) fPainter->SelectDrawable(fPixmapID);; 2012 } else; 2013 if (fCanvasID != -1) fPainter->SelectDr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:62796,avail,available,62796,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['avail'],['available']
Availability,"alysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier response. const Ranking* CreateRanking(); create ranking. void PrintHelpMessage() const; print help message. void Init(). void DeclareOptions(). void ProcessOptions(). Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets). void MakeClassSpecific(ostream& , const TString& ) const; make ROOT-independent C++ class for classifier response (classifier-specific implementation). void GetHelpMessage() const; get specific help message from classifer. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__IMethod.html:1762,error,error,1762,root/html534/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html534/TMVA__IMethod.html,2,['error'],['error']
Availability,"alyticalIntegralWN(). Int_t RooLagrangianMorphFunc::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; numVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Retrieve the mat. ; Reimplemented from RooAbsReal.; Definition at line 2946 of file RooLagrangianMorphFunc.cxx. ◆ getBinWidth(). RooRealVar * RooLagrangianMorphFunc::getBinWidth ; (; ); const. retrieve the histogram observable ; Definition at line 2531 of file RooLagrangianMorphFunc.cxx. ◆ getCache(). RooLagrangianMorphFunc::CacheElem * RooLagrangianMorphFunc::getCache ; (; ); const. private . retrieve the cache object ; Definition at line 2327 of file RooLagrangianMorphFunc.cxx. ◆ getCondition(). double RooLagrangianMorphFunc::getCondition ; (; ); const. Retrieve the condition of the coefficient matrix. ; If the condition number is very large, then the matrix is ill-conditioned and is almost singular. The computation of the inverse is prone to large numerical errors ; Definition at line 3011 of file RooLagrangianMorphFunc.cxx. ◆ getCouplings(). RooLagrangianMorphFunc::ParamSet RooLagrangianMorphFunc::getCouplings ; (; ); const. retrieve a set of couplings (-?-) ; Definition at line 2722 of file RooLagrangianMorphFunc.cxx. ◆ getCouplingSet(). const RooArgList * RooLagrangianMorphFunc::getCouplingSet ; (; ); const. get the set of couplings ; Definition at line 2713 of file RooLagrangianMorphFunc.cxx. ◆ getFlag(). RooRealVar * RooLagrangianMorphFunc::getFlag ; (; const char * ; name); const. retrieve the RooRealVar object incorporating the flag with the given name ; Definition at line 2433 of file RooLagrangianMorphFunc.cxx. ◆ getFunc(). RooRealSumFunc * RooLagrangianMorphFunc::getFunc ; (; ); const. get the func ; Definition at line 2767 of file RooLagrangianMorphFunc.cxx. ◆ getInvertedMatrix(). TMatrixD RooLagrangianMorphFunc::getInvertedMatrix ; (; ); const. Retrieve the matrix of coefficients after inversion. ; Definition at line 2998 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:80890,error,errors,80890,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['error'],['errors']
Availability,"al~MCFitter(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tTMVA::FitterBase::EstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const char*TMVA::Configurable::GetConfigDescription() const; const char*TMVA::Configurable::GetConfigName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TMVA::IFitterTarget&TMVA::FitterBase::GetFitterTarget() const; virtual const char*TObject::GetIconName() const; virtual const char*TMVA::FitterBase::GetName() const; Int_tTMVA::FitterBase::GetNpars() const; virtual char*TObject::GetObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MCFitter.html:1402,Error,Error,1402,root/html532/TMVA__MCFitter.html,https://root.cern,https://root.cern/root/html532/TMVA__MCFitter.html,2,['Error'],['Error']
Availability,"al~TEntryList(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(const TEntryList* elist); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tContains(Long64_t entry, TTree* tree = 0); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDirectoryAutoAdd(TDirectory*); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual Bool_tEnter(Long64_t entry, TTree* tree = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TEntryList*GetCurrentList() const; virtual TDirectory*GetDirectory() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long64_tGetEntriesToProcess() const; virtual Long64_tGetEntry(Int_t index); virtual Long64_tGetEntryAndTree(Int_t index, Int_t& treenum); virtual TEntryList*GetEntryList(const char* treename, const char* filename, Option_t* opt = """"); virtual const char*GetFileName() const; virtual cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEntryList.html:9728,Error,Error,9728,root/html532/TEntryList.html,https://root.cern,https://root.cern/root/html532/TEntryList.html,4,['Error'],['Error']
Availability,"al~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetMergeList() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOutputFileName() const; Int_tGetPrintLevel() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasCompressionChange() const; virtual ULong_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFileMerger.html:1795,error,error,1795,root/html530/TFileMerger.html,https://root.cern,https://root.cern/root/html530/TFileMerger.html,1,['error'],['error']
Availability,"al~TFileMerger(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tAddFile(const char* url, Bool_t cpProgress = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCWD(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; TList*GetMergeList() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetOutputFileName() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileMerger.html:1807,error,error,1807,root/html528/TFileMerger.html,https://root.cern,https://root.cern/root/html528/TFileMerger.html,1,['error'],['error']
Availability,"al~TGridCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TGridCollection*); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCheckIfOnline(Bool_t = kFALSE); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Bool_tDeselectFile(const char*, Int_t = -1, Int_t = -1); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDownscaleSelection(UInt_t = 2); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExportXML(const char*, Bool_t = kTRUE, Bool_t = kTRUE, const char* = ""ROOT xml"", const char* = ""Exported XML""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetCollectionName() const; virtual TDSet*GetDataset(const char*, const char*, const char*); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TEntryList*GetEntryList(const char*); virtual const char*GetExportUrl(); virtual TFileCollection*GetFileCollection(const char* = """", const char* = """") const; virtual TList*GetFileGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGridCollection.html:1446,Error,Error,1446,root/html532/TGridCollection.html,https://root.cern,https://root.cern/root/html532/TGridCollection.html,4,['Error'],['Error']
Availability,"am by a constant c1. ;  ; virtual void SetAxisColor (Color_t color=1, Option_t *axis=""X"");  Set color to draw the axis line and tick marks. ;  ; virtual void SetAxisRange (Double_t xmin, Double_t xmax, Option_t *axis=""X"");  Set the ""axis"" range. ;  ; virtual void SetBarOffset (Float_t offset=0.25);  Set the bar offset as fraction of the bin width for drawing mode ""B"". ;  ; virtual void SetBarWidth (Float_t width=0.5);  Set the width of bars as fraction of the bin width for drawing mode ""B"". ;  ; virtual void SetBinContent (Int_t bin, Double_t content);  Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater than the number of bins and the timedisplay option is set or CanExtendAllAxes(), the number of bins is automatically doubled to accommodate the new bin. ;  ; virtual void SetBinContent (Int_t bin, Int_t, Double_t content);  ; virtual void SetBinContent (Int_t bin, Int_t, Int_t, Double_t content);  ; virtual void SetBinError (Int_t bin, Double_t error);  Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empty bin the bin error is set by default to the square root of their content. ;  ; virtual void SetBinError (Int_t binx, Int_t biny, Double_t error);  See convention for numbering bins in TH1::GetBin. ;  ; virtual void SetBinError (Int_t binx, Int_t biny, Int_t binz, Double_t error);  See convention for numbering bins in TH1::GetBin. ;  ; virtual void SetBinErrorOption (EBinErrorOpt type);  ; virtual void SetBins (Int_t nx, const Double_t *xBins);  Redefine x axis parameters with variable bin sizes. ;  ; virtual void SetBins (Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins);  Redefine x and y axis parameters with variable bin sizes. ;  ; virtual void SetBins (Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins);  Redefine x, y and z axis parameters with variable bin sizes. ;  ; virtual void SetBins (Int_t nx, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:43140,error,error,43140,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,16,['error'],['error']
Availability,"am contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:58170,error,errors,58170,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['error'],['errors']
Availability,"am objects in the current ...Definition TH1.cxx:8937; TH1::FitPanelvirtual void FitPanel()Display a panel with all histogram fit options.Definition TH1.cxx:4284; TH1::fBufferDouble_t * fBuffer[fBufferSize] entry bufferDefinition TH1.h:108; TH1::AutoP2FindLimitsvirtual Int_t AutoP2FindLimits(Double_t min, Double_t max)Buffer-based estimate of the histogram range using the power of 2 algorithm.Definition TH1.cxx:1343; TH1::GetEffectiveEntriesvirtual Double_t GetEffectiveEntries() constNumber of effective entries of the histogram.Definition TH1.cxx:4448; TH1::GetObjectInfochar * GetObjectInfo(Int_t px, Int_t py) const overrideRedefines TObject::GetObjectInfo.Definition TH1.cxx:4502; TH1::Smoothvirtual void Smooth(Int_t ntimes=1, Option_t *option="""")Smooth bin contents of this histogram.Definition TH1.cxx:6879; TH1::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn bin center for 1D histogram.Definition TH1.cxx:9141; TH1::Rebuildvirtual void Rebuild(Option_t *option="""")Using the current bin info, recompute the arrays for contents and errors.Definition TH1.cxx:7087; TH1::SetBarOffsetvirtual void SetBarOffset(Float_t offset=0.25)Set the bar offset as fraction of the bin width for drawing mode ""B"".Definition TH1.h:364; TH1::fgStatOverflowsstatic Bool_t fgStatOverflows! Flag to use under/overflows in statisticsDefinition TH1.h:117; TH1::FindLastBinAbovevirtual Int_t FindLastBinAbove(Double_t threshold=0, Int_t axis=1, Int_t firstBin=1, Int_t lastBin=-1) constFind last bin with content > threshold for axis (1=x, 2=y, 3=z) if no bins with content > threshold i...Definition TH1.cxx:3797; TH1::GetZaxisTAxis * GetZaxis()Definition TH1.h:326; TH1::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute distance from point px,py to a line.Definition TH1.cxx:2823; TH1::Multiplyvirtual Bool_t Multiply(TF1 *f1, Double_t c1=1)Performs the operation:Definition TH1.cxx:6049; TH1::kXaxis@ kXaxisDefinition TH1.h:73; TH1::kNoAxis@ kNoAxisNOTE: Must a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:433916,error,errors,433916,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"am relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const ROOT::Math::IntegrationOneDim::Type type, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const Integration::Type type, const Integration::GKRule rule, double absTol = 1.E-9, double relTol = 1E-6, size_t size = 1000). generic constructor for GSL Integrator. @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule. It is used only for ADAPTIVE::Integration types. The possible rules are defined in the Integration::GKRule enumeration; @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. GSLIntegrator(const char* type, int rule, double absTol, double relTol, size_t size); constructor of GSL Integrator. In the case of Adaptive integration the Gauss-Krond rule of 31 points is used; This is used by the plug-in manager (need a char * instead of enumerations). @param type type of integration. The possible types are defined in the Integration::Type enumeration; @param rule Gauss-Kronrod rule (from 1 to 6); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals. virtual ~GSLIntegrator(); ~GSLIntegrator();. GSLIntegrator(const ROOT::Math::GSLIntegrator& ); disable copy ctrs. GSLIntegrator & operator=(const ROOT::Math::GSLIntegrator& ). void SetFunction(const ROOT::Math::IGenFunction& f); template methods for generic functors. method to set the a generic integration function. @param f integration function. The function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html:5868,Error,Error,5868,root/html532/ROOT__Math__GSLIntegrator.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLIntegrator.html,4,['Error'],['Error']
Availability,"am will be equivalent to the one obtained by; filling directly a TH2D using the 3-rd value as a weight.; This option makes sense only for profile filled with all weights =1.; When the profile is weighted (filled with weights different than 1) the; bin error of the projected histogram (obtained using this option ""W"") cannot be; correctly computed from the information stored in the profile. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); -*-*Reset contents of a Profile2D histogram; *-* =======================================. void RebinAxis(Double_t x, TAxis* axis); Profile histogram is resized along axis such that x is in the axis range.; The new axis limits are recomputed by doubling iteratively; the current axis range until the specified value x is within the limits.; The algorithm makes a copy of the histogram, then loops on all bins; of the old histogram to fill the rebinned histogram.; Takes into account errors (Sumw2) if any.; The bit kCanRebin must be set before invoking this function.; Ex: h->SetBit(TH1::kCanRebin);. TProfile2D * Rebin2D(Int_t nxgroup = 2, Int_t nygroup = 2, const char* newname = """"); -*-*-*Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together*-*-*-*-. if newname is not blank a new profile hnew is created.; else the current histogram is modified (default); The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this; have to be merged into one bin of hnew; If the original profile has errors stored (via Sumw2), the resulting; profile has new errors correctly calculated. examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins; hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; // Carefull: previous contents of hpxpy are lost; hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; // Carefull: previous contents of hpxpy are lost; hpxpy->RebinX(5); //mer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:41566,error,errors,41566,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,4,['error'],['errors']
Availability,"am); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGCanvas*TGContainer::GetCanvas() const; TGClient",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTVLVContainer.html:5074,error,error,5074,root/html602/TTVLVContainer.html,https://root.cern,https://root.cern/root/html602/TTVLVContainer.html,4,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Bool_tEnableHide() const; voidEnableHide(Bool_t onoff); Bool_tEnableUndock() const; voidEnableUndock(Bool_t onoff); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; TGCompositeFrame*GetContainer() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionTGCompositeFrame::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGDockableFrame.html:4760,error,error,4760,root/html528/TGDockableFrame.html,https://root.cern,https://root.cern/root/html528/TGDockableFrame.html,6,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tGetBBox(); virtual TPointGetBBoxCenter(); virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; Int_tGetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEvent() const; virtual Int_tGetEventX() const; virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:7466,error,error,7466,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,2,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Double_tGetAbsHNDC() const; virtual Double_tGetAbsWNDC() const; virtual Double_tGetAbsXlowNDC() const; virtual Double_tGetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tGetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tGetBorderMode() const; virtual Short_tGetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*GetCanvas() const; virtual Int_tGetCanvasID() const; virtual TCanvasImp*GetCanvasImp() const; Int_tGetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetEvent() const; virtual Int_tGetEventX() const; virtual Int_tGetEventY() const; virtual Color_tTAttFill::GetFillColor() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPad.html:7347,error,error,7347,root/html528/TPad.html,https://root.cern,https://root.cern/root/html528/TPad.html,4,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnd(Bool_t mark = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; ETextJustificationGetAlignment() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGTextBuffer*GetBuffer() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); Int_tGetCursorPosition() const; static FontStruct_tGetDefaultFontStruct(); static Pixel_tTGFrame::GetDefaultFrameBackground(); static const TGGC&GetDefaultGC(); virtual UInt_tTGFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGFrame:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEntry.html:8339,error,error,8339,root/html602/TGTextEntry.html,https://root.cern,https://root.cern/root/html602/TGTextEntry.html,4,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEnableMenuBarHiding(); virtual voidTGLViewer::EndScene(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGLViewer::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; Bool_tTGLViewerBase::FindClosestOpaqueRecord(TGLSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestOverlayRecord(TGLOvlSelectRecord& rec, Int_t& recIdx); Bool_tTGLViewerBase::FindClosestRecord(TGLSelectRecord& rec, Int_t& recIdx); TGLLogicalShape*TGLViewerBase::FindLogicalInScenes(TObject* id); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGLAutoRotator*TGLViewer::GetAutoRotator(); TGLCameraOverlay*TGLViewer::GetCameraOverlay() const; Bool_tTGLViewer::GetClipAutoUpdate() const; TGLClipSet*TGLViewer::GetClipSet() const; TGLOverlayElement*TGLViewer::GetCurrentOvlElm() const; static TGLColorSet&TGLViewer::GetDefaultColorSet(); Int_tTGLViewer::GetDev() const; TGLV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLSAViewer.html:5463,error,error,5463,root/html528/TGLSAViewer.html,https://root.cern,https://root.cern/root/html528/TGLSAViewer.html,6,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableItem(const char* name, Bool_t on = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGCompositeFrame::GetDefaultHeight() const; static Pixel_tTGFrame::GetDefaultSelectedBackground(); virtual TGDimensionGetDefaultSize() const; virtual UInt_tTGCompositeFrame::GetDefaultWidth() const; virtual TDNDData*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGShutter.html:4388,error,error,4388,root/html602/TGShutter.html,https://root.cern,https://root.cern/root/html602/TGShutter.html,4,['error'],['error']
Availability,"am); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidExcludeClassEditor(TClass* cl, Bool_t recurse = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTVirtualPadEditor::FillAttributes(Int_t, Int_t); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TCanvas*GetCanvas() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGedEditor.html:6499,error,error,6499,root/html602/TGedEditor.html,https://root.cern,https://root.cern/root/html602/TGedEditor.html,4,['error'],['error']
Availability,"am, Double_t nullHypoValue = 0); RooDLLSignificanceMCSModule(const char* parName, Double_t nullHypoValue = 0); virtual~RooDLLSignificanceMCSModule(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tRooAbsMCStudyModule::doInitializeInstance(RooMCStudy&); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual RooDataSet*finalizeRun(); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDLLSignificanceMCSModule.html:2113,Error,Error,2113,root/html532/RooDLLSignificanceMCSModule.html,https://root.cern,https://root.cern/root/html532/RooDLLSignificanceMCSModule.html,2,['Error'],['Error']
Availability,"am, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is succesfull; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is succesfull; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__LikelihoodInterval.html:10253,failure,failure,10253,root/html528/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html528/RooStats__LikelihoodInterval.html,4,['failure'],['failure']
Availability,"am, bool& status); Compute lower limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. Double_t UpperLimit(const RooRealVar& param, bool& status); Compute upper limit, check first if limit has been computed; status is a boolean flag which will b set to false in case of error; and is true if calculation is successful; in case of error return also a lower limit value of zero. void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case; check first if limit has been computed; otherwise compute limit using MINOS; in case of failure lower and upper will mantain previous value (will not be modified). Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); default constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. Double_t LowerLimit(const RooRealVar& param); return the lower bound of the interval on a given parameter. { bool ok; return LowerLimit(param,ok); }. Double_t UpperLimit(const RooRealVar& param); return the upper bound of the interval on a given parameter. { bool ok; return UpperLimit(param,ok);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__LikelihoodInterval.html:10351,failure,failure,10351,root/html534/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html534/RooStats__LikelihoodInterval.html,6,['failure'],['failure']
Availability,"am; change the draw options of the histogram.; 3.21.2.1.3 Plot; draw a 2D or 3D plot of the histogram; according to the dimension, the drawing possibilities are different.; 3.21.2.2 2-D Plot; 3.21.2.2.1 Contour; draw a contour plot (None, Cont0…5); 3.21.2.2.2 Cont #; set the number of Contours;; 3.21.2.2.3 Arrow; set the arrow mode and shows the gradient between adjacent cells;; 3.21.2.2.4 Col; a box is drawn for each cell with a color scale varying with contents;; 3.21.2.2.5 Text; draw bin contents as text;; 3.21.2.2.6 Box; a box is drawn for each cell with surface proportional to contents;; 3.21.2.2.7 Scat; draw a scatter-plot (default);; 3.21.2.2.8 Palette; the color palette is drawn.; 3.21.2.3 3-D Plot; 3.21.2.3.1 Type; set histogram type to Lego or surface plot; draw (Lego, Lego1.2, Surf, Surf1…5); 3.21.2.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.);; 3.21.2.3.3 Cont #; set the number of Contours (for e.g. Lego2 draw option);; 3.21.2.3.4 Errors; draw errors in a Cartesian lego plot;; 3.21.2.3.5 Palette; draw the color palette;; 3.21.2.3.6 Front; draw the front box of a Cartesian lego plot;; 3.21.2.3.7 Back; draw the back box of a Cartesian lego plot;; 3.21.2.3.8 Bar; change the bar attributes: the width and offset.; 3.21.2.4 Rebinning Tab; The Rebinning tab has two different layouts. One is for a histogram that is not drawn from an ntuple; the other one is available for a histogram, which is drawn from an ntuple. In this case, the rebin algorithm can create a rebinned histogram from the original data i.e. the ntuple. To see the differences do for example:; TFile f (""hsimple.root"");; hpxpy->Draw(""Lego2""); // non ntuple histogram; ntuple->Draw(""px:py"","""",""Lego2""); // ntuple histogram; 3.21.2.5 Non-ntuple histogram:; Rebin with sliders (one for the x, one for the y-axis) and the number of bins (shown in the field below them can be changed to any number, which divides the number of bins of the original histogram. Selecting the Apply button will d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:139388,error,errors,139388,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Error', 'error']","['Errors', 'errors']"
Availability,"ame = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidCopyCollectionProxy(const TVirtualCollectionProxy&); voidTDictionary::CreateAttributeMap(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteArray(void* ary, Bool_t dtorOnly = kFALSE); voidDestructor(void* obj, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDump() const; voidDump(void* obj) const; void*DynamicCast(const TClass* base, void* obj, Bool_t up = kTRUE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; char*EscapeChars(const char* text) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TVirtualStreamerInfo*FindConversionStreamerInfo(const char* onfile_classname, UInt_t checksum) const; TVirtualStreamerInfo*FindConversionStreamerInfo(const TClass* onfile_cl, UInt_t checksum) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TVirtualStreamerInfo*FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*GetBaseClass(const char* classname); TClass*GetBaseClass(const TClass* base); Int_tGetBaseClassOffset(const TClass* base); TClass*GetBaseDataMember(const char* datamember); UInt_tGetCheckSum(TClass::ECheckSum code = kCurrentChe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:3331,error,error,3331,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['error'],['error']
Availability,"ame = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& crown) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTEllipse::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCrown(Double_t x1, Double_t y1, Double_t radin, Double_t radout, Double_t phimin = 0, Double_t phimax = 360, Option_t* option = """"); virtual voidTEllipse::DrawEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, Double_t theta, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Double_tTEllipse::GetPhimax() const; Double_tTEllips",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCrown.html:2497,error,error,2497,root/html526/TCrown.html,https://root.cern,https://root.cern/root/html526/TCrown.html,5,['error'],['error']
Availability,"ame = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidCopy(TObject& crown) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTEllipse::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCrown(Double_t x1, Double_t y1, Double_t radin, Double_t radout, Double_t phimin = 0, Double_t phimax = 360, Option_t* option = """"); virtual voidTEllipse::DrawEllipse(Double_t x1, Double_t y1, Double_t r1, Double_t r2, Double_t phimin, Double_t phimax, Double_t theta, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTEllipse::GetBBox(); virtual TPointTEllipse::GetBBoxCenter(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TObject::GetName() const; Bool_tTEllipse::GetNoEdges() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCrown.html:2497,error,error,2497,root/html534/TCrown.html,https://root.cern,https://root.cern/root/html534/TCrown.html,6,['error'],['error']
Availability,"ame = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasFilledCache()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsDataStore.html:2538,error,error,2538,root/html532/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html532/RooAbsDataStore.html,1,['error'],['error']
Availability,"ame = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tdefaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tdirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get() const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsDataStore.html:2571,error,error,2571,root/html534/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html534/RooAbsDataStore.html,6,['error'],['error']
Availability,"ame = 0); Copy constructor. Initializes in clean state so that upon eval; this instance will create its own server processes. ~RooRealMPFE(); Destructor. void initVars(); Initialize list of variables of front-end argument 'arg'. void initialize(); Initialize the remote process and message passing; pipes between current process and remote process. void serverLoop(); Server loop of remote processes. This function will return; only when an incoming TERMINATE message is received. void calculate() const; Client-side function that instructs server process to start; asynchronuous (re)calculation of function value. This function; returns immediately. The calculated value can be retrieved; using getVal(). Double_t getVal(const RooArgSet* nset = 0) const; If value needs recalculation and calculation has not beed started; with a call to calculate() start it now. This function blocks; until remote process has finished calculation and returns; remote value. Double_t evaluate() const; Send message to server process to retrieve output value; If error were logged use logEvalError() on remote side; transfer those errors to the local eval error queue. void standby(); Terminate remote server process and return front-end class; to standby mode. Calls to calculate() or evaluate() after; this call will automatically recreated the server process. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Intercept call to optimize constant term in test statistics; and forward it to object on server side. void setVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); Control verbose messaging related to inter process communication; on both client and server side. TObject* clone(const char* newname) const; { return new RooRealMPFE(*this,newname); }. » Last changed: Tue Dec 14 15:30:40 2010 » Last generated: 2010-12-14 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealMPFE.html:35888,error,error,35888,root/html528/RooRealMPFE.html,https://root.cern,https://root.cern/root/html528/RooRealMPFE.html,3,['error'],"['error', 'errors']"
Availability,"ame = 0); RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:24886,Error,ErrorLoggingMode,24886,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,2,['Error'],['ErrorLoggingMode']
Availability,"ame = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. static RooStats::HistFactory::EstimateSummary::ConstraintTypeGaussian; boolIncludeStatErrorFlag to implement Statistical errors for this sample; static RooStats::HistFactory::EstimateSummary::ConstraintTypePoisson; Double_tRelErrorThresholdThe minimum relative uncertainty for a bin to use stat errors; RooStats::HistFactory::EstimateSummary::ConstraintTypeStatConstraintTypeThe type of constraint binwise stat errors; stringchannel; pair<double,double>dummyForRoot; vector<TH1*>highHistsx pb per jet bin for + variations over list of systematics; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie; vector<TH1*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<RooStats::HistFactory::EstimateSummary::NormFactor>normFactor; stringnormName; map<string,pair<double,double> >overallSyst""acceptance""->(0.8,1.2); TH1*relStatErrorAn (optional) externally provided shape for this error; stringshapeFactorN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__EstimateSummary.html:5366,error,errors,5366,root/html602/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__EstimateSummary.html,12,['error'],['errors']
Availability,"ame = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidRooAbsStudy::aggregateSummaryOutput(TList* chunkList); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); voidRooAbsStudy::registerSummaryOutput(const RooArgSet& allVars, const RooArgSet& varsWithError = RooArgSet(), const RooArgSet& varsWithAsymError = RooArgSet()); voidRooAbsStudy::storeDetailedOutput(TNamed& object); voidRooAbsStudy::storeSummaryOutput(const RooArgSet& vars). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; RooArgSetfParamPointOfInterest; TStringTNamed::fTitleobject title; RooStats::ToyMCSampler*fToyMCSampler. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t initialize(void). Bool_t execute(void). Bool_t finalize(void). Bool_t merge(RooStats::SamplingDistribution& result); returns true if there was an error. ToyMCStudy(const char* name = ""ToyMCStudy"", const char* title = ""ToyMCStudy""); need to have constructor without arguments for proof. virtual ~ToyMCStudy(). void SetToyMCSampler(RooStats::ToyMCSampler& t); { fToyMCSampler = &t; }. void SetParamPointOfInterest(const RooArgSet& poi); { fParamPointOfInterest.add(poi); }. » Author: Sven Kreiss and Kyle Cranmer June 2010 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: ToyMCStudy.h 36602 2010-11-11 16:52:13Z moneta $ » Last generated: 2010-11-11 18:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__ToyMCStudy.html:6598,error,error,6598,root/html528/RooStats__ToyMCStudy.html,https://root.cern,https://root.cern/root/html528/RooStats__ToyMCStudy.html,1,['error'],['error']
Availability,"ame T> Long64_t TMath::BinarySearch(Long64_t n, const T **array, T value); 363{; 364 const T* pind;; 365 pind = std::lower_bound(*array, *array + n, value);; 366 if ( (pind != *array + n) && (*pind == value) ); 367 return (pind - *array);; 368 else; 369 return ( pind - *array - 1);; 370}; 371 ; 372template<typename T>; 373struct CompareDesc {; 374 ; 375 CompareDesc(T d) : fData(d) {}; 376 ; 377 template<typename Index>; 378 bool operator()(Index i1, Index i2) {; 379 return *(fData + i1) > *(fData + i2);; 380 }; 381 ; 382 T fData;; 383};; 384 ; 385template<typename T>; 386struct CompareAsc {; 387 ; 388 CompareAsc(T d) : fData(d) {}; 389 ; 390 template<typename Index>; 391 bool operator()(Index i1, Index i2) {; 392 return *(fData + i1) < *(fData + i2);; 393 }; 394 ; 395 T fData;; 396};; 397 ; 398/// Sort the n1 elements of the Short_t array defined by its; 399/// iterators. In output the array index contains the indices of; 400/// the sorted array. If down is false sort in increasing order; 401/// (default is decreasing order).; 402///; 403/// NOTE that the array index must be created with a length bigger; 404/// or equal than the main array before calling this function.; 405template <typename Iterator, typename IndexIterator>; 406void TMath::SortItr(Iterator first, Iterator last, IndexIterator index, Bool_t down); 407{; 408 int i = 0;; 409 ; 410 IndexIterator cindex = index;; 411 for ( Iterator cfirst = first; cfirst != last; ++cfirst ); 412 {; 413 *cindex = i++;; 414 ++cindex;; 415 }; 416 ; 417 if ( down ); 418 std::sort(index, cindex, CompareDesc<Iterator>(first) );; 419 else; 420 std::sort(index, cindex, CompareAsc<Iterator>(first) );; 421}; 422 ; 423/// Sort the n elements of the array a of generic templated type Element.; 424/// In output the array index of type Index contains the indices of the sorted array.; 425/// If down is false sort in increasing order (default is decreasing order).; 426///; 427/// NOTE that the array index must be created with a length >= ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMathBase_8h_source.html:15369,down,down,15369,doc/master/TMathBase_8h_source.html,https://root.cern,https://root.cern/doc/master/TMathBase_8h_source.html,1,['down'],['down']
Availability,"ame and title in the case of a container sub-branch. ; Definition at line 1144 of file TBranchElement.cxx. ◆ Class(). static TClass * TBranchElement::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TBranchElement::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TBranchElement::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 255 of file TBranchElement.h. ◆ DeclFileName(). static const char * TBranchElement::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 255 of file TBranchElement.h. ◆ FillImpl(). Int_t TBranchElement::FillImpl ; (; ROOT::Internal::TBranchIMTHelper * ; imtHelper). overrideprivatevirtual . Loop on all leaves of this branch to fill the basket buffer. ; The function returns the number of bytes committed to the individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; Note: We not not use any member functions from TLeafElement! ; Reimplemented from TBranch.; Definition at line 1229 of file TBranchElement.cxx. ◆ FillLeavesAssociativeCollectionMember(). void TBranchElement::FillLeavesAssociativeCollectionMember ; (; TBuffer & ; b). protected . Write leaves into i/o buffers for this branch. ; Case of a data member within a collection (fType == 41). ; Definition at line 1561 of file TBranchElement.cxx. ◆ FillLeavesClones(). void TBranchElement::FillLeavesClones ; (; TBuffer & ; b). protected . Write leaves into i/o buffers for this branch. ; Case of a TClonesArray (fType == 3). ; Definition at line 1592 of file TBranchElement.cxx. ◆ FillLeavesClonesMember(). void TBranchElement::FillLeavesClonesMember ; (; TBuffer & ; b). protected . Write leaves into i/o buffers for this branch. ; Case of a data member within a TClonesArray ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBranchElement.html:44727,error,error,44727,doc/master/classTBranchElement.html,https://root.cern,https://root.cern/doc/master/classTBranchElement.html,1,['error'],['error']
Availability,"ame and title. ; Definition at line 74 of file TGraphMultiErrors.cxx. ◆ TGraphMultiErrors() [3/23]. TGraphMultiErrors::TGraphMultiErrors ; (; Int_t ; np, . Int_t ; ne = 1 . ). TGraphMultiErrors normal constructor with np points and ne y-errors. ; All values are initialized to 0. ; Definition at line 84 of file TGraphMultiErrors.cxx. ◆ TGraphMultiErrors() [4/23]. TGraphMultiErrors::TGraphMultiErrors ; (; const Char_t * ; name, . const Char_t * ; title, . Int_t ; np, . Int_t ; ne = 1 . ). TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ; All values are initialized to 0. ; Definition at line 95 of file TGraphMultiErrors.cxx. ◆ TGraphMultiErrors() [5/23]. TGraphMultiErrors::TGraphMultiErrors ; (; Int_t ; np, . const Float_t * ; x, . const Float_t * ; y, . const Float_t * ; exL = nullptr, . const Float_t * ; exH = nullptr, . const Float_t * ; eyL = nullptr, . const Float_t * ; eyH = nullptr, . Int_t ; m = kOnlyFirst . ). TGraphMultiErrors normal constructor with np points and a single y-error. ; The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors. If exL,exH or eyL,exH are NULL, the corresponding values are preset to zero. ; Definition at line 107 of file TGraphMultiErrors.cxx. ◆ TGraphMultiErrors() [6/23]. TGraphMultiErrors::TGraphMultiErrors ; (; const Char_t * ; name, . const Char_t * ; title, . Int_t ; np, . const Float_t * ; x, . const Float_t * ; y, . const Float_t * ; exL = nullptr, . const Float_t * ; exH = nullptr, . const Float_t * ; eyL = nullptr, . const Float_t * ; eyH = nullptr, . Int_t ; m = kOnlyFirst . ). TGraphMultiErrors normal constructor with name, title, np points and a single y-error. ; If exL,exH or eyL,eyH are NULL, the corresponding values are preset to zero. ; Definition at line 141 of file TGraphMultiErrors.cxx. ◆ TGraphMultiErrors() [7/23]. TGraphMultiErrors::TGraphMultiErrors ; (; Int_t ; np, . const Double_t * ; x, . const Double_t * ; y, . const Double_t * ; exL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:46198,error,error,46198,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,"ame background color; Int_tTGFrame::fBorderWidthframe border width; TGHorizontalFrame*TGTable::fBottomFrameFrame that contains the bottom part; TGHorizontalFrame*TGTable::fButtonFrameContains the buttons; TGTableHeaderFrame*TGTable::fCHdrFrameFrame that contains the row headers; TList*TGTable::fCHdrHintsList; TGCanvas*TGTable::fCanvasCanvas that will contains the cells; UInt_tTGTable::fCellHeightDefault cell width; TList*TGTable::fCellHintsList; UInt_tTGTable::fCellWidthDefault cell width; TGClient*TGObject::fClientConnection to display server; TObjArray*TGTable::fColumnHeadersArray of column headers; TStringTGWidget::fCommandcommand to be executed; TTableRange*TGTable::fCurrentRangeRange of data currently loaded; Int_tTGFrame::fDNDStateEDNDFlags; TTableRange*TGTable::fDataRangeFull range of the data set; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; Pixel_tTGTable::fEvenRowBackgroundBackground color for even numbered rows; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextEntry*TGTable::fFirstCellEntryTextEntry for the range frame; TGLabel*TGTable::fFirstCellLabelLabel for the range frame; TGTextButton*TGTable::fGotoButtonButton to goto a new range; TTableRange*TGTable::fGotoRangeRange used by Goto frame; Pixel_tTGTable::fHeaderBackgroundBackground color for headers; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; TVirtualTableInterface*TGTable::fInterfaceInterface to the data source; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*TGTable::fMainHintsListList for all hints used in the main table frame; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSimpleTable.html:20631,mask,mask,20631,root/html528/TGSimpleTable.html,https://root.cern,https://root.cern/root/html528/TGSimpleTable.html,19,['mask'],['mask']
Availability,"ame dimensions: C(i,j) = A(i,j) / B(i,j) returning a matrix expression. ;  ; template<class T , unsigned int D> ; T Dot (const SVector< T, D > &lhs, const SVector< T, D > &rhs);  Vector dot product. ;  ; template<class A , class T , unsigned int D> ; T Dot (const SVector< T, D > &lhs, const VecExpr< A, T, D > &rhs);  ; template<class A , class T , unsigned int D> ; T Dot (const VecExpr< A, T, D > &lhs, const SVector< T, D > &rhs);  ; template<class A , class B , class T , unsigned int D> ; T Dot (const VecExpr< A, T, D > &lhs, const VecExpr< B, T, D > &rhs);  ; template<class T > ; T etaMax ();  Function providing the maximum possible value of pseudorapidity for a non-zero rho, in the Scalar type with the largest dynamic range. ;  ; long double etaMax_impl ();  The following function could be called to provide the maximum possible value of pseudorapidity for a non-zero rho. ;  ; double expm1 (double x);  exp(x) -1 with error cancellation when x is small ;  ; double exponential_cdf (double x, double lambda, double x0=0);  Cumulative distribution function of the exponential distribution (lower tail). ;  ; double exponential_cdf_c (double x, double lambda, double x0=0);  Complement of the cumulative distribution function of the exponential distribution (upper tail). ;  ; template<class A , class T , unsigned int D, unsigned int D2, class R > ; Expr< UnaryOp< Fabs< T >, Expr< A, T, D, D2, R >, T >, T, D, D2, R > fabs (const Expr< A, T, D, D2, R > &rhs);  ; template<class T , unsigned int D, unsigned int D2, class R > ; Expr< UnaryOp< Fabs< T >, SMatrix< T, D, D2, R >, T >, T, D, D2, R > fabs (const SMatrix< T, D, D2, R > &rhs);  abs of a matrix m2(i,j) = | m1(i,j) | returning a matrix epression ;  ; template<class T , unsigned int D> ; VecExpr< UnaryOp< Fabs< T >, SVector< T, D >, T >, T, D > fabs (const SVector< T, D > &rhs);  abs of a vector : v2(i) = | v1(i) | returning a vector expression ;  ; template<class A , class T , unsigned int D> ; VecExpr< UnaryOp< Fabs< T >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:56512,error,error,56512,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['error'],['error']
Availability,"ame of the curve (to retrieve it from a plot) ; [in]titleTitle (for plotting). ; [in]c1First curve. ; [in]c2Second curve. ; [in]scale1Scale y values for c1 by this factor. ; [in]scale2Scale y values for c2 by this factor. . Definition at line 196 of file RooCurve.cxx. Member Function Documentation. ◆ addPoint(). void RooCurve::addPoint ; (; double ; x, . double ; y . ). Add a point with the specified coordinates. Update our y-axis limits. ; Definition at line 447 of file RooCurve.cxx. ◆ addPoints(). void RooCurve::addPoints ; (; const RooAbsFunc & ; func, . double ; xlo, . double ; xhi, . Int_t ; minPoints, . double ; prec, . double ; resolution, . WingMode ; wmode, . Int_t ; numee = 0, . bool ; doEEVal = false, . double ; eeVal = 0.0, . std::list< double > * ; samplingHint = nullptr . ). protected . Add points calculated with the specified function, over the range (xlo,xhi). ; Add at least minPoints equally spaced points, and add sufficient points so that the maximum deviation from the final straight-line segments is prec*(ymax-ymin), down to a minimum horizontal spacing of resolution*(xhi-xlo). ; Definition at line 284 of file RooCurve.cxx. ◆ addRange(). void RooCurve::addRange ; (; const RooAbsFunc & ; func, . double ; x1, . double ; x2, . double ; y1, . double ; y2, . double ; minDy, . double ; minDx, . int ; numee, . bool ; doEEVal, . double ; eeVal, . double ; epsilon . ). protected . Fill the range (x1,x2) with points calculated using func(&x). ; No point will be added at x1, and a point will always be added at x2. The density of points will be calculated so that the maximum deviation from a straight line approximation is prec*(ymax-ymin) down to the specified minimum horizontal spacing. ; Definition at line 402 of file RooCurve.cxx. ◆ average(). double RooCurve::average ; (; double ; lo, . double ; hi . ); const. Return average curve value in [xFirst,xLast] by integrating curve between points and dividing by xLast-xFirst. ; Definition at line 580 of file RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:43341,down,down,43341,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,1,['down'],['down']
Availability,"ame""); This function calculates the background spectrum in this histogram.; The background is returned as a histogram.; to be implemented (may be). Int_t ShowPeaks(Double_t sigma = 2, Option_t* option = """", Double_t threshold = 0.05); Interface to TSpectrum2::Search; the function finds peaks in this histogram where the width is > sigma; and the peak maximum greater than threshold*maximum bin content of this.; for more detauils see TSpectrum::Search.; note the difference in the default value for option compared to TSpectrum2::Search; option="""" by default (instead of ""goff""). void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this 2-d histogram using kernel algorithms; similar to the ones used in the raster graphics community.; Bin contents in the active range are replaced by their smooth values.; If Errors are defined via Sumw2, they are also scaled and computed.; However, note the resulting errors will be correlated between different-bins, so; the errors should not be used blindly to perform any calculation involving several bins,; like fitting the histogram. One would need to compute also the bin by bin correlation matrix. 3 kernels are proposed k5a, k5b and k3a.; k5a and k5b act on 5x5 cells (i-2,i-1,i,i+1,i+2, and same for j); k5b is a bit more stronger in smoothing; k3a acts only on 3x3 cells (i-1,i,i+1, and same for j).; By default the kernel ""k5a"" is used. You can select the kernels ""k5b"" or ""k3a""; via the option argument.; If TAxis::SetRange has been called on the x or/and y axis, only the bins; in the specified range are smoothed.; In the current implementation if the first argument is not used (default value=1). implementation by David McKee (dmckee@bama.ua.edu). Extended by Rene Brun. void Streamer(TBuffer& ); Stream an object of class TH2. Int_t BufferFill(Double_t x, Double_t y, Double_t w). Int_t Fill(Double_t ). void FillN(Int_t , const Double_t* , const Double_t* , Int_t ); {;}. Double_t GetBinErrorLow(Int_t binx, Int_t biny);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH2.html:55033,error,errors,55033,root/html534/TH2.html,https://root.cern,https://root.cern/root/html534/TH2.html,4,['error'],['errors']
Availability,"ame"");; 81 ; 82//### 3. A 2d graph; 83 //Create and fill the graph; 84 int ngr2 = 100;; 85 double z, rnd, e=0.3;; 86 TGraph2D *gr2 = new TGraph2D(ngr2);; 87 gr2->SetName(""Graph2DNoError"");; 88 TF2 *f2 = new TF2(""f2"",; 89 ""1000*(([0]*sin(x)/x)*([1]*sin(y)/y))+250"",-6,6,-6,6);; 90 f2->SetParameters(1,1);; 91 for (i=0; i<ngr2; i++){; 92 f2->GetRandom2(x,y);; 93 // Generate a random number in [-e,e]; 94 rnd = 2*gRandom->Rndm()*e-e;; 95 z = f2->Eval(x,y)*(1+rnd);; 96 gr2->SetPoint(i,x,y,z);; 97 }; 98 //Create a graph with errors to store the intervals; 99 TGraph2DErrors *grint2 = new TGraph2DErrors(ngr2);; 100 for (i=0; i<ngr2; i++); 101 grint2->SetPoint(i, gr2->GetX()[i], gr2->GetY()[i], 0);; 102 ; 103 //Fit the graph; 104 f2->SetParameters(0.5,1.5);; 105 gr2->Fit(f2, ""Q"");; 106 /*Compute the confidence intervals*/; 107 (TVirtualFitter::GetFitter())->GetConfidenceIntervals(grint2);; 108 //Now the ""grint2"" graph contains function values as z-coordinates; 109 //and confidence intervals as their errors; 110 //draw; 111 myc->cd(3);; 112 f2->SetNpx(30);; 113 f2->SetNpy(30);; 114 f2->SetFillColor(kBlue);; 115 f2->Draw(""surf4"");; 116 grint2->SetNpx(20);; 117 grint2->SetNpy(20);; 118 grint2->SetMarkerStyle(24);; 119 grint2->SetMarkerSize(0.7);; 120 grint2->SetMarkerColor(kRed);; 121 grint2->SetLineColor(kRed);; 122 grint2->Draw(""E0 same"");; 123 grint2->SetTitle(""Fitted 2d function with .95 error bars"");; 124 ; 125 myc->cd();; 126 ; 127}; 128 ; 129 ; 130 ; 131 ; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF2.h; TGraph2DErrors.h; TGraphErrors.h; TH1.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; TVirtualFitter.h; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ConfidenceIntervals_8C_source.html:3723,error,errors,3723,doc/master/ConfidenceIntervals_8C_source.html,https://root.cern,https://root.cern/doc/master/ConfidenceIntervals_8C_source.html,1,['error'],['errors']
Availability,"ame() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); TIterTCollection::end() const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TCollection::FindObject(const char* name) const; virtual TObject*TCollection::FindObject(const TObject* obj) const; virtual TObject*First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TCollection::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; virtual const char*TObject::GetTitle() const; virtual UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSeqCollection.html:2500,error,error,2500,root/html602/TSeqCollection.html,https://root.cern,https://root.cern/root/html602/TSeqCollection.html,4,['error'],['error']
Availability,"ame() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsNumGenerator*clone(const RooAbsReal& func, const RooArgSet& genVars, const RooArgSet&, const RooNumGenConfig& config, Bool_t verbose = kFALSE, const RooAbsReal* maxFuncVal = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooPrintable::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*generateEvent(UInt_t remaining, Double_t& resampleRatio); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tgetFuncMax(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAcceptReject.html:2283,Error,Error,2283,root/html534/RooAcceptReject.html,https://root.cern,https://root.cern/root/html534/RooAcceptReject.html,3,['Error'],['Error']
Availability,"ame() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); TGeoNavigator*GetCurrentNavigator() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigatorArray.html:3024,error,error,3024,root/html532/TGeoNavigatorArray.html,https://root.cern,https://root.cern/root/html532/TGeoNavigatorArray.html,4,['error'],['error']
Availability,"ame() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; TObject**TObjArray::GetObjectRef() const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__TSchemaMatch.html:2434,error,error,2434,root/html532/ROOT__TSchemaMatch.html,https://root.cern,https://root.cern/root/html532/ROOT__TSchemaMatch.html,2,['error'],['error']
Availability,"ame() const; virtual voidTObjArray::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; virtual voidTObjArray::Compress(); Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObjArray::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObjArray::Expand(Int_t newSize); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObjArray::FindObject(const char* name) const; virtual TObject*TObjArray::FindObject(const TObject* obj) const; virtual TObject*TObjArray::First() const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTObjArray::GetEntries() const; Int_tTObjArray::GetEntriesFast() const; virtual const char*TObject::GetIconName() const; virtual Int_tTObjArray::GetLast() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**TObjArray::GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__TSchemaMatch.html:2434,error,error,2434,root/html530/ROOT__TSchemaMatch.html,https://root.cern,https://root.cern/root/html530/ROOT__TSchemaMatch.html,1,['error'],['error']
Availability,"ame(),qtype, prob);; 2541 }; 2542 // check if the histogram is already existing; 2543 TH1D *h1=nullptr;; 2544 //check if histogram with identical name exist; 2545 TObject *h1obj = gROOT->FindObject(qname);; 2546 if (h1obj) {; 2547 h1 = dynamic_cast<TH1D*>(h1obj);; 2548 if (!h1) {; 2549 Error(""DoQuantiles"",""Histogram with name %s must be a TH1D and is a %s"",qname.Data(),h1obj->ClassName());; 2550 return nullptr;; 2551 }; 2552 }; 2553 if (h1) {; 2554 h1->Reset();; 2555 } else {; 2556 // create the histogram; 2557 h1 = new TH1D(qname, GetTitle(), 1, 0, 1);; 2558 }; 2559 // set the bin content; 2560 Int_t firstOutBin = std::max(outAxis->GetFirst(),1);; 2561 Int_t lastOutBin = std::max(outAxis->GetLast(),outAxis->GetNbins());; 2562 const TArrayD *xbins = outAxis->GetXbins();; 2563 if (xbins->fN == 0); 2564 h1->SetBins(lastOutBin-firstOutBin+1,outAxis->GetBinLowEdge(firstOutBin),outAxis->GetBinUpEdge(lastOutBin));; 2565 else; 2566 h1->SetBins(lastOutBin-firstOutBin+1,&xbins->fArray[firstOutBin-1]);; 2567 ; 2568 // set the bin content of the histogram; 2569 Double_t pp[1];; 2570 pp[0] = prob;; 2571 ; 2572 TH1D * slice = nullptr;; 2573 for (int ibin = outAxis->GetFirst() ; ibin <= outAxis->GetLast() ; ++ibin) {; 2574 Double_t qq[1];; 2575 // do a projection on the opposite axis; 2576 slice = DoProjection(!onX, ""tmp"",ibin,ibin,"""");; 2577 if (!slice) break;; 2578 if (slice->GetSum() == 0) continue;; 2579 slice->GetQuantiles(1,qq,pp);; 2580 h1->SetBinContent(ibin,qq[0]);; 2581 // compute error using normal approximation; 2582 // quantile error ~ sqrt (q*(1-q)/ *( n * f(xq)^2 ) from Kendall; 2583 // where f(xq) is the p.d.f value at the quantile xq; 2584 Double_t n = slice->GetEffectiveEntries();; 2585 Double_t f = TMath::Gaus(qq[0], slice->GetMean(), slice->GetStdDev(), kTRUE);; 2586 Double_t error = 0;; 2587 // set the errors to zero in case of small statistics; 2588 if (f > 0 && n > 1); 2589 error = TMath::Sqrt( prob*(1.-prob)/ (n * f * f) );; 2590 h1->SetBinError(ibin, error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:105852,error,error,105852,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,2,['error'],['error']
Availability,"ame(). static const char * TDCacheFile::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 75 of file TDCacheFile.h. ◆ GetDcapPath(). TString TDCacheFile::GetDcapPath ; (; const char * ; path). static . Transform the input path into a path usuable by the dcap C library, i.e either dcap://nodename.org/where/filename.root or /pnfs/where/filename.root. ; Definition at line 588 of file TDCacheFile.cxx. ◆ GetDcapVersion(). const char * TDCacheFile::GetDcapVersion ; (; ). static . Return dCache version string. ; Definition at line 404 of file TDCacheFile.cxx. ◆ IsA(). TClass * TDCacheFile::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 75 of file TDCacheFile.h. ◆ ReadBuffer() [1/2]. Bool_t TDCacheFile::ReadBuffer ; (; char * ; buf, . Int_t ; len . ). overridevirtual . Read specified byte range from remote file via dCache daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 211 of file TDCacheFile.cxx. ◆ ReadBuffer() [2/2]. Bool_t TDCacheFile::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevirtual . Read specified byte range from remote file via dCache daemon. ; Returns kTRUE in case of error. ; Reimplemented from TFile.; Definition at line 227 of file TDCacheFile.cxx. ◆ ReadBuffers(). Bool_t TDCacheFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). overridevirtual . Read the nbuf blocks described in arrays pos and len, where pos[i] is the seek position of block i of length len[i]. ; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented from TFile.; Definition at line 247 of file TDCacheFile.cxx. ◆ ResetErrno(). void TDCacheFile::ResetErrno ; (; ); const. overridevirtual . Method resetting the dc_errno ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDCacheFile.html:45670,error,error,45670,doc/master/classTDCacheFile.html,https://root.cern,https://root.cern/doc/master/classTDCacheFile.html,1,['error'],['error']
Availability,"ame(). static const char * TSelHist::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 60 of file TSelHist.h. ◆ GetOutputList(). TList * TSelHist::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 56 of file TSelHist.h. ◆ IsA(). TClass * TSelHist::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelHist.h. ◆ Process(). Bool_t TSelHist::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelHist::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 267 of file TSelHist.cxx. ◆ SetInputList(). void TSelHist::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 55 of file TSelHist.h. ◆ SetObject(). void TSelHist::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelHist.h. ◆ SetOption(). void TSelHist::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelHist.h. ◆ SlaveBegin(). void TSelHist::SlaveBeg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelHist.html:15172,avail,available,15172,doc/master/classTSelHist.html,https://root.cern,https://root.cern/doc/master/classTSelHist.html,1,['avail'],['available']
Availability,"ame) const; get index of variable given a variable given a name; return -1 if variable is not found. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fOptions.PrintLevel(); }. unsigned int MaxFunctionCalls() const; max number of function calls. { return fOptions.MaxFunctionCalls(); }. unsigned int MaxIterations() const; max iterations. { return fOptions.MaxIterations(); }. double Tolerance() const; absolute tolerance. { return fOptions.Tolerance(); }. double Precision() const; precision of minimizer in the evaluation of the objective function; ( a value <=0 corresponds to the let the minimizer choose its default one). { return fOptions.Precision(); }. int Strategy() const; strategy. { return fOptions.Strategy(); }. int Status() const; status code of minimizer. { return fStatus; }. double ErrorDef() const; return the statistical scale used for calculate the error; is typically 1 for Chi2 and 0.5 for likelihood minimization. { return fOptions.ErrorDef(); }. bool IsValidError() const; return true if Minimizer has performed a detailed error validation (e.g. run Hesse for Minuit). { return fValidError; }. void SetPrintLevel(int level); set print level. { fOptions.SetPrintLevel(level); }. void SetMaxFunctionCalls(unsigned int maxfcn); set maximum of function calls. { if (maxfcn > 0) fOptions.SetMaxFunctionCalls(maxfcn); }. void SetMaxIterations(unsigned int maxiter); set maximum iterations (one iteration can have many function calls). { if (maxiter > 0) fOptions.SetMaxIterations(maxiter); }. void SetTolerance(double tol); set the tolerance. { fOptions.SetTolerance(tol); }. void SetPrecision(double prec); set in the minimizer the objective function evaluation precision; ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. default case). { fOptions.SetPrecision(prec); }. void SetStrategy(int strategyLevel); set the strategy. { fOptions.SetStrategy(strategyLevel); }. void SetErrorDef(double up); set scale f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:12756,Error,ErrorDef,12756,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,3,['Error'],['ErrorDef']
Availability,"ame); Provides the most common way for accessing a font: opens (loads) the; specified font and returns a pointer to the appropriate FontStruct_t; structure. If the font does not exist, it returns NULL. FontH_t GetFontHandle(FontStruct_t fs); Returns the font handle of the specified font structure ""fs"". void DeleteFont(FontStruct_t fs); Explicitely deletes the font structure ""fs"" obtained via LoadQueryFont(). GContext_t CreateGC(Drawable_t id, GCValues_t* gval); Creates a graphics context using the provided GCValues_t *gval structure.; The mask data member of gval specifies which components in the GC are; to be set using the information in the specified values structure.; It returns a graphics context handle GContext_t that can be used with any; destination drawable or O if the creation falls. void ChangeGC(GContext_t gc, GCValues_t* gval); Changes the components specified by the mask in gval for the specified GC. GContext_t gc - specifies the GC to be changed; GCValues_t gval - specifies the mask and the values to be set; (see also the GCValues_t structure). void CopyGC(GContext_t org, GContext_t dest, Mask_t mask); Copies the specified components from the source GC ""org"" to the; destination GC ""dest"". The ""mask"" defines which component to copy; and it is a data member of GCValues_t. void DeleteGC(GContext_t gc); Deletes the specified GC ""gc"". Cursor_t CreateCursor(ECursor cursor); Creates the specified cursor. (just return cursor from cursor pool).; The cursor can be:. kBottomLeft, kBottomRight, kTopLeft, kTopRight,; kBottomSide, kLeftSide, kTopSide, kRightSide,; kMove, kCross, kArrowHor, kArrowVer,; kHand, kRotate, kPointer, kArrowRight,; kCaret, kWatch. void SetCursor(Window_t id, Cursor_t curid); Sets the cursor ""curid"" to be used when the pointer is in the; window ""id"". Pixmap_t CreatePixmap(Drawable_t id, UInt_t w, UInt_t h); Creates a pixmap of the specified width and height and returns; a pixmap ID that identifies it. Pixmap_t CreatePixmap(Drawable_t id, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualX.html:41102,mask,mask,41102,root/html528/TVirtualX.html,https://root.cern,https://root.cern/root/html528/TVirtualX.html,10,['mask'],['mask']
Availability,"ame); ~TStreamerArtificial(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tTStreamerElement::CannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*TStreamerElement::GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerArtificial.html:1505,error,error,1505,root/html528/TStreamerArtificial.html,https://root.cern,https://root.cern/root/html528/TStreamerArtificial.html,6,['error'],['error']
Availability,"ame, const Char_t *title, Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL, const Float_t *exH, std::vector< TArrayF > eyL, std::vector< TArrayF > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne=1);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const TGraphMultiErrors &tgme);  TGraphMultiErrors copy constructor. ;  ;  TGraphMultiErrors (const TH1 *pass, const TH1 *total, Int_t ne=1, Option_t *option="""");  Creates a TGraphMultiErrors by dividing two input TH1 histograms: pass/total. ;  ;  TGraphMultiErrors (const TH1 *th, Int_t ne=1);  TGraphMultiErrors constructor importing its parameters from the TH1 object passed as argument. ;  ;  TGraphMultiErrors (const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL, const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m=kOnlyFirst);  Constructor with six vectors of doubles in input and a single y error dimension. ;  ;  TGraphMultiErrors (const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL, const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m=kOnlyFirst);  Constructor with six vectors of floats in input and a single y error dimension. ;  ;  TGraphMultiErrors (Int_t ne, const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL, const TVectorD &tvExH, const TVectorD *tvEyL, const TVectorD *tvEyH, Int_t m=kOnlyFirst);  Constructor with multiple vectors of doubles in input and multiple y error dimensions A grapherrors is built with the X coordinates taken from tvX the Y coordinates from tvY and the errors from vectors tvExL, tvExH and tvEyL/H[yErrorDimension]. ;  ;  TGraphMultiErrors (Int_t ne, const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL, const TVectorF &tvExH, const TVectorF *tvEyL, const TVectorF *tvEyH, In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:6606,error,error,6606,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,"ame, const char* title, const RooArgList& pdfList, RooAbsCategoryLValue& indexCat); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSimultaneous.html:29907,Error,ErrorLoggingMode,29907,root/html602/RooSimultaneous.html,https://root.cern,https://root.cern/root/html602/RooSimultaneous.html,2,['Error'],['ErrorLoggingMode']
Availability,"ame, which may be found as a trailing part of the; name or in a url fragment section. If not found this will; be empty.; query - is the url query section, including the leading question; mark. If not found or the query section is only followed by; a fragment this will be empty.; suffix - the portion of name which was removed to form filename. void Print(Option_t* option = """") const; -- Print the header information of each tree in the chain.; See TTree::Print for a list of options. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process all entries in this chain, calling functions in filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success.; See TTree::Process. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = kBigNumber, Long64_t firstentry = 0); Process this chain executing the code in selector.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void RecursiveRemove(TObject* obj); Make sure that obj (which is being deleted or will soon be) is no; longer referenced by this TTree. void RemoveFriend(TTree* ); Remove a friend from the list of friends. void Reset(Option_t* option = """"); Resets the state of this chain. void ResetAfterMerge(TFileMergeInfo* ); Resets the state of this chain after a merge (keep the customization but; forget the data). Long64_t Scan(const char* varexp = """", const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); -- Loop on tree and print entries passing selection.; If varexp is 0 (or """") then print only first 8 columns.; If varexp = ""*"" print all columns.; Otherwise a columns selection can be made using ""var1:var2:var3"".; See TTreePlayer::Scan for more information. void SetAutoDelete(Bool_t autodel = kTRUE); -- Set the global branch kAutoDelete bit. When LoadTree loads a new Tree, the branches for which; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TChain.html:51299,error,error,51299,root/html602/TChain.html,https://root.cern,https://root.cern/root/html602/TChain.html,4,['error'],['error']
Availability,"ame. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; TClass * IsA () const override;  ; Bool_t IsClient () const override;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented: meaningful only in the remote player. Returns kFALSE. ;  ; Long64_t Process (TDSet *set, const char *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF worker. ;  ; Long64_t Process (TDSet *set, TSelector *selector, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Process specified TDSet on PROOF worker with TSelector object The return value is -1 in case of error and TSelector::GetStatus() in case of success. ;  ; void Progress (Long64_t total, Long64_t processed) override;  Report progress (may not be used in this class). ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  Report progress (may not be used in this class). ;  ; void Progress (TProofProgressInfo *pi) override;  Report progress (may not be used in this class). ;  ; void Progress (TSlave *, Long64_t total, Long64_t processed) override;  ; void Progress (TSlave *, Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti) override;  ; void Progress (TSlave *, TProofProgressInfo *pi) override;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void Rem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:5440,error,error,5440,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['error'],['error']
Availability,"ame3); ; c = ROOT.TCanvas(""rf105_funcbinding"", ""rf105_funcbinding"", 1200, 400); c.Divide(3); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.6); frame1.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); ; c.SaveAs(""rf105_funcbinding.png""); RooCFunction1Binding<double,double>::erf[ function=(0x7f013b501000) x=x ] = 0; RooCFunction3PdfBinding<double,double,double,double>::beta[ function=ROOT::Math::beta_pdf x=x2 a=a b=b ] = 0.934689; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Fitting -- RooAbsPdf::fitTo(beta_over_beta_Int[x2]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_beta_over_beta_Int[x2]_betaData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:NumericIntegration -- RooRealIntegral::init(beta_Int[x2]) using numeric integrator RooIntegrator1D to calculate Int(x2); RooTFnBinding::fa1[ TFn={fa1=sin(x)/x} obs=(x3) ] = -0.0547936; DateFebruary 2018 ; AuthorsClemens Lange, Wouter Verkerke (C version) ; Definition in file rf105_funcbinding.py. tutorialsroofitrf105_funcbinding.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf105__funcbinding_8py.html:3202,error,error,3202,doc/master/rf105__funcbinding_8py.html,https://root.cern,https://root.cern/doc/master/rf105__funcbinding_8py.html,1,['error'],['error']
Availability,"ame::fBackgroundframe background color; TGCheckButton*fBestErrorsswitch on/off option 'improve errors'; TList*TGMainFrame::fBindListlist with key bindings; Int_tTGFrame::fBorderWidthframe border width; TStringTGMainFrame::fClassNameWM class name; TGClient*TGObject::fClientConnection to display server; TGTextButton*fCloseButtonclose the fit panel; TGRadioButton*fConvset convolution mode; Int_tTGFrame::fDNDStateEDNDFlags; Atom_t*TGMainFrame::fDNDTypeListhandles DND types; TGComboBox*fDataSetcontains list of data set to be fitted; Int_tfDimobject dimension; TGTextButton*fDrawAdvancedopens a dialog for advanced draw options; TGCheckButton*fDrawSameswitch on/off fit function drawing; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; TGCheckButton*fEmptyBinsWghts1switch on/off option 'include empry bins'; TGTextEntry*fEnteredFunccontains user function file name; TGNumberEntryField*fErrorScalecontains error scale set for minimization; UInt_tTGFrame::fEventMaskcurrenty active event mask; TGFrameElement*TGFrame::fFEpointer to frame element; TGTextButton*fFitButtonperforms fitting; TObject*fFitObjectselected object to fit; TGComboBox*fFuncListcontains function list; vector<FuncParamData_t>fFuncParsfunction parameters (value + limits); TGCompositeFrame*fGeneralgeneral tab; UInt_tTGFrame::fHeightframe height; TStringTGMainFrame::fIconNameicon name; TStringTGMainFrame::fIconPixmapicon pixmap name; Handle_tTGObject::fIdX11/Win32 Window identifier; TGCheckButton*fImproveResultsswitch on/off option 'improve fit results'; TGCheckButton*fIntegralswitch on/off option 'integral'; TGNumberEntryField*fIterationscontains maximum number of iterations; TGLayoutHints*fLayoutAddlayout hints of fAdd radio button; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutHints*fLayoutConvlayout hints of fConv radio button; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGLayoutHints*fLayoutNonelayout hints of fNone radio button; TGRadioButton*fLibFumiliset",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitEditor.html:25162,mask,mask,25162,root/html528/TFitEditor.html,https://root.cern,https://root.cern/root/html528/TFitEditor.html,1,['mask'],['mask']
Availability,ame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; const TGPicture*fPictureimage used for popup window; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fStylebutton style (modern or classic); UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGedMarkerSelect.html:21380,down,down,21380,root/html530/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html530/TGedMarkerSelect.html,9,['down'],['down']
Availability,ame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; const TGWindow*TGWidget::fMsgWindowwindow which handles widget events; TStringTGWindow::fNamename of the window used in SavePrimitive(); Bool_tTGWindow::fNeedRedrawkTRUE if window needs to be redrawn; GContext_tTGButton::fNormGCgraphics context used for drawing button; const TGPicture*TGCheckButton::fOffbutton OFF picture; const TGPicture*TGCheckButton::fOnbutton ON picture; UInt_tTGFrame::fOptionsframe options; const TGWindow*TGWindow::fParentParent window; const TGPicture*fPictureimage used for popup window; TGedPopup*TGedSelect::fPopup; EButtonStateTGCheckButton::fPrevStateprevious check button state; Bool_tTGTextButton::fPrevStateOnbit to save previos state On/Off; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; EButtonStateTGButton::fStatebutton state; Bool_tTGTextButton::fStateOnbit to save the state across disable/enable; Bool_tTGButton::fStayDowntrue if button has to stay down; UInt_tTGButton::fTHeightbutton height; TGTextLayout*TGTextButton::fTLayouttext layout; Int_tTGTextButton::fTModetext justify mode; UInt_tTGButton::fTWidthbutton width; TGToolTip*TGButton::fTiptool tip associated with button; void*TGButton::fUserDatapointer to user data structure; Int_tTGWidget::fWidgetFlagswidget status flags (OR of EWidgetStatus); Int_tTGWidget::fWidgetIdthe widget id (used for event processing); UInt_tTGFrame::fWidthframe width; Int_tTGTextButton::fWrapLengthwrap length; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGCheckButton::fgDefaultFont; static const TGFont*TGT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedMarkerSelect.html:21042,down,down,21042,root/html528/TGedMarkerSelect.html,https://root.cern,https://root.cern/root/html528/TGedMarkerSelect.html,1,['down'],['down']
Availability,"ame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. private:. TGTextButton*fClosecancel button; TGColorSelect*fConfColorColor for the graph; TGVerticalFrame*fConfFrameConfidence Intervals Frame; TGNumberEntry*fConfLevelConfidence Level; TGColorSelect*fContourColorColor for the graph; TGNumberEntry*fContourErrorError Level for Contour; TGVerticalFrame*fContourFrameContour Frame; TGCheckButton*fContourOverSuperimpose the graphics; TGComboBox*fContourPar1Parameter 1 for Contour; TGComboBox*fContourPar2Parameter 2 for Contour; TGNumberEntry*fContourPointsNumber of points for the graph; TGTextButton*fDrawok button; TBackCompFitter*fFitterFitter.; TGVerticalFrame*fMainFrameMain Vertical Frame; TGVerticalFrame*fScanFrameScan Frame; TGNumberEntry*fScanMaxMax Value for Contour; TGNumberEntry*fScanMinMin Value for Contour; TGComboBox*fScanParParameter for Scan; TGNumberEntry*fScanPointsNumber of points for the graph; TGTab*fTabTab containing the available methods. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TAdvancedGraphicsDialog(const TGWindow* p, const TGWindow* main); Creates the Advanced Graphics Dialog. void CreateContourFrame(); Create the frame that contains all the necessary information for; the Contour method. void CreateScanFrame(); Create the frame that contains all the necessary information for; the Scan method. void CreateConfFrame(); Create the frame that contains all the necessary information for; the Confidence Level method. void AddParameters(TGComboBox* ); Add all the parameters of the VirtualFitter into a comboBox; (helper method). void ConnectSlots(); Connect the slots (buttons mainly + specific methods). void DoChangedScanPar(Int_t selected); Changes the Min and Max default values of the scan method,; depending on the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAdvancedGraphicsDialog.html:24363,avail,available,24363,root/html602/TAdvancedGraphicsDialog.html,https://root.cern,https://root.cern/root/html602/TAdvancedGraphicsDialog.html,4,['avail'],['available']
Availability,"ame;  CTGMapKey;  CTGMatrixLayout;  CTGMdiButtons;  CTGMdiContainer;  CTGMdiCornerWinResizer;  CTGMdiDecorFrame;  CTGMdiFrame;  CTGMdiFrameList;  CTGMdiGeometry;  CTGMdiHorizontalWinResizer;  CTGMdiMainFrame;  CTGMdiMenuBar;  CTGMdiTitleBar;  CTGMdiTitleIcon;  CTGMdiVerticalWinResizer;  CTGMdiWinResizer;  CTGMenuBar;  CTGMenuEntry;  CTGMenuTitle;  CTGMime;  CTGMimeTypes;  CTGMsgBox;  CTGNumberEntry;  CTGNumberEntryField;  CTGNumberEntryLayout;  CTGNumberFormat;  CTGObject;  CTGondzioSolver;  CTGOSXGLManager;  CTGPack;  CTGPasswdDialog;  CTGPicture;  CTGPictureButton;  CTGPicturePool;  CTGPopupMenu;  CTGPosition;  CTGPrintDialog;  CTGProgressBar;  CTGQuartzThis is non-GUI part of TVirtualX interface, implemented for MacOS X, using CoreGraphics (Quartz) ;  CTGRadioButton;  CTGraphA Graph is a graphics object made of two arrays X and Y with npoints each ;  CTGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each ;  CTGraph2DErrorsGraph 2D class with errors ;  CTGraph2DPainterThe TGraphDelaunay painting class ;  CTGraphAsymmErrorsTGraph with assymetric error bars ;  CTGraphBentErrorsA TGraphBentErrors is a TGraph with bent, assymetric error bars ;  CTGraphDelaunayTGraphDelaunay generates a Delaunay triangulation of a TGraph2D ;  CTGraphDelaunay2D;  CTGraphEdgeAn edge object connecting two nodes which can be added in a TGraphStruct ;  CTGraphEditor;  CTGraphErrorsA TGraphErrors is a TGraph with error bars ;  CTGraphNodeA graph node object which can be added in a TGraphStruct ;  CTGraphPainterThe graph painter class ;  CTGraphPolarTo draw a polar graph ;  CTGraphPolargramTo draw polar axis ;  CTGraphQQThis class allows to draw quantile-quantile plots ;  CTGraphSmoothA helper class to smooth TGraph ;  CTGraphStructThe Graph Structure is an interface to the graphviz package ;  CTGraphTimeTGraphTime is used to draw a set of objects evolving with nsteps in time between tmin and tmax ;  CTGRecorder;  CTGRectangle;  CTGRectMap;  CTGRedirectOut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:130877,error,errors,130877,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['error'],['errors']
Availability,"ame;  CTGMapKey;  CTGMatrixLayout;  CTGMdiButtons;  CTGMdiContainer;  CTGMdiCornerWinResizer;  CTGMdiDecorFrame;  CTGMdiFrame;  CTGMdiFrameList;  CTGMdiGeometry;  CTGMdiHorizontalWinResizer;  CTGMdiMainFrame;  CTGMdiMenuBar;  CTGMdiTitleBar;  CTGMdiTitleIcon;  CTGMdiVerticalWinResizer;  CTGMdiWinResizer;  CTGMenuBar;  CTGMenuEntry;  CTGMenuTitle;  CTGMime;  CTGMimeTypes;  CTGMsgBox;  CTGNumberEntry;  CTGNumberEntryField;  CTGNumberEntryLayout;  CTGNumberFormat;  CTGObject;  CTGondzioSolver;  CTGOSXGLManager;  CTGPack;  CTGPasswdDialog;  CTGPicture;  CTGPictureButton;  CTGPicturePool;  CTGPopupMenu;  CTGPosition;  CTGPrintDialog;  CTGProgressBar;  CTGQuartzThis is non-GUI part of TVirtualX interface, implemented for MacOS X, using CoreGraphics (Quartz) ;  CTGRadioButton;  CTGraphA Graph is a graphics object made of two arrays X and Y with npoints each ;  CTGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each ;  CTGraph2DErrorsGraph 2D class with errors ;  CTGraph2DPainterThe TGraphDelaunay painting class ;  CTGraphAsymmErrorsTGraph with asymmetric error bars ;  CTGraphBentErrorsA TGraphBentErrors is a TGraph with bent, assymetric error bars ;  CTGraphDelaunayTGraphDelaunay generates a Delaunay triangulation of a TGraph2D ;  CTGraphDelaunay2DTGraphDelaunay2D generates a Delaunay triangulation of a TGraph2D ;  CTGraphEdgeAn edge object connecting two nodes which can be added in a TGraphStruct ;  CTGraphEditor;  CTGraphErrorsA TGraphErrors is a TGraph with error bars ;  CTGraphNodeA graph node object which can be added in a TGraphStruct ;  CTGraphPainterThe graph painter class ;  CTGraphPolarTo draw a polar graph ;  CTGraphPolargramTo draw polar axis ;  CTGraphQQThis class allows to draw quantile-quantile plots ;  CTGraphSmoothA helper class to smooth TGraph ;  CTGraphStructThe Graph Structure is an interface to the graphviz package ;  CTGraphTimeTGraphTime is used to draw a set of objects evolving with nsteps in time between tmin an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:157408,error,errors,157408,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,5,['error'],['errors']
Availability,"ameArchive file name; TStringfCommentArchive comment; TArchiveMember*TArchiveFile::fCurMemberCurrent archive member; Long64_tfDirOffsetCentral directory offset (from the beginning of the archive); Long64_tfDirPosCentral directory position; Long64_tfDirSizeCentral directory size; TFile*TArchiveFile::fFileFile stream used to access the archive; Int_tTArchiveFile::fMemberIndexIndex of sub-file in archive; TStringTArchiveFile::fMemberNameSub-file name; TObjArray*TArchiveFile::fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Int_t ReadDirectory(); Read the directory of the ZIP archive. Returns -1 in case of error,; 0 otherwise. Int_t ReadMemberHeader(TZIPMember* member); Read the member header of the ZIP archive. Sets the position where; the data starts in the member object. Returns -1 in case of error,; 0 otherwise. Int_t SetCurrentMember(); Find the desired member in the member array and make it the; current member. Returns -1 in case member is not found, 0 otherwise. UInt_t Get(const void* buffer, Int_t bytes); Read a ""bytes"" long little-endian integer value from ""buffer"". void Print(Option_t* option = """") const; Pretty print ZIP archive members. TZIPFile(const TZIPFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TZIPFile.html:10381,error,error,10381,root/html528/TZIPFile.html,https://root.cern,https://root.cern/root/html528/TZIPFile.html,1,['error'],['error']
Availability,"ameArchive file name; TStringfCommentArchive comment; TArchiveMember*TArchiveFile::fCurMemberCurrent archive member; Long64_tfDirOffsetCentral directory offset (from the beginning of the archive); Long64_tfDirPosCentral directory position; Long64_tfDirSizeCentral directory size; TFile*TArchiveFile::fFileFile stream used to access the archive; Int_tTArchiveFile::fMemberIndexIndex of sub-file in archive; TStringTArchiveFile::fMemberNameSub-file name; TObjArray*TArchiveFile::fMembersMembers in this archive. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TZIPFile(); Default ctor. TZIPFile(const char* archive, const char* member, TFile* file); Specify the archive name and member name. The member can be a decimal; number which allows to access the n-th member. Int_t OpenArchive(); Open archive and read end-header and directory. Returns -1 in case; of error, 0 otherwise. Long64_t FindEndHeader(); Find the end header of the ZIP archive. Returns 0 in case of error. Int_t ReadEndHeader(Long64_t pos); Read the end header of the ZIP archive including the archive comment; at the current file position. Check that it really was a single-disk; archive with all the entries as expected. Most importantly, figure; out where the central directory begins. Returns -1 in case of error,; 0 otherwise. Long64_t ReadZip64EndLocator(Long64_t pos); Read Zip64 end of central directory locator. Returns -1 in case of error,; -2 in case end locator magic is not found (i.e. not a zip64 file) and; offset of Zip64 end of central directory record in case of success. Int_t ReadZip64EndRecord(Long64_t pos); Read Zip64 end of central directory record. Returns -1 in case of error; and 0 in case of success. Int_t ReadDirectory(); Read the directory of the ZIP archive. Returns -1 in case of error,; 0 otherwise. Int_t ReadMemberHeader(TZIPMember* member); Read the member header of the ZIP archive. Sets the position where; the data starts in the member object. Returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TZIPFile.html:11874,error,error,11874,root/html530/TZIPFile.html,https://root.cern,https://root.cern/root/html530/TZIPFile.html,5,['error'],['error']
Availability,"amed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tRooAbsDataStore::hasFilledCache() const; virtual ULon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:2774,error,error,2774,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,2,['error'],['error']
Availability,"amed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual const RooArgSet*getNative(Int_t index) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:3137,error,error,3137,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,2,['error'],['error']
Availability,"amed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual const RooArgSet*getNative(Int_t index) const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:3169,error,error,3169,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,6,['error'],['error']
Availability,"amed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voiddump(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual Int_tfill(); virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidforceCacheUpdate(); virtual const RooArgSet*get(Int_t index) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual Bool_thasFilledCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCompositeDataStore.html:2807,error,error,2807,root/html534/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html534/RooCompositeDataStore.html,6,['error'],['error']
Availability,"amed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char* src, const char* dst = 0, const char* opts = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*TProofMgr::CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* what = ""~/"", const char* how = ""-type f"", const char* where = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char* remote, const char* local, const char* opt = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*GetMssUrl(Bool_t = kFALSE); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:2202,error,error,2202,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,6,['error'],['error']
Availability,"amed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char* src, const char* dst = 0, const char* opts = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*TProofMgr::CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* what = ""~/"", const char* how = ""-type f"", const char* where = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char* remote, const char* local, const char* opt = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual TProofDesc*TProofMgr::GetProofDesc(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXProofMgr.html:2178,error,error,2178,root/html528/TXProofMgr.html,https://root.cern,https://root.cern/root/html528/TXProofMgr.html,4,['error'],['error']
Availability,"amed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTSystem::SetObjExt(const char* objExt); virtual voidSetProgname(const char* name); virtual intSetSockOpt(int sock, int option, int val); virtual voidTSystem::SetSoExt(const char* soExt); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidTSystem::ShowOutput(RedirectHandle_t* h); virtual voidSigAlarmInterruptsSyscalls(Bool_t set); virtual Int_tTNamed::Sizeof() const; virtual voidSleep(UInt_t milliSec); virtual TStringTSystem::SplitAclicMode(const char* filename, TString& mode, TString& args, TString& io) const; virtual voidStackTrace(); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual intSymlink(const char* from, const char* to); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual voidSyslog(ELogLevel level, const char* mess); virtual const char*TempDirectory() const; virtual FILE*TempFileName(TString& base, const char* dir = 0); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual intUmask(Int_t mask); virtual const char*TSystem::UnixPathName(const char* unixpathname); virtual intUnlink(const char* name); virtual voidUnload(const char* module); virtual voidUnsetenv(const char* name); virtual voidTObject::UseCurrentStyle(); virtual intUtime(const char* file, Long_t modtime, Long_t actime); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual char*TSystem::Which(const char* search, const char* file, EAccessMode mode = kFileExists); virtual const char*WorkingDirectory(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnixSystem.html:13578,mask,mask,13578,root/html534/TUnixSystem.html,https://root.cern,https://root.cern/root/html534/TUnixSystem.html,2,['mask'],['mask']
Availability,"amed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMinuit(); Minuit normal constructor*-*-*-*-; *-* ========================. TMinuit(Int_t maxpar); Minuit normal constructor*-*-*-*-; *-* ========================. maxpar is the maximum number of parameters used with this TMinuit object. TMinuit(const TMinuit& m); Private TMinuit copy ctor. TMinuit can not be copied. ~TMinuit(); Minuit default destructor*-*-*-*-; *-* =========================. void BuildArrays(Int_t maxpar = 15); -*-*-*Create internal Minuit arrays for the maxpar parameters; *-* =======================================================. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; Function pointer is copied to Clone. Int_t Command(const char* command); execute a Minuit command; Equivalent to MNEXCM except that the command is given as a; character string.; See TMinuit::mnhelp for the full list of available commands; See also http://wwwasdoc.web.cern.ch/wwwasdoc/minuit/node18.html for; a complete documentation of all the available commands. Returns the status of the execution:; = 0: command executed normally; 1: command is blank, ignored; 2: command line unreadable, ignored; 3: unknown command, ignored; 4: abnormal termination (e.g., MIGRAD not converged); 5: command is a request to read PARAMETER definitions; 6: 'SET INPUT' command; 7: 'SET TITLE' command; 8: 'SET COVAR' command; 9: reserved; 10: END command; 11: EXIT or STOP command; 12: RETURN command. *. TObject * Contour(Int_t npoints = 10, Int_t pa1 = 0, Int_t pa2 = 1); Creates a TGraph object describing the n-sigma contour of a; TMinuit fit. The contour of the parameters pa1 and pa2 is calculated; unsing npoints (>=4) points. The TMinuit status will be; 0 on success and; -1 if errors in the calling sequence (pa1, pa2 not variable); 1 if less than four points can be found; 2 if npoints<4; n>3 if only n points can be found (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:30323,avail,available,30323,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,10,['avail'],['available']
Availability,"amed] { kDeleteWindowCalled; };; enum TGWindow::EEditMode { kEditEnable; kEditDisable; kEditDisableEvents; kEditDisableGrab; kEditDisableLayout; kEditDisableResize; kEditDisableHeight; kEditDisableWidth; kEditDisableBtnEnable; kEditDisableKeyEnable; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; Int_tTGFrame::fBorderWidthframe border width; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; TGCheckButton*fDrawFrameCheckbox for frame rendering.; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; UInt_tTGFrame::fHeightframe height; TGCheckButton*fHighlightFrameCheckbox for frame rendering.; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TGColorSelect*fLineColorLine color widget.; TGNumberEntry*fLineWidthLine width widget.; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TEveShape*fMModel object.; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaximal frame width; UInt_tTGFrame::fMinHeightminimal frame height; UInt_tTGFrame::fMinWidthminimal frame width; TClass*TGedFrame::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveShapeEditor.html:17393,mask,mask,17393,root/html528/TEveShapeEditor.html,https://root.cern,https://root.cern/root/html528/TEveShapeEditor.html,6,['mask'],['mask']
Availability,"amed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. private:. TProofServLiteInterruptHandler*fInterruptHandler; TStringfSockPathunix socket path; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TProofServLite(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. void HandleFork(TMessage* mess); Cloning itself via fork. Int_t SetupOnFork(const char* ord); Finalize the server setup afetr forking.; Return 0 on success, -1 on error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TProofServLite.h 33637 2010-05-28 13:13:05Z rdm $ » Last generated: 2010-09-23 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServLite.html:16800,error,error,16800,root/html528/TProofServLite.html,https://root.cern,https://root.cern/root/html528/TProofServLite.html,5,"['alive', 'error']","['alive', 'error']"
Availability,"amedvirtual; Compare(const TObject *obj) const overrideTNamedvirtual; Copy(TObject &named) const overrideTNamedvirtual; DeclFileName()TFumiliinlinestatic; Delete(Option_t *option="""")TObjectvirtual; DeleteArrays()TFumili; Derivatives(Double_t *, Double_t *)TFumili; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Eval(Int_t &npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)TFumili; EvalTFN(Double_t *, Double_t *)TFumili; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteCommand(const char *command, Double_t *args, Int_t nargs) overrideTFumilivirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; ExecuteSetCommand(Int_t)TFumili; fATFumiliprivate; fAKAPPATFumiliprivate; fAMNTFumiliprivate; fAMXTFumiliprivate; fANamesTFumiliprivate; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fCacheTVirtualFitterprotected; fCacheSizeTVirtualFitterprotected; fCmParTFumiliprivate; FCNFunc_t typedefTVirtualFitter; fCwordTFumiliprivate; fDATFumiliprivate; fDEBUGTFumiliprivate; fDFTFumiliprivate; fENDFLGTFumiliprivate; fEPSTFumiliprivate; fEXDATFumiliprivate; fFCNTVirtualFitterprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; fGrTFumiliprivate; fGRADTFumiliprivate; fGTTFumiliprivate; FillBuffer(char *&buffer)TNamedvirtual; fINDFLGTFumiliprivate; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; FitChisquare(Int_t &npar, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili-members.html:1613,error,error,1613,doc/master/classTFumili-members.html,https://root.cern,https://root.cern/doc/master/classTFumili-members.html,2,['error'],['error']
Availability,"amer facility.Definition TNamed.cxx:74; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::Writevirtual Int_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0)Write this object to the current directory.Definition TObject.cxx:886; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TPaveStatsThe histogram statistics painter class.Definition TPaveStats.h:18; TPaveStats::SetOptStatvoid SetOptStat(Int_t stat=1)Set the stat option.Definition TPaveStats.cxx:308; TSelector::fInputTList * fInputList of objects available during processing.Definition TSelector.h:41; TSelector::fOutputTSelectorList * fOutput! List of objects created during processingDefinition TSelector.h:42; TSelector::GetOptionconst char * GetOption() const overrideDefinition TSelector.h:57; TStringBasic string class.Definition TString.h:139; TStyle::SetOptStatvoid SetOptStat(Int_t stat=1)The type of information printed in the histogram statistics box can be selected via the parameter mod...Definition TStyle.cxx:1640; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; TTreeReaderArray::AtT & At(std::size_t idx)Definition TTreeReaderArray.h:205; TTreeReader::GetTreeTTree * GetTree() constDefinition TTreeReader.h:207; TTreeReader::SetLocalEntryEEntryStatus SetLocalEntry(Long64_t entry)Set the next local tree entry.Definition TTreeReader.h:235; TTreeA TTree represents a columnar dataset.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1analysisTreeReader_8C.html:12573,avail,available,12573,doc/master/h1analysisTreeReader_8C.html,https://root.cern,https://root.cern/doc/master/h1analysisTreeReader_8C.html,1,['avail'],['available']
Availability,"amerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the system.rootrc file. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2048 of file TFile.cxx. ◆ ReOpen(). Int_t TFile::ReOpen ; (; Option_t * ; mode). virtual . Reopen a file with a different access mode. ; For example, it is possible to change from READ to UPDATE or from NEW, CREATE, RECREATE, UPDATE to READ. Thus the mode argument can be either ""READ"" or ""UPDATE"". The method returns 0 in case the mode was successfully modified, 1 in case the mode did not change (was already as requested or w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89661,recover,recovered,89661,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recovered']
Availability,"amerInfoActions.h""; 23#include ""THashTable.h""; 24#include ""THashList.h""; 25#include <cstdlib>; 26 ; 27#define MESSAGE(which,text); 28 ; 29/**; 30\class TGenVectorProxy; 31\ingroup IO; 32Local optimization class.; 33 ; 34Collection proxies get copied. On copy we switch the type of the; 35proxy to the concrete STL type. The concrete types are optimized; 36for element access.; 37*/; 38 ; 39class TGenVectorProxy : public TGenCollectionProxy {; 40public:; 41 // Standard Destructor; 42 TGenVectorProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c); 43 {; 44 }; 45 // Standard Destructor; 46 ~TGenVectorProxy() override; 47 {; 48 }; 49 // Return the address of the value at index 'idx'; 50 void* At(UInt_t idx) override; 51 {; 52 if ( fEnv && fEnv->fObject ) {; 53 fEnv->fIdx = idx;; 54 switch( idx ) {; 55 case 0:; 56 return fEnv->fStart = fFirst.invoke(fEnv);; 57 default:; 58 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 59 return ((char*)fEnv->fStart) + fValDiff*idx;; 60 }; 61 }; 62 Fatal(""TGenVectorProxy"",""At> Logic error - no proxy object set."");; 63 return nullptr;; 64 }; 65 // Call to delete/destruct individual item; 66 void DeleteItem(Bool_t force, void* ptr) const override; 67 {; 68 if ( force && ptr ) {; 69 if ( fVal->fProperties&kNeedDelete) {; 70 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 71 TPushPop helper(proxy,ptr);; 72 proxy->Clear(""force"");; 73 }; 74 fVal->DeleteItem(ptr);; 75 }; 76 }; 77};; 78 ; 79/**; 80\class TGenVectorBoolProxy; 81\ingroup IO; 82Local optimization class.; 83 ; 84Collection proxies get copied. On copy we switch the type of the; 85proxy to the concrete STL type. The concrete types are optimized; 86for element access.; 87*/; 88class TGenVectorBoolProxy : public TGenCollectionProxy {; 89 Bool_t fLastValue;; 90 ; 91public:; 92 TGenVectorBoolProxy(const TGenCollectionProxy& c) : TGenCollectionProxy(c), fLastValue(false); 93 {; 94 // Standard Constructor.; 95 }; 96 ~TGenVectorBoolProxy() override; 97 {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:2004,error,error,2004,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['error'],['error']
Availability,"amervoid Streamer(TBuffer &) overrideStream an object of class TLine.Definition TLine.cxx:518; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::RemoveTString & Remove(Ssiz_t pos)Definition TString.h:685; TString::Streamervirtual void Streamer(TBuffer &)Stream a string object.Definition TString.cxx:1412; TString::AppendTString & Append(const char *cs)Definition TString.h:572; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Ind",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:127235,error,error,127235,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['error'],['error']
Availability,"ameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; independently if the fit option ""S"" is used or not:; TFitResultPtr r = h->Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is OK (i.e no error occurred).; The value of the fit status code is negative in case of an error not connected with the; minimization procedure, for example when a wrong function is used.; Otherwise the return value is the one returned from the minimization procedure.; When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :; fitStatus = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.; TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in; case of error (see the documentation of TMinuit::mnexcm). So for example, for an error; only in Minos but not in Migrad a fitStatus of 40 will be returned.; Minuit2 will return also 0 in case of success and different values in migrad minos or; hesse depending on the error. See in this case the documentation of; Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the; minosResult and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:83472,error,error,83472,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,6,['error'],['error']
Availability,"ameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; independently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is OK (i.e no error occurred).; The value of the fit status code is negative in case of an error not connected with the; minimization procedure, for example when a wrong function is used.; Otherwise the return value is the one returned from the minimization procedure.; When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :; fitStatus = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.; TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in; case of error (see the documentation of TMinuit::mnexcm). So for example, for an error; only in Minos but not in Migrad a fitStatus of 40 will be returned.; Minuit2 will return also 0 in case of success and different values in migrad minos or; hesse depending on the error. See in this case the documentation of; Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the; minosResult and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:80202,error,error,80202,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,2,['error'],['error']
Availability,"ameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is OK (i.e no error occurred).; The value of the fit status code is negative in case of an error not connected with the; minimization procedure, for example when a wrong function is used.; Otherwise the return value is the one returned from the minimization procedure.; When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :; fitStatus = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.; TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in; case of error (see the documentation of TMinuit::mnexcm). So for example, for an error; only in Minos but not in Migrad a fitStatus of 40 will be returned.; Minuit2 will return also 0 in case of success and different values in migrad minos or; hesse depending on the error. See in this case the documentation of; Minuit2Minimizer::Minimize for the migradResult, Minuit2Minimizer::GetMinosError for the; minosResult and Minuit2Minimizer::Hesse for the hesseResult.; If other minimizers are used see their specific documentation for the status code returned.; For example in the cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:78468,error,error,78468,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['error'],['error']
Availability,"ameter five, then add; MnContours contour(...);; std::vector<std::pair<double, double> > points = contour(4, 5);; to see a two-dimensional picture.; 6.5 Interpretation of parameter errors; There are two kinds of problems that can arise: The reliability of M ’s error estimates, and their statistical interpretation, assuming they are accurate.; 6.5.1 Statistical interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, parabolic versus \(\mbox{MINOS}\) errors, the appropriate value for \(\mbox{up}\) (see [howto:errordef]), and setting of exact confidence levels, see (in order of increasing complexity and completeness):. “Interpretation of the Errors on Parameters”, see Part 3 of this write-up.; “Determining the Statistical Significance of Experimental Results”@bib-MIN81.; “Statistical Methods in Experimental Physics”@bib-EADIE. 6.5.2 The reliability of M error estimates; M always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a \(\mbox{MIGRAD}\) or \(\mbox{HESSE}\) step, the errors are usually quite accurate, unless there has been a problem. If no mitigating adjective is given in the printout of the errors, then at least M believes the errors are accurate, although there is always a small chance that M has been fooled. Some visible signs that M may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of \(\mbox{EDM}\) too big. For a “normal” minimization, after \(\mbox{MIGRAD}\), the value of \(\mbox{EDM}\) is usually more than three orders of magnitude smaller than \(\mbox{up}\), unless a looser tolerance has been specified.; Correlation coefficients exactly equal to zero, unless some parameters are known to be u",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:69731,reliab,reliability,69731,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,6,"['error', 'reliab']","['error', 'errors', 'reliability']"
Availability,"ameter tau, method DoUnfold(tau) . or multiple times in a scan to determine the best chouce of tau, method ScanLCurve() . Unfolding results are retrieved using various GetXXX() methods . Description of (systematic) uncertainties available in TUnfoldSys. There are covariance matrix contributions and there are systematic shifts. Systematic shifts correspond to the variation of a (buicance) parameter, for example a background normalisation or a one-sigma variation of a correlated systematic error. . Set by Access covariance matrix Access vector of shifts Description . (a)TUnfoldSys constructor GetEmatrixSysUncorr()n.a. uncorrelated errors on the input matrix histA, taken as the errors provided with the histogram. These are typically statistical errors from finite Monte Carlo samples. . (b)AddSysError()GetEmatrixSysSource() GetDeltaSysSource() correlated shifts of the input matrix histA. These shifts are taken as one-sigma effects when switchig on a given error soure. Several such error sources may be defined . (c)SetTauError()GetEmatrixSysTau() GetDeltaSysTau() A systematic error on the regularisation parameter tau . (d)SubtractBackground() GetEmatrixSysBackgroundUncorr()n.a. uncorrelated errors on background sources, originating from the errors provided with the background histograms . (e)SubtractBackground GetEmatrixSysBackgroundScale()GetDeltaSysBackgroundScale() scale errors on background sources . (i)SetInput() GetEmatrixInput()n.a.statistical uncertainty of the input (the measurement) . (i)+(d)+(e)see aboveGetEmatrix()n.a. Partial sun of uncertainties: all sources which are propagated to the covariance before unfolding . (i)+(a)+(b)+(c)+(d)+(e)see aboveGetEmatrixTotal() n.a.All known error sources summed up . Note: (a), (b), (c) are propagated to the result AFTER unfolding, whereas the background errors (d) and (e) are added to the data errors BEFORE unfolding. For this reason the errors of type (d) and (e) are INCLUDED in the standard error matrix and other meth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:3323,error,error,3323,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['error'],['error']
Availability,"ameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.94999999999999996, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitResult.html:8935,error,error,8935,root/html602/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitResult.html,4,['error'],['error']
Availability,"ameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatrix(TMatrixTSym<double>& mat) const; fill a correlation matrix elements using a generic symmetric matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitResult.html:8537,error,error,8537,root/html530/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html,5,['error'],['error']
Availability,"ameter values seen by Minuit (which are unbounded); 298and the external parameter values seen by the user in FCN (which remain; 299inside the desired limits). Therefore the internal error matrix kept by; 300Minuit must be transformed to an external error matrix for the user.; 301This is done by multiplying the (I,J)th element by DEXDIN(I)*DEXDIN(J),; 302where DEXDIN is the derivative of the external value with respect to the; 303internal value at the minimum. This is a linearisation of the; 304transformation, and is the only way to produce an error matrix in external; 305coordinates meaningful to the user. But when reporting the individual; 306parabolic errors for limited parameters, Minuit can do a little better, so; 307it does. In this case, Minuit actually transforms the ends of the; 308internal ""error bar"" to external coordinates and reports the length of; 309this transformed interval. Strictly speaking, it is now asymmetric, but; 310since the origin of the asymmetry is only an artificial transformation it; 311does not make much sense, so the transformed errors are symmetrized.; 312 ; 313The result of all the above is that for parameters with limits, the error; 314reported by Minuit is not exactly equal to the square root of the diagonal; 315element of the error matrix. The difference is a measure of how much the; 316limits deform the problem. If possible, it is suggested not to use limits; 317on parameters, and the problem goes away. If for some reason limits are; 318necessary, and you are sensitive to the difference between the two ways of; 319calculating the errors, it is suggested to use Minos errors which take; 320into account the non-linearities much more precisely.; 321 ; 322*/; 323 ; 324#include <cstdlib>; 325#include <cstdio>; 326 ; 327#include ""TROOT.h""; 328#include ""TList.h""; 329#include ""TMinuit.h""; 330#include ""TMath.h""; 331#include ""TError.h""; 332#include ""TPluginManager.h""; 333#include ""TClass.h""; 334 ; 335#include <atomic>; 336 ; 337TMinuit *gMin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:15419,error,errors,15419,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['errors']
Availability,"ameterState::isValid() and; MnUserParameterState::hasCovariance(); 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),; MnUserParameterState::nfcn(). 5.16 MnPrint.h; 5.16.1 operator\(<<\)(std::ostream&, const FunctionMinimum&); 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&). 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.1.1 \(\mbox{MIGRAD}\); 6.1.2 \(\mbox{MINIMIZE}\); 6.1.3 \(\mbox{SCAN}\); 6.1.4 \(\mbox{SIMPLEX}\). 6.2 Floating point precision; 6.3 Parameter limits; 6.3.1 Getting the Right Minimum with Limits; 6.3.2 Getting the right parameter errors with limits. 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.5.1 Statistical interpretation; 6.5.2 The reliability of M error estimates. 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.1.1 GaussFunction.h; 7.1.2 GaussFcn.h; 7.1.3 GaussFcn.cpp. 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Alt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:5178,error,errors,5178,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"ameters does not match existing one, create a new parameter setting list. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetMinosErrors(const vector<unsigned int>& paramInd); set parameter indeces for running Minos; this can be used for running Minos on a subset of parameters - otherwise is run on all of them; if MinosErrors() is set. void SetDefaultMinimizer(const char* type, const char* algo = 0). static function to control default minimizer type and algorithm. » Author: L. Moneta Thu Sep 21 16:21:29 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: FitConfig.h 29513 2009-07-17 15:30:07Z moneta $ » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitConfig.html:4516,error,error,4516,root/html528/ROOT__Fit__FitConfig.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitConfig.html,1,['error'],['error']
Availability,"ameters&, unsigned int); Constructor for high level parameters interface. Optional the strategy level in MnStrategy can be specified.; 5.6.3 MnMigrad(const FCNBase&, const MnUserParameterState&, const MnStrategy&); Constructor from a full state (parameters + covariance) as starting input plus the desired strategy.; 5.6.4 operator(); [api:migradop] MnMigrad::operator()(unsigned int maxfcn, double tolerance) causes minimization of the \(\mbox{FCN}\) and returns the result in form of a FunctionMinimum. The optional argument \(\mbox{maxfcn}\) specifies the (approximate) maximum number of function calls after which the calculation will be stopped even if it has not yet converged. The optional argument \(\mbox{tolerance}\) specifies the required tolerance on the function value at the minimum. The default \(\mbox{tolerance}\) value is \(0.1\), and the minimization will stop when the estimated vertical distance to the minimum (\(\mbox{EDM}\)) is less than \(0.001*\)\(\mbox{tolerance}\)\(*\)\(\mbox{up}\) (see [howto:errordef]).; 5.6.5 Parameter interaction; MnMigrad retains the result after each minimization (MnUserParameterStae, see [api:state]) and forwards the interface.; 5.6.6 VariableMetricMinimizer(); The VariableMetricMinimizer is instantiated using default constructor.; 5.6.7 minimize(const FCNBase&, …); The VariableMetricMinimizer provides several overloaded methods minimize with return value FunctionMinimum. Together with the user \(\mbox{FCN}\) (either an implementation of FCNBase or FCNGradientBase) the user has to give as input the parameters with starting values in one of the defined formats (std::vector\(<\)double\(>\), MnUserParameters or MnUserParameterState).; 5.7 MnMinimize and CombinedMinimizer; [api:minimize]; Causes minimization of the function by the method of \(\mbox{MIGRAD}\), as does the MnMigrad class, but switches to the \(\mbox{SIMPLEX}\) method if \(\mbox{MIGRAD}\) fails to converge. Constructor arguments, methods arguments and names of methods ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:49041,toler,tolerance,49041,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,8,"['error', 'toler']","['errordef', 'tolerance']"
Availability,"ameters, which is usually reliable unless warning"");; 3589 Printf("" messages are produced."");; 3590 Printf("" The optional argument [maxcalls] specifies the (approximate)"");; 3591 Printf("" maximum number of function calls after which the calculation"");; 3592 Printf("" will be stopped even if it has not yet converged."");; 3593 Printf("" The optional argument [tolerance] specifies required tolerance"");; 3594 Printf("" on the function value at the minimum."");; 3595 Printf("" The default tolerance is 0.1, and the minimization will stop"");; 3596 Printf("" when the estimated vertical distance to the minimum (EDM) is"");; 3597 Printf("" less than 0.001*[tolerance]*UP (see [SET ERRordef])."");; 3598 goto L99;; 3599 }; 3600//______________________________________________________________________________; 3601//; 3602// Command MINIMIZE; 3603//; 3604 if( !strncmp(comd.Data(),""MINI"",4) ) {; 3605 Printf("" ***>MINImize [maxcalls] [tolerance]"");; 3606 Printf("" Causes minimization of the function by the method of Migrad,"");; 3607 Printf("" as does the MIGrad command, but switches to the SIMplex method"");; 3608 Printf("" if Migrad fails to converge. Arguments are as for MIGrad."");; 3609 Printf("" Note that command requires four characters to be unambiguous."");; 3610 goto L99;; 3611 }; 3612//______________________________________________________________________________; 3613//; 3614// Command MINOS; 3615//; 3616 if( !strncmp(comd.Data(),""MIN0"",4) ) {; 3617 Printf("" ***>MINOs [maxcalls] [parno] [parno] ..."");; 3618 Printf("" Causes a Minos error analysis to be performed on the parameters"");; 3619 Printf("" whose numbers [parno] are specified. If none are specified,"");; 3620 Printf("" Minos errors are calculated for all variable parameters."");; 3621 Printf("" Minos errors may be expensive to calculate, but are very"");; 3622 Printf("" reliable since they take account of non-linearities in the"");; 3623 Printf("" problem as well as parameter correlations, and are in general"");; 3624 Printf("" asymmetric."");",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:116224,toler,tolerance,116224,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['toler'],['tolerance']
Availability,"ameters; �� Double_t; *fAmpCalcY1;�������������������� //[fNPeaks] array of calculated values of; amplitudes of 1D ridges in y direction, output parameters; �� Double_t; *fAmpErrY1;��������������������� //[fNPeaks] array of amplitudes errors of 1D; ridges in y direction, output parameters; �� Double_t; *fVolume;����������������������� //[fNPeaks] array of calculated volumes of 2D; peaks, output parameters; �� Double_t; *fVolumeErr;�������������������� //[fNPeaks] array of volumes errors of 2D; peaks, output parameters; �� Double_t�; fSigmaInitX;������������������� //initial value of sigma x parameter; �� Double_t�; fSigmaCalcX;������������������� //calculated value of sigma x parameter; �� Double_t�; fSigmaErrX;�������������������� //error value of sigma x parameter; �� Double_t�; fSigmaInitY;������������������� //initial value of sigma y parameter; �� Double_t�; fSigmaCalcY;������������������� //calculated value of sigma y parameter; �� Double_t�; fSigmaErrY;�������������������� //error value of sigma y parameter; �� Double_t�; fRoInit;����������������������� //initial value of correlation coefficient; �� Double_t�; fRoCalc;����������������������� //calculated value of correlation coefficient; �� Double_t�; fRoErr;������������������������ //error value of correlation coefficient; �� Double_t�; fTxyInit;���������������������� //initial value of t parameter for 2D peaks; (relative amplitude of tail), for details see html manual and references; �� Double_t�; fTxyCalc;���������������������� //calculated value of t parameter for 2D peaks; �� Double_t�; fTxyErr;����������������������� //error value of t parameter for 2D peaks; �� Double_t�; fSxyInit;���������������������� //initial value of s parameter for 2D peaks; (relative amplitude of step), for details see html manual and references; �� Double_t�; fSxyCalc;���������������������� //calculated value of s parameter for 2D peaks; �� Double_t�; fSxyErr;����������������������� //error value of s parameter for 2D peaks; ��",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Fit.html:43010,error,error,43010,root/html528/TSpectrum2Fit.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Fit.html,10,['error'],['error']
Availability,"ameters’ button opens a dialog for parameters settings, which will be explained later.; 5.6.2 Fitter Settings; ‘Method’ combo box currently provides only two fit model choices: Chi-square and Binned Likelihood. The default one is Chi-square. The Binned Likelihood is recommended for bins with low statistics.; ‘Linear Fit’ check button sets the use of Linear fitter when is selected. Otherwise the minimization is done by Minuit, i.e. fit option “F” is applied. The Linear fitter can be selected only for functions linear in parameters (for example - polN).; ‘Robust’ number entry sets the robust value when fitting graphs.; ‘No Chi-square’ check button switch On/Off the fit option “C” - do not calculate Chi-square (for Linear fitter).; ‘Integral’ check button switch On/Off the option “I” - use integral of function instead of value in bin center.; ‘Best Errors’ sets On/Off the option “E” - better errors estimation by using Minos technique.; ‘All weights = 1’ sets On/Off the option “W”- all weights set to 1 excluding empty bins; error bars ignored.; ‘Empty bins, weights=1’ sets On/Off the option “WW” - all weights equal to 1 including empty bins; error bars ignored.; ‘Use range’ sets On/Off the option “R” - fit only data within the specified function range. Sliders settings are used if this option is set to On. Users can change the function range values by pressing the left mouse button near to the left/right slider edges. It is possible to change both values simultaneously by pressing the left mouse button near to the slider center and moving it to a new position.; ‘Improve fit results’ sets On/Off the option “M”- after minimum is found, search for a new one.; ‘Add to list’ sets On/Off the option “+”- add function to the list without deleting the previous one. When fitting a histogram, the function is attached to the histogram’s list of functions. By default, the previously fitted function is deleted and replaced with the most recent one, so the list only contains one funct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:184872,error,error,184872,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability,"amevirtual const char * GetName() constReturns name of object.Definition TObject.cxx:444; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::FindObjectvirtual TObject * FindObject(const char *name) constMust be redefined in derived classes.Definition TObject.cxx:408; TObject::Classstatic TClass * Class(); TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::GetTitlevirtual const char * GetTitle() constReturns title of object.Definition TObject.cxx:488; TObject::IsAvirtual TClass * IsA() constDefinition TObject.h:243; TObject::lsvirtual void ls(Option_t *option="""") constThe ls function lists the contents of a class on stdout.Definition TObject.cxx:579; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TObject::Obsoletevoid Obsolete(const char *method, const char *asOfVers, const char *removedFromVers) constUse this method to declare a method obsolete.Definition TObject.cxx:1055; TRealDataThe TRealData class manages the effective list of all data members for a given class.Definition TRealData.h:30; TRealData::GetNameconst char * GetName() const overrideReturn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:267416,error,error,267416,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['error'],['error']
Availability,"amicPathName(const char* lib, Bool_t quiet = kFALSE); Find a dynamic library called lib using the system search paths.; Appends known extensions if needed. Returned string must be deleted; by the user!. const char * FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); Find a dynamic library using the system search paths. lib will be updated; to contain the absolute filename if found. Returns lib if found, or NULL; if a library called lib was not found.; This function does not open the library. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:35597,error,error,35597,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,4,['error'],['error']
Availability,"ample that there are more; 245unknowns than there are data points, or that the parameterisation of the; 246fit contains a linear dependence. If this is the case, then MINUIT (or any; 247other program) cannot solve your problem uniquely, and the error matrix; 248will necessarily be largely meaningless, so the user must remove the; 249under-determinedness by reformulating the parameterisation. MINUIT cannot; 250do this itself.; 251 ; 252##### Numerical inaccuracies:; 253 ; 254It is possible that the apparent lack of positive-definiteness is in fact; 255only due to excessive roundoff errors in numerical calculations in the; 256user function or not enough precision. This is unlikely in general, but; 257becomes more likely if the number of free parameters is very large, or if; 258 ; 259the parameters are badly scaled (not all of the same order of magnitude),; 260and correlations are also large. In any case, whether the; 261non-positive-definiteness is real or only numerical is largely irrelevant,; 262since in both cases the error matrix will be unreliable and the minimum; 263suspicious.; 264 ; 265##### An ill-posed problem:; 266 ; 267For questions of parameter dependence, see the discussion above on; 268positive-definiteness.; 269 ; 270Possible other mathematical problems are the following:; 271 ; 272##### Excessive numerical roundoff:; 273 ; 274Be especially careful of exponential and factorial functions which get big; 275very quickly and lose accuracy.; 276 ; 277##### Starting too far from the solution:; 278 ; 279The function may have unphysical local minima, especially at infinity in; 280some variables.; 281 ; 282##### Minuit parameter errors in the presence of limits; 283This concerns the way Minuit reports the symmetric (or parabolic) errors; 284on parameters. It does not apply to the errors reported from Minos, which; 285are in general asymmetric.; 286 ; 287The symmetric errors reported by Minuit are always calculated from; 288the covariance matrix, assuming that t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:12869,error,error,12869,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['error']
Availability,"ample: inspect the reader metrics after loading every entry**; 348 /// ~~~ {.cpp}; 349 /// #include <ROOT/RNTupleReader.hxx>; 350 /// using ROOT::Experimental::ENTupleInfo;; 351 /// using ROOT::Experimental::RNTupleReader;; 352 ///; 353 /// #include <iostream>; 354 ///; 355 /// auto ntuple = RNTupleReader::Open(""myNTuple"", ""some/file.root"");; 356 /// // metrics must be turned on beforehand; 357 /// ntuple->EnableMetrics();; 358 ///; 359 /// for (auto i : ntuple->GetEntryRange()) {; 360 /// ntuple->LoadEntry(i);; 361 /// }; 362 /// ntuple->PrintInfo(ENTupleInfo::kMetrics);; 363 /// ~~~; 364 void EnableMetrics() { fMetrics.Enable(); }; 365 const Detail::RNTupleMetrics &GetMetrics() const { return fMetrics; }; 366}; // class RNTupleReader; 367 ; 368} // namespace Experimental; 369} // namespace ROOT; 370 ; 371#endif // ROOT7_RNTupleReader; RConfig.hxx; R__unlikely#define R__unlikely(expr)Definition RConfig.hxx:586; RError.hxx; R__FAIL#define R__FAIL(msg)Short-hand to return an RResult<T> in an error state; the RError is implicitly converted into RResult...Definition RError.hxx:290; RNTupleDescriptor.hxx; RNTupleMetrics.hxx; RNTupleModel.hxx; RNTupleReadOptions.hxx; RNTupleUtil.hxx; RNTupleView.hxx; RPageStorage.hxx; RSpan.hxx; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; indexOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Experimental::Detail::RNTupleMetricsA collection of Counter objects with a name, a unit, and a description.Definition RNTupleMetrics.hxx:285; ROOT::Experimental::Detail::RNTupleMetrics::IsEnabledbool IsEnabled() constDefinition RNTupleMetrics.hxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleReader_8hxx_source.html:15522,error,error,15522,doc/master/RNTupleReader_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleReader_8hxx_source.html,1,['error'],['error']
Availability,"ampler. class TUnuranSampler: public ROOT::Math::DistSampler. Function Members (Methods); public:. virtual~TUnuranSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(); ROOT::Math::DistSamplerROOT::Math::DistSampler::DistSampler(const ROOT::Math::DistSampler&); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, ROOT::Fit::UnBinData& data); virtual boolROOT::Math::DistSampler::Generate(unsigned int nevt, const int* nbins, ROOT::Fit::BinData& data, bool extend = true); boolROOT::Math::DistSampler::Generate(unsigned int nevt, int nbins, double xmin, double xmax, ROOT::Fit::BinData& data, bool extend = true); virtual TRandom*GetRandom(); virtual boolInit(const char* algo = """"); virtual boolInit(const ROOT::Math::DistSamplerOptions& opt); unsigned intROOT::Math::DistSampler::NDim() const; TUnuranSampler&operator=(const TUnuranSampler&); const ROOT::Math::IMultiGenFunction&ROOT::Math::DistSampler::ParentPdf() const; virtual boolSample(double* x); virtual doubleSample1D(); virtual boolSampleBin(double prob, double& value, double* error = 0); virtual boolROOT::Math::DistSampler::SampleBins(unsigned int n, const double* prob, double* values, double* errors = 0); virtual voidSetArea(double area); virtual voidSetFunction(const ROOT::Math::IGenFunction& func); voidSetFunction(TF1* pdf); voidROOT::Math::DistSampler::SetFunction<const ROOT::Math::IBaseFunctionOneDim>(ROOT::Math::const IBaseFunctionOneDim& func, unsigned int dim); virtual voidSetMode(double mode); voidSetPrintLevel(int level); virtual voidSetRandom(TRandom* r); voidROOT::Math::DistSampler::SetRange(const ROOT::Fit::DataRange& range); voidROOT::Math::DistSampler::SetRange(const double* xmin, const double* xmax); voidROOT::Math::DistSampler::SetRange(double xmin, double xmax, int icoord = 0); virtual voidSetSeed(unsigned int seed); TUnuranSampler(); TUnuranSampler(const TUnuranSampler&). protected:. boolDoInit1D(const char* algo); boolDoInitDiscrete1D(const char* algo); boolDoInitND(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuranSampler.html:1355,error,error,1355,root/html602/TUnuranSampler.html,https://root.cern,https://root.cern/root/html602/TUnuranSampler.html,8,['error'],"['error', 'errors']"
Availability,"ams are filled:; histA: migration matrix from generator (x-axis) to detector (y-axis); the errors of histA are the uncorrelated systematic errors; histAsys1: alternative migration matrix, when systematic #1 is applied; histAsys1: alternative migration matrix, when systematic #2 is applied; histBgr: known background to the data, with errors. set up the unfolding:. TUnfoldSys unfold(histA,TUnfold::kHistMapOutputVert);; unfold.SetInput(input);; // this background has 5% scale uncertainty; unfold.SubtractBackground(histBgr1,""bgr1"",1.0,0.05);; // this background is scaled by 0.8 and has 10% scale uncertainty; unfold.SubtractBackground(histBgr2,""bgr2"",0.8,0.1);; unfold.AddSysError(histAsys1,""syserror1"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);; unfold.AddSysError(histAsys2,""syserror2"",TUnfold::kHistMapOutputVert,; TUnfoldSys::kSysErrModeMatrix);. run the unfolding: see description of class TUnfold; unfold.ScanLcurve( ...). retrieve the output; the errors include errors from input, from histBgr1 and from histBgr2; unfold.GetOutput(output);. retreive systematic shifts corresponding to correlated error sources; In the example, there are 4 correlated sources:; * 5% scale error on bgr1; * 10% scale error on bgr2; * the systematic error ""syserror1""; * the systematic error ""syserror2""; These error s are returned as vectors; (corresponding to one-sigma shifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:3651,error,errors,3651,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,8,['error'],['errors']
Availability,"ams); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); virtual voidEnableCursorWithoutFocus(Bool_t on = kTRUE); virtual voidEnableMenu(Bool_t on = kTRUE)TOGGLE GETTER ; virtual voidEnd(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFindAgain()SIGNAL ; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; TGViewFrame*TGView::GetCanvas() const; TGClient*TGObject::GetClient() const; const char*TGWidget::GetCommand() const; static Int_tTGWindow::GetCounter(); TGLongPositionGetCurrentPos() const; stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEdit.html:4813,Error,Error,4813,root/html602/TGTextEdit.html,https://root.cern,https://root.cern/root/html602/TGTextEdit.html,2,['Error'],['Error']
Availability,"ams;  list of limited parameters ;  ; double fChi2;  fit chi2 value (different than fval in case of chi2 fits) ;  ; std::vector< double > fCovMatrix;  covariance matrix (size is npar*(npar+1)/2) where npar is total parameters ;  ; int fCovStatus;  covariance matrix status code ;  ; double fEdm;  expected distance from minimum ;  ; std::vector< double > fErrors;  errors ;  ; std::shared_ptr< FitData > fFitData;  ! data set used in the fit ;  ; std::shared_ptr< IModelFunction > fFitFunc;  ! model function resulting from the fit. ;  ; std::map< unsigned int, bool > fFixedParams;  list of fixed parameters ;  ; std::vector< double > fGlobalCC;  global Correlation coefficient ;  ; std::shared_ptr< ROOT::Math::Minimizer > fMinimizer;  ! minimizer object used for fitting ;  ; std::string fMinimType;  string indicating type of minimizer ;  ; std::map< unsigned int, std::pair< double, double > > fMinosErrors;  map contains the two Minos errors ;  ; unsigned int fNCalls;  number of function calls ;  ; unsigned int fNdf;  number of degree of freedom ;  ; unsigned int fNFree;  number of fit free parameters (total parameters are in size of parameter vector) ;  ; bool fNormalized;  flag for indicating is errors are normalized ;  ; std::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunc;  ! objective function used for fitting ;  ; std::vector< std::pair< double, double > > fParamBounds;  parameter bounds ;  ; std::vector< double > fParams;  parameter values. Size is total number of parameters ;  ; std::vector< std::string > fParNames;  parameter names (only with FCN only fits, when fFitFunc=0) ;  ; int fStatus;  minimizer status code ;  ; double fVal;  minimum function value ;  ; bool fValid;  flag for indicating valid fit ;  . #include <TFitResult.h>. Inheritance diagram for TFitResult:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TFitResult() [1/3]. TFitResult::TFitResult ; (; int ; st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitResult.html:20662,error,errors,20662,doc/master/classTFitResult.html,https://root.cern,https://root.cern/doc/master/classTFitResult.html,2,['error'],['errors']
Availability,"ams;  list of limited parameters ;  ; double fChi2;  fit chi2 value (different than fval in case of chi2 fits) ;  ; std::vector< double > fCovMatrix;  covariance matrix (size is npar*(npar+1)/2) where npar is total parameters ;  ; int fCovStatus;  covariance matrix status code ;  ; double fEdm;  expected distance from minimum ;  ; std::vector< double > fErrors;  errors ;  ; std::shared_ptr< FitData > fFitData;  ! data set used in the fit ;  ; std::shared_ptr< IModelFunction > fFitFunc;  ! model function resulting from the fit. ;  ; std::map< unsigned int, bool > fFixedParams;  list of fixed parameters ;  ; std::vector< double > fGlobalCC;  global Correlation coefficient ;  ; std::shared_ptr< ROOT::Math::Minimizer > fMinimizer;  ! minimizer object used for fitting ;  ; std::string fMinimType;  string indicating type of minimizer ;  ; std::map< unsigned int, std::pair< double, double > > fMinosErrors;  map contains the two Minos errors ;  ; unsigned int fNCalls;  number of function calls ;  ; unsigned int fNdf;  number of degree of freedom ;  ; unsigned int fNFree;  number of fit free parameters (total parameters are in size of parameter vector) ;  ; bool fNormalized;  flag for indicating is errors are normalized ;  ; std::shared_ptr< ROOT::Math::IMultiGenFunction > fObjFunc;  ! objective function used for fitting ;  ; std::vector< std::pair< double, double > > fParamBounds;  parameter bounds ;  ; std::vector< double > fParams;  parameter values. Size is total number of parameters ;  ; std::vector< std::string > fParNames;  parameter names (only with FCN only fits, when fFitFunc=0) ;  ; int fStatus;  minimizer status code ;  ; double fVal;  minimum function value ;  ; bool fValid;  flag for indicating valid fit ;  . Friends; class Fitter;  . #include <Fit/FitResult.h>. Inheritance diagram for ROOT::Fit::FitResult:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ IModelFunction. typedef ROO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html:8992,error,errors,8992,doc/master/classROOT_1_1Fit_1_1FitResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1FitResult.html,2,['error'],['errors']
Availability,"an 1) the bin error of the projected histogram (obtained using this option ""W"") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable (TProfile2D::fSumw2[bin] ) . Definition at line 1287 of file TProfile2D.cxx. ◆ PutStats(). void TProfile2D::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimplemented from TH2.; Definition at line 1474 of file TProfile2D.cxx. ◆ Rebin2D(). TProfile2D * TProfile2D::Rebin2D ; (; Int_t ; nxgroup = 2, . Int_t ; nygroup = 2, . const char * ; newname = """" . ). overridevirtual . Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together. ; if newname is not blank a new profile hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to be merged into one bin of hnew If the original profile has errors stored (via Sumw2), the resulting profile has new errors correctly calculated.; examples: if hpxpy is an existing TProfile2D profile with 40 x 40 bins hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one; // Carefull: previous contents of hpxpy are lost; hpxpy->Rebin2D(3,5); // merges 3 bins along the xaxis and 5 bins along the yaxis in one; // Carefull: previous contents of hpxpy are lost; hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; TProfile2D *hnew = hpxpy->RebinY(5,""hnew""); // creates a new profile hnew; // merging 5 bins of hpxpy along the yaxis in one bin; TProfile2DProfile2D histograms are used to display the mean value of Z and its error for each cell in X,...Definition TProfile2D.h:27; TProfile2D::RebinYTProfile2D * RebinY(Int_t ngroup=2, const char *newname="""") overrideRebin only the Y axis.Definition TProfile2D.cxx:1845; NOTE : If nxgroup/nygroup is not an exact divider ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:98213,error,errors,98213,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,2,['error'],['errors']
Availability,"an and Fumili).; Refer to the guide for an introduction how Minuit works. ; Definition at line 54 of file Minuit2Minimizer.h. Public Member Functions;  Minuit2Minimizer (const char *type);  Constructor with a char (used by PM) ;  ;  Minuit2Minimizer (ROOT::Minuit2::EMinimizerType type=ROOT::Minuit2::kMigrad);  Default constructor. ;  ;  ~Minuit2Minimizer () override;  Destructor (no operations) ;  ; void Clear () override;  reset for consecutive minimization - implement if needed ;  ; bool Contour (unsigned int i, unsigned int j, unsigned int &npoints, double *xi, double *xj) override;  find the contour points (xi,xj) of the function for parameter i and j around the minimum The contour will be find for value of the function = Min + ErrorUp(); ;  ; double Correlation (unsigned int i, unsigned int j) const override;  return correlation coefficient between variable i and j. ;  ; double CovMatrix (unsigned int i, unsigned int j) const override;  return covariance matrix elements if the variable is fixed or const the value is zero The ordering of the variables is the same as in errors and parameter value. ;  ; int CovMatrixStatus () const override;  return the status of the covariance matrix status = -1 : not available (inversion failed or Hesse failed) status = 0 : available but not positive defined status = 1 : covariance only approximate status = 2 : full matrix but forced pos def status = 3 : full accurate matrix ;  ; double Edm () const override;  return expected distance reached from the minimum ;  ; const double * Errors () const override;  return errors at the minimum ;  ; bool FixVariable (unsigned int ivar) override;  fix an existing variable ;  ; bool GetCovMatrix (double *cov) const override;  Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. ;  ; bool GetHessianMatrix (double *h) const override;  Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:1777,error,errors,1777,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['error'],['errors']
Availability,"an be also used to reset the list of queries; waiting to be processed: for that purpose use ref == ""cleanupqueue"". Int_t Archive(Int_t query, const char* url); Send archive request for the qry-th query in fQueries. Int_t Archive(const char* queryref, const char* url = 0); Send archive request for the query specified by ref.; Generic method working for all queries known by the server.; If ref == ""Default"", path is understood as a default path for; archiving. Int_t CleanupSession(const char* sessiontag); Send cleanup request for the session specified by tag. void SetQueryMode(TProof::EQueryMode mode); Change query running mode to the one specified by 'mode'. Long64_t DrawSelect(TDSet* dset, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Execute the specified drawing action on a data set (TDSet).; Event- or Entry-lists should be set in the data set object using; TDSet::SetEntryList.; Returns -1 in case of error or number of selected events otherwise. Long64_t DrawSelect(const char* dsetname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Execute the specified drawing action on a data set which is stored on the; master with name 'dsetname'.; The syntax for dsetname is name[#[dir/]objname], e.g.; ""mydset"" analysis of the first tree in the top dir of the dataset; named ""mydset""; ""mydset#T"" analysis tree ""T"" in the top dir of the dataset; named ""mydset""; ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of the dataset; named ""mydset""; ""mydset#adir/"" analysis of the first tree in the dir ""adir"" of the; dataset named ""mydset""; The last argument 'enl' specifies an entry- or event-list to be used as; event selection.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void StopProcess(Bool_t abort, Int_t timeout = -1); Send STOPPROCESS message to master and workers. void Di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:51596,error,error,51596,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['error'],['error']
Availability,"an be found on the MINUIT Web Site and in particular at the following documentation page at http://www.cern.ch/minuit/doc/doc.html.; A detailed User Guide for Minuit2 exists, describing the API of the internal classes. ROOT uses Minuit2 for fitting via the Minuit2Minimizer class which implements the ROOT::Math::Minimizer interface.; Minuit2 is also distributed as an independent package of ROOT and can be built without any other dependency on the ROOT libraries.; Examples on how to use the Minuit2 and Fumili2 plug-ins are provided in the tutorials’ directory $ROOTSYS/tutorials/fit: minuit2FitBench.C, minuit2FitBench2D.C and minuit2GausFit.C. More information on the classes and functions present in Minuit2 is available at online reference documentation.; Useful information on MINUIT and minimization in general is provided in the following documents:; F. James, Minuit Tutorial on Function Minimization ( http://seal.cern.ch/documents/minuit/mntutorial.pdf); F. James, The Interpretation of Errors in Minuit ( http://seal.cern.ch/documents/minuit/mnerror.pdf);; 5.11 FUMILI Minimization Package; FUMILI is used to minimize Chi-square function or to search maximum of likelihood function. Experimentally measured values \(F_{i}\) are fitted with theoretical functions \(f_{i}(\vec{x_{i}},\vec{\theta})\), where \(\vec{x_{i}}\) are coordinates, and \(\vec{\theta}\) - vector of parameters. For better convergence Chi-square function has to be the following form; \[; \frac{\chi^2}{2} = \frac{1}{2} \sum_{i=1}^{n}; \left(\frac{f_{i}(\vec{x_{i}},\vec{\theta}) - F_{i}}; {\sigma_{i}}\right)^{2}; \]; where \(\sigma_{i}\) are errors of the measured function. The minimum condition is:; \[; \frac{\partial \chi^{2}}{\partial \theta_{i}} =; \sum_{j=1}^{n}; \frac{1}{\sigma_{j}^{2}} . \frac{\partial f_{i}}{\partial \theta_{i}}; \left[ (\vec{x_{j}},\vec{\theta}); - F_{j}\right] = 0, i = 1 ... m; \]; where \(m\) is the quantity of parameters. Expanding left part of this equation over parameter incre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:227026,Error,Errors,227026,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Error'],['Errors']
Availability,"an be set in the option string know options. ; general. RuleFitModule <string> available values are:; RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string> available values are:; Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used available values are:; ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees . Implements TMVA::MethodBase.; Definition at line 228 of file MethodRuleFit.cxx. ◆ DeclFileName(). static const char * TMVA::MethodRuleFit::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 210 of file MethodRuleFit.h. ◆ GetForest(). const std::vector< TMVA::DecisionTree * > & TMVA::MethodRuleFit::GetForest ; (; ); const. inline . Definition at line 92 of file MethodRuleFit.h. ◆ GetGDErrScale(). Double_t TMVA::MethodRuleFit::GetGDErrScale ; (; ); const. inline . Definition at line 105 of file MethodRuleFit.h. ◆ GetGDNPathSteps(). Int_t TMVA::MethodRuleFit::GetGDNPathSteps ; (; ); const. inline . Definition at li",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html:35439,avail,available,35439,doc/master/classTMVA_1_1MethodRuleFit.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodRuleFit.html,1,['avail'],['available']
Availability,"an be set in the option string; know options. general. RuleFitModule <string>; available values are: RFTMVA - use TMVA implementation; RFFriedman - use Friedmans original implementation. Path search (fitting). GDTau <float> gradient-directed path: fit threshhold, default; GDTauPrec <float> gradient-directed path: precision of estimated tau; GDStep <float> gradient-directed path: step size; GDNSteps <float> gradient-directed path: number of steps; GDErrScale <float> stop scan when error>scale*errmin. Tree generation. fEventsMin <float> minimum fraction of events in a splittable node; fEventsMax <float> maximum fraction of events in a splittable node; nTrees <float> number of trees in forest.; ForestType <string>; available values are: Random - create forest using random subsample and only random variables subset at each node; AdaBoost - create forest with boosted events. Model creation. RuleMinDist <float> min distance allowed between rules; MinImp <float> minimum rule importance accepted; Model <string> model to be used; available values are: ModRuleLinear <default>; ModRule; ModLinear. Friedmans module. RFWorkDir <string> directory where Friedmans module (rf_go.exe) is installed; RFNrules <int> maximum number of rules allowed; RFNendnodes <int> average number of end nodes in the forest of trees. void ProcessOptions(); process the options specified by the user. void InitMonitorNtuple(); initialize the monitoring ntuple. void Init(); default initialization. void InitEventSample( void ); write all Events from the Tree into a vector of Events, that are; more easily manipulated.; This method should never be called without existing trainingTree, as it; the vector of events from the ROOT training tree. void Train( void ). void TrainTMVARuleFit( void ); training of rules using TMVA implementation. void TrainJFRuleFit( void ); training of rules using Jerome Friedmans implementation. const TMVA::Ranking* CreateRanking(); computes ranking of input variables. void AddWeightsXML",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodRuleFit.html:20751,avail,available,20751,root/html528/TMVA__MethodRuleFit.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodRuleFit.html,10,['avail'],['available']
Availability,"an be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProfile2D histogram. Making a 5D plot using GL; If option GL5D is specified together with 5 variables, a 5D plot is drawn using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot; In case of a 2-Dim or more expression with the option=para, one can generate a parallel co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:128443,error,error,128443,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['error'],['error']
Availability,"an be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; 255 double x[] = {0, 1, 2, 3, 4};; 256 double y[] = {0, 2, 4, 1, 3};; 257 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 258 double ey[] = {1, 0.5, 1, 0.5, 1};; 259 auto ge = new TGraphErrors(5, x, y, ex, ey);; 260 ge->SetTitle(""A graph with errors"");; 261 ge->Draw(""ap"");; 262}; 263End_Macro; 264 ; 265The option ""0"" shows the error bars for data points outside range.; 266 ; 267Begin_Macro(source); 268{; 269 auto c48 = new TCanvas(""c48"",""c48"",200,10,600,400);; 270 float x[] = {1,2,3};; 271 float err_x[] = {0,0,0};; 272 float err_y[] = {5,5,5};; 273 float y[] = {1,4,9};; 274 auto tg = new TGraphErrors(3,x,y,err_x,err_y);; 275 c48->Divide(2,1);; 276 c48->cd(1); gPad->DrawFrame(0,0,4,8); tg->Draw(""PC"");; 277 c48->cd(2); gPad->DrawFrame(0,0,4,8); tg->Draw(""0PC"");; 278}; 279End_Macro; 280 ; 281The option ""3"" shows the errors as a band.; 282 ; 283Begin_Macro(source); 284{; 285 auto c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; 286 double x[] = {0, 1, 2, 3, 4};; 287 double y[] = {0, 2, 4, 1, 3};; 288 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:10607,error,errors,10607,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"an create a TF1 object as TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; For such a TF1 you don't have to set the initial conditions and the linear fitter is used. Going via the linear fitter for functions, linear in parameters, gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option ROB. See the tutorial fitLinearRobust.C. Notes on TGraph/TGraphErrors Fitting:. By using the ""effective variance"" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.; The effective variance technique assumes that there is no correlation between the x and y coordinate.; The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option ""EX0""; The linear fitter doesn't take into account the errors in x. When fitting a TGraphErrors with a linear functions the errors in x will not be considered. If errors in x are important, use option ""F"" for linear function fitting.; When fitting a TGraph (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: parameter_error *= sqrt(chisquare/(ndf-1)). General Fitting documentation; See in TH1::Fit for the documentation of; Fit Result; Fit Status; Fit Statistics Box; Fitting in a Range; Setting Initial Conditions . Definition at line 1231 of file TGraph.cxx. ◆ FitPanel(). void TGraph::FitPanel ; (; ). virtual . Display a GUI panel with all graph fit options. ; See class TFitEditor for example ; Definition at line 1274 of file TGraph.cxx. ◆ GetCorrelationFactor(). Double_t TGraph::GetCorrelationFactor ; (; ); const. virtual . Return graph correlation factor. ; Definition at line 1296 of file TGraph.cxx. ◆ GetCovariance(). Double_t TGraph::GetCovariance ; (; ); const. virtual . Return covariance of vectors x,y. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:52281,error,errors,52281,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['error'],['errors']
Availability,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If option = ""par"", create a PAR file with the minimal set of code needed to read the content; of the ROOT file. The name of the PAR file is basename(dirname), with extension; '.par' enforced; the PAR file will be created at dirname(dirname) .; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFile.html:42634,error,error,42634,root/html532/TFile.html,https://root.cern,https://root.cern/root/html532/TFile.html,4,['error'],['error']
Availability,"an include file; for each class in the StreamerInfo list for which a TClass; object does not exist. The code generated includes:; dirnameProjectHeaders.h // contains one #include statement per generated header file; dirnameProjectSource.cxx // contains all the constructors and destructors implementation.; and one header per class that is not nested inside another class.; The header file name is the fully qualified name of the class after all the special characters; ""<>,:"" are replaced by underscored. For example for pair<edm::Vertex,int> the file name is; pair_edm__Vertex_int_.h. In the generated classes, map, multimap when the first template parameter is a class; are replaced by a vector of pair. set and multiset when the tempalte parameter; is a class are replaced by a vector. This is required since we do not have the; code needed to order and/or compare the object of the classes. If option = ""new"" (default) a new directory dirname is created.; If dirname already exist, an error message is printed; and the function returns.; If option = ""recreate"", then;; if dirname does not exist, it is created (like in ""new""); if dirname already exist, all existing files in dirname; are deleted before creating the new files.; If option = ""update"", then new classes are added to the existing directory.; Existing classes with the same name are replaced by the; new definition. If the directory dirname doest not exist,; same effect as ""new"".; If option = ""genreflex"", then use genreflex rather than rootcint to generate; the dictionary.; If, in addition to one of the 3 above options, the option ""+"" is specified,; the function will generate:; - a script called MAKEP to build the shared lib; - a dirnameLinkDef.h file; - rootcint will be run to generate a dirnameProjectDict.cxx file; - dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; - a shared lib dirname.so will be created.; If the option ""++"" is specified, the generated shared lib is dynamically; linke",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:40533,error,error,40533,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,2,['error'],['error']
Availability,"an nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:36182,error,error,36182,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,2,['error'],['error']
Availability,"an not be created the kZombie; bit will be set in the TDCacheFile object. Use IsZombie() to see if the; file is accessable. For a description of the option and other arguments; see the TFile ctor. The preferred interface to this constructor is; via TFile::Open(). ~TDCacheFile(); Close and cleanup dCache file. Bool_t ReadBuffer(char* buf, Int_t len); Read specified byte range from remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure. Bool_t WriteBuffer(const char* buf, Int_t len); Write specified byte range to remote file via dCache daemon.; Returns kTRUE in case of error. Bool_t Stage(const char* path, UInt_t secs, const char* location = 0); Stage() returns kTRUE on success and kFALSE on failure. Bool_t CheckFile(const char* path, const char* location = 0); CheckFile() returns kTRUE on success and kFALSE on failure. In; case the file exists but is not cached, CheckFile() returns; kFALSE and errno is set to EAGAIN. void SetOpenTimeout(UInt_t secs); Set file open timeout. void SetOnError(TDCacheFile::OnErrorAction = kOnErrorDefault); Set on error handler. void SetReplyHostName(const char* host_name); Set reply host name. const char * GetDcapVersion(); Return dCache version string. Int_t SysOpen(const char* pathname, Int_t flags, UInt_t mode); Interface to system open. All arguments like in POSIX open. Int_t SysClose(Int_t fd); Interface to system close. All arguments like in POSIX close. Int_t SysRead(Int_t fd, void* buf, Int_t len); Interface to system read. All arguments like in POSIX read. Int_t SysWrite(Int_t fd, const void* buf, Int_t len); Interface to system write. All arguments like in POSIX write. Long64_t S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TDCacheFile.html:23655,failure,failure,23655,root/html526/TDCacheFile.html,https://root.cern,https://root.cern/root/html526/TDCacheFile.html,1,['failure'],['failure']
Availability,"an take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]variationTagsnames for each of the varied values, e.g. ""up"" and ""down"". ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". This overload of Vary takes a list of column names as first argument and requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each affected column. The variationTags are defined as {""down"", ""up""}.; Example usage: // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; auto nominal_hx =; df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; {""down"", ""up""}, // variation tags; ""ptAndEta"") // variation name; .Histo1D(""pt"", ""eta"");; ; auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; hx[""nominal""].Draw();; hx[""ptAndEta:down""].Draw(""SAME"");; hx[""ptAndEta:up""].Draw(""SAME"");; ROOT::RDF::RInterface::Histo1DRResultPtr<::TH1D > Histo1D(const TH1DModel &model={"""", """", 128u, 0., 0.}, std::string_view vName="""")Fill and return a one-dimensional histogram with the values of a column (lazy action).Definition RInterface.hxx:1804; ptTPaveText * ptDefinition entrylist_figure1.C:7; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; See alsoThis Vary() overload for more information. ; Definition at line 950 of file RInterface.hxx. ◆ Vary() [2/11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Prox",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:138076,down,down,138076,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['down'],['down']
Availability,"an write in this case; directly:; Int_t fitStatus = h->Fit(myFunc). If the option ""S"" is instead used, TFitResultPtr contains the TFitResult and behaves; as a smart pointer to it. For example one can do:; TFitResultPtr r = h->Fit(myFunc,""S"");; TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; Double_t chi2 = r->Chi2(); // to retrieve the fit chi2; Double_t par0 = r->Value(0); // retrieve the value for the parameter 0; Double_t err0 = r->Error(0); // retrieve the error for the parameter 0; r->Print(""V""); // print full information of fit including covariance matrix; r->Write(); // store the result in a file. The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; from the fitted function.; If the histogram is made persistent, the list of; associated functions is also persistent. Given a pointer (see above); to an associated function myfunc, one can retrieve the function/fit; parameters with calls such as:; Double_t chi2 = myfunc->GetChisquare();; Double_t par0 = myfunc->GetParameter(0); //value of 1st parameter; Double_t err0 = myfunc->GetParError(0); //error on first parameter. Access to the fit status. The status of the fit can be obtained converting the TFitResultPtr to an integer; indipendently if the fit option ""S"" is used or not:; TFitResultPtr r = h=>Fit(myFunc,opt);; Int_t fitStatus = r;. The fitStatus is 0 if the fit is OK (i.e. no error occurred).; The value of the fit status code is negative in case of an error not connected with the; minimization procedure, for example when a wrong function is used.; Otherwise the return value is the one returned from the minimization procedure.; When TMinuit (default case) or Minuit2 are used as minimizer the status returned is :; fitStatus = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult.; TMinuit will return 0 (for migrad, minos, hesse or improve) in case of success and 4 in; case of error (see the documentation of TMinuit::mnexcm). So for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:28550,error,error,28550,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,4,['error'],['error']
Availability,"an(unsigned int ipar, TGraph *gr, double xmin, double xmax); 94{; 95 if (!gr); 96 return false;; 97 ; 98 unsigned int npoints = gr->GetN();; 99 if (npoints == 0) {; 100 npoints = 40;; 101 gr->Set(npoints);; 102 }; 103 bool ret = ROOT::Fit::FitResult::Scan(ipar, npoints, gr->GetX(), gr->GetY(), xmin, xmax);; 104 if ((int)npoints < gr->GetN()); 105 gr->Set(npoints);; 106 return ret;; 107}; 108 ; 109////////////////////////////////////////////////////////////////////////////////; 110/// Create a 2D contour around the minimum for the parameter ipar and jpar; 111/// if a minimum does not exist or is invalid it will return false; 112/// on exit a TGraph is filled with the contour points; 113/// the number of contour points is determined by the size of the TGraph.; 114/// if the size is zero a default number of points = 20 is used; 115/// pass optionally the confidence level, default is 0.683; 116/// it is assumed that ErrorDef() defines the right error definition; 117/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 118 ; 119bool TFitResult::Contour(unsigned int ipar, unsigned int jpar, TGraph *gr, double confLevel); 120{; 121 if (!gr); 122 return false;; 123 ; 124 unsigned int npoints = gr->GetN();; 125 if (npoints == 0) {; 126 npoints = 40;; 127 gr->Set(npoints);; 128 }; 129 bool ret = ROOT::Fit::FitResult::Contour(ipar, jpar, npoints, gr->GetX(), gr->GetY(), confLevel);; 130 if ((int)npoints < gr->GetN()); 131 gr->Set(npoints);; 132 ; 133 return ret;; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Print the TFitResult.; 138 ; 139std::string cling::printValue(const TFitResult* val); 140{; 141 std::stringstream outs;; 142 val->ROOT::Fit::FitResult::Print(outs, false /*doCovMat*/);; 143 return outs.str();; 144}; f#define f(i)Definition RSha256.hxx:104; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TFitResult.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFitResult_8cxx_source.html:4605,error,error,4605,doc/master/TFitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFitResult_8cxx_source.html,1,['error'],['error']
Availability,"anDataSet(const char* uri, const char* opt); Scans the dataset indicated by 'uri' following the 'opts' directives. The 'opts' string contains up to 4 directive fields separated by ':'. 'selection' field :; A, allfiles: process all files; D, staged: process only staged (on Disk) files (if 'allfiles:' is not specified; the default is to process only files marked as non-staged); 'pre-action field':; O, open: open the files marked as staged when processing only files; marked as non-staged; T, touch: open and touch the files marked as staged when processing; only files marked as non-staged; I, nostagedcheck: do not check the actual stage status on selected files. 'process' field:; N, noaction: do nothing on the selected files; P, fullproc: open the selected files and extract the meta information; L, locateonly: only locate the selected files; S, stageonly: issue a stage request for the selected files not yet staged. 'auxilliary' field; V, verbose: notify the actions. Returns 0 on success, -1 if any failure occurs. Int_t ScanDataSet(const char* uri, UInt_t option = kReopen|kDebug); Scans the dataset indicated by <uri> and returns the number of missing files.; Returns -1 if any failure occurs.; For more details, see documentation of; ScanDataSet(TFileCollection *dataset, const char *option). void GetQuota(const char* group, const char* user, const char* dsName, TFileCollection* dataset). Gets quota information from this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:12801,failure,failure,12801,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,4,['failure'],['failure']
Availability,"anSol(TGeoBatemanSol* sol, Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawCurrentPoint(Int_t color); virtual voidDrawOnly(Option_t* option = """"); virtual voidDrawOverlap(void* ovlp, Option_t* option = """"); virtual voidDrawPanel(); virtual voidDrawPath(const char* path, Option_t* option = """"); virtual voidDrawPolygon(const TGeoPolygon* poly); virtual voidDrawShape(TGeoShape* shape, Option_t* option = """"); virtual voidDrawVolume(TGeoVolume* vol, Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidEditGeometry(Option_t* option = """"); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidEstimateCameraMove(Double_t tmin, Double_t tmax, Double_t* start, Double_t* end); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteManagerEvent(TGeoManager* geom, Int_t event, Int_t px, Int_t py); virtual voidExecuteShapeEvent(TGeoShape* shape, Int_t event, Int_t px, Int_t py); virtual voidExecuteVolumeEvent(TGeoVolume* volume, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVirtualGeoPainter*TVirtualGeoPainter::GeoPainter(); virtual voidGetBombFactors(Double_t& bombx, Double_t& bomby, Double_t& bombz, Double_t& bombr) const; virtual Int_tGetBombMode() const; virtual TGeoNode*GetCheckedNode(); TGeoChecker*GetChecker(); virtual Int_tGetColor(Int_t base, Float_t light) const; virtual TGeoVolume*GetDrawnVolume() const; virtual Option_t*TObject::GetDrawOption() const; virtual const char*GetDrawPath() const; static Long_tTObject::GetDto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPainter.html:3354,error,error,3354,root/html534/TGeoPainter.html,https://root.cern,https://root.cern/root/html534/TGeoPainter.html,6,['error'],['error']
Availability,"analysis.C. The main features of this facility are:. * on-demand loading of branches; * ability to use the 'branchname' as if it was a data member; * protection against array out-of-bound; * ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram. In case of a 2-Dim expression, one can generate a TProfile histogram; instead of a TH2F histogram by specyfying option=prof or option=profs.; The option=prof is automatically selected in case of y:x>>pf; where pf is an existing TProfile histogram. Making a 5D plot using GL. If option GL5D is specified together with 5 variables, a 5D plot is drawn; using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example. Making a parallel coordinates plot. In case of a 2-Dim or more expression with the option=para, one can generate; a parallel coordinates plot. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Making a candle sticks chart. In case of a 2-Dim or more expression with the option=candle, one can generate; a candle sticks chart. With that option, the number of dimensions is; arbitrary. Giving more than 4 variables without the option=para or; option=candle or option=goff will produce an error. Saving the result of Draw to a TEventList or a TEntryList. TTree::Draw can be used to fill a TEventList object (list of entry numbers); instead of histogramming one variable.; If varexp0 has the form >>elist , a TEventList object named ""elist""; is created in the current directory. elist will contain the list; of entry numbers satisfying the current selection.; If option ""entrylist"" is used, a TEntryList object is created; Example:; tree.Draw("">>yplus"",""y>0""); will create a TEventList object named ""yplus"" in the current directory.; In an interactive session, one can type (after TTree::Draw); yplus.Print(""all""); to print the list of entry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:77175,error,error,77175,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['error'],['error']
Availability,"ance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou own the retured pointer. ; Definition at line 749 of file Factory.cxx. ◆ GetROC() [2/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TString ; datasetname, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). private . Private method to generate a ROCCurve instance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou own the retured pointer. ; Definition at line 762 of file Factory.cxx. ◆ GetROCCurve() [1/4]. TGraph * TMVA::Factory::GetROCCurve ; (; DataLoader * ; loader, . TString ; theMethodName, . Bool_t ; setTitles = kTRUE, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ; It is ignored for binary classification.; Returns a ROC graph for a given method, or nullptr on error.; Note: Evaluation of the given method must have been run prior to ROC generation through Factory::EvaluateAllMetods.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 912 of file Factory.cxx. ◆ GetROCCurve() [2/4]. TCanvas * TMVA::Factory::GetROCCurve ; (; TMVA::DataLoader * ; loader, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Draws ROC curves for all methods booked with the factory for a given class onto a canvas. ; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:26763,error,error,26763,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['error'],['error']
Availability,"ance&); 5.15.4 parameters(); 5.15.5 covariance(); 5.15.6 globalCC(); 5.15.7 MnUserParameterState::isValid() and; MnUserParameterState::hasCovariance(); 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),; MnUserParameterState::nfcn(). 5.16 MnPrint.h; 5.16.1 operator\(<<\)(std::ostream&, const FunctionMinimum&); 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&). 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.1.1 \(\mbox{MIGRAD}\); 6.1.2 \(\mbox{MINIMIZE}\); 6.1.3 \(\mbox{SCAN}\); 6.1.4 \(\mbox{SIMPLEX}\). 6.2 Floating point precision; 6.3 Parameter limits; 6.3.1 Getting the Right Minimum with Limits; 6.3.2 Getting the right parameter errors with limits. 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.5.1 Statistical interpretation; 6.5.2 The reliability of M error estimates. 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.1.1 GaussFunction.h; 7.1.2 GaussFcn.h; 7.1.3 GaussFcn.cpp. 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require gu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:5089,error,errors,5089,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"ance; Inherited Members; Includes; Libraries. Function documentation; MethodFDA(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); standard constructor. MethodFDA(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::ve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFDA.html:19945,avail,availabel,19945,root/html602/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFDA.html,4,['avail'],['availabel']
Availability,"ance; Inherited Members; Includes; Libraries. Function documentation; TProofMgrLite(const char* url, Int_t loglevel = -1, const char* alias = """"); Create a PROOF manager for the Lite environment. TProof * CreateSession(const char* = 0, const char* = 0, Int_t = -1); Create a new session. TProofLog * GetSessionLogs(Int_t ridx = 0, const char* stag = 0, const char* pattern = ""-v | SvcMsg"", Bool_t rescan = kFALSE); Get logs or log tails from last session associated with this manager; instance.; The arguments allow to specify a session different from the last one:; isess specifies a position relative to the last one, i.e. 1; for the next to last session; the absolute value is taken; so -1 and 1 are equivalent.; stag specifies the unique tag of the wanted session; The special value stag = ""NR"" allows to just initialize the TProofLog; object w/o retrieving the files; this may be useful when the number; of workers is large and only a subset of logs is required.; If 'stag' is specified 'isess' is ignored (unless stag = ""NR"").; If 'pattern' is specified only the lines containing it are retrieved; (remote grep functionality); to filter out a pattern 'pat' use; pattern = ""-v pat"".; Returns a TProofLog object (to be deleted by the caller) on success,; 0 if something wrong happened. TObjString * ReadBuffer(const char* file, Long64_t ofs, Int_t len); Read 'len' bytes from offset 'ofs' of the local file 'fin'.; Returns a TObjString with the content or 0, in case of failure. TObjString * ReadBuffer(const char* file, const char* pattern); Read lines containing 'pattern' in 'file'.; Returns a TObjString with the content or 0, in case of failure. virtual ~TProofMgrLite(); { }. » Author: G. Ganis, Apr 2008 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofMgrLite.html:10621,failure,failure,10621,root/html534/TProofMgrLite.html,https://root.cern,https://root.cern/root/html534/TProofMgrLite.html,4,['failure'],['failure']
Availability,"ance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. { fPOI.removeAll(); fPOI.add(set); }. void SetNuisanceParameters(const RooArgSet& set); specify the nuisance parameters (eg. the rest of the parameters). {fNuisanceParameters.removeAll(); fNuisanceParameters.add(set);}. void SetPriorPdf(RooAbsPdf& pdf); Set only the Prior Pdf. { fPriorPdf = &pdf; }. void SetConditionalObservables(const RooArgSet& set); set the conditional observables which will be used when creating the NLL; so the pdf's will not be normalized on the conditional observables when computing the NLL. {fConditionalObs.removeAll(); fConditionalObs.add(set);}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__BayesianCalculator.html:16907,error,error,16907,root/html534/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html534/RooStats__BayesianCalculator.html,6,['error'],['error']
Availability,"ancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDivide(const TH1* h1); virtual voidDivide(TF1* h1, Double_t c1 = 1); virtual voidDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t x, Double_t y); virtual Int_tFill(const char* namex, Double_t y); virtual Int_tFill(Double_t x, Double_t y, Double_t w); virtual Int_tFill(const char* namex, Double_t y, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH1::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH1::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tTH1::FindBin(Double_t x, Double_t y = 0, Double_t z = 0); virtual Int_tTH1::FindFirstBinAbove(Double_t threshold = 0, Int_t axis = 1) const; virtual Int_tTH1::FindFixBin(Double_t x, Double_t y = 0, Double_t z = 0) const; virtual Int_tTH1::FindLastBinAbove(Double_t threshold = 0, Int_t axis = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:5092,error,error,5092,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,4,['error'],['error']
Availability,"ancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDivide(const TH1* h1); virtual voidDivide(TF1* h1, Double_t c1 = 1); virtual voidDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z); virtual Int_tFill(Double_t x, const char* namey, Double_t z); virtual Int_tFill(const char* namex, Double_t y, Double_t z); virtual Int_tFill(const char* namex, const char* namey, Double_t z); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH2::FillN(Int_t, const Double_t*, const Double_t*, Int_t); virtual voidTH2::FillN(Int_t ntimes, const Double_t* x, const Double_t* y, const Double_t* w, Int_t stride = 1); virtual voidTH2::FillRandom(const char* fname, Int_t ntimes = 5000); virtual voidTH2::FillRandom(TH1* h, Int_t ntimes = 5000); virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:5229,error,error,5229,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,4,['error'],['error']
Availability,"ancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTH1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDivide(const TH1* h1); virtual voidDivide(TF1* h1, Double_t c1 = 1); virtual voidDivide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """")MENU ; virtual voidTH1::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual TH1*DrawCopy(Option_t* option = """") const; virtual TH1*TH1::DrawNormalized(Option_t* option = """", Double_t norm = 1) const; virtual voidTH1::DrawPanel()MENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTH1::Eval(TF1* f1, Option_t* option = """"); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTH1::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TH1*TH1::FFT(TH1* h_output, Option_t* option); virtual Int_tFill(Double_t); virtual Int_tFill(const char*, Double_t); virtual Int_tFill(Double_t, Double_t); virtual Int_tFill(Double_t, Double_t, Double_t); virtual Int_tFill(const char*, const char*, const char*, Double_t); virtual Int_tFill(const char*, Double_t, const char*, Double_t); virtual Int_tFill(const char*, const char*, Double_t, Double_t); virtual Int_tFill(Double_t, const char*, const char*, Double_t); virtual Int_tFill(Double_t, const char*, Double_t, Double_t); virtual Int_tFill(Double_t, Double_t, const char*, Double_t); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t t); virtual Int_tFill(Double_t x, Double_t y, Double_t z, Double_t t, Double_t w); virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTH1::FillN(Int_t ntimes, const Double_t* x, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile3D.html:4901,error,error,4901,root/html528/TProfile3D.html,https://root.cern,https://root.cern/root/html528/TProfile3D.html,4,['error'],['error']
Availability,"anch (whose implementation; 2344/// has been moved to BranchOld).; 2345///; 2346/// NOTE: The 'Bronch' method supports only one possible calls; 2347/// signature (where the object type has to be specified; 2348/// explicitly and the address must be the address of a pointer).; 2349/// For more flexibility use 'Branch'. Use Bronch only in (rare); 2350/// cases (likely to be legacy cases) where both the new and old; 2351/// implementation of Branch needs to be used at the same time.; 2352///; 2353/// This function is far more powerful than the old Branch; 2354/// function. It supports the full C++, including STL and has; 2355/// the same behaviour in split or non-split mode. classname does; 2356/// not have to derive from TObject. The function is based on; 2357/// the new TStreamerInfo.; 2358///; 2359/// Build a TBranchElement for an object of class classname.; 2360///; 2361/// addr is the address of a pointer to an object of class; 2362/// classname. The class dictionary must be available (ClassDef; 2363/// in class header).; 2364///; 2365/// Note: See the comments in TBranchElement::SetAddress() for a more; 2366/// detailed discussion of the meaning of the addr parameter.; 2367///; 2368/// This option requires access to the library where the; 2369/// corresponding class is defined. Accessing one single data; 2370/// member in the object implies reading the full object.; 2371///; 2372/// By default the branch buffers are stored in the same file as the Tree.; 2373/// use TBranch::SetFile to specify a different file; 2374///; 2375/// IMPORTANT NOTE about branch names:; 2376///; 2377/// And in general, in case two or more master branches contain subbranches; 2378/// with identical names, one must add a ""."" (dot) character at the end; 2379/// of the master branch name. This will force the name of the subbranches; 2380/// to be of the form `master.subbranch` instead of simply `subbranch`.; 2381/// This situation happens when the top level object; 2382/// has two or more me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:93539,avail,available,93539,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['avail'],['available']
Availability,"anches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:41540,error,errors,41540,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,2,['error'],['errors']
Availability,"and ""kExport"" are mutually exclusive; NB2: for options ""kPrint"" and ""kQuoatUpdate"" return is null. Int_t FillLsDataSet(const char* group, const char* user, const char* dsName, TList* out, UInt_t option); Check for the 'ls.txt' for 'group' and 'user' and fill the path for the; ls file in 'out'.; If 'dsname' is defined, open the file and extract the relevant line.; Return 0 on success, -1 on failure. TFileCollection * GetDataSet(const char* group, const char* user, const char* dsName, UInt_t option = 0, TMD5** checksum = 0). Returns the dataset <dsName> of user <user> in group <group> .; If checksum is non-zero, it will contain the pointer to a TMD5 sum object; with the checksum of the file, has to be deleted by the user.; If option has the bi kReadShort set, the shortobject is read, that does not; contain the list of files. This is much faster. Int_t CheckLocalCache(const char* group, const char* user, const char* dsName = ""ls"", UInt_t option = 0); Check if the local cache information for group, user, dsName is up-to-date; If not, make the relevant updates; Return 0 if OK, 1 if the dataset does not exists anymore, -1 on failure. Int_t ClearCache(const char* uri = 0); Clear cached information matching uri. Int_t ShowCache(const char* uri = 0); Show cached information matching uri. Int_t WriteDataSet(const char* group, const char* user, const char* dsName, TFileCollection* dataset, UInt_t option = 0, TMD5* checksum = 0). Writes indicated dataset.; If option has the bit kFileMustExist set, the file must still exist,; otherwise the new dataset is not written (returns 3 in this case).; If checksum is non-zero the files current checksum is checked against it,; if it does not match the file is not written (the function returns 2 in this; case, if the file has disappeared it is also not written (i.e. checksum; implies the bit kFileMustExist set in option).; Returns != 0 for success, 0 for error. Int_t ChecksumDataSet(const char* path, const char* md5path, TString& checksum);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:16410,failure,failure,16410,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,10,['failure'],['failure']
Availability,"and -1 in case of error. ; Reimplemented from TProof.; Definition at line 1539 of file TProofLite.cxx. ◆ MakeQueryResult(). TProofQueryResult * TProofLite::MakeQueryResult ; (; Long64_t ; nent, . const char * ; opt, . Long64_t ; fst, . TDSet * ; dset, . const char * ; selec . ). protected . Create a TProofQueryResult instance for this query. ; Definition at line 1000 of file TProofLite.cxx. ◆ NotifyStartUp(). void TProofLite::NotifyStartUp ; (; const char * ; action, . Int_t ; done, . Int_t ; tot . ). private . Notify setting-up operation message. ; Definition at line 667 of file TProofLite.cxx. ◆ operator=(). void TProofLite::operator= ; (; const TProofLite & ; ). private . ◆ PollForNewWorkers(). Int_t TProofLite::PollForNewWorkers ; (; ). overrideprotectedvirtual . Simulate dynamic addition, for test purposes. ; Here we decide how many workers to add, we create them and set the environment. This call is called regularly by Collect if the opton is enabled. Returns the number of new workers added, or <0 on errors. ; Reimplemented from TProof.; Definition at line 2528 of file TProofLite.cxx. ◆ Print(). void TProofLite::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print status of PROOF-Lite cluster. ; Reimplemented from TProof.; Definition at line 949 of file TProofLite.cxx. ◆ Process() [1/8]. Long64_t TProofLite::Process ; (; const char * ; dsetname, . const char * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0, . TObject * ; elist = 0 . ). inlineoverridevirtual . Process a dataset which is stored on the master with name 'dsetname'. ; The syntax for dsetname is name[#[dir/]objname], e.g. ""mydset"" analysis of the first tree in the top dir of the dataset named ""mydset"" ""mydset#T"" analysis tree ""T"" in the top dir of the dataset named ""mydset"" ""mydset#adir/T"" analysis tree ""T"" in the dir ""adir"" of the dataset named ""mydset"" ""mydset#adir/"" analysis of the first tree in the dir ""adir"" of the dataset named ""mydse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:56068,error,errors,56068,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['error'],['errors']
Availability,"and 1D ridges. . positionX - gets vector of x positions of 2D peaks; positionY - gets vector of y positions of 2D peaks; positionX1 - gets vector of x positions of 1D ridges; positionY1 - gets vector of y positions of 1D ridges . Definition at line 5708 of file TSpectrum2Fit.cxx. ◆ GetRo(). void TSpectrum2Fit::GetRo ; (; Double_t & ; ro, . Double_t & ; roErr . ). This function gets the ro parameter and its error. . ro - gets the fitted value of ro parameter; roErr - gets error value of ro parameter . Definition at line 5814 of file TSpectrum2Fit.cxx. ◆ GetSigmaX(). void TSpectrum2Fit::GetSigmaX ; (; Double_t & ; sigmaX, . Double_t & ; sigmaErrX . ). This function gets the sigma x parameter and its error. . sigmaX - gets the fitted value of sigma x parameter; sigmaErrX - gets error value of sigma x parameter . Definition at line 5792 of file TSpectrum2Fit.cxx. ◆ GetSigmaY(). void TSpectrum2Fit::GetSigmaY ; (; Double_t & ; sigmaY, . Double_t & ; sigmaErrY . ). This function gets the sigma y parameter and its error. . sigmaY - gets the fitted value of sigma y parameter; sigmaErrY - gets error value of sigma y parameter . Definition at line 5803 of file TSpectrum2Fit.cxx. ◆ GetTailParameters(). void TSpectrum2Fit::GetTailParameters ; (; Double_t & ; txy, . Double_t & ; txyErr, . Double_t & ; tx, . Double_t & ; txErr, . Double_t & ; ty, . Double_t & ; tyErr, . Double_t & ; bx, . Double_t & ; bxErr, . Double_t & ; by, . Double_t & ; byErr, . Double_t & ; sxy, . Double_t & ; sxyErr, . Double_t & ; sx, . Double_t & ; sxErr, . Double_t & ; sy, . Double_t & ; syErr . ). This function gets the tail parameters and their errors. . txy - gets the fitted value of txy parameter; txyErr - gets error value of txy parameter; tx - gets the fitted value of tx parameter; txErr - gets error value of tx parameter; ty - gets the fitted value of ty parameter; tyErr - gets error value of ty parameter; bx - gets the fitted value of bx parameter; bxErr - gets error value of bx parameter; by - g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:67589,error,error,67589,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['error']
Availability,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoMCGeometry.html:21808,error,errors,21808,root/html534/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html534/TGeoMCGeometry.html,2,['error'],['errors']
Availability,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoMCGeometry.html:22269,error,errors,22269,root/html604/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html604/TGeoMCGeometry.html,2,['error'],['errors']
Availability,"and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& imed, Int_t& nmat, Int_t& isvol, Int_t& ifield, Double_t& fieldm, Double_t& tmaxfd, Double_t& stemax, Double_t& deemax, Double_t& epsil, Double_t& stmin, TArrayD& par); Returns the Medium and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name.; Outputs:; TString &name Medium name; Int_t &nmat Material number defined for this medium; Int_t &imed The medium index number; Int_t &isvol volume number defined for this medium; Int_t &iflield Magnetic field flag; Double_t &fieldm Magnetic field strength; Double_t &tmaxfd Maximum angle of deflection per step; Double_t &stemax Maximum step size; Double_t &deemax Maximum fraction of energy allowed to be lost; to continuous process.; Double_t &epsil Boundary crossing precision; Double_t &stmin Minimum step size allowed; TArrayD &par A TArrayD of user parameters with all of the; parameters of the specified medium.; Return:; kTRUE if there where no errors. TGeoMCGeometry(const char* name, const char* title, Bool_t g3CompatibleVolumeNames = false). void Gsbool(const char* , const char* ); {}. TGeoMCGeometry& operator=(const TGeoMCGeometry& ). » Last changed: root/vmc:$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoMCGeometry.html:22269,error,errors,22269,root/html602/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html602/TGeoMCGeometry.html,2,['error'],['errors']
Availability,"and RooNonCentralChiSquare. ◆ StreamerNVirtual(). void RooAbsPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 351 of file RooAbsPdf.h. ◆ syncNormalization(). bool RooAbsPdf::syncNormalization ; (; const RooArgSet * ; nset, . bool ; adjustProxies = true . ); const. protectedvirtual . Verify that the normalization integral cached with this PDF is valid for given set of normalization observables. ; If not, the cached normalization integral (if any) is deleted and a new integral is constructed for use with 'nset'. Elements in 'nset' can be discrete and real, but must be lvalues.; For functions that declare to be self-normalized by overloading the selfNormalized() function, a unit normalization is always constructed. ; Definition at line 481 of file RooAbsPdf.cxx. ◆ traceEvalPdf(). bool RooAbsPdf::traceEvalPdf ; (; double ; value); const. private . Check that passed value is positive and not 'not-a-number'. ; If not, print an error, until the error counter reaches its set maximum. ; Definition at line 384 of file RooAbsPdf.cxx. ◆ verboseEval() [1/2]. Int_t RooAbsPdf::verboseEval ; (; ). static . Return global level of verbosity for p.d.f. evaluations. ; Definition at line 2418 of file RooAbsPdf.cxx. ◆ verboseEval() [2/2]. void RooAbsPdf::verboseEval ; (; Int_t ; stat). static . Change global level of verbosity for p.d.f. evaluations. ; Definition at line 2408 of file RooAbsPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAbsReal. friend class RooAbsReal. friend . Definition at line 348 of file RooAbsPdf.h. ◆ RooChi2Var. friend class RooChi2Var. friend . Definition at line 349 of file RooAbsPdf.h. ◆ RooMCStudy. friend class RooMCStudy. friend . Definition at line 307 of file RooAbsPdf.h. Member Data Documentation. ◆ _errorCount. Int_t RooAbsPdf::_errorCount = 0. mutableprotected . Number of errors remaining to print. ; Definition at line 334 of file RooAbsPdf.h. ◆ _negCount. Int_t RooAbsPdf::_negCount = 0. mutableprote",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:156738,error,error,156738,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,2,['error'],['error']
Availability,"and SET; 3758//; 3759 if( !strncmp(comd.Data(),""SET"",3) ) {; 3760 Printf("" ***>SET <option_name>"");; 3761 Printf("" SET BATch"");; 3762 Printf("" Informs Minuit that it is running in batch mode."");; 3763 ; 3764 Printf("" "");; 3765 Printf("" SET EPSmachine <accuracy>"");; 3766 Printf("" Informs Minuit that the relative floating point arithmetic"");; 3767 Printf("" precision is <accuracy>. Minuit determines the nominal"");; 3768 Printf("" precision itself, but the SET EPSmachine command can be"");; 3769 Printf("" used to override Minuit own determination, when the user"");; 3770 Printf("" knows that the FCN function value is not calculated to"");; 3771 Printf("" the nominal machine accuracy. Typical values of <accuracy>"");; 3772 Printf("" are between 10**-5 and 10**-14."");; 3773 ; 3774 Printf("" "");; 3775 Printf("" SET ERRordef <up>"");; 3776 Printf("" Sets the value of UP (default value= 1.), defining parameter"");; 3777 Printf("" errors. Minuit defines parameter errors as the change"");; 3778 Printf("" in parameter value required to change the function value"");; 3779 Printf("" by UP. Normally, for chisquared fits UP=1, and for negative"");; 3780 Printf("" log likelihood, UP=0.5."");; 3781 ; 3782 Printf("" "");; 3783 Printf("" SET GRAdient [force]"");; 3784 Printf("" Informs Minuit that the user function is prepared to"");; 3785 Printf("" calculate its own first derivatives and return their values"");; 3786 Printf("" in the array GRAD when IFLAG=2 (see specs of FCN)."");; 3787 Printf("" If [force] is not specified, Minuit will calculate"");; 3788 Printf("" the FCN derivatives by finite differences at the current"");; 3789 Printf("" point and compare with the user calculation at that point,"");; 3790 Printf("" accepting the user values only if they agree."");; 3791 Printf("" If [force]=1, Minuit does not do its own derivative"");; 3792 Printf("" calculation, and uses the derivatives calculated in FCN."");; 3793 ; 3794 Printf("" "");; 3795 Printf("" SET INPut [unitno] [filename]"");; 3796 Printf("" Causes Minuit, in data-dri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:124899,error,errors,124899,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['errors']
Availability,"and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros computation to be performed after fitting. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Fit__FitConfig.html:4918,error,errors,4918,root/html534/ROOT__Fit__FitConfig.html,https://root.cern,https://root.cern/root/html534/ROOT__Fit__FitConfig.html,2,['error'],['errors']
Availability,"and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list. void SetParamsSettings(const vector<ROOT::Fit::ParameterSettings>& pars). Set the parameter settings from a vector of parameter settings. void SetFromFitResult(const ROOT::Fit::FitResult& rhs). Set the parameter settings from a fit Result. ROOT::Math::Minimizer * CreateMinimizer(). create a new minimizer according to chosen configuration. void SetMinimizer(const char* type, const char* algo = 0). set minimizer type. const std::string & MinimizerType() const. return type of minimizer package. { return fMinimizerOpts.MinimizerType(); }. const std::string & MinimizerAlgoType() const. return type of minimizer algorithms. { return fMinimizerOpts.MinimizerAlgorithm(); }. bool NormalizeErrors() const. flag to check if resulting errors are be normalized according to chi2/ndf. { return fNormErrors; }. bool ParabErrors() const; do analysis for parabolic errors. { return fParabErrors; }. bool MinosErrors() const; do minos errros analysis on the parameters. { return fMinosErrors; }. bool UpdateAfterFit() const; Update configuration after a fit using the FitResult. { return fUpdateAfterFit; }. bool UseWeightCorrection() const; Apply Weight correction for error matrix computation. { return fWeightCorr; }. const std::vector<unsigned int> & MinosParams() const; return vector of parameter indeces for which the Minos Error will be computed. { return fMinosParams; }. void SetNormErrors(bool on = true). set the option to normalize the error on the result according to chi2/ndf. { fNormErrors= on; }. void SetParabErrors(bool on = true); set parabolic erros. { fParabErrors = on; }. void SetMinosErrors(bool on = true); set Minos erros. { fMinosErrors = on; }. void SetWeightCorrection(bool on = true); apply the weight correction for error matric computation. { fWeightCorr = on; }. void SetMinosErrors(const vector<unsigned int>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__FitConfig.html:4918,error,errors,4918,root/html532/ROOT__Fit__FitConfig.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__FitConfig.html,2,['error'],['errors']
Availability,"and allow to change; and delete the original one without affecting the clone.; Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example:. h->Draw(""E1 SAME"");. The options are not case sensitive:. h->Draw(""e1 same"");. The default drawing option can be set with TH1::SetOption and retrieve; using TH1::GetOption:. root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; root [4] h->Draw(); // Draw ""h"" using error bars; root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; (const Option_t* 0xa3ff948)""E"". Options supported for 1D and 2D histograms. ""E""; Draw error bars. ""AXIS""; Draw only axis. ""AXIG""; Draw only grid (if the grid is requested). ""HIST""; When an histogram has errors it is visualized by default with error bars. To; visualize it without errors use the option ""HIST"" together with the required; option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the; histogram and not the associated function(s). ""FUNC""; When an histogram has a fitted function, this option allows to draw the fit; result only. ""SAME""; Superimpose on previous picture in the same pad. ""LEGO""; Draw a lego plot with hidden line removal. ""LEGO1""; Draw a lego plot with hidden surface removal. ""LEGO2""; Draw a lego plot using colors to show the cell contents When the option ""0"" is; used with any LEGO option, the empty bins are not drawn. ""LEGO3""; Draw a lego plot with hidden surface removal, like LEGO1 but the border lines; of each lego-bar are not drawn. ""LEGO4""; Draw a lego plot with hidden surface removal, like LEGO1 but without the; shadow effect on each lego-bar. ""TEXT""; Draw bin contents as text (format set via gStyle->SetPaintTextFormat). ""TEXTnn""; Draw bin contents as text at angle nn (0 < nn < 90). ""X+""; The X-axis is drawn on the top side of the plot. ""Y+""; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THistPainter.html:5060,error,errors,5060,root/html534/THistPainter.html,https://root.cern,https://root.cern/root/html534/THistPainter.html,6,['error'],['errors']
Availability,"and combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. Keyboard Bindings. The following table lists the keyboard shortcuts and accelerator; keys. Key: Action:. Up Move cursor up.; Shift+Up Move cursor up and extend selection.; Down Move cursor down.; Shift+Down Move cursor down and extend selection.; Left Move cursor left.; Shift+Left Move cursor left and extend selection.; Right Move cursor right.; Shift+Right Move cursor right and extend selection.; Home Move cursor to begin of line.; Shift+Home Move cursor to begin of line and extend selection.; Ctrl+Home Move cursor to top of page.; End Move cursor to end of line.; Shift+End Move cursor to end of line and extend selection.; Ctrl+End Move cursor to end of page.; PgUp Move cursor up one page.; Shift+PgUp Move cursor up one page and extend selection.; PgDn Move cursor down one page.; Shift+PgDn Move cursor down one page and extend selection.; Delete Delete character after cursor, or text selection.; BackSpace Delete character before cursor, or text selection.; Ctrl+B Move cursor left.; Ctrl+D Delete character after cursor, or text selection.; Ctrl+E Move cursor to end of line.; Ctrl+H Delete character before cursor, or text selection.; Ctrl+K Delete characters from current position to the; end of line.; Ctrl+U Delete current line. /*. */. Function Members (Methods); public:. TGTextEditor(const char* filename = 0, const TGWindow* p = 0, UInt_t w = 900, UInt_t h = 600); TGTextEditor(TMacro* macro, const TGWindow* p = 0, UInt_t w = 0, UInt_t h = 0); virtual~TGTextEditor(); voidAbout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddLine(const char* string); voidAddLineFast(const char* string); voidAddText(TGText* text); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEditor.html:4235,down,down,4235,root/html528/TGTextEditor.html,https://root.cern,https://root.cern/root/html528/TGTextEditor.html,6,['down'],['down']
Availability,"and combo box will be passed to; the CINT interpreter. This combo box will keep the commands history; and will allow you to re-execute the same commands during an editor; session. Keyboard Bindings. The following table lists the keyboard shortcuts and accelerator; keys. Key: Action:. Up Move cursor up.; Shift+Up Move cursor up and extend selection.; Down Move cursor down.; Shift+Down Move cursor down and extend selection.; Left Move cursor left.; Shift+Left Move cursor left and extend selection.; Right Move cursor right.; Shift+Right Move cursor right and extend selection.; Home Move cursor to begin of line.; Shift+Home Move cursor to begin of line and extend selection.; Ctrl+Home Move cursor to top of page.; End Move cursor to end of line.; Shift+End Move cursor to end of line and extend selection.; Ctrl+End Move cursor to end of page.; PgUp Move cursor up one page.; Shift+PgUp Move cursor up one page and extend selection.; PgDn Move cursor down one page.; Shift+PgDn Move cursor down one page and extend selection.; Delete Delete character after cursor, or text selection.; BackSpace Delete character before cursor, or text selection.; Ctrl+B Move cursor left.; Ctrl+D Delete character after cursor, or text selection.; Ctrl+E Move cursor to end of line.; Ctrl+H Delete character before cursor, or text selection.; Ctrl+K Delete characters from current position to the; end of line.; Ctrl+U Delete current line. /*. */. Function Members (Methods); public:. virtual~TGTextEditor(); voidAbout(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); voidAddLine(const char* string); voidAddLineFast(const char* string); voidAddText(TGText* text); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGTextEditor.html:4235,down,down,4235,root/html602/TGTextEditor.html,https://root.cern,https://root.cern/root/html602/TGTextEditor.html,4,['down'],['down']
Availability,"and dividing by xLast-xFirst. ;  ; double chiSquare (const RooHist &hist, int nFitParam) const;  Calculate the chi^2/NDOF of this curve with respect to the histogram 'hist' accounting nFitParam floating parameters in case the curve was the result of a fit. ;  ; Int_t findPoint (double value, double tolerance=1e-10) const;  Find the nearest point to xvalue. ;  ; double getFitRangeBinW () const override;  Get the bin width associated with this plotable object. ;  ; double getFitRangeNEvt () const override;  Return the number of events associated with the plotable object, it is always 1 for curves. ;  ; double getFitRangeNEvt (double xlo, double xhi) const override;  Return the number of events associated with the plotable object, in the given range. ;  ; double interpolate (double x, double tolerance=1e-10) const;  Return linearly interpolated value of curve at xvalue. ;  ; TClass * IsA () const override;  ; bool isIdentical (const RooCurve &other, double tol=1e-6, bool verbose=true) const;  Return true if curve is identical to other curve allowing for given absolute tolerance on each point compared point. ;  ; RooCurve * makeErrorBand (const std::vector< RooCurve * > &plusVar, const std::vector< RooCurve * > &minusVar, const TMatrixD &V, double Z=1) const;  Construct filled RooCurve represented error band represent the error added in quadrature defined by the curves arguments plusVar and minusVar corresponding to one-sigma variations of each parameter. ;  ; RooCurve * makeErrorBand (const std::vector< RooCurve * > &variations, double Z=1) const;  Construct filled RooCurve represented error band that captures alpha% of the variations of the curves passed through argument variations, where the percentage alpha corresponds to the central interval fraction of a significance Z. ;  ; void Print (Option_t *options=nullptr) const override;  This method must be overridden when a class wants to print itself. ;  ; void printClassName (std::ostream &os) const override;  Print th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCurve.html:5062,toler,tolerance,5062,doc/master/classRooCurve.html,https://root.cern,https://root.cern/doc/master/classRooCurve.html,1,['toler'],['tolerance']
Availability,"and drawn with option.; 3135/// A pointer to the normalized histogram is returned.; 3136/// The contents of the histogram copy are scaled such that the new; 3137/// sum of weights (excluding under and overflow) is equal to norm.; 3138/// Note that the returned normalized histogram is not added to the list; 3139/// of histograms in the current directory in memory.; 3140/// It is the user's responsibility to delete this histogram.; 3141/// The kCanDelete bit is set for the returned object. If a pad containing; 3142/// this copy is cleared, the histogram will be automatically deleted.; 3143///; 3144/// See Draw for the list of options; 3145 ; 3146TH1 *TH1::DrawNormalized(Option_t *option, Double_t norm) const; 3147{; 3148 Double_t sum = GetSumOfWeights();; 3149 if (sum == 0) {; 3150 Error(""DrawNormalized"",""Sum of weights is null. Cannot normalize histogram: %s"",GetName());; 3151 return nullptr;; 3152 }; 3153 Bool_t addStatus = TH1::AddDirectoryStatus();; 3154 TH1::AddDirectory(kFALSE);; 3155 TH1 *h = (TH1*)Clone();; 3156 h->SetBit(kCanDelete);; 3157 // in case of drawing with error options - scale correctly the error; 3158 TString opt(option); opt.ToUpper();; 3159 if (fSumw2.fN == 0) {; 3160 h->Sumw2();; 3161 // do not use in this case the ""Error option "" for drawing which is enabled by default since the normalized histogram has now errors; 3162 if (opt.IsNull() || opt == ""SAME"") opt += ""HIST"";; 3163 }; 3164 h->Scale(norm/sum);; 3165 if (TMath::Abs(fMaximum+1111) > 1e-3) h->SetMaximum(fMaximum*norm/sum);; 3166 if (TMath::Abs(fMinimum+1111) > 1e-3) h->SetMinimum(fMinimum*norm/sum);; 3167 h->Draw(opt);; 3168 TH1::AddDirectory(addStatus);; 3169 return h;; 3170}; 3171 ; 3172////////////////////////////////////////////////////////////////////////////////; 3173/// Display a panel with all histogram drawing options.; 3174///; 3175/// See class TDrawPanelHist for example; 3176 ; 3177void TH1::DrawPanel(); 3178{; 3179 if (!fPainter) {Draw(); if (gPad) gPad->Update();}; 3180 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:125764,error,error,125764,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['error']
Availability,"and error; x = -10 + 2 * i;; x.setError(i < 5 ? 0.5 / 1. : 1.0 / 1.);; ; // Set Y value and error; y = x.getVal() * x.getVal() + 4 * fabs(gRandom->Gaus());; y.setError(sqrt(y.getVal()));; ; dxy.add({x, y});; }; ; // P e r f o r m c h i 2 f i t t o X + / - d x a n d Y + / - d Y v a l u e s; // ---------------------------------------------------------------------------------------; ; // Make fit function; RooRealVar a(""a"", ""a"", 0.0, -10, 10);; RooRealVar b(""b"", ""b"", 0.0, -100, 100);; RooRealVar c(""c"", ""c"", 0.0, -100, 100);; RooPolyVar f(""f"", ""f"", x, RooArgList(b, a, c));; ; // Plot dataset in X-Y interpretation; RooPlot *frame = x.frame(Title(""Chi^2 fit of function set of (X#pmdX,Y#pmdY) values""));; dxy.plotOnXY(frame, YVar(y));; ; // Fit chi^2 using X and Y errors; std::unique_ptr<RooFitResult> fit1{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1))};; fit1->Print();; ; // Overlay fitted function; f.plotOn(frame);; ; // Alternative: fit chi^2 integrating f(x) over ranges defined by X errors, rather; // than taking point at center of bin; std::unique_ptr<RooFitResult> fit2{f.chi2FitTo(dxy, YVar(y), Save(), PrintLevel(-1), Integrate(true))};; fit2->Print();; ; // Overlay alternate fit result; f.plotOn(frame, LineStyle(kDashed), LineColor(kRed));; ; // Draw the plot on a canvas; new TCanvas(""rf609_xychi2fit"", ""rf609_xychi2fit"", 600, 600);; gPad->SetLeftMargin(0.15);; frame->GetYaxis()->SetTitleOffset(1.4);; frame->Draw();; }; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; RooDataSet.h; RooPlot.h; RooPolyVar.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kDashed@ kDashedDefinition TAttLine.h:48; TAxis.h; TCanvas.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; gPad#define gPadDefinition TVirtualPad.h:308; RooArgListRooArgList is a container object that can hold multiple RooAbsArg objects.Definition RooArgList.h:22; RooDataSetConta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf609__xychi2fit_8C.html:2273,error,errors,2273,doc/master/rf609__xychi2fit_8C.html,https://root.cern,https://root.cern/doc/master/rf609__xychi2fit_8C.html,1,['error'],['errors']
Availability,"and kind). void SetBlockSize(Int_t blockSize); Make sure the block size is a power of two, with a minimum of 32768. Long64_t PutFile(const char* file, const char* remoteName = 0); Transfer file to remote host. Returns number of bytes; sent or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling PutFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling PutFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the remoteName with a '-'. Long64_t GetFile(const char* file, const char* localName = 0); Transfer file from remote host. Returns number of bytes; received or < 0 in case of error. Error -1 connection is still; open, error -2 connection has been closed. In case of failure; fRestartAt is set to the number of bytes correclty transfered.; Calling GetFile() immediately afterwards will restart at fRestartAt.; If this is not desired call SetRestartAt(0) before calling GetFile().; If rootd reports that the file is locked, and you are sure this is not; the case (e.g. due to a crash), you can force unlock it by prepending; the file name with a '-'. Int_t ChangeDirectory(const char* dir) const; Change the remote directory. If the remote directory contains a .message; file and it is < 1024 characters then the contents is echoed back.; Returns 0 in case of success and -1 in case of failure. Int_t MakeDirectory(const char* dir, Bool_t print = kFALSE) const; Make a remote directory. Anonymous users may not create directories.; Returns 0 in case of success and -1 in case of failure. Int_t DeleteDirectory(const char* dir) const; Delete a remote directory. Anonymous users may not delete directories.; Returns 0 in case of success and -1 in case of failure. Int_t ListDirectory(Option_t* cmd = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFTP.html:9750,failure,failure,9750,root/html528/TFTP.html,https://root.cern,https://root.cern/root/html528/TFTP.html,10,['failure'],['failure']
Availability,"and line, argv[0]) and copy it in gProgName.Definition TSystem.cxx:226; TSystem::SendRawvirtual int SendRaw(int sock, const void *buffer, int length, int flag)Send exactly length bytes from buffer.Definition TSystem.cxx:2409; TSystem::SetFPEMaskvirtual Int_t SetFPEMask(Int_t mask=kDefaultMask)Set which conditions trigger a floating point exception.Definition TSystem.cxx:642; TSystem::fLevelInt_t fLevelDefinition TSystem.h:292; TSystem::GetBuildCompilervirtual const char * GetBuildCompiler() constReturn the build compiler.Definition TSystem.cxx:3883; TSystem::CloseConnectionvirtual void CloseConnection(int sock, Bool_t force=kFALSE)Close socket connection.Definition TSystem.cxx:2390; TSystem::GetLibrariesvirtual const char * GetLibraries(const char *regexp="""", const char *option="""", Bool_t isRegexp=kTRUE)Return a space separated list of loaded shared libraries.Definition TSystem.cxx:2136; TSystem::fBuildDirTString fBuildDirDefinition TSystem.h:307; TSystem::SetErrorStrvoid SetErrorStr(const char *errstr)Set the system error string.Definition TSystem.cxx:245; TSystem::RemoveSignalHandlervirtual TSignalHandler * RemoveSignalHandler(TSignalHandler *sh)Remove a signal handler from list of signal handlers.Definition TSystem.cxx:542; TSystem::SetSoExtvirtual void SetSoExt(const char *soExt)Set shared library extension, should be either .so, .sl, .a, .dll, etc.Definition TSystem.cxx:4236; TSystem::Closelogvirtual void Closelog()Close connection to system log daemon.Definition TSystem.cxx:1694; TSystem::fBuildCompilerTString fBuildCompilerDefinition TSystem.h:303; TSystem::Setenvvirtual void Setenv(const char *name, const char *value)Set environment variable.Definition TSystem.cxx:1649; TSystem::GetBuildArchvirtual const char * GetBuildArch() constReturn the build architecture.Definition TSystem.cxx:3875; TSystem::Linkvirtual int Link(const char *from, const char *to)Create a link from file1 to file2.Definition TSystem.cxx:1359; TSystem::SigAlarmInterruptsSyscallsvirtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:191280,error,error,191280,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"and oscar to be the same. . Reimplemented from TSystem.; Definition at line 2536 of file TWinNTSystem.cxx. ◆ Unlink(). int TWinNTSystem::Unlink ; (; const char * ; name). overridevirtual . Unlink, i.e. ; remove, a file or directory.; If the file is currently open by the current or another process Windows does not allow the file to be deleted and the operation is a no-op. ; Reimplemented from TSystem.; Definition at line 2899 of file TWinNTSystem.cxx. ◆ Utime(). int TWinNTSystem::Utime ; (; const char * ; file, . Long_t ; modtime, . Long_t ; actime . ). overridevirtual . Set a files modification and access times. ; If actime = 0 it will be set to the modtime. Returns 0 on success and -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3090 of file TWinNTSystem.cxx. ◆ WinNTUdpConnect(). int TWinNTSystem::WinNTUdpConnect ; (; const char * ; hostname, . int ; port . ). staticprotected . Creates a UDP socket connection Is called via the TSocket constructor. ; Returns -1 in case of error. ; Definition at line 5317 of file TWinNTSystem.cxx. ◆ WinNTUnixConnect() [1/2]. int TWinNTSystem::WinNTUnixConnect ; (; const char * ; path). staticprotected . Connect to a Unix domain socket. Returns -1 in case of error. ; Definition at line 5287 of file TWinNTSystem.cxx. ◆ WinNTUnixConnect() [2/2]. int TWinNTSystem::WinNTUnixConnect ; (; int ; port). staticprotected . Connect to a Unix domain socket. ; Definition at line 5256 of file TWinNTSystem.cxx. ◆ WorkingDirectory() [1/2]. const char * TWinNTSystem::WorkingDirectory ; (; ). overridevirtual . Return the working directory for the default drive. ; Reimplemented from TSystem.; Definition at line 2141 of file TWinNTSystem.cxx. ◆ WorkingDirectory() [2/2]. const char * TWinNTSystem::WorkingDirectory ; (; char ; driveletter). Return working directory for the selected drive driveletter == 0 means return the working durectory for the default drive. ; Definition at line 2164 of file TWinNTSystem.cxx. Member Data Documentat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:76540,error,error,76540,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['error'],['error']
Availability,"and put them into an array; Double_t *nx = gr3->GetX();; Double_t *ny = gr3->GetY();. // create markers of different colors; for (Int_t j=2; j<n-1; j++) {; TMarker *m = new TMarker(nx[j], 0.5*ny[j], 22);; m->SetMarkerSize(2);; m->SetMarkerColor(31+j);; m->Draw();; }; }; 4.2 Superimposing Two Graphs; To super impose two graphs you need to draw the axis only once, and leave out the “A” in the draw options for the second graph. Next is an example:. Superimposing two graphs. {; Int_t n = 20;; Double_t x[n], y[n], x1[n], y1[n];. // create a blue graph with a cos function; gr1->SetLineColor(4);; gr1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146086,error,error,146086,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability,"and the sea. ; Reimplemented from TH2.; Definition at line 1407 of file TH2Poly.cxx. ◆ SetBinContent() [2/3]. void TH2Poly::SetBinContent ; (; Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH2.; Definition at line 149 of file TH2Poly.h. ◆ SetBinContent() [3/3]. void TH2Poly::SetBinContent ; (; Int_t ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH2.; Definition at line 150 of file TH2Poly.h. ◆ SetBinContentChanged(). void TH2Poly::SetBinContentChanged ; (; Bool_t ; flag). inline . Definition at line 122 of file TH2Poly.h. ◆ SetBinError() [1/3]. void TH2Poly::SetBinError ; (; Int_t ; bin, . Double_t ; error . ). overridevirtual . Set the bin Error. ; Re-implementation for TH2Poly given the different bin indexing in the stored squared error array. See also notes in TH1::SetBinError; Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins ; Reimplemented from TH1.; Definition at line 893 of file TH2Poly.cxx. ◆ SetBinError() [2/3]. void TH2Poly::SetBinError ; (; Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 151 of file TH2Poly.h. ◆ SetBinError() [3/3]. void TH2Poly::SetBinError ; (; Int_t ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 152 of file TH2Poly.h. ◆ SetFloat(). void TH2Poly::SetFloat ; (; Bool_t ; flag = true). When set to kTRUE, allows the histogram to expand if a bin outside the limits is added. ; Definition at line 1424 of file TH2Poly.cxx. ◆ SetNewBinAdded(). void TH2Poly::SetNewBinAdded ; (; Bool_t ; flag). inline . Definition at line 124 of file TH2Poly.h. ◆ Streamer(). void TH2Poly::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:86148,error,errors,86148,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['error'],['errors']
Availability,"and use the ROOT::Math::Minimizer interface to perform the minimization of the objective function. More information about the function interface and the multi-dimensional minimization in ROOT is given in the Mathematical Library chapter.; Here we present a detailed description of the ROOT::Fit classes and how to use them. Using these classes instead of the interface provided directly in the ROOT data objects, like TH1::Fit allow are more fine control to configure and customise the fits. For example, using these classes a combined fit of several histograms can be performed.; To understand how these class work, let’s go through a simple example, such as fitting an histogram.; When fitting an histogram, instead of using TH1::Fit we will show in the following hot wo use the ROOT::Fit classes. We will show how to perform the following different type of fits with the histogram data: * a least square fit using the observed errors (Neyman chi-squared); * a least square fit using the expected errors from the function (Pearson chi-squared); * a binned likelihood fit; * an extended unbinned likelihood fits, if the histogram has been set to store in the buffer the original data used to fill it.; Let’s go through all the steps required for performing these fits using the ROOT::Fit::Fitter class. These steps are: 1. Create the input fit data object. 2. Create the input model function. 3. Configure the fit. 4. Perform the data fitting. 5. Examine the result.; 5.7.1 Creating the input fit data; We have two types of input data, binned data (class ROOT::Fit::BinData) used for least square (chi-square) fits of histograms or TGraph objects or un-binned data (class ROOT::Fit::UnBinData) used for fitting vectors of data points (e.g. from a TTree).; 5.7.1.1 Using Binned data; Let’s suppose we have an histogram, represented as a TH1 type object (it can be one or multi-dimensional). The following shows how to create and fill a ROOT:Fit::BinData object.; ROOT::Fit::DataOptions opt;; opt.fInt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:190869,error,errors,190869,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['error'],['errors']
Availability,"and wgt2 are not; 1 in this mode, a warning message is printed. If SumW2 errors are selectd the histograms are added; and the histograms errors are added in quadrature, taking the weights into account. void initialize(); Perform common initialization for all constructors. Double_t getFitRangeNEvt() const; Return the number of events of the dataset associated with this RooHist.; This is the number of events in the RooHist itself, unless a different; value was specified through setRawEntries(). Double_t getFitRangeNEvt(Double_t xlo, Double_t xhi) const; Calculate integral of histogram in given range. Double_t getFitRangeBinW() const; Return (average) bin width of this RooHist. Int_t roundBin(Double_t y); Return the nearest positive integer to the input value; and print a warning if an adjustment is required. void addBin(Axis_t binCenter, Double_t n, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the specified integer bin contents; and using an error bar calculated with Poisson statistics. The bin width; is used to set the relative scale of bins with different widths. void addBinWithError(Axis_t binCenter, Double_t n, Double_t elow, Double_t ehigh, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Bool_t correctForBinWidth = kTRUE, Double_t scaleFactor = 1.0); Add a bin to this histogram with the specified bin contents; and error. The bin width is used to set the relative scale of; bins with different widths. void addBinWithXYError(Axis_t binCenter, Double_t n, Double_t exlow, Double_t exhigh, Double_t eylow, Double_t eyhigh, Double_t scaleFactor = 1.0); Add a bin to this histogram with the specified bin contents; and error. The bin width is used to set the relative scale of; bins with different widths. void addAsymmetryBin(Axis_t binCenter, Int_t n1, Int_t n2, Double_t binWidth = 0, Double_t xErrorFrac = 1.0, Double_t scaleFactor = 1.0); Add a bin to this histogram with the value (n1-n2)/(n1+n2); using an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHist.html:22658,error,error,22658,root/html526/RooHist.html,https://root.cern,https://root.cern/root/html526/RooHist.html,7,['error'],['error']
Availability,"and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; unsigned long RndmInt (unsigned long max) const;  Generate an integer number between [0,max-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; void SetSeed (unsigned int seed) const;  set the random generator seed ;  ; unsigned int Size () const;  return the state size of generator ;  ; void Terminate ();  delete pointer to contained rng ;  . Friends; class GSLMCIntegrator;  . Random Distributions; Implemented using the GSL Random number Distributions . GSLRngWrapper * fRng;  ; unsigned int fCurTime;  ; double Gaussian (double sigma) const;  Gaussian distribution - default method is Box-Muller (polar method) ;  ; double GaussianZig (double sigma) const;  Gaussian distribution - Ziggurat method. ;  ; double GaussianRatio (double sigma) const;  Gaussian distribution - Ratio method. ;  ; double GaussianTail (double a, double sigma) const;  Gaussian Tail distribution. ;  ; void Gaussian2D (double sigmaX, double sigmaY, double rho, double &x, double &y) const;  Bivariate Gaussian distribution with correlation. ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRandomEngine.html:2433,avail,available,2433,doc/master/classROOT_1_1Math_1_1GSLRandomEngine.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRandomEngine.html,2,"['avail', 'error']","['available', 'error']"
Availability,"and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; unsigned long RndmInt (unsigned long max) const;  Generate an integer number between [0,max-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; void SetSeed (unsigned int seed) const;  set the random generator seed ;  ; unsigned int Size () const;  return the state size of generator ;  ; void Terminate ();  delete pointer to contained rng ;  ; double Gaussian (double sigma) const;  Gaussian distribution - default method is Box-Muller (polar method) ;  ; double GaussianZig (double sigma) const;  Gaussian distribution - Ziggurat method. ;  ; double GaussianRatio (double sigma) const;  Gaussian distribution - Ratio method. ;  ; double GaussianTail (double a, double sigma) const;  Gaussian Tail distribution. ;  ; void Gaussian2D (double sigmaX, double sigmaY, double rho, double &x, double &y) const;  Bivariate Gaussian distribution with correlation. ;  ; void GaussianND (size_t dim, const double *pars, const double *covmat, double *genpars, double *lmat=nullptr) const;  Multivariate Gaussian distribution. ;  ; doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngCMRG.html:2232,avail,available,2232,doc/master/classROOT_1_1Math_1_1GSLRngCMRG.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngCMRG.html,28,"['avail', 'error']","['available', 'error']"
Availability,"and(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TObject*AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(Option_t* opt = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tDoOwner(Bool_t done = kTRUE); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TObjectSet.html:1991,Error,Error,1991,root/html532/TObjectSet.html,https://root.cern,https://root.cern/root/html532/TObjectSet.html,4,['Error'],['Error']
Availability,"andalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.7616; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.731202 0.712689 0.193045 0.0157486 14439.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.701214 0.698536 0.191577 0.0154545 14535.3 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.6901 0.69615 0.192163 0.0158037 14515.8 0; : 4 | 0.683586 0.700826 0.19294 0.0151654 14400.2 1; : 5 | 0.682085 0.701998 0.192893 0.0153949 14422.7 2; : 6 | 0.6867 0.696275 0.191869 0.0152227 14492.2 3; : 7 Minimum Test error found - save the configuration ; : 7 | 0.692231 0.691692 0.197632 0.0164904 14132.6 0; : 8 | 0.683383 0.694963 0.194299 0.0156318 14328.3 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.682898 0.684979 0.192122 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:18781,error,error,18781,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"andalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:18116,error,error,18116,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['error'],['error']
Availability,"andler function. ; It prints the message on fgErrorHandlerFile and if abort is set it aborts the application. ; Definition at line 5755 of file TProofServ.cxx. ◆ FilterLocalroot(). void TProofServ::FilterLocalroot ; (; TString & ; path, . const char * ; dsrv = ""root://dum/"" . ). static . If 'path' is local and 'dsrv' is Xrootd, apply 'path.Localroot' settings, if any. ; The final path via the server is dsrv+path. ; Definition at line 6966 of file TProofServ.cxx. ◆ FlushLogFile(). void TProofServ::FlushLogFile ; (; ). Reposition the read pointer in the log file to the very end. ; This allows to ""hide"" useful debug messages during normal operations while preserving the possibility to have them in case of problems. ; Definition at line 6013 of file TProofServ.cxx. ◆ Fork(). Int_t TProofServ::Fork ; (; ). protectedvirtual . Fork a child. ; If successful, return 0 in the child process and the child pid in the parent process. The child pid is registered for reaping. Return <0 in the parent process in case of failure. ; Definition at line 6665 of file TProofServ.cxx. ◆ Get(). TObject * TProofServ::Get ; (; const char * ; namecycle). Get object with name ""name;cycle"" (e.g. ; ""aap;2"") from master or client. This method is called by TDirectory::Get() in case the object can not be found locally. ; Definition at line 1091 of file TProofServ.cxx. ◆ GetActSessions(). Int_t TProofServ::GetActSessions ; (; ); const. inline . Definition at line 263 of file TProofServ.h. ◆ GetCacheDir(). const char * TProofServ::GetCacheDir ; (; ); const. inline . Definition at line 248 of file TProofServ.h. ◆ GetCacheLock(). TProofLockPath * TProofServ::GetCacheLock ; (; ). inline . Definition at line 281 of file TProofServ.h. ◆ GetCompressionLevel(). Int_t TProofServ::GetCompressionLevel ; (; ); const. inlineprivate . Definition at line 464 of file TProofServ.h. ◆ GetConfDir(). const char * TProofServ::GetConfDir ; (; ); const. inline . Definition at line 239 of file TProofServ.h. ◆ GetConfFile(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:36524,failure,failure,36524,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['failure'],['failure']
Availability,"andler)Add a RLogHandler in the back - to be called after all others.Definition RLogger.hxx:153; ROOT::Experimental::RLogScopedDiagCountObject to count the number of warnings and errors emitted by a section of code, after construction of...Definition RLogger.hxx:260; ROOT::Experimental::RLogScopedDiagCount::GetAccumulatedWarningslong long GetAccumulatedWarnings() constGet the number of warnings that the RLogDiagCount has emitted since construction of *this.Definition RLogger.hxx:282; ROOT::Experimental::RLogScopedDiagCount::HasWarningOccurredbool HasWarningOccurred() constWhether the RLogDiagCount has emitted a warnings since construction time of *this.Definition RLogger.hxx:291; ROOT::Experimental::RLogScopedDiagCount::HasErrorOrWarningOccurredbool HasErrorOrWarningOccurred() constWhether the RLogDiagCount has emitted an error or a warning since construction time of *this.Definition RLogger.hxx:297; ROOT::Experimental::RLogScopedDiagCount::HasErrorOccurredbool HasErrorOccurred() constWhether the RLogDiagCount has emitted an error (fatal or not) since construction time of *this.Definition RLogger.hxx:294; ROOT::Experimental::RLogScopedDiagCount::RLogScopedDiagCountRLogScopedDiagCount(RLogDiagCount &cnt)Construct the scoped count given a counter (e.g.Definition RLogger.hxx:272; ROOT::Experimental::RLogScopedDiagCount::fInitialErrorslong long fInitialErrorsThe number of the RLogDiagCount's emitted errors at construction time.Definition RLogger.hxx:265; ROOT::Experimental::RLogScopedDiagCount::fInitialWarningslong long fInitialWarningsThe number of the RLogDiagCount's emitted warnings at construction time of *this.Definition RLogger.hxx:263; ROOT::Experimental::RLogScopedDiagCount::fCounterRLogDiagCount * fCounterDefinition RLogger.hxx:261; ROOT::Experimental::RLogScopedDiagCount::GetAccumulatedErrorslong long GetAccumulatedErrors() constGet the number of errors that the RLogDiagCount has emitted since construction of *this.Definition RLogger.hxx:285; ROOT::Experimenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:22282,error,error,22282,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['error']
Availability,"andlers = tmp_rh->next;; 19450 mg_free(tmp_rh->uri);; 19451 mg_free(tmp_rh);; 19452 }; 19453 ; 19454#if defined(USE_MBEDTLS); 19455 if (ctx->dd.ssl_ctx != NULL) {; 19456 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19457 mg_free(ctx->dd.ssl_ctx);; 19458 ctx->dd.ssl_ctx = NULL;; 19459 }; 19460 ; 19461#elif !defined(NO_SSL); 19462 /* Deallocate SSL context */; 19463 if (ctx->dd.ssl_ctx != NULL) {; 19464 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19465 int callback_ret =; 19466 (ctx->callbacks.external_ssl_ctx == NULL); 19467 ? 0; 19468 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19469 ; 19470 if (callback_ret == 0) {; 19471 SSL_CTX_free(ctx->dd.ssl_ctx);; 19472 }; 19473 /* else: ignore error and ommit SSL_CTX_free in case; 19474 * callback_ret is 1 */; 19475 }; 19476#endif /* !NO_SSL */; 19477 ; 19478 /* Deallocate worker thread ID array */; 19479 mg_free(ctx->worker_threadids);; 19480 ; 19481 /* Deallocate worker thread ID array */; 19482 mg_free(ctx->worker_connections);; 19483 ; 19484 /* deallocate system name string */; 19485 mg_free(ctx->systemName);; 19486 ; 19487 /* Deallocate context itself */; 19488 mg_free(ctx);; 19489}; 19490 ; 19491 ; 19492void; 19493mg_stop(struct mg_context *ctx); 19494{; 19495 pthread_t mt;; 19496 if (!ctx) {; 19497 return;; 19498 }; 19499 ; 19500 /* We don't use a lock here. Calling mg_stop with the same ctx from; 19501 * two threads is not allowed. */; 19502 mt = ctx->masterthreadid;; 19503 if (mt == 0) {; 19504 return;; 19505 }; 19506 ; 19507 ctx->masterthreadid = 0;; 19508 ; 19509 /* Set stop flag, so all threads know they have to exit. */; 19510 STOP_FLAG_ASSIGN(&ctx->stop_flag, 1);; 19511 ; 19512 /* Join timer thread */; 19513#if defined(USE_TIMERS); 19514 timers_exit(ctx);; 19515#endif; 19516 ; 19517 /* Wait until everything has stopped. */; 19518 while (!STOP_FLAG_IS_TWO(&ctx->stop_flag)) {; 19519 (void)mg_sleep(10);; 19520 }; 19521 ; 19522 /* Wait to stop master thread */; 19523 mg_join_thread(mt);; 19524 ; 19525 /* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:580818,error,error,580818,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"andlers = tmp_rh->next;; 19451 mg_free(tmp_rh->uri);; 19452 mg_free(tmp_rh);; 19453 }; 19454 ; 19455#if defined(USE_MBEDTLS); 19456 if (ctx->dd.ssl_ctx != NULL) {; 19457 mbed_sslctx_uninit(ctx->dd.ssl_ctx);; 19458 mg_free(ctx->dd.ssl_ctx);; 19459 ctx->dd.ssl_ctx = NULL;; 19460 }; 19461 ; 19462#elif !defined(NO_SSL); 19463 /* Deallocate SSL context */; 19464 if (ctx->dd.ssl_ctx != NULL) {; 19465 void *ssl_ctx = (void *)ctx->dd.ssl_ctx;; 19466 int callback_ret =; 19467 (ctx->callbacks.external_ssl_ctx == NULL); 19468 ? 0; 19469 : (ctx->callbacks.external_ssl_ctx(&ssl_ctx, ctx->user_data));; 19470 ; 19471 if (callback_ret == 0) {; 19472 SSL_CTX_free(ctx->dd.ssl_ctx);; 19473 }; 19474 /* else: ignore error and ommit SSL_CTX_free in case; 19475 * callback_ret is 1 */; 19476 }; 19477#endif /* !NO_SSL */; 19478 ; 19479 /* Deallocate worker thread ID array */; 19480 mg_free(ctx->worker_threadids);; 19481 ; 19482 /* Deallocate worker thread ID array */; 19483 mg_free(ctx->worker_connections);; 19484 ; 19485 /* deallocate system name string */; 19486 mg_free(ctx->systemName);; 19487 ; 19488 /* Deallocate context itself */; 19489 mg_free(ctx);; 19490}; 19491 ; 19492 ; 19493void; 19494mg_stop(struct mg_context *ctx); 19495{; 19496 pthread_t mt;; 19497 if (!ctx) {; 19498 return;; 19499 }; 19500 ; 19501 /* We don't use a lock here. Calling mg_stop with the same ctx from; 19502 * two threads is not allowed. */; 19503 mt = ctx->masterthreadid;; 19504 if (mt == 0) {; 19505 return;; 19506 }; 19507 ; 19508 ctx->masterthreadid = 0;; 19509 ; 19510 /* Set stop flag, so all threads know they have to exit. */; 19511 STOP_FLAG_ASSIGN(&ctx->stop_flag, 1);; 19512 ; 19513 /* Join timer thread */; 19514#if defined(USE_TIMERS); 19515 timers_exit(ctx);; 19516#endif; 19517 ; 19518 /* Wait until everything has stopped. */; 19519 while (!STOP_FLAG_IS_TWO(&ctx->stop_flag)) {; 19520 (void)mg_sleep(10);; 19521 }; 19522 ; 19523 /* Wait to stop master thread */; 19524 mg_join_thread(mt);; 19525 ; 19526 /* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:580851,error,error,580851,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"andling InputArguments DataHandling NumericIntegration ; [2] MinLevel = INFO Topic = HistFactory ; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for f: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for m: using 2; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for p0: using 0.005; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for s: using 2; Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; p0=0.01, ; prevFCN = 31.75882326 f=0.501, ; prevFCN = 31.76758673 f=0.499, ; prevFCN = 31.75008506 f=0.5, m=0.02014, ; prevFCN = 31.72980141 m=-0.02014, ; prevFCN = 31.78749743 m=0.004235, ; prevFCN = 31.75274724 m=-0.004235, ; prevFCN = 31.76488389 m=0, p0=0.01005, ; prevFCN = 31.75954549 p0=0.009948, ; prevFCN = 31.75810351 p0=0.01013, ; prevFCN = 31.76062402 p0=0.009872, ; prevFCN = 31.75703788 p0=0.01, s=1.02, ; prevFCN = 31.67915486 s=0.9799, ; prevFCN = 31.84068856 s=1.002, ; prevFCN = 31.75075447 s=0.998, ; prevFCN = 31.76691405 m=0.004235, s=1, ; prevFCN = 31.75274724 m=0.02118, ; prevFCN = 31.72829189 m=0.06353, ; prevFCN = 31.66614321 m=0.1906, ; prevFCN = 31.47244051 m=0.5715, ; prevFCN = 30.87227361 m=1.707, ; prevFCN = 29.88047134 m=2.064, ; prevFCN = 29.97604268 f=0.5008, m=1.707, ; prevFCN = 29.88564172 f=0.4992, ; prevFCN = 29.87531802 f=0.5, m=1.711, ; prevFCN = 29.88",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf506__msgservice_8C.html:9247,error,error,9247,doc/master/rf506__msgservice_8C.html,https://root.cern,https://root.cern/doc/master/rf506__msgservice_8C.html,2,"['avail', 'error']","['available', 'error']"
Availability,"andom functions.; 2531/// This function is automatically called by GetRandom when the fIntegral; 2532/// array does not exist or when the number of entries in the histogram; 2533/// has changed since the previous call to GetRandom.; 2534/// The resulting integral is normalized to 1.; 2535/// If the routine is called with the onlyPositive flag set an error will; 2536/// be produced in case of negative bin content and a NaN value returned; 2537/// \return 1 if success, 0 if integral is zero, NAN if onlyPositive-test fails; 2538 ; 2539Double_t TH1::ComputeIntegral(Bool_t onlyPositive); 2540{; 2541 if (fBuffer) BufferEmpty();; 2542 ; 2543 // delete previously computed integral (if any); 2544 if (fIntegral) delete [] fIntegral;; 2545 ; 2546 // - Allocate space to store the integral and compute integral; 2547 Int_t nbinsx = GetNbinsX();; 2548 Int_t nbinsy = GetNbinsY();; 2549 Int_t nbinsz = GetNbinsZ();; 2550 Int_t nbins = nbinsx * nbinsy * nbinsz;; 2551 ; 2552 fIntegral = new Double_t[nbins + 2];; 2553 Int_t ibin = 0; fIntegral[ibin] = 0;; 2554 ; 2555 for (Int_t binz=1; binz <= nbinsz; ++binz) {; 2556 for (Int_t biny=1; biny <= nbinsy; ++biny) {; 2557 for (Int_t binx=1; binx <= nbinsx; ++binx) {; 2558 ++ibin;; 2559 Double_t y = RetrieveBinContent(GetBin(binx, biny, binz));; 2560 if (onlyPositive && y < 0) {; 2561 Error(""ComputeIntegral"",""Bin content is negative - return a NaN value"");; 2562 fIntegral[nbins] = TMath::QuietNaN();; 2563 break;; 2564 }; 2565 fIntegral[ibin] = fIntegral[ibin - 1] + y;; 2566 }; 2567 }; 2568 }; 2569 ; 2570 // - Normalize integral to 1; 2571 if (fIntegral[nbins] == 0 ) {; 2572 Error(""ComputeIntegral"", ""Integral = 0, no hits in histogram bins (excluding over/underflow)."");; 2573 return 0;; 2574 }; 2575 for (Int_t bin=1; bin <= nbins; ++bin) fIntegral[bin] /= fIntegral[nbins];; 2576 fIntegral[nbins+1] = fEntries;; 2577 return fIntegral[nbins];; 2578}; 2579 ; 2580////////////////////////////////////////////////////////////////////////////////; 2581/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:100860,error,error,100860,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"andom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: DebuggingSampler.h 34109 2010-06-24 15:00:16Z moneta $ » Last generated: 2010-11-25 07:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__DebuggingSampler.html:3213,error,error,3213,root/html528/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html528/RooStats__DebuggingSampler.html,1,['error'],['error']
Availability,"andom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: DebuggingSampler.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__DebuggingSampler.html:3225,error,error,3225,root/html530/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html530/RooStats__DebuggingSampler.html,1,['error'],['error']
Availability,"andom*fRand; Double_tfSize; RooRealVar*fTestStatistic. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~DebuggingSampler(). SamplingDistribution* GetSamplingDistribution(RooArgSet& paramsOfInterest); Main interface to get a ConfInterval, pure virtual. Double_t EvaluateTestStatistic(RooAbsData& , RooArgSet& ); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; Get the TestStatistic. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); Common Initialization. void SetPdf(RooAbsPdf& ); Set the Pdf, add to the the workspace if not already there. {}. void SetParameters(RooArgSet& ); specify the parameters of interest in the interval. {}. void SetNuisanceParameters(const RooArgSet& ); specify the nuisance parameters (eg. the rest of the parameters). {}. void SetParametersForTestStat(const RooArgSet& ); specify the values of parameters used when evaluating test statistic. {}. void SetGlobalObservables(const RooArgSet& ); specify the conditional observables. {}. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size;}. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl;}. void SetTestStatistic(RooStats::TestStatistic* ); Set the TestStatistic (want the argument to be a function of the data & parameter points. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: DebuggingSampler.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__DebuggingSampler.html:3225,error,error,3225,root/html532/RooStats__DebuggingSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__DebuggingSampler.html,2,['error'],['error']
Availability,"ange [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::SetContentvirtual void SetContent(const Double_t *content)Replace bin contents by the contents of array content.Definition TH1.cxx:8398; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::fBarWidthShort_t fBarWidth(1000*width) for bar charts or legosDefinition TH1.h:94; TH1::GetBinErrorSqUncheckedvirtual Double_t GetBinErrorSqUnchecked(Int_t bin) constDefinition TH1.h:449; TH1::AxisChoiceInt_t AxisChoice(Option_t *axis) constChoose an axis according to ""axis"".Definition Haxis.cxx:14; TH1::SetMinimumvirtual void SetMinimum(D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:446131,error,error,446131,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"ange [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definition TH1.h:103; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::RebinXvirtual TH1 * RebinX(Int_t ngroup=2, const char *newname="""")Definition TH1.h:354; TH1::Browsevoid Browse(TBrowser *b) overrideBrowse the Histogram object.Definition TH1.cxx:762; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin, Int_t, Int_t) constDefinition TH1.h:267; TH1::SetContentvirtual void SetContent(const Double_t *content)Replace bin contents by the contents of array content.Definition TH1.cxx:8398; TH1::GetLabelSizevirtual Float_t GetLabelSize(Option_t *axis=""X"") constReturn the ""axis"" label size.Definition Haxis.cxx:92; TH1::SavePrimitiveHelpvirtual void SavePrimitiveHelp(std::ostream &out, const char *hname, Option_t *option="""")Helper function for the SavePrimitive functions from TH1 or classes derived from TH1,...Definition TH1.cxx:7379; TH1::fBarWidthShort_t fBarWidth(1000*width) for bar charts or legosDefinition TH1.h:94; TH1::GetBinErrorSqUncheckedvirtual Double_t G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8h_source.html:67703,error,error,67703,doc/master/TH1_8h_source.html,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html,1,['error'],['error']
Availability,"ange includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. Double_t GetMeanError(Int_t axis = 1) const; -*-*-*-*-*-*Return standard error of mean of this histogram along the X axis*-*-*-*-*. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram.; Also note, that although the definition of standard error doesn't include the; assumption of normality, many uses of this feature implicitly assume it. Double_t GetRMS(Int_t axis = 1) const; For axis = 1,2 or 3 returns the Sigma value of the histogram along; X, Y or Z axis; For axis = 11, 12 or 13 returns the error of RMS estimation along; X, Y or Z axis for Normal distribution. Note that the mean value/sigma is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram.; Note that this function returns the Standard Deviation (Sigma); of the distribution (not RMS).; The Sigma estimate is computed as Sqrt((1/N)*(Sum(x_i-x_mean)^2)); The name ""RMS"" was introduced many years ago (Hbook/PAW times).; We kept the name for continuity. Double_t GetRMSError(Int_t axis = 1) const; Return error of RMS estimation for Normal distribution. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:102191,error,error,102191,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,['error'],['error']
Availability,"ange without notice. It might trigger earthquakes. Feedback; 6/// is welcome!; 7 ; 8/*************************************************************************; 9 * Copyright (C) 1995-2020, Rene Brun and Fons Rademakers. *; 10 * All rights reserved. *; 11 * *; 12 * For the licensing terms see $ROOTSYS/LICENSE. *; 13 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 14 *************************************************************************/; 15 ; 16#ifndef ROOT7_RLogger; 17#define ROOT7_RLogger; 18 ; 19#include <atomic>; 20#include <list>; 21#include <memory>; 22#include <mutex>; 23#include <sstream>; 24#include <string>; 25#include <utility>; 26 ; 27namespace ROOT {; 28namespace Experimental {; 29 ; 30class RLogEntry;; 31class RLogManager;; 32 ; 33/**; 34 Kinds of diagnostics.; 35 */; 36enum class ELogLevel : unsigned char {; 37 kUnset,; 38 kFatal, ///< An error which causes further processing to be unreliable; 39 kError, ///< An error; 40 kWarning, ///< Warnings about likely unexpected behavior; 41 kInfo, ///< Informational messages; used for instance for tracing; 42 kDebug ///< Debug information; only useful for developers; can have added verbosity up to 255-kDebug.; 43};; 44 ; 45inline ELogLevel operator+(ELogLevel severity, int offset); 46{; 47 return static_cast<ELogLevel>(static_cast<int>(severity) + offset);; 48}; 49 ; 50/**; 51 Keep track of emitted errors and warnings.; 52 */; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:1255,error,error,1255,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,2,['error'],['error']
Availability,"ange();; 905 bool useRangeX = ( range.Size(0) > 0);; 906 bool useRangeY = ( range.Size(1) > 0);; 907 double xmin = 0;; 908 double xmax = 0;; 909 double ymin = 0;; 910 double ymax = 0;; 911 range.GetRange(xmin,xmax,ymin,ymax);; 912 ; 913 dv.Initialize(nPoints,2, type);; 914 ; 915 for ( int i = 0; i < nPoints; ++i) {; 916 ; 917 x[0] = gx[i];; 918 x[1] = gy[i];; 919 ; 920 //if (fitOpt.fUseRange && HFitInterface::IsPointOutOfRange(func, x) ) continue;; 921 if (useRangeX && ( x[0] < xmin || x[0] > xmax) ) continue;; 922 if (useRangeY && ( x[1] < ymin || x[1] > ymax) ) continue;; 923 ; 924 // need to evaluate function to know about rejected points; 925 // hugly but no other solutions; 926 if (func) {; 927 TF1::RejectPoint(false);; 928 (*func)( x ); // evaluate using stored function parameters; 929 if (TF1::RejectedPoint() ) continue;; 930 }; 931 ; 932 if (type == BinData::kNoError) {; 933 dv.Add( x, gz[i] );; 934 continue;; 935 }; 936 ; 937 double errorZ = gr->GetErrorZ(i);; 938 if (!HFitInterface::AdjustError(fitOpt,errorZ) ) continue;; 939 ; 940 if (type == BinData::kValueError) {; 941 dv.Add( x, gz[i], errorZ );; 942 }; 943 else if (type == BinData::kCoordError) { // case use error in coordinates (x and y); 944 ex[0] = std::max(gr->GetErrorX(i), 0.);; 945 ex[1] = std::max(gr->GetErrorY(i), 0.);; 946 dv.Add( x, gz[i], ex, errorZ );; 947 }; 948 else; 949 assert(0); // should not go here; 950 ; 951#ifdef DEBUG; 952 std::cout << ""Point "" << i << "" "" << gx[i] << "" "" << gy[i] << "" "" << errorZ << std::endl;; 953#endif; 954 ; 955 }; 956 ; 957#ifdef DEBUG; 958 std::cout << ""THFitInterface::FillData Graph2D FitData size is "" << dv.Size() << std::endl;; 959#endif; 960 ; 961}; 962 ; 963 ; 964// confidence intervals; 965bool GetConfidenceIntervals(const TH1 * h1, const ROOT::Fit::FitResult & result, TGraphErrors * gr, double cl ) {; 966 if (h1->GetDimension() != 1) {; 967 Error(""GetConfidenceIntervals"",""Invalid object used for storing confidence intervals"");; 968 return false;; 969 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:30479,error,errorZ,30479,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,2,['error'],['errorZ']
Availability,"ange(Double_t *xmin, Double_t *xmax) constReturn range of a generic N-D function.Definition TF1.cxx:2281; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::RejectedPointstatic Bool_t RejectedPoint()See TF1::RejectPoint above.Definition TF1.cxx:3692; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetParametervirtual void SetParameter(Int_t param, Double_t value)Definition TF1.h:667; TF1::IsInsidevirtual Bool_t IsInside(const Double_t *x) constreturn kTRUE if the point is inside the function rangeDefinition TF1.h:626; TF1::GetNdimvirtual Int_t GetNdim() constDefinition TF1.h:513; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraphErrorsA TGraphErrors is a TGraph with error bars.Definition TGraphErrors.h:26; TGraphErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:623; TGraphErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraphErrors.h:69; TGraphErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:612; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideIt returns the e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:39460,error,error,39460,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['error'],['error']
Availability,"ange. void SetBins(Int_t nx, const Double_t* xBins); Redefine x axis parameters with variable bin sizes. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); Redefine x and y axis parameters. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); Redefine x and y axis parameters with variable bin sizes. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax, Int_t nz, Double_t zmin, Double_t zmax); Redefine x, y and z axis parameters. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins, Int_t nz, const Double_t* zBins); Redefine x, y and z axis parameters with variable bin sizes. The X, Y and Z axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1,; zBins is supp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:125231,error,errors,125231,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,8,['error'],['errors']
Availability,"ange;  logical slider range ;  ; Int_t fSliderSize;  logical slider size ;  ; Int_t fSmallInc;  Small Increment in the sliding algorithm. ;  ; Window_t fSubw;  sub window in which mouse is pressed ;  ; TGScrollBarElement * fTail;  tail button of scrollbar ;  ; const TGPicture * fTailPic;  picture in tail (down or right arrow) ;  ; Int_t fX0;  ; Int_t fXp;  ; Int_t fY0;  current slider position in pixels ;  ; Int_t fYp;  previous slider position in pixels ;  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Protected Attributes inherited from TGWidget; TString fCommand;  command to be executed ;  ; const TGWindow * fMsgWindow;  window which handles widget events ;  ; Int_t fWidgetFlags;  widget status flags (OR of EWidgetStatus) ;  ; Int_t fWidgetId;  the widget id (used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHScrollBar.html:29041,mask,mask,29041,doc/master/classTGHScrollBar.html,https://root.cern,https://root.cern/doc/master/classTGHScrollBar.html,3,['mask'],['mask']
Availability,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly conformin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTimeStamp.html:7560,error,error,7560,root/html534/TTimeStamp.html,https://root.cern,https://root.cern/root/html534/TTimeStamp.html,2,['error'],['error']
Availability,"angle, given a longitude; in degrees. Return value will always be between 0 and 24 (hours).; Sidereal time is most accurately calculated from UT1. If fSec and; fNanoSec are in UTC (which they are by default), the optional argument; UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. Double_t AsLAST(Double_t Longitude, Double_t UT1Offset = 0) const; Return local apparant sidereal time (LAST) in hour-angle, given a; longitude in degrees. Return value will always be between 0 and 24; (hours). Sidereal time is most accurately calculated from UT1. If fSec; and fNanoSec are in UTC (which they are by default), the optional; argument UT1Offset can be supplied (in milliseconds). If UT1Offset is not; supplied, conversion has maximum error of 1s. If offset is supplied error; can be reduced to us level. Values for UT1Offset can be found in IERS; Bulletin B: ftp://ftp.iers.org/products/eop/bulletinb/format_2009. const Char_t * AsString(const Option_t* option = """") const; Return the date & time as a string. Result is pointer to a statically allocated string.; User should copy this into their own buffer before calling; this method again. Option ""l"" returns it in local zone format; (can be applied to default or compact format). Default format is RFC822 compliant:; ""Mon, 02 Jan 2001 18:11:12 +0000 (GMT) +999999999 nsec""; ""Mon, 02 Jan 2001 10:11:12 -0800 (PST) +999999999 nsec"". Option ""c"" compact is (almost) ISO 8601 compliant:; ""2001-01-02 18:11:12.9999999999Z""; ""2001-01-02 10:11:12.9999999999-0800"" if PST; * uses ""-"" as date separator as specified in ISO 8601; * uses ""."" rather than preferred "","" for decimal separator; * -HHMM is the difference between local and UTC (if behind, + if ahead).; The ""-HHMM"" is replaced with ""Z"" if given as UTC.; To be strictly con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTimeStamp.html:7586,error,error,7586,root/html604/TTimeStamp.html,https://root.cern,https://root.cern/root/html604/TTimeStamp.html,2,['error'],['error']
Availability,"anmorph.root with object name(s) 'pTV'; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x7ffccdd4a418; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; [#1] INFO:DataHandling -- RooDataHist::adjustBinning(morph_dh_cHq3=0.01): fit range of variable pTV expanded to nearest bin boundaries: [10,600] --> [0,600]; [#1] INFO:InputArguments -- RooAbsData::plotOn(SM_NPsq0) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq1) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 24931.9 will supersede previous event count of 10852.3 for normalization of PDF projections; [#1] INFO:InputArguments -- RooAbsData::plotOn(cHq3_NPsq2) INFO: dataset has non-integer weights, auto-selecting SumW2 errors instead of Poisson errors; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 29789.2 will supersede previous event count of 24931.9 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 18947.1 will supersede previous event count of 11104.6 for normalization of PDF projections; [#1] INFO:Plotting -- RooPlot::updateFitRangeNorm: New event count of 30765.5 will supersede previous event count of 18947.1 for normalization of PDF projections; [#0] PROGRESS:Caching -- creating cache from getCache function for 0x557821400550; [#0] PROGRESS:Caching -- current storage has size 3; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_SM_NPsq0_morphfunc_Int[cHq3]) using numeric integrator RooIntegrator1D to calculate Int(cHq3); [#1] INFO:NumericIntegration -- RooRealIntegral::init(w_cHq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html:14364,error,errors,14364,doc/master/rf711__lagrangianmorph_8C.html,https://root.cern,https://root.cern/doc/master/rf711__lagrangianmorph_8C.html,2,['error'],['errors']
Availability,"annel with a default verbosity. ;  ; ELogLevel GetEffectiveVerbosity (const RLogManager &mgr) const;  ; const std::string & GetName () const;  ; ELogLevel GetVerbosity () const;  ; ELogLevel SetVerbosity (ELogLevel verbosity);  ;  Public Member Functions inherited from ROOT::Experimental::RLogDiagCount; long long GetNumErrors () const;  Returns the current number of errors. ;  ; long long GetNumFatalErrors () const;  Returns the current number of fatal errors. ;  ; long long GetNumWarnings () const;  Number of fatal errors. ;  ; void Increment (ELogLevel severity);  Increase warning or error count. ;  . Private Attributes; std::string fName;  Name as shown in diagnostics. ;  ; ELogLevel fVerbosity = ELogLevel::kUnset;  Verbosity of this channel. By default, use the global verbosity. ;  . Additional Inherited Members;  Protected Attributes inherited from ROOT::Experimental::RLogDiagCount; std::atomic< long long > fNumErrors {0ll};  Number of warnings. ;  ; std::atomic< long long > fNumFatalErrors {0ll};  Number of errors. ;  ; std::atomic< long long > fNumWarnings {0ll};  . #include <ROOT/RLogger.hxx>. Inheritance diagram for ROOT::Experimental::RLogChannel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RLogChannel() [1/3]. ROOT::Experimental::RLogChannel::RLogChannel ; (; ). default . Construct an anonymous channel. . ◆ RLogChannel() [2/3]. ROOT::Experimental::RLogChannel::RLogChannel ; (; ELogLevel ; verbosity). inlineexplicit . Construct an anonymous channel with a default verbosity. ; Definition at line 113 of file RLogger.hxx. ◆ RLogChannel() [3/3]. ROOT::Experimental::RLogChannel::RLogChannel ; (; const std::string & ; name). inline . Construct a log channel given its name, which is part of the diagnostics. ; Definition at line 116 of file RLogger.hxx. Member Function Documentation. ◆ GetEffectiveVerbosity(). ELogLevel ROOT::Experimental::RLogChannel::GetEffectiveVerbos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html:1749,error,errors,1749,doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1Experimental_1_1RLogChannel.html,2,['error'],['errors']
Availability,"annotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie; vector<TH1*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<RooStats::HistFactory::EstimateSummary::NormFactor>normFactor; stringnormName; map<string,pair<double,double> >overallSyst""acceptance""->(0.8,1.2); TH1*relStatErrorAn (optional) externally provided shape for this error; stringshapeFactorName; vector<RooStats::HistFactory::EstimateSummary::ShapeSys>shapeSysts; vector<string>systSourceForHist. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EstimateSummary(). ~EstimateSummary(); {}. void Print(const char* opt = 0) const. void AddSyst(const string& sname, TH1* low, TH1* high). bool operator==(const RooStats::HistFactory::EstimateSummary& other) const; Comparator for two Estimate summary objects. Useful to make sure two analyses are the same. bool CompareHisto(const TH1* one, const TH1* two) const. EstimateSummary(); simple structure to hold necessary information about each channel. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2015-06-02 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__HistFactory__EstimateSummary.html:6919,error,error,6919,root/html604/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html604/RooStats__HistFactory__EstimateSummary.html,2,['error'],['error']
Availability,"annotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie; vector<TH1*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<RooStats::HistFactory::EstimateSummary::NormFactor>normFactor; stringnormName; map<string,pair<double,double> >overallSyst""acceptance""->(0.8,1.2); TH1*relStatErrorAn (optional) externally provided shape for this error; stringshapeFactorName; vector<RooStats::HistFactory::EstimateSummary::ShapeSys>shapeSysts; vector<string>systSourceForHist. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EstimateSummary(). ~EstimateSummary(); {}. void Print(const char* opt = 0) const. void AddSyst(const string& sname, TH1* low, TH1* high). bool operator==(const RooStats::HistFactory::EstimateSummary& other) const; Comparator for two Estimate summary objects. Useful to make sure two analyses are the same. bool CompareHisto(const TH1* one, const TH1* two) const. EstimateSummary(); simple structure to hold necessary information about each channel. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2015-06-30 14:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__EstimateSummary.html:6919,error,error,6919,root/html602/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__EstimateSummary.html,2,['error'],['error']
Availability,"ans ""a"" vertical and ""b"" horizontal along X; The resulting profile contains the combination of all the considered bins along X By default, all bins are included considering also underflow/overflows; The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details; To select a bin range along an axis, use TAxis::SetRange, eg h3.GetYaxis()->SetRange(23,56); ; Reimplemented from TH3.; Definition at line 1054 of file TProfile3D.cxx. ◆ ProjectionXYZ(). TH3D * TProfile3D::ProjectionXYZ ; (; const char * ; name = ""_pxyz"", . Option_t * ; option = ""e"" . ); const. virtual . Project this profile3D into a 3-D histogram along X,Y,Z. ; The projection is always of the type TH3D. if option ""E"" is specified, the errors are computed. (default); if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""E"" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH2D using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:96620,error,errors,96620,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,3,['error'],['errors']
Availability,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*GetRotation() const; virtual const Double_t*GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; virtual const Double_t*GetTranslati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCombiTrans.html:8433,error,error,8433,root/html528/TGeoCombiTrans.html,https://root.cern,https://root.cern/root/html528/TGeoCombiTrans.html,10,['error'],['error']
Availability,"ans(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoMatrix::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTGeoMatrix::GetHomogenousMatrix(Double_t* hmat) const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; char*TGeoMatrix::GetPointerName() const; TGeoRotation*TGeoCombiTrans::GetRotation() const; virtual const Double_t*TGeoCombiTrans::GetRotationMatrix() const; virtual const Double_t*GetScale() const; virtual const char*TNamed::GetTitle() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGenTrans.html:8380,error,error,8380,root/html528/TGeoGenTrans.html,https://root.cern,https://root.cern/root/html528/TGeoGenTrans.html,10,['error'],['error']
Availability,"ansient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; RooRealProxy_realVarRealVar with the original error; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooErrorVar.html:36849,error,error,36849,root/html530/RooErrorVar.html,https://root.cern,https://root.cern/root/html530/RooErrorVar.html,1,['error'],['error']
Availability,"ant to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RKeyBlob.html:7779,error,error,7779,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RKeyBlob.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RKeyBlob.html,6,['error'],['error']
Availability,"ant to support this special case; 5447 // Int_t n = TMath::Min(axis->GetNbins(), labels->GetSize());; 5448 ; 5449 // support only cases where each bin has a labels (should be when axis is alphanumeric); 5450 Int_t n = labels->GetSize();; 5451 if (n != axis->GetNbins()) {; 5452 // check if labels are all consecutive and starts from the first bin; 5453 // in that case the current code will work fine; 5454 Int_t firstLabelBin = axis->GetNbins()+1;; 5455 Int_t lastLabelBin = -1;; 5456 for (Int_t i = 0; i < n; ++i) {; 5457 Int_t bin = labels->At(i)->GetUniqueID();; 5458 if (bin < firstLabelBin) firstLabelBin = bin;; 5459 if (bin > lastLabelBin) lastLabelBin = bin;; 5460 }; 5461 if (firstLabelBin != 1 || lastLabelBin-firstLabelBin +1 != n) {; 5462 Error(""LabelsOption"", ""%s of Histogram %s contains bins without labels. Sorting will not work correctly - return"",; 5463 axis->GetName(), GetName());; 5464 return;; 5465 }; 5466 // case where label bins are consecutive starting from first bin will work; 5467 // calling before a TH1::LabelsDeflate() will avoid this error message; 5468 Warning(""LabelsOption"", ""axis %s of Histogram %s has extra following bins without labels. Sorting will work only for first label bins"",; 5469 axis->GetName(), GetName());; 5470 }; 5471 std::vector<Int_t> a(n);; 5472 std::vector<Int_t> b(n);; 5473 ; 5474 ; 5475 Int_t i, j, k;; 5476 std::vector<Double_t> cont;; 5477 std::vector<Double_t> errors2;; 5478 THashList *labold = new THashList(labels->GetSize(), 1);; 5479 TIter nextold(labels);; 5480 TObject *obj = nullptr;; 5481 labold->AddAll(labels);; 5482 labels->Clear();; 5483 ; 5484 // delete buffer if it is there since bins will be reordered.; 5485 if (fBuffer); 5486 BufferEmpty(1);; 5487 ; 5488 if (sort > 0) {; 5489 //---sort by values of bins; 5490 if (GetDimension() == 1) {; 5491 cont.resize(n);; 5492 if (fSumw2.fN); 5493 errors2.resize(n);; 5494 for (i = 0; i < n; i++) {; 5495 cont[i] = RetrieveBinContent(i + 1);; 5496 if (!errors2.empty()); 5497 e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:219207,error,error,219207,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"antile (0.5 is the default for the median) An approximate error for the quantile is computed assuming that the distribution in the other variable is normal. ; Definition at line 2518 of file TH2.cxx. ◆ Rebin(). TH2 * TH2::Rebin ; (; Int_t ; ngroup = 2, . const char * ; newname = """", . const Double_t * ; xbins = nullptr . ). overridevirtual . Override TH1::Rebin as TH2::RebinX Rebinning in variable binning as for TH1 is not allowed If a non-null pointer is given an error is flagged see RebinX and Rebin2D. ; Reimplemented from TH1.; Definition at line 1663 of file TH2.cxx. ◆ Rebin2D(). TH2 * TH2::Rebin2D ; (; Int_t ; nxgroup = 2, . Int_t ; nygroup = 2, . const char * ; newname = """" . ). virtual . Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together. ; if newname is not blank a new temporary histogram hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to me merged into one bin of hnew If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.; examples: if hpxpy is an existing TH2 histogram with 40 x 40 bins hpxpy->Rebin2D(); // merges two bins along the xaxis and yaxis in one in hpxpy; // Carefull: previous contents of hpxpy are lost; hpxpy->RebinX(5); //merges five bins along the xaxis in one in hpxpy; TH2 *hnew = hpxpy->RebinY(5,""hnew""); // creates a new histogram hnew; // merging 5 bins of h1 along the yaxis in one bin; TH2Service class for 2-D histogram classes.Definition TH2.h:30; TH2::RebinYvirtual TH2 * RebinY(Int_t ngroup=2, const char *newname="""")Rebin only the Y axis see Rebin2D.Definition TH2.cxx:1652; NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned histogram is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the corresponding bins are added to the ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2.html:103215,error,errors,103215,doc/master/classTH2.html,https://root.cern,https://root.cern/doc/master/classTH2.html,2,['error'],['errors']
Availability,"anup. ;  ; Int_t BrowseDirectory (const char *dirname);  Browse directory and send back its content to client. ;  ; Int_t BrowseFile (const char *fname);  Browse root file and send back its content; if fname is null, send the full list of files. ;  ; Int_t BrowseKey (const char *keyname);  Read key object and send it back to client. ;  ; const char * GetHost () const;  ; void GetOptions (Int_t *argc, char **argv) override;  Get and handle command line options. ;  ; Int_t GetPort () const;  ; Int_t GetProtocol () const;  ; TSocket * GetSocket () const;  ; const char * GetUser () const;  ; void HandleSigPipe ();  Called when the client is not alive anymore (i.e. ;  ; void HandleSocketInput ();  Handle input coming from the client or from the master server. ;  ; void HandleUrgentData ();  Handle Out-Of-Band data sent by the master or client. ;  ; void Interrupt ();  ; TClass * IsA () const override;  ; Bool_t IsValid () const;  ; Longptr_t ProcessLine (const char *line, Bool_t=kFALSE, Int_t *err=nullptr) override;  Parse a command line received from the client, making sure that the files needed for the execution, if any, are available. ;  ; Int_t ReceiveFile (const char *file, Bool_t bin, Long64_t size);  Receive a file, either sent by a client or a master server. ;  ; void Reset (const char *dir);  Reset environment to be ready for execution of next command. ;  ; void Run (Bool_t retrn=kFALSE) override;  Main server eventloop. ;  ; void SendLogFile (Int_t status=0, Int_t start=-1, Int_t end=-1);  Send log file to master. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate (Int_t status) override;  Terminate the proof server. ;  ;  Public Member Functions inherited from TApplication;  TApplication (const char *appClassName, Int_t *argc, char **argv, void *options=nullptr, Int_t numOptions=0);  Create an application environment. ;  ; virtual ~TApplication ();  T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:1744,avail,available,1744,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['avail'],['available']
Availability,"anup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. static RooCFunction1Map<double,double>*_fmapPointer to mapping service object; RooCFunction1Ref<double,double>::func_t_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCFunction1Map<double,double>& RooCFunction1Ref<double,double> fmap(); Return reference to function pointer-to-name mapping service. void RooCFunction1Ref<VO,VI> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registered name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(double x) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. VO dummyFunction(double ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Jun 2 13:07:08 2015 » Last generated: 2015-06-02 13:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Ref_double_double_.html:7392,ERROR,ERROR,7392,root/html602/RooCFunction1Ref_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Ref_double_double_.html,1,['ERROR'],['ERROR']
Availability,"anup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. static RooCFunction1Map<double,double>*_fmapPointer to mapping service object; RooCFunction1Ref<double,double>::func_t_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCFunction1Map<double,double>& RooCFunction1Ref<double,double> fmap(); Return reference to function pointer-to-name mapping service. void RooCFunction1Ref<VO,VI> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registered name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(double x) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. VO dummyFunction(double ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Jun 2 15:28:21 2015 » Last generated: 2015-06-02 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction1Ref_double_double_.html:7392,ERROR,ERROR,7392,root/html604/RooCFunction1Ref_double_double_.html,https://root.cern,https://root.cern/root/html604/RooCFunction1Ref_double_double_.html,1,['ERROR'],['ERROR']
Availability,"anvas along X in CM. ;  ; Size_t fYsizeReal;  Current size of canvas along Y in CM. ;  ; Size_t fYsizeUser;  User specified size of canvas along Y in CM. ;  ;  Protected Attributes inherited from TPad; Bool_t fAbsCoord;  Use absolute coordinates. ;  ; Double_t fAbsHNDC;  Absolute Height of pad along Y in NDC. ;  ; Double_t fAbsPixeltoXk;  Conversion coefficient for absolute pixel to X World. ;  ; Double_t fAbsPixeltoYk;  Conversion coefficient for absolute pixel to Y World. ;  ; Double_t fAbsWNDC;  Absolute Width of pad along X in NDC. ;  ; Double_t fAbsXlowNDC;  Absolute X top left corner of pad in NDC [0,1]. ;  ; Double_t fAbsYlowNDC;  Absolute Y top left corner of pad in NDC [0,1]. ;  ; Double_t fAspectRatio;  ratio of w/h in case of fixed ratio ;  ; Short_t fBorderMode;  Bordermode (-1=down, 0 = no border, 1=up) ;  ; Short_t fBorderSize;  pad bordersize in pixels ;  ; TCanvas * fCanvas {nullptr};  ! Pointer to mother canvas ;  ; Int_t fCGnx;  ! Size of the collide grid along x ;  ; Int_t fCGny;  ! Size of the collide grid along y ;  ; std::vector< Bool_t > fCollideGrid;  ! Grid used to find empty space when adding a box (Legend) in a pad ;  ; Bool_t fCopyGLDevice;  ! ;  ; Int_t fCrosshair;  Crosshair type (0 if no crosshair requested) ;  ; Int_t fCrosshairPos;  Position of crosshair. ;  ; Bool_t fEditable;  True if canvas is editable. ;  ; Bool_t fEmbeddedGL;  ! ;  ; TList * fExecs {nullptr};  List of commands to be executed when a pad event occurs. ;  ; Bool_t fFixedAspectRatio;  True if fixed aspect ratio. ;  ; TFrame * fFrame {nullptr};  ! Pointer to 2-D frame (if one exists) ;  ; Int_t fGLDevice;  ! OpenGL off-screen pixmap identifier ;  ; Bool_t fGridx;  Set to true if grid along X. ;  ; Bool_t fGridy;  Set to true if grid along Y. ;  ; Double_t fHNDC;  Height of pad along Y in Normalized Coordinates (NDC) ;  ; Int_t fLogx;  (=0 if X linear scale, =1 if log scale) ;  ; Int_t fLogy;  (=0 if Y linear scale, =1 if log scale) ;  ; Int_t fLogz;  (=0 if Z linear s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:54926,down,down,54926,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,4,['down'],['down']
Availability,"anvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject *prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCanvas.html:39995,down,down,39995,root/html526/TCanvas.html,https://root.cern,https://root.cern/root/html526/TCanvas.html,1,['down'],['down']
Availability,"anvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCanvas.html:39989,down,down,39989,root/html528/TCanvas.html,https://root.cern,https://root.cern/root/html528/TCanvas.html,10,['down'],['down']
Availability,"anvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static Bool_t AreOverlapping (const TGeoBBox *box1, const TGeoMatrix *mat1, const TGeoBBox *box2, const TGeoMatrix *mat2) R__DEPRECATED(6;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Contains (const Double_t *point, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin);  ; static const char * DeclFileName ();  ; static Double_t DistFromInside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big());  ; static Double_t DistFromOutside (const Double_t *point, const Double_t *dir, Double_t dx, Double_t dy, Double_t dz, const Double_t *origin, Double_t stepmax=TGeoShape::Big());  ;  Static Public Member Functions inherited from TGeoShape; static Double_t Big ();  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Double_t ComputeEpsMch ();  Compute machine round-off double precision error as the smallest number that if added to 1.0 is different than 1.0. ;  ; static const char * DeclFileName ();  ; static Double_t DistToPhiMin (const Double_t *point, const Double_t *dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in=kTRUE);  compute distance from point (inside phi) to both phi planes. Return minimum. ;  ; static Double_t EpsMch ();  static function returning the machine round-off error ;  ; static TGeoMatrix * GetTran",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoBBox.html:14919,error,error,14919,doc/master/classTGeoBBox.html,https://root.cern,https://root.cern/doc/master/classTGeoBBox.html,1,['error'],['error']
Availability,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Double_tTGeoBBox::fDXX half-length; Double_tTGeoBBox::fDYY half-length; Double_tTGeoBBox::fDZZ half-length; TStringTNamed::fNameobject identifier; Double_tTGeoBBox::fOrigin[3]box origin; UInt_tTGeoShape::fShapeBitsshape bits; Int_tTGeoShape::fShapeIdshape id; TStringTNamed::fTitleobject title. private:. TGeoBoolNode*fNodetop boolean node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCompositeShape(); Default constructor. TGeoCompositeShape(const char* name, const char* expression); Default constructor. TGeoCompositeShape(const char* expression); Default constructor. TGeoCompositeShape(const char* name, TGeoBoolNode* node); Constructor with a Boolean node. ~TGeoCompositeShape(); destructor. Double_t Capacity() const; Computes capacity of this shape [length^3] by sampling with 1% error. void ComputeBBox(); compute bounding box of the sphere. void ComputeNormal(Double_t* point, Double_t* dir, Double_t* norm); Computes normal vector in POINT to the composite shape. Bool_t Contains(Double_t* point) const; Tests if point is inside the shape. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute closest distance from point px,py to each corner. Double_t DistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from outside point to this composite shape.; Check if the bounding box is crossed within the requested distance. Double_t DistFromInside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; Compute distance from inside point to outside of this composite shape. TGeoVolume * Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Divi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoCompositeShape.html:17615,error,error,17615,root/html528/TGeoCompositeShape.html,https://root.cern,https://root.cern/root/html528/TGeoCompositeShape.html,2,['error'],['error']
Availability,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName = 0); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTreeDataStore.html:10836,error,error,10836,root/html528/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html528/RooTreeDataStore.html,4,['error'],['error']
Availability,"anvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; const RooAbsArg*_cacheOwner! Object owning cache contents; TTree*_cacheTree! TTree holding the cached function values; RooArgSetRooAbsDataStore::_cachedVars; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Bool_t_defCtor! Was object constructed with default ctor?; static Int_t_defTreeBufSize; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; TTree*_treeTTree holding the data points; RooArgSetRooAbsDataStore::_vars; RooArgSet_varsww; RooRealVar*_wgtVarPointer to weight variable (if set); TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeDataStore(). RooTreeDataStore(TTree* t, const RooArgSet& vars, const char* wgtVarName); Constructor to facilitate reading of legacy RooDataSets. RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const char* wgtVarName = 0). RooTreeDataStore(const char* name, const char* title, const RooArgSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooTreeDataStore.html:10827,error,error,10827,root/html526/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html526/RooTreeDataStore.html,2,['error'],['error']
Availability,"ap G3 TRAP shape; TGeoTrapEditor TGeoTrap editor; TGeoTrd1 TRD1 shape class; TGeoTrd1Editor TGeoTrd1 editor; TGeoTrd2 TRD2 shape class; TGeoTrd2Editor TGeoTrd2 editor; TGeoTreeDialog List-Tree based dialog; TGeoTube cylindrical tube class; TGeoTubeEditor TGeoTube editor; TGeoTubeSeg cylindrical tube segment class; TGeoTubeSegEditor TGeoTubeSeg editor; TGeoUniformMagField Uniform magnetic field; TGeoUnion union node; TGeoVolume geometry volume descriptor; TGeoVolumeAssembly an assembly of volumes; TGeoVolumeDialog List-Tree based volume dialog; TGeoVolumeEditor TGeoVolume editor; TGeoVolumeMulti class to handle multiple volumes in one step; TGeoVoxelFinder voxel finder class; TGeoXtru extruded polygon class; TGeometry Structure for Matrices, Shapes and Nodes; TGlobal Global variable class; TGondzioSolver Gondzio Qp Solver class; TGraph Graph graphics class; TGraph2D Set of n x[n],y[n],z[n] points with 3-d graphics including Delaunay triangulation; TGraph2DErrors A 2D graph with error bars; TGraph2DPainter TGraph2D painter; TGraphAsymmErrors A graph with asymmetric error bars; TGraphBentErrors A graph with bent, asymmetric error bars; TGraphDelaunay Delaunay triangulation; TGraphEdge Graph edge class; TGraphEditor graph editor; TGraphErrors A graph with error bars; TGraphNode Graph node class; TGraphPainter TGraph painter; TGraphPolar Polar graph; TGraphPolargram Polar axis; TGraphQQ to create and to draw quantile-quantile plots; TGraphSmooth Graph Smoother; TGraphStruct Graph structure class; TGraphTime An array of objects evolving with time; TGrid ABC defining interface to GRID services; TGridCollection ABC managing collection of files on the Grid; TGridJDL ABC defining interface JDL generator; TGridJob ABC defining interface to a GRID job; TGridJobStatus ABC defining status of a Grid job; TGridJobStatusList ABC defining interface to a list of GRID jobs; TGridResult ABC defining interface to GRID result set; TGroupButton A user interface button in a group of buttons.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:91934,error,error,91934,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,12,['error'],['error']
Availability,"ap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; TGeoHMatrix*GetFirstMatrix() const; TGeoVolume*GetFirstVolume() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoOverlap.html:1778,error,error,1778,root/html528/TGeoOverlap.html,https://root.cern,https://root.cern/root/html528/TGeoOverlap.html,10,['error'],['error']
Availability,"ap<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooErrorVar(const char* name, const char* title, const RooRealVar& input); Construct an lvalue variable representing the error of RooRealVar input. RooErrorVar(const RooErrorVar& other, const char* name = 0). ~RooErrorVar(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return value, i.e. error on input variable. Bool_t hasBinning(const char* name) const; Return true if we have binning with given name. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning with given name. If no binning exists with such a name, clone the default; binning on the fly if so requested. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning with given name. If no binning exists with such a name, clone the default; binning on the fly if so requested. std::list<std::string> getBinningNames() const; Get a list of all binning names. An empty name implies the default binning.; A 0 pointer should be passed to getBinning in this case. void setBinning(const RooAbsBinning& binning, const char* name = 0); Store given binning with this variable under the given name. void setMin(const char* name, Double_t value); Set the lower bound of the range with the given name to the giv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooErrorVar.html:40936,error,error,40936,root/html534/RooErrorVar.html,https://root.cern,https://root.cern/root/html534/RooErrorVar.html,2,['error'],['error']
Availability,"ap<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooErrorVar(const char* name, const char* title, const RooRealVar& input); Construct an lvalue variable representing the error of RooRealVar input. RooErrorVar(const RooErrorVar& other, const char* name = 0). ~RooErrorVar(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return value, i.e. error on input variable. Bool_t hasBinning(const char* name) const; Return true if we have binning with given name. const RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE) const; Return binning with given name. If no binning exists with such a name, clone the default; binning on the fly if so requested. RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE); Return binning with given name. If no binning exists with such a name, clone the default; binning on the fly if so requested. void setBinning(const RooAbsBinning& binning, const char* name = 0); Store given binning with this variable under the given name. void setMin(const char* name, Double_t value); Set the lower bound of the range with the given name to the given value; If name is a null pointer, set the lower bound of the default range. void setMax(const char* name, Double_t value); Set the upper bound of the range with the given name to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooErrorVar.html:39045,error,error,39045,root/html532/RooErrorVar.html,https://root.cern,https://root.cern/root/html532/RooErrorVar.html,2,['error'],['error']
Availability,"ap<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction3Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Mar 10 17:15:18 2015 » Last generated: 2015-03-10 17:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Binding_double_double_int_int_.html:37093,ERROR,ERROR,37093,root/html534/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Binding_double_double_int_int_.html,1,['ERROR'],['ERROR']
Availability,"ap<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction3Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 2 13:07:43 2015 » Last generated: 2015-06-02 13:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html:38695,ERROR,ERROR,38695,root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,1,['ERROR'],['ERROR']
Availability,"ap<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. TObject* clone(const char* newname) const; { return new RooCFunction3Binding(*this,newname); }. void printArgs(ostream& os) const; Print object arguments and name/address of function pointer. Double_t evaluate() const; Return value of embedded function using value of referenced variable x. » Last changed: Tue Jun 2 15:28:57 2015 » Last generated: 2015-06-02 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooCFunction3Binding_double_unsigned_int_double_double_.html:38695,ERROR,ERROR,38695,root/html604/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html604/RooCFunction3Binding_double_unsigned_int_double_double_.html,1,['ERROR'],['ERROR']
Availability,"ape(const TShape&); TShape(const char* name, const char* title, const char* material); virtual~TShape(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; TMaterial*GetMaterial() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TShape.html:1716,Error,Error,1716,root/html532/TShape.html,https://root.cern,https://root.cern/root/html532/TShape.html,2,['Error'],['Error']
Availability,"ape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tDistToSegZ(Double_t* point, Double_t* dir, Int_t& iz, Double_t c1, Double_t s1, Double_t c2, Double_t s2, Double_t cfio, Double_t sfio, Double_t cdfi) const; virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); Double_t&Dphi(); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const char*GetAxisName(Int_t iaxis) const; virtual Double_tGetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tGetByteCount() const; Double_tGetDphi() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoBBox::GetDZ() const; virtual Double_tTGeoBBox::GetFacetArea(Int_t index = 0) const; virtual Int_tTGeoBBox::GetFittingBox(const TGeoBBox* parambox, TGeoMatrix* ma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoPcon.html:3086,error,error,3086,root/html528/TGeoPcon.html,https://root.cern,https://root.cern/root/html528/TGeoPcon.html,4,['error'],['error']
Availability,"apeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); virtual voidRooAbsRealLValue::setValFast(Double_t value); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. RooLinkedList_altBinning!; RooLinTransBinning_binning; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branche",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:36025,Error,ErrorLoggingMode,36025,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,1,['Error'],['ErrorLoggingMode']
Availability,"apeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:36856,Error,ErrorLoggingMode,36856,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,2,['Error'],['ErrorLoggingMode']
Availability,"apeDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); virtual Bool_tRooAbsPdf::syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Double_tRooAbsReal::traceEval(const RooArgSet* set) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsPdf::ExtendMode { CanNotBeExtended; CanBeExtended; MustBeExtended; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealSumPdf.html:37190,Error,ErrorLoggingMode,37190,root/html532/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html532/RooRealSumPdf.html,2,['Error'],['ErrorLoggingMode']
Availability,"apeDirty(const RooAbsArg* source) const; voidsetSimCount(Int_t simCount); virtual voidRooAbsReal::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsReal::syncCache(const RooArgSet* set = 0); Double_tRooAbsReal::traceEval(const RooArgSet* set) const; virtual Bool_tRooAbsReal::traceEvalHook(Double_t) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum GOFOpMode { SimMaster; MPMaster; Slave; };; enum RooAbsReal::ScaleType { Raw; Relative; NumEvent; RelativeExpected; };; enum RooAbsReal::ErrorLoggingMode { PrintErrors; CollectErrors; CountErrors; Ignore; };; enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. string_addCoefRangeNameName of reference to be used for RooAddPdf components; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsTestStatistic.html:32806,Error,ErrorLoggingMode,32806,root/html534/RooAbsTestStatistic.html,https://root.cern,https://root.cern/root/html534/RooAbsTestStatistic.html,1,['Error'],['ErrorLoggingMode']
Availability,"aped marker (with 9 pixel); 2492 shape[0].x = -1 ; shape[0].y = 1;; 2493 shape[1].x = 1 ; shape[1].y = 1;; 2494 shape[2].x = -1 ; shape[2].y = 0;; 2495 shape[3].x = 1 ; shape[3].y = 0;; 2496 shape[4].x = -1 ; shape[4].y = -1;; 2497 shape[5].x = 1 ; shape[5].y = -1;; 2498 SetMarkerType(4,6,shape);; 2499 } else if (markerstyle == 8 || markerstyle == 20) {; 2500 // O shaped marker (filled); 2501 SetMarkerType(1,im*2,shape);; 2502 } else if (markerstyle == 21) {; 2503 // full square; 2504 shape[0].x = -im; shape[0].y = -im;; 2505 shape[1].x = im; shape[1].y = -im;; 2506 shape[2].x = im; shape[2].y = im;; 2507 shape[3].x = -im; shape[3].y = im;; 2508 shape[4].x = -im; shape[4].y = -im;; 2509 SetMarkerType(3,5,shape);; 2510 } else if (markerstyle == 22) {; 2511 // full triangle up; 2512 shape[0].x = -im; shape[0].y = im;; 2513 shape[1].x = im; shape[1].y = im;; 2514 shape[2].x = 0; shape[2].y = -im;; 2515 shape[3].x = -im; shape[3].y = im;; 2516 SetMarkerType(3,4,shape);; 2517 } else if (markerstyle == 23) {; 2518 // full triangle down; 2519 shape[0].x = 0; shape[0].y = im;; 2520 shape[1].x = im; shape[1].y = -im;; 2521 shape[2].x = -im; shape[2].y = -im;; 2522 shape[3].x = 0; shape[3].y = im;; 2523 SetMarkerType(3,4,shape);; 2524 } else if (markerstyle == 25) {; 2525 // open square; 2526 shape[0].x = -im; shape[0].y = -im;; 2527 shape[1].x = im; shape[1].y = -im;; 2528 shape[2].x = im; shape[2].y = im;; 2529 shape[3].x = -im; shape[3].y = im;; 2530 shape[4].x = -im; shape[4].y = -im;; 2531 SetMarkerType(2,5,shape);; 2532 } else if (markerstyle == 26) {; 2533 // open triangle up; 2534 shape[0].x = -im; shape[0].y = im;; 2535 shape[1].x = im; shape[1].y = im;; 2536 shape[2].x = 0; shape[2].y = -im;; 2537 shape[3].x = -im; shape[3].y = im;; 2538 SetMarkerType(2,4,shape);; 2539 } else if (markerstyle == 27) {; 2540 // open losange; 2541 Int_t imx = Int_t(2.66*MarkerSizeReduced + 0.5);; 2542 shape[0].x =-imx; shape[0].y = 0;; 2543 shape[1].x = 0; shape[1].y = -im;; 2544 shape[",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:81352,down,down,81352,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['down'],['down']
Availability,"aph * SmoothLowess(TGraph* grin, Option_t* option = """", Double_t span = 0.67, Int_t iter = 3, Double_t delta = 0); Smooth data with Lowess smoother*-*-. This function performs the computations for the LOWESS smoother; (see the reference below). Lowess returns the output points; x and y which give the coordinates of the smooth. Arguments:; grin: Input graph. span: the smoother span. This gives the proportion of points in the plot; which influence the smooth at each value.; Larger values give more smoothness.; iter: the number of robustifying iterations which should be performed.; Using smaller values of iter will make lowess run faster.; delta: values of x which lie within delta of each other replaced by a; single value in the output from lowess.; For delta = 0, delta will be calculated. References:; Cleveland, W. S. (1979) Robust locally weighted regression and smoothing; scatterplots. J. Amer. Statist. Assoc. 74, 829-836.; Cleveland, W. S. (1981) LOWESS: A program for smoothing scatterplots; by robust locally weighted regression.; The American Statistician, 35, 54. void Lowess(Double_t* x, Double_t* y, Int_t n, Double_t* ys, Double_t span, Int_t iter, Double_t delta); Lowess regression smoother*-*-*-*-*-. Based on R function clowess: Translated to C++ by C. Stratowa; (R source file: lowess.c by R Development Core Team (C) 1999-2001). -. void Lowest(Double_t* x, Double_t* y, Int_t n, Double_t& xs, Double_t& ys, Int_t nleft, Int_t nright, Double_t* w, Bool_t userw, Double_t* rw, Bool_t& ok); Fit value at x[i] *-*-*-*-*-*-*-*-*-. Based on R function lowest: Translated to C++ by C. Stratowa; (R source file: lowess.c by R Development Core Team (C) 1999-2001). -. TGraph * SmoothSuper(TGraph* grin, Option_t* option = """", Double_t bass = 0, Double_t span = 0, Bool_t isPeriodic = kFALSE, Double_t* w = 0); Smooth data with Super smoother*-*-*-. Smooth the (x, y) values by Friedman's ``super smoother''. Arguments:; grin: graph for smoothing. span: the fraction of the observat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphSmooth.html:9739,robust,robust,9739,root/html528/TGraphSmooth.html,https://root.cern,https://root.cern/root/html528/TGraphSmooth.html,6,['robust'],['robust']
Availability,"aphAsymmErrors normal constructor. ;  ;  ~TGraphAsymmErrors () override;  TGraphAsymmErrors default destructor. ;  ; virtual void AddPointError (Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.);  Add a point with asymmetric errorbars to the graph. ;  ; void Apply (TF1 *f) override;  Apply a function to all data points \( y = f(x,y) \). ;  ; virtual void BayesDivide (const TH1 *pass, const TH1 *total, Option_t *opt="""");  This function is only kept for backward compatibility. ;  ; void ComputeRange (Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const override;  Compute Range. ;  ; virtual void Divide (const TH1 *pass, const TH1 *total, Option_t *opt=""cp"");  Fill this TGraphAsymmErrors by dividing two 1-dimensional histograms pass/total. ;  ; Double_t GetErrorX (Int_t bin) const override;  Returns the combined error along X at point i by computing the average of the lower and upper variance. ;  ; Double_t GetErrorXhigh (Int_t i) const override;  Get high error on X. ;  ; Double_t GetErrorXlow (Int_t i) const override;  Get low error on X. ;  ; Double_t GetErrorY (Int_t bin) const override;  Returns the combined error along Y at point i by computing the average of the lower and upper variance. ;  ; Double_t GetErrorYhigh (Int_t i) const override;  Get high error on Y. ;  ; Double_t GetErrorYlow (Int_t i) const override;  Get low error on Y. ;  ; Double_t * GetEXhigh () const override;  ; Double_t * GetEXlow () const override;  ; Double_t * GetEYhigh () const override;  ; Double_t * GetEYlow () const override;  ; TClass * IsA () const override;  ; Int_t Merge (TCollection *list) override;  Adds all graphs with asymmetric errors from the collection to this graph. ;  ; TGraphAsymmErrors & operator= (const TGraphAsymmErrors &gr);  TGraphAsymmErrors assignment operator. ;  ; void Print (Option_t *chopt="""") const override;  Print graph and errors values. ;  ; void SavePrimitive (std::ostream &out, Option_t *option=""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:8424,error,error,8424,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,2,['error'],['error']
Availability,"aphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::Classstatic TClass * Class(); TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:27278,error,error,27278,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['error']
Availability,"aphBentErrors()TGraphBentErrors default constructor.Definition TGraphBentErrors.cxx:62; TGraphBentErrors::GetEXlowDouble_t * GetEXlow() const overrideDefinition TGraphBentErrors.h:80; TGraphBentErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphBentErrors.h:31; TGraphBentErrors::fEXlowdDouble_t * fEXlowd[fNpoints] array of X low displacementsDefinition TGraphBentErrors.h:33; TGraphBentErrors::fEYlowdDouble_t * fEYlowd[fNpoints] array of Y low displacementsDefinition TGraphBentErrors.h:35; TGraphBentErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphBentErrors.cxx:346; TGraphBentErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with asymmetric errors.Definition TGraphBentErrors.cxx:367; TGraphBentErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition TGraphBentErrors.h:83; TGraphBentErrors::GetErrorXlowDouble_t GetErrorXlow(Int_t bin) const overrideGet low error on X[i].Definition TGraphBentErrors.cxx:441; TGraphBentErrors::GetEYlowDouble_t * GetEYlow() const overrideDefinition TGraphBentErrors.h:82; TGraphBentErrors::GetEYhighdDouble_t * GetEYhighd() const overrideDefinition TGraphBentErrors.h:87; TGraphBentErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute range.Definition TGraphBentErrors.cxx:248; TGraphBentErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphBentErrors.h:81; TGraphBentErrors::GetEYlowdDouble_t * GetEYlowd() const overrideDefinition TGraphBentErrors.h:86; TGraphBentErrors::fEXhighdDouble_t * fEXhighd[fNpoints] array of X high displacementsDefinition TGraphBentErrors.h:34; TGraphBentErrors::GetEXhighdDouble_t * GetEXhighd() const overrideDefinition TGraphBentErrors.h:85; TGraphBentErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideGet high error on X[i].Definition TGraphBent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8h_source.html:7294,error,error,7294,doc/master/TGraphBentErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html,1,['error'],['error']
Availability,"aphBentErrors::GetErrorYDouble_t GetErrorY(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphBentErrors.cxx:416; TGraphBentErrors::fEYlowDouble_t * fEYlow[fNpoints] array of Y low errorsDefinition TGraphBentErrors.h:30; TGraphBentErrors::fEYhighdDouble_t * fEYhighd[fNpoints] array of Y high displacementsDefinition TGraphBentErrors.h:36; TGraphBentErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphBentErrors.cxx:278; TGraphBentErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphBentErrors.cxx:646; TGraphBentErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE***to arrays[***] or to f*** Copy points.Definition TGraphBentErrors.cxx:312; TGraphBentErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideGet low error on Y[i].Definition TGraphBentErrors.cxx:463; TGraphBentErrors::GetErrorXDouble_t GetErrorX(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphBentErrors.cxx:402; TGraphBentErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideGet high error on Y[i].Definition TGraphBentErrors.cxx:452; TGraphBentErrors::Applyvoid Apply(TF1 *f) overrideApply a function to all data points .Definition TGraphBentErrors.cxx:210; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::AllocateArraysDouble_t ** AllocateArrays(Int_t Narrays, Int_t arraySize)Allocate arrays.Definition TGraph.cxx:598; bool; double; int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; grTGraphErrors * grDefinition legend1.C:25. histhistincTGraphBentErrors.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8h_source.html:11052,error,error,11052,doc/master/TGraphBentErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8h_source.html,2,['error'],['error']
Availability,"aphMultiErrors assignment operator.Definition TGraphMultiErrors.cxx:599; TGraphMultiErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphMultiErrors.cxx:748; TGraphMultiErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphMultiErrors.cxx:1729; TGraphMultiErrors::fSumErrorsModeInt_t fSumErrorsModeHow y errors are summed: kOnlyFirst = Only First; kSquareSum = Squared Sum; kSum = Absolute Addition.Definition TGraphMultiErrors.h:33; TGraphMultiErrors::GetLineWidthvirtual Width_t GetLineWidth() constReturn the line width.Definition TAttLine.h:35; TGraphMultiErrors::GetEXhighDouble_t * GetEXhigh() const overrideDefinition TGraphMultiErrors.h:142; TGraphMultiErrors::kAbsSum@ kAbsSumCalculate the absolute sum of all errors.Definition TGraphMultiErrors.h:60; TGraphMultiErrors::kSquareSum@ kSquareSumCalculate the square sum of all errors.Definition TGraphMultiErrors.h:59; TGraphMultiErrors::kOnlyFirst@ kOnlyFirstOnly take errors from first dimension.Definition TGraphMultiErrors.h:58; TGraphMultiErrors::GetAttFillvirtual TAttFill * GetAttFill(Int_t e)Get AttFill pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1621; TGraphMultiErrors::SetLineStylevirtual void SetLineStyle(Int_t e, Style_t lstyle)Set Line Style of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2095; TGraphMultiErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphMultiErrors.cxx:777; TGraphMultiErrors::SetPointEXhighvirtual void SetPointEXhigh(Int_t i, Double_t exH)Set exH value for point i.Definition TGraphMultiErrors.cxx:1869; TGraphMultiErrors::fExLDouble_t * fExL[fNpoints] array of X low errorsDefinition TGraphMultiErrors.h:35; TGraphMultiEr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:81085,error,errors,81085,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"aphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 105/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 106 ; 107TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL,; 108 const Float_t *exH, const Float_t *eyL, const Float_t *eyH, Int_t m); 109 : TGraph(np, x, y), fNYErrors(1), fSumErrorsMode(m); 110{; 111 if (!CtorAllocate()); 112 return;; 113 ; 114 for (Int_t i = 0; i < fNpoints; i++) {; 115 if (exL); 116 fExL[i] = exL[i];; 117 else; 118 fExL[i] = 0.;; 119 if (exH); 120 fExH[i] = exH[i];; 121 else; 122 fExH[i] = 0.;; 123 if (eyL); 124 fEyL[0][i] = eyL[i];; 125 else; 126 fEyL[0][i] = 0.;; 127 if (eyH); 128 fEyH[0][i] = eyH[i];; 129 else; 130 fEyH[0][i] = 0.;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3865,error,error,3865,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"aphMultiErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set Note: This function should be called only fro...Definition TGraphMultiErrors.cxx:718; TGraphMultiErrors::fExHDouble_t * fExH[fNpoints] array of X high errorsDefinition TGraphMultiErrors.h:36; TGraphMultiErrors::SetPointEYvirtual void SetPointEY(Int_t i, Int_t ne, const Double_t *eyL, const Double_t *eyH)Set ey values for point i.Definition TGraphMultiErrors.cxx:1885; TGraphMultiErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exL)Set exL value for point i.Definition TGraphMultiErrors.cxx:1853; TGraphMultiErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH)Set eyH values for point i.Definition TGraphMultiErrors.cxx:1907; TGraphMultiErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphMultiErrors.cxx:1379; TGraphMultiErrors::fNYErrorsInt_t fNYErrorsThe amount of different y-errors.Definition TGraphMultiErrors.h:32; TGraphMultiErrors::fEyLstd::vector< TArrayD > fEyLTwo dimensional array of Y low errors.Definition TGraphMultiErrors.h:37; TGraphMultiErrors::GetErrorYDouble_t GetErrorY(Int_t i) const overrideGet error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1454; TGraphMultiErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for size points.Definition TGraphMultiErrors.cxx:933; TGraphMultiErrors::DoMergeBool_t DoMerge(const TGraph *tg) overrideProtected function to perform the merge operation of a graph with multiple asymmetric errors.Definition TGraphMultiErrors.cxx:838; TGraphMultiErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t i) const overrideGet high error on y coordinate for point i.Definition TGraphMultiErrors.cxx:1530; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TH1TH1 is the base class of all histogram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html:25074,error,errors,25074,doc/master/TGraphMultiErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8h_source.html,1,['error'],['errors']
Availability,"app);; 99 ; 100public:; 101 TApplication(const char *appClassName, Int_t *argc, char **argv,; 102 void *options = nullptr, Int_t numOptions = 0);; 103 virtual ~TApplication();; 104 ; 105 void InitializeGraphics(Bool_t only_web = kFALSE);; 106 virtual void GetOptions(Int_t *argc, char **argv);; 107 TSignalHandler *GetSignalHandler() const { return fSigHandler; }; 108 virtual void SetEchoMode(Bool_t mode);; 109 TString GetSetup();; 110 void OpenForumTopic(const TString & type);; 111 void OpenGitHubIssue(const TString & type);; 112 void OpenInBrowser(const TString & url);; 113 void OpenReferenceGuideFor(const TString & strippedClass);; 114 virtual void HandleException(Int_t sig);; 115 virtual void HandleIdleTimer(); //*SIGNAL*; 116 virtual Bool_t HandleTermInput() { return kFALSE; }; 117 virtual void Init() { fAppImp->Init(); }; 118 virtual Longptr_t ProcessLine(const char *line, Bool_t sync = kFALSE, Int_t *error = nullptr);; 119 virtual Longptr_t ProcessFile(const char *file, Int_t *error = nullptr, Bool_t keep = kFALSE);; 120 virtual void Run(Bool_t retrn = kFALSE);; 121 virtual void SetIdleTimer(UInt_t idleTimeInSec, const char *command);; 122 virtual void RemoveIdleTimer();; 123 const char *GetIdleCommand() const { return fIdleCommand; }; 124 virtual void StartIdleing();; 125 virtual void StopIdleing();; 126 EExitOnException ExitOnException(EExitOnException opt = kExit);; 127 ; 128 virtual const char *ApplicationName() const { return fAppImp->ApplicationName(); }; 129 virtual void Show() { fAppImp->Show(); }; 130 virtual void Hide() { fAppImp->Hide(); }; 131 virtual void Iconify() { fAppImp->Iconify(); }; 132 virtual void Open() { fAppImp->Open(); }; 133 virtual void Raise() { fAppImp->Raise(); }; 134 virtual void Lower() { fAppImp->Lower(); }; 135 virtual Bool_t IsCmdThread() { return fAppImp ? fAppImp->IsCmdThread() : kTRUE; }; 136 virtual TApplicationImp *GetApplicationImp() { return fAppImp;}; 137 ; 138 void ls(Option_t *option="""") const override;; 139 ; 140 I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:4865,error,error,4865,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['error'],['error']
Availability,"apped over to the std::any result.; 421/// The default value is `""_anyresult""`.; 422/// \return bool Returns `true` if the command was successfully executed,; 423/// otherwise returns `false`.; 424 ; 425Bool_t TPython::Exec(const char *cmd, std::any *result, std::string const &resultName); 426{; 427 // setup; 428 if (!Initialize()); 429 return kFALSE;; 430 ; 431 PyGILRAII gilRaii;; 432 ; 433 std::stringstream command;; 434 // Add the actual command; 435 command << cmd;; 436 // Swap the std::any with the one in the C++ world if required; 437 if (result) {; 438 command << ""; ROOT.Internal.SwapWithObjAtAddr['std::any']("" << resultName << "", ""; 439 << reinterpret_cast<std::intptr_t>(result) << "")"";; 440 }; 441 ; 442 // execute the command; 443 PyObject *pyObjectResult =; 444 PyRun_String(const_cast<char *>(command.str().c_str()), Py_file_input, gMainDict, gMainDict);; 445 ; 446 // test for error; 447 if (pyObjectResult) {; 448 Py_DECREF(pyObjectResult);; 449 return kTRUE;; 450 }; 451 ; 452 PyErr_Print();; 453 return kFALSE;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Evaluate a python expression (e.g. ""ROOT.TBrowser()"").; 458///; 459/// Caution: do not hold on to the return value: either store it in a builtin; 460/// type (implicit casting will work), or in a pointer to a ROOT object (explicit; 461/// casting to a void* is required).; 462///; 463/// \deprecated Use TPython::Exec() with an std::any output parameter instead.; 464 ; 465const TPyReturn TPython::Eval(const char *expr); 466{; 467 // setup; 468 if (!Initialize()); 469 return TPyReturn();; 470 ; 471 PyGILRAII gilRaii;; 472 ; 473 // evaluate the expression; 474 PyObject *result = PyRun_String(const_cast<char *>(expr), Py_eval_input, gMainDict, gMainDict);; 475 ; 476 // report errors as appropriate; return void; 477 if (!result) {; 478 PyErr_Print();; 479 return TPyReturn();; 480 }; 481 ; 482 // results that require no conversion; 483 if (result == Py_No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:15075,error,error,15075,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['error'],['error']
Availability,"apsulated object can be accessed via the arrow operator. Upon invocation of the arrow operator or dereferencing (operator*), the loop on the events and calculations of all scheduled actions are executed if needed. It is possible to iterate on the result proxy if the proxied object is a collection. for (auto& myItem : myResultProxy) { ... };; If iteration is not supported by the type of the proxied object, a compilation error is thrown. ; Definition at line 119 of file RResultPtr.hxx. Public Types; using Value_t = T;  Convenience alias to simplify access to proxied type. ;  . Public Member Functions;  RResultPtr ()=default;  ;  RResultPtr (const RResultPtr &)=default;  ; template<typename T2 , std::enable_if_t< std::is_constructible< std::shared_ptr< T >, std::shared_ptr< T2 > >::value, int > = 0> ;  RResultPtr (const RResultPtr< T2 > &r);  Convert a RResultPtr<T2> to a RResultPtr<T>. ;  ;  RResultPtr (RResultPtr &&)=default;  ; RIterationHelper< T >::Iterator_t begin ();  Return an iterator to the beginning of the contained object if this makes sense, throw a compilation error otherwise. ;  ; RIterationHelper< T >::Iterator_t end ();  Return an iterator to the end of the contained object if this makes sense, throw a compilation error otherwise. ;  ; T * GetPtr ();  Get the pointer to the encapsulated object. ;  ; const T & GetValue ();  Get a const reference to the encapsulated object. ;  ; bool IsReady () const;  Check whether the result has already been computed. ;  ; RResultPtr< T > & OnPartialResult (ULong64_t everyNEvents, std::function< void(T &)> callback);  Register a callback that RDataFrame will execute ""everyNEvents"" on a partial result. ;  ; RResultPtr< T > & OnPartialResultSlot (ULong64_t everyNEvents, std::function< void(unsigned int, T &)> callback);  Register a callback that RDataFrame will execute in each worker thread concurrently on that thread's partial result. ;  ;  operator bool () const;  ; T & operator* ();  Get a pointer to the encapsulated ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html:1822,error,error,1822,doc/master/classROOT_1_1RDF_1_1RResultPtr.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RResultPtr.html,1,['error'],['error']
Availability,"ar * TUnixSystem::PrependPathName ; (; const char * ; dir, . TString & ; name . ). overridevirtual . Concatenate a directory and a file name. ; Reimplemented from TSystem.; Definition at line 1552 of file TUnixSystem.cxx. ◆ RecvBuf(). int TUnixSystem::RecvBuf ; (; int ; sock, . void * ; buf, . int ; length . ). overridevirtual . Receive a buffer headed by a length indicator. ; Length is the size of the buffer. Returns the number of bytes received in buf or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3316 of file TUnixSystem.cxx. ◆ RecvRaw(). int TUnixSystem::RecvRaw ; (; int ; sock, . void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Receive exactly length bytes into buffer. ; Use opt to receive out-of-band data or to have a peek at what is in the buffer (see TSocket). Buffer must be able to store at least length bytes. Returns the number of bytes received (can be 0 if other side of connection was closed) or -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 3368 of file TUnixSystem.cxx. ◆ RedirectOutput(). Int_t TUnixSystem::RedirectOutput ; (; const char * ; file, . const char * ; mode = ""a"", . RedirectHandle_t * ; h = nullptr . ). overridevirtual . Redirect standard output (stdout, stderr) to the specified file. ; If the file argument is 0 the output is set again to stderr, stdout. The second argument specifies whether the output should be added to the file (""a"", default) or the file be truncated before (""w""). This function saves internally the current state into a static structure. The call can be made reentrant by specifying the opaque structure pointed by 'h', which is filled with the relevant information. The handle 'h' obtained on the first call must then be used in any subsequent call, inclu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:61935,error,error,61935,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability,"ar *extensions,; 18428 mg_websocket_data_handler data_func,; 18429 mg_websocket_close_handler close_func,; 18430 void *user_data); 18431{; 18432 struct mg_client_options client_options;; 18433 memset(&client_options, 0, sizeof(client_options));; 18434 client_options.host = host;; 18435 client_options.port = port;; 18436 ; 18437 return mg_connect_websocket_client_impl(&client_options,; 18438 use_ssl,; 18439 error_buffer,; 18440 error_buffer_size,; 18441 path,; 18442 origin,; 18443 extensions,; 18444 data_func,; 18445 close_func,; 18446 user_data);; 18447}; 18448 ; 18449struct mg_connection *; 18450mg_connect_websocket_client_secure_extensions(; 18451 const struct mg_client_options *client_options,; 18452 char *error_buffer,; 18453 size_t error_buffer_size,; 18454 const char *path,; 18455 const char *origin,; 18456 const char *extensions,; 18457 mg_websocket_data_handler data_func,; 18458 mg_websocket_close_handler close_func,; 18459 void *user_data); 18460{; 18461 if (!client_options) {; 18462 return NULL;; 18463 }; 18464 return mg_connect_websocket_client_impl(client_options,; 18465 1,; 18466 error_buffer,; 18467 error_buffer_size,; 18468 path,; 18469 origin,; 18470 extensions,; 18471 data_func,; 18472 close_func,; 18473 user_data);; 18474}; 18475 ; 18476/* Prepare connection data structure */; 18477static void; 18478init_connection(struct mg_connection *conn); 18479{; 18480 /* Is keep alive allowed by the server */; 18481 int keep_alive_enabled =; 18482 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], ""yes"");; 18483 ; 18484 if (!keep_alive_enabled) {; 18485 conn->must_close = 1;; 18486 }; 18487 ; 18488 /* Important: on new connection, reset the receiving buffer. Credit; 18489 * goes to crule42. */; 18490 conn->data_len = 0;; 18491 conn->handled_requests = 0;; 18492 conn->connection_type = CONNECTION_TYPE_INVALID;; 18493 mg_set_user_connection_data(conn, NULL);; 18494 ; 18495#if defined(USE_SERVER_STATS); 18496 conn->conn_state = 2; /* init */; 18497#endif; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:547966,alive,alive,547966,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['alive'],['alive']
Availability,"ar *extensions,; 18429 mg_websocket_data_handler data_func,; 18430 mg_websocket_close_handler close_func,; 18431 void *user_data); 18432{; 18433 struct mg_client_options client_options;; 18434 memset(&client_options, 0, sizeof(client_options));; 18435 client_options.host = host;; 18436 client_options.port = port;; 18437 ; 18438 return mg_connect_websocket_client_impl(&client_options,; 18439 use_ssl,; 18440 error_buffer,; 18441 error_buffer_size,; 18442 path,; 18443 origin,; 18444 extensions,; 18445 data_func,; 18446 close_func,; 18447 user_data);; 18448}; 18449 ; 18450struct mg_connection *; 18451mg_connect_websocket_client_secure_extensions(; 18452 const struct mg_client_options *client_options,; 18453 char *error_buffer,; 18454 size_t error_buffer_size,; 18455 const char *path,; 18456 const char *origin,; 18457 const char *extensions,; 18458 mg_websocket_data_handler data_func,; 18459 mg_websocket_close_handler close_func,; 18460 void *user_data); 18461{; 18462 if (!client_options) {; 18463 return NULL;; 18464 }; 18465 return mg_connect_websocket_client_impl(client_options,; 18466 1,; 18467 error_buffer,; 18468 error_buffer_size,; 18469 path,; 18470 origin,; 18471 extensions,; 18472 data_func,; 18473 close_func,; 18474 user_data);; 18475}; 18476 ; 18477/* Prepare connection data structure */; 18478static void; 18479init_connection(struct mg_connection *conn); 18480{; 18481 /* Is keep alive allowed by the server */; 18482 int keep_alive_enabled =; 18483 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_KEEP_ALIVE], ""yes"");; 18484 ; 18485 if (!keep_alive_enabled) {; 18486 conn->must_close = 1;; 18487 }; 18488 ; 18489 /* Important: on new connection, reset the receiving buffer. Credit; 18490 * goes to crule42. */; 18491 conn->data_len = 0;; 18492 conn->handled_requests = 0;; 18493 conn->connection_type = CONNECTION_TYPE_INVALID;; 18494 mg_set_user_connection_data(conn, NULL);; 18495 ; 18496#if defined(USE_SERVER_STATS); 18497 conn->conn_state = 2; /* init */; 18498#endif; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:547999,alive,alive,547999,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['alive'],['alive']
Availability,"ar *location, const char *fmt, va_list va) constTObjectprotectedvirtual; DoMerge(const TGraph *tg) overrideTGraphMultiErrorsprotectedvirtual; Draw(Option_t *chopt="""") overrideTGraphvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; DrawGraph(Int_t n, const Int_t *x, const Int_t *y, Option_t *option="""")TGraphvirtual; DrawGraph(Int_t n, const Float_t *x, const Float_t *y, Option_t *option="""")TGraphvirtual; DrawGraph(Int_t n, const Double_t *x=nullptr, const Double_t *y=nullptr, Option_t *option="""")TGraphvirtual; DrawPanel()TGraphvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTGraph; ESummationModes enum nameTGraphMultiErrors; Eval(Double_t x, TSpline *spline=nullptr, Option_t *option="""") constTGraphvirtual; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideTGraphvirtual; Expand(Int_t newsize)TGraphvirtual; Expand(Int_t newsize, Int_t step)TGraphvirtual; ExpandAndCopy(Int_t size, Int_t iend)TGraphprotected; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fAttFillTGraphMultiErrorsprotected; fAttLineTGraphMultiErrorsprotected; fBitsTObjectprivate; fExHTGraphMultiErrorsprotected; fExLTGraphMultiErrorsprotected; fEyHTGraphMultiErrorsprotected; fEyHSumTGraphMultiErrorsmutableprotected; fEyLTGraphMultiErrorsprotected; fEyLSumTGraphMultiErrorsmutableprotected; fFillColorTAttFillprotected; fFillStyleTAttFillprotected; fFunctionsTGraphprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; fHistogramTGraphprotected; FillBuffer(char *&buffer)TNamedvirtual; FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideTGraphMultiErrorsprotectedvirtual; FindObject(const char *name) const overrideTGraphvirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors-members.html:3540,error,error,3540,doc/master/classTGraphMultiErrors-members.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors-members.html,2,['error'],['error']
Availability,"ar *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTParallelCoordSelect.html:11416,error,error,11416,doc/master/classTParallelCoordSelect.html,https://root.cern,https://root.cern/doc/master/classTParallelCoordSelect.html,4,['error'],['error']
Availability,"ar *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCollection.html:7780,error,error,7780,doc/v632/classTCollection.html,https://root.cern,https://root.cern/doc/v632/classTCollection.html,30,['error'],['error']
Availability,"ar *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TList::Deletevoid Delete(Option_t *option="""") overrideRemove all objects from the list AND delete all heap based objects.Definition TList.cxx:468; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::UncheckedAtTObject * UncheckedAt(Int_t i) constDefinition TObjArray.h:84; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::SetUniqueIDvirtual void SetUniqueID(UInt_t uid)Set the unique object id.Definition TObject.cxx:797; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TProfileProfile Histogram.Definition TProfile.h:32; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TSystem::Execvirtual Int_t Exec(const char *shellcmd)Execute a command.Definition TSystem.cxx:653; TTreeFormulaUsed to pass a selection expression to the Tree drawing routine.Definition TTreeFormula.h:58; TTreeFormula::GetLeafvirtual TLeaf * GetLeaf(Int_t n) constReturn leaf corresponding to serial number n.Definition TTreeFormula.cxx:4465; TTreeFormula::GetNcodes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THbookFile_8cxx_source.html:42996,error,error,42996,doc/master/THbookFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THbookFile_8cxx_source.html,1,['error'],['error']
Availability,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLAttr.html:2754,error,error,2754,doc/master/classTXMLAttr.html,https://root.cern,https://root.cern/doc/master/classTXMLAttr.html,49,['error'],['error']
Availability,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns strin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLDocument.html:3098,error,error,3098,doc/master/classTXMLDocument.html,https://root.cern,https://root.cern/doc/master/classTXMLDocument.html,514,['error'],['error']
Availability,"ar *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual const char * GetName () const;  Returns name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTView.html:7305,error,error,7305,doc/master/classTView.html,https://root.cern,https://root.cern/doc/master/classTView.html,2,['error'],['error']
Availability,"ar * ; dir = nullptr, . const char * ; suffix = nullptr . ). overridevirtual . Create a secure temporary file by appending a unique 6 letter string to base. ; The file will be created in a standard (system) directory or in the directory provided in dir. Optionally one can provide suffix append to the final name - like extension "".txt"" or "".html"". The full filename is returned in base and a filepointer is returned for safely writing to the file (this avoids certain security problems). Returns 0 in case of error. ; Reimplemented from TSystem.; Definition at line 2281 of file TWinNTSystem.cxx. ◆ ThreadStub(). static void TWinNTSystem::ThreadStub ; (; void * ; Parameter). inlinestaticprivate . Definition at line 88 of file TWinNTSystem.h. ◆ TimerThread(). void TWinNTSystem::TimerThread ; (; ). private . Special Thread to check asynchronous timers. ; Definition at line 4442 of file TWinNTSystem.cxx. ◆ Umask(). int TWinNTSystem::Umask ; (; Int_t ; mask). overridevirtual . Set the process file creation mode mask. ; Reimplemented from TSystem.; Definition at line 3081 of file TWinNTSystem.cxx. ◆ UnixPathName(). const char * TWinNTSystem::UnixPathName ; (; const char * ; name). overridevirtual . Convert a pathname to a unix pathname. ; E.g. from \user\root to /user/root. General rules for applications creating names for directories and files or processing names supplied by the user include the following:. Use any character in the current code page for a name, but do not use a path separator, a character in the range 0 through 31, or any character explicitly disallowed by the file system. A name can contain characters in the extended character set (128-255).; Use the backslash (), the forward slash (/), or both to separate components in a path. No other character is acceptable as a path separator.; Use a period (.) as a directory component in a path to represent the current directory.; Use two consecutive periods (..) as a directory component in a path to represent the parent ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWinNTSystem.html:74067,mask,mask,74067,doc/master/classTWinNTSystem.html,https://root.cern,https://root.cern/doc/master/classTWinNTSystem.html,1,['mask'],['mask']
Availability,"ar * ; msgfmt, .  ; ... . ). Use this function for informational messages. ; Definition at line 218 of file TError.cxx. ◆ MayNotUse(). void MayNotUse ; (; const char * ; method). This function can be used in classes that should override a certain function, but in the inherited class the function makes no sense. ; Definition at line 168 of file TError.cxx. ◆ Obsolete(). void Obsolete ; (; const char * ; function, . const char * ; asOfVers, . const char * ; removedFromVers . ). Use this function to declare a function obsolete. ; Specify as of which version the method is obsolete and as from which version it will be removed. ; Definition at line 177 of file TError.cxx. ◆ SetErrorHandler(). ErrorHandlerFunc_t SetErrorHandler ; (; ErrorHandlerFunc_t ; newhandler). Set an errorhandler function. Returns the old handler. ; Definition at line 90 of file TError.cxx. ◆ SysError(). void SysError ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in case a system (OS or GUI) related error occurred. ; Definition at line 196 of file TError.cxx. ◆ Warning(). void Warning ; (; const char * ; location, . const char * ; msgfmt, .  ; ... . ). Use this function in warning situations. ; Definition at line 229 of file TError.cxx. Variable Documentation. ◆ gErrorAbortLevel. Int_t gErrorAbortLevel. extern . Definition at line 32 of file TError.cxx. ◆ gErrorIgnoreLevel. Int_t gErrorIgnoreLevel. extern . Error handling routines. ; This file defines a number of global error handling routines: Warning(), Error(), SysError() and Fatal(). They all take a location string (where the error happened) and a printf style format string plus vararg's. In the end these functions call an errorhandler function. Initially the MinimalErrorHandler, which is supposed to be replaced by the proper DefaultErrorHandler() ; Definition at line 31 of file TError.cxx. ◆ gPrintViaErrorHandler. Bool_t gPrintViaErrorHandler. extern . Definition at line 33 of file TError.cxx. ◆ kAssertMsg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8h.html:8200,error,error,8200,doc/master/TError_8h.html,https://root.cern,https://root.cern/doc/master/TError_8h.html,1,['error'],['error']
Availability,"ar * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . #include <TProofServ.h>. Inheritance diagram for TProofLockPath:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TProofLockPath(). TProofLockPath::TProofLockPath ; (; const char * ; path). inline . Definition at line 354 of file TProofServ.h. ◆ ~TProofLockPath(). TProofLockPath::~TProofLockPath ; (; ). inlineoverride . Definition at line 355 of file TProofServ.h. Member Function Documentation. ◆ IsLocked(). Bool_t TProofLockPath::IsLocked ; (; ); const. inline . Definition at line 360 of file TProofServ.h. ◆ Lock(). Int_t TProofLockPath::Lock ; (; ). Locks the directory. ; Waits if lock is hold by an other process. Returns 0 on success, -1 in case of error. ; Definition at line 6986 of file TProofServ.cxx. ◆ Unlock(). Int_t TProofLockPath::Unlock ; (; ). Unlock the directory. ; Returns 0 in case of success, -1 in case of error. ; Definition at line 7022 of file TProofServ.cxx. Member Data Documentation. ◆ fLockId. Int_t TProofLockPath::fLockId. private . Definition at line 351 of file TProofServ.h. proof/proof/inc/TProofServ.h; proof/proof/src/TProofServ.cxx. TProofLockPath. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLockPath.html:11580,error,error,11580,doc/master/classTProofLockPath.html,https://root.cern,https://root.cern/doc/master/classTProofLockPath.html,2,['error'],['error']
Availability,"ar : number of variable parameters; nparx : total number of parameters. Double_t GetSumLog(Int_t ); return Sum(log(i) i=0,n; used by log likelihood fits. void InvertZ(Int_t ); Inverts packed diagonal matrix Z by square-root method.; Matrix elements corresponding to; fix parameters are removed. n: number of variable parameters. Bool_t IsFixed(Int_t ipar) const; return kTRUE if parameter ipar is fixed, kFALSE othersise). Int_t Minimize(); *; FUMILI; Based on ideas, proposed by I.N. Silin; [See NIM A440, 2000 (p431)]; converted from FORTRAN to C by; Sergey Yaschenko <s.yaschenko@fz-juelich.de>. *. This function is called after setting theoretical function; by means of TFumili::SetUserFunc and initializing parameters.; Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); If FCN is undefined then user has to provide data arrays by calling; TFumili::SetData procedure. TFumili::Minimize return following values:; 0 - fit is converged; -2 - function is not decreasing (or bad derivatives); -3 - error estimations are infinite; -4 - maximum number of iterations is exceeded. void PrintResults(Int_t k, Double_t p) const; Prints fit results. ikode is the type of printing parameters; p is function value. ikode = 1 - print values, errors and limits; ikode = 2 - print values, errors and steps; ikode = 3 - print values, errors, steps and derivatives; ikode = 4 - print only values and errors. void ReleaseParameter(Int_t ipar); Releases parameter number ipar. void SetData(Double_t* , Int_t , Int_t ); Sets pointer to data array provided by user.; Necessary if SetFCN is not called. numpoints: number of experimental points; vecsize: size of data point vector + 2; (for N-dimensional fit vecsize=N+2); exdata: data array with following format. exdata[0] = ExpValue_0 - experimental data value number 0; exdata[1] = ExpSigma_0 - error of value number 0; exdata[2] = X_0[0]; exdata[3] = X_0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:20903,error,error,20903,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,10,['error'],['error']
Availability,"ar Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; Strlen.h; TBrowser.h; TBuffer.h; TClassTable.h; TClass.h; tcling_callfunc_Wrapper_tvoid(* tcling_callfunc_Wrapper_t)(void *, int, void **, void *)Definition TClingCallFunc.h:56; GetCurrentDirectoryLockstatic std::atomic_flag * GetCurrentDirectoryLock()Definition TDirectory.cxx:36; R__CreateBufferstatic TBuffer * R__CreateBuffer()Fast execution of 'new TBufferFile(TBuffer::kWrite,10000), without having a compile time circular dep...Definition TDirectory.cxx:336; kMaxLenconst Int_t kMaxLenDefinition TDirectory.cxx:34; TDirectory.h; gDirectory#define gDirectoryDefinition TDirectory.h:384; TError.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; maskOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t maskDefinition TGWin32VirtualXProxy.cxx:178; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:52536,mask,maskDefinition,52536,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['mask'],['maskDefinition']
Availability,"ar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& ); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealVar.html:46935,error,errors,46935,root/html534/RooRealVar.html,https://root.cern,https://root.cern/root/html534/RooRealVar.html,12,['error'],['errors']
Availability,"ar for pretty printing on RooPlot; parameter boxes. This function processes the named arguments; taken by paramOn() and translates them to an option string; parsed by RooRealVar::format(Int_t sigDigits, const char *options). TString * format(Int_t sigDigits, const char* options) const; Format numeric value of RooRealVar and its error in a variety of ways. To control what is shown use the following options; N = show name; H = hide value; E = show error; A = show asymmetric error instead of parabolic error (if available); U = show unit. To control how it is shown use these options; L = TLatex mode; X = Latex mode; Y = Latex table mode ( '=' replaced by '&' ); V = Make name \verbatim in Latex mode; P = use error to control shown precision; F = force fixed precision. Double_t chopAt(Double_t what, Int_t where) const; Utility to calculate number of decimals to show; based on magnitude of error. void attachToVStore(RooVectorDataStore& vstore); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void attachToTree(TTree& t, Int_t bufSize = 32000); Overload RooAbsReal::attachToTree to also attach; branches for errors and/or asymmetric errors; attribute StoreError and/or StoreAsymError are set. void fillTreeBranch(TTree& t); Overload RooAbsReal::fillTreeBranch to also; fill tree branches with (asymmetric) errors; if requested. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); Copy the cached value of another RooAbsArg to our cache; Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void Streamer(TBuffer& b); Stream an object of class RooRealVar. void deleteSharedProperties(); No longer used?. void printScientific(Bool_t flag = kFALSE); If true, contents of RooRealVars will be printed in scientific notation. void printSigDigits(Int_t ndig = 5); Set number of digits",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:44873,error,errors,44873,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,4,['error'],['errors']
Availability,"ar is total parameters; intROOT::Fit::FitResult::fCovStatuscovariance matrix status code; doubleROOT::Fit::FitResult::fEdmexpected distance from mimimum; vector<double>ROOT::Fit::FitResult::fErrorserrors; shared_ptr<ROOT::Fit::FitData>ROOT::Fit::FitResult::fFitData! data set used in the fit; shared_ptr<ROOT::Fit::FitResult::IModelFunction>ROOT::Fit::FitResult::fFitFunc! model function resulting from the fit.; map<unsigned int,bool>ROOT::Fit::FitResult::fFixedParamslist of fixed parameters; vector<double>ROOT::Fit::FitResult::fGlobalCCglobal Correlation coefficient; stringROOT::Fit::FitResult::fMinimTypestring indicating type of minimizer; shared_ptr<ROOT::Math::Minimizer>ROOT::Fit::FitResult::fMinimizer! minimizer object used for fitting; map<unsigned int,pair<double,double> >ROOT::Fit::FitResult::fMinosErrorsmap contains the two Minos errors; unsigned intROOT::Fit::FitResult::fNCallsnumber of function calls; unsigned intROOT::Fit::FitResult::fNFreenumber of fit free parameters (total parameters are in size of parameter vector); TStringTNamed::fNameobject identifier; unsigned intROOT::Fit::FitResult::fNdfnumber of degree of freedom; boolROOT::Fit::FitResult::fNormalizedflag for indicating is errors are normalized; shared_ptr<ROOT::Math::IMultiGenFunction>ROOT::Fit::FitResult::fObjFunc! objective function used for fitting; vector<string>ROOT::Fit::FitResult::fParNamesparameter names (only with FCN only fits, when fFitFunc=0); vector<pair<double,double> >ROOT::Fit::FitResult::fParamBoundsparameter bounds; vector<double>ROOT::Fit::FitResult::fParamsparameter values. Size is total number of parameters; intROOT::Fit::FitResult::fStatusminimizer status code; TStringTNamed::fTitleobject title; doubleROOT::Fit::FitResult::fValminimum function value; boolROOT::Fit::FitResult::fValidflag for indicating valid fit. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFitResult(const ROOT::Fit::FitResult& f); constructor from an IFitResult;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TFitResult.html:10738,error,errors,10738,root/html604/TFitResult.html,https://root.cern,https://root.cern/root/html604/TFitResult.html,4,['error'],['errors']
Availability,"ar& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Mon Jul 4 15:24:52 2011 » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooXYChi2Var.html:42767,error,error,42767,root/html530/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html530/RooXYChi2Var.html,2,['error'],['error']
Availability,"ar& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Sat Oct 9 06:58:49 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:41769,error,error,41769,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,2,['error'],['error']
Availability,"ar& other, const char* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Thu Nov 3 20:10:10 2011 » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:43528,error,error,43528,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,4,['error'],['error']
Availability,"ar(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; Int_tCollisions(const char* keyname) const; Int_tCollisions(TObject* key) const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDelete(Option_t* option = """"); voidDeleteAll(); Bool_tDeleteEntry(TObject* key); voidDeleteKeys(); voidDeleteValues(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTCollection::Dump() const; static voidTCollection::EmptyGarbageCollection(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* keyname) const; virtual TObject*FindObject(const TObject* key) const; static voidTCollection::GarbageCollect(TObject* obj); static TCollection*TCollection::GetCurrentCollection(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTCollection::GetEntries() const; virtual const char*TObject::GetIconName() const; virtual const char*TCollection::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; virtual TObject**GetObjectRef(const TObject* obj) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Int_tTCollection::GetSize() const; const THashTable*GetTable() const; virtual const char*TObject::GetTit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMap.html:2291,error,error,2291,root/html530/TMap.html,https://root.cern,https://root.cern/root/html530/TMap.html,5,['error'],['error']
Availability,"ar(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProofMgr::Close(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char* src, const char* dst = 0, const char* opts = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*TProofMgr::CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* what = ""~/"", const char* how = ""-type f"", const char* where = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char* remote, const char* local, const char* opt = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*GetMssUrl(Bool_t = kFALSE); virtual const char*TNamed::GetName() const; virtual char*TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXProofMgr.html:2073,Error,Error,2073,root/html534/TXProofMgr.html,https://root.cern,https://root.cern/root/html534/TXProofMgr.html,3,['Error'],['Error']
Availability,"ar(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTProofMgr::Close(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tCp(const char* src, const char* dst = 0, const char* opts = 0); static TProofMgr*TProofMgr::Create(const char* url, Int_t loglevel = -1, const char* alias = 0, Bool_t xpd = kTRUE); virtual TProof*TProofMgr::CreateSession(const char* = 0, const char* = 0, Int_t = -1); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDetachSession(Int_t, Option_t* = """"); virtual voidDetachSession(TProof*, Option_t* = """"); virtual voidTProofMgr::DiscardSession(TProof* p); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidFind(const char* what = ""~/"", const char* how = ""-type f"", const char* where = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetFile(const char* remote, const char* local, const char* opt = 0); virtual const char*TObject::GetIconName() const; static TList*TProofMgr::GetListOfManagers(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXProofMgr.html:2073,Error,Error,2073,root/html532/TXProofMgr.html,https://root.cern,https://root.cern/root/html532/TXProofMgr.html,1,['Error'],['Error']
Availability,"ar(const char* name = """", Long64_t val = 0); virtual~TSelectorScalar(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTParameter<Long64_t>::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TParameter<Long64_t>::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const long long&TParameter<Long64_t>::GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTParameter<Long64_t>::Hash() const; voidInc(Long_t n = 1); virtual voidTObject::Info(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSelectorScalar.html:1657,error,error,1657,root/html532/TSelectorScalar.html,https://root.cern,https://root.cern/root/html532/TSelectorScalar.html,4,['error'],['error']
Availability,"ar* dir, const char* name); virtual voidTNamed::Copy(TObject& named) const; virtual intCopyFile(const char* from, const char* to, Bool_t overwrite = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual const char*DirName(const char* pathname); virtual voidDispatchOneEvent(Bool_t pendingOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; char*DynamicPathName(const char* lib, Bool_t quiet = kFALSE); virtual Func_tDynFindSymbol(const char* module, const char* entry); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tExec(const char* shellcmd); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExit(int code, Bool_t mode = kTRUE); virtual voidExitLoop(); virtual Bool_tExpandPathName(TString& path); virtual char*ExpandPathName(const char* path); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual const char*FindDynamicLibrary(TString& lib, Bool_t quiet = kFALSE); virtual const char*FindFile(const char* search, TString& file, EAccessMode mode = kFileExists); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidFreeDirectory(void* dirp); virtual TSystem::EAclicModeGetAclicMode() const; virtual Int_tGetAclicProperties() const; voidGetBeepDefaults(Int_t& freq, Int_t& duration) const; virtual const char*GetBuildArch() const; virtual const char*GetBuildCompiler() const; virtual const char*GetBuildCompilerVersion() const; virtual const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:3510,error,error,3510,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,4,['error'],['error']
Availability,"ar* dst, Bool_t progressbar = kTRUE, UInt_t buffersize = 1000000); virtual TKey*CreateKey(TDirectory* mother, const TObject* obj, const char* name, Int_t bufsize); virtual TKey*CreateKey(TDirectory* mother, const void* obj, const TClass* cl, const char* name, Int_t bufsize); static TDirectory*&TDirectory::CurrentDirectory(); static TFile*&TFile::CurrentFile(); static voidTDirectory::DecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidTFile::Delete(const char* namecycle = """"); virtual voidTDirectory::DeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTFile::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawMap(const char* = ""*"", Option_t* = """"); virtual voidTObject::Dump() constMENU ; static voidTDirectory::EncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFillBuffer(char*&); virtual TKey*TDirectoryFile::FindKey(const char* keyname) const; virtual TKey*TDirectoryFile::FindKeyAny(const char* keyname) const; virtual TObject*TDirectory::FindObject(const char* name) const; virtual TObject*TDirectory::FindObject(const TObject* obj) const; virtual TObject*TDirectoryFile::FindObjectAny(const char* name) const; virtual TObject*TDirectoryFile::FindObjectAnyFile(const char* name) const; virtual voidFlush(); virtual TObject*TDirectoryFile::Get(const char* namecycle); TArchiveFile*TFile::GetArchive() const; Long64_tTFile::GetArchiveOffset() const; Int_tGetArrayLimit() const; stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSQLFile.html:9581,Error,Error,9581,root/html532/TSQLFile.html,https://root.cern,https://root.cern/root/html532/TSQLFile.html,1,['Error'],['Error']
Availability,"ar* filename = """", Option_t* option = """") constMENU ; virtual voidSavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTGeoBBox::SetBoxDimensions(Double_t dx, Double_t dy, Double_t dz, Double_t* origin = 0); voidTGeoBBox::SetBoxPoints(Double_t* points) const; virtual voidSetDimensions(Double_t* param); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTGeoShape::SetId(Int_t id); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetPoints(Double_t* points) const; virtual voidSetPoints(Float_t* points) const; voidTGeoShape::SetRuntime(Bool_t flag = kTRUE); virtual voidTGeoBBox::SetSegsAndPols(TBuffer3D& buffer) const; voidTGeoShape::SetShapeBit(UInt_t f); voidTGeoShape::SetShapeBit(UInt_t f, Bool_t set); virtual voidTNamed::SetTitle(const char* title = """")MENU ; static voidTGeoShape::SetTransform(TGeoMatrix* matrix); virtual voidTObject::SetUniqueID(UInt_t uid); Int_tTGeoShape::ShapeDistancetoPrimitive(Int_t numpoints, Int_t px, Int_t py) const; virtual voidShowMembers(TMemberInspector& insp); virtual Int_tTNamed::Sizeof() const; virtual voidSizeof3D() const; virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; Bool_tTGeoShape::TestShapeBit(UInt_t f) const; Int_tTGeoShape::TestShapeBits(UInt_t f) const; static Double_tTGeoShape::Tolerance(); virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPara.html:9906,Toler,Tolerance,9906,root/html532/TGeoPara.html,https://root.cern,https://root.cern/root/html532/TGeoPara.html,1,['Toler'],['Tolerance']
Availability,"ar* filename) const. Int_t Load(const char* filenam, Bool_t system = kFALSE). void LoadMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Int_t LoadLibraryMap(const char* rootmapfile = 0). Int_t RescanLibraryMap(). Int_t ReloadAllSharedLibraryMaps(). Int_t UnloadAllSharedLibraryMaps(). Int_t UnloadLibraryMap(const char* library). Long_t ProcessLine(const char* line, TInterpreter::EErrorCode* error = 0). Long_t ProcessLineSynch(const char* line, TInterpreter::EErrorCode* error = 0). void PrintIntro(). void SetGetline(char *(*)(const char* prompt) getlineFunc, void (*)(char* line) histaddFunc). void ResetAll(). void ResetGlobals(). void RewindDictionary(). Int_t DeleteGlobal(void* obj). void SaveContext(). void SaveGlobalsContext(). void UpdateListOfGlobals(). void UpdateListOfGlobalFunctions(). void UpdateListOfTypes(). void SetClassInfo(TClass* cl, Bool_t reload = kFALSE). Bool_t CheckClassInfo(const char* name, Bool_t autoload = kTRUE). Long_t Calc(const char* line, TInterpreter::EErrorCode* error = 0). void CreateListOfBaseClasses(TClass* cl). void CreateListOfDataMembers(TClass* cl). void CreateListOfMethods(TClass* cl). void CreateListOfMethodArgs(TFunction* m). void UpdateListOfMethods(TClass* cl). TString GetMangledName(TClass* cl, const char* method, const char* params). TString GetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto). const char * GetInterpreterTypeName(const char* name, Bool_t full = kFALSE). void * GetInterfaceMethod(TClass* cl, const char* method, const char* params). void * GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto). void Execute(const char* function, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0). void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0). Long_t ExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0). Bool_t IsEr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TInterpreter.html:19170,error,error,19170,root/html528/TInterpreter.html,https://root.cern,https://root.cern/root/html528/TInterpreter.html,1,['error'],['error']
Availability,"ar* filename); Process an additional configuration file. int fReadFile(const char* fileName, bool is_included = false); Parses the configuration file. The objects can be specified following; the rules of the RooFactoryWSTool, plus some more flexibility. The official format for the datacards is "".rs"". All the instructions end with a "";"" (like in C++). Carriage returns and white lines are irrelevant but adviced since they; improve readability (like in C++). The (Roo)ClassName::objname(description) can be replaced with the more; ""pythonic"" objname = (Roo)ClassName(description). The comments can be specified with a ""//"" if on a single line or with; /* */ if on multiple lines (like in C++). The ""#include path/to/file.rs"" statement triggers the inclusion of a; configuration fragment. The ""import myobject:myworkspace:myrootfile"" will add to the Workspace; the object myobject located in myworkspace recorded in myrootfile.; Alternatively, one could choose the ""import myobject:myrootfile"" in case; no Workspace is present. The ""echo"" statement prompts a message on screen. void fCreateCategory(); Builds the category necessary for the mutidimensional models. Its name; will be <HLFactory name>_category and the types are specified by the; model labels. bool fNamesListsConsistent(); Check the number of entries in each list. If not the same and the list; is not empty prompt an error. int fParseLine(TString& line); Parse a single line and puts the content in the RooWorkSpace. void DumpCfg(const char* ); Dump the Workspace content as configuration file; It needs some workspace object list or something.. { /* t.b.i. */ }. RooWorkspace* GetWs(); Get the RooWorkspace containing the models and variables. {return fWs;}. » Last changed: root/roostats:$Id: HLFactory.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HLFactory.html:9020,echo,echo,9020,root/html530/RooStats__HLFactory.html,https://root.cern,https://root.cern/root/html530/RooStats__HLFactory.html,2,"['echo', 'error']","['echo', 'error']"
Availability,"ar* filename); Process an additional configuration file. int fReadFile(const char* fileName, bool is_included = false); Parses the configuration file. The objects can be specified following; the rules of the RooFactoryWSTool, plus some more flexibility. The official format for the datacards is "".rs"". All the instructions end with a "";"" (like in C++). Carriage returns and white lines are irrelevant but adviced since they; improve readability (like in C++). The (Roo)ClassName::objname(description) can be replaced with the more; ""pythonic"" objname = (Roo)ClassName(description). The comments can be specified with a ""//"" if on a single line or with; /* */ if on multiple lines (like in C++). The ""#include path/to/file.rs"" statement triggers the inclusion of a; configuration fragment. The ""import myobject:myworkspace:myrootfile"" will add to the Workspace; the object myobject located in myworkspace recorded in myrootfile.; Alternatively, one could choose the ""import myobject:myrootfile"" in case; no Workspace is present. The ""echo"" statement prompts a message on screen. void fCreateCategory(); Builds the category necessary for the mutidimensional models. Its name; will be <HLFactory name>_category and the types are specified by the; model labels. bool fNamesListsConsistent(); Check the number of entries in each list. If not the same and the list; is not empty prompt an error. int fParseLine(TString& line); Parse a single line and puts the content in the RooWorkSpace. void DumpCfg(const char* ); Dump the Workspace content as configuration file; It needs some workspace object list or something.. { /* t.b.i. */ }. RooWorkspace* GetWs(); Get the RooWorkspace containing the models and variables. {return fWs;}. » Last changed: root/roostats:$Id: HLFactory.h 39391 2011-05-26 09:51:59Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HLFactory.html:9020,echo,echo,9020,root/html532/RooStats__HLFactory.html,https://root.cern,https://root.cern/root/html532/RooStats__HLFactory.html,4,"['echo', 'error']","['echo', 'error']"
Availability,"ar* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static doubledummyFunction(unsigned int, double, unsigned int). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static RooCFunction3Map<double,unsigned int,double,unsigned int>*_fmapPointer to mapping service object; void*_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(unsigned int x, double y, unsigned int z) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. return fmap(). VO dummyFunction(unsigned int , double , unsigned int ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Mar 10 17:15:34 2015 » Last generated: 2015-03-10 17:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_double_unsigned_int_.html:7246,ERROR,ERROR,7246,root/html534/RooCFunction3Ref_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_double_unsigned_int_.html,1,['ERROR'],['ERROR']
Availability,"ar* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static doubledummyFunction(unsigned int, unsigned int, double). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static RooCFunction3Map<double,unsigned int,unsigned int,double>*_fmapPointer to mapping service object; void*_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(unsigned int x, unsigned int y, double z) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. return fmap(). VO dummyFunction(unsigned int , unsigned int , double ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Mar 10 17:15:35 2015 » Last generated: 2015-03-10 17:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_unsigned_int_double_.html:7246,ERROR,ERROR,7246,root/html534/RooCFunction3Ref_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_unsigned_int_double_.html,1,['ERROR'],['ERROR']
Availability,"ar* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static doubledummyFunction(double, double, double, int). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static RooCFunction4Map<double,double,double,double,int>*_fmapPointer to mapping service object; void*_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction4Ref<VO,VI1,VI2,VI3,VI4> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(double x, double y, double z, int w) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. return fmap(). VO dummyFunction(double , double , double , int ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Mar 10 17:15:48 2015 » Last generated: 2015-03-10 17:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction4Ref_double_double_double_double_int_.html:7152,ERROR,ERROR,7152,root/html534/RooCFunction4Ref_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction4Ref_double_double_double_double_int_.html,1,['ERROR'],['ERROR']
Availability,"ar* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static doubledummyFunction(int). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static RooCFunction1Map<double,int>*_fmapPointer to mapping service object; void*_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCFunction1Map<double,int>& RooCFunction1Ref<double,int> fmap(); Return reference to function pointer-to-name mapping service. void RooCFunction1Ref<VO,VI> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registered name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(int x) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. VO dummyFunction(int ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Mar 10 17:14:49 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1Ref_double_int_.html:6936,ERROR,ERROR,6936,root/html534/RooCFunction1Ref_double_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1Ref_double_int_.html,1,['ERROR'],['ERROR']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBringOnTop()MENU ; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidDelete(const Option_t* options = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* options = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t entry, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual Color_tTAttLine::GetLineColor() const; virtual Style_tTAttLine::GetLineStyle() const; virtual Width_tTAttLine::GetLineWidth() const; virtual Double_tGetMax(); virtual Double_tGetMin(); virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TParallelCoordSelect*GetSelection(); virtual const char*TNamed::GetTitle() const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoordRange.html:1533,error,error,1533,root/html602/TParallelCoordRange.html,https://root.cern,https://root.cern/root/html602/TParallelCoordRange.html,4,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTGenerator::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGenerator::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGenerator::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEventListing() const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGenerator::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidGenerateEvent(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual TObjArray*TGenerator::GetListOfParticles() const; Int_tGetN() const; virtual const char*TNamed::GetName() const; Int_tTGenerator::GetNumberOfParticles() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual Double_tTGenerator::GetParameter(const char*) const; virtual TParticle*TGenerator::GetParticle(Int_t i) const; virtual TObjArray*TGenerator::GetPrimaries(Option_t* option = """"); Float_tTGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia8.html:4089,error,error,4089,root/html528/TPythia8.html,https://root.cern,https://root.cern/root/html528/TPythia8.html,10,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCreate(const char*); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; THttpServer*GetServer() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpEngine.html:1494,error,error,1494,root/html534/THttpEngine.html,https://root.cern,https://root.cern/root/html534/THttpEngine.html,6,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawSlice(Double_t pos) const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TGLLevelPalette&GetPalette() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLTH3Slice.html:1697,error,error,1697,root/html528/TGLTH3Slice.html,https://root.cern,https://root.cern/root/html528/TGLTH3Slice.html,10,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual RooSharedProperties*clone(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategorySharedProperties.html:1885,error,error,1885,root/html526/RooCategorySharedProperties.html,https://root.cern,https://root.cern/root/html526/RooCategorySharedProperties.html,12,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetArrayDim() const; Int_tGetArrayLength() const; TClass*GetClass() const; virtual TClass*GetClassPointer() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tGetExecID() const; Double_tGetFactor() const; virtual const char*GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tGetMaxIndex(Int_t i) const; virtual ULong_tGetMethod() const; virtual const char*TNamed::GetName() const; TClass*GetNewClass() const; Int_tGetNewType() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); Int_tGetOffset() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerElement.html:1530,error,error,1530,root/html528/TStreamerElement.html,https://root.cern,https://root.cern/root/html528/TStreamerElement.html,10,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Bool_tCannotSplit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tTStreamerElement::GetArrayDim() const; Int_tTStreamerElement::GetArrayLength() const; TClass*TStreamerElement::GetClass() const; virtual TClass*TStreamerElement::GetClassPointer() const; Int_tGetCtype() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Int_tTStreamerElement::GetExecID() const; Double_tTStreamerElement::GetFactor() const; virtual const char*TStreamerElement::GetFullName() const; virtual const char*TObject::GetIconName() const; virtual const char*GetInclude() const; Int_tTStreamerElement::GetMaxIndex(Int_t i) const; virtual ULong_tTStreamerElement::GetMethod() const; virtual const char*TNamed::GetNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStreamerSTL.html:1594,error,error,1594,root/html528/TStreamerSTL.html,https://root.cern,https://root.cern/root/html528/TStreamerSTL.html,10,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCenterLabels(Bool_t center = kTRUE)TOGGLE GETTER ; virtual voidCenterTitle(Bool_t center = kTRUE)TOGGLE GETTER ; const char*ChooseTimeFormat(Double_t axislength = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& axis) const; virtual voidDelete(Option_t* = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*DrawClone(Option_t* = """") const; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual Int_tFindBin(Double_t x); virtual Int_tFindBin(const char* label); virtual Int_tFindFixBin(Double_t x) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Color_tTAttAxis::GetAxisColor() const; virtual Double_tGetBinCenter(Int_t bin) const; virtual Double_tGetBinCenterLog(Int_t bin) const; const char*GetBinLabel(Int_t bin) const; virtual Double_tGetBinLowEdge(Int_t bin) const; virtual Double_tGetBinUpEdge(Int_t bin) const; virtual Double_tGetBinWidth(Int_t bin) const; virtual voidGetCenter(Double_t* center) const; Bool_tGetCenterLabels() const; Bool_tGetCenterTitle() const; Bool_tGetDecimals() const; virtual Option_t*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TAxis.html:1845,error,error,1845,root/html526/TAxis.html,https://root.cern,https://root.cern/root/html526/TAxis.html,7,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssign(const TProofNodeInfo& n); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TString&GetConfig() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TString&GetId() const; const TString&GetImage() const; const TString&GetMsd() const; virtual const char*GetName() const; const TString&GetNodeName() const; TProofNodeInfo::ENodeTypeGetNodeType() const; static TProofNodeInfo::ENodeTypeGetNodeType(const TString& type); Int_tGetNWrks() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&GetOrdinal() const; Int_tGetPerfIndex() const; Int_tGetPort() const; virtual const char*TObject::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofNodeInfo.html:1559,error,error,1559,root/html602/TProofNodeInfo.html,https://root.cern,https://root.cern/root/html602/TProofNodeInfo.html,4,['error'],['error']
Availability,"ar* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidAssign(const TProofNodeInfo& n); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const TString&GetConfig() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; const TString&GetId() const; const TString&GetImage() const; const TString&GetMsd() const; virtual const char*TObject::GetName() const; const TString&GetNodeName() const; TProofNodeInfo::ENodeTypeGetNodeType() const; static TProofNodeInfo::ENodeTypeGetNodeType(const TString& type); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const TString&GetOrdinal() const; Int_tGetPerfIndex() const; Int_tGetPort() const; virtual const char*TObject::GetTitle() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofNodeInfo.html:1658,error,error,1658,root/html528/TProofNodeInfo.html,https://root.cern,https://root.cern/root/html528/TProofNodeInfo.html,6,['error'],['error']
Availability,"ar* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; static voidNeedGraphicsLibs(); Bool_tNoLogoOpt() const; Bool_tNoLogOpt() const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; virtual voidOpen(); static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Long_tProcessFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); virtual Long_tProcessLine(const char* line, Bool_t sync = kFALSE, Int_t* error = 0); Bool_tQuitOpt() const; virtual voidRaise(); virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); virtual voidRemoveIdleTimer(); voidTObject::ResetBit(UInt_t f); Bool_tReturnFromRun() const; virtual voidReturnPressed(char* text)SIGNAL ; virtual voidRun(Bool_t retrn = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEchoMode(Bool_t mode); virtual voidSetIdleTimer(UInt_t idleTimeInSec, const char* command); static voidTObject::SetObjectStat(Bool_t stat); voidSetReturnFromRun(Bool_t ret); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShow(); virtual voidShowMembers(TMemberInspecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TApplication.html:7594,error,error,7594,root/html526/TApplication.html,https://root.cern,https://root.cern/root/html526/TApplication.html,2,['error'],['error']
Availability,"ar* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual Int_tTObject::Read(const char* name); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRemoveRootProxy(); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidSetDragPixmap(Pixmap_t pic, Pixmap_t mask, Int_t hot_x, Int_t hot_y); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetMainFrame(TGFrame* main); static voidTObject::SetObjectStat(Bool_t stat); Bool_tSetRootProxy(); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); Bool_tStartDrag(TGFrame* src, Int_t x_root, Int_t y_root, Window_t grabWin = kNone); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGDNDManager.html:4902,mask,mask,4902,root/html534/TGDNDManager.html,https://root.cern,https://root.cern/root/html534/TGDNDManager.html,2,['mask'],['mask']
Availability,"ar* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static void*FindSpecialObject(const char* name, Cint::G__ClassInfo* type, void** prevObj, void** assocPtr); virtual void*FindSym(const char* entry) const; virtual Int_tGenerateDictionary(const char* classes, const char* includes = 0, const char* options = 0); virtual voidGenericError(const char* error) const; virtual const char*GetClassSharedLibs(const char* cls); virtual const char*GetCurrentMacroName() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Long_tGetExecByteCode() const; virtual Int_tGetExitCode() const; virtual Long_tGetgvp() const; virtual const char*TObject::GetIconName() const; virtual const char*GetIncludePath(); virtual void*GetInterfaceMethod(TClass* cl, const char* method, const char* params); virtual void*GetInterfaceMethodWithPrototype(TClass* cl, const char* method, const char* proto); virtual const char*GetInterpreterTypeName(const char* name, Bool_t full = kFALSE); virtual TStringGetMangledName(TClass* cl, const char* method, const char* params); virtual TStringGetMangledNameWithPrototype(TClass* cl, const char* method, const char* proto); virtual TEnv*GetMapfile() const; virtual Int_tGetMore() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCint.html:8610,error,error,8610,root/html528/TCint.html,https://root.cern,https://root.cern/root/html528/TCint.html,6,['error'],['error']
Availability,"ar* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , RooFit::MPSplit , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Tue Jun 30 14:38:19 2015 » Last generated: 2015-06-30 14:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:49424,error,error,49424,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,['error'],['error']
Availability,"ar* name = 0); Copy constructor. void initialize(); Common constructor initialization. void initIntegrator(); Initialize bin content integrator. ~RooXYChi2Var(); Destructor. Double_t xErrorContribution(Double_t ydata) const; Calculate contribution to internal error due to error on 'x' coordinates; at point i. Double_t fy() const; Return function value requested bu present configuration. If integration is required, the function value integrated; over the bin volume divided by the bin volume is returned,; otherwise the value at the bin center is returned.; The bin volume is defined by the error on the 'X' coordinates. If an extended p.d.f. is used as function, its value is; also multiplied by the expected number of events here. Double_t evaluatePartition(Int_t firstEvent, Int_t lastEvent, Int_t stepSize) const; Calculate chi^2 in partition from firstEvent to lastEvent using given stepSize. RooArgSet requiredExtraObservables() const; Inform base class that observable yvar cannot be optimized away from the dataset. TObject* clone(const char* newname) const; { return new RooXYChi2Var(*this,newname); }. RooAbsTestStatistic* create(const char* name, const char* title, RooAbsReal& pdf, RooAbsData& adata, const RooArgSet& , const char* , const char* , Int_t , RooFit::MPSplit , Bool_t , Bool_t , Bool_t ); Virtual constructor. Double_t defaultErrorLevel() const; The default error level for MINUIT error analysis for a chi^2 is 1.0. RooNumIntConfig& binIntegratorConfig(); { return _intConfig ; }. const RooNumIntConfig& binIntegratorConfig() const; { return _intConfig ; }. Bool_t allowFunctionCache(); Disable function (component) caching if integration is requested as the function; will be evaluated at coordinates other than the points in the dataset. » Last changed: Tue Mar 10 17:21:20 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooXYChi2Var.html:47797,error,error,47797,root/html534/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html534/RooXYChi2Var.html,4,['error'],['error']
Availability,"ar* name, const char* title); virtual~TStyle(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); Int_tAxisChoice(Option_t* axis) const; virtual voidBrowse(TBrowser* b); static voidBuildStyles(); virtual voidcd(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject& style) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TAttText*GetAttDate(); Color_tGetAxisColor(Option_t* axis = ""X"") const; Float_tGetBarOffset() const; Float_tGetBarWidth() const; Int_tGetCanvasBorderMode() const; Width_tGetCanvasBorderSize() const; Color_tGetCanvasColor() const; Int_tGetCanvasDefH() const; Int_tGetCanvasDefW() const; Int_tGetCanvasDefX() const; Int_tGetCanvasDefY() const; Bool_tGetCanvasPreferGL() const; Int_tGetColorModelPS() const; Int_tGetColorPalette(Int_t i) const; Float_tGetDateX() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStyle.html:1783,Error,Error,1783,root/html532/TStyle.html,https://root.cern,https://root.cern/root/html532/TStyle.html,2,['Error'],['Error']
Availability,"ar* name, const char* title, const RooResolutionModel& model, RooRealVar& convVar); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsAnaConvPdf.html:31670,Error,ErrorLoggingMode,31670,root/html604/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html604/RooAbsAnaConvPdf.html,1,['Error'],['ErrorLoggingMode']
Availability,"ar* name, const char* value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tCompressWithGzip(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillHttpHeader(TString& buf, const char* header = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const void*GetContent() const; Long_tGetContentLength() const; const char*GetContentType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFileName() const; TStringGetHeader(const char* name); TStringGetHeaderName(Int_t number) const; virtual const char*TObject::GetIconName() const; const char*GetMethod() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPathName() const; void*GetPostData() const; Long_tGetPostDataLength() const; const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THttpCallArg.html:1565,error,error,1565,root/html534/THttpCallArg.html,https://root.cern,https://root.cern/root/html534/THttpCallArg.html,4,['error'],['error']
Availability,"ar* name, const char* value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tCompressWithGzip(); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFillHttpHeader(TString& buf, const char* header = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; const void*GetContent() const; Long_tGetContentLength() const; const char*GetContentType() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); const char*GetFileName() const; virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; const char*GetPathName() const; const char*GetQuery() const; virtual const char*TObject::GetTitle() const; const char*GetTopName() const; virtual UInt_tTObject::GetUniqueID() const; Int_tGetZipping() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THttpCallArg.html:1549,error,error,1549,root/html602/THttpCallArg.html,https://root.cern,https://root.cern/root/html602/THttpCallArg.html,2,['error'],['error']
Availability,"ar* newName = 0); Return a clone of this dataset containing only the cached variables. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Returns true if histogram contains bins with entries with a non-integer weight. const RooArgSet* get() const; Return a RooArgSet with the coordinates of the current event. void add(const RooArgSet& row, Double_t weight = 1.0, Double_t weightError = 0); Add a data point, with its coordinates specified in the 'data' argset, to the data set.; Any variables present in 'data' but not in the dataset will be silently ignored. void add(const RooArgSet& row, Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:26394,Error,ErrorType,26394,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,1,['Error'],['ErrorType']
Availability,"ar* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TNode*CreateTNode(const TVolumePosition* position = 0); virtual voidTObjectSet::Delete(Option_t* opt = """"); virtual voidDeletePosition(TVolumePosition* position); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTObjectSet::DoOwner(Bool_t done = kTRUE); virtual voidDraw(Option_t* depth = ""3"")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOnly(Option_t* option = """"); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TDataSet*TDataSet::Find(const char* path) const; virtual TDataSet*TDataSet::FindByName(const char* name, const char* path = """", Option_t* opt = """") const; virtual TDataSet*TDataSet::FindByPath(const char* path) const; virtual TDataSet*TDataSet::FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const; virtual TObject*TDataSet::FindObject(const char* name) const; virtual TObject*TDataSet::FindObject(const TObject* o) const; virtual TDataSet*TDataSet::First() const; virtual TSeqCollection*TDataSet::GetCollection() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; static TRotMatrix*GetIdent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVolume.html:3119,error,error,3119,root/html528/TVolume.html,https://root.cern,https://root.cern/root/html528/TVolume.html,10,['error'],['error']
Availability,"ar* newname = 0); RooAbsDataStore(const char* name, const char* title, const RooArgSet& vars); RooAbsDataStore(const RooAbsDataStore& other, const RooArgSet& vars, const char* newname = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetDirtyProp(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExternalWeightArray(Double_t*, Double_t*, Double_t*, Double_t*); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual Double_tsumEntries() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual const TTree*tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tvalid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tweight() const; virtual Double_tweight(Int_t index) const; virtual Double_tweightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual voidweightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsDataStore.html:7977,Error,ErrorType,7977,root/html602/RooAbsDataStore.html,https://root.cern,https://root.cern/root/html602/RooAbsDataStore.html,4,['Error'],['ErrorType']
Availability,"ar* path = 0); static Bool_tCd(const char* path); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TObject*CloneObject(const TObject* obj, Bool_t autoadd = kTRUE); virtual voidClose(Option_t* option = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidCopy(TObject&) const; static TDirectory*&CurrentDirectory(); static voidDecodeNameCycle(const char* namecycle, char* name, Short_t& cycle); virtual voidDelete(const char* namecycle = """"); virtual voidDeleteAll(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static voidEncodeNameCycle(char* buffer, const char* name, Short_t cycle); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*FindKey(const char*) const; virtual TKey*FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char*) const; virtual TObject*Get(const char* namecycle); virtual Int_tGetBufferSize() const; virtual TDirectory*GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDirectory.html:1930,Error,Error,1930,root/html532/TDirectory.html,https://root.cern,https://root.cern/root/html532/TDirectory.html,1,['Error'],['Error']
Availability,"ar* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch) final;; 300 DeclId_t GetFunctionWithValues(ClassInfo_t *cl, const char* method, const char* params, Bool_t objectIsConst = kFALSE) final;; 301 DeclId_t GetFunctionTemplate(ClassInfo_t *cl, const char *funcname) final;; 302 void GetFunctionOverloads(ClassInfo_t *cl, const char *funcname, std::vector<DeclId_t>& res) const final;; 303 virtual void LoadFunctionTemplates(TClass* cl) const final;; 304 ; 305 std::vector<std::string> GetUsingNamespaces(ClassInfo_t *cl) const final;; 306 ; 307 void GetInterpreterTypeName(const char* name, std::string &output, Bool_t full = kFALSE) final;; 308 void Execute(const char* function, const char* params, int* error = nullptr) final;; 309 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = nullptr) final;; 310 void Execute(TObject* obj, TClass* cl, const char* method, const char* params, Bool_t objectIsConst, int* error = nullptr);; 311 void Execute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = nullptr) final;; 312 void ExecuteWithArgsAndReturn(TMethod* method, void* address, const void* args[] = nullptr, int nargs = 0, void* ret= nullptr) const final;; 313 Longptr_t ExecuteMacro(const char* filename, EErrorCode* error = nullptr) final;; 314 void RecursiveRemove(TObject* obj) final;; 315 Bool_t IsErrorMessagesEnabled() const final;; 316 Bool_t SetErrorMessages(Bool_t enable = kTRUE) final;; 317 Bool_t IsProcessLineLocked() const final {; 318 return fLockProcessLine;; 319 }; 320 void SetProcessLineLock(Bool_t lock = kTRUE) final {; 321 fLockProcessLine = lock;; 322 }; 323 const char* TypeName(const char* typeDesc) final;; 324 ; 325 void SnapshotMutexState(ROOT::TVirtualRWMutex* mtx) final;; 326 void ForgetMutexState() final;; 327 ; 328 void ApplyToInterpreterMutex(void* delta);; 329 void *RewindInterpreterMutex();; 330 ; 331 static void UpdateClassInfo(char* name, Long_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:14947,error,error,14947,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['error'],['error']
Availability,"ar* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:6092,Error,Error,6092,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,1,['Error'],['Error']
Availability,"ar* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:6321,Error,Error,6321,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,2,['Error'],['Error']
Availability,"ar* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; static voidFilterLocalroot(TString& path, const char* url = ""root://dum/""); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*GetCacheLock(); const char*GetConfDir() const; const char*GetConfFile() const; Float_tGetCpuTime() const; const char*GetDataDir() const; const char*GetDataDirOpts() const; static TMap*GetDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:4316,error,error,4316,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,2,['error'],['error']
Availability,"ar* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEnableTimeout(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; static voidErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); static Long_tTApplication::ExecuteFile(const char* file, Int_t* error = 0, Bool_t keep = kFALSE); TApplication::EExitOnExceptionTApplication::ExitOnException(TApplication::EExitOnException opt = kExit); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidFlushLogFile(); TObject*Get(const char* namecycle); Int_tGetActSessions() const; virtual TApplicationImp*TApplication::GetApplicationImp(); static TList*TApplication::GetApplications(); TApplication*TApplication::GetAppRemote() const; TProofLockPath*GetCacheLock(); const char*GetConfDir() const; const char*GetConfFile() const; Float_tGetCpuTime() const; const char*GetDataDir() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Float_tGetEffSessions() const; TList*GetEnabl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:4316,error,error,4316,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,4,['error'],['error']
Availability,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteAction(); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGroupButton.html:5978,error,error,5978,root/html534/TGroupButton.html,https://root.cern,https://root.cern/root/html534/TGroupButton.html,2,['error'],['error']
Availability,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteAction(); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGroupButton.html:5872,error,error,5872,root/html528/TGroupButton.html,https://root.cern,https://root.cern/root/html528/TGroupButton.html,4,['error'],['error']
Availability,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TButton.html:7779,error,error,7779,root/html534/TButton.html,https://root.cern,https://root.cern/root/html534/TButton.html,2,['error'],['error']
Availability,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TButton.html:7673,error,error,7673,root/html526/TButton.html,https://root.cern,https://root.cern/root/html526/TButton.html,5,['error'],['error']
Availability,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePad.html:5736,error,error,5736,root/html534/TEvePad.html,https://root.cern,https://root.cern/root/html534/TEvePad.html,4,['error'],['error']
Availability,"ar* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_tTPad::GetCanvasID() const; virtual TCanvasImp*TPad::GetCanvasImp() const; Int_tTPad::GetCrosshair() const; virtual Option_t*TObject::GetDrawOption() const; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEvePad.html:5630,error,error,5630,root/html528/TEvePad.html,https://root.cern,https://root.cern/root/html528/TEvePad.html,8,['error'],['error']
Availability,"ar* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* uri); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*GetDataSet(const char* uri, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofLite.html:6366,error,error,6366,root/html534/TProofLite.html,https://root.cern,https://root.cern/root/html534/TProofLite.html,2,['error'],['error']
Availability,"ar* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tTProof::EnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tTProof::EnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tTProof::Exec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tTProof::Exec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tTProof::ExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidTProof::Feedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tTProof::Finalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tTProof::Finalize(const char* queryref, Bool_t force = kFALSE); TList*TProof::FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Long64_tTProof::GetBytesRead() const; Int_tTProof::GetClientProtocol() const; const char*TProof::GetConfDir() const; const char*TProof::GetConfFile() const; Float_tTProof::GetCpuTime() const; const char*TProof::GetDataPoolUrl() const; virtual TFileCollection*TProof::GetDataSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:6595,error,error,6595,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,4,['error'],['error']
Availability,"ar* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidTQObject::EmitVA<>(const char* signal_name, Int_t); voidEnterLeave(TPad* prevSelPad, TObject* prevSelObj); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTPad::EventPave()SIGNAL ; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTPad::ExecuteEventAxis(Int_t event, Int_t px, Int_t py, TAxis* axis); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedbackMode(Bool_t set); virtual TObject*TPad::FindObject(const char* name) const; virtual TObject*TPad::FindObject(const TObject* obj) const; voidFlush(); voidForceUpdate(); virtual Double_tTPad::GetAbsHNDC() const; virtual Double_tTPad::GetAbsWNDC() const; virtual Double_tTPad::GetAbsXlowNDC() const; virtual Double_tTPad::GetAbsYlowNDC() const; Float_tTAttPad::GetAfile() const; virtual Double_tTPad::GetAspectRatio() const; Float_tTAttPad::GetAstat() const; Bool_tGetAutoExec() const; virtual Rectangle_tTPad::GetBBox(); virtual TPointTPad::GetBBoxCenter(); virtual Short_tTPad::GetBorderMode() const; virtual Short_tTPad::GetBorderSize() const; Float_tTAttPad::GetBottomMargin() const; virtual TCanvas*TPad::GetCanvas() const; virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCanvas.html:8084,error,error,8084,root/html602/TCanvas.html,https://root.cern,https://root.cern/root/html602/TCanvas.html,4,['error'],['error']
Availability,"ar* stager = """"); TNetFileStager(const TNetFileStager&); virtual~TNetFileStager(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TStringTFileStager::GetPathName(TObject* o); virtual TList*TFileStager::GetStaged(TCollection* pathlist); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TNetFileStager.html:1404,error,error,1404,root/html530/TNetFileStager.html,https://root.cern,https://root.cern/root/html530/TNetFileStager.html,5,['error'],['error']
Availability,"ar* title, Int_t x, Int_t y, UInt_t width, UInt_t height, Option_t* opt); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TGClient*GetRootClient(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQtRootGuiFactory.html:2577,Error,Error,2577,root/html532/TQtRootGuiFactory.html,https://root.cern,https://root.cern/root/html532/TQtRootGuiFactory.html,3,['Error'],['Error']
Availability,"ar* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; static TGClient*GetRootClient(); virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQtRootGuiFactory.html:2706,error,error,2706,root/html528/TQtRootGuiFactory.html,https://root.cern,https://root.cern/root/html528/TQtRootGuiFactory.html,7,['error'],['error']
Availability,"ar* title, UInt_t width, UInt_t height); virtual TCanvasImp*CreateCanvasImp(TCanvas* c, const char* title, Int_t x, Int_t y, UInt_t width, UInt_t height); virtual TContextMenuImp*CreateContextMenuImp(TContextMenu* c, const char* name, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title); virtual TControlBarImp*CreateControlBarImp(TControlBar* c, const char* title, Int_t x, Int_t y); virtual TInspectorImp*CreateInspectorImp(const TObject* obj, UInt_t width, UInt_t height); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TNamed::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGuiFactory.html:2621,error,error,2621,root/html528/TGuiFactory.html,https://root.cern,https://root.cern/root/html528/TGuiFactory.html,10,['error'],['error']
Availability,"ar* title, double(*)(double,double,double,double) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z, RooAbsReal& _w); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html:24935,Error,ErrorLoggingMode,24935,root/html602/RooCFunction4Binding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html,2,['Error'],['ErrorLoggingMode']
Availability,"ar* title, double(*)(double,int) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html:29510,Error,ErrorLoggingMode,29510,root/html602/RooCFunction2PdfBinding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_double_int_.html,2,['Error'],['ErrorLoggingMode']
Availability,"ar* title, double(*)(int,double) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html:29510,Error,ErrorLoggingMode,29510,root/html602/RooCFunction2PdfBinding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_int_double_.html,2,['Error'],['ErrorLoggingMode']
Availability,"ar* unit = """"); RooAbsHiddenReal(const char* name, const char* title, RooAbsCategory& blindState, const char* unit = """"); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:24496,Error,ErrorLoggingMode,24496,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,2,['Error'],['ErrorLoggingMode']
Availability,"ar*DataMemberInfo_TypeTrueName(DataMemberInfo_t*) const; virtual const char*DataMemberInfo_ValidArrayIndex(DataMemberInfo_t*) const; virtual Bool_tDeclare(const char* code); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDeleteGlobal(void* obj); virtual Int_tDeleteVariable(const char* name); virtual intDisplayClass(FILE*, const char*, int, int) const; virtual intDisplayIncludePath(FILE*) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidEnableAutoLoading(); virtual voidEndOfLineAction(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidExecute(const char* function, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, const char* method, const char* params, int* error = 0); virtual voidExecute(TObject* obj, TClass* cl, TMethod* method, TObjArray* params, int* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Long_tExecuteMacro(const char* filename, TInterpreter::EErrorCode* error = 0); virtual voidExecuteWithArgsAndReturn(TMethod* method, void* address, const void*[] args = 0, int = 0, void* ret = 0) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual void*FindSym(const char*) const; virtual voidFuncTempInfo_Delete(FuncTempInfo_t*) const; virtual FuncTempInfo_t*FuncTempInfo_Factory(TInterpreter::DeclId_t declid) const; virtual FuncTempInfo_t*FuncTempInfo_FactoryCopy(FuncTempInfo_t*) const; virtual Bool_tFuncTempInfo_IsValid(FuncTempInfo_t*) const; virtual voidFuncTempInfo_Name(FuncTempInfo_t*, TString& na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TInterpreter.html:9956,error,error,9956,root/html602/TInterpreter.html,https://root.cern,https://root.cern/root/html602/TInterpreter.html,4,['error'],['error']
Availability,"ar*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual floatTMatrixTBase<float>::ColNorm() const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Double_tDeterminant() const; virtual voidDeterminant(Double_t& d1, Double_t& d2) const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTMatrixTBase<float>::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual floatTMatrixTBase<float>::E2Norm() const; const TMatrixT<float>EigenVectors(TVectorT<float>& eigenValues) const; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTMatrixTBase<float>::ExtractRow(Int_t row, Int_t col, float* v, Int_t n = -1) const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual const Int_t*GetColIndexArray() const; virtual Int_t*GetColIndexArray(); Int_tTMatrixTBase<float>::GetColLwb() const; Int_tTMatrixTBase<float>::GetColUpb() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual voidTMatrixTBase<float>::GetMatrix2Array(float* data, Option_t* option = """") const; virtual const float*GetMatrixArray() const; virtual float*GetMatrixArray(); virtual const char*TObject::GetName() const; Int_tTMatrixTBase<float>::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSym_float_.html:2921,error,error,2921,root/html528/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSym_float_.html,20,['error'],['error']
Availability,"ar1, const RooAbsRealLValue& var2, Int_t nx, Int_t ny, const char* cuts = """", const char* name = ""hist"") const; Create a TH2F histogram of the distribution of the specified variable; using this dataset. Apply any cuts to select which events are used.; The variable being plotted can either be contained directly in this; dataset, or else be a function of the variables in this dataset.; The histogram will be created using RooAbsReal::createHistogram() with; the name provided (with our dataset name prepended). RooPlot* plotOnXY(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()) const; Special plot method for 'X-Y' datasets used in Chi^2 fitting. These datasets; have one observable (X) and have weights (Y) and associated errors. Contents options. YVar(RooRealVar& var) -- Designate specified observable as 'y' variable; If not specified, the event weight will be the y variable; Histogram drawing options. DrawOption(const char* opt) -- Select ROOT draw option for resulting TGraph object; LineStyle(Int_t style) -- Select line style by ROOT line style code, default is solid; LineColor(Int_t color) -- Select line color by ROOT color code, default is black; LineWidth(Int_t width) -- Select line with in pixels, default is 3; MarkerStyle(Int_t style) -- Select the ROOT marker style, default is 21; MarkerColor(Int_t color) -- Select the ROOT marker color, default is black; MarkerSize(Double_t size) -- Select the ROOT marker size; Rescale(Double_t factor) -- Apply global rescaling factor to histogram. Misc. other options. Name(const chat* name) -- Give curve specified name in frame. Useful if curve is to be referenced later; Invisible(Bool_t flag) -- Add curve to frame, but do n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:29093,error,errors,29093,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,11,['error'],['errors']
Availability,"ar5Definition TMinuit.h:44; TMinuit::fCOMDplistDouble_t * fCOMDplistDefinition TMinuit.h:123; TMinuit::fLnolimBool_t fLnolimDefinition TMinuit.h:160; TMinuit::Evalvirtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function Input parameters:Definition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::Classstatic TClass * Class(); TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:268750,error,error,268750,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['error']
Availability,"ar5Definition TMinuit.h:44; TMinuit::fCOMDplistDouble_t * fCOMDplistDefinition TMinuit.h:123; TMinuit::fLnolimBool_t fLnolimDefinition TMinuit.h:160; TMinuit::Evalvirtual Int_t Eval(Int_t npar, Double_t *grad, Double_t &fval, Double_t *par, Int_t flag)Evaluate the minimisation function Input parameters:Definition TMinuit.cxx:800; TMinuit::fFIXPyyDouble_t * fFIXPyyDefinition TMinuit.h:102; TMinuit::fStatusInt_t fStatusDefinition TMinuit.h:154; TMinuit::fGstepDouble_t * fGstepDefinition TMinuit.h:83; TMinuit::fXtDouble_t * fXtDefinition TMinuit.h:76; TMinuit::mnmigrvirtual void mnmigr()Performs a local function minimization.Definition TMinuit.cxx:5048; TMinuit::fIstratInt_t fIstratDefinition TMinuit.h:150; TMinuit::fCwordTString fCwordDefinition TMinuit.h:169; TMinuit::fPlotTObject * fPlotDefinition TMinuit.h:176; TMinuit::fPSDFsDouble_t * fPSDFsDefinition TMinuit.h:116; TMinuit::fMIGRgsDouble_t * fMIGRgsDefinition TMinuit.h:110; TMinuit::mnematvirtual void mnemat(Double_t *emat, Int_t ndim)Calculates the external error matrix from the internal matrix.Definition TMinuit.cxx:2501; TMinuit::mnrn15virtual void mnrn15(Double_t &val, Int_t &inseed)This is a super-portable random number generator.Definition TMinuit.cxx:6619; TMinuit::mnerrsvirtual void mnerrs(Int_t number, Double_t &eplus, Double_t &eminus, Double_t &eparab, Double_t &gcc)Utility routine to get MINOS errors.Definition TMinuit.cxx:2578; TMinuit::fMIGRstepDouble_t * fMIGRstepDefinition TMinuit.h:109; TMinuit::fEpsiDouble_t fEpsiDefinition TMinuit.h:53; TMinuit::fWord7Double_t * fWord7Definition TMinuit.h:96; TMinuit::mnexinvirtual void mnexin(Double_t *pint)Transforms the external parameter values U to internal values.Definition TMinuit.cxx:3151; TMinuit::fCovmesTString fCovmes[4]Definition TMinuit.h:172; TMinuit::fIstkwrInt_t fIstkwr[10]Definition TMinuit.h:139; TMinuit::fNparInt_t fNparDefinition TMinuit.h:41; TMinuit::mnexcmvirtual void mnexcm(const char *comand, Double_t *plist, Int_t llist, Int_t &ierflg)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8h_source.html:26898,error,error,26898,doc/master/TMinuit_8h_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8h_source.html,1,['error'],['error']
Availability,"arAdd variable field.; TGColorSelect*fAvFillColorSelectfill color widget for the average.; TGedPatternSelect*fAvFillPatternSelectfill pattern widget for the average.; TGColorSelect*fAvLineColorSelectline color widget for the average.; TGLineStyleComboBox*fAvLineStyleComboline style combo box for the average.; TGLineWidthComboBox*fAvLineWidthComboline width combo box for the average.; Bool_tTGedFrame::fAvoidSignalflag for executing slots; Pixel_tTGFrame::fBackgroundframe background color; TGButtonGroup*fBgroupGroup of the plot type selection.; Int_tTGFrame::fBorderWidthframe border width; TGCompositeFrame*fBrowseBrowse tab.; TGClient*TGObject::fClientConnection to display server; Int_tTGFrame::fDNDStateEDNDFlags; TGTextEntry*fDeleteVarDelete variable field.; TGCheckButton*fDisplayAverageButton for the display of the average.; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; TList*TGedFrame::fExtraTabsaddtional tabs in ged editor; TGFrameElement*TGFrame::fFEpointer to frame element; TGedEditor*TGedFrame::fGedEditormanager of this frame; TGNumberEntryField*fGotoEntryJump to an entry field.; TGPictureButton*fGotoFollowingGo to next entry button.; TGPictureButton*fGotoNextGo to next entries button.; TGPictureButton*fGotoPrecedingGo to last entry button.; TGPictureButton*fGotoPreviousGo to previous entries button.; UInt_tTGFrame::fHeightframe height; Handle_tTGObject::fIdX11/Win32 Window identifier; Bool_tTGedFrame::fInitinit flag for setting signals/slots; Bool_tTGCompositeFrame::fLayoutBrokenno layout manager is used; TGLayoutManager*TGCompositeFrame::fLayoutManagerlayout manager; TList*TGCompositeFrame::fListcontainer of frame elements; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTGCompositeFrame::fMapSubwindowskTRUE - map subwindows; UInt_tTGFrame::fMaxHeightmaximal frame height; UInt_tTGFrame::fMaxWidthmaxim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpiderEditor.html:18506,mask,mask,18506,root/html530/TSpiderEditor.html,https://root.cern,https://root.cern/root/html530/TSpiderEditor.html,9,['mask'],['mask']
Availability,"arFunctionMinimizer::ModularFunctionMinimizer(); ROOT::Minuit2::ModularFunctionMinimizerROOT::Minuit2::ModularFunctionMinimizer::ModularFunctionMinimizer(const ROOT::Minuit2::ModularFunctionMinimizer&); ROOT::Minuit2::FumiliMinimizer&operator=(const ROOT::Minuit2::FumiliMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Data Members; private:. ROOT::Minuit2::FumiliBuilderfMinBuilder; ROOT::Minuit2::MnSeedGeneratorfMinSeedGen. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FumiliMinimizer(). Constructor initializing the FumiliMinimizer by instantiatiating; the SeedGenerator and MinimumBuilder for the Fumili minimization method. @see MnSeedGenerator. @see FumiliBuilder. {}. ~FumiliMinimizer(); {}. FunctionMinimum Minimize(const FCNBase&, const MnUserParameterState&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1); for Fumili. FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameterState&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>& par, const std::vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1); need to re-implement all function in ModularFuncitionMinimizer otherwise they will be hided. FunctionMinimum Minimize(const FCNGradientBase&fcn, const std::vector<double>&par, const std::vector<double>&err, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase& fcn, const std::vector<double>&par, unsigned int nrow, const std::vector<double>&cov, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase& fcn, const MnUserParameters& par, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FumiliMinimizer.html:4966,toler,toler,4966,root/html602/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FumiliMinimizer.html,4,['toler'],['toler']
Availability,"arNew = new TFormula();; 718 TFormula * linearOld = (TFormula*) fLinearParts[i];; 719 if (linearOld) {; 720 linearOld->Copy(*linearNew);; 721 fnew.fLinearParts.push_back(linearNew);; 722 }; 723 else; 724 Warning(""Copy"",""Function %s - expr %s has a dummy linear part %d"",GetName(),GetExpFormula().Data(),i);; 725 }; 726 }; 727 ; 728 fnew.fClingInput = fClingInput;; 729 fnew.fReadyToExecute = fReadyToExecute;; 730 fnew.fClingInitialized = fClingInitialized.load();; 731 fnew.fAllParametersSetted = fAllParametersSetted;; 732 fnew.fClingName = fClingName;; 733 fnew.fSavedInputFormula = fSavedInputFormula;; 734 fnew.fLazyInitialization = fLazyInitialization;; 735 ; 736 // case of function based on a C++ expression (lambda's) which is ready to be compiled; 737 if (fLambdaPtr && TestBit(TFormula::kLambda)) {; 738 ; 739 bool ret = fnew.InitLambdaExpression(fnew.fFormula);; 740 if (ret) {; 741 fnew.SetBit(TFormula::kLambda);; 742 fnew.fReadyToExecute = true;; 743 }; 744 else {; 745 Error(""TFormula"",""Syntax error in building the lambda expression %s"", fFormula.Data() );; 746 fnew.fReadyToExecute = false;; 747 }; 748 }; 749 ; 750 // use copy-constructor of TMethodCall; 751 // if c++-14 could use std::make_unique; 752 TMethodCall *m = (fMethod) ? new TMethodCall(*fMethod) : nullptr;; 753 fnew.fMethod.reset(m);; 754 ; 755 fnew.fFuncPtr = fFuncPtr;; 756 fnew.fGradGenerationInput = fGradGenerationInput;; 757 fnew.fHessGenerationInput = fHessGenerationInput;; 758 fnew.fGradFuncPtr = fGradFuncPtr;; 759 fnew.fHessFuncPtr = fHessFuncPtr;; 760 ; 761}; 762 ; 763////////////////////////////////////////////////////////////////////////////////; 764/// Clear the formula setting expression to empty and reset the variables and; 765/// parameters containers.; 766 ; 767void TFormula::Clear(Option_t * ); 768{; 769 fNdim = 0;; 770 fNpar = 0;; 771 fNumber = 0;; 772 fFormula = """";; 773 fClingName = """";; 774 ; 775 fMethod.reset();; 776 ; 777 fClingVariables.clear();; 778 fClingParameters.clear();; 779 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:27423,error,error,27423,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['error'],['error']
Availability,"ar] = new PDF( TString(GetName()) + "" PDF Var Sig "" + GetInputVar( ivar ), (*fVarHistS_smooth)[ivar], PDF::kSpline2 );; 1210 (*fVarPdfB)[ivar] = new PDF( TString(GetName()) + "" PDF Var Bkg "" + GetInputVar( ivar ), (*fVarHistB_smooth)[ivar], PDF::kSpline2 );; 1211 }; 1212}; 1213 ; 1214////////////////////////////////////////////////////////////////////////////////; 1215/// read the cuts from stream; 1216 ; 1217void TMVA::MethodCuts::ReadWeightsFromStream( std::istream& istr ); 1218{; 1219 TString dummy;; 1220 UInt_t dummyInt;; 1221 ; 1222 // first the dimensions; 1223 istr >> dummy >> dummy;; 1224 // coverity[tainted_data_argument]; 1225 istr >> dummy >> fNbins;; 1226 ; 1227 // get rid of one read-in here because we read in once all ready to check for decorrelation; 1228 istr >> dummy >> dummy >> dummy >> dummy >> dummy >> dummy >> dummyInt >> dummy ;; 1229 ; 1230 // sanity check; 1231 if (dummyInt != Data()->GetNVariables()) {; 1232 Log() << kFATAL << ""<ReadWeightsFromStream> fatal error: mismatch ""; 1233 << ""in number of variables: "" << dummyInt << "" != "" << Data()->GetNVariables() << Endl;; 1234 }; 1235 //SetNvar(dummyInt);; 1236 ; 1237 // print some information; 1238 if (fFitMethod == kUseMonteCarlo) {; 1239 Log() << kWARNING << ""Read cuts optimised using sample of MC events"" << Endl;; 1240 }; 1241 else if (fFitMethod == kUseMonteCarloEvents) {; 1242 Log() << kWARNING << ""Read cuts optimised using sample of MC events"" << Endl;; 1243 }; 1244 else if (fFitMethod == kUseGeneticAlgorithm) {; 1245 Log() << kINFO << ""Read cuts optimised using Genetic Algorithm"" << Endl;; 1246 }; 1247 else if (fFitMethod == kUseSimulatedAnnealing) {; 1248 Log() << kINFO << ""Read cuts optimised using Simulated Annealing algorithm"" << Endl;; 1249 }; 1250 else if (fFitMethod == kUseEventScan) {; 1251 Log() << kINFO << ""Read cuts optimised using Full Event Scan"" << Endl;; 1252 }; 1253 else {; 1254 Log() << kWARNING << ""unknown method: "" << fFitMethod << Endl;; 1255 }; 1256 Log() << kINFO <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:46343,error,error,46343,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['error'],['error']
Availability,"ar];; 579 fSIMPy = new Double_t[fMaxpar];; 580 fVERTq = new Double_t[fMaxpar];; 581 fVERTs = new Double_t[fMaxpar];; 582 fVERTpp = new Double_t[fMaxpar];; 583 fCOMDplist = new Double_t[fMaxpar];; 584 fPARSplist = new Double_t[fMaxpar];; 585 ; 586 for (int i = 0; i < fMaxpar; i++) {; 587 fErp[i] = 0;; 588 fErn[i] = 0;; 589 }; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////; 593/// Make a clone of an object using the Streamer facility.; 594/// Function pointer is copied to Clone; 595 ; 596TObject *TMinuit::Clone(const char *newname) const; 597{; 598 TMinuit *named = (TMinuit*)TNamed::Clone(newname);; 599 named->fFCN=fFCN;; 600 return named;; 601}; 602 ; 603////////////////////////////////////////////////////////////////////////////////; 604/// Execute a Minuit command; 605///; 606/// Equivalent to MNEXCM except that the command is given as a character string.; 607/// See TMinuit::mnhelp for the full list of available commands; 608/// See also the; 609/// [complete documentation of all the available commands](https://root.cern/sites/d35c7d8c.web.cern.ch/files/minuit.pdf); 610///; 611/// Returns the status of the execution:; 612/// - 0: command executed normally; 613/// - 1: command is blank, ignored; 614/// - 2: command line unreadable, ignored; 615/// - 3: unknown command, ignored; 616/// - 4: abnormal termination (e.g., MIGRAD not converged); 617/// - 5: command is a request to read PARAMETER definitions; 618/// - 6: 'SET INPUT' command; 619/// - 7: 'SET TITLE' command; 620/// - 8: 'SET COVAR' command; 621/// - 9: reserved; 622/// - 10: END command; 623/// - 11: EXIT or STOP command; 624/// - 12: RETURN command; 625 ; 626Int_t TMinuit::Command(const char *command); 627{; 628 Int_t status = 0;; 629 mncomd(command,status);; 630 return status;; 631}; 632 ; 633////////////////////////////////////////////////////////////////////////////////; 634/// Creates a TGraph object describing the n-sigma contour of a; 635/// TMinuit f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:23915,avail,available,23915,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,['avail'],['available']
Availability,"aracterized by a bias and weighted links in between - let’s call those links synapses. The input neurons receive the inputs, normalize them and forward them to the first hidden layer. Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers.; Such a structure is very useful because of two theorems:; 1- A linear combination of sigmoids can approximate any continuous function.; 2- Trained with output=1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X.; 5.12.3 Learning Methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrate, divided by two, of the error on each individual output neuron. In all methods implemented in this library, one needs to compute the first derivative of that error with respect to the weights. Exploiting the well-known properties of the derivative, one can express this derivative as the product of the local partial derivative by the weighted sum of the outputs derivatives (for a neuron) or as the product of the input value with the local partial derivative of the output neuron (for a synapse). This computation is called “back-propagation of the errors”. Six learning methods are implemented.; 5.12.3.1 Stochastic Minimization; This is the most trivial learning method. The Robbins-Monro stochastic approximation is applied to multilayer perceptrons. The weights are updated after each example according to the formula:; \[; w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t); \]; with:; \[; \Delta w_{ij}(t) = - \eta \left(; \frac{\partial e_p}{\partial w_{ij}} + \delta \right) +; \epsilon \Delta w_{ij}(t-1); \]; The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; 5.12.3.2 Steepest Descent With Fixed Step Siz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:232151,error,error,232151,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability,"arallel; world. The parallel world has to be closed before calling any navigation; method. Function Members (Methods); public:. virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(TGeoPhysicalNode* pnode); voidAddOverlap(TGeoVolume* vol); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoPhysicalNode*FindNextBoundary(Double_t[3] point, Double_t[3] dir, Double_t& step, Double_t stepmax = 1.0E+30); TGeoPhysicalNode*FindNode(Double_t[3] point); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoManager*GetGeometry() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoParallelWorld.html:1940,error,error,1940,root/html602/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html602/TGeoParallelWorld.html,5,"['Error', 'error']","['Error', 'error']"
Availability,"arallelWorld(const char* name, TGeoManager* mgr); virtual~TGeoParallelWorld(); voidTObject::AbstractMethod(const char* method) const; voidAddNode(const char* path); voidAddOverlap(TGeoVolume* vol, Bool_t activate = kTRUE); voidAddOverlap(const char* volname, Bool_t activate = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidCheckOverlaps(Double_t ovlp = 0.001); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; Bool_tCloseGeometry(); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoPhysicalNode*FindNextBoundary(Double_t* point, Double_t* dir, Double_t& step, Double_t stepmax = 1.E30); TGeoPhysicalNode*FindNode(Double_t* point); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TGeoManager*GetGeometry() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoParallelWorld.html:2096,error,error,2096,root/html534/TGeoParallelWorld.html,https://root.cern,https://root.cern/root/html534/TGeoParallelWorld.html,5,"['Error', 'error']","['Error', 'error']"
Availability,"arallelWorld*CreateParallelWorld(const char* name); voidCreateThreadData() const; TGeoNode*CrossBoundaryAndLocate(Bool_t downwards, TGeoNode* skipnode); voidDefaultAngles()MENU ; voidDefaultColors()MENU ; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDisableInactiveVolumes(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); TGeoVolume*Division(const char* name, const char* mother, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step, Int_t numed = 0, Option_t* option = """"); voidDoBackupState(); voidDoRestoreState(); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawCurrentPoint(Int_t color = 2)MENU ; voidDrawPath(const char* path, Option_t* option = """"); voidDrawTracks(Option_t* option = """")MENU ; virtual voidTObject::Dump() constMENU ; virtual voidEdit(Option_t* option = """")MENU ; voidEnableInactiveVolumes(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExport(const char* filename, const char* name = """", Option_t* option = ""vg""); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); TGeoMaterial*FindDuplicateMaterial(const TGeoMaterial* mat) const; TGeoNode*FindNextBoundary(Double_t stepmax = TGeoShape::Big(), const char* path = """", Bool_t frombdr = kFALSE); TGeoNode*FindNextBoundaryAndStep(Double_t stepmax = TGeoShape::Big(), Bool_t compsafe = kFALSE); TGeoNode*FindNextDaughterBoundary(Double_t* point, Double_t* dir, Int_t& idaughter, Bool_t compmatrix = kFALSE); TGeoNode*FindNode(Bool_t safe_start = kTRUE); TGeoNode*FindNode(Double_t x, Double_t y, Double_t z); Double_t*FindNorm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoManager.html:14377,Error,Error,14377,root/html534/TGeoManager.html,https://root.cern,https://root.cern/root/html534/TGeoManager.html,3,['Error'],['Error']
Availability,"aram); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidEraseStatusBar(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual TGFrame*ExecuteAction(); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; TGMdiFrame*FindEditableMdiFrame(const TGWindow* win); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGuiBldAction*TGuiBuilder::GetAction() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); static ULong_tGetBgnd(); static TGGC*GetBgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootGuiBuilder.html:7335,error,error,7335,root/html528/TRootGuiBuilder.html,https://root.cern,https://root.cern/root/html528/TRootGuiBuilder.html,6,['error'],['error']
Availability,"aram); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); virtual voidTObject::Error(const char* method, const char* msgfmt) const; voidEveMenu(Int_t id); voidTRootBrowser::EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); virtual Long_tTRootBrowser::ExecPlugin(const char* name = 0, const char* fname = 0, const char* cmd = 0, Int_t pos = kRight, Int_t subpos = -1); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTRootBrowser::ExecuteDefaultAction(TObject* obj)SIGNAL ; virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; TGFrame*TRootBrowser::GetActFrame() const; virtual Pixel_tTGFrame::GetBackground() const; static const TGGC&TGFrame::GetBckgndGC(); TList*TGMainFrame::GetBindList() const; static const TGGC&TGFrame::GetBlackGC(); static Pixel_tTGFrame::GetBlackPixel(); Int_tTGFrame::GetBorderWidth() const; virtual TBrowser*TBrowserImp::GetBrowser() const; voidTGMainFrame::GetClassHints(const char*& className, const char*& resourceName) const; TGClient*TGObject::GetClient() const; static Int_tTGWindow::GetCounter(); static Pixel_tTGFrame::GetDefaultFrameBackground(); virtual UInt_tTGComposi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveBrowser.html:5219,error,error,5219,root/html534/TEveBrowser.html,https://root.cern,https://root.cern/root/html534/TEveBrowser.html,2,['error'],['error']
Availability,"aramArr); voidTQObject::Emit(const char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); voidEmptyAll(); virtual voidTGContainer::End(Bool_t select = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; const char*Ex(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); TTVLVEntry*ExpressionItem(Int_t index); TList*ExpressionList(); const char*Ey(); const char*Ez(); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGFrameElement*TGContainer::FindFrame(Int_t x, Int_t y, Bool_t exclude = kTRUE); virtual TGFrame*TGContainer::FindFrameByName(const char* name); virtual TGFrameElement*TGCompositeFrame::FindFrameElement(TGFrame* f) const; virtual void*TGContainer::FindItem(const TString& name, Bool_t direction = kTRUE, Bool_t caseSensitive = kTRUE, Bool_t subString = kFALSE); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Pixel_tTGFrame::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTVLVContainer.html:4905,Error,Error,4905,root/html532/TTVLVContainer.html,https://root.cern,https://root.cern/root/html532/TTVLVContainer.html,2,['Error'],['Error']
Availability,"arameter (not to fit); -a1Init - initial value of a1 parameter; -fixA1 - logical value of a1 parameter, which allows to fix the parameter (not to fit); -a2Init - initial value of a2 parameter; -fixA2 - logical value of a2 parameter, which allows to fix the parameter (not to fit). void SetTailParameters(Double_t tInit, Bool_t fixT, Double_t bInit, Bool_t fixB, Double_t sInit, Bool_t fixS). SETTER FUNCTION. This function sets the following fitting parameters of tails of peaks; -tInit - initial value of t parameter; -fixT - logical value of t parameter, which allows to fix the parameter (not to fit); -bInit - initial value of b parameter; -fixB - logical value of b parameter, which allows to fix the parameter (not to fit); -sInit - initial value of s parameter; -fixS - logical value of s parameter, which allows to fix the parameter (not to fit). void GetSigma(Double_t& sigma, Double_t& sigmaErr). GETTER FUNCTION. This function gets the sigma parameter and its error; -sigma - gets the fitted value of sigma parameter; -sigmaErr - gets error value of sigma parameter. void GetBackgroundParameters(Double_t& a0, Double_t& a0Err, Double_t& a1, Double_t& a1Err, Double_t& a2, Double_t& a2Err). GETTER FUNCTION. This function gets the background parameters and their errors; -a0 - gets the fitted value of a0 parameter; -a0Err - gets error value of a0 parameter; -a1 - gets the fitted value of a1 parameter; -a1Err - gets error value of a1 parameter; -a2 - gets the fitted value of a2 parameter; -a2Err - gets error value of a2 parameter. void GetTailParameters(Double_t& t, Double_t& tErr, Double_t& b, Double_t& bErr, Double_t& s, Double_t& sErr). GETTER FUNCTION. This function gets the tail parameters and their errors; -t - gets the fitted value of t parameter; -tErr - gets error value of t parameter; -b - gets the fitted value of b parameter; -bErr - gets error value of b parameter; -s - gets the fitted value of s parameter; -sErr - gets error value of s parameter. TSpectrumFit(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumFit.html:37703,error,error,37703,root/html528/TSpectrumFit.html,https://root.cern,https://root.cern/root/html528/TSpectrumFit.html,20,['error'],['error']
Availability,"arameter ;  ; Double_t fSigmaCalcY;  calculated value of sigma y parameter ;  ; Double_t fSigmaErrX;  error value of sigma x parameter ;  ; Double_t fSigmaErrY;  error value of sigma y parameter ;  ; Double_t fSigmaInitX;  initial value of sigma x parameter ;  ; Double_t fSigmaInitY;  initial value of sigma y parameter ;  ; Int_t fStatisticType;  type of statistics, possible values kFitOptimChiCounts (chi square statistics with counts as weighting coefficients), kFitOptimChiFuncValues (chi square statistics with function values as weighting coefficients),kFitOptimMaxLikelihood ;  ; Double_t fSxCalc;  calculated value of s parameter for 1D ridges in x direction ;  ; Double_t fSxErr;  error value of s parameter for 1D ridges in x direction ;  ; Double_t fSxInit;  initial value of s parameter for 1D ridges in x direction (relative amplitude of step), for details see html manual and references ;  ; Double_t fSxyCalc;  calculated value of s parameter for 2D peaks ;  ; Double_t fSxyErr;  error value of s parameter for 2D peaks ;  ; Double_t fSxyInit;  initial value of s parameter for 2D peaks (relative amplitude of step), for details see html manual and references ;  ; Double_t fSyCalc;  calculated value of s parameter for 1D ridges in y direction ;  ; Double_t fSyErr;  error value of s parameter for 1D ridges in y direction ;  ; Double_t fSyInit;  initial value of s parameter for 1D ridges in y direction (relative amplitude of step), for details see html manual and references ;  ; Double_t fTxCalc;  calculated value of t parameter for 1D ridges in x direction ;  ; Double_t fTxErr;  error value of t parameter for 1D ridges in x direction ;  ; Double_t fTxInit;  initial value of t parameter for 1D ridges in x direction (relative amplitude of tail), for details see html manual and references ;  ; Double_t fTxyCalc;  calculated value of t parameter for 2D peaks ;  ; Double_t fTxyErr;  error value of t parameter for 2D peaks ;  ; Double_t fTxyInit;  initial value of t paramet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:31639,error,error,31639,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['error']
Availability,"arameter Errors; There are two kinds of problems that can arise: the reliability of Minuit’s error estimates, and their statistical interpretation, assuming they are accurate.; 5.9.3.4 Statistical Interpretation; For discussion of basic concepts, such as the meaning of the elements of the error matrix, or setting of exact confidence levels see the articles:. F.James. Determining the statistical Significance of experimental Results. Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet. Statistical Methods in Experimental Physics. North-Holland, 1971. 5.9.4 Reliability of Minuit Error Estimates; Minuit always carries around its own current estimates of the parameter errors, which it will print out on request, no matter how accurate they are at any given point in the execution. For example, at initialization, these estimates are just the starting step sizes as specified by the user. After a HESSE step, the errors are usually quite accurate, unless there has been a problem. Minuit, when it prints out error values, also gives some indication of how reliable it thinks they are. For example, those marked CURRENT GUESS ERROR are only working values not to be believed, and APPROXIMATE ERROR means that they have been calculated but there is reason to believe that they may not be accurate.; If no mitigating adjective is given, then at least Minuit believes the errors are accurate, although there is always a small chance that Minuit has been fooled. Some visible signs that Minuit may have been fooled:. Warning messages produced during the minimization or error analysis; Failure to find new minimum; Value of EDM too big (estimated Distance to Minimum); Correlation coefficients exactly equal to zero, unless some parameters are known to be uncorrelated with the others; Correlation coefficients very close to one (greater than 0.99). This indicates both an exceptionally difficult problem, and one which has been badly para",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:221494,error,errors,221494,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['errors']
Availability,"arameter and visualize; 2692 // a from a linearized calculation as follows; 2693 //; 2694 // error(x) = F(a) C_aa' F(a'); 2695 //; 2696 // Where F(a) = (f(x,a+da) - f(x,a-da))/2; 2697 // and C_aa' is the correlation matrix; 2698 ; 2699 // Strip out parameters with zero error; 2700 RooArgList fpf_stripped;; 2701 for (auto const* frv : static_range_cast<RooRealVar*>(fr.floatParsFinal())) {; 2702 if (frv->getError() > frv->getVal() * std::numeric_limits<double>::epsilon()) {; 2703 fpf_stripped.add(*frv);; 2704 }; 2705 }; 2706 ; 2707 // Clone self for internal use; 2708 RooAbsReal* cloneFunc = static_cast<RooAbsReal*>(cloneTree()) ;; 2709 RooArgSet cloneParams;; 2710 cloneFunc->getObservables(&fpf_stripped, cloneParams) ;; 2711 RooArgSet errorParams{cloneParams};; 2712 if(params) {; 2713 // clear and fill errorParams only with parameters that both in params and cloneParams; 2714 cloneParams.selectCommon(*params, errorParams);; 2715 }; 2716 ; 2717 ; 2718 // Make list of parameter instances of cloneFunc in order of error matrix; 2719 RooArgList paramList ;; 2720 const RooArgList& fpf = fr.floatParsFinal() ;; 2721 std::vector<int> fpf_idx ;; 2722 for (std::size_t i=0 ; i<fpf.size() ; i++) {; 2723 RooAbsArg* par = errorParams.find(fpf[i].GetName()) ;; 2724 if (par) {; 2725 paramList.add(*par) ;; 2726 fpf_idx.push_back(i) ;; 2727 }; 2728 }; 2729 ; 2730 std::vector<RooCurve *> plusVar;; 2731 std::vector<RooCurve *> minusVar;; 2732 ; 2733 // Create std::vector of plus,minus variations for each parameter; 2734 ; 2735 TMatrixDSym V(paramList.size() == fr.floatParsFinal().size() ?; 2736 fr.covarianceMatrix():; 2737 fr.reducedCovarianceMatrix(paramList)) ;; 2738 ; 2739 ; 2740 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2741 ; 2742 RooRealVar& rrv = static_cast<RooRealVar&>(fpf[fpf_idx[ivar]]) ;; 2743 ; 2744 double cenVal = rrv.getVal() ;; 2745 double errVal = sqrt(V(ivar,ivar)) ;; 2746 ; 2747 // Make Plus variation; 2748 (static_cast<RooRealVar*>(paramList.at(ivar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:119357,error,errorParams,119357,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['error'],"['error', 'errorParams']"
Availability,"arameter can be a TGraphErrors, a TGraph2DErrors or a TH1,2,3.; For Graphs, confidence intervals are computed for each point,; the value of the graph at that point is set to the function value at that; point, and the graph y-errors (or z-errors) are set to the value of; the confidence interval at that point.; For Histograms, confidence intervals are computed for each bin center; The bin content of this bin is then set to the function value at the bin; center, and the bin error is set to the confidence interval value.; NOTE: confidence intervals are approximate for nonlinear models!. Allowed combinations:; Fitted object Passed object; TGraph TGraphErrors, TH1; TGraphErrors, AsymmErrors TGraphErrors, TH1; TH1 TGraphErrors, TH1; TGraph2D TGraph2DErrors, TH2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; get the error matrix in a pointer to a NxN array.; excluding the fixed parameters. Double_t GetCovarianceMatrixElement(Int_t i, Int_t j) const; get error matrix element. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc) const; get fit errors. Int_t GetNumberTotalParameters() const; number of total parameters. Int_t GetNumberFreeParameters() const; number of variable parameters. Double_t GetParError(Int_t ipar) const; parameter error. Double_t GetParameter(Int_t ipar) const; parameter value. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& verr, Double_t& vlow, Double_t& vhigh) const; get all parameter info (name, value, errors). const char * GetParName(Int_t ipar) const; return name of parameter ipar. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx) const; get fit statistical information. Double_t GetSumLog(Int_t i); sum of log . Un-needed. Bool_t IsFixed(Int_t ipar) const; query if parameter ipar is fixed. void PrintResults(Int_t level, Double_t amin) const; print the fit result; use PrintResults ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBackCompFitter.html:14649,error,error,14649,root/html526/TBackCompFitter.html,https://root.cern,https://root.cern/root/html526/TBackCompFitter.html,1,['error'],['error']
Availability,"arameter for the point in; parameter-space that is the most likely.; How do we do if there are points that are equi-probable?; use approximate posterior; t.b.d use real function to find the mode. void ComputeIntervalUsingRooFit(double c1, double c2) const; internal function compute the interval using RooFit. void ComputeIntervalFromCdf(double c1, double c2) const; internal function compute the interval using Cdf integration. void ApproximatePosterior() const; approximate posterior in nbins using a TF1; scan the poi values and evaluate the posterior at each point; and save the result in a cloned TF1; For each point the posterior is evaluated by integrating the nuisance; parameters. void ComputeIntervalFromApproxPosterior(double c1, double c2) const; compute the interval using the approximate posterior function. void ComputeShortestInterval() const; compute the shortest interval. BayesianCalculator(); constructor. void SetData(RooAbsData& data). void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). { SetTestSize(1.-cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). { return fSize; }. Double_t ConfidenceLevel() const; Get the Confidence level for the test. { return 1.-fSize; }. void SetLeftSideTailFraction(Double_t leftSideFraction); set the fraction of probability content on the left tail; Central limits use 0.5 (default case); for upper limits it is 0 and 1 for lower limit; For shortest intervals a negative value (i.e. -1) must be given. {fLeftSideFraction = leftSideFraction;}. void SetShortestInterval(); set the Bayesian calculator to compute the shorest interval (default is central interval); to switch off SetLeftSideTailFraction to the rght value. { fLeftSideFraction = -1; }. void SetBrfPrecision(double precision); set the precision of the Root",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:15924,error,error,15924,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,3,['error'],['error']
Availability,"arameter mode can be; 665`= pcev` (default `= 0111`); 666 ; 667 p = 1; print Probability; 668 c = 1; print Chisquare/Number of degrees of freedom; 669 e = 1; print errors (if e=1, v must be 1); 670 v = 1; print name/values of parameters; 671 ; 672Example:; 673 ; 674 gStyle->SetOptFit(1011);; 675 ; 676print fit probability, parameter names/values and errors.; 677 ; 6781. When `v = 1` is specified, only the non-fixed parameters are shown.; 6792. When `v = 2` all parameters are shown.; 680 ; 681Note: `gStyle->SetOptFit(1)` means ""default value"", so it is equivalent; 682to `gStyle->SetOptFit(111)`; 683 ; 684 ; 685\anchor HP09; 686### The error bars options; 687 ; 688 ; 689| Option | Description |; 690|----------|-------------------------------------------------------------------|; 691| ""E"" | Default. Shows only the error bars, not a marker.|; 692| ""E1"" | Small lines are drawn at the end of the error bars.|; 693| ""E2"" | Error rectangles are drawn.|; 694| ""E3"" | A filled area is drawn through the end points of the vertical error bars.|; 695| ""E4"" | A smoothed filled area is drawn through the end points of the vertical error bars.|; 696| ""E0"" | Draw error bars. Markers are drawn for bins with 0 contents. Combined with E1 or E2 it avoids error bars clipping|; 697| ""E5"" | Like E3 but ignore the bins with 0 contents.|; 698| ""E6"" | Like E4 but ignore the bins with 0 contents.|; 699| ""X0"" | When used with one of the ""E"" option, it suppress the error bar along X as `gStyle->SetErrorX(0)` would do.|; 700 ; 701Begin_Macro(source); 702{; 703 auto c1 = new TCanvas(""c1"",""c1"",600,400);; 704 auto he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; 705 for (int i=0; i<10000; i++) he->Fill(gRandom->Gaus(0,1));; 706 gStyle->SetEndErrorSize(3);; 707 gStyle->SetErrorX(1.);; 708 he->SetMarkerStyle(20);; 709 he->Draw(""E1"");; 710}; 711End_Macro; 712 ; 713The options ""E3"" and ""E4"" draw an error band through the end points of the; 714vertical error bars. With ""E4"" th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:30586,error,error,30586,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['error']
Availability,"arameter<double>(const char* name, const double& val); virtual~TParameter<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const double&GetVal() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TParameter_double_.html:1560,error,error,1560,root/html528/TParameter_double_.html,https://root.cern,https://root.cern/root/html528/TParameter_double_.html,1,['error'],['error']
Availability,"arameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/re...Definition ParameterSettings.h:33; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::MinimizerOptionsMinimizer options.Definition MinimizerOptions.h:40; ROOT::Math::MinimizerOptions::SetMaxFunctionCallsvoid SetMaxFunctionCalls(unsigned int maxfcn)set maximum of function callsDefinition MinimizerOptions.h:213; ROOT::Math::MinimizerOptions::Strategyint Strategy() conststrategyDefinition MinimizerOptions.h:183; ROOT::Math::MinimizerOptions::ExtraOptionsconst IOptions * ExtraOptions() constreturn extra options (NULL pointer if they are not present)Definition MinimizerOptions.h:195; ROOT::Math::MinimizerOptions::Tolerancedouble Tolerance() constabsolute toleranceDefinition MinimizerOptions.h:186; ROOT::Math::MinimizerOptions::Precisiondouble Precision() constprecision in the objective function calculation (value <=0 means left to default)Definition MinimizerOptions.h:189; ROOT::Math::MinimizerOptions::SetMinimizerTypevoid SetMinimizerType(const char *type)set minimizer typeDefinition MinimizerOptions.h:231; ROOT::Math::MinimizerOptions::MinimizerAlgorithmconst std::string & MinimizerAlgorithm() consttype of algorithmDefinition MinimizerOptions.h:201; ROOT::Math::MinimizerOptions::ErrorDefdouble ErrorDef() consterror definitionDefinition MinimizerOptions.h:192; ROOT::Math::MinimizerOptions::SetDefaultMinimizerstatic void SetDefaultMinimizer(const char *type, const char *algo=nullptr)Set the default Minimizer type and corresponding algorithms.Definition MinimizerOptions.cxx:43; ROOT::Math::MinimizerOptions::DefaultMinimizerTypestatic const std::string & DefaultMinimizerType()Definition MinimizerOptions.cxx:100; ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8cxx_source.html:15461,toler,toleranceDefinition,15461,doc/master/FitConfig_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8cxx_source.html,1,['toler'],['toleranceDefinition']
Availability,"arameters at the Minimum. Function Members (Methods); public:. ~FunctionMinimum(); voidAdd(const ROOT::Minuit2::MinimumState& state); voidAdd(const ROOT::Minuit2::MinimumState& state, ROOT::Minuit2::FunctionMinimum::MnAboveMaxEdm); doubleEdm() const; const ROOT::Minuit2::MinimumError&Error() const; ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::FunctionMinimum& min); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, double up); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, const vector<ROOT::Minuit2::MinimumState>& states, double up); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, const vector<ROOT::Minuit2::MinimumState>& states, double up, ROOT::Minuit2::FunctionMinimum::MnReachedCallLimit); ROOT::Minuit2::FunctionMinimumFunctionMinimum(const ROOT::Minuit2::MinimumSeed& seed, const vector<ROOT::Minuit2::MinimumState>& states, double up, ROOT::Minuit2::FunctionMinimum::MnAboveMaxEdm); doubleFval() const; const ROOT::Minuit2::FunctionGradient&Grad() const; boolHasAccurateCovar() const; boolHasCovariance() const; boolHasMadePosDefCovar() const; boolHasPosDefCovar() const; boolHasReachedCallLimit() const; boolHasValidCovariance() const; boolHasValidParameters() const; boolHesseFailed() const; boolIsAboveMaxEdm() const; boolIsValid() const; intNFcn() const; ROOT::Minuit2::FunctionMinimum&operator=(const ROOT::Minuit2::FunctionMinimum& min); const ROOT::Minuit2::MinimumParameters&Parameters() const; const ROOT::Minuit2::MinimumSeed&Seed() const; voidSetErrorDef(double up); const ROOT::Minuit2::MinimumState&State() const; const vector<ROOT::Minuit2::MinimumState>&States() const; doubleUp() const; const ROOT::Minuit2::MnUserCovariance&UserCovariance() const; const ROOT::Minuit2::MnUserParameters&UserParameters() const; const ROOT::Minuit2::MnUserParameterState&UserState() const. Data Members; private:. ROOT::Minuit2::MnRefCountedPointer<RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FunctionMinimum.html:736,Error,Error,736,root/html602/ROOT__Minuit2__FunctionMinimum.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FunctionMinimum.html,2,['Error'],['Error']
Availability,"arameters where they are not needed. As an example, suppose that the user has defined the following parameters:. Parameter 0, constant.; Parameter 1, freely variable.; Parameter 2, variable with limits.; Parameter 3, constant.; Parameter 4, freely variable. Then the internal parameter list would be as follows:. Internal parameter 0 = external parameter 1.; Internal parameter 1 = external parameter 2, transformed appropriately.; Internal parameter 2 = external parameter 4. In the above example, M considers that the number of external parameters is 5, and the number of internal parameters is 3. This is the number which determines, for example, the size of the error matrix of the parameters, since only variable parameters have errors.; An important feature of M is that parameters are allowed to change types during the M minimization and analysis of a \(\mbox{FCN}\) function. Several applications in M have methods available to make variable parameters fixed and vice-versa; to impose, change, or remove limits from variable parameters; and even to define completely new parameters at any time during a run. In addition, some M applications (notably the \(\mbox{MINOS}\) error analysis) cause one or more variable parameters to be temporarily fixed during the calculation. Therefore, the correspondence between external and internal parameter lists is in general a dynamic one, and the number of internal parameters is not necessarily constant.; For more details about parameter interaction see [api:parameters].; 2.3.1 The transformation for parameters with limits; [intro:limits]; For variable parameters with double sided limits \(a\) (lower) and \(b\) (upper), M uses the following transformation:; \[\begin{aligned}; P_{\mathrm{int}} &=& \arcsin; \left( 2\: \frac{ P_{\mathrm{ext}}-a}{ b-a} - 1 \right) \\; P_{\mathrm{ext}} &=& a + \frac{ b - a}{ 2}; \left( \sin P_{\mathrm{int}} + 1 \right) \end{aligned}\]; so that the internal value \(P_{\mathrm{int}}\) can take on any value, while ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:12944,avail,available,12944,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['avail'],['available']
Availability,"arametrization for multi-dimensional data by fitting them to multi-dimensional data using polynomial or Chebyshev or Legendre polynomial; TSpectrum contains advanced spectra processing functions for 1- and 2-dimensional background estimation, smoothing, deconvolution, peak search and fitting, and orthogonal transformations.; RooFit is a complete toolkit for fitting and data analysis modeling (see the RooFit User Guide at ftp://root.cern.ch/root/doc/RooFit_Users_Manual_2.07-29.pdf); TSplot to disentangle signal from background via an extended maximum likelihood fit and with a tool to access the quality and validity of the fit producing distributions for the control variables. (see M. Pivk and F.R. Le Diberder, Nucl. Inst. Meth.A 555, 356-369, 2005).; 13.14.3 Multi-variate Analysis Classes; TMultiLayerPerceptron is a Neural Network class (see for more details the chapter “Neural Networks”).; TPrincipal provides the Principal Component Analysis.; TRobustEstimator is a robust method for minimum covariance determinant estimator (MCD).; TMVA is a package for multivariate data analysis (see https://github.com/root-project/root/blob/master/documentation/tmva/UsersGuide/TMVAUsersGuide.pdf the User’s Guide).; 14 Linear Algebra in ROOT; The linear algebra package is supposed to give a complete environment in ROOT to perform calculations like equation solving and eigenvalue decompositions. Most calculations are performed in double precision. For backward compatibility, some classes are also provided in single precision like TMatrixF, TMatrixFSym and TVectorF. Copy constructors exist to transform these into their double precision equivalent, thereby allowing easy access to decomposition and eigenvalue classes, only available in double precision.; The choice was made not to provide the less frequently used complex matrix classes. If necessary, users can always reformulate the calculation in 2 parts, a real one and an imaginary part. Although, a linear equation involving complex nu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:767814,robust,robust,767814,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['robust'],['robust']
Availability,"aration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. ROOT::Fit::Fitter* GetFitter() const; Give direct access to the underlying fitter class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; high",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:14406,error,error,14406,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,4,['error'],['error']
Availability,"aration of the fit parameters). Note that; the histograms are not copied, only references are used.; Arguments:; data: histogram to be fitted; MCs: array of TH1* corresponding template distributions; Option: can be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result. ~TFractionFitter(); TFractionFitter default destructor. void SetData(TH1* data); Change the histogram to be fitted to. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetMC(Int_t parm, TH1* MC); Change the histogram for template number <parm>. Notes:; - Parameter constraints and settings are retained from a possible previous fit.; - Modifying the dimension or number of bins results in an error (in this case; rather instantiate a new TFractionFitter object). void SetWeight(Int_t parm, TH1* weight); Set bin by bin weights for template number <parm> (the parameter numbering; follows that of the input template vector).; Weights can be ""unset"" by passing a null pointer.; Consistency of the weights histogram with the data histogram is checked at; this point, and an error in case of problems. TVirtualFitter* GetFitter() const; Give direct access to the underlying minimisation class. This can be; used e.g. to modify parameter values or step sizes. void CheckParNo(Int_t parm) const; Function for internal use, checking parameter validity; An invalid parameter results in an error. void SetRangeX(Int_t low, Int_t high); Set the X range of the histogram to be used in the fit.; Use ReleaseRangeX() to go back to fitting the full histogram.; The consistency check ensures that no empty fit range occurs (and also; recomputes the bin content integrals).; Arguments:; low: lower X bin number; h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:13799,error,error,13799,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,5,['error'],['error']
Availability,"arch interval.; doublefXMinimumPosition of the stimated minimum. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BrentMinimizer1D(); Default Constructor. . virtual ~BrentMinimizer1D(); Default Destructor. . {}. double XMinimum() const; Return current estimate of the position of the minimum. . { return fXMinimum; }. double XLower() const; Return current lower bound of the minimization interval. . { return fXMin; }. double XUpper() const; Return current upper bound of the minimization interval. . { return fXMax; }. double FValMinimum() const; Return function value at current estimate of the minimum. . double FValLower() const; Return function value at current lower bound of the minimization interval. . double FValUpper() const; Return function value at current upper bound of the minimization interval. . bool Minimize(int maxIter, double absTol = 1.E-8, double relTol = 1.E-10); Find minimum position iterating until convergence specified by the absolute and relative tolerance or; the maximum number of iteration is reached.; Return true if iterations converged successfully; \@param maxIter maximum number of iterations.; \@param absTol desired absolute error in the minimum position (default 1.E-8); \@param absTol desired relative error in the minimum position (default = 1.E-10). int Iterations() const; Return number of iteration used to find minimum . { return fNIter; }. const char * Name() const; Return name of minimization algorithm (""BrentMinimizer1D"") . void SetFunction(const ROOT::Math::IGenFunction& f, double xlow, double xup); Sets function to be minimized. \@param f Function to be minimized.; \@param xlow Lower bound of the search interval.; \@param xup Upper bound of the search interval. void SetNpx(int npx); Set the number of point used to bracket root using a grid . { fNpx = npx; }. void SetLogScan(bool on). Set a log grid scan (default is equidistant bins); will work only if xlow > 0. { fLogScan = on; }. int Status() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html:3789,toler,tolerance,3789,root/html528/ROOT__Math__BrentMinimizer1D.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__BrentMinimizer1D.html,6,['toler'],['tolerance']
Availability,"arching...; No Matches. List of all members |; Public Types |; Public Member Functions |; List of all members ; ROOT::Math::GSLRngRanLuxS1 Class ReferenceMath » MathCore » Interface classes for Random number generation. ; Second generation of Ranlux generator for single precision with luxury level of 1 (It throws away 202 values for every 12 used) see here ; Definition at line 369 of file GSLRndmEngines.h. Public Types; typedef GSLRandomEngine BaseType;  . Public Member Functions;  GSLRngRanLuxS1 ();  ;  Public Member Functions inherited from ROOT::Math::GSLRandomEngine;  GSLRandomEngine ();  default constructor. ;  ;  GSLRandomEngine (const GSLRandomEngine &eng);  Copy constructor : clone the contained GSL generator. ;  ;  GSLRandomEngine (GSLRngWrapper *rng);  create from an existing rng. ;  ; virtual ~GSLRandomEngine ();  call Terminate() ;  ; void Initialize ();  initialize the generator If no rng is present the default one based on Mersenne and Twister is created ;  ; unsigned long IntRndm () const;  Generate an integer number between [0,max_generator-1] (including 0 and max-1) if max is larger than available range of algorithm an error message is printed and zero is returned. ;  ; unsigned long MaxInt () const;  return the maximum integer +1 a generator can handle ;  ; unsigned long MinInt () const;  return the minimum integer a generator can handle typically this value is 0 ;  ; std::string Name () const;  return name of generator ;  ; double operator() () const;  Generate a random number between ]0,1] 0 is excluded and 1 is included. ;  ; GSLRandomEngine & operator= (const GSLRandomEngine &eng);  Assignment operator : make a deep copy of the contained GSL generator. ;  ; void RandomArray (double *begin, double *end) const;  Generate an array of random numbers The iterators points to the random numbers. ;  ; template<class Iterator > ; void RandomArray (Iterator begin, Iterator end) const;  Generate an array of random numbers. ;  ; double Rndm () const;  Gener",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxS1.html:1231,avail,available,1231,doc/master/classROOT_1_1Math_1_1GSLRngRanLuxS1.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLRngRanLuxS1.html,2,"['avail', 'error']","['available', 'error']"
Availability,"ard (double x, double h);  Computes the numerical derivative at a point x using an adaptive backward difference algorithm with a step size h. ;  ; double EvalCentral (double x, double h);  Computes the numerical derivative at a point x using an adaptive central difference algorithm with a step size h. ;  ; double EvalForward (double x, double h);  Computes the numerical derivative at a point x using an adaptive forward difference algorithm with a step size h. ;  ; void SetFunction (const IGenFunction &f);  Set the function for calculating the derivatives. ;  ; void SetFunction (GSLFuncPointer f, void *p=nullptr);  Set the function f for evaluating the derivative using a GSL function pointer type. ;  . — Static methods —; int fStatus;  ; double fResult;  ; double fError;  ; GSLFunctionWrapper fFunction;  ; int Status () const;  return the error status of the last integral calculation ;  ; double Result () const;  return the result of the last derivative calculation ;  ; double Error () const;  return the estimate of the absolute error of the last derivative calculation ;  ; static double EvalCentral (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive central difference algorithm with a step size h. ;  ; static double EvalForward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive forward difference algorithm with a step size h. ;  ; static double EvalBackward (const IGenFunction &f, double x, double h);  Computes the numerical derivative of a function f at a point x using an adaptive backward difference algorithm with a step size h. ;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLDerivator.h>; Constructor & Destructor Documentation. ◆ GSLDerivator(). ROOT::Math::GSLDerivator::GSLDerivator ; (; ). inline . Default Constructor of a GSLDerivator class based on G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html:1651,error,error,1651,doc/master/classROOT_1_1Math_1_1GSLDerivator.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLDerivator.html,2,['error'],['error']
Availability,"ard = kFALSE); voidTObject::ResetBit(UInt_t f); static voidTProof::ResetEnvVars(); voidTProof::ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent)SIGNAL ; voidTProof::ResetProgressDialogStatus(); Int_tTProof::Retrieve(Int_t query, const char* path = 0); Int_tTProof::Retrieve(const char* queryref, const char* path = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; Int_tTProof::SavePerfTree(const char* pf = 0, const char* qref = 0); virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); voidTProof::SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Bool_tTProof::SendingLogToWindow() const; voidTProof::SendLogToWindow(Bool_t mode); voidTProof::SetActive(Bool_t = kTRUE); virtual voidTProof::SetAlias(const char* alias = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTProof::SetDataPoolUrl(const char* url); virtual Int_tTProof::SetDataSetTreeName(const char* dataset, const char* treename); voidTProof::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTProof::SetInputDataFile(const char* datafile); voidTProof::SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); voidTProof::SetManager(TProofMgr* mgr); voidTProof::SetMaxDrawQueries(Int_t max); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); Int_tTProof::SetParallel(Int_t nodes = -1, Bool_t random = kFALSE); voidTProof::SetParameter(const char* par, const char* value); voidTProof::SetParameter(const char* par, Int_t value); voidTProof::SetParameter(const char* par, Long_t value); voidTProof::SetParameter(const char* par, Long64_t value); voidTProof::SetParameter(const char* par, Double_t value); voidTProof::SetPerfTree(const char* pf = ""perftree.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:16982,mask,mask,16982,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,6,['mask'],['mask']
Availability,"ard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general assymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate af",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:22297,error,errors,22297,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"ard-deviation errors.; When the error matrix has been calculated (for example by the successful execution of \(\mbox{MIGRAD}\) (MnMigrad::operator(), see [api:migradop]) or HESSE (MnHesse::operator())) then the parameter errors printed by M are the square roots of the diagonal elements of this matrix. The covariance or the correlations can be printed and shown via std::cout as the ostream operator operator\(<<\) is overloaded. The eigenvalues of the error matrix can be calculated using MnEigen, which should all be positive if the matrix is positive-definite (see below on \(\mbox{MIGRAD}\) and positive-definiteness).; The effect of correlations on the individual parameter errors can be seen as follows. When parameter \(\mbox{n}\) is fixed (e.g. via the method MnMigrad::fix(n)), M inverts the error matrix, removes the row and column corresponding to parameter \(\mbox{n}\), and re-inverts the result. The effect on the errors of the other parameters will in general be to make them smaller, since the component due to the uncertainty in parameter \(\mbox{n}\) has now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general asymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate aft",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:18275,error,errors,18275,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['error'],['errors']
Availability,"are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histograms*-*-*-*-*-*-*. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list of options). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this histogram. -case 1 xbins=0; If newname is blank (default), the current histogram is modified and; a pointer to it is returned. If newname is not blank, the current histogram is not modified, and a; new histogram is returned which is a Clone of the current histogram; with its name set to newname. The parameter ngroup indicates how many bins of this have t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:95583,error,errors,95583,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,6,"['avail', 'error']","['available', 'errors']"
Availability,"are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histograms*-*-*-*-*-*-*. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list of options). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this histogram. -case 1 xbins=0; if newname is not blank a new temporary histogram hnew is created.; else the current histogram is modified (default); The parameter ngroup indicates how many bins of this have to me merged; into one bin of hnew; If the original histogram has errors stored (via Sumw2), the resulting; histograms has new errors correctly calculat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:93649,error,errors,93649,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,6,"['avail', 'error']","['available', 'errors']"
Availability,"are changed. To get the minimum value of bins in the histogram regardless of; whether the value has been overridden, use; h->GetBinContent(h->GetMinimumBin()). Int_t GetMinimumBin() const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. Int_t GetMinimumBin(Int_t& locmix, Int_t& locmiy, Int_t& locmiz) const; -*-*-*-*-*Return location of bin with minimum value in the range*-*. void SetBins(Int_t nx, Double_t xmin, Double_t xmax); -*-*-*-*-*-*-*Redefine x axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins); -*-*-*-*-*-*-*Redefine x axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*-*. The X axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1. void SetBins(Int_t nx, Double_t xmin, Double_t xmax, Int_t ny, Double_t ymin, Double_t ymax); -*-*-*-*-*-*-*Redefine x and y axis parameters*-*-*-*-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange. void SetBins(Int_t nx, const Double_t* xBins, Int_t ny, const Double_t* yBins); -*-*-*-*-*-*-*Redefine x and y axis parameters with variable bin sizes *-*-*-*-*-*-*-*-*. The X and Y axis parameters are modified.; The bins content array is resized; if errors (Sumw2) the errors array is resized; The previous bin contents are lost; To change only the axis limits, see TAxis::SetRange; xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1. void SetBins(Int_t nx, Double_t xmin, Double_t xma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:113651,error,errors,113651,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,12,['error'],['errors']
Availability,"are defined in the header file Math/ProbFunc.h. The majority of the CDF’s are present in the MathCore, apart from the chisquared, fdistribution, gamma and tdistribution, which are in the MathMore library.; 13.5.4.1 Inverse of the Cumulative Distribution Functions(Quantiles); For almost all the cumulative distribution functions (_cdf) and their complements (_cdf_c) present in the library, we provide the inverse functions. The inverse of the cumulative distribution function is called in statistics quantile function. The functions with the extension _quantile calculate the inverse of the cumulative distribution function (lower tail integral of the probability density function), while those with the quantile_c extension calculate the inverse of the complement of the cumulative distribution (upper tail integral). All the inverse distributions are in the MathMore library and are defined in the header file Math/ProbFuncInv.h.; The following picture illustrates the available statistical functions (PDF, CDF and quantiles) in the case of the normal distribution. PDF, CDF and quantiles in the case of the normal distribution. 13.6 Numerical Algorithms; ROOT provides C++ classes implementing numerical algorithms to solve a wide set of problem, like:. Evaluation of function derivatives.; Evaluation of integrals.; Finding the roots of a function; Finding the minimum/maximum of a function. In order to use these algorithm the user needs to provide a function. ROOT provides a common way of specifying them via some interfaces; 13.7 ROOT::Math Function interfaces; To get a consistency in the mathematical methods within ROOT, there exists a set of interfaces to define the basic behaviour of a mathematical function. In order to use the classes presented in this chapter, the mathematical functions defined by the user must inherit from any of the classes seen in the figure:. ROOT::Math Function interface structure. 13.7.1 One-dimensional Function Interfaces; These interfaces are used for n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:686033,avail,available,686033,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"are in disallowed regions (e.g. PDF is negative), return very high value to fitter to force it out of that region. This can, however, mean that the fitter gets lost in this region. If this happens, try switching it off. . RecoverFromUndefinedRegions(double strength) When PDF is invalid (e.g. parameter in undefined region), try to direct minimiser away from that region. strength controls the magnitude of the penalty term. Leaving out this argument defaults to 10. Switch off with strength = 0.. SumW2Error(bool flag) Apply correction to errors and covariance matrix. This uses two covariance matrices, one with the weights, the other with squared weights, to obtain the correct errors for weighted likelihood fits. If this option is activated, the corrected covariance matrix is calculated as \( V_\mathrm{corr} = V C^{-1} V \), where \( V \) is the original covariance matrix and \( C \) is the inverse of the covariance matrix calculated using the squared weights. This allows to switch between two interpretations of errors: . SumW2Error Interpretation . true The errors reflect the uncertainty of the Monte Carlo simulation. Use this if you want to know how much accuracy you can get from the available Monte Carlo statistics.; Example: Simulation with 1000 events, the average weight is 0.1. The errors are as big as if one fitted to 1000 events. . false The errors reflect the errors of a dataset, which is as big as the sum of weights. Use this if you want to know what statistical errors you would get if you had a dataset with as many events as the (weighted) Monte Carlo simulation represents.; Example (Data as above): The errors are as big as if one fitted to 100 events. . NoteIf the SumW2Error correction is enabled, the covariance matrix quality stored in the RooFitResult object will be the minimum of the original covariance matrix quality and the quality of the covariance matrix calculated with the squared weights. . AsymptoticError() Use the asymptotically correct approach to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:107556,error,errors,107556,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['error'],['errors']
Availability,"are input tree (this must be replaced by your data source); 141 // in this example, there is a toy tree with signal and one with background events; 142 // we'll later on use only the ""signal"" events for the test in this example.; 143 //; 144 TFile *input(0);; 145 TString fname = ""./tmva_reg_example.root"";; 146 if (!gSystem->AccessPathName( fname )) {; 147 input = TFile::Open( fname ); // check if file in local directory exists; 148 }; 149 else {; 150 TFile::SetCacheFileDir(""."");; 151 input = TFile::Open(""http://root.cern/files/tmva_reg_example.root"", ""CACHEREAD""); // if not: download from ROOT server; 152 }; 153 if (!input) {; 154 std::cout << ""ERROR: could not open data file"" << std::endl;; 155 exit(1);; 156 }; 157 std::cout << ""--- TMVARegressionApp : Using input file: "" << input->GetName() << std::endl;; 158 ; 159 // --- Event loop; 160 ; 161 // Prepare the tree; 162 // - here the variable names have to corresponds to your tree; 163 // - you can use the same variables as above which is slightly faster,; 164 // but of course you can use different ones and copy the values inside the event loop; 165 //; 166 TTree* theTree = (TTree*)input->Get(""TreeR"");; 167 std::cout << ""--- Select signal sample"" << std::endl;; 168 theTree->SetBranchAddress( ""var1"", &var1 );; 169 theTree->SetBranchAddress( ""var2"", &var2 );; 170 ; 171 std::cout << ""--- Processing: "" << theTree->GetEntries() << "" events"" << std::endl;; 172 TStopwatch sw;; 173 sw.Start();; 174 for (Long64_t ievt=0; ievt<theTree->GetEntries();ievt++) {; 175 ; 176 if (ievt%1000 == 0) {; 177 std::cout << ""--- ... Processing event: "" << ievt << std::endl;; 178 }; 179 ; 180 theTree->GetEntry(ievt);; 181 ; 182 // Retrieve the MVA target values (regression outputs) and fill into histograms; 183 // NOTE: EvaluateRegression(..) returns a vector for multi-target regression; 184 ; 185 for (Int_t ih=0; ih<nhists; ih++) {; 186 TString title = hists[ih]->GetTitle();; 187 Float_t val = (reader->EvaluateRegression( title ))[0];; 188 hi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegressionApplication_8C_source.html:5093,down,download,5093,doc/master/TMVARegressionApplication_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVARegressionApplication_8C_source.html,1,['down'],['download']
Availability,"are not OK, modify the; : model either by modifying the rule ensemble; : or add/remove linear terms; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; RuleFit : -------------------RULE ENSEMBLE SUMMARY------------------------; : Tree training method : AdaBoost; : Number of events per tree : 2000; : Number of trees : 20; : Number of generated rules : 196; : Idem, after cleanup : 80; : Average number of cuts per rule : 3.01; : Spread in number of cuts per rules : 1.23; : ----------------------------------------------------------------; : ; : GD path scan - the scan stops when the max num. of steps is reached or a min is found; : Estimating the cutoff parameter tau. The estimated time is a pessimistic maximum.; : Best path found with tau = 0.0000 after 2.21 sec ; : Fitting model...; <WARNING> : ; : Minimisation elapsed time : 1.23 sec ; : ----------------------------------------------------------------; : Found minimum at step 10000 with error = 0.552378; : Reason for ending loop: end of loop reached; : ----------------------------------------------------------------; : The error rate was still decreasing at the end of the path; : Increase number of steps (GDNSteps).; : Removed 28 out of a total of 80 rules with importance < 0.001; : ; : ================================================================; : M o d e l ; : ================================================================; RuleFit : Offset (a0) = 9.46803; : ------------------------------------; : Linear model (weights unnormalised); : ------------------------------------; : Variable : Weights : Importance; : ------------------------------------; : myvar1 : -6.338e-01 : 0.472; : myvar2 : -4.488e-01 : 0.209; : var3 : -2.810e-01 : 0.129; : var4 : 1.850e+00 : 1.000; : ------------------------------------; : Number of rules = 52; : Printing the first 10 rules, ordered in importance.; : Rule 1 : Importance = 0.4294",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:58118,error,error,58118,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['error'],['error']
Availability,"are now ready (enough is loaded) to init the list of opaque typedefs.; 4490 ROOT::TMetaUtils::TNormalizedCtxt normCtxt(interp.getLookupHelper());; 4491 ROOT::TMetaUtils::TClingLookupHelper helper(interp, normCtxt, nullptr, nullptr, nullptr);; 4492 TClassEdit::Init(&helper);; 4493 ; 4494 // flags used only for the pragma parser:; 4495 clingArgs.push_back(""-D__CINT__"");; 4496 clingArgs.push_back(""-D__MAKECINT__"");; 4497 ; 4498 AddPlatformDefines(clingArgs);; 4499 ; 4500 std::string currentDirectory = ROOT::FoundationUtils::GetCurrentDir();; 4501 ; 4502 std::string interpPragmaSource;; 4503 std::string includeForSource;; 4504 std::string interpreterDeclarations;; 4505 std::string linkdef;; 4506 ; 4507 for (size_t i = 0, e = gOptDictionaryHeaderFiles.size(); i < e; ++i) {; 4508 const std::string& optHeaderFileName = gOptDictionaryHeaderFiles[i];; 4509 bool isSelectionFile = IsSelectionFile(optHeaderFileName.c_str());; 4510 ; 4511 if (isSelectionFile) {; 4512 if (i == e - 1) {; 4513 linkdef = optHeaderFileName;; 4514 } else { // if the linkdef was not last, issue an error.; 4515 ROOT::TMetaUtils::Error(nullptr, ""%s: %s must be last file on command line\n"",; 4516 executableFileName, optHeaderFileName.c_str());; 4517 return 1;; 4518 }; 4519 }; 4520 ; 4521 // coverity[tainted_data] The OS should already limit the argument size, so we are safe here; 4522 std::string fullheader(optHeaderFileName);; 4523 // Strip any trailing + which is only used by GeneratedLinkdef.h which currently; 4524 // use directly argv.; 4525 if (fullheader[fullheader.length() - 1] == '+') {; 4526 fullheader.erase(fullheader.length() - 1);; 4527 }; 4528 std::string header(; 4529 isSelectionFile ? fullheader : ROOT::FoundationUtils::MakePathRelative(fullheader, currentDirectory, gBuildingROOT));; 4530 ; 4531 interpPragmaSource += std::string(""#include \"""") + header + ""\""\n"";; 4532 if (!isSelectionFile) {; 4533 // In order to not have to add the equivalent to -I${PWD} to the; 4534 // command line, include",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:185308,error,error,185308,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['error'],['error']
Availability,"are only working values; not to be believed, and APPROXIMATE ERROR means that they have; been calculated but there is reason to believe that they may not be; accurate. If no mitigating adjective is given, then at least MINUIT believes the; errors are accurate, although there is always a small chance that MINUIT; has been fooled. Some visible signs that MINUIT may have been fooled are:. Warning messages produced during the minimization or error analysis.; Failure to find new minimum.; Value of EDM too big (estimated Distance to Minimum).; Correlation coefficients exactly equal to zero, unless some parameters; are known to be uncorrelated with the others.; Correlation coefficients very close to one (greater than 0.99). This; indicates both an exceptionally difficult problem, and one which has been; badly parameterized so that individual errors are not very meaningful; because they are so highly correlated.; Parameter at limit. This condition, signalled by a MINUIT warning; message, may make both the function minimum and parameter errors; unreliable. See the discussion above ``Getting the right parameter errors; with limits''. The best way to be absolutely sure of the errors, is to use; ``independent'' calculations and compare them, or compare the calculated; errors with a picture of the function. Theoretically, the covariance; matrix for a ``physical'' function must be positive-definite at the; minimum, although it may not be so for all points far away from the; minimum, even for a well-determined physical problem. Therefore, if MIGRAD; reports that it has found a non-positive-definite covariance matrix, this; may be a sign of one or more of the following:. A non-physical region:. On its way to the minimum, MIGRAD may have traversed a region which has; unphysical behaviour, which is of course not a serious problem as long as; it recovers and leaves such a region. An underdetermined problem:. If the matrix is not positive-definite even at the minimum, this may mean; tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:9331,error,errors,9331,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,10,['error'],['errors']
Availability,"are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from iymin to iymax and izmin to izmax included.; By default, underflow and overflows are included; By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Y axis; ranging from ixmin to ixmax and izmin to izmax included.; By default, underflow and overflow are ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:38660,error,errors,38660,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,4,['error'],['errors']
Availability,"are present and limits are different the function will fail.; The function returns the total number of entries in the result histogram; if the merge is successfull, -1 otherwise. IMPORTANT remark. The 2 axis x and y may have different number; of bins and different limits, BUT the largest bin width must be; a multiple of the smallest bin width and the upper limit must also; be a multiple of the bin width. TH1D * ProjectionX(const char* name = ""_px"", Int_t firstybin = 0, Int_t lastybin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along X*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the X axis; ranging from iymin to iymax and izmin to izmax included.; By default, underflow and overflows are included; By Setting iymin=1 and iymax=NbinsY the underflow and/or overflow will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad; the histogram is reset and filled again with the projected contents of the TH3. implemented using Project3D. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Int_t firstzbin = 0, Int_t lastzbin = -1, Option_t* option = """") const; Project a 3-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the cells along the Y axis; ranging from ixmin to ixmax and izmin to izmax included.; By default, underflow and overflow are included.; By Setting ixmin=1 and ixmax=NbinsX the underflow and/or overflow will be excluded. if option ""e"" is specified",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH3.html:41146,error,errors,41146,root/html534/TH3.html,https://root.cern,https://root.cern/root/html534/TH3.html,2,['error'],['errors']
Availability,"are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProof.html:61370,error,error,61370,root/html530/TProof.html,https://root.cern,https://root.cern/root/html530/TProof.html,3,['error'],['error']
Availability,"are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:70622,error,error,70622,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['error'],['error']
Availability,"are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* pac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProof.html:72780,error,error,72780,root/html602/TProof.html,https://root.cern,https://root.cern/root/html602/TProof.html,2,['error'],['error']
Availability,"are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package 'pack' from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = kCheckROOT, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:73453,error,error,73453,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['error'],['error']
Availability,"are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t ClearPackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackage(const char* package); Remove a specific package.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackageOnClient(const char* package); Remove a specific package from the client.; Returns 0 in case of success and -1 in case of error. Int_t DisablePackages(); Remove all packages.; Returns 0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:60828,error,error,60828,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['error'],['error']
Availability,"are(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t* cBoxX, Int_t* cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidTTex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMathText.html:54373,error,error,54373,root/html534/TMathText.html,https://root.cern,https://root.cern/root/html534/TMathText.html,2,['error'],['error']
Availability,"are(const TObject* obj) const; virtual voidCopy(TObject& text) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTText::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; TMathText*DrawMathText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawText(Double_t x, Double_t y, const wchar_t* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const char* text); virtual TText*TText::DrawTextNDC(Double_t x, Double_t y, const wchar_t* text); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTText::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Rectangle_tTText::GetBBox(); virtual TPointTText::GetBBoxCenter(); virtual voidGetBoundingBox(UInt_t& w, UInt_t& h, Bool_t angle = kFALSE); virtual voidTText::GetControlBox(Int_t x, Int_t y, Double_t theta, Int_t[4] cBoxX, Int_t[4] cBoxY); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Color_tTAttFill::GetFillColor() const; virtual Style_tTAttFill::GetFillStyle() const; virtual const char*TObject::GetIconName() const; virtual const char*TNamed::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMathText.html:54253,error,error,54253,root/html602/TMathText.html,https://root.cern,https://root.cern/root/html602/TMathText.html,4,['error'],['error']
Availability,"areQuantile (Double_t p, Double_t ndf);  Evaluate the quantiles of the chi-squared probability distribution function. ;  ; Double_t Cos (Double_t);  Returns the cosine of an angle of x radians. ;  ; Double_t CosH (Double_t);  Returns the hyperbolic cosine of x. ;  ; template<typename T > ; T * Cross (const T v1[3], const T v2[3], T out[3]);  Calculates the Cross Product of two vectors: out = [v1 x v2]. ;  ; constexpr Double_t CUncertainty ();  Speed of light uncertainty. ;  ; constexpr Double_t DegToRad ();  Conversion from degree to radian: \( \frac{\pi}{180} \). ;  ; Double_t DiLog (Double_t x);  Modified Struve functions of order 1. ;  ; constexpr Double_t E ();  Base of natural log: \( e \). ;  ; Double_t Erf (Double_t x);  Computation of the error function erf(x). ;  ; Double_t Erfc (Double_t x);  Computes the complementary error function erfc(x). ;  ; Double_t ErfcInverse (Double_t x);  Returns the inverse of the complementary error function. ;  ; Double_t ErfInverse (Double_t x);  Returns the inverse error function. ;  ; constexpr Double_t EulerGamma ();  Euler-Mascheroni Constant. ;  ; Bool_t Even (Long_t a);  Returns true if a is even. ;  ; Double_t Exp (Double_t x);  Returns the base-e exponential function of x, which is e raised to the power x. ;  ; Double_t Factorial (Int_t i);  Computes factorial(n). ;  ; Double_t FDist (Double_t F, Double_t N, Double_t M);  Computes the density function of F-distribution (probability function, integral of density, is computed in FDistI). ;  ; Double_t FDistI (Double_t F, Double_t N, Double_t M);  Calculates the cumulative distribution function of F-distribution (see ROOT::Math::fdistribution_cdf). ;  ; Int_t Finite (Double_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Int_t Finite (Float_t x);  Check if it is finite with a mask in order to be consistent in presence of fast math. ;  ; Double_t Floor (Double_t x);  Rounds x downward, returning the largest integral value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:6225,error,error,6225,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['error'],['error']
Availability,"arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {}, . const RooCmdArg & ; arg6 = {}, . const RooCmdArg & ; arg7 = {}, . const RooCmdArg & ; arg8 = {} . ). virtual . Add a box with parameter values (and errors) to the specified frame. ; The following named arguments are supported. Type of CmdArg Effect on parameter box . Parameters(const RooArgSet& param) Only the specified subset of parameters will be shown. By default all non-constant parameters are shown. . ShowConstants(bool flag) Also display constant parameters . Format(const char* what,...) Parameter formatting options. . Parameter Format . const char* what Controls what is shown. ""N"" adds name (alternatively, ""T"" adds the title), ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value . FixedPrecision(int n) Controls precision, set fixed number of digits . AutoPrecision(int n) Controls precision. Number of shown digits is calculated from error + n specified additional digits (1 is sensible default) . Label(const chat* label) Add label to parameter box. Use \n for multi-line labels. . Layout(double xmin, double xmax, double ymax) Specify relative position of left/right side of box and top of box. Coordinates are given as position on the pad between 0 and 1. The lower end of the box is calculated automatically from the number of lines in the box. . Example use: pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;; Formatstatic char * Format(const char *format, va_list ap)Format a string in a circular formatting buffer (using a printf style format descriptor).Definition TString.cxx:2442. PyROOT; The RooAbsPdf::paramOn() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 2285 of file RooAbsPdf.cxx. ◆ plotOn() [1/3]. RooAbsPdf::plotOn ; (; RooPlot * ; frame, . const RooCmdArg & ; arg1 = {}, . const RooCmdArg & ; arg2 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:135805,error,error,135805,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['error'],['error']
Availability,"arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; Return a binned generator context. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:56926,error,errors,56926,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,2,['error'],['errors']
Availability,"arg5, RooCmdArg arg6, RooCmdArg arg7, RooCmdArg arg8). for documentation of options. RooFitResult* chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); Internal back-end function to steer chi2 fits. RooAbsReal* createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create a chi-2 from a histogram and this function. The following named arguments are supported. Options to control construction of the chi^2. Extended() -- Use expected number of events of an extended p.d.f as normalization; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables. RooAbsReal* createChi2(RooDataSet& data, const RooLinkedList& cmdList); Internal back-end function to create a chi^2 from a p.d.f. and a dataset. void printValue(ostream& os) const; Print value of p.d.f, also print normalization integral that was last used, if any. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print multi line detailed information of this RooAbsPdf. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Interface function to create a generator context from a p.d.f. This default; implementation returns a 'standard' context that works for any p.d.f. RooDataSet * generate(const RooArgSet& whatVars, Int_t nEvents, const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:55172,error,errors,55172,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,4,['error'],['errors']
Availability,"arg6={});  Add a message logging stream for message with given RooFit::MsgLevel or higher. ;  ; void clearErrorCount ();  ; Int_t & debugCode ();  ; RooWorkspace * debugWorkspace ();  ; void deleteStream (Int_t id);  Delete stream with given unique ID code. ;  ; Int_t errorCount () const;  ; StreamConfig & getStream (Int_t id);  ; bool getStreamStatus (Int_t id) const;  Get activation status of stream with given unique ID. ;  ; RooFit::MsgLevel globalKillBelow () const;  ; TClass * IsA () const override;  ; template<class T > ; bool isActive (T self, RooFit::MsgTopic topic, RooFit::MsgLevel level);  Check if logging is active for given object/topic/RooFit::MsgLevel combination. ;  ; std::ostream & log (const RooAbsArg *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with RooAbsArg object self at given level and topic. ;  ; std::ostream & log (const TObject *self, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  Log error message associated with TObject object self at given level and topic. ;  ; std::ostream & log (std::nullptr_t, RooFit::MsgLevel level, RooFit::MsgTopic facility, bool forceSkipPrefix=false);  ; Int_t numStreams () const;  ; void Print (Option_t *options=nullptr) const override;  Print configuration of message service. ;  ; void reset ();  ; void restoreState ();  Restore last saved state of message service. ;  ; void saveState ();  Save current state of message service. ;  ; void setGlobalKillBelow (RooFit::MsgLevel level);  ; void setSilentMode (bool flag);  ; void setStreamStatus (Int_t id, bool active);  (De)Activate stream with given unique ID ;  ; void showPid (bool flag);  ; bool silentMode () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMsgService.html:3803,error,error,3803,doc/master/classRooMsgService.html,https://root.cern,https://root.cern/doc/master/classRooMsgService.html,1,['error'],['error']
Availability,"arg8 = RooCmdArg::none()); virtual RooPlot*RooAbsData::statOn(RooPlot* frame, const char* what, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.14999999999999999, Double_t xmax = 0.65000000000000002, Double_t ymax = 0.84999999999999998, const char* cutSpec = 0, const char* cutRange = 0, const RooCmdArg* formatCmd = 0); RooAbsDataStore*RooAbsData::store(); const RooAbsDataStore*RooAbsData::store() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual Double_tRooAbsData::sumEntries() const; virtual Double_tRooAbsData::sumEntries(const char* cutSpec, const char* cutRange = 0) const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; virtual Roo1DTable*RooAbsData::table(const RooArgSet& catSet, const char* cuts = """", const char* opts = """") const; virtual Roo1DTable*RooAbsData::table(const RooAbsCategory& cat, const char* cuts = """", const char* opts = """") const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const TTree*RooAbsData::tree() const; virtual voidTObject::UseCurrentStyle(); virtual Bool_tRooAbsData::valid() const; virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Double_tRooAbsData::weight() const; virtual Double_tRooAbsData::weightError(RooAbsData::ErrorType etype = Poisson) const; virtual voidRooAbsData::weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = Poisson) const; virtual Double_tRooAbsData::weightSquared() const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:12569,Error,ErrorType,12569,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,4,['Error'],['ErrorType']
Availability,"arge number of new and delete calls in large; loops like this (O(100000) x O(10000) times new/delete):. TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; a[i] = new TTrack(x,y,z,...);. }. a.Delete();; }. One better uses a TClonesArray which reduces the number of; new/delete calls to only O(10000):. TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000) events; for (int i = 0; i < ev->Ntracks; i++) { // O(10000) tracks; new(a[i]) TTrack(x,y,z,...);. }. a.Delete();; }. Note: the only supported way to add objects to a TClonesArray is; via the new with placement method. The diffrent Add() methods of; TObjArray and its base classes are not allowed. Considering that a new/delete costs about 70 mus on a 300 MHz HP,; O(10^9) new/deletes will save about 19 hours. NOTE 1. C/C++ offer the possibility to allocate and delete memory.; Forgetting to delete allocated memory is a programming error that originate ""leaks"",; i.e. the memory of your process grows and eventually your program crashes.; Even if you *always* delete the allocated memory, the recovered space may not be; efficiently reused. The process knows that there are portions of free memory,; but when you allocate it again, a fresh piece of memory is grabbed.; Your program is free from semantic errors, but the total memory of your process; still grows. Moreover your program's memory is full of ""holes"" which reduce the; efficiency of memory access, this is called ""memory fragmentation"".; Moreover new / delete are expensive operations in terms of CPU time. Without entering into technical details, the TClonesArray allow to ""reuse"" the; same portion of memory for new/delete avoiding memory fragmentation and memory; growth and improving by orders of magnitude the performance. Every time the; memory of the TClonesArray has to be reused, the Clear() method is employed.; To provide its benefits, each TClone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClonesArray.html:1577,error,error,1577,root/html528/TClonesArray.html,https://root.cern,https://root.cern/root/html528/TClonesArray.html,2,['error'],['error']
Availability,"arget axes will be kept, but only bins inside the selected range will be filled.; NOTE that if a TH1D named ""name"" exists in the current directory or pad, the histogram is reset and filled again with the projected contents of the TH3.; implemented using Project3D ; Definition at line 1812 of file TH3.cxx. ◆ PutStats(). void TH3::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimplemented from TH1.; Reimplemented in TProfile3D.; Definition at line 2889 of file TH3.cxx. ◆ Rebin3D(). TH3 * TH3::Rebin3D ; (; Int_t ; nxgroup = 2, . Int_t ; nygroup = 2, . Int_t ; nzgroup = 2, . const char * ; newname = """" . ). virtual . Rebin this histogram grouping nxgroup/nygroup/nzgroup bins along the xaxis/yaxis/zaxis together. ; if newname is not blank a new temporary histogram hnew is created. else the current histogram is modified (default) The parameter nxgroup/nygroup indicate how many bins along the xaxis/yaxis of this have to me merged into one bin of hnew If the original histogram has errors stored (via Sumw2), the resulting histograms has new errors correctly calculated.; examples: if hpxpy is an existing TH3 histogram with 40 x 40 x 40 bins hpxpypz->Rebin3D(); // merges two bins along the xaxis and yaxis in one in hpxpypz // Carefull: previous contents of hpxpy are lost hpxpypz->RebinX(5); //merges five bins along the xaxis in one in hpxpypz TH3 *hnew = hpxpypz->RebinY(5,""hnew""); // creates a new histogram hnew // merging 5 bins of h1 along the yaxis in one bin; NOTE : If nxgroup/nygroup is not an exact divider of the number of bins, along the xaxis/yaxis the top limit(s) of the rebinned histogram is changed to the upper edge of the xbin=newxbins*nxgroup resp. ybin=newybins*nygroup and the corresponding bins are added to the overflow bin. Statistics will be recomputed from the new bin contents. ; Definition at line 2957 of file TH3.cxx. ◆ RebinX(). TH3 * TH3::RebinX ; (; Int_t ; ngroup = 2, . const char * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:99252,error,errors,99252,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,2,['error'],['errors']
Availability,"arget value y0; the graph is evaluated using linear interpolation by default.; if option = ""S"" a TSpline3 is used. double FindInterpolatedLimit(double target, bool lowSearch = false, double xmin = 1, double xmax = 0); interpolate to find a limit value; Use a linear or a spline interpolation depending on the interpolation option. int FindClosestPointIndex(double target, int mode = 0, double xtarget = 0); if mode = 0; find closest point to target in Y, the object closest to the target which is 3 sigma from the target; and has smaller error; if mode = 1; find 2 closest point to target in X and between these two take the one closer to the target; if mode = 2 as in mode = 1 but return the lower point not the closest one; if mode = 3 as in mode = 1 but return the upper point not the closest one. Double_t LowerLimit(). Double_t UpperLimit(); std::cout << ""finding point with cl = "" << (1-ConfidenceLevel())/2 << endl;. Double_t CalculateEstimatedError(double target, bool lower = true, double xmin = 1, double xmax = 0); Return an error estimate on the upper(lower) limit. This is the error on; either CLs or CLsplusb divided by an estimate of the slope at this; point. Double_t LowerLimitEstimatedError(); need to have compute first lower limit. Double_t UpperLimitEstimatedError(). SamplingDistribution * GetBackgroundTestStatDist(int index) const; get the background test statistic distribution. SamplingDistribution * GetSignalAndBackgroundTestStatDist(int index) const; get the signal and background test statistic distribution. SamplingDistribution * GetExpectedPValueDist(int index) const; get the expected p-value distribution at the scanned point index. SamplingDistribution * GetLimitDistribution(bool lower) const; get the limit distribution (lower/upper depending on the flag); by interpolating the expected p values for each point. double GetExpectedLowerLimit(double nsig = 0, const char* opt = """") const; Get the expected lower limit; nsig is used to specify which expected value ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html:13943,error,error,13943,root/html534/RooStats__HypoTestInverterResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestInverterResult.html,6,['error'],['error']
Availability,"arget; 113 ; 114Bool_t TMVA::MethodDNN::HasAnalysisType(Types::EAnalysisType type,; 115 UInt_t numberClasses,; 116 UInt_t /*numberTargets*/ ); 117{; 118 if (type == Types::kClassification && numberClasses == 2 ) return kTRUE;; 119 if (type == Types::kMulticlass ) return kTRUE;; 120 if (type == Types::kRegression ) return kTRUE;; 121 ; 122 return kFALSE;; 123}; 124 ; 125////////////////////////////////////////////////////////////////////////////////; 126/// default initializations; 127 ; 128void TMVA::MethodDNN::Init() {; 129 Log() << kWARNING; 130 << ""MethodDNN is deprecated and it will be removed in future ROOT version. ""; 131 ""Please use MethodDL ( TMVA::kDL)""; 132 << Endl;; 133 ; 134}; 135 ; 136////////////////////////////////////////////////////////////////////////////////; 137/// Options to be set in the option string:; 138///; 139/// - LearningRate <float> DNN learning rate parameter.; 140/// - DecayRate <float> Decay rate for learning parameter.; 141/// - TestRate <int> Period of validation set error computation.; 142/// - BatchSize <int> Number of event per batch.; 143///; 144/// - ValidationSize <string> How many events to use for validation. ""0.2""; 145/// or ""20%"" indicates that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Default: 20%)"");; 162 ; 163 DeclareOptionRef(fErrorStrategy=""CROSSENTROPY"",; 164 ""ErrorStrategy"",; 165 ""Loss function: Mean squared error (regression)""; 166 "" or cross entropy (binary classification)."");; 167 AddPreDefVal(TString(""CROSSEN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:4856,error,error,4856,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['error'],['error']
Availability,"arget; Int_tfNumParnumber of parameters; vector<Double_t>fParametersvector holding the current parameters . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MinuitWrapper(TMVA::IFitterTarget& target, Int_t maxpar); constructor. Int_t Eval(Int_t , Double_t* , Double_t& , Double_t* , Int_t ); std::vector<Double_t> parameters( npar );. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); Execute a fitter command;; command : command string; args : list of nargs command arguments. void Clear(Option_t* = 0); reset the fitter environment. Int_t GetStats(Double_t& amin, Double_t& edm, Double_t& errdef, Int_t& nvpar, Int_t& nparx); return global fit parameters; amin : chisquare; edm : estimated distance to minimum; errdef; nvpar : number of variable parameters; nparx : total number of parameters. Int_t GetErrors(Int_t ipar, Double_t& eplus, Double_t& eminus, Double_t& eparab, Double_t& globcc); return current errors for a parameter; ipar : parameter number; eplus : upper error; eminus : lower error; eparab : parabolic error; globcc : global correlation coefficient. Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); set initial values for a parameter; ipar : parameter number; parname : parameter name; value : initial parameter value; verr : initial error for this parameter; vlow : lower value for the parameter; vhigh : upper value for the parameter. TObject * Clone(const char* ) const; produces a clone of this MinuitWrapper. virtual ~MinuitWrapper(); {}. void SetFitterTarget(TMVA::IFitterTarget& target); { fFitterTarget = target; }. » Author: Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MinuitWrapper.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MinuitWrapper.html:19325,error,error,19325,root/html530/TMVA__MinuitWrapper.html,https://root.cern,https://root.cern/root/html530/TMVA__MinuitWrapper.html,1,['error'],['error']
Availability,"argument returning a single number result:; ties = ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGraphSmooth.html:17395,down,down,17395,root/html534/TGraphSmooth.html,https://root.cern,https://root.cern/root/html534/TGraphSmooth.html,2,['down'],['down']
Availability,"argument returning a single number result:; ties = ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 16:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGraphSmooth.html:17886,down,down,17886,root/html604/TGraphSmooth.html,https://root.cern,https://root.cern/root/html604/TGraphSmooth.html,2,['down'],['down']
Availability,"argument returning a single number result:; ties = ""ordered"" (iTies = 0): input x are ""ordered""; ties = ""mean"" (iTies = 1): function ""mean""; ties = ""min"" (iTies = 2): function ""min""; ties = ""max"" (iTies = 3): function ""max"". Details:; At least two complete (x, y) pairs are required.; If there are duplicated (tied) x values and ties is a function it is; applied to the y values for each distinct x value. Useful functions in; this context include mean, min, and max.; If ties=""ordered"" the x values are assumed to be already ordered. The; first y value will be used for interpolation to the left and the last; one for interpolation to the right. Value:; approx returns a graph with components x and y, containing n coordinates; which interpolate the given data points according to the method (and rule); desired. Double_t Approx1(Double_t v, Double_t f, Double_t* x, Double_t* y, Int_t n, Int_t iKind, Double_t Ylow, Double_t Yhigh); Approximate one data point*-*-*-*-*-; *-* ==========================. Approximate y(v), given (x,y)[i], i = 0,..,n-1; Based on R function approx1: Translated to C++ by Christian Stratowa; (R source file: approx.c by R Development Core Team (C) 1999-2001). Int_t Rcmp(Double_t x, Double_t y); static function; if (ISNAN(x)) return 1;; if (ISNAN(y)) return -1;. void Psort(Double_t* x, Int_t n, Int_t k); static function; based on R function rPsort: adapted to C++ by Christian Stratowa; (R source file: R_sort.c by R Development Core Team (C) 1999-2001). void Rank(Int_t n, Double_t* a, Int_t* index, Int_t* rank, Bool_t down = kTRUE); static function. TGraphSmooth(const TGraphSmooth& ). TGraphSmooth& operator=(const TGraphSmooth& ). » Author: Christian Stratowa 30/09/2001 » Copyright (c) 2001- , Dr. Christian Stratowa, Vienna, Austria. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 15:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGraphSmooth.html:17886,down,down,17886,root/html602/TGraphSmooth.html,https://root.cern,https://root.cern/root/html602/TGraphSmooth.html,2,['down'],['down']
Availability,"argument values. const char * CreatePopupTitle(TObject* object); Create title for popup menu. void Execute(TObject *object, TFunction *method, const char *params); Execute method with specified arguments for specified object. void Execute(TObject *object, TFunction *method, TObjArray *params); Execute method with specified arguments for specified object. void Popup(Int_t x, Int_t y, TObject* obj, TVirtualPad* c = 0, TVirtualPad* p = 0); Popup context menu at given location in canvas c and pad p for selected; object. void Popup(Int_t x, Int_t y, TObject* obj, TBrowser* b); Popup context menu at given location in browser b for selected object. TContextMenu(const TContextMenu& ). TContextMenu& operator=(const TContextMenu& ). void DisplayPopUp(Int_t x, Int_t y); { if (fContextMenuImp) fContextMenuImp->DisplayPopup(x, y); }. TContextMenu(). void Action(TObject *object, TMethod *method). void Action(TObject *object, TToggle *toggle). void Execute(const char *method, const char *params, Int_t *error=0); { TObject::Execute(method, params, error); }. void Execute(TMethod *method, TObjArray *params, Int_t *error=0); { TObject::Execute(method, params, error); }. void Execute(TObject *object, TFunction *method, const char *params). void Execute(TObject *object, TFunction *method, TObjArray *params). TBrowser * GetBrowser(); { return fBrowser; }. TContextMenuImp * GetContextMenuImp(); { return fContextMenuImp; }. TVirtualPad * GetSelectedCanvas(); { return fSelectedCanvas; }. TFunction * GetSelectedMethod(); { return fSelectedMethod; }. TObject * GetSelectedObject(); { return fSelectedObject; }. TObject * GetCalledObject(); { return fCalledObject; }. TClassMenuItem * GetSelectedMenuItem(); { return fSelectedMenuItem; }. TVirtualPad * GetSelectedPad(); { return fSelectedPad; }. void SetCanvas(TVirtualPad* c); { fSelectedCanvas = c; }. void SetBrowser(TBrowser* b); { fBrowser = b; }. void SetMethod(TFunction* m); { fSelectedMethod = m; }. void SetCalledObject(TObject* o); { fCall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TContextMenu.html:9828,error,error,9828,root/html526/TContextMenu.html,https://root.cern,https://root.cern/root/html526/TContextMenu.html,2,['error'],['error']
Availability,"ariable (override if minimizer supports them ) otherwise as default set an unlimited variable ;  ; virtual bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower);  set a new lower limit variable (override if minimizer supports them ) ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; virtual bool SetUpperLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double upper);  set a new upper limit variable (override if minimizer supports them ) ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariable (unsigned int ivar, const std::string &name, double val, double step)=0;  set a new free variable ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; virtual bool SetVariableLimits (unsigned int ivar, double lower, double upper);  set the limits of an already existing variable ;  ; virtual bool SetVariableLowerLimit (unsigned int ivar, double lower);  set the lower-limit of an already existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; virtual bool SetVariableStepSize (unsig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:11210,toler,tolerance,11210,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"ariable (override if minimizer supports them ) otherwise as default set an unlimited variable ;  ; virtual bool SetLowerLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double lower);  set a new lower limit variable (override if minimizer supports them ) ;  ; void SetMaxFunctionCalls (unsigned int maxfcn);  set maximum of function calls ;  ; void SetMaxIterations (unsigned int maxiter);  set maximum iterations (one iteration can have many function calls) ;  ; void SetOptions (const MinimizerOptions &opt);  set all options in one go ;  ; void SetPrecision (double prec);  set in the minimizer the objective function evaluation precision ( a value <=0 means the minimizer will choose its optimal value automatically, i.e. ;  ; void SetPrintLevel (int level);  set print level ;  ; void SetStrategy (int strategyLevel);  set the strategy ;  ; void SetTolerance (double tol);  set the tolerance ;  ; virtual bool SetUpperLimitedVariable (unsigned int ivar, const std::string &name, double val, double step, double upper);  set a new upper limit variable (override if minimizer supports them ) ;  ; void SetValidError (bool on);  flag to check if minimizer needs to perform accurate error analysis (e.g. run Hesse for Minuit) ;  ; virtual bool SetVariableInitialRange (unsigned int, double, double);  set the initial range of an existing variable ;  ; virtual bool SetVariableLimits (unsigned int ivar, double lower, double upper);  set the limits of an already existing variable ;  ; virtual bool SetVariableLowerLimit (unsigned int ivar, double lower);  set the lower-limit of an already existing variable ;  ; template<class VariableIterator > ; int SetVariables (const VariableIterator &begin, const VariableIterator &end);  add variables . Return number of variables successfully added ;  ; virtual bool SetVariableStepSize (unsigned int ivar, double value);  set the step size of an already existing variable ;  ; virtual bool SetVariableUpperLimit (unsigne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:8447,toler,tolerance,8447,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,2,"['error', 'toler']","['error', 'tolerance']"
Availability,"ariable if so designated; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooXYChi2Var(); coverity[UNINIT_CTOR]. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where the weight is interpreted; as the Y value and the weight error is interpreted as the Y value error. The weight must have an; non-zero error defined at each point for the chi^2 calculation to be meaningful. To store errors associated with the x and y values in a RooDataSet, call RooRealVar::setAttribute(""StoreError""); on each X-type observable for which the error should be stored and add datapoints to the dataset as follows. RooDataSet::add(xset,yval,yerr) where xset is the RooArgSet of x observables (with or without errors) and yval and yerr; are the Double_t values that correspond to the Y and its error. RooXYChi2Var(const char* name, const char* title, RooAbsReal& func, RooDataSet& data, RooRealVar& yvar, Bool_t integrate = kFALSE). RooXYChi2Var constructor with function and X-Y values dataset. An X-Y dataset is a weighted dataset with one or more observables X where given yvar is interpreted; as the Y value. The Y variable must have a non-zero error defined at each point for the chi^2 calculation to be meaningful. To store errors associated with the x and y values in a RooDataSet, call RooRealVar::setAttribute(""StoreError""); on each X-type observable for which the error should be stored and add datapoints to the dataset as follows. RooDataSet::add(xset,yval,yerr) where xset is the RooArgSet of x observables (with or without errors) and yval and yerr; are the Double_t values that correspond to the Y and its error. RooXYChi2Var(const char* name, const char* title, RooAbsPdf& extPdf, RooDataSet&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooXYChi2Var.html:37421,error,errors,37421,root/html528/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html528/RooXYChi2Var.html,20,['error'],"['error', 'errors']"
Availability,"ariables. RooAbsData* emptyClone(const char* newName = 0, const char* newTitle = 0, const RooArgSet* vars = 0) const; Return an empty clone of this dataset. If vars is not null, only the variables in vars; are added to the definition of the empty clone. void initialize(const char* wgtVarName); Initialize the dataset. If wgtVarName is not null, interpret the observable; with that name as event weight. RooAbsData* reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ~RooDataSet(); Destructor. RooDataHist* binnedClone(const char* newName = 0, const char* newTitle = 0) const; Return binned clone of this dataset. Double_t weight() const; Return event weight of current event. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = SumW2) const. Double_t weightError(RooAbsData::ErrorType etype = SumW2) const. const RooArgSet* get(Int_t index) const; Return RooArgSet with coordinates of event 'index'. Double_t sumEntries() const. Double_t sumEntries(const char* cutSpec, const char* cutRange = 0) const; Return the sum of weights in all entries matching cutSpec (if specified); and in named range cutRange (if specified). Bool_t isWeighted() const; Return true if dataset contains weighted events. Bool_t isNonPoissonWeighted() const; Returns true if histogram contains bins with entries with a non-integer weight. const RooArgSet* get() const; Return a RooArgSet with the coordinates of the current event. void add(const RooArgSet& row, Double_t weight = 1.0, Double_t weightError = 0); Add a data point, with its coordinates specified in the 'data' argset, to the data set.; Any variables present in 'data' but not in the dataset will be silently ignored. void add(const RooArgSet& row, Double_t weight, Double_t weightErrorLo, Double_t weightErrorHi); Add a data point, wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDataSet.html:26459,Error,ErrorType,26459,root/html532/RooDataSet.html,https://root.cern,https://root.cern/root/html532/RooDataSet.html,1,['Error'],['ErrorType']
Availability,"ariance matrix calculation will re-implement the method. { return 0; }. double Correlation(unsigned int i, unsigned int j) const. return correlation coefficient between variable i and j.; If the variable is fixed or const the return value is zero. double GlobalCC(unsigned int ) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. { return -1; }. bool GetMinosError(unsigned int , double& errLow, double& errUp, int = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (runopt=-1) or the upper (runopt=+1) error calculation is run; (This feature isnot yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. { return false; }. bool Scan(unsigned int , unsigned int& , double* , double* , double = 0, double = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int , unsigned int , unsigned int& , double* , double* ). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. { return std::string();}. int Vari",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__Minimizer.html:7766,error,error,7766,root/html526/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__Minimizer.html,5,['error'],['error']
Availability,"ariance& cov, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnUserCovariance& cov, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::MnFcn& mfcn, const ROOT::Minuit2::GradientCalculator& gc, const ROOT::Minuit2::MinimumSeed& seed, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn, double toler) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, unsigned int nrow, const vector<double>& cov, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; ROOT::Minuit2::ModularFunctionMinimizerROOT::Minuit2::ModularFunctionMinimizer::ModularFunctionMinimizer(); ROOT::Minuit2::ModularFunctionMinimizerROOT::Minuit2::ModularFunctionMinimizer::ModularFunctionMinimizer(const ROOT::Minuit2::ModularFunctionMinimizer&); ROOT::Minuit2::FumiliMinimizer&operator=(const ROOT::Minuit2::FumiliMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Data Members; private:. ROOT::Minuit2::FumiliBuilderfMinBuilder; ROOT::Minuit2::MnSeedGeneratorfMinSeedGen. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; FumiliMinimizer(). Constructor initializing the FumiliMinimizer by instantiatiating; the SeedGenerator and MinimumBuilder for the Fumili minimization method. @see MnSeedGenerator. @see FumiliBuilder. {}. ~FumiliMinimizer(); {}. Func",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__FumiliMinimizer.html:3811,toler,toler,3811,root/html602/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__FumiliMinimizer.html,4,['toler'],['toler']
Availability,"aried quantity, a map/dictionary of varied results can be produced with ROOT::RDF::Experimental::VariationsFor (see the example below).; The dictionary will contain a ""nominal"" value (accessed with the ""nominal"" key) for the unchanged result, and values for each of the systematic variations that affected the result (via upstream Filters or via direct or indirect dependencies of the column values on some registered variations). The keys will be a composition of variation names and tags, e.g. ""pt:up"" and ""pt:down"" for the example below.; In the following example we add up/down variations of pt and fill a histogram with a quantity that depends on pt. We automatically obtain three histograms in output (""nominal"", ""pt:up"" and ""pt:down""): auto nominal_hx =; df.Vary(""pt"", [] (double pt) { return RVecD{pt*0.9, pt*1.1}; }, {""down"", ""up""}); .Filter(""pt > k""); .Define(""x"", someFunc, {""pt""}); .Histo1D(""x"");; ; auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; hx[""nominal""].Draw();; hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; RDataFrame computes all variations as part of a single loop over the data. In particular, this means that I/O and computation of values shared among variations only happen once for all variations. Thus, the event loop run-time typically scales much better than linearly with the number of variations.; RDataFrame lazily computes the varied values required to produce the outputs of VariationsFor(). If VariationsFor() was not called for a result, the computations are only run for the nominal case.; See other overloads for examples when variations are added for multiple existing columns, or when the tags are auto-generated instead of being directly defined. ; Definition at line 862 of file RInterface.hxx. ◆ Vary() [9/11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; std::string_view ; colName, . F && ; expression, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:150284,down,down,150284,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['down'],['down']
Availability,"aries for the frequentist Clopper-Pearson interval.Definition TEfficiency.cxx:2016; TF11-Dim function classDefinition TF1.h:233; TGraphMultiErrorsTGraph with asymmetric error bars and multiple y error dimensions.Definition TGraphMultiErrors.h:29; TGraphMultiErrors::fEyLSumDouble_t * fEyLSum! Array of summed Y low errors for fittingDefinition TGraphMultiErrors.h:39; TGraphMultiErrors::GetFillColorvirtual Color_t GetFillColor() constReturn the fill area color.Definition TAttFill.h:30; TGraphMultiErrors::GetEYhighDouble_t * GetEYhigh() const overrideGet all high errors on y coordinates as an array summed according to fSumErrorsMode.Definition TGraphMultiErrors.cxx:1588; TGraphMultiErrors::GetErrorXDouble_t GetErrorX(Int_t i) const overrideGet error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1439; TGraphMultiErrors::GetFillStylevirtual Style_t GetFillStyle() constReturn the fill area style.Definition TAttFill.h:31; TGraphMultiErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on x coordinate for point i.Definition TGraphMultiErrors.cxx:1492; TGraphMultiErrors::SetPointErrorvirtual void SetPointError(Double_t exL, Double_t exH, Double_t eyL1, Double_t eyH1, Double_t eyL2=0., Double_t eyH2=0., Double_t eyL3=0., Double_t eyH3=0.)Set ex and ey values for point pointed by the mouse.Definition TGraphMultiErrors.cxx:1793; TGraphMultiErrors::GetAttLinevirtual TAttLine * GetAttLine(Int_t e)Get AttLine pointer for specified error dimension.Definition TGraphMultiErrors.cxx:1632; TGraphMultiErrors::SetFillColorAlphavirtual void SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha)Set Fill Color and Alpha of error e (-1 = Global and x errors).Definition TGraphMultiErrors.cxx:2051; TGraphMultiErrors::GetLineColorvirtual Color_t GetLineColor() constReturn the line color.Definition TAttLine.h:33; TGraphMultiErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t i) const overrideGet low error on y coordinate for point i.Definition TGraphMult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:77454,error,error,77454,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"arized error is calculated as follows: ; \[; \mathrm{error}(x) = Z * F_a(x) * \mathrm{Corr}(a,a') * F_{a'}^\mathrm{T}(x),; \]. where ; \[; F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; \]. with \( f(x) \) the plotted curve and \( \mathrm{d}a \) taken from the fit result, and \( \mathrm{Corr}(a,a') \) = the correlation matrix from the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111) Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. ; Definition at line 2601 of file RooAbsReal.cxx. ◆ plotSamplingHint(). std::list< double > * RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAdditio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:138766,error,error,138766,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,"arized error is calculated as follows: ; \[; \mathrm{error}(x) = Z * F_a(x) * \mathrm{Corr}(a,a') * F_{a'}^\mathrm{T}(x),; \]. where ; \[; F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; \]. with \( f(x) \) the plotted curve and \( \mathrm{d}a \) taken from the fit result, and \( \mathrm{Corr}(a,a') \) = the correlation matrix from the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111) Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. ; Definition at line 2686 of file RooAbsReal.cxx. ◆ plotSamplingHint(). std::list< double > * RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAdditio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:140193,error,error,140193,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability,arker size combo box; TGedMarkerSelect*fMarkerStylegeneral marker style entry; TGMenuBar*fMenuBarthe main window menu bar; TGPopupMenu*fMenuHelpthe 'Help' popup menu; TGPopupMenu*fMenuStylethe 'Style' popup menu; Bool_tfMoreAndNotLess=kTRUE when editor is open; TGTextButton*fMoreLessopen/close the editor; TGNumberEntry*fNumberContourshistograms number of contours number entry; TGCheckButton*fOptDateBoolcanvas date show/hide check box; TGComboBox*fOptDateFormatcanvas date format text entry; TGCheckButton*fOptFitChifit Chi show/hide check box; TGCheckButton*fOptFitErrorsfit errors check box; TGCheckButton*fOptFitProbabilityfit probability show/hide check box; TGCheckButton*fOptFitValuesfit values show/hide check box; TGCheckButton*fOptLogxX axis logarithmic scale check box; TGCheckButton*fOptLogyY axis logarithmic scale check box; TGCheckButton*fOptLogzZ axis logarithmic scale check box; TGCheckButton*fOptStatEntriesstats entries show/hide check box; TGCheckButton*fOptStatErrorsstats errors check box; TGCheckButton*fOptStatIntegralstats integral show/hide check box; TGCheckButton*fOptStatKurtosisstats kurtosis show/hide check box; TGCheckButton*fOptStatMeanstats mean show/hide check box; TGCheckButton*fOptStatNamestats name show/hide check box; TGCheckButton*fOptStatOverflowstats overflow show/hide check box; TGCheckButton*fOptStatRMSstats RMS show/hide check box; TGCheckButton*fOptStatSkewnessstats Skewness show/hide check box; TGCheckButton*fOptStatUnderflowstats underflow show/hide check box; TGCheckButton*fOptTitletitle show/hide check box; TGButtonGroup*fPadBorderModepad border mode button group; TGLineWidthComboBox*fPadBorderSizepad border size combo box; TGNumberEntry*fPadBottomMarginpad bottom margin number entry; TGColorSelect*fPadColorpad fill color selection widget; TGCheckButton*fPadGridXpad grid along X show/hide check box; TGCheckButton*fPadGridYpad grid along Y show/hide check box; TGNumberEntry*fPadLeftMarginpad left margin number entry; TGNumberEntry*f,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:40320,error,errors,40320,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,10,['error'],['errors']
Availability,"arker::SetMarkerStyle(Style_t mstyle = 1); virtual voidSetMaximum(Double_t maximum = -1111)MENU ; virtual voidSetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidSetNDF(Int_t ndf); virtual voidSetNormalized(Bool_t flag); virtual voidSetNpx(Int_t npx = 100)MENU ; virtual voidSetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetParameter(Int_t param, Double_t value); virtual voidSetParameter(const TString& name, Double_t value); virtual voidSetParameters(const Double_t* params); virtual voidSetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidSetParent(TObject* p = 0); virtual voidSetParError(Int_t ipar, Double_t error); virtual voidSetParErrors(const Double_t* errors); virtual voidSetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidSetParName(Int_t ipar, const char* name); virtual voidSetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax)MENU ; virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidSetSavedPoint(Int_t point, Double_t value); virtual voidSetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:17797,error,errors,17797,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,2,['error'],['errors']
Availability,"arkerStyle(Style_t mstyle = 1); virtual voidTF1::SetMaximum(Double_t maximum = -1111)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNormalized(Bool_t flag); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTF1::SetParameter(Int_t param, Double_t value); virtual voidTF1::SetParameter(const TString& name, Double_t value); virtual voidTF1::SetParameters(const Double_t* params); virtual voidTF1::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTF1::SetParName(Int_t ipar, const char* name); virtual voidTF1::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidTF1::SetRange(Double_t xmin, Double_t xmax)MENU ; virtual voidTF1::SetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidTF1::SetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax); virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidSetXY(Double_t xy)MENU ; virtual voidSho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF12.html:13503,error,error,13503,root/html604/TF12.html,https://root.cern,https://root.cern/root/html604/TF12.html,2,['error'],['error']
Availability,"arlowBeestonLLRooBarlowBeestonLL(const char* name, const char* title, RooAbsReal& nll); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); voidsetDataset(RooAbsData* data); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidsetPdf(RooAbsPdf* pdf); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html:24423,Error,ErrorLoggingMode,24423,root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__RooBarlowBeestonLL.html,3,['Error'],['ErrorLoggingMode']
Availability,"array of pointers to objects to read into.; 850 pp[ndx] = (char *)new char *[vlen];; 851 if (!pp[ndx]) {; 852 Error(""ReadBuffer"", ""Memory allocation failed!\n"");; 853 continue;; 854 }; 855 // And set each pointer to null.; 856 memset(pp[ndx], 0, vlen * sizeof(char *)); // This is the right size we really have a char**: pp[ndx]; 857 // = (char*) new char*[vlen];; 858 }; 859 if (!isPtrPtr) {; 860 // -- We are a varying-length array of objects.; 861 // Loop over the elements of the varying length array.; 862 for (Int_t v = 0; v < vlen; ++v) {; 863 // Read the object from the buffer.; 864 cl->Streamer(pp[ndx] + (v * cl->Size()), buf);; 865 } // v; 866 } else {; 867 // -- We are a varying-length array of object pointers.; 868 // Get a pointer to the object pointer array.; 869 char **r = (char **)pp[ndx];; 870 // Loop over the elements of the varying length array.; 871 for (Int_t v = 0; v < vlen; ++v) {; 872 // Allocate an object to read into.; 873 r[v] = (char *)cl->New();; 874 if (!r[v]) {; 875 // Do not print a second error message here.; 876 // Error(""ReadBuffer"", ""Memory allocation failed!\n"");; 877 continue;; 878 }; 879 // Read the object from the buffer.; 880 cl->Streamer(r[v], buf);; 881 } // v; 882 } // isPtrPtr; 883 } // ndx; 884 // } // k; 885 } // fileVersion; 886 buf.CheckByteCount(start, count, config->fCompInfo->fElem->GetFullName());; 887 return 0;; 888 }; 889 ; 890 class TConfWithFactor : public TConfiguration {; 891 // Configuration object for the Float16/Double32 where a factor has been specified.; 892 public:; 893 Double_t fFactor;; 894 Double_t fXmin;; 895 TConfWithFactor(TVirtualStreamerInfo *info, UInt_t id, TCompInfo_t *compinfo, Int_t offset, Double_t factor, Double_t xmin) : TConfiguration(info,id,compinfo,offset),fFactor(factor),fXmin(xmin) {};; 896 TConfiguration *Copy() override { return new TConfWithFactor(*this); }; 897 };; 898 ; 899 template <typename T>; 900 INLINE_TEMPLATE_ARGS Int_t ReadBasicType_WithFactor(TBuffer &buf, void *addr, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:35574,error,error,35574,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['error'],['error']
Availability,"array out-of-bound; 4300/// * ability to use the branch data as object (when the user code is available); 4301///; 4302/// See TTree::MakeProxy for more details.; 4303///; 4304/// ### Making a Profile histogram; 4305///; 4306/// In case of a 2-Dim expression, one can generate a TProfile histogram; 4307/// instead of a TH2F histogram by specifying option=prof or option=profs; 4308/// or option=profi or option=profg ; the trailing letter select the way; 4309/// the bin error are computed, See TProfile2D::SetErrorOption for; 4310/// details on the differences.; 4311/// The option=prof is automatically selected in case of y:x>>pf; 4312/// where pf is an existing TProfile histogram.; 4313///; 4314/// ### Making a 2D Profile histogram; 4315///; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:174024,error,error,174024,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"array.; if (fVertex[0]>10) fVertex[0]; if (fVertex[1]>10) fVertex[1]; if (fVertex[2]>10) fVertex[2]. tree->Draw(""fPx[600]""); tree->Draw(""fPx[600]"",""fNtrack > 600""). When using a specific element for a variable length array the entries with fewer elements are ignored. Thus these two commands are equivalent. tree->Draw(""Nation""). Nation is a char* branch. When drawing a char* it will plot an alphanumeric histogram, of the different value of the string Nation. The axis will have the Nation values. See “Histograms”. tree->Draw(""MyChar +0""). If you want to plot a char* variable as a byte rather than a string, you can use the syntax above. tree->Draw(""fTracks.fTriggerBits""). fTriggerBits is a data member of TTrack of type TBits. Objects of class TBits can be drawn directly. This command will create a 1D histogram from 0 to nbits which is filled for each non-null bit-number. tree->Draw(""fMatrix-Alt$(fClosestDistance,0)""). Alt$(primary,alternate) returns the value of “primary” if it is available for the current iteration; otherwise return the value of “alternate”. Assuming that fClosestDistance is a smaller array than fMatrix. This example will draw fMatrix[i]+fClosestDistance[i] for i less than the size of fClosestDistance, and will draw fMatrix[i]+0 for the other value of i. tree->Draw(""fClosestDistance:Iteration$""). This example draws a 2D plot with, for all entries, fClosestDistance[i]:i for each value of i between 0 and the size of fClosestDistance. Iterations$ is one of four special variables giving some indications of the state of the loops implied by the formula:; Entry$ : return the current entry number (TTree::GetReadEntry()); Entries$ : return the total number of entries (TTree::GetEntries()); Length$ : return the total number of element of this formula for this entry; Iteration$: return the current iteration over this formula for this entry (i.e. varies from 0 to Length$). tree->Draw(""fLastTrack.GetPx():fLastTrack.fPx"");. TRef and TRefArray are automatically def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:606298,avail,available,606298,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"ars. Without ""Z"", the default is to draw these. |; 226| "">"" | An arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 227| \""\|>\"" | A filled arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9130,error,error,9130,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['error'],['error']
Availability,"ars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error along x.; dx = 0 removes the error along x. gStyle->SetEndErrorSize(np) controls the size of the lines; at the end of the error bars (when option 1 is used).; By default np=1. (np represents the number of pixels).; TGraphErrors; A TGraphErrors is a TGraph with error bars. The errors are; defined along X and Y and are symmetric: The left and right errors are the same; along X and the bottom and up errors are the same along Y. Picture; Source. {; TCanvas *c4 = new TCanvas(""c4"",""c4"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraphErrors(5, x, y, ex, ey);; ge->Draw(""ap"");; return c4;; }; The option ""3"" allows to shows the error as band. Picture; Source. {; TCanvas *c41 = new TCanvas(""c41"",""c41"",200,10,600,400);; double x[] = {0, 1, 2, 3, 4};; double y[] = {0, 2, 4, 1, 3};; double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; double ey[] = {1, 0.5, 1, 0.5, 1};; TGraphErrors* ge = new TGraph",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:6175,error,error,6175,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['error']
Availability,"arse.h:67; THnSparse::fBinsTExMap fBins! Filled binsDefinition THnSparse.h:42; THnSparse::GetBinLong64_t GetBin(const Double_t *x) const overrideDefinition THnSparse.h:97; THnSparse::CreateSparsestatic THnSparse * CreateSparse(const char *name, const char *title, const THnBase *hn, Int_t chunkSize=1024 *16)Definition THnSparse.h:82; THnSparse::ProjectionTHnSparse * Projection(Int_t ndim, const Int_t *dim, Option_t *option="""") constDefinition THnSparse.h:154; THnSparse::fBinsContinuedTExMap fBinsContinued! Filled bins for non-unique hashes, containing pairs of (bin index 0, bin index 1)Definition THnSparse.h:43; THnSparse::AddBinContentvoid AddBinContent(const Int_t *idx, Double_t v=1.)Forwards to THnBase::AddBinContent().Definition THnSparse.h:113; THnSparse::Reservevoid Reserve(Long64_t nbins) overrideInitialize storage for nbins.Definition THnSparse.cxx:689; THnSparse::fChunkSizeInt_t fChunkSizeNumber of entries for each chunk.Definition THnSparse.h:39; THnSparse::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THnSparse.cxx:948; THnSparse::GetNbinsLong64_t GetNbins() const overrideDefinition THnSparse.h:93; THnSparse::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all filled bins of a THnSparse.Definition THnSparse.cxx:896; THnSparse::SetFilledBinsvoid SetFilledBins(Long64_t nbins) overrideDefinition THnSparse.h:94; THnSparse::GetBinIndexForCurrentBinLong64_t GetBinIndexForCurrentBin(Bool_t allocate)Return the index for fCurrentBinIndex.Definition THnSparse.cxx:789; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::GetEntriesFastInt_t GetEntriesFast() constDefinition TObjArray.h:58; bool; double; int; xDouble_t x[n]Definition legend1.C:17; h1TH1F * h1Definition legend1.C:5; v@ vDefinition rootcling_impl.cxx:3699; groupDefinition TWinNTSystem.h:50. histhistincTHnSparse.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:32 (GVA Time) using Doxyg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8h_source.html:17989,error,errors,17989,doc/master/THnSparse_8h_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8h_source.html,1,['error'],['errors']
Availability,"arseMSparseTranspVector (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixTBase< Double_t > *v) const;  calculate a sparse matrix product M1*V*M2T where the diagonal matrix V is given by a vector ;  ; TMatrixDSparse * MultiplyMSparseTranspMSparse (const TMatrixDSparse *a, const TMatrixDSparse *b) const;  multiply a transposed Sparse matrix with another Sparse matrix ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; TMatrixD * fAoutside;  Input: underflow/overflow bins. ;  ; TMap * fBgrErrScaleIn;  Input: background sources correlated error. ;  ; TMap * fBgrErrUncorrInSq;  Input: uncorr error squared from bgr sources. ;  ; TMap * fBgrIn;  Input: size of background sources. ;  ; TMatrixD * fDAinColRelSq;  Input: normalized column err.sq. (inp.matr.) ;  ; TMatrixDSparse * fDAinRelSq;  Input: normalized errors from input matrix. ;  ; TMap * fDeltaCorrAx;  Result: syst.shift from fSysIn on fAx. ;  ; TMap * fDeltaCorrX;  Result: syst.shift from fSysIn on fX. ;  ; TMatrixDSparse * fDeltaSysTau;  Result: systematic shift from tau. ;  ; Double_t fDtau;  Input: error on tau. ;  ; TMatrixDSparse * fEmatUncorrAx;  Result: syst.error from fDA2 on fAx. ;  ; TMatrixDSparse * fEmatUncorrX;  Result: syst.error from fDA2 on fX. ;  ; TMap * fSysIn;  Input: correlated errors. ;  ; TMatrixDSparse * fVyyData;  Input: error on fY prior to bgr subtraction. ;  ; TMatrixD * fYData;  Input: fY prior to bgr subtraction. ;  ;  Protected Attributes inherited from TUnfold; TMatrixDSparse * fA;  response matrix A ;  ; Double_t fBiasScale;  scale factor for the bias ;  ; EConstraint fConstraint;  type of constraint to use for the unfolding ;  ; TArrayI fHistToX;  mapping of histogram bins to matrix indices ;  ; TMatrixDSparse * fL;  regularisation conditions L ;  ; ERegMode fRegMode;  type of regul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:28179,error,errors,28179,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['error'],['errors']
Availability,"arsing option string: ; : ... ""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:WeightInitialization=XAVIERUNIFORM:Layout=TANH|128,TANH|128,TANH|128,LINEAR:TrainingStrategy=LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""N"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : Layout: ""TANH|128,TANH|128,TANH|128,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-2,Momentum=0.9,ConvergenceSteps=20,BatchSize=100,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,DropConfig=0.0+0.5+0.5+0.5"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : InputLayout: ""0|0|0"" [The Layout of the input]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:7152,error,error,7152,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['error'],['error']
Availability,"art (between TProofServ and TXProofServ) of the setup phase. ;  ; Bool_t UnlinkDataDir (const char *path);  Scan recursively the datadir and unlink it if empty Return kTRUE if it can be unlinked, kFALSE otherwise. ;  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Attributes; static Long64_t fgLastEntry = -1;  ; static TString fgLastMsg;  ;  Static Protected Attributes inherited from TApplication; static TList * fgApplications = nullptr;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . Private Member Functions; Bool_t AcceptResults (Int_t connections, TVirtualProofPlayer *mergerPlayer);  Accept and merge results from a set of workers. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:25612,error,error,25612,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['error'],['error']
Availability,"art (between TProofServ and TXProofServ) of the setup phase. ;  ; Bool_t UnlinkDataDir (const char *path);  Scan recursively the datadir and unlink it if empty Return kTRUE if it can be unlinked, kFALSE otherwise. ;  ;  Protected Member Functions inherited from TApplication;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  ;  Static Protected Member Functions inherited from TApplication; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static function used to attach to an existing remote application or to start one. ;  ; static Int_t ParseRemoteLine (const char *ln, TString &hostdir, TString &user, Int_t &dbg, TString &script);  Parse the content of a line starting with "".R"" (already s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLite.html:26457,error,error,26457,doc/master/classTProofServLite.html,https://root.cern,https://root.cern/doc/master/classTProofServLite.html,1,['error'],['error']
Availability,"art, Double_t end); virtual~TGeoPatternSphTheta(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidcd(Int_t idiv); virtual TGeoNode*TGeoPatternFinder::CdNext(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidTGeoPatternFinder::ClearThreadData() const; virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TGeoMatrix*CreateMatrix() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TGeoNode*FindNode(Double_t* point, const Double_t* dir = 0); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tTGeoPatternFinder::GetByteCount() const; Int_tTGeoPatternFinder::GetCurrent(); virtual Int_tGetDivAxis(); Int_tTGeoPatternFinder::GetDivIndex(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Double_tTGeoPatternFinder::GetEnd() const; virtual const char*TObject::GetIconName() const; virtual TGeoMatrix*TGeoPatternFinder::GetMatrix(); virtual const char*TObject::GetName() const; Int_tTGeoPa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoPatternSphTheta.html:2578,Error,Error,2578,root/html532/TGeoPatternSphTheta.html,https://root.cern,https://root.cern/root/html532/TGeoPatternSphTheta.html,1,['Error'],['Error']
Availability,"artViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accomodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:82978,error,error,82978,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['error'],['error']
Availability,"arting as master server (if master = """"). For a description; of the arguments see the TProof ctor. Returns the number of started; master or slave servers, returns 0 in case of error, in which case; fValid remains false. void ParseConfigField(const char* config); The config file field may contain special instructions which need to be; parsed at the beginning, e.g. for debug runs with valgrind. Int_t AssertPath(const char* path, Bool_t writable); Make sure that 'path' exists; if 'writable' is kTRUE, make also sure; that the path is writable. void SetManager(TProofMgr* mgr); Set manager and schedule its destruction after this for clean; operations. Int_t AddWorkers(TList* wrks); Works on the master node only.; It starts workers on the machines in workerList and sets the paths,; packages and macros as on the master.; It is a subbstitute for StartSlaves(...); The code is mostly the master part of StartSlaves,; with the parallel startup removed. Int_t RemoveWorkers(TList* wrks); Used for shuting down the workres after a query is finished.; Sends each of the workers from the workerList, a kPROOF_STOP message.; If the workerList == 0, shutdown all the workers. Bool_t StartSlaves(Bool_t attach = kFALSE); Start up PROOF slaves. void Close(Option_t* option = """"); Close all open slave servers.; Client can decide to shutdown the remote session by passing option is 'S'; or 's'. Default for clients is detach, if supported. Masters always; shutdown the remote counterpart. TSlave * CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); Create a new TSlave of type TSlave::kSlave.; Note: creation of TSlave is private with TProof as a friend.; Derived classes must use this function to create slaves. TSlave * CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); Create a new TSlave of type TSlave::kMaster.; Note: creation of TSlave is private with TProof as a friend.; Derived classes must use this function to cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:34060,down,down,34060,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,1,['down'],['down']
Availability,"arts. ROOT; » MATH; » MINUIT2; » ROOT::Minuit2::MnUserParameters. class ROOT::Minuit2::MnUserParameters. Function Members (Methods); public:. ~MnUserParameters(); boolAdd(const string&, double); boolAdd(const string&, double, double); boolAdd(const string&, double, double, double, double); doubleError(unsigned int) const; doubleError(const string&) const; vector<double>Errors() const; voidFix(unsigned int); voidFix(const string&); const string&GetName(unsigned int) const; unsigned intIndex(const string&) const; ROOT::Minuit2::MnUserParametersMnUserParameters(); ROOT::Minuit2::MnUserParametersMnUserParameters(const ROOT::Minuit2::MnUserParameters& par); ROOT::Minuit2::MnUserParametersMnUserParameters(const vector<double>&, const vector<double>&); const char*Name(unsigned int) const; ROOT::Minuit2::MnUserParameters&operator=(const ROOT::Minuit2::MnUserParameters& par); const ROOT::Minuit2::MinuitParameter&Parameter(unsigned int) const; const vector<ROOT::Minuit2::MinuitParameter>&Parameters() const; vector<double>Params() const; const ROOT::Minuit2::MnMachinePrecision&Precision() const; voidRelease(unsigned int); voidRelease(const string&); voidRemoveLimits(unsigned int); voidRemoveLimits(const string&); voidSetError(unsigned int, double); voidSetError(const string&, double); voidSetLimits(unsigned int, double, double); voidSetLimits(const string&, double, double); voidSetLowerLimit(unsigned int, double); voidSetLowerLimit(const string&, double); voidSetName(unsigned int, const string&); voidSetPrecision(double eps); voidSetUpperLimit(unsigned int, double); voidSetUpperLimit(const string&, double); voidSetValue(unsigned int, double); voidSetValue(const string&, double); const ROOT::Minuit2::MnUserTransformation&Trafo() const; doubleValue(unsigned int) const; doubleValue(const string&) const; unsigned intVariableParameters() const. Data Members; private:. ROOT::Minuit2::MnUserTransformationfTransformation. Class Charts. Inheritance; Inherited Members; Includes; Librarie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__MnUserParameters.html:584,Error,Errors,584,root/html534/ROOT__Minuit2__MnUserParameters.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__MnUserParameters.html,3,['Error'],['Errors']
Availability,"aryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}; 179 RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); 180 {; 181 const auto v = Mean(Map(pt[type == 11], [this](auto p); 182 {return this->graph.Eval(p); }); 183 );; 184 return RVec<double>{(1 + v) * w, (1 - v) * w};; 185 }; 186};; 187 ; 188VaryHelper variationsFactory;; 189""""""; 190); 191 ; 192# Use the Vary method to add the systematic variations to the total MC scale factor (""weight"") of the analysis.; 193df_variations_mc = (; 194 df.Filter(""isMC == true""); 195 .Vary(""weight"", ""variationsFactory(weight, goodlep_pt, goodlep_type)"", [""up"", ""down""]); 196 .Histo1D(ROOT.RDF.TH1DModel(""Invariant Mass"", ""m4l"", 24, 80, 170), ""m4l"", ""weight""); 197); 198histos_mc = ROOT.RDF.Experimental.VariationsFor(df_variations_mc); 199 ; 200# We reached the end of the analysis part. We now evaluate the total MC uncertainty based on the variations.; 201# No computation graph was triggered yet, we trigger the computation graph for all histograms at once now,; 202# by calling 'histos_mc[""nominal""].GetXaxis()'.; 203# Note, in this case the uncertainties are symmetric.; 204for i in range(0, histos_mc[""nominal""].GetXaxis().GetNbins()):; 205 (; 206 histos_mc[""nominal""].SetBinError(; 207 i, (histos_mc[""weight:up""].GetBinContent(i) - histos_mc[""nominal""].GetBinContent(i)); 208 ); 209 ); 210 ; 211# Make the plot of the data, individual MC contributions and the total MC scale factor systematic variations.; 212 ; 213# Set styles; 214ROOT.gROOT.SetStyle(""ATLAS""); 215 ; 216# Create canvas with pad; 217c1 = ROOT.TCanvas(""c"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:8949,down,down,8949,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['down'],['down']
Availability,"as * GetCanvas() const overrideDefinition TPad.h:262; TPad::fBorderSizeShort_t fBorderSizepad bordersize in pixelsDefinition TPad.h:97; TPad::Paintvoid Paint(Option_t *option="""") overridePaint all primitives in pad.Definition TPad.cxx:3584; TPad::fNameTString fNamePad name.Definition TPad.h:109; TPad::fPixmapIDInt_t fPixmapID! Off-screen pixmap identifierDefinition TPad.h:84; TPad::FindObjectTObject * FindObject(const char *name) const overrideSearch if object named name is inside this pad or in pads inside this pad.Definition TPad.cxx:2700; TPad::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet Current pad.Definition TPad.cxx:693; TPad::GetLogyInt_t GetLogy() const overrideDefinition TPad.h:257; TPad::SetBorderModevoid SetBorderMode(Short_t bordermode) overrideDefinition TPad.h:325; TPad::SetTicksvoid SetTicks(Int_t valuex=1, Int_t valuey=1) overrideDefinition TPad.h:355; TPad::fY2Double_t fY2Y of upper Y coordinate.Definition TPad.h:39; TPad::fBorderModeShort_t fBorderModeBordermode (-1=down, 0 = no border, 1=up)Definition TPad.h:98; TPad::SetLogxvoid SetLogx(Int_t value=1) overrideSet Lin/Log scale for X.Definition TPad.cxx:6086; TPad::GetLogxInt_t GetLogx() const overrideDefinition TPad.h:256; TPad::GetX2Double_t GetX2() const overrideDefinition TPad.h:241; TPad::GetX1Double_t GetX1() const overrideDefinition TPad.h:240; TPad::fMotherTPad * fMother! pointer to mother of the listDefinition TPad.h:105; TPad::GetNameconst char * GetName() const overrideReturns name of object.Definition TPad.h:260; TQObject::Emitvoid Emit(const char *signal, const T &arg)Activate signal with single parameter.Definition TQObject.h:164; TQObject::ConnectBool_t Connect(const char *signal, const char *receiver_class, void *receiver, const char *slot)Non-static method is used to connect from the signal of this object to the receiver slot.Definition TQObject.cxx:869; TROOT::IncreaseDirLevelstatic Int_t IncreaseDirLevel()Increase the indentation level for ls().Definition TROOT.cxx:2887;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:127503,down,down,127503,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['down'],['down']
Availability,"as Zsenei & Lorenzo Moneta 06/2005; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2005 , LCG ROOT MathLib Team *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11#if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 12#define NOT_HAVE_TGAMMA; 13#endif; 14 ; 15 ; 16#include ""SpecFuncCephes.h""; 17 ; 18 ; 19#include <cmath>; 20#include <limits>; 21 ; 22#ifndef PI; 23#define PI 3.14159265358979323846264338328 /* pi */; 24#endif; 25 ; 26// use cephes for functions which are also in C99; 27#define USE_CEPHES; 28 ; 29// platforms not implemening C99; 30// #if defined(__sun) || defined(__sgi) || defined(_WIN32) || defined(_AIX); 31// #define USE_CEPHES; 32// #endif; 33 ; 34 ; 35namespace ROOT {; 36namespace Math {; 37 ; 38 ; 39 ; 40 ; 41 ; 42// (26.x.21.2) complementary error function; 43 ; 44double erfc(double x) {; 45 ; 46 ; 47#ifdef USE_CEPHES; 48 // use cephes implementation; 49 return ROOT::Math::Cephes::erfc(x);; 50#else; 51 return ::erfc(x);; 52#endif; 53 ; 54}; 55 ; 56 ; 57// (26.x.21.1) error function; 58 ; 59double erf(double x) {; 60 ; 61 ; 62#ifdef USE_CEPHES; 63 return ROOT::Math::Cephes::erf(x);; 64#else; 65 return ::erf(x);; 66#endif; 67 ; 68 ; 69}; 70 ; 71 ; 72 ; 73 ; 74double lgamma(double z) {; 75 ; 76#ifdef USE_CEPHES; 77 return ROOT::Math::Cephes::lgam(z);; 78#else; 79 return ::lgamma(z);; 80#endif; 81 ; 82}; 83 ; 84 ; 85 ; 86 ; 87// (26.x.18) gamma function; 88 ; 89double tgamma(double x) {; 90 ; 91#ifdef USE_CEPHES; 92 return ROOT::Math::Cephes::gamma(x);; 93#else; 94 return ::tgamma(x);; 95#endif; 96 ; 97}; 98 ; 99double inc_gamma( double a, double x) {; 100 return ROOT::Math::Cephes::igam(a,x);; 101}; 102 ; 103double inc_gamma_c( double a, double x) {; 104 return ROOT::Math::Cephes::igamc(a,x);; 105}; 106 ; 107 ; 108// [5.2.1.3] beta function; 109// (26.x.19); 110 ; 111double beta(double x, double y) {; 112 return std::exp(lgamm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html:1144,error,error,1144,doc/master/SpecFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncMathCore_8cxx_source.html,1,['error'],['error']
Availability,"as been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. ; Reimplemented from TSocket.; Definition at line 483 of file TPSocket.cxx. ◆ Send() [3/4]. Int_t TPSocket::Send ; (; Int_t ; kind). inlineoverridevirtual . Send a single message opcode. ; Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented from TSocket.; Definition at line 69 of file TPSocket.h. ◆ Send() [4/4]. Int_t TPSocket::Send ; (; Int_t ; status, . Int_t ; kind . ). inlineoverridevirtual . Send a status and a single message opcode. ; Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always 2*sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented from TSocket.; Definition at line 70 of file TPSocket.h. ◆ SendRaw(). Int_t TPSocket::SendRaw ; (; const void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). overridevirtual . Send a raw buffer of specified length. ; Returns the number of bytes send and -1 in case of error. ; Reimplemented from TSocket.; Definition at line 545 of file TPSocket.cxx. ◆ SetOption(). Int_t TPSocket::SetOption ; (; ESockOptions ; opt, . Int_t ; val . ). overridevirtual . Set socket options. ; Reimplemented from TSocket.; Definition at line 754 of file TPSocket.cxx. ◆ Streamer(). void TPSocket::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TNamed. ◆ StreamerNVirtual(). void TPSocket::StreamerNVirtual ; (; TBuff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:29868,error,error,29868,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['error'],['error']
Availability,"as now been removed. (In the limit that a given parameter is uncorrelated with parameter \(\mbox{n}\), its error will not change when parameter \(\mbox{n}\) is fixed.) However the procedure is not reversible, since M forgets the original error matrix, so if parameter \(\mbox{n}\) is then released (e.g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general assymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:23420,error,error,23420,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['error'],['error']
Availability,"as possible. the requirement 1. has priority over 2. ; Definition at line 893 of file MethodCuts.cxx. ◆ CreateRanking(). const Ranking * TMVA::MethodCuts::CreateRanking ; (; ). inlinevirtual . Implements TMVA::MethodBase.; Definition at line 124 of file MethodCuts.h. ◆ CreateVariablePDFs(). void TMVA::MethodCuts::CreateVariablePDFs ; (; void ; ). private . for PDF method: create efficiency reference histograms and PDFs ; Definition at line 1106 of file MethodCuts.cxx. ◆ DeclareOptions(). void TMVA::MethodCuts::DeclareOptions ; (; ). virtual . define the options (their key words) that can be set in the option string. ; know options:; Method <string> Minimisation method. Available values are:; MC Monte Carlo <default>; GA Genetic Algorithm; SA Simulated annealing. EffMethod <string> Efficiency selection method. Available values are:; EffSel <default>; EffPDF. VarProp <string> Property of variable 1 for the MC method (taking precedence over the globale setting. The same values as for the global option are available. Variables 1..10 can be set this way; CutRangeMin/Max <float> user-defined ranges in which cuts are varied . Implements TMVA::MethodBase.; Definition at line 319 of file MethodCuts.cxx. ◆ DeclFileName(). static const char * TMVA::MethodCuts::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file MethodCuts.h. ◆ DynamicCast(). static MethodCuts * TMVA::MethodCuts::DynamicCast ; (; IMethod * ; method). inlinestatic . Definition at line 74 of file MethodCuts.h. ◆ EstimatorFunction() [1/2]. Double_t TMVA::MethodCuts::EstimatorFunction ; (; Int_t ; ievt1, . Int_t ; ievt2 . ). for full event scan ; Definition at line 834 of file MethodCuts.cxx. ◆ EstimatorFunction() [2/2]. Double_t TMVA::MethodCuts::EstimatorFunction ; (; std::vector< Double_t > & ; pars). virtual . returns estimator for ""cut fitness"" used by GA ; Implements TMVA::IFitterTarget.; Definition at line 878 of file MethodCuts.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html:38470,avail,available,38470,doc/master/classTMVA_1_1MethodCuts.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodCuts.html,1,['avail'],['available']
Availability,as supplied in the constructor. ;  ; RooObjCacheManager _intCacheMgr;  ! Manager of cache with integrals ;  ; RooArgSet _ownedComps;  ! Owned components ;  ; RooListProxy _pdfList;  List of component PDFs. ;  ; RooObjCacheManager _projCacheMgr;  ! Manager of cache with coefficient projections and transformations ;  ; RooSetProxy _refCoefNorm;  ! Reference observable set for coefficient interpretation ;  ; TNamed * _refCoefRangeName = nullptr;  ! Reference range name for coefficient interpretation ;  ; RooArgList * _snormList {nullptr};  ! List of supplemental normalization factors ;  ;  Protected Attributes inherited from RooResolutionModel; RooFormulaVar * _basis = nullptr;  Basis function convolved with this resolution model. ;  ; Int_t _basisCode;  Identifier code for selected basis function. ;  ; bool _ownBasis;  Flag indicating ownership of _basis. ;  ; RooTemplateProxy< RooAbsRealLValue > x;  Dependent/convolution variable. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if flag set. ;  ; TString _label;  Plot label for objects value. ;  ; RooFit::UniqueId< RooArgSet >::Value_t _lastNormSetId = RooFit::UniqueId<RooArgSet>::nullval;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; Int_t _plotBins = 100;  Number of plot ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:72857,error,errors,72857,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['error'],['errors']
Availability,"as() const; voidTObject::MayNotUse(const char* method) const; static Bool_tMemCheck(); voidMessage(Int_t id, const TObject* obj); virtual TDirectory*TDirectory::mkdir(const char* name, const char* title = """"); Bool_tMustClean() const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual TFile*TDirectory::OpenFile(const char*, Option_t* = """", const char* = """", Int_t = 1, Int_t = 0); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual voidTDirectory::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidTDirectory::Print(Option_t* option = """") const; Long_tProcessLine(const char* line, Int_t* error = 0); Long_tProcessLineFast(const char* line, Int_t* error = 0); Long_tProcessLineSync(const char* line, Int_t* error = 0); virtual voidTDirectory::Purge(Short_t = 1); virtual voidTDirectory::pwd() const; virtual Int_tTObject::Read(const char* name); virtual voidTDirectory::ReadAll(Option_t* = """"); Bool_tReadingObject() const; virtual Int_tTDirectory::ReadKeys(Bool_t = kTRUE); virtual Int_tTDirectory::ReadTObject(TObject*, const char*); virtual voidTDirectory::RecursiveRemove(TObject* obj); voidRefreshBrowsers(); static voidRegisterModule(const char* modulename, const char** headers, const char** includePaths, const char* payLoadCode, const char* fwdDeclCode, void(*)() triggerFunc, const TROOT::FwdDeclArgsToKeepCollection_t& fwdDeclsArgToSkip, const char** classesHeaders); virtual TObject*TDirectory::Remove(TObject*); voidRemoveClass(TClass*); voidReset(Option_t* option = """"); voidTObject::ResetBit(UInt_t f); virtual voidTDirectory::rmdir(const char* name); static Int_tRootVersionCode(); virtual voidTDirectory::Save(); virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:11899,error,error,11899,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['error'],['error']
Availability,"asPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor early. ; Use static initialization to insure only one TStreamerInfo is created. ; Definition at line 1664 of file TCling.cxx. ◆ RegisterCxxModules(). static void RegisterCxxModules ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1183 of file TCling.cxx. ◆ RegisterPreIncludedHeaders(). static void RegisterPreIncludedHeaders ; (; cling::Interpreter & ; clingInterp). static . Definition at line 1299 of file TCling.cxx. ◆ requiresRootMap(). static bool requiresRootMap ; (; const char * ; rootmapfile). static . Definition at line 5512 of file TCling.cxx. ◆ s_IsLibraryLoaded(). static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:15370,avail,available,15370,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['avail'],['available']
Availability,"ase 'type' is ignored. TDSet(const TChain& chain, Bool_t withfriends = kTRUE); Create a named TDSet object from existing TChain 'chain'.; If 'withfriends' is kTRUE add also friends.; This constructor substituted the static methods TChain::MakeTDSet; removing any residual dependence of 'tree' on 'proof'. ~TDSet(); Cleanup. Long64_t Process(TSelector* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Process TDSet on currently active PROOF session.; The last argument 'enl' specifies an entry- or event-list to be used as; event selection.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0, TObject* enl = 0); Process TDSet on currently active PROOF session.; The last argument 'enl' specifies an entry- or event-list to be used as; event selection.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. void AddInput(TObject* obj); Add objects that might be needed during the processing of; the selector (see Process()). void ClearInput(); Clear input object list. TObject * GetOutput(const char* name); Get specified object that has been produced during the processing; (see Process()). TList * GetOutputList(); Get list with all object created during processing (see Process()). void Print(Option_t* option = """") const; Print TDSet basic or full data. When option=""a"" print full data. void SetObjName(const char* objname); Set/change object name. void SetDirectory(const char* dir); Set/change directory. Bool_t Add(const char* file, const char* objname = 0, const char* dir = 0, Long64_t first = 0, Long64_t num = -1, const char* msd = 0); Add file to list of files to be analyzed. Optionally with the; objname and dir arguments the default, TDSet wide, objname and; dir can be overridden. Bool_t Add(TDSet* set); Add specified data set to the this set.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDSet.html:11190,error,error,11190,root/html534/TDSet.html,https://root.cern,https://root.cern/root/html534/TDSet.html,6,['error'],['error']
Availability,"ase cache for data reads between runs ; TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans; static TF1*fgFioFunction used for I/O rate fits; static TF1*fgFioVFunction used for I/O rate fits with non-constant Rcpu; static TF1*fgFp1Simple 1st degree polynomial; static TF1*fgFp1nNormalized 1st degree; static TF1*fgFp2Simple 2nd degree polynomial; static TF1*fgFp2nNormalized 2nd degree; static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:' draw normalized plot; 'normx:' draw normalized plot, 1 worker per node; what = 'max:' draw max rate; 'avg:' draw average rate; 'all:' draw max and average rate on same ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBench.html:9408,error,error,9408,root/html534/TProofBench.html,https://root.cern,https://root.cern/root/html534/TProofBench.html,2,['error'],['error']
Availability,"ase.; Definition at line 398 of file MethodSVM.cxx. ◆ Class(). static TClass * TMVA::MethodSVM::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodSVM::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodSVM::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 165 of file MethodSVM.h. ◆ CreateRanking(). const Ranking * TMVA::MethodSVM::CreateRanking ; (; ). inlinevirtual . Implements TMVA::MethodBase.; Definition at line 104 of file MethodSVM.h. ◆ DeclareCompatibilityOptions(). void TMVA::MethodSVM::DeclareCompatibilityOptions ; (; ). privatevirtual . options that are used ONLY for the READER to ensure backward compatibility ; Reimplemented from TMVA::MethodBase.; Definition at line 251 of file MethodSVM.cxx. ◆ DeclareOptions(). void TMVA::MethodSVM::DeclareOptions ; (; ). privatevirtual . declare options available for this method ; Implements TMVA::MethodBase.; Definition at line 220 of file MethodSVM.cxx. ◆ DeclFileName(). static const char * TMVA::MethodSVM::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 165 of file MethodSVM.h. ◆ GetHelpMessage(). void TMVA::MethodSVM::GetHelpMessage ; (; ); const. protectedvirtual . get help message text ; typical length of text line: ""|--------------------------------------------------------------|"" ; Implements TMVA::IMethod.; Definition at line 715 of file MethodSVM.cxx. ◆ getLoss(). Double_t TMVA::MethodSVM::getLoss ; (; TString ; lossFunction). private . getLoss Calculates loss for testing dataset. ; The loss function can be specified when booking the method, otherwise defaults to hinge loss. Currently not used however is accesible if required. ; Definition at line 1163 of file MethodSVM.cxx. ◆ GetMGamma(). void TMVA::MethodSVM::GetMGamma ; (; const std::vector< float > & ; gammas). Produces Gamma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html:31961,avail,available,31961,doc/master/classTMVA_1_1MethodSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html,1,['avail'],['available']
Availability,"ase.cxx. ◆ RebinnedAdd(). void THnBase::RebinnedAdd ; (; const THnBase * ; h, . Double_t ; c = 1. . ). Add contents of h scaled by c to this histogram: this = this + c * h Note that if h has Sumw2 set, Sumw2 is automatically called for this if not already set. ; In contrast to Add(), RebinnedAdd() does not require consistent binning of this and h; instead, each bin's center is used to determine the target bin. ; Definition at line 887 of file THnBase.cxx. ◆ Reserve(). virtual void THnBase::Reserve ; (; Long64_t ; ). inlineprotectedvirtual . Reimplemented in THnSparse.; Definition at line 104 of file THnBase.h. ◆ Reset(). virtual void THnBase::Reset ; (; Option_t * ; option = """"). pure virtual . Implemented in THn, and THnSparse. ◆ ResetBase(). void THnBase::ResetBase ; (; Option_t * ; option = """"). protected . Clear the histogram. ; Definition at line 1327 of file THnBase.cxx. ◆ Scale(). void THnBase::Scale ; (; Double_t ; c). Scale contents and errors of this histogram by c: this = this * c It does not modify the histogram's number of entries. ; Definition at line 774 of file THnBase.cxx. ◆ SetBinContent() [1/2]. void THnBase::SetBinContent ; (; const Int_t * ; idx, . Double_t ; v . ). inline . Definition at line 207 of file THnBase.h. ◆ SetBinContent() [2/2]. virtual void THnBase::SetBinContent ; (; Long64_t ; bin, . Double_t ; v . ). pure virtual . Implemented in THn, and THnSparse. ◆ SetBinEdges(). void THnBase::SetBinEdges ; (; Int_t ; idim, . const Double_t * ; bins . ). Set the axis # of bins and bin limits on dimension idim. ; Definition at line 1180 of file THnBase.cxx. ◆ SetBinError() [1/2]. void THnBase::SetBinError ; (; const Int_t * ; idx, . Double_t ; e . ). inline . Definition at line 189 of file THnBase.h. ◆ SetBinError() [2/2]. void THnBase::SetBinError ; (; Long64_t ; bin, . Double_t ; e . ). inline . Definition at line 190 of file THnBase.h. ◆ SetBinError2(). virtual void THnBase::SetBinError2 ; (; Long64_t ; bin, . Double_t ; e2 . ). pure virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnBase.html:42079,error,errors,42079,doc/master/classTHnBase.html,https://root.cern,https://root.cern/doc/master/classTHnBase.html,1,['error'],['errors']
Availability,"ase::fTsumw2Double_t fTsumw2Total sum of weights squared; -1 if no errors are calculated.Definition THnBase.h:50; THnBase::fNdimensionsInt_t fNdimensionsNumber of dimensions.Definition THnBase.h:45; THnMultidimensional histogram.Definition THn.h:30; THn::AllocCoordBufvoid AllocCoordBuf() constCreate the coordinate buffer.Definition THn.cxx:232; THn::InitStoragevoid InitStorage(Int_t *nbins, Int_t chunkSize) overrideInitialize the storage of a histogram created via Init()Definition THn.cxx:240; THn::~THn~THn() overrideDestruct a THn.Definition THn.cxx:199; THn::fCoordBufstd::vector< Int_t > fCoordBufDefinition THn.h:181; THn::fSumw2TNDArrayT< Double_t > fSumw2Definition THn.h:180; THn::CreateIterROOT::Internal::THnBaseBinIter * CreateIter(Bool_t respectAxisRange) const overrideCreate an iterator over all bins. Public interface is THnIter.Definition THn.cxx:207; THn::Resetvoid Reset(Option_t *option="""") overrideReset the contents of a THn.Definition THn.cxx:250; THn::Sumw2void Sumw2() overrideEnable calculation of errors.Definition THn.cxx:216; THn::THnTHn()=default; THn::GetNbinsLong64_t GetNbins() const overrideDefinition THn.h:54; THn::GetArrayvirtual const TNDArray & GetArray() const =0; TNDArrayN-Dim array class.Definition TNDArray.h:46; TNDArray::AtAsDoublevirtual Double_t AtAsDouble(ULong64_t linidx) const =0; TNDArray::GetCellSizeLong64_t GetCellSize(Int_t dim) constDefinition TNDArray.h:70; TNDArray::Initvirtual void Init(Int_t ndim, const Int_t *nbins, bool addOverflow=false)Definition TNDArray.h:55; TNDArray::Resetvirtual void Reset(Option_t *option="""")=0; TObjArrayAn array of TObjects.Definition TObjArray.h:31; TObjArray::AtTObject * At(Int_t idx) const overrideDefinition TObjArray.h:164; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; bool; double; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8cxx_source.html:12616,error,errors,12616,doc/master/THn_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html,1,['error'],['errors']
Availability,"aseFunc, ROOT::Math::GradFunctor::ImplBase, ROOT::Fit::Fitter::BaseFunc, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::Functor::Impl, ROOT::Fit::Chi2FCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Fit::Chi2FCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction, ROOT::Math::WrappedMultiTF1::BaseFunc, ROOT::Fit::PoissonLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IGradientFunctionMultiDim::BaseFunc, ROOT::Math::IBaseFunctionMultiDim::BaseFunc, ROOT::Math::Functor::ImplBase, ROOT::Math::BasicFitMethodFunction<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Math::IParametricFunctionMultiDim::BaseFunc, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IGradientFunctionMultiDim>::BaseFunction, ROOT::Fit::LogLikelihoodFCN<ROOT::Math::IBaseFunctionMultiDim>::BaseFunction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IBaseFunctionMultiDim(); virtual ROOT::Math::IBaseFunctionMultiDim*Clone() const; virtual unsigned intNDim() const; doubleoperator()(const double* x) const; ROOT::Math::IBaseFunctionMultiDim&operator=(const ROOT::Math::IBaseFunctionMultiDim&). private:. virtual doubleDoEval(const double* x) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IBaseFunctionMultiDim(). virtual destructor. {}. IBaseFunctionMultiDim * Clone() const. Clone a function.; Each derived class must implement his version of the Clone method. unsigned int NDim() const. Retrieve the dimension of the function. double operator()(const double* x) const. Evaluate the function at a point x[].; Use the pure virtual private method DoEval which must be implemented by the sub-classes. return DoEval(const double* x) const. » Last changed: root/mathcore:$Id: IFunction.h 24482 2008-06-23 15:33:08Z moneta $ » Last generated: 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__IBaseFunctionMultiDim.html:2150,avail,available,2150,root/html526/ROOT__Math__IBaseFunctionMultiDim.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__IBaseFunctionMultiDim.html,1,['avail'],['available']
Availability,"aseIntegratorOptions& opt); doubleRelTolerance() const; voidSetAbsTolerance(double tol); voidSetExtraOptions(const ROOT::Math::IOptions& opt); voidSetRelTolerance(double tol); voidSetWKSize(unsigned int size); unsigned intWKSize() const. protected:. voidClearExtra(). Data Members; protected:. doublefAbsToleranceabsolute tolerance ; ROOT::Math::IOptions*fExtraOptionsextra options ; intfIntegTypeIntegrator type (value converted from enum); unsigned intfNCalls(max) funxtion calls; doublefRelTolerancerelative tolerance ; unsigned intfWKSizeworkspace size. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BaseIntegratorOptions & operator=(const ROOT::Math::BaseIntegratorOptions& opt); assignment operators. virtual ~BaseIntegratorOptions(); protected constructor to avoid user creating this class. { ClearExtra(); }. std::string Integrator() const; name of 1D integrator. double AbsTolerance() const; non-static methods for retrivieng options ; absolute tolerance. { return fAbsTolerance; }. double RelTolerance() const; absolute tolerance. { return fRelTolerance; }. unsigned int WKSize() const; size of the workspace. { return fWKSize; }. IOptions * ExtraOptions() const; return extra options. { return fExtraOptions; }. void SetAbsTolerance(double tol); non-static methods for setting options ; set the abs tolerance. { fAbsTolerance = tol; }. void SetRelTolerance(double tol); set the relative tolerance. { fRelTolerance = tol; }. void SetWKSize(unsigned int size); set workspace size. { fWKSize = size; }. void SetExtraOptions(const ROOT::Math::IOptions& opt); set extra options (in this case pointer is cloned). void ClearExtra(). » Author: L. Moneta Fri Aug 15 2008 » Copyright (c) 2008 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html:1948,toler,tolerance,1948,root/html534/ROOT__Math__BaseIntegratorOptions.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__BaseIntegratorOptions.html,6,['toler'],['tolerance']
Availability,"ased on algorithm 353QH twice presented by J. Friedman; in Proc.of the 1974 CERN School of Computing, Norway, 11-24 August, 1974. void Smooth(Int_t ntimes = 1, Option_t* option = """"); Smooth bin contents of this histogram.; if option contains ""R"" smoothing is applied only to the bins; defined in the X axis range (default is to smooth all bins); Bin contents are replaced by their smooth values.; Errors (if any) are not modified.; the smoothing procedure is repeated ntimes (default=1). void StatOverflows(Bool_t flag = kTRUE); if flag=kTRUE, underflows and overflows are used by the Fill functions; in the computation of statistics (mean value, StdDev).; By default, underflows or overflows are not used. void Streamer(TBuffer& ); Stream a class object. void Print(Option_t* option = """") const; Print some global quantities for this histogram. If option ""base"" is given, number of bins and ranges are also printed; If option ""range"" is given, bin contents and errors are also printed; for all bins in the current range (default 1-->nbins); If option ""all"" is given, bin contents and errors are also printed; for all bins including under and overflows. void Rebuild(Option_t* option = """"); Using the current bin info, recompute the arrays for contents and errors. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc. if option ""ICE"" is specified, resets only Integral, Contents and Errors.; if option ""ICES"" is specified, resets only Integral, Contents , Errors and Statistics; This option is used; if option ""M"" is specified, resets also Minimum and Maximum. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitive as a C++ statement(s) on output stream out. void SavePrimitiveHelp(ostream& out, const char* hname, Option_t* option = """"); helper function for the SavePrimitive functions from TH1; or classes derived from TH1, eg TProfile, TProfile2D. void UseCurrentStyle(); Copy current attributes from/to current style. Double_t GetMean(Int_t axis = 1)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:109056,error,errors,109056,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,4,['error'],['errors']
Availability,"ased on string path; 1663/// Used to highlight geo volumes by browser hover event; 1664 ; 1665std::vector<int> RGeomDescription::MakeStackByPath(const std::vector<std::string> &path); 1666{; 1667 TLockGuard lock(fMutex);; 1668 ; 1669 std::vector<int> res;; 1670 ; 1671 RGeomBrowserIter iter(*this);; 1672 ; 1673 if (iter.Navigate(path)); 1674 res = MakeStackByIds(iter.CurrentIds());; 1675 ; 1676 return res;; 1677}; 1678 ; 1679/////////////////////////////////////////////////////////////////////////////////; 1680/// Produce list of node ids for given stack; 1681/// If found nodes preselected - use their ids; 1682 ; 1683std::vector<int> RGeomDescription::MakeIdsByStack(const std::vector<int> &stack); 1684{; 1685 TLockGuard lock(fMutex);; 1686 ; 1687 std::vector<int> ids;; 1688 ; 1689 ids.emplace_back(0);; 1690 int nodeid = 0;; 1691 bool failure = false;; 1692 ; 1693 for (auto s : stack) {; 1694 auto &chlds = fDesc[nodeid].chlds;; 1695 if (s >= (int)chlds.size()) {; 1696 failure = true;; 1697 break;; 1698 }; 1699 ; 1700 ids.emplace_back(chlds[s]);; 1701 ; 1702 nodeid = chlds[s];; 1703 }; 1704 ; 1705 if (failure) {; 1706 printf(""Fail to convert stack into list of nodes\n"");; 1707 ids.clear();; 1708 }; 1709 ; 1710 return ids;; 1711}; 1712 ; 1713/////////////////////////////////////////////////////////////////////////////////; 1714/// Returns path string for provided stack; 1715 ; 1716std::vector<std::string> RGeomDescription::MakePathByStack(const std::vector<int> &stack); 1717{; 1718 TLockGuard lock(fMutex);; 1719 ; 1720 std::vector<std::string> path;; 1721 ; 1722 auto ids = MakeIdsByStack(stack);; 1723 path.reserve(ids.size());; 1724for (auto &id : ids); 1725 path.emplace_back(fDesc[id].name);; 1726 ; 1727 return path;; 1728}; 1729 ; 1730/////////////////////////////////////////////////////////////////////////////////; 1731/// Return string with only part of nodes description which were modified; 1732/// Checks also volume; 1733 ; 1734std::string RGeomDescription::Produc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:51473,failure,failure,51473,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['failure'],['failure']
Availability,"ash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a clone of an object using the Streamer facility. ;  ; virtual Int_t Compare (const TObject *obj) const;  Compare abstract method. ;  ; virtual void Copy (TObject &object) const;  Copy this to obj. ;  ; virtual Int_t DistancetoPrimitive (Int_t px, Int_t py);  Computes distance from point (px,py) to the object. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual const char * GetTitle () const;  Returns title of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStructViewerGUI.html:19288,error,error,19288,doc/master/classTStructViewerGUI.html,https://root.cern,https://root.cern/doc/master/classTStructViewerGUI.html,1,['error'],['error']
