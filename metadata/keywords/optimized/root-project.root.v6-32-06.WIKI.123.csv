quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Usability,"command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQCommand & operator=(const TQCommand& ). TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:24786,undo,undo,24786,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,1,['undo'],['undo']
Usability,"command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 25128 2008-08-12 17:59:19Z pcanal $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:23771,undo,undo,23771,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,1,['undo'],['undo']
Usability,"command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TQCommand.html:24026,undo,undo,24026,root/html530/TQCommand.html,https://root.cern,https://root.cern/root/html530/TQCommand.html,1,['undo'],['undo']
Usability,"command.; Merged commands are executed in reverse order. const char * GetName() const; Returns the command name. Default name is ""ClassName::RedoName(args)""; If list of merged commands is not empty the name is; ""ClassName::RedoName(args):cname1:cname2 ..."". const char * GetTitle() const; Returns command description.; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"". const char * GetRedoName() const; Returns the name of redo command. const char * GetUndoName() const; Returns the name of undo command. Long_t * GetRedoArgs() const; Returns a pointer to array of redo arguments. Long_t * GetUndoArgs() const; Returns a pointer to array of undo arguments. Int_t GetNRargs() const; Returns a number of redo arguments. Int_t GetNUargs() const; Returns a number of undo arguments. void * GetObject() const; Returns an object for which undo redo acions are applied. Int_t GetStatus() const; Returns a number of sequential undo or redo operations. Bool_t IsMacro() const; Returns kTRUE if neither redo nor undo action specified. Bool_t IsUndoing() const; Undo action is in progress. Bool_t IsRedoing() const; Redo action is in progress. Bool_t IsExecuting() const; Returns kTRUE if command execution is in progress. void SetName(const char* name); Sets name of the command. void SetTitle(const char* title); Sets description of the command. void ls(Option_t* option = """") const; ls this command and merged commands. void PrintCollectionHeader(Option_t* option) const; Print collection header. TQConnection * GetRedo() const; { return fRedo; }. TQConnection * GetUndo() const; { return fUndo; }. void Add(TObject* obj, Option_t* opt). » Author: Valeriy Onuchin 04/27/2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TQCommand.h 39365 2011-05-24 19:53:19Z pcanal $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQCommand.html:24026,undo,undo,24026,root/html532/TQCommand.html,https://root.cern,https://root.cern/root/html532/TQCommand.html,1,['undo'],['undo']
Usability,"compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:23617,clear,clearTypes,23617,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,3,['clear'],['clearTypes']
Usability,conbase list tree icon picture; Bool_tfBusyKTRUE if busy i.e : connecting; TGPopupMenu*fCascadeMenuoptions menu entry; Bool_tfChangePicKTRUE if animation active; TStringfConfigFileconfiguration file name; TGHProgressBar*fConnectProgconnection progress bar; TContextMenu*fContextMenuinput/output objects context menu; time_tfElapsedtime of connection; TGPopupMenu*fFileMenufile menu entry; TGPopupMenu*fHelpMenuhelp menu entry; TGHorizontalFrame*fHf; TSessionInputFrame*fInputFrameinput frame; const TGPicture*fLocallocal session icon picture; TSessionLogView*fLogWindowexternal log window; TGMenuBar*fMenuBarapplication main menu bar; TGPopupMenu*fOptionsMenuoptions menu entry; TSessionOutputFrame*fOutputFrameoutput frame; TGPopupMenu*fPopupQryquery related popup menu; TGPopupMenu*fPopupSrvserver related popup menu; const TGPicture*fProofConconnected server icon picture; const TGPicture*fProofDiscondisconnected server icon picture; const TGPicture*fQueryConconnected(?) query icon picture; const TGPicture*fQueryDiscondisconnected(?) query icon picture; TSessionQueryFrame*fQueryFrameright side query frame; TGPopupMenu*fQueryMenuquery menu entry; TGIcon*fRightIconassociated picture; TGPicture*fRightIconPicturelower bottom left icon used to show connection status; TSessionServerFrame*fServerFrameright side server frame; TSessionFrame*fSessionFrameright side session frame; TGListTree*fSessionHierarchymain sessions/queries hierarchy list tree; TGListTreeItem*fSessionItembase (main) session list tree item; TGPopupMenu*fSessionMenusession menu entry; TList*fSessionslist of sessions; time_tfStarttime of connection; TGStatusBar*fStatusBarbottom status bar; TTimer*fTimertimer used to change icon picture; TGToolBar*fToolBarapplication tool bar; TGCanvas*fTreeViewmain right sessions/queries tree view; UserGroup_t*fUserGroupuser connected to session; TGVerticalFrame*fV1; TGVerticalFrame*fV2; TEnv*fViewerEnvviewer's configuration. Class Charts. Inheritance Chart:. TObject. ←; TGObject. ←;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSessionViewer.html:24663,progress bar,progress bar,24663,root/html602/TSessionViewer.html,https://root.cern,https://root.cern/root/html602/TSessionViewer.html,2,['progress bar'],['progress bar']
Usability,"confined in a close vicinity. The linearity property of this method is reflected in the metric with which ""far apart"" and ""close vicinity"" are determined: the covariance matrix of the discriminant variable space.; The classification of the events in signal and background classes relies on the following characteristics (only): overall sample means, \( x_i \), for each input variable, \( i \), class-specific sample means, \( x_{S(B),i}\), and total covariance matrix \( T_{ij} \). The covariance matrix can be decomposed into the sum of a within ( \( W_{ij} \)) and a between-class ( \( B_{ij} \)) class matrix. They describe the dispersion of events relative to the means of their own class (within-class matrix), and relative to the overall sample means (between-class matrix). The Fisher coefficients, \( F_i \), are then given by. \[; F_i = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} W_{ij}^{-1} (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. where in TMVA is set \( N_S = N_B \), so that the factor in front of the sum simplifies to \( \frac{1}{2}\). The Fisher discriminant then reads. \[; X_{Fi} = F_0 + \sum_{i=1}^{N_{SB}} F_i X_i; \]. The offset \( F_0 \) centers the sample mean of \( x_{Fi} \) at zero. Instead of using the within-class matrix, the Mahalanobis variant determines the Fisher coefficients as follows:. \[; F_i = \frac{\sqrt{N_s N_b}}{N_s + N_b} \sum_{j=1}^{N_{SB}} (W + B)_{ij}^{-1} (\bar{X}_{Sj} - \bar{X}_{Bj}); \]. with resulting \( x_{Ma} \) that are very similar to the \( x_{Fi} \).; TMVA provides two outputs for the ranking of the input variables:. Fisher test: the Fisher analysis aims at simultaneously maximising the between-class separation, while minimising the within-class dispersion. A useful measure of the discrimination power of a variable is hence given by the diagonal quantity: \( \frac{B_{ii}}{W_{ii}} \) .; Discrimination power: the value of the Fisher coefficient is a measure of the discriminating power of a variable. The discrimination power of se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html:1954,simpl,simplifies,1954,doc/master/classTMVA_1_1MethodFisher.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFisher.html,1,['simpl'],['simplifies']
Usability,"const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddPdf.html:3897,clear,clearEvalError,3897,root/html532/RooAddPdf.html,https://root.cern,https://root.cern/root/html532/RooAddPdf.html,2,['clear'],['clearEvalError']
Usability,"const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProdPdf.html:4343,clear,clearEvalError,4343,root/html532/RooProdPdf.html,https://root.cern,https://root.cern/root/html532/RooProdPdf.html,1,['clear'],['clearEvalError']
Usability,"const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:4343,clear,clearEvalError,4343,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,1,['clear'],['clearEvalError']
Usability,"const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; static voidblockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); const TMatrixDSym&covarianceMatrix() const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMultiVarGaussian.html:3047,clear,clearShapeDirty,3047,root/html526/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html526/RooMultiVarGaussian.html,1,['clear'],['clearShapeDirty']
Usability,"const TEmulatedCollectionProxy &);  . Friends; class TCollectionProxy;  . Additional Inherited Members;  Static Public Attributes inherited from TVirtualCollectionProxy; static const Int_t fgIteratorArenaSize = 16;  The size of a small buffer that can be allocated on the stack to store iterator-specific information. ;  ;  Protected Types inherited from TGenCollectionProxy; typedef void *(* ArrIterfunc_t) (void *from, size_t size);  ; typedef void *(* Collectfunc_t) (void *from, void *to);  ; typedef ROOT::Detail::TCollectionProxyInfo::Environ< char[64]> Env_t;  ; typedef ROOT::Detail::TCollectionProxyInfo::EnvironBase EnvironBase_t;  ; typedef void *(* Feedfunc_t) (void *from, void *to, size_t size);  ; typedef std::vector< EnvironBase_t * > Proxies_t;  ; typedef void(* Sizing_t) (void *obj, size_t size);  ; typedef std::vector< TStaging * > Staged_t;  Collection of pre-allocated staged array for associative containers. ;  ;  Protected Attributes inherited from TGenCollectionProxy; Method fClear;  Method cache for container accessors: clear container. ;  ; Collectfunc_t fCollect;  Method to collect objects from container. ;  ; ArrIterfunc_t fConstruct;  Container accessors: block construct. ;  ; std::map< std::string, TObjArray * > * fConversionReadMemberWise;  Array of bundle of TStreamerInfoActions to stream out (read) derived from another class. ;  ; Method0 fCreateEnv;  Method to allocate an Environment holder. ;  ; Sizing_t fDestruct;  Container accessors: block destruct. ;  ; EnvironBase_t * fEnv;  Address of the currently proxied object. ;  ; Feedfunc_t fFeed;  Container accessors: block feed. ;  ; Method fFirst;  Container accessors: generic iteration: first. ;  ; CopyIterator_t fFunctionCopyIterator;  ; CreateIterators_t fFunctionCreateIterators;  ; DeleteIterator_t fFunctionDeleteIterator;  ; DeleteTwoIterators_t fFunctionDeleteTwoIterators;  ; Next_t fFunctionNextIterator;  ; Value * fKey;  Descriptor of the key_type. ;  ; std::string fName;  Name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:11273,clear,clear,11273,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,1,['clear'],['clear']
Usability,"const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoTubeEditor.html:22222,undo,undoing,22222,root/html604/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html604/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoTubeEditor.html:22222,undo,undoing,22222,root/html602/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoRotationEditor.html:21908,undo,undoing,21908,root/html528/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html528/TGeoRotationEditor.html,1,['undo'],['undoing']
Usability,"const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoRotationEditor.html:22008,undo,undoing,22008,root/html530/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html530/TGeoRotationEditor.html,1,['undo'],['undoing']
Usability,"const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoRotationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for rotation editor. ~TGeoRotationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected rotation. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoRotationEditor.html:22008,undo,undoing,22008,root/html532/TGeoRotationEditor.html,https://root.cern,https://root.cern/root/html532/TGeoRotationEditor.html,1,['undo'],['undoing']
Usability,"const char * ; hname, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Make a projection of a tree using selections. ; Depending on the value of varexp (described in Draw) a 1-D, 2-D, etc., projection of the tree will be filled in histogram hname. Note that the dimension of hname must match with the dimension of varexp. ; Definition at line 7498 of file TTree.cxx. ◆ Query(). TSQLResult * TTree::Query ; (; const char * ; varexp = """", . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = kMaxEntries, . Long64_t ; firstentry = 0 . ). virtual . Loop over entries and return a TSQLResult object containing entries following selection. ; Definition at line 7513 of file TTree.cxx. ◆ ReadFile(). Long64_t TTree::ReadFile ; (; const char * ; filename, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from filename. ; if branchDescriptor = """" (default), it is assumed that the Tree descriptor is given in the first line of the file with a syntax like A/D:Table[2]/F:Ntracks/I:astring/C; F#define F(x, y, z); I#define I(x, y, z); otherwise branchDescriptor must be specified with the above syntax. If the type of the first variable is not specified, it is assumed to be ""/F""; If the type of any other variable is not specified, the type of the previous variable is assumed. eg; x:y:z (all variables are assumed of type ""F""); x/D:y:z (all variables are of type ""D""); x:y/D:z (x is type ""F"", y and z of type ""D""). delimiter allows for the use of another delimiter besides whitespace. This provides support for direct import of common data file formats like csv. If delimiter != ' ' and branchDescriptor == """", then the branch description is taken from the first line in the file, but delimiter is used for the branch names tokenization rather than ':'. Note however that if the values in the fir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:193183,simpl,simply,193183,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simply']
Usability,"const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsCachedPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:57815,clear,clearEvalErrorLog,57815,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,3,['clear'],['clearEvalErrorLog']
Usability,"const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool checkSyntax (const char *arg);  Perform basic syntax on given factory expression. ;  ; void clearError ();  Associated workspace. ;  ; Int_t errorCount ();  ; std::string processAliasExpression (const char *arg);  Parse token. ;  ; std::string processCompositeExpression (const char *arg);  Process a single composite expression. ;  ; std::string processCreateArg (std::string &func, std::vector< std::string > &args);  Glue function between high-level syntax and low-level factory call to createArg: Process a parsed call to create a pdf named func ;  ; std::string processCreateVar (std::string &func, std::vector< std::string > &args);  Glue function between high-level syntax and low-level factory call to createVariable: Process a parsed call to create a variable named func ;  ; std::string processListExpression (const char *arg);  Process a list of high-level expression. ;  ; std::string processMetaArg (std::string &func, std::vector< std::string > &args);  Concatenate list of args into comma separated string. ;  ; std::string processSingleExpression (const char *arg);  Process a single high-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFactoryWSTool.html:17817,clear,clearError,17817,doc/master/classRooFactoryWSTool.html,https://root.cern,https://root.cern/doc/master/classRooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"const char * GetElementTitle () const;  Virtual function for retrieving title of the render-element. ;  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual const TGPicture * GetListTreeIcon (Bool_t open=kFALSE);  Returns pointer to first listtreeicon. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; virtual TObject * GetObject (const TEveException &eh) const;  Get a TObject associated with this render-element. ;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCaloData.html:13244,feedback,feedback,13244,doc/master/classTEveCaloData.html,https://root.cern,https://root.cern/doc/master/classTEveCaloData.html,3,['feedback'],['feedback']
Usability,"const std::string &fprefix="""");  Configures recording of communication data in protocol file Provided filename will be used to store JSON array with names of written files - text or binary If data was send from client, ""send"" entry will be placed. ;  ; void Run (double tm=0.);  Run window functionality for specified time If no action can be performed - just sleep specified time. ;  ; void Send (unsigned connid, const std::string &data);  Sends data to specified connection. ;  ; void SendBinary (unsigned connid, const void *data, std::size_t len);  Send binary data to specified connection. ;  ; void SendBinary (unsigned connid, std::string &&data);  Send binary data to specified connection. ;  ; void SetCallBacks (WebWindowConnectCallback_t conn, WebWindowDataCallback_t data, WebWindowConnectCallback_t disconn=nullptr);  Set call-backs function for connect, data and disconnect events. ;  ; void SetClearOnClose (const std::shared_ptr< void > &handle=nullptr);  Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ;  ; void SetClientVersion (const std::string &vers);  Set client version, used as prefix in scripts URL When changed, web browser will reload all related JS files while full URL will be different Default is empty value - no extra string in URL Version should be string like ""1.2"" or ""ver1.subv2"" and not contain any special symbols. ;  ; void SetConnectCallBack (WebWindowConnectCallback_t func);  Set call-back function for new connection. ;  ; void SetConnLimit (unsigned lmt=0);  Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ;  ; void SetConnToken (const std::string &token="""");  Configures connection token (default none) When specified, in URL of webpage such token should be provided as &token=value parameter, otherwise web window will refuse connection. ;  ; void SetDataCallBac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:6873,clear,cleared,6873,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to the TTree for each table; column (default=kFALSE). const char * At(Int_t i) const; {return fFirstParentRow + i*fParentRowSize;}. Long_t GetRowSize(); { return fParentRowSize; }. Int_t operator[](Int_t value) const; { return BSearch(value); }. Int_t operator[](Long_t value) const; { return BSearch(value); }. Int_t operator[](Double_t value) const; { return BSearch(value); }. Int_t operator[](void* value) const; { return BSearch(value); }. Int_t operator()(Float_t value); { return BinarySearch(value); }. Int_t operator()(Int_t value); { return BinarySearch(value); }. Int_t operator()(Long_t value); { return BinarySearch(value); }. Int_t operator()(Double_t value); { return BinarySearch(value); }. TTableSorter(const TTableSorter& ). TTableSorter & operator=(const TTableSorter& ). int CompareFloat_t(const void** , const void** ). int CompareInt_t(const void** , con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTableSorter.html:19287,learn,learn,19287,root/html534/TTableSorter.html,https://root.cern,https://root.cern/root/html534/TTableSorter.html,3,['learn'],['learn']
Usability,"const. Counts the number of different key values. Bool_t FillIndexArray(). File the array of the pointers and check whether; the original table has been sorted to avoid an extra job. Return: kTRUE - the table has been sorted; kFALSE - otherwise. Int_t FindFirstKey(const void* key) const. Looks for the first index of the ""key""; within SORTED table AFTER sorting. Returns: = -1 if the ""key"" was not found. Note: This method has no sense for; ==== the float and double key. To get the index within the original; unsorted table the GetIndex() method; may be used like this:; GetIndex(FindFirstKey(key)). const char * GetTableName() const; to be documented. const char * GetTableTitle() const; to be documented. const char * GetTableType() const; to be documented. TTable * GetTable() const; to be documented. void SetSearchMethod(); Select search function at once. void QSort(); Call the standard C run-time library ""qsort"" function. void LearnTable(). LearnTable() allows the TTableSorter to learn the structure of the; tables used to fill the ntuple.; table - the name of the table; buildTree - if kTRUE, then add TBranches to the TTree for each table; column (default=kFALSE). const char * At(Int_t i) const; {return fFirstParentRow + i*fParentRowSize;}. Long_t GetRowSize(); { return fParentRowSize; }. Int_t operator[](Int_t value) const; { return BSearch(value); }. Int_t operator[](Long_t value) const; { return BSearch(value); }. Int_t operator[](Double_t value) const; { return BSearch(value); }. Int_t operator[](void* value) const; { return BSearch(value); }. Int_t operator()(Float_t value); { return BinarySearch(value); }. Int_t operator()(Int_t value); { return BinarySearch(value); }. Int_t operator()(Long_t value); { return BinarySearch(value); }. Int_t operator()(Double_t value); { return BinarySearch(value); }. int CompareFloat_t(const void** , const void** ). int CompareInt_t(const void** , const void** ). int CompareLong_t(const void** , const void** ). int CompareULong_t(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:19189,learn,learn,19189,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,3,['learn'],['learn']
Usability,"const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:6532,clear,clearValueAndShapeDirty,6532,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:4911,clear,clearValueDirty,4911,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:4911,clear,clearValueDirty,4911,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"const;  Print statistics about the TreeCache for this tree. ;  ; virtual Long64_t Process (const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the TSelector code in the specified filename. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the code in the specified selector. ;  ; virtual Long64_t Project (const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Make a projection of a tree using selections. ;  ; virtual TSQLResult * Query (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over entries and return a TSQLResult object containing entries following selection. ;  ; virtual Long64_t ReadFile (const char *filename, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from filename. ;  ; virtual Long64_t ReadStream (std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:35581,simpl,simply,35581,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,3,['simpl'],['simply']
Usability,"const;  Print statistics about the TreeCache for this tree. ;  ; virtual Long64_t Process (const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the TSelector code in the specified filename. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the code in the specified selector. ;  ; virtual Long64_t Project (const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Make a projection of a tree using selections. ;  ; virtual TSQLResult * Query (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over entries and return a TSQLResult object containing entries following selection. ;  ; virtual Long64_t ReadFile (const char *filename, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from filename. ;  ; virtual Long64_t ReadStream (std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from an input stream. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:17191,simpl,simply,17191,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['simpl'],['simply']
Usability,"const;  Print statistics about the TreeCache for this tree. ;  ; virtual Long64_t Process (const char *filename, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the TSelector code in the specified filename. ;  ; virtual Long64_t Process (TSelector *selector, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Process this tree executing the code in the specified selector. ;  ; virtual Long64_t Project (const char *hname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Make a projection of a tree using selections. ;  ; virtual TSQLResult * Query (const char *varexp="""", const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Loop over entries and return a TSQLResult object containing entries following selection. ;  ; virtual Long64_t ReadFile (const char *filename, const char *branchDescriptor="""", char delimiter=' ');  Create or simply read branches from filename. ;  ; void RecursiveRemove (TObject *obj) override;  Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ;  ; virtual void Refresh ();  Refresh contents of this tree and its branches from the current status on disk. ;  ; virtual void RegisterExternalFriend (TFriendElement *);  Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual void RemoveFriend (TTree *);  Remove a friend from the list of friends. ;  ; virtual void Reset (Option_t *option="""");  Reset baskets, buffers and entries count in all branches and leaves. ;  ; virtual void ResetAfterMerge (TFileMergeInfo *);  Resets the state of this TTree after a merge (keep the customization but forget the data). ;  ; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:18481,simpl,simply,18481,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,2,['simpl'],['simply']
Usability,"content of log file. ;  ; std::string NewWidgetMsg (std::shared_ptr< RBrowserWidget > &widget);  Create message which send to client to create new widget. ;  ; std::string ProcessBrowserRequest (const std::string &msg);  Process browser request. ;  ; std::string ProcessDblClick (unsigned connid, std::vector< std::string > &args);  Process dbl click on browser item. ;  ; void ProcessMsg (unsigned connid, const std::string &arg);  Process received message from the client. ;  ; void ProcessPostponedRequests ();  Process postponed requests - decouple from websocket handling Only requests which can take longer time should be postponed. ;  ; void ProcessRunMacro (const std::string &file_path);  Process run macro command in the editor. ;  ; void ProcessSaveFile (const std::string &fname, const std::string &content);  Process file save command in the editor. ;  ; void SendInitMsg (unsigned connid);  Process client connect. ;  ; void SendProgress (unsigned connid, float progr);  Send generic progress message to the web window Should show progress bar on client side. ;  . Protected Attributes; std::string fActiveWidgetName;  ! name of active widget ;  ; RBrowserData fBrowsable;  ! central browsing element ;  ; bool fCatchWindowShow {true};  ! if arbitrary RWebWindow::Show calls should be catched by browser ;  ; unsigned fConnId {0};  ! default connection id ;  ; float fLastProgressSend {0};  ! last value of send progress ;  ; long long fLastProgressSendTm {0};  ! time when last progress message was send ;  ; std::vector< std::vector< std::string > > fPostponed;  ! postponed messages, handled in timer ;  ; std::string fPromptFileOutput;  ! file name for prompt output ;  ; std::unique_ptr< RBrowserTimer > fTimer;  ! timer to handle postponed requests ;  ; std::string fTitle;  ! title ;  ; bool fUseRCanvas {false};  ! which canvas should be used ;  ; std::shared_ptr< RWebWindow > fWebWindow;  ! web window to browser ;  ; int fWidgetCnt {0};  ! counter for created widgets ;  ; std",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowser.html:3608,progress bar,progress bar,3608,doc/v632/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowser.html,2,['progress bar'],['progress bar']
Usability,"cord a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDebug (Int_t level=1, Long64_t min=0, Long64_t max=9999999);  Set the debug level and the debug range. ;  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:25828,learn,learning,25828,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['learn'],['learning']
Usability,"cord a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ;  ; virtual void RemoveExternalFriend (TFriendElement *);  Removes external friend. ;  ; virtual bool SetAlias (const char *aliasName, const char *aliasFormula);  Set a tree variable alias. ;  ; virtual void SetAutoFlush (Long64_t autof=-30000000);  This function may be called at the start of a program to change the default value for fAutoFlush. ;  ; virtual void SetAutoSave (Long64_t autos=-300000000);  In case of a program crash, it will be possible to recover the data in the tree up to the last AutoSave point. ;  ; virtual void SetBasketSize (const char *bname, Int_t buffsize=16000);  Set a branch's basket size. ;  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T **add, TBranch **ptr=nullptr);  ; template<class T > ; Int_t SetBranchAddress (const char *bname, T *add, TBranch **ptr=nullptr);  ; virtual Int_t SetCacheEntryRange (Long64_t first, Long64_t last);  interface to TTreeCache to set the cache entry range ;  ; virtual void SetCacheLearnEntries (Int_t n=10);  Interface to TTreeCache to set the number of entries for the learning phase. ;  ; virtual void SetChainOffset (Long64_t offset=0);  ; virtual void SetCircular (Long64_t maxEntries);  Enable/Disable circularity for this tree. ;  ; virtual void SetClusterPrefetch (bool enabled);  ; virtual void SetDefaultEntryOffsetLen (Int_t newdefault, bool updateExisting=false);  Update the default value for the branch's fEntryOffsetLen. ;  ; virtual Long64_t SetEntries (Long64_t n=-1);  Change number of entries in the tree. ;  ; virtual void SetEstimate (Long64_t nentries=1000000);  Set number of entries to estimate variable limits. ;  ; virtual void SetFileNumber (Int_t number=0);  Set fFileNumber to number. ;  ; virtual void SetImplicitMT (bool enabled);  ; ROOT::TIOFeatures SetIOFeatures (const ROOT::TIOFeatures &);  Provide the end-user with the ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:26767,learn,learning,26767,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['learn'],['learning']
Usability,corder/replayer interface for a user.; TRecorderInactive Represents state of TRecorder after its creation; TRecorderPaused Represents state of TRecorder when paused; TRecorderRecording Represents state of TRecorder when recording events; TRecorderReplaying Represents state of TRecorder when replaying; TRecorderState Abstract class that defines interface for a state of recorder; TRedirectOutputGuard Exception safe output redirection; TRef Persistent Reference link to a TObject; TRefArray An array of references to TObjects; TRefArrayIter Object array iterator; TRefCnt ; TRefTable Table of referenced objects during an I/O operation; TRegexp Regular expression class; TRemoteObject A remote object; TResponseTable Generic Geant detector response table; TRint ROOT Interactive Application Interface; TRobustEstimator Minimum Covariance Determinant Estimator; TRolke ; TRootApplication ROOT native GUI application environment; TRootAuth client auth interface; TRootBrowser New ROOT Browser; TRootBrowserLite ROOT native GUI version of browser; TRootCanvas ROOT native GUI version of main window with menubar and drawing area; TRootContextMenu ROOT native GUI context sensitive popup menu; TRootControlBar ROOT native GUI implementation of TControlBar; TRootDialog Native GUI method argument prompt dialog box; TRootEmbeddedCanvas A ROOT TCanvas that can be embedded in a TGFrame; TRootGuiBuilder ROOT GUI Builder; TRootGuiFactory Factory for ROOT GUI components; TRootHelpDialog Dialog to display help text; TRootIOCtor ; TRootSecContext Class providing host specific authentication information; TRotMatrix Rotation Matrix for 3-D geometry objects; TRotation Rotations of TVector3 objects; TSAXParser SAX Parser; TSPHE SPHE shape; TSPlot class to disentangle signal from background; TSQLClassColumnInfo Keeps information about single column in class table; TSQLClassInfo Keeps the table information relevant for one class ; TSQLColumnData Single SQL column data.; TSQLColumnInfo Summury information ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:120772,pause,paused,120772,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,1,['pause'],['paused']
Usability,"count in the message service...; 3521 ccoutD(Eval) << ""RooAbsReal::logEvalError("" << GetName(); 3522 << "") delayed evaluation error, "" << std::endl; 3523 << "" origin : "" << oss2.str() << std::endl; 3524 << "" message : "" << oee._msg << std::endl; 3525 << "" server values: "" << oee._srvval << std::endl ;; 3526 evalErrorList.second.pop_front();; 3527 }; 3528 evalErrorList.first = oss2.str() ;; 3529 evalErrorList.second.push_back(ee) ;; 3530 }; 3531 ; 3532 inLogEvalError = false ;; 3533 //coutE(Tracing) << ""RooAbsReal::logEvalError("" << GetName() << "") message = "" << message << std::endl ;; 3534}; 3535 ; 3536 ; 3537 ; 3538 ; 3539////////////////////////////////////////////////////////////////////////////////; 3540/// Clear the stack of evaluation error messages; 3541 ; 3542void RooAbsReal::clearEvalErrorLog(); 3543{; 3544 if (evalErrorData().mode == PrintErrors) {; 3545 return ;; 3546 } else if (evalErrorData().mode == CollectErrors) {; 3547 evalErrorData().errorList.clear() ;; 3548 } else {; 3549 evalErrorData().count = 0 ;; 3550 }; 3551}; 3552 ; 3553 ; 3554////////////////////////////////////////////////////////////////////////////////; 3555/// Retrieve bin boundaries if this distribution is binned in `obs`.; 3556/// \param[in] obs Observable to retrieve boundaries for.; 3557/// \param[in] xlo Beginning of range.; 3558/// \param[in] xhi End of range.; 3559/// \return The caller owns the returned std::list.; 3560std::list<double>* RooAbsReal::binBoundaries(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3561 return nullptr;; 3562}; 3563 ; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:151609,clear,clear,151609,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['clear']
Usability,counting experiment with uncertainty on both the background rate and signal efficiency. ;  ; file  rs101_limitexample.py;   Limits: number counting experiment with uncertainty on both the background rate and signal efficiency. ;  ; file  rs102_hypotestwithshapes.C;   A typical search for a new particle by studying an invariant mass distribution ;  ; file  rs301_splot.C;   SPlot tutorial ;  ; file  rs302_JeffreysPriorDemo.C;   tutorial demonstrating and validates the RooJeffreysPrior class ;  ; file  rs401c_FeldmanCousins.C;   Produces an interval on the mean signal in a number counting experiment with known background using the Feldman-Cousins technique. ;  ; file  rs401c_FeldmanCousins.py;   Produces an interval on the mean signal in a number counting experiment with known background using the Feldman-Cousins technique. ;  ; file  rs401d_FeldmanCousins.C;   Neutrino Oscillation Example from Feldman & Cousins ;  ; file  rs601_HLFactoryexample.C;   High Level Factory: creation of a simple model ;  ; file  rs601_HLFactoryexample.py;   High Level Factory: creation of a simple model ;  ; file  rs602_HLFactoryCombinationexample.C;   High Level Factory: creation of a combined model ;  ; file  rs603_HLFactoryElaborateExample.C;   High Level Factory: creating a complex combined model. ;  ; file  rs701_BayesianCalculator.C;   Bayesian calculator: basic example ;  ; file  rs701_BayesianCalculator.py;   Bayesian calculator: basic example ;  ; file  rs_bernsteinCorrection.C;   Example of the BernsteinCorrection utility in RooStats. ;  ; file  rs_bernsteinCorrection.py;   Example of the BernsteinCorrection utility in RooStats. ;  ; file  rs_numberCountingCombination.C;   'Number Counting Example' RooStats tutorial macro #100 ;  ; file  rs_numbercountingutils.C;   'Number Counting Utils' RooStats tutorial ;  ; file  rs_numbercountingutils.py;   'Number Counting Utils' RooStats tutorial ;  ; file  StandardBayesianMCMCDemo.C;   Standard demo of the Bayesian MCMC calculator ;  ; fil,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roostats.html:2188,simpl,simple,2188,doc/master/group__tutorial__roostats.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roostats.html,1,['simpl'],['simple']
Usability,"cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2618 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2619 return;; 2620 }; 2621 fError = nullptr;; 2622 ; 2623 if (angle) {; 2624 Int_t cBoxX[4], cBoxY[4];; 2625 Int_t ptx, pty;; 2626 if (TestBit(kTextNDC)) {; 2627 ptx = gPad->UtoPixel(fX);; 2628 pty = gPad->VtoPixel(fY);; 2629 } else {; 2630 ptx = gPad->XtoAbsPixel(gPad->XtoPad(fX));; 2631 pty = gPad->YtoAbsPixel(gPad->YtoPad(fY));; 2632 }; 2633 GetControlBox(ptx, pty, fTextAngle, cBoxX, cBoxY);; 2634 Int_t x1 = cBoxX[0];; 2635 Int_t x2 = cBoxX[0];; 2636 Int_t y1 = cBoxY[0];; 2637 Int_t y2 = cBoxY[0];; 2638 for (Int_t i=1; i<4; i++) {; 2639 if (cBoxX[i] < x1) x1 = cBoxX[i];; 2640 if (cBoxX[i] > x2) x2 = cBoxX[i];; 2641 if (cBoxY[i] < y1) y1 = cBoxY[i];; 2642 if (cBoxY[i] > y2) y2 = cBoxY[i];; 2643 }; 2644 w = x2-x1;; 2645 h = y2-y1;; 2646 } else {; 2647 const Char_t *text = newText.Data() ;; 2648 TLatexFormSize fs = FirstParse(GetTextAngle(),GetTextSize(),text);; 2649 fTabSize.clear();; 2650 w = (UInt_t)fs.Width();; 2651 h = (UInt_t)fs.Height();; 2652 }; 2653}; 2654 ; 2655////////////////////////////////////////////////////////////////////////////////; 2656/// Return size of the formula along Y in pad coordinates when the text precision; 2657/// is smaller than 3.; 2658 ; 2659Double_t TLatex::GetYsize(); 2660{; 2661 if (!gPad) return 0.;; 2662 TString newText = GetTitle();; 2663 if( newText.Length() == 0) return 0;; 2664 ; 2665 // The text is a TMathText.; 2666 if ( newText.Contains(""\\"") ) {; 2667 TMathText tm(0., 0., newText.Data());; 2668 return tm.GetYsize();; 2669 }; 2670 ; 2671 fError = nullptr;; 2672 if (CheckLatexSyntax(newText)) {; 2673 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2674 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2675 return 0;; 2676 }; 2677 fError = nullptr;; 2678 ; 2679 const Char_t *text = newText.Data();; 2680 Double_t angsav = fTextAngle;; 2681 TLatexFormSize fs = FirstParse(0,GetTextSize(),text);; 2682 fTextAngle = angsav;; 2683 fTabSi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:93818,clear,clear,93818,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['clear'],['clear']
Usability,"coverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(currentline, kBufSize);; 1800 if (macro.eof()) break;; 1801 if (!res) {; 1802 // Probably only read kBufSize, let's ignore the remainder of; 1803 // the line.; 1804 macro.clear();; 1805 while (!macro.getline(dummyline, kBufSize) && !macro.eof()) {; 1806 macro.clear();; 1807 }; 1808 }; 1809 s = currentline;; 1810 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1811 ; 1812 // very simple minded pre-processor parsing, only works in case macro file; 1813 // starts with ""#ifndef __CINT__"". In that case everything till next; 1814 // ""#else"" or ""#endif"" will be skipped.; 1815 if (*s == '#') {; 1816 char *cs = Compress(currentline);; 1817 if (strstr(cs, ""#ifndef__CINT__"") ||; 1818 strstr(cs, ""#if!defined(__CINT__)"")); 1819 ifndefc = 1;; 1820 else if (ifndefc && (strstr(cs, ""#ifdef"") || strstr(cs, ""#ifndef"") ||; 1821 strstr(cs, ""#ifdefined"") || strstr(cs, ""#if!defined""))); 1822 ifdef++;; 1823 else if (ifndefc && strstr(cs, ""#endif"")) {; 1824 if (ifdef); 1825 ifdef--;; 1826 else; 1827 ifndefc = 0;; 1828 } else if (ifndefc && !ifdef && strstr(cs, ""#else"")); 1829 ifndefc = 0;; 1830 delete [] cs;; 1831 }; 1832 if (!*s || *s == '#' || ifndefc || !strncmp(s, ""//"", 2)) continue;; 1833 ; 1834 if (!comment && (!strncmp(s, "".X"", 2) || !strncmp(s, "".x"", 2))) {; 1835 retval = ExecuteFile(s+3);; 1836 execute = kTRUE;; 1837 continue;; 1838 }; 1839 ; 1840 if (!str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:69765,clear,clear,69765,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,2,"['clear', 'simpl']","['clear', 'simple']"
Usability,"cpy(buff, c+1, n+1); // strlcpy copy 'size-1' characters.; 1169 std::string hd = GetHomeDirectory(buff);; 1170 e = c+1+n;; 1171 if (!hd.empty()) { // we have smth to copy; 1172 p = hd.c_str();; 1173 strlcpy(x, p, kBufSize);; 1174 x += strlen(p);; 1175 c = e;; 1176 } else {; 1177 x++[0] = c[0];; 1178 //++ier;; 1179 ++c;; 1180 }; 1181 }; 1182 ; 1183 for ( ; c[0]; c++) {; 1184 ; 1185 p = nullptr; e = nullptr;; 1186 ; 1187 if (c[0] == '.' && c[1] == '/' && c[-1] == ' ') { // $cwd; 1188 std::string wd = GetWorkingDirectory();; 1189 strlcpy(buff, wd.c_str(), kBufSize);; 1190 p = buff;; 1191 e = c + 1;; 1192 }; 1193 if (p) { // we have smth to copy */; 1194 strlcpy(x, p, kBufSize); x += strlen(p); c = e-1; continue;; 1195 }; 1196 ; 1197 if (c[0] != '$') { // not $, simple copy; 1198 x++[0] = c[0];; 1199 } else { // we have a $; 1200 b = c+1;; 1201 if (c[1] == '(') b++;; 1202 if (c[1] == '{') b++;; 1203 if (b[0] == '$'); 1204 e = b+1;; 1205 else; 1206 for (e = b; isalnum(e[0]) || e[0] == '_'; e++) ;; 1207 buff[0] = 0; strncat(buff, b, e-b);; 1208 p = Getenv(buff);; 1209 if (!p) { // too bad, try UPPER case; 1210 for (t = buff; (t[0] = toupper(t[0])); t++) ;; 1211 p = Getenv(buff);; 1212 }; 1213 if (!p) { // too bad, try Lower case; 1214 for (t = buff; (t[0] = tolower(t[0])); t++) ;; 1215 p = Getenv(buff);; 1216 }; 1217 if (!p && !strcmp(buff, ""cwd"")) { // it is $cwd; 1218 std::string wd = GetWorkingDirectory();; 1219 strlcpy(buff, wd.c_str(), kBufSize);; 1220 p = buff;; 1221 }; 1222 if (!p && !strcmp(buff, ""$"")) { // it is $$ (replace by GetPid()); 1223 snprintf(buff,kBufSize*4, ""%d"", GetPid());; 1224 p = buff;; 1225 }; 1226 if (!p) { // too bad, nothing can help; 1227#ifdef WIN32; 1228 // if we're on windows, we can have \\SomeMachine\C$ - don't; 1229 // complain about that, if '$' is followed by nothing or a; 1230 // path delimiter.; 1231 if (c[1] && c[1]!='\\' && c[1]!=';' && c[1]!='/'); 1232 ier++;; 1233#else; 1234 ier++;; 1235#endif; 1236 x++[0] = c[0];; 1237 } else { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:36946,simpl,simple,36946,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['simpl'],['simple']
Usability,"created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMediumEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMediumEditor.html:22034,undo,undoing,22034,root/html528/TGeoMediumEditor.html,https://root.cern,https://root.cern/root/html528/TGeoMediumEditor.html,1,['undo'],['undoing']
Usability,"created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMediumEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoMediumEditor.html:22134,undo,undoing,22134,root/html530/TGeoMediumEditor.html,https://root.cern,https://root.cern/root/html530/TGeoMediumEditor.html,1,['undo'],['undoing']
Usability,"created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoMediumEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for medium editor. ~TGeoMediumEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoEditMaterial(); Edit selected material. void DoMedName(); Slot for medium name. void DoMedId(); Slot for medium id. void DoSelectMaterial(); Select the material component. void DoToggleSensitive(); Slot for sensitivity. void DoMagfldSelect(Int_t ientry); Slot for mag. field. void DoFieldm(); Slot for max field. void DoTmaxfd(); Slot for tmaxfd. void DoStemax(); Slot for the max allowed step. void DoDeemax(); Slot for the maximum allowed dedx. void DoEpsil(); Slot for tracking precision. void DoStmin(); Slot for min. step. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMediumEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoMediumEditor.html:22134,undo,undoing,22134,root/html532/TGeoMediumEditor.html,https://root.cern,https://root.cern/root/html532/TGeoMediumEditor.html,1,['undo'],['undoing']
Usability,cript. ; Definition at line 3009 of file TPostScript.cxx. ◆ VtoPS(). Int_t TPostScript::VtoPS ; (; Double_t ; v). Convert V from NDC coordinate to PostScript. ; Definition at line 3018 of file TPostScript.cxx. ◆ XtoPS(). Int_t TPostScript::XtoPS ; (; Double_t ; x). Convert X from world coordinate to PostScript. ; Definition at line 3027 of file TPostScript.cxx. ◆ YtoPS(). Int_t TPostScript::YtoPS ; (; Double_t ; y). Convert Y from world coordinate to PostScript. ; Definition at line 3036 of file TPostScript.cxx. ◆ Zone(). void TPostScript::Zone ; (; ). Initialize the PostScript page in zones. ; Definition at line 3045 of file TPostScript.cxx. Member Data Documentation. ◆ fBlue. Float_t TPostScript::fBlue. protected . Per cent of blue. ; Definition at line 50 of file TPostScript.h. ◆ fBoundingBox. Bool_t TPostScript::fBoundingBox. protected . True for Encapsulated PostScript. ; Definition at line 63 of file TPostScript.h. ◆ fClear. Bool_t TPostScript::fClear. protected . True when page must be cleared. ; Definition at line 64 of file TPostScript.h. ◆ fClip. Int_t TPostScript::fClip. protected . Clipping mode. ; Definition at line 62 of file TPostScript.h. ◆ fClipStatus. Bool_t TPostScript::fClipStatus. protected . Clipping Indicator. ; Definition at line 65 of file TPostScript.h. ◆ fCurrentColor. Int_t TPostScript::fCurrentColor. protected . current Postscript color index ; Definition at line 58 of file TPostScript.h. ◆ fDXC. Float_t TPostScript::fDXC. protected . Definition at line 31 of file TPostScript.h. ◆ fDYC. Float_t TPostScript::fDYC. protected . Definition at line 32 of file TPostScript.h. ◆ fFileName. TString TPostScript::fFileName. protected . PS file name. ; Definition at line 77 of file TPostScript.h. ◆ fFontEmbed. Bool_t TPostScript::fFontEmbed. protected . True is FontEmbed has been called. ; Definition at line 78 of file TPostScript.h. ◆ fFX. Float_t TPostScript::fFX. protected . Definition at line 35 of file TPostScript.h. ◆ fFY. Float_t TPostScript:,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPostScript.html:53035,clear,cleared,53035,doc/master/classTPostScript.html,https://root.cern,https://root.cern/doc/master/classTPostScript.html,1,['clear'],['cleared']
Usability,"cription(topnode, topnode->GetVolume());; 447 ; 448 if (!volname.empty()) {; 449 auto vol = mgr->GetVolume(volname.c_str());; 450 RGeomBrowserIter iter(*this);; 451 if (vol && (vol != topnode->GetVolume()) && iter.Navigate(vol)); 452 fSelectedStack = MakeStackByIds(iter.CurrentIds());; 453 }; 454}; 455 ; 456/////////////////////////////////////////////////////////////////////; 457/// Collect information about geometry from single volume; 458/// like it done in JSROOT ClonedNodes.createClones; 459 ; 460void RGeomDescription::Build(TGeoVolume *vol); 461{; 462 ClearDescription();; 463 if (!vol); 464 return;; 465 ; 466 TLockGuard lock(fMutex);; 467 ; 468 fDrawVolume = vol;; 469 ; 470 fSelectedStack.clear();; 471 ; 472 BuildDescription(nullptr, fDrawVolume);; 473}; 474 ; 475/////////////////////////////////////////////////////////////////////; 476/// Clear geometry description; 477 ; 478void RGeomDescription::ClearDescription(); 479{; 480 TLockGuard lock(fMutex);; 481 ; 482 fDesc.clear();; 483 fNodes.clear();; 484 fSortMap.clear();; 485 ClearDrawData();; 486 fDrawIdCut = 0;; 487 fDrawVolume = nullptr;; 488 fSelectedStack.clear();; 489}; 490 ; 491/////////////////////////////////////////////////////////////////////; 492/// Build geometry description; 493 ; 494void RGeomDescription::BuildDescription(TGeoNode *topnode, TGeoVolume *topvolume); 495{; 496 // vector to remember numbers; 497 std::vector<int> numbers;; 498 int offset = 1000000000;; 499 ; 500 // try to build flat list of all nodes; 501 TGeoNode *snode = topnode;; 502 TGeoIterator iter(topvolume);; 503 do {; 504 if (!snode) {; 505 numbers.emplace_back(offset);; 506 fNodes.emplace_back(nullptr);; 507 } else if (snode->GetNumber() >= offset) {; 508 // artificial offset already applied, used as identifier; 509 iter.Skip(); // no need to look inside; 510 } else {; 511 numbers.emplace_back(snode->GetNumber());; 512 snode->SetNumber(offset + fNodes.size()); // use id with shift 1e9; 513 fNodes.emplace_back(snode);; 514 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:12498,clear,clear,12498,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"cription; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::SplitRule. class RooSimWSTool::SplitRule: public TNamed. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSimWSTool__SplitRule.html:1099,simpl,simple,1099,root/html534/RooSimWSTool__SplitRule.html,https://root.cern,https://root.cern/root/html534/RooSimWSTool__SplitRule.html,3,['simpl'],['simple']
Usability,"cs » 3D Graphics » Basic 3D graphics. ; An hyperboloid (not implemented) ; It has 4 parameters:. name: name of the shape; title: shape's title; material: (see TMaterial); rmin: inner radius of the tube; rmax: outer radius of the tube; dz: half-length of the box along the z-axis; phi: stereo angle . Definition at line 28 of file THYPE.h. Public Member Functions;  THYPE ();  HYPE shape default constructor. ;  ;  THYPE (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi);  HYPE shape normal constructor. ;  ;  ~THYPE () override;  HYPE shape default destructor. ;  ; virtual Float_t GetPhi () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TTUBE;  TTUBE ();  TUBE shape default constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmax, Float_t dz);  TUBE shape ""simplified"" constructor. ;  ;  TTUBE (const char *name, const char *title, const char *material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect=1);  TUBE shape normal constructor. ;  ;  ~TTUBE () override;  TUBE shape default destructor. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a TUBE. ;  ; virtual Float_t GetAspectRatio () const;  ; const TBuffer3D & GetBuffer3D (Int_t reqSections) const override;  Get buffer 3d. ;  ; virtual Float_t GetDz () const;  ; virtual Int_t GetNdiv () const;  ; virtual Int_t GetNumberOfDivisions () const;  ; virtual Float_t GetRmax () const;  ; virtual Float_t GetRmin () const;  ; TClass * IsA () const override;  ; virtual void SetAspectRatio (Float_t factor=1);  ; virtual void SetNumberOfDivisions (Int_t ndiv);  Set number of divisions used to draw this tube. ;  ; void Sizeof3D () const override;  Return total X3D needed by TNode::ls (when called wi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHYPE.html:1314,simpl,simplified,1314,doc/master/classTHYPE.html,https://root.cern,https://root.cern/doc/master/classTHYPE.html,1,['simpl'],['simplified']
Usability,"ct class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0 no compression.; level = 1 minimal compression level but fast. level = 9 maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferXML.html:27117,simpl,simple,27117,root/html530/TBufferXML.html,https://root.cern,https://root.cern/root/html530/TBufferXML.html,5,['simpl'],['simple']
Usability,"ct class, return 0.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). void* ConvertFromXMLAny(const char* str, TClass** cl = 0, Bool_t GenericLayout = kFALSE, Bool_t UseNamespaces = kFALSE); Read object of any class from XML, produced by ConvertToXML() method.; If cl!=0, return actual class of object.; GenericLayout and UseNamespaces should be the same as in ConvertToXML(). XMLNodePointer_t XmlWriteAny(const void* obj, const TClass* cl); Convert object of any class to xml structures; Return pointer on top xml element. void* XmlReadAny(XMLNodePointer_t node, void* obj, TClass** cl); Recreate object from xml structure.; Return pointer to read object.; if (cl!=0) returns pointer to class of object. void WriteObject(const TObject* obj); Convert object into xml structures.; !!! Should be used only by TBufferXML itself.; Use ConvertToXML() methods to convert your object to xml; Redefined here to avoid gcc 3.x warning. TXMLStackObj* PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); add new level to xml stack. TXMLStackObj* PopStack(); remove one level from xml stack. TXMLStackObj* Stack(Int_t depth = 0); return xml stack object of specified depth. XMLNodePointer_t StackNode(); return pointer on current xml node. void ShiftStack(const char* info = 0); shift stack node to next. void XmlWriteBlock(XMLNodePointer_t node); write binary data block from buffer to xml; this data can be produced only by direct call of TBuffer::WriteBuf() functions. void XmlReadBlock(XMLNodePointer_t node); read binary block of data from xml. Bool_t ProcessPointer(const void* ptr, XMLNodePointer_t node); Add ""ptr"" attribute to node, if ptr is null or; if ptr is pointer on object, which is already saved in buffer; Automatically add ""ref"" attribute to node, where referenced object is stored. void RegisterPointer(const void* ptr, XMLNodePointer_t node); Register pair of object pointer and node, where this object is saved,; in object map. Bool_t ExtractPointer(XMLNodePo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBufferXML.html:25995,simpl,simple,25995,root/html526/TBufferXML.html,https://root.cern,https://root.cern/root/html526/TBufferXML.html,2,['simpl'],['simple']
Usability,"ct the ""Associated Members"". TDataSet * FindByPath(const char* path) const; Aliase for TDataSet::Find(const Char_t *path) method. TDataSet * Find(const char* path) const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByName(const char* name, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This is method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * FindByTitle(const char* title, const char* path = """", Option_t* opt = """") const. Full description see: TDataSetIter::Find. Note. This method is quite expansive.; ----- It is done to simplify the user's code when one wants to find ONLY object.; If you need to find more then 1 object in this dataset,; regard using TDataSetIter class yourself. TDataSet * First() const; Return the first object in the list. Returns 0 when list is empty. void AddMain(TDataSet* set); add data set to main data set. TDataSet * GetMainSet(); return pointer to the main dataset. TObject * GetObject() const; The depricated method (left here for the sake of the backward compatibility). TDataSet * Last() const; Return the last object in the list. Returns 0 when list is empty. TDataSet * Next() const; Return the object next to this one in the parent structure; This convinient but time-consuming. Don't use it in the inner loops. TDataSet * Prev() const; Return the object that is previous to this one in the parent structure; This convinient but time-consuming. Don't use it in the inner loops. void SetObject(TObject* obj); The depricated method (left here for the sake of the backward compatibility). void ls(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSet.html:14727,simpl,simplify,14727,root/html528/TDataSet.html,https://root.cern,https://root.cern/root/html528/TDataSet.html,6,['simpl'],['simplify']
Usability,"ct::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = __null); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = __null); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. private:. TQCommand&operator=(const TQCommand&). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:15748,undo,undo,15748,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"ct::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-12 16:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TCollectionPropertyBrowsable.html:9611,simpl,simply,9611,root/html534/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html534/TCollectionPropertyBrowsable.html,1,['simpl'],['simply']
Usability,"ct::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 40605 2011-08",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TCollectionPropertyBrowsable.html:9592,simpl,simply,9592,root/html532/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html532/TCollectionPropertyBrowsable.html,1,['simpl'],['simply']
Usability,"ct::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); contrsuctor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchBrowsable.h 20882 2007-11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionPropertyBrowsable.html:9537,simpl,simply,9537,root/html526/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionPropertyBrowsable.html,3,['simpl'],['simply']
Usability,"ct; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Int_tfColDimensionsThe number of the dimensions for array (=-1 means it is a ""simple"" array); TStringfColName; Int_tfColOffset; Int_tfColSizeThe size of the selected column in bytes; TTable::EColumnTypefColTypedata type of the selected column; COMPAREMETHODfCompareMethodFunction to sort the original array; const char*fFirstParentRow! pointer to the internal array of TTable object;; Int_tfFirstRowfirst row of the table to be sorted; Int_t*fIndexArray""parsed"" indecis; Int_tfLastFoundThe index of the last found index within fSortIndex; TStringTNamed::fNameobject identifier; Int_tfNumberOfRowsnumber of rows of the table to be sorted; Long_tfParentRowSizeTo be filled from TTable::GetRowSize() method; const TTable*fParentTable!- the back pointer to the sorted table; SEARCHMETHODfSearchMethodFunction selected to search values; void**fSortIndexArray of pointers to columns of the sorted table; TStringTNamed::fTitleobject title; const Char_t*fsimpleArrayPointer to the ""simple"" array;. private:. union(anonymous)fValue. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TTableSorter. Function documentation; TTableSorter(); default ctor for RootCint dictionary. TTableSorter(const TTable& table, TString& colName, Int_t firstRow = 0, Int_t numbeRows = 0). TTableSorter ctor sorts the input table along its column defined with colName. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableSorter.html:12401,simpl,simple,12401,root/html602/TTableSorter.html,https://root.cern,https://root.cern/root/html602/TTableSorter.html,4,['simpl'],['simple']
Usability,"cted number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Mon Dec 7 13:45:38 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsGenContext.html:9980,clear,clear,9980,root/html526/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html526/RooAbsGenContext.html,1,['clear'],['clear']
Usability,"cted number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Mon Jul 4 15:21:22 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsGenContext.html:10326,clear,clear,10326,root/html530/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html530/RooAbsGenContext.html,1,['clear'],['clear']
Usability,"cted number of events, if non-zero. The returned; dataset belongs to the caller. Return zero in case of an error.; Generation of individual events is delegated to a virtual generateEvent(); method. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Sat Oct 9 06:57:57 2010 » Last generated: 2010-10-09 06:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsGenContext.html:10011,clear,clear,10011,root/html528/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html528/RooAbsGenContext.html,1,['clear'],['clear']
Usability,"cted object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A clone of the selected style will be used as a base of the new; style. All its values can be modified via the style editor later.; The dialog that appears will ask for the name and description of the; new style. Import a style (from a macro):; A style macro can be imported at any time. The new imported style in; the ROOT session will become the selected one. Import a style (from a canvas):; You can do that selecting the Style menu/Import from.../Canvas or; the corresponding Tool b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:1422,undo,undo,1422,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,6,['undo'],['undo']
Usability,"ction class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasThe Canvas class.Definition TCanvas.h:23; TF11-Dim function classDefinition TF1.h:233; TF1::SetRangevirtual void SetRange(Double_t xmin, Double_t xmax)Initialize the upper and lower bounds to draw the function.Definition TF1.cxx:3528; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::SetFitResultvirtual void SetFitResult(const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr)Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (...Definition TF1.cxx:3355; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::GetListOfFunctionsTList * GetListOfFunctions() constDefinition TH1.h:244; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TStyle::SetOptFitvoid SetOptFit(Int_t fit=1)The type of information about fit parameters printed in the histogram statistics box can be selected ...Definition TStyle.cxx:1593; c1return c1Definition legend1.C:41; f1TF1 * f1Definition legend1.C:11; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; combinedFitDefinition combinedFit.py:1; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28. tutorialsfitcombinedFit.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8C_source.html:9881,simpl,simple,9881,doc/master/combinedFit_8C_source.html,https://root.cern,https://root.cern/doc/master/combinedFit_8C_source.html,1,['simpl'],['simple']
Usability,"ction will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats); and the class TNtupleD (a simple Tree with branches of doubles). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:7788,simpl,simple,7788,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['simpl'],['simple']
Usability,"ction& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidaddToRange(const char* rangeName, const char* stateNameList); virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCategory.html:2011,clear,clearValueDirty,2011,root/html526/RooCategory.html,https://root.cern,https://root.cern/root/html526/RooCategory.html,1,['clear'],['clearValueDirty']
Usability,"ction::begin ; (; ); const. inline . Definition at line 253 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 432 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 282 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 392 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inline . Check if collection contains an a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:36176,clear,clearStructureTags,36176,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clearStructureTags']
Usability,"ction::begin ; (; ); const. inline . Definition at line 276 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 455 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 305 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 415 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 76 of file RooAbsCollection.h. ◆ contains(). bool RooAbsCollection::contains ; (; const RooAbsArg & ; var); const. inline . Check if collection contains an a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsCollection.html:36950,clear,clearStructureTags,36950,doc/v632/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/v632/classRooAbsCollection.html,1,['clear'],['clearStructureTags']
Usability,"ctives; TSeqCollection*fpEnvVars; TSeqCollection*fpFiles; TSeqCollection*fpGlobals; int*fpLocinitialized by Hook(); TSeqCollection*fpPragmas; TSeqCollection*fpSysIncFiles; TSeqCollection*fpUsers. Class Charts. Inheritance Chart:. TTabCom. Function documentation; TTabCom(); Default constructor. ~TTabCom(); Destructor. void ClearClasses(); Clear classes and namespace collections. void ClearCppDirectives(); Forget all Cpp directives seen so far. void ClearEnvVars(); Forget all environment variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:8251,clear,clears,8251,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['clear'],['clears']
Usability,"ctor of efficiencies. E^-1 = ((A# Vyy^-1 A)+tau^2 Lsquared). x = E (A# Vyy^-1 y + tau^2 Lsquared x0 +lambda/2 * epsilon) is the result. The derivatives; dx_k/dy_i; dx_k/dA_ij; dx_k/d(tau^2); are calculated for further usage. The covariance matrix V_xx is calculated as:; Vxx_ij = sum_kl dx_i/dy_k Vyy_kl dx_j/dy_l. Warning:. The algorithm is based on ""standard"" matrix inversion, with the; known limitations in numerical accuracy and computing cost for; matrices with large dimensions. Thus the algorithm should not used for large dimensions of x and y; nx should not be much larger than 200; ny should not be much larger than 1000. Proper choice of tau. One of the difficult questions is about the choice of tau.; The method implemented in TUnfold is the L-curve method:; a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is available.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of the scan is determined automatically. A nice overview of the L-curve method is given in:; The L-curve and Its Use in the Numerical Treatment of Inverse Problems; (2000) by P. C. Hansen, in Computational Inverse Problems in; Electrocardiology, ed. P. Johnston,; Advances in Computational Bioengineering; http://www.imm.dtu.dk/~pch/TR/Lcurve.ps. Alternative Regularisation conditions. Regularisation is needed for most unfolding problems, in order to avoid; large oscillations and large correlations on the output bins.; It means that some extra conditions are applied on the output bins. Within TUnfold these conditions are posed on the difference (x-x0), where; x: unfolding output; x0: the bias distribution, by default calculated from; the input matrix A. There is a method SetBias(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:4871,simpl,simple,4871,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,3,['simpl'],['simple']
Usability,"ctor, either with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight is taken into account.; Finally, one starts the training with TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The first argument is the number of epochs while option is a string that can contain: ""text"" (simple text output) , ""graph"" (evoluting graphical training curves), ""update=X"" (step for the text/graph output update) or ""+"" (will skip the randomisation and start from the previous values). All combinations are available.; Example: net.Train(100,""text, graph, update=10"");; When the neural net is trained, it can be used directly ( TMultiLayerPerceptron::Evaluate() ) or exported to a standalone C++ code ( TMultiLayerPerceptron::Export() ).; Finally, note that even if this implementation is inspired from the mlpfit code, the feature lists are not exactly matching:. mlpfit hybrid learning method is not implemented; output neurons can be normalized, this is not the case for mlpfit; the neural net is exported in C++, FORTRAN or PYTHON; the drawResult() method allows a fast check of the learning procedure. In addition, the paw version of mlpfit had additional limitations on the number of neurons, hidden layers and inputs/outputs that does not apply to TMultiLayerPerceptron. ; Definition at line 26 of file TMultiLayerPerceptron.h. Public Types; enum  EDataSet { kTraining; , kTest; };  ; enum  ELearningMethod { ;   kStochastic; , kBatch; , kSteepestDescent; , kRibierePolak; , ;   kFletcherReeves; , kBFGS. };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsRefer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:8707,learn,learning,8707,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,2,['learn'],['learning']
Usability,"ctor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; virtual void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients)=0;  Update the biases, given the current bias gradients. ;  ; virtual void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients)=0;  Update the weights, given the current weight gradients. ;  . Protected Attributes; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/Optimizer.h>. Inheritance diagram for TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 47 of file Optimizer.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 48 of file Optimizer.h. Constructor & Destructor Documentation. ◆ VOptimizer(). template<typename Architecture_t , typ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html:1995,learn,learning,1995,doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VOptimizer.html,1,['learn'],['learning']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Mon Dec 7 13:48:30 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:43687,clear,clearConvolutionWindow,43687,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Mon Jul 4 15:23:33 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:44723,clear,clearConvolutionWindow,44723,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Thu Nov 3 20:08:50 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:45130,clear,clearConvolutionWindow,45130,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Thu Sep 23 20:00:22 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:44163,clear,clearConvolutionWindow,44163,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Tue Jun 2 15:32:39 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooNumConvPdf.html:49143,clear,clearConvolutionWindow,49143,root/html604/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html604/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Tue Jun 30 14:34:34 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvPdf.html:49143,clear,clearConvolutionWindow,49143,root/html602/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html602/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctor. Double_t evaluate() const; Calculate and return value of p.d.f. void initialize() const; One-time initialization of object. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return appropriate generator context for this convolved p.d.f. If both pdf and resolution; model support internal generation return and optimization convolution generation context; that uses a smearing algorithm. Otherwise return a standard accept/reject sampling; context on the convoluted shape. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooNumConvPdf(*this,newname) ; }. RooNumIntConfig& convIntConfig(); Calls forwarded to RooNumConvolution. { return conv().convIntConfig() ; }. void clearConvolutionWindow(); { conv().clearConvolutionWindow() ; }. void setConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); { conv().setConvolutionWindow(centerParam,widthParam,widthScaleFactor) ; }. void setCallWarning(Int_t threshold = 2000); { conv().setCallWarning(threshold) ; }. void setCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); { conv().setCallProfiling(flag,nbinX,nbinCall,nCallHigh) ; }. const TH2* profileData() const; { return conv().profileData() ; }. RooRealVar& var() const; Access components. { return (RooRealVar&)(const_cast<RooAbsReal&>(_origVar.arg())) ; }. RooAbsReal& pdf() const; { return const_cast<RooAbsReal&>(_origPdf.arg()) ; }. RooAbsReal& model() const; { return const_cast<RooAbsReal&>(_origModel.arg()) ; }. RooNumConvolution& conv() const; WVE Store all properties of RooNumConvolution here so that can be take; along in the copy ctor. { if (!_init) initialize() ; return *_conv ; }. » Last changed: Tue Mar 10 17:18:13 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:47481,clear,clearConvolutionWindow,47481,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ctrum2Fit Spectrum2 Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrum2Painter TSpectrum 3d graphics package; TSpectrum2Transform Spectrum2 Transformer, it calculates classic orthogonal 2D transforms; TSpectrum3 Peak Finder, Background estimator, Markov smoothing and Deconvolution for 3-D histograms; TSpectrumFit Spectrum Fitter using algorithm without matrix inversion and conjugate gradient method for symmetrical matrices (Stiefel-Hestens method); TSpectrumTransform Spectrum Transformer, it calculates classic orthogonal 1D transforms; TSpider Helper class to draw spider; TSpiderEditor GUI for editing the spider plot attributes.; TSpline Spline base class; TSpline3 Class to create third natural splines; TSpline5 Class to create quintic natural splines; TSplinePoly Spline polynomial terms; TSplinePoly3 Third spline polynomial terms; TSplinePoly5 Quintic spline polynomial terms; TStatistic Named statistical variable; TStatsFeedback Present PROOF query feedback; TStatus Status class; TStdExceptionHandler C++ exception handler; TStopwatch A stopwatch which times real and cpu time; TStorage Storage manager class; TStreamerArtificial StreamerElement injected by a TSchemaRule. Transient only to preverse forward compatibility.; TStreamerBase Streamer element of type base class; TStreamerBasicPointer Streamer element for a pointer to a basic type; TStreamerBasicType Streamer element for a basic type; TStreamerElement Base class for one element (data member) to be Streamed; TStreamerInfo Streamer information for one class version; TStreamerInfoActions ; TStreamerInfoActions::TActionSequence ; TStreamerInfoActions::TConfiguration ; TStreamerInfoActions::TConfiguredAction A configured action; TStreamerLoop Streamer element for a pointer to an array of objects; TStreamerObject Streamer element of type object; TStreamerObjectAny Streamer element of type object other than TObject; TStreamerObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:133144,feedback,feedback,133144,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,3,['feedback'],['feedback']
Usability,"cts to; 365// automatize memory management and not introduce even more preprocessor; 366// branching for deletion at the end of the method.; 367//; 368// FUTURE IMPROVEMENT ONCE OLD PYTHON VERSIONS ARE NOT SUPPORTED BY CPPYY:; 369// Right now we use C++ objects to automatize memory management. One could use; 370// RAAI and the Python memory allocation API (PEP 445) once some old Python; 371// version is deprecated in CPPYY. That new feature is available since version; 372// 3.4 and the preprocessor branching to also support that would be so; 373// complicated to make the code unreadable.; 374 std::vector<std::wstring> argv2;; 375 argv2.reserve(argc);; 376 argv2.emplace_back(name.c_str(), &name[name.size()]);; 377 ; 378 for (int i = 1; i < argc; ++i) {; 379 auto iarg = args[i - 1].c_str();; 380 argv2.emplace_back(iarg, &iarg[strlen(iarg)]);; 381 }; 382 ; 383#if PY_VERSION_HEX < 0x03080000; 384// Before version 3.8, the code is one simple line; 385 wchar_t *argv2_arr[argc];; 386 for (int i = 0; i < argc; ++i) {; 387 argv2_arr[i] = const_cast<wchar_t *>(argv2[i].c_str());; 388 }; 389 PySys_SetArgv(argc, argv2_arr);; 390 ; 391#else; 392// Here we comply to ""PEP 587 – Python Initialization Configuration"" to avoid; 393// deprecation warnings at compile time.; 394 class PyConfigHelperRAAI {; 395 public:; 396 PyConfigHelperRAAI(const std::vector<std::wstring> &argv2); 397 {; 398 PyConfig_InitPythonConfig(&fConfig);; 399 fConfig.parse_argv = 1;; 400 UpdateArgv(argv2);; 401 InitFromConfig();; 402 }; 403 ~PyConfigHelperRAAI() { PyConfig_Clear(&fConfig); }; 404 ; 405 private:; 406 void InitFromConfig() { Py_InitializeFromConfig(&fConfig); };; 407 void UpdateArgv(const std::vector<std::wstring> &argv2); 408 {; 409 auto WideStringListAppendHelper = [](PyWideStringList *wslist, const wchar_t *wcstr) {; 410 PyStatus append_status = PyWideStringList_Append(wslist, wcstr);; 411 if (PyStatus_IsError(append_status)) {; 412 std::wcerr << ""Error: could not append element "" << wcstr << "" t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/API_8cxx_source.html:13320,simpl,simple,13320,doc/master/API_8cxx_source.html,https://root.cern,https://root.cern/doc/master/API_8cxx_source.html,1,['simpl'],['simple']
Usability,"cts/subfolder/obj/root.json.gz; If the access to the server is restricted with htdigest, it is recommended to use the curl program since only curl correctly implements such authentication method. The command will look like:; [shell] curl --user ""accout:password"" http://localhost:8080/Objects/subfolder/obj/root.json --digest -o root.json; 1.9.1 Objects data access in JSON format; Request root.json implemented with TBufferJSON class. TBufferJSON generates such object representation, which could be directly used in JSROOT for drawing. root.json request returns either complete object or just object member like:; [shell] wget http://localhost:8080/Objects/subfolder/obj/fTitle/root.json; The result will be: ""title"".; For the root.json request one could specify the ‘compact’ parameter, which allow to reduce the number of spaces and new lines without data lost. This parameter can have values from ‘0’ (no compression) till ‘3’ (no spaces and new lines at all). In addition, one can use simple compression algorithm for big arrays. If compact=‘10’, zero values in the begin and at the end of the array will be excluded. If compact=‘20’, similar values or large zero gaps in-between will be compressed. Such array compression support in JSROOT from version 4.8.2.; Usage of root.json request is about as efficient as binary root.bin request. Comparison of different request methods with TH2 histogram from hsimple.C shown in the table:. Request; Size. root.bin; 7672 bytes. root.bin.gz; 1582 bytes. root.json; 8570 bytes. root.json?compact=3; 6004 bytes. root.json?compact=23; 5216 bytes. root.json.gz?compact=23; 1855 bytes. One should remember that JSON representation always includes names of the data fields which are not present in the binary representation. Even then the size difference is negligible.; root.json used in JSROOT to request objects from THttpServer.; 1.9.2 Generating images out of objects; For the ROOT classes which are implementing Draw method (like TH1 or TGraph) one cou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html:15879,simpl,simple,15879,root/htmldoc/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html,1,['simpl'],['simple']
Usability,"cular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3701,learn,learning,3701,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"culation is skipped if err==0; 198 virtual Double_t GetMvaValue( Double_t* errLower = nullptr, Double_t* errUpper = nullptr) = 0;; 199 ; 200 // signal/background classification response; 201 Double_t GetMvaValue( const TMVA::Event* const ev, Double_t* err = nullptr, Double_t* errUpper = nullptr );; 202 ; 203 protected:; 204 // helper function to set errors to -1; 205 void NoErrorCalc(Double_t* const err, Double_t* const errUpper);; 206 ; 207 // signal/background classification response for all current set of data; 208 virtual std::vector<Double_t> GetMvaValues(Long64_t firstEvt = 0, Long64_t lastEvt = -1, Bool_t logProgress = false);; 209 // same as above but using a provided data set (used by MethodCategory); 210 virtual std::vector<Double_t> GetDataMvaValues(DataSet *data = nullptr, Long64_t firstEvt = 0, Long64_t lastEvt = -1, Bool_t logProgress = false);; 211 ; 212 public:; 213 // regression response; 214 const std::vector<Float_t>& GetRegressionValues(const TMVA::Event* const ev){; 215 fTmpEvent = ev;; 216 const std::vector<Float_t>* ptr = &GetRegressionValues();; 217 fTmpEvent = nullptr;; 218 return (*ptr);; 219 }; 220 ; 221 virtual const std::vector<Float_t>& GetRegressionValues() {; 222 std::vector<Float_t>* ptr = new std::vector<Float_t>(0);; 223 return (*ptr);; 224 }; 225 ; 226 // multiclass classification response; 227 virtual const std::vector<Float_t>& GetMulticlassValues() {; 228 std::vector<Float_t>* ptr = new std::vector<Float_t>(0);; 229 return (*ptr);; 230 }; 231 ; 232 // Training history; 233 virtual const std::vector<Float_t>& GetTrainingHistory(const char* /*name*/ ) {; 234 std::vector<Float_t>* ptr = new std::vector<Float_t>(0);; 235 return (*ptr);; 236 }; 237 ; 238 // probability of classifier response (mvaval) to be signal (requires ""CreateMvaPdf"" option set); 239 virtual Double_t GetProba( const Event *ev); // the simple one, automatically calculates the mvaVal and uses the SAME sig/bkg ratio as given in the training sample (typically 50/50 .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:8832,simpl,simple,8832,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['simpl'],['simple']
Usability,"cutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TExecutorCRTP::Mapauto Map(F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >Execute a function without arguments several times.Definition TExecutorCRTP.hxx:185; ROOT::TExecutorCRTP::ReduceT * Reduce(const std::vector< T * > &mergeObjs)""Reduce"" an std::vector into a single object by using the object's Merge method.Definition TExecutorCRTP.hxx:347; ROOT::TProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel,...Definition TProcessExecutor.hxx:37; ROOT::TProcessExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TProcessExecutor.hxx:262; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TThreadExecutor.hxx:482; v@ vDefinition rootcling_impl.cxx:3687; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. Definition at line 103 of file TExecutorCRTP.hxx. Public Member Functions;  TExecutorCRTP ()=default;  ;  TExecutorCRTP (const TExecutorCRTP &)=delete;  ; template<class F , class T , class Cond = validMapReturnCond<F, T>> ; auto Map (F func, const std::vector< T > &args) -> std::vector< InvokeResult_t< F, T > >;  Execute a function over the elements of an immutable vector. ;  ; template<class F , class INTEGER , class Cond = validMapReturnCond<F, INTEGER>> ; auto Map (F func, ROOT::TSeq< INTEGER > args) -> std::vector< InvokeResult_t< F, INTEGER >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TExecutorCRTP.html:4201,simpl,simple,4201,doc/v632/classROOT_1_1TExecutorCRTP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TExecutorCRTP.html,1,['simpl'],['simple']
Usability,"cutor pool; auto hist = pool.MapReduce(CreateAndFillHists, 10, PoolUtils::ReduceObjects);; ROOT::ExecutorUtils::ReduceObjectsMerge collection of TObjects.Definition PoolUtils.h:35; ROOT::TExecutorCRTP::Mapauto Map(F func, unsigned nTimes) -> std::vector< InvokeResult_t< F > >Execute a function without arguments several times.Definition TExecutorCRTP.hxx:185; ROOT::TExecutorCRTP::ReduceT * Reduce(const std::vector< T * > &mergeObjs)""Reduce"" an std::vector into a single object by using the object's Merge method.Definition TExecutorCRTP.hxx:347; ROOT::TProcessExecutorThis class provides a simple interface to execute the same task multiple times in parallel,...Definition TProcessExecutor.hxx:37; ROOT::TProcessExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TProcessExecutor.hxx:262; ROOT::TThreadExecutorThis class provides a simple interface to execute the same task multiple times in parallel threads,...Definition TThreadExecutor.hxx:41; ROOT::TThreadExecutor::MapReduceauto MapReduce(F func, unsigned nTimes, R redfunc) -> InvokeResult_t< F >Execute a function nTimes in parallel (Map) and accumulate the results into a single value (Reduce).Definition TThreadExecutor.hxx:482; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345. Definition at line 103 of file TExecutorCRTP.hxx. Public Member Functions;  TExecutorCRTP ()=default;  ;  TExecutorCRTP (const TExecutorCRTP &)=delete;  ; template<class F , class T , class Cond = validMapReturnCond<F, T>> ; auto Map (F func, const std::vector< T > &args) -> std::vector< InvokeResult_t< F, T > >;  Execute a function over the elements of an immutable vector. ;  ; template<class F , class INTEGER , class Cond = validMapReturnCond<F, INTEGER>> ; auto Map (F func, ROOT::TSeq< INTEGER > args) -> std::vector< InvokeResult_t< F, INTEGER >",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TExecutorCRTP.html:4202,simpl,simple,4202,doc/master/classROOT_1_1TExecutorCRTP.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TExecutorCRTP.html,1,['simpl'],['simple']
Usability,"cxx. ◆ getAnalyticalIntegral(). Int_t RooPolyVar::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Advertise that we can internally integrate over x. ; Reimplemented from RooAbsReal.; Definition at line 168 of file RooPolyVar.cxx. ◆ IsA(). TClass * RooPolyVar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 62 of file RooPolyVar.h. ◆ Streamer(). void RooPolyVar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooPolyVar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 62 of file RooPolyVar.h. ◆ translate(). void RooPolyVar::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 115 of file RooPolyVar.cxx. Friends And Related Symbol Documentation. ◆ RooPolynomial. friend class RooPolynomial. friend . Definition at line 55 of file RooPolyVar.h. Member Data Documentation. ◆ _coefList. RooListProxy RooPolyVar::_coefList. protected . Definition at line 43 of file RooPolyVar.h. ◆ _lowestOrder. Int_t RooPolyVar::_lowestOrder = 0. protected . Definition at line 44 of file RooPolyVar.h. ◆ _wksp. std::vector<d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooPolyVar.html:65154,simpl,simple,65154,doc/master/classRooPolyVar.html,https://root.cern,https://root.cern/doc/master/classRooPolyVar.html,1,['simpl'],['simple']
Usability,"d ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnew",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172611,learn,learn,172611,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"d Initialize()Initialize the weights and biases according to the given initialization method.Definition GeneralLayer.h:395; TMVA::DNN::VGeneralLayer::GetBiasesAtMatrix_t & GetBiasesAt(size_t i)Definition GeneralLayer.h:182; TMVA::DNN::VGeneralLayer::SetInputHeightvoid SetInputHeight(size_t inputHeight)Definition GeneralLayer.h:219; TMVA::DNN::VGeneralLayer::fBiasGradientsstd::vector< Matrix_t > fBiasGradientsGradients w.r.t. the bias values of the layer.Definition GeneralLayer.h:75; TMVA::DNN::VGeneralLayer::SetDepthvoid SetDepth(size_t depth)Definition GeneralLayer.h:221; TMVA::DNN::VGeneralLayer::SetExtraLayerParametersvirtual void SetExtraLayerParameters(const std::vector< Matrix_t > &)Definition GeneralLayer.h:212; TMVA::DNN::VGeneralLayer::ReadWeightsFromXMLvirtual void ReadWeightsFromXML(void *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:29384,learn,learningRate,29384,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"d Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::LogInterval Interval definition, continous and discrete; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach); TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodInfo ; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach""); TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ClassIndex.html:102814,simpl,simple,102814,root/html604/ClassIndex.html,https://root.cern,https://root.cern/root/html604/ClassIndex.html,1,['simpl'],['simple']
Usability,"d Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::LogInterval Interval definition, continous and discrete; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach); TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach""); TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::Optimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:102158,simpl,simple,102158,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['simpl'],['simple']
Usability,"d Members; Includes; Libraries. Function documentation; TEveTrack(); Default constructor. TEveTrack(TParticle* t, Int_t label, TEveTrackPropagator* prop = 0); Constructor from TParticle. TEveTrack(TEveMCTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveUtil Monte Carlo track. TEveTrack(TEveRecTrack* t, TEveTrackPropagator* prop = 0); Constructor from TEveUtil reconstructed track. TEveTrack(const TEveTrack& t); Copy constructor. Track paremeters are copied but the; extrapolation is not perfermed so you should still call; MakeTrack() to do that.; If points of 't' are locked, they are cloned. ~TEveTrack(); Destructor. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Returns list-tree icon for TEveTrack. void ComputeBBox(); Compute the bounding box of the track. void SetStdTitle(); Set standard track title based on most data-member values. void SetTrackParams(const TEveTrack& t); Copy track parameters from t. Track-propagator is set, too.; PathMarks are cleared - you can copy them via SetPathMarks(t).; If track 't' is locked, you should probably clone its points; over - use TEvePointSet::ClonePoints(t);. void SetPathMarks(const TEveTrack& t); Copy path-marks from t. void SetPropagator(TEveTrackPropagator* prop); Set track's render style.; Reference counts of old and new propagator are updated. void SetAttLineAttMarker(TEveTrackList* tl); Set line and marker attributes from TEveTrackList. void MakeTrack(Bool_t recurse = kTRUE); Calculate track representation based on track data and current; settings of the propagator.; If recurse is true, descend into children. void CopyVizParams(const TEveElement* el); Copy visualization parameters from element el. void WriteVizParams(ostream& out, const TString& var); Write visualization parameters. TClass* ProjectedClass(const TEveProjection* p) const; Virtual from TEveProjectable, return TEveTrackProjected class. void SortPathMarksByTime(); Sort registerd pat-marks by time. void PrintPathMarks(); Print registered ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTrack.html:30606,clear,cleared,30606,root/html528/TEveTrack.html,https://root.cern,https://root.cern/root/html528/TEveTrack.html,1,['clear'],['cleared']
Usability,"d SetDelta(Double_t delta); Sets Delta - used in stochastic minimisation; (look at the constructor for the complete description; of learning methods and parameters). void SetEtaDecay(Double_t ed); Sets EtaDecay - Eta *= EtaDecay at each epoch; (look at the constructor for the complete description; of learning methods and parameters). void SetTau(Double_t tau); Sets Tau - used in line search; (look at the constructor for the complete description; of learning methods and parameters). void SetReset(Int_t reset); Sets number of epochs between two resets of the; search direction to the steepest descent.; (look at the constructor for the complete description; of learning methods and parameters). void GetEntry(Int_t ) const; Load an entry into the network. void Train(Int_t nEpoch, Option_t* option = ""text"", Double_t minE = 0); Train the network.; nEpoch is the number of iterations.; option can contain:; - ""text"" (simple text output); - ""graph"" (evoluting graphical training curves); - ""update=X"" (step for the text/graph output update); - ""+"" will skip the randomisation and start from the previous values.; - ""current"" (draw in the current canvas); - ""minErrorTrain"" (stop when NN error on the training sample gets below minE; - ""minErrorTest"" (stop when NN error on the test sample gets below minE; All combinations are available. Double_t Result(Int_t event, Int_t index = 0) const; Computes the output for a given event.; Look at the output neuron designed by index. Double_t GetError(Int_t event) const; Error on the output for a given event. Double_t GetError(TMultiLayerPerceptron::EDataSet set) const; Error on the whole dataset. Double_t GetSumSquareError() const; Error on the output for a given event. Double_t GetCrossEntropyBinary() const; Cross entropy error for sigmoid output neurons, for a given event. Double_t GetCrossEntropy() const; Cross entropy error for a softmax output neuron, for a given event. void ComputeDEDw() const; Compute the DEDw = sum on all training events",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:24900,simpl,simple,24900,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['simpl'],['simple']
Usability,"d UpdateOffset(); Updates start text offset according GetAlignment() mode,; if cursor is out of frame => scroll the text.; See also SetAlignment() and ScrollByChar(). void SetToolTipText(const char* text, Long_t delayms = 500); Set tool tip text associated with this text entry. The delay is in; milliseconds (minimum 250). To remove tool tip call method with; text = 0. void SetFocus(); Set focus to this text entry. void InsertText(const char* text, Int_t pos); Inserts text at position pos, clears the selection and moves; the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(), SetText(), AppendText(), RemoveText(). void AppendText(const char* text); Appends text to the end of text entry, clears the selection; and moves the cursor to the end of the line.; If necessary the text is truncated to fit MaxLength().; See also GetText(), InsertText(), SetText(), RemoveText(). void RemoveText(Int_t start, Int_t end); Removes text at the range, clears the selection and moves; the cursor to the end of the line.; See also GetText(), InsertText(), SetText(), AppendText(). void SetFont(FontStruct_t font, Bool_t local = kTRUE); Changes text font.; If local is kTRUE font is changed locally. void SetFont(const char* fontName, Bool_t local = kTRUE); Changes text font specified by name.; If local is kTRUE font is changed locally. void SetFont(TGFont* font, Bool_t local = kTRUE); Changes text font specified by pointer to TGFont object.; If local is kTRUE font is changed locally. void SetTextColor(Pixel_t color, Bool_t local = kTRUE); Changes text color.; If local is true color is changed locally. void SetTextColor(TColor* color, Bool_t local = kTRUE); Changes text color.; If local is true color is changed locally. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context. const TGGC & GetDefaultSelectedGC(); Return selection graphics context. const TGGC & Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEntry.html:37288,clear,clears,37288,root/html528/TGTextEntry.html,https://root.cern,https://root.cern/root/html528/TGTextEntry.html,6,['clear'],['clears']
Usability,"d a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage * LoadImage(const char* uri, int w = 0, int h = 0); User function to get an image from a URL. int Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:38585,clear,clear,38585,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,4,['clear'],['clear']
Usability,"d a color integer for the color whose color components; are given by pRef. const char * GetHref(int x, int y, const char** target = 0); This routine searchs for a hyperlink beneath the coordinates x,y; and returns a pointer to the HREF for that hyperlink. The text; is held in one of the markup argv[] fields of the <a> markup. int ElementCoords(TGHtmlElement* p, int i, int pct, int* coords); Return coordinates of item. TGHtmlElement * AttrElem(const char* name, char* value); Returns html element matching attribute name and value. void UpdateSelection(int forceUpdate); Given the selection end-points in fSelBegin and fSelEnd, recompute; pSelBeginBlock and fPSelEndBlock, then call UpdateSelectionDisplay(); to update the display. This routine should be called whenever the selection changes or; whenever the set of TGHtmlBlock structures change. void UpdateSelectionDisplay(); The fPSelStartBlock and fPSelEndBlock values have been changed.; This routine's job is to loop over all TGHtmlBlocks and either; set or clear the HTML_Selected bits in the .fFlags field; as appropriate. For every TGHtmlBlock where the bit changes,; mark that block for redrawing. void LostSelection(); Clear selection. int SelectionSet(const char* startIx, const char* endIx); Set selection. void UpdateInsert(); Recompute the position of the insertion cursor based on the; position in fIns. int SetInsert(const char* insIx); Set the position of the insertion cursor. void SavePrimitive(ostream& out, Option_t* = """"); Save a html widget as a C++ statement(s) on output stream out. TGHtmlTextElement & operator=(const TGHtml& ). TGHtml(const TGWindow* p, int w, int h, int id = -1). Bool_t ProcessMessage(Long_t , Long_t , Long_t ). int GetTableRelief() const; { return fTableRelief; }. int GetRuleRelief() const; { return fRuleRelief; }. int GetRulePadding() const; { return fRulePadding; }. const char * GetBaseUri() const; { return fZBase; }. char * ResolveUri(const char* uri); User function to resolve URIs. TImage",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHtml.html:39770,clear,clear,39770,root/html602/TGHtml.html,https://root.cern,https://root.cern/root/html602/TGHtml.html,2,['clear'],['clear']
Usability,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented from TObject.; Definition at line 69 of file TBuffer.h. ◆ Write() [2/2]. Int_t TBuffer::Write ; (; const char * ; name, . Int_t ; option, . Int_t ; bufsize .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:58911,simpl,simply,58911,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['simpl'],['simply']
Usability,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented from TObject.; Reimplemented in TSQLFile, TXMLFile, TFile, TParallelMergingFile, and TDirectoryFile.; Definition at line 265 of file TDirectory.h. ◆ Write() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:52375,simpl,simply,52375,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['simpl'],['simply']
Usability,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 858 of file TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:119209,simpl,simply,119209,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['simpl'],['simply']
Usability,"d buffer is created to hold the compressed buffer.; Reservation of the corresponding space in the file by looking in the TFree list of free blocks of the file.; The buffer is written to the file. Bufsize can be given to force a given buffer size to write this object. By default, the buffersize will be taken from the average buffer size of all objects written to the current file so far.; If a name is specified, it will be the name of the key. If name is not given, the name of the key will be the name as returned by GetName().; The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete Using the kOverwrite option a previous key with the same name is overwritten. The previous key is deleted before writing the new object. Using the kWriteDelete option a previous key with the same name is deleted only after the new object has been written. This option is safer than kOverwrite but it is slower. NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile– the space is simply freed up to be overwritten; in the case of a TTree, it is more complicated. If one opens a TTree, appends some entries, then writes it out, the behaviour is effectively the same. If, however, one creates a new TTree and writes it out in this way, only the metadata is replaced, effectively making the old data invisible without deleting it. TTree::Delete() can be used to mark all disk space occupied by a TTree as free before overwriting its metadata this way. The kSingleKey option is only used by TCollection::Write() to write a container with a single key instead of each object in the container with its own key.; An object is read from the file into memory via TKey::Read() or via TObject::Read().; The function returns the total number of bytes written to the file. It returns 0 if the object cannot be written. ; Reimplemented in TSQLFile, TXMLFile, TDirectory, TBuffer, TFile, TParallelMergingFile, TDirectoryFile, TCollection, TMap, and TTree.; Definition at line 864 of file TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:118210,simpl,simply,118210,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['simpl'],['simply']
Usability,"d by a warning message isued by M when running into troubles. Problems can be:. a bug in M; an error in the \(\mbox{FCN}\); a highly difficult problem (usually strong correlations among parameters); floating–point precision. 4.5 The output from minimization; 4.5.1 The FunctionMinimum; The output of the minimizers is the FunctionMinimum. The FunctionMinimum contains the result of the minimization in both internal parameter representation and external parameter representation.; 4.5.2 User representable format: MnUserParameterState; On request, the result of the minimzation is transformed into a user representable format for parameters and errors, the MnUserParameterState.; 4.5.3 Access values, errors, covariance; The result can be accessed via methods like MnUserParameterState::value(unsigned int n) and MnUserParameterState::error(unsigned int n), where \(n\) is the index of the parameter in the list of parameters defined by the user.; 4.5.4 Printout of the result; The FunctionMinimum can be printed on the output simply via std::cout. It will print both the internal and external state, that is parameters, errors and the covariance matrix (if available). It also tells the user if M did converge or not by issueing an appropriate message. If a covariance matrix is available, the global correlation coefficients are printed as well.; 4.5.5 Global correlation coefficients; The global correlation coefficient for parameter \(n\) is a number between zero and one which gives the correlation between parameter \(n\) and that linear combination of all other parameters which is most strongly correlated with \(n\).; 5 M application programming interface (API); [api:api]; 5.1 FunctionMinimum; [api:fm] The FunctionMinimum is the output of the minimizers and contains the minimzation result. The state at the minimum is available both in internal and external representations. For the external representations the return methods. FunctionMinimum::userState(),; FunctionMinimum::userParamete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:41607,simpl,simply,41607,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,1,['simpl'],['simply']
Usability,"d cloning of p.d.f. into a simultaneous p.d.f; RooSimWSTool::BuildConfig Build configuration object for RooSimWSTool; RooSimWSTool::MultiBuildConfig Build configuration object for RooSimWSTool with multiple prototype p.d.f.; RooSimWSTool::ObjBuildConfig Validated RooSimWSTool build configuration; RooSimWSTool::ObjSplitRule Validated RooSimWSTool split rule; RooSimWSTool::SplitRule Split rule specification for prototype p.d.f; RooSimultaneous Simultaneous operator p.d.f, functions like C++ 'switch()' on input p.d.fs operating on index category5A; RooStats ; RooStats::AcceptanceRegion A simple class for acceptance regions used for ConfidenceBelt; RooStats::BernsteinCorrection A utility to add polynomial corrrection terms to a model to improve the description of data.; RooStats::CombinedCalculator A base class that is for tools that can be both HypoTestCalculators and IntervalCalculators; RooStats::ConfInterval Interface for Confidence Intervals; RooStats::ConfidenceBelt A confidence belt for the Neyman Construction; RooStats::DebuggingSampler A simple implementation of the DistributionCreator interface; RooStats::DebuggingTestStat A concrete implementation of the TestStatistic interface, useful for debugging.; RooStats::FeldmanCousins Interface for tools setting limits (producing confidence intervals); RooStats::HybridCalculator Hypothesis test calculator using a Bayesian-frequentist hybrid method; RooStats::HybridPlot Provides the plots for an HybridResult; RooStats::HybridResult Class containing the results of the HybridCalculator; RooStats::HypoTestCalculator Interface for tools doing hypothesis tests; RooStats::HypoTestResult Base class to represent results of a hypothesis test; RooStats::IntervalCalculator Interface for tools setting limits (producing confidence intervals); RooStats::LikelihoodInterval Concrete implementation of a ConfInterval based on a likelihood ratio; RooStats::LikelihoodIntervalPlot Class containing the results of the IntervalCalculator; RooS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:42028,simpl,simple,42028,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,1,['simpl'],['simple']
Usability,"d controlled by the user or admin who can also force saving in all cases; parameter PROOF_SavePartialResults or RC env ProofPlayer.SavePartialResults . However, if 'force' is kTRUE, fSavePartialResults and fSaveResultsPerPacket are ignored. Return -1 in case of problems, 0 otherwise. ; Implements TVirtualProofPlayer.; Definition at line 780 of file TProofPlayer.cxx. ◆ SetCurrentQuery(). void TProofPlayer::SetCurrentQuery ; (; TQueryResult * ; q). overridevirtual . Set current query and save previous value. ; Implements TVirtualProofPlayer.; Definition at line 451 of file TProofPlayer.cxx. ◆ SetDispatchTimer(). void TProofPlayer::SetDispatchTimer ; (; Bool_t ; on = kTRUE). overridevirtual . Enable/disable the timer to dispatch pening events while processing. ; Implements TVirtualProofPlayer.; Definition at line 309 of file TProofPlayer.cxx. ◆ SetDrawFeedbackOption(). void TProofPlayer::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). overridevirtual . Set draw feedback option. ; Implements TVirtualProofPlayer.; Definition at line 741 of file TProofPlayer.cxx. ◆ SetExitStatus(). void TProofPlayer::SetExitStatus ; (; EExitStatus ; st). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 204 of file TProofPlayer.h. ◆ SetInitTime(). void TProofPlayer::SetInitTime ; (; ). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 213 of file TProofPlayer.h. ◆ SetMaxDrawQueries(). void TProofPlayer::SetMaxDrawQueries ; (; Int_t ; max). inlineoverridevirtual . Implements TVirtualProofPlayer.; Definition at line 168 of file TProofPlayer.h. ◆ SetMerging(). void TProofPlayer::SetMerging ; (; Bool_t ; = kTRUE). inlineoverridevirtual . Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 215 of file TProofPlayer.h. ◆ SetOutputFilePath(). void TProofPlayer::SetOutputFilePath ; (; const char * ; fp). inlineoverridevirtual . Implements TVirtualP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:40382,feedback,feedback,40382,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"d drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableInterface *iface = new TGSimpleTableInterface(data, 6, 5); . // Create the table; TGTable *table = new TGTable(mainframe, 999, iface); . // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));. //Update data; data[5][1] = 3.01; ; //update the table view; table->Update(); . // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainfr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTable.html:1497,simpl,simple,1497,root/html528/TGTable.html,https://root.cern,https://root.cern/root/html528/TGTable.html,6,['simpl'],['simple']
Usability,"d in 'url' on remote 'port' as 'user'. url: [[proto][p][auth]://]host[/?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd); [auth] = ""up"", ""s"", ""k"", ""g"", ""h"", ""ug"" to force UsrPwd,; SRP, Krb5, Globus, SSH or UidGid authentication; [options] = ""m"" or ""s"", when proto=proofd indicates whether; we are master or slave (used internally by TSlave). An already opened connection can be used by passing its socket; in opensock. If 'err' is defined, '*err' on return from a failed call contains an error; code (see NetErrors.h). Example:. TSocket::CreateAuthSocket(""qwerty"",""rootdps://machine.fq.dn"",5051). creates an authenticated socket to a rootd server running; on remote machine machine.fq.dn on port 5051; ""parallel""; sockets are forced internally because rootd expects; parallel sockets; however a simple socket will be created; in this case because the size is 0 (the default);; authentication will attempt protocol SRP first. TSocket::CreateAuthSocket(""qwerty"",""pk://machine.fq.dn:5052"",3). creates an authenticated parallel socket of size 3 to a sockd; server running on remote machine machine.fq.dn on port 5052;; authentication will attempt protocol Kerberos first. NB: may hang if the remote server is not of the correct type;; at present TSocket has no way to find out the type of the; remote server automatically. Returns pointer to an authenticated socket or 0 if creation or; authentication is unsuccessful. Int_t GetClientProtocol(); Static method returning supported client protocol. void NetError(const char* where, Int_t error); Print error string depending on error code. ULong64_t GetSocketBytesSent(); Get total number of bytes sent via all sockets. ULong64_t GetSocketBytesRecv(); Get total number of bytes received via all sockets. Int_t GetCompressionAlgorithm() const. Int_t GetCompressi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:23869,simpl,simple,23869,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,5,['simpl'],['simple']
Usability,"d in grayscale, and re-paint it if necessary.Definition TCanvas.cxx:2576; TCanvas::SetTitlevoid SetTitle(const char *title="""") overrideSet canvas title.Definition TCanvas.cxx:2155; TCanvas::fChUInt_t fChHeight of the canvas along Y (pixels)Definition TCanvas.h:44; TCanvas::GetDISPLAYconst char * GetDISPLAY() constDefinition TCanvas.h:132; TCanvas::fContextMenuTContextMenu * fContextMenu! Context menu pointerDefinition TCanvas.h:58; TCanvas::GetCanvasIDInt_t GetCanvasID() const overrideDefinition TCanvas.h:157; TCanvas::fCattTAttCanvas fCattCanvas attributes.Definition TCanvas.h:31; TCanvas::SetNamevoid SetName(const char *name="""") overrideSet canvas name.Definition TCanvas.cxx:2047; TCanvas::GetWindowWidthUInt_t GetWindowWidth() constDefinition TCanvas.h:161; TCanvas::fRetainedBool_t fRetainedRetain structure flag.Definition TCanvas.h:61; TCanvas::DisconnectWidgetvoid DisconnectWidget()Used by friend class TCanvasImp.Definition TCanvas.cxx:2558; TCanvas::FeedbackModevoid FeedbackMode(Bool_t set)Turn rubberband feedback mode on or off.Definition TCanvas.cxx:1128; TCanvas::GetYsizeUserSize_t GetYsizeUser() constDefinition TCanvas.h:154; TCanvas::GetSelectedYInt_t GetSelectedY() constDefinition TCanvas.h:144; TCanvas::lsvoid ls(Option_t *option="""") const overrideList all pads.Definition TCanvas.cxx:1504; TCanvas::RaiseWindowvoid RaiseWindow()Raise canvas window.Definition TCanvas.cxx:1744; TCanvas::Buildvoid Build()Build a canvas. Called by all constructors.Definition TCanvas.cxx:587; TCanvas::SaveAllstatic Bool_t SaveAll(const std::vector< TPad * > &={}, const char *filename="""", Option_t *option="""")Save provided pads/canvases into the image file(s) Filename can include printf argument for image num...Definition TCanvas.cxx:2654; TCanvas::GetSelectedXInt_t GetSelectedX() constDefinition TCanvas.h:143; TCanvas::fWindowTopYInt_t fWindowTopYTop Y position of window (in pixels)Definition TCanvas.h:40; TCanvas::Paintvoid Paint(Option_t *option="""") overridePaint canvas.Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8h_source.html:25478,feedback,feedback,25478,doc/master/TCanvas_8h_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html,1,['feedback'],['feedback']
Usability,"d of being spread across the file. However it might; decrease the performance when reading more branches (or the full; entry). When using SortBasketsByEntry the baskets with the lowest; starting entry are written first. (i.e. the baskets are; sorted on the index/number of the first entry they contain).; This means that on the file the baskets will be in the order; in which they will be needed when reading the whole tree; sequentially. For examples of CloneTree, see tutorials:. -- copytree. A macro to copy a subset of a TTree to a new TTree. The input file has been generated by the program in $ROOTSYS/test/Event; with: Event 1000 1 1 1. -- copytree2. A macro to copy a subset of a TTree to a new TTree. One branch of the new Tree is written to a separate file. The input file has been generated by the program in $ROOTSYS/test/Event; with: Event 1000 1 1 1. void CopyAddresses(TTree* , Bool_t undo = kFALSE); Set branch addresses of passed tree equal to ours.; If undo is true, reset the branch address instead of copying them.; This insures 'separation' of a cloned tree from its original. Long64_t CopyEntries(TTree* tree, Long64_t nentries = -1, Option_t* option = """"); Copy nentries from given tree to this tree.; This routines assumes that the branches that intended to be copied are; already connected. The typical case is that this tree was created using; tree->CloneTree(0). By default copy all entries. Returns number of bytes copied to this tree. If 'option' contains the word 'fast' and nentries is -1, the cloning will be; done without unzipping or unstreaming the baskets (i.e., a direct copy of the; raw bytes on disk). When 'fast' is specified, 'option' can also contains a sorting order for the; baskets in the output file. There are currently 3 supported sorting order:; SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry. See TTree::CloneTree for a detailed explanation of the semantics of these 3 options. If the tree or any of the underlying tree of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:58225,undo,undo,58225,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['undo'],['undo']
Usability,"d of inheritence, etc. But also, notice that you have to run an Init function. Why? That is specifically what the constructor is for. Why does everything in ROOT know how to draw itself? Why does everything in ROOT have 100 methods, for ""quick access"" to other objects that do the actual work of those methods? These are questions that should be asked. But most of all, if you aren't going to fix these problems, why bother migrating at all? You fail to treat this migration as what it actually is. You are migrating to a new language, not a new version of a language. ROOT isn't written in C++. It's written in CINT. I am just frustrated to see this happen, because I know this community can do better. Maybe I'll make a draft of some smaller changes that need to be made and submit them to the mailing list. But honestly, I'm not very hopeful about this migration. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Re: Why? . Hi Matt!; Thanks for your feedback; I'll tried to reply to each of your comments one by one. I do not disagree with all of your comments, but I might have explanations for some of them :-) Sometimes you seem to misinterpret ""backward compatibility"" (which means ""what used to work will continue to work"") with ""no change"" - but that might just have been your motivation to take the time for writing your feedback, so I don't complain :-) Given the relevance of your comments I decided to reply in a separate blog post.; Cheers, Axel. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Thank you for the very nice . Thank you for the very nice explanation of CINT vs cling issue. I did not know that Reflex relies on CINT. The proposed upgrade to cling sounds very promising indeed. By the way, we will also need to consider backward compatibility as experiments will still need to read data already recorded in 2010/2011. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:50 Permalink . Re: Backward Compatib",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:12463,feedback,feedback,12463,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['feedback'],['feedback']
Usability,"d on expression templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2009-12-14 18:22 » Last generated: 2009-12-14 18:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/MATH_Index.html:4353,guid,guide,4353,root/html526/MATH_Index.html,https://root.cern,https://root.cern/root/html526/MATH_Index.html,3,['guid'],['guide']
Usability,"d retaining/discarding the physical placements as required. The viewer may decide to force the client to rebuild (republish) the scene (via a TPad repaint at present), and thus collect these objects if the internal viewer state changes. It does this presently by forcing a repaint on the attached TPad object - hence the reason for putting all publishing to the viewer in the attached pad objects Paint() method. We will likely remove this requirement in the future, indicating the rebuild request via a normal ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); TBuffer3DGeneric 3D primitive description class.Definition TBuffer3D.h:18; TVirtualViewer3D::AddObjectvirtual Int_t AddObject(const TBuffer3D &buffer, Bool_t *addChildren=nullptr)=0; bool; unsigned int; If you use the first (simple) case a viewer using logical/physical pairs will generate IDs for each physical object internally. In the second you can specify a unique identifier from the client, which allows the viewer to be more efficient. It can now cache both logical and physical objects, and only discard physical objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of descendents. Both AddObject() methods have an addChildren parameter. The viewer will complete this (if passed) indicating if children (contained within the one just sent) are worth adding. Recycling TBuffer3D; Once add AddObject() has been called, the contents are copied to the viewer internally. You are free to destroy this object, or recycle it for the next object if suitable. ; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:10693,simpl,simple,10693,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['simpl'],['simple']
Usability,"d slots communication mechanism. ;  ; file  guitest_playback.C;  This macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved. ;  ; file  guiWithCLING.C;  A simple example of entering CLING commands and having the CLING output in a ROOT GUI application window. ;  ; file  iconAsXPMData.C;  A simple example of creating icon image from XPM data, included into the code. ;  ; file  listBox.C;  This macro gives an example of how to create a list box and how to set and use its multiple selection feature. ;  ; file  mditest.C;  GUI MDI features. ;  ; file  ntupleTableTest.C;  This TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface. ;  ; file  numberEntry.C;  This macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry. ;  ; file  simpleTableTest.C;  This TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface. ;  ; file  Slider3Demo.C;  Simple macro showing capabilities of triple slider. ;  ; file  splitbuttonTest.C;  A simple example that shows the usage of a TGSplitButton. ;  ; file  splitterHorizontal.C;  This macro gives an example of how to create a horizontal splitter. ;  ; file  splitterVertical.C;  This macro gives an example of how to create a vertical splitter. ;  ; file  staffTableTest.C;  This TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface. ;  ; file  statusBar.C;  This macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window. ;  ; file  textEntries.C;  This macro gives an example of how to set/change text entry attributes. ;  ; file  textviewostream.C;  This macro gives an example of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__gui.html:2848,simpl,simpleTableTest,2848,doc/master/group__tutorial__gui.html,https://root.cern,https://root.cern/doc/master/group__tutorial__gui.html,1,['simpl'],['simpleTableTest']
Usability,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__GSLMultiRootFinder.html:7594,clear,clear,7594,root/html602/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 16:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html:7346,clear,clear,7346,root/html534/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"d to add the function. unsigned int Dim() const. return the number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__GSLMultiRootFinder.html:7594,clear,clear,7594,root/html604/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"d user data.; Float_t*fVerts[3*fNVerts]; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveTriangleSet(Int_t nv, Int_t nt, Bool_t norms = kFALSE, Bool_t cols = kFALSE); Constructor. ~TEveTriangleSet(); Destructor. void GenerateTriangleNormals(); Generate triangle normals via cross product of triangle edges. void GenerateRandomColors(); Assign random colors to all triangles. void GenerateZNormalColors(Float_t fac = 20, Int_t min = -20, Int_t max = 20, Bool_t interp = kFALSE, Bool_t wrap = kFALSE); Generate triangle colors by the z-component of the normal.; Current palette is taken from gStyle. void ComputeBBox(); Compute bounding box.; Virtual from TAttBBox. void Paint(Option_t* option = """"); Paint this object. Only direct rendering is supported. TEveTriangleSet* ReadTrivialFile(const char* file); Read a simple ascii input file describing vertices and triangles. TEveTriangleSet(const TEveTriangleSet& ). TEveTriangleSet& operator=(const TEveTriangleSet& ). Bool_t CanEditMainTransparency() const; { return kTRUE; }. Int_t GetNVerts() const; { return fNVerts; }. Int_t GetNTrings() const; { return fNTrings; }. Float_t* Vertex(Int_t i); { return &(fVerts[3*i]); }. Int_t* Triangle(Int_t i); { return &(fTrings[3*i]); }. Float_t* TriangleNormal(Int_t i); { return &(fTringNorms[3*i]); }. UChar_t* TriangleColor(Int_t i); { return &(fTringCols[3*i]); }. void SetVertex(Int_t i, Float_t x, Float_t y, Float_t z); { Float_t* v = Vertex(i); v[0] = x; v[1] = y; v[2] = z; }. void SetTriangle(Int_t i, Int_t v0, Int_t v1, Int_t v2); { Int_t* t = Triangle(i); t[0] = v0; t[1] = v1; t[2] = v2; }. void SetTriangleColor(Int_t i, UChar_t r, UChar_t g, UChar_t b, UChar_t a = 255); { UChar_t* c = TriangleColor(i); c[0] = r; c[1] = g; c[2] = b; c[3] = a; }. void SetTransparency(Char_t tr); { SetMainTransparency(tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveTriangleSet.html:21560,simpl,simple,21560,root/html528/TEveTriangleSet.html,https://root.cern,https://root.cern/root/html528/TEveTriangleSet.html,4,['simpl'],['simple']
Usability,"d varying on the type of FCN function passesd and on the objects used for the parameters. More...;  ; class  MPIProcess;  ; class  MPITerminate;  ; class  NegativeG2LineSearch;  In case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive. More...;  ; class  Numerical2PGradientCalculator;  class performing the numerical gradient calculation More...;  ; class  NumericalDerivator;  ; class  ParametricFunction;  Function which has parameters. More...;  ; class  PrefixStack;  ; class  ScanBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  ScanMinimizer;  Class implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class. More...;  ; class  SimplexBuilder;  Performs a minimization using the simplex method of Nelder and Mead (ref. More...;  ; class  SimplexMinimizer;  Class implementing the required methods for a minimization using Simplex. More...;  ; class  SimplexParameters;  class describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process. More...;  ; class  SimplexSeedGenerator;  generate Simplex starting point (state) More...;  ; class  SinParameterTransformation;  class for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one More...;  ; class  SqrtLowParameterTransformation;  Transformation from external to internal Parameter based on sqrt(1 + x**2) More...;  ; class  SqrtUpParameterTransformation;  Transformation from external to internal Parameter based on sqrt(1 + x**2) More...;  ; class  StackAllocator;  StackAllocator controls the memory allocation/deallocation of Minuit. More...;  ; class  StackAllocatorHolder;  ; class  S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:11519,simpl,simplex,11519,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['simpl'],['simplex']
Usability,"d we want the Z size to match the one of each container:; 275 ; 276~~~ {.cpp}; 277 TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; 278 TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; 279 TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; 280 container1->AddNode(pvol, 1);; 281 container2->AddNode(pvol, 1);; 282~~~; 283 ; 284 Note that the third parameter of PVOL is negative, which does not make sense; 285as half-length on Z. This is interpreted as: when positioned, create a box; 286replacing all invalid parameters with the corresponding dimensions of the; 287container. This is also internally handled by the TGeoVolumeMulti class, which; 288does not need to be instantiated by users.; 289 ; 290### Dividing volumes; 291 ; 292 Volumes can be divided according a pattern. The most simple division can; 293be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; 294the most simple case: we would like to divide a box in N equal slices along X; 295coordinate, representing a new volume family. Supposing we already have created; 296the initial box, this can be done like:; 297 ; 298~~~ {.cpp}; 299 TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);; 300~~~; 301 ; 302where SLICE is the name of the new family representing all slices and 1 is the; 303slicing axis. The meaning of the axis index is the following: for all volumes; 304having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; 305tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; 306pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; 307 In fact, the division operation has the same effect as positioning volumes; 308in a given order inside the divided container - the advantage being that the; 309navigation in such a structure is much faster. When a volume is divided, a; 310volume family corresponding to the slices is created. In case all slices can; 311be represented by a single ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:14823,simpl,simple,14823,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['simpl'],['simple']
Usability,"d with entries. The caller has to make sure that the data that gets filled into an ntuple is not modified for the time of the Fill() call. The fill call serializes the C++ object into the column format and writes data into the corresponding column page buffers. Writing of the buffers to storage is deferred and can be triggered by FlushCluster() or by destructing the writer. On I/O errors, an exception is thrown. ; Definition at line 60 of file RNTupleWriter.hxx. Public Member Functions;  RNTupleWriter (const RNTupleWriter &)=delete;  ;  ~RNTupleWriter ();  ; void CommitCluster (bool commitClusterGroup=false);  Ensure that the data from the so far seen Fill calls has been written to storage. ;  ; std::unique_ptr< REntry > CreateEntry ();  ; std::unique_ptr< RNTupleModel::RUpdater > CreateModelUpdater ();  Get a RNTupleModel::RUpdater that provides limited support for incremental updates to the underlying model, e.g. ;  ; void EnableMetrics ();  ; std::size_t Fill ();  The simplest user interface if the default entry that comes with the ntuple model is used. ;  ; std::size_t Fill (REntry &entry);  Multiple entries can have been instantiated from the ntuple model. ;  ; void FillNoFlush (REntry &entry, RNTupleFillStatus &status);  Fill an entry into this ntuple, but don't commit the cluster. ;  ; void FlushCluster ();  Flush so far filled entries to storage. ;  ; void FlushColumns ();  Flush column data, preparing for CommitCluster or to reduce memory usage. ;  ; NTupleSize_t GetLastCommitted () const;  Return the entry number that was last committed in a cluster. ;  ; NTupleSize_t GetLastCommittedClusterGroup () const;  Return the entry number that was last committed in a cluster group. ;  ; NTupleSize_t GetLastFlushed () const;  Return the entry number that was last flushed in a cluster. ;  ; const Detail::RNTupleMetrics & GetMetrics () const;  ; const RNTupleModel & GetModel () const;  ; NTupleSize_t GetNEntries () const;  Return the number of entries filled so far. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:1510,simpl,simplest,1510,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['simpl'],['simplest']
Usability,"d() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(testingEventVector, Types::kTesting );; 1463 ; 1464 ; 1465 if (ds->GetNTrainingEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65676,clear,clear,65676,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"d*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:18862,undo,undo,18862,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"d, MnMinos, MnContours).; 2 Introduction: M basic concepts; [sec:intro]; 2.1 The organization of M; The M package acts on a multiparameter objective function which is called — for historical reasons — the \(\mbox{FCN}\) function (see [howto:fcn]). This function is usually a chisquared or a log–likelihood, but it could also be a mathematical function. The \(\mbox{FCN}\) function needs to be written in for which M defines the pure abstract base class FCNBase as interface. The user must define and implement the \(\mbox{FCN}\) function in a derived class from FCNBase. Sometimes this is done by an intermediate program such as HippoDraw@bib-HippoDraw, in which case M is being used under the control of such an intermediate program1. The value of the \(\mbox{FCN}\) function will in general depend on one or more variable parameters whose meaning is defined by the user (or by the intermediate program), but whose trial values are determined by M .; To take a simple example, suppose the problem is to fit a polynomial through a set of data points. Then the user would write a \(\mbox{FCN}\) which calculates the \(\chi^2\) between a polynomial and the data; the variable parameters of \(\mbox{FCN}\) would be the coefficients of the polynomials. Using objects for minimization from M , the user would request M to minimize the \(\mbox{FCN}\) with respect to the parameters, that is, find those values of the coefficients which give the lowest value of chisquare.; The user must therefore supply, in addition to the function to be analyzed, via a set or sequence of M applications the instructions which analysis is wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The mainta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:8123,simpl,simple,8123,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['simpl'],['simple']
Usability,"d. ; when the cutTube keyword is found, this function is called, and the dimensions required are taken and stored, these are then bound and converted to type TGeoCtub and stored in fsolmap map using the name as its key. ; Definition at line 3037 of file TGDMLParse.cxx. ◆ DeclFileName(). static const char * TGDMLParse::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 226 of file TGDMLParse.h. ◆ DefineConstants(). void TGDMLParse::DefineConstants ; (; ). private . Define constant expressions used. ; Definition at line 494 of file TGDMLParse.cxx. ◆ ElCone(). XMLNodePointer_t TGDMLParse::ElCone ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, an elliptical cone may be declared. ; Unfortunately, the elliptical cone is not supported under ROOT so, when the elcone keyword is found, this function is called to convert it to a simple box with similar dimensions, and the dimensions required are taken and stored, these are then bound and converted to type TGeoBBox and stored in fsolmap map using the name as its key. ; Definition at line 2707 of file TGDMLParse.cxx. ◆ EleProcess(). XMLNodePointer_t TGDMLParse::EleProcess ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLNodePointer_t ; parentn, . Bool_t ; hasIsotopes, . Bool_t ; hasIsotopesExtended . ). private . When the element keyword is found, this function is called, and the name and values of the element are converted into type TGeoElement and stored in felemap map using the name as its key. ; Definition at line 1086 of file TGDMLParse.cxx. ◆ Ellipsoid(). XMLNodePointer_t TGDMLParse::Ellipsoid ; (; TXMLEngine * ; gdml, . XMLNodePointer_t ; node, . XMLAttrPointer_t ; attr . ). private . In the solids section of the GDML file, an ellipsoid may be declared. ; Unfortunately, the ellipsoid is not supported under ROOT so, when the ellipsoid keyword is found, this function is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDMLParse.html:30501,simpl,simple,30501,doc/master/classTGDMLParse.html,https://root.cern,https://root.cern/doc/master/classTGDMLParse.html,1,['simpl'],['simple']
Usability,"d. <one line to give the library's name and a brief idea of what it does>; Copyright (C) <year> <name of author>. This library is free software; you can redistribute it and/or; modify it under the terms of the GNU Lesser General Public; License as published by the Free Software Foundation; either; version 2.1 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful,; but WITHOUT ANY WARRANTY; without even the implied warranty of; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU; Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public; License along with this library; if not, write to the Free Software; Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. Also add information on how to contact you by electronic and paper mail. You should also get your employer (if you work as a programmer) or your; school, if any, to sign a ""copyright disclaimer"" for the library, if; necessary. Here is a sample; alter the names:. Yoyodyne, Inc., hereby disclaims all copyright interest in the; library `Frob' (a library for tweaking knobs) written by James Random Hacker. <signature of Ty Coon> 1 April 1990; Ty Coon, President of Vice. That's all there is to it!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:28840,guid,guidelines,28840,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['guid'],['guidelines']
Usability,"d.; The object falls outside some ‘interest’ limits of the viewer camera.; The object is too small to be worth drawing. In all these cases TBuffer3D::AddObject() returns kNone, as it does for successful addition, indicating it does not require further information about this object. Hence you should not try to make any assumptions about what the viewer did with the object. The viewer may decide to force the client to rebuild (republish) the scene, obtaining a different collection of objects, if the internal viewer state changes .e.g. significant camera move. It does this presently by forcing a repaint on the attached TPad object - hence you should attach you master geometry object to the pad (via TObject::Draw()), and perform the publishing to the viewer in response to TObject::Paint().; 9.13.4.9 Physical IDs; TVirtualViewer3D provides for two methods of object addition:; virtual Int_t AddObject(const TBuffer3D &buffer,; Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID,; const TBuffer3D & buffer,; Bool_t *addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs will generate sequential IDs for each physical object internally. Scene rebuilds will require destruction and recreation of all physical objects. For the second you can specify an identifier from the client side, which must be unique and stable - i.e. the IDs of a published object is consistent, regardless of changes in termination of contained child geometry branches. In this case the viewer can safely cache the physical objects across scene rebuilds, discarding those no longer of interest.; 9.13.4.10 Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer is not interested in a certain object due to limits/size then it will also not be interest in any of the contained branch of siblings. Both TBuffer3D::AddObject() methods have an addChildren return parameter. The viewer will complete this (if passed) indicating if ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:416688,simpl,simple,416688,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"d::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; std::string createLabel () const;  Compile a string with all the labels of the serving categories, such as {1Jet;1Lepton;2Tag}. ;  ; value_type evaluate () const override;  Calculate the current value. ;  ; void recomputeShape () override;  Inspect all the subcategories, and enumerate and name their states. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiCategory.html:35670,clear,clearTypes,35670,doc/master/classRooMultiCategory.html,https://root.cern,https://root.cern/doc/master/classRooMultiCategory.html,1,['clear'],['clearTypes']
Usability,"d; The array dimension is the number of bins in the histograms; including underflow and overflow (fNCells); the last value integral[fNCells] is set to the number of entries of; the histogram. void Copy(TObject& hnew) const; -*-*-*-*-*Copy this histogram structure to newth1*-*-*-*-*-*-*-*-*-*-*-*. Note that this function does not copy the list of associated functions.; Use TObject::Clone to make a full copy of an histogram. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); -*-*-*-*-*-*-*-*-*Compute distance from point px,py to a line*-*-*-*-*-*. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. void Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1.html:58807,simpl,simple,58807,root/html532/TH1.html,https://root.cern,https://root.cern/root/html532/TH1.html,1,['simpl'],['simple']
Usability,"d<(useForTraining-availableTraining) ||; 1284 availableUndefined<(useForTesting -availableTesting ) ||; 1285 availableUndefined<(useForTraining+useForTesting-availableTraining-availableTesting ) ){; 1286 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested than available!"" << Endl;; 1287 }; 1288 ; 1289 // select the events; 1290 if (useForTraining>availableTraining){; 1291 eventVectorTraining.insert( eventVectorTraining.end() , eventVectorUndefined.begin(), eventVectorUndefined.begin()+ useForTraining- availableTraining );; 1292 eventVectorUndefined.erase( eventVectorUndefined.begin(), eventVectorUndefined.begin() + useForTraining- availableTraining);; 1293 }; 1294 if (useForTesting>availableTesting){; 1295 eventVectorTesting.insert( eventVectorTesting.end() , eventVectorUndefined.begin(), eventVectorUndefined.begin()+ useForTesting- availableTesting );; 1296 }; 1297 }; 1298 eventVectorUndefined.clear();; 1299 ; 1300 // finally shorten the event vectors to the requested size by removing random events; 1301 if (splitMode.Contains( ""RANDOM"" )){; 1302 UInt_t sizeTraining = eventVectorTraining.size();; 1303 if( sizeTraining > UInt_t(requestedTraining) ){; 1304 std::vector<UInt_t> indicesTraining( sizeTraining );; 1305 // make indices; 1306 std::generate( indicesTraining.begin(), indicesTraining.end(), TMVA::Increment<UInt_t>(0) );; 1307 // shuffle indices; 1308 std::shuffle(indicesTraining.begin(), indicesTraining.end(), rndm);; 1309 // erase indices of not needed events; 1310 indicesTraining.erase( indicesTraining.begin()+sizeTraining-UInt_t(requestedTraining), indicesTraining.end() );; 1311 // delete all events with the given indices; 1312 for( std::vector<UInt_t>::iterator it = indicesTraining.begin(), itEnd = indicesTraining.end(); it != itEnd; ++it ){; 1313 delete eventVectorTraining.at( (*it) ); // delete event; 1314 eventVectorTraining.at( (*it) ) = NULL; // set pointer to NULL; 1315 }; 1316 // now remove and erase all events with point",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:57227,clear,clear,57227,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"dByFignore()""; in addition, the number of strings which were not ""ExcludedByFignore()"" is returned in ""nGoodStrings"". ; Definition at line 685 of file TTabCom.cxx. ◆ AppendListOfFilesInDirectory(). void TTabCom::AppendListOfFilesInDirectory ; (; const char ; dirName[], . TSeqCollection * ; pList . ). static . [static utility function]///////////////////////////// ; adds a TObjString to ""*pList"" for each entry found in the system directory ""dirName""; directories that do not exist are silently ignored. ; Definition at line 750 of file TTabCom.cxx. ◆ Class(). static TClass * TTabCom::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TTabCom::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TTabCom::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 226 of file TTabCom.h. ◆ ClearAll(). void TTabCom::ClearAll ; (; ). clears all lists except for user names and system include files. ; Definition at line 319 of file TTabCom.cxx. ◆ ClearClasses(). void TTabCom::ClearClasses ; (; ). Clear classes and namespace collections. ; Definition at line 218 of file TTabCom.cxx. ◆ ClearCppDirectives(). void TTabCom::ClearCppDirectives ; (; ). Forget all Cpp directives seen so far. ; Definition at line 230 of file TTabCom.cxx. ◆ ClearEnvVars(). void TTabCom::ClearEnvVars ; (; ). Forget all environment variables seen so far. ; Definition at line 242 of file TTabCom.cxx. ◆ ClearFiles(). void TTabCom::ClearFiles ; (; ). Close all files. ; Definition at line 254 of file TTabCom.cxx. ◆ ClearGlobalFunctions(). void TTabCom::ClearGlobalFunctions ; (; ). Forget all global functions seen so far. ; Not needed anymore. Use gROOT->GetListOfGlobalFunctions() ; Definition at line 267 of file TTabCom.cxx. ◆ ClearGlobals(). void TTabCom::ClearGlobals ; (; ). Forget all global variables seen so far. ; With teh new implamentation the list is gROOT->GetListOfGlobal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:9276,clear,clears,9276,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['clear'],['clears']
Usability,"dDL.h:153; TMVA::MethodDL::ParseRecurrentLayervoid ParseRecurrentLayer(ERecurrentLayerType type, DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate rnn layer.Definition MethodDL.cxx:931; TMVA::MethodDL::fTrainingSettingsstd::vector< TTrainingSettings > fTrainingSettingsThe vector defining each training strategy.Definition MethodDL.h:204; TMVA::MethodDL::GetInputWidthsize_t GetInputWidth() constDefinition MethodDL.h:257; TMVA::MethodDL::SetInputShapevoid SetInputShape(std::vector< size_t > inputShape)Definition MethodDL.h:289; TMVA::MethodDL::GetLossFunctionDNN::ELossFunction GetLossFunction() constDefinition MethodDL.h:270; TMVA::MethodDL::fBatchLayoutStringTString fBatchLayoutStringThe string defining the layout of the batch.Definition MethodDL.h:193; TMVA::MethodDL::HasAnalysisTypeBool_t HasAnalysisType(Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets)Check the type of analysis the deep learning network can do.Definition MethodDL.cxx:1091; TMVA::MethodDL::ParseConvLayervoid ParseConvLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate convolutional layer.Definition MethodDL.cxx:669; TMVA::MethodDL::ParseReshapeLayervoid ParseReshapeLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate reshape layer.Definition MethodDL.cxx:829; TMVA::MethodDL::GetRegressionValuesvirtual const std::vector< Float_t > & GetRegressionValues(); TMVA::MethodDL::fTrainingStrategyStringTString fTrainingStrategyStringThe string defining the training strategy.Definition MethodDL.h:196; TMVA::MethodDL::CreateRankingconst Rankin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:109536,learn,learning,109536,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learning']
Usability,"dNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; TTreeCache::EPrefillTypefPrefillTypeWhether a prefilling is enabled (and if applicable which type); Int_tTFileCacheRead::fReadCallsNumber of read calls for this cache; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:21092,learn,learning,21092,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['learn'],['learning']
Usability,"dObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a high level interface for analyses of data stored in TTrees, CSV's and other data formats. More...;  ; class  ROpaqueTaskArena;  ; class  TExecutor;  This class defines an interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:2173,simpl,simple,2173,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['simpl'],['simple']
Usability,"dPdf::setAllExtendable ; (; bool ; allExtendable). inlineprivate . Definition at line 151 of file RooAddPdf.h. ◆ setCacheAndTrackHints(). void RooAddPdf::setCacheAndTrackHints ; (; RooArgSet & ; trackNodes). overridevirtual . Label OK'ed components of a RooAddPdf with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 938 of file RooAddPdf.cxx. ◆ setRecursiveFraction(). void RooAddPdf::setRecursiveFraction ; (; bool ; recursiveFraction). inlineprivate . Definition at line 150 of file RooAddPdf.h. ◆ Streamer(). void RooAddPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooAddPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 153 of file RooAddPdf.h. ◆ translate(). void RooAddPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 548 of file RooAddPdf.cxx. ◆ updateCoefficients(). void RooAddPdf::updateCoefficients ; (; AddCacheElem & ; cache, . const RooArgSet * ; nset, . bool ; syncCoefValues = true . ); const. protected . Update the coefficient values in the given cache element: calculate new remainder fraction, normalize fractions obtained from extended ML terms to unity, and multiply the various range and dimensional corrections needed in the curre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:94712,simpl,simple,94712,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['simpl'],['simple']
Usability,"dRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Int_tcalculateBandWidth(Int_t kernel = -999); Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DKeysPdf.html:2968,clear,clearValueDirty,2968,root/html534/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html534/Roo2DKeysPdf.html,3,['clear'],['clearValueDirty']
Usability,"dSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveScene(const char* n = ""TEveScene"", const char* t = """"); Constructor. TEveScene(TGLScenePad* gl_scene, const char* n = ""TEveScene"", const char* t = """"); Constructor. ~TEveScene(); Destructor. void CollectSceneParents(TEveElement::List_t& scenes); Virtual from TEveElement; here we simply append this scene to; the list. void Repaint(Bool_t dropLogicals = kFALSE); Repaint the scene. void RetransHierarchically(); Entry point for hierarchical transformation update.; Calls the recursive variant on all children. void RetransHierarchicallyRecurse(TEveElement* el, const TEveTrans& tp); Set transformation matrix for physical shape of element el in; the GL-scene and recursively descend into children (if enabled). void SetName(const char* n); Set scene's name. void Paint(Option_t* option = """"); Paint the scene. Iterate over children and calls PadPaint(). void DestroyElementRenderers(TEveElement* element); Remove element from the scene.; It is not an error if the element is not found in the scene. void DestroyElementRenderers(TObject* rnrObj); Remove element represented by object rnrObj from the scene.; It is not an error if the element is not found in the scene. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return icon for scene. TEveSce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveScene.html:21606,simpl,simply,21606,root/html602/TEveScene.html,https://root.cern,https://root.cern/root/html602/TEveScene.html,2,['simpl'],['simply']
Usability,"dataloader, TString options);  ;  ~CrossValidation ();  ; void Evaluate ();  Does training, test set evaluation and performance evaluation of using cross-evalution. ;  ; Factory & GetFactory ();  ; UInt_t GetNumFolds ();  ; const std::vector< CrossValidationResult > & GetResults () const;  ; TString GetSplitExpr ();  ; void InitOptions ();  ; virtual TClass * IsA () const;  ; void ParseOptions ();  Method to parse the internal option string. ;  ; void SetNumFolds (UInt_t i);  ; void SetSplitExpr (TString splitExpr);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; void SetFile (TFile *file);  Method to set the pointer to TFile object, with a writable file. ;  ; void SetModelPersistence (Bool_t status=kTRUE);  Method enable m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html:2361,learn,learning,2361,doc/master/classTMVA_1_1CrossValidation.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1CrossValidation.html,1,['learn'],['learning']
Usability,"ddingacolumnofstl); 51- [Add a column holding an object](\ref addingacolumnofobjs); 52- [Add a column holding a TObjectArray](\ref addingacolumnofobjs); 53- [Fill the tree](\ref fillthetree); 54- [Add a column to an already existing Tree](\ref addcoltoexistingtree); 55- [An Example](\ref fullexample); 56 ; 57\anchor creatingattree; 58## Construct a TTree; 59 ; 60~~~ {.cpp}; 61 TTree tree(name, title); 62~~~; 63Creates a Tree with name and title.; 64 ; 65Various kinds of branches can be added to a tree:; 66- Variables representing fundamental types, simple classes/structures or list of variables: for example for C or Fortran; 67structures.; 68- Any C++ object or collection, provided by the STL or ROOT.; 69 ; 70In the following, the details about the creation of different types of branches are given.; 71 ; 72\anchor addcolumnoffundamentaltypes; 73## Add a column (""branch"") holding fundamental types and arrays thereof; 74This strategy works also for lists of variables, e.g. to describe simple structures.; 75It is strongly recommended to persistify those as objects rather than lists of leaves.; 76 ; 77~~~ {.cpp}; 78 auto branch = tree.Branch(branchname, address, leaflist, bufsize); 79~~~; 80- address is the address of the first item of a structure; 81- leaflist is the concatenation of all the variable names and types; 82 separated by a colon character :; 83 The variable name and the variable type are separated by a; 84 slash (/). The variable type must be 1 character. (Characters; 85 after the first are legal and will be appended to the visible; 86 name of the leaf, but have no effect.) If no type is given, the; 87 type of the variable is assumed to be the same as the previous; 88 variable. If the first variable does not have a type, it is; 89 assumed of type F by default. The list of currently supported; 90 types is given below:; 91 - `C` : a character string terminated by the 0 character; 92 - `B` : an 8 bit signed integer (`Char_t`); Treated as a character when in an ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:3761,simpl,simple,3761,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"de ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; TMVA::Rule Class ReferenceTMVA. ; Implementation of a rule. ; A rule is simply a branch or a part of a branch in a tree. It fulfills the following:. First node is the root node of the originating tree; Consists of a minimum of 2 nodes; A rule returns for a given event:; 0 : if the event fails at any node; 1 : otherwise. If the rule contains <2 nodes, it returns 0 SHOULD NOT HAPPEN!. The coefficient is found by either brute force or some sort of intelligent fitting. See the RuleEnsemble class for more info. ; Definition at line 50 of file Rule.h. Public Member Functions;  Rule ();  the simple constructor ;  ;  Rule (const Rule &other);  ;  Rule (RuleEnsemble *re);  the simple constructor ;  ;  Rule (RuleEnsemble *re, const std::vector< const TMVA::Node * > &nodes);  the main constructor for a Rule ;  ; virtual ~Rule ();  destructor ;  ; void * AddXMLTo (void *parent) const;  ; void CalcImportance ();  ; Bool_t ContainsVariable (UInt_t iv) const;  check if variable in node ;  ; Bool_t Equal (const Rule &other, Bool_t useCutValue, Double_t maxdist) const;  Compare two rules. ;  ; Bool_t EvalEvent (const Event &e) const;  ; Double_t GetCoefficient () const;  ; Double_t GetImportance () const;  ; Double_t GetImportanceRef () const;  ; UInt_t GetNcuts () const;  ; Double_t GetNorm () const;  ; UInt_t GetNumVarsUsed () const;  ; Double_t GetRelImportance () const;  ; const RuleCut * GetRuleCut () const;  ; const RuleEnsemble * GetRuleEnsemble () const;  ; Double_t GetSigma () const;  ; Double_t GetSSB () const;  ; Double_t GetSSBNeve () const;  ; Double_t GetSupport () const;  ; Bool_t IsSignalRule () const;  ; Bool_t operator< (const Rule &other) const;  comparison operator < ;  ; void operator= (const Rule &other);  ; Bool_t operator== (const Rule &other) const;  comparison operator == ;  ; voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Rule.html:842,simpl,simple,842,doc/master/classTMVA_1_1Rule.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Rule.html,2,['simpl'],['simple']
Usability,"de a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 372 of file RooCategory.cxx. ◆ addToRange() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 141 of file RooCategory.h. ◆ clear(). void RooCategory::clear ; (; ). inline . Clear all defined category states. ; Definition at line 69 of file RooCategory.h. ◆ clearRange(). void RooCategory::clearRange ; (; const char * ; name, . bool ; silent . ). Clear the named range. ; NoteThis affects all copies of this category, because they are sharing range definitions. This ensures that categories inside a dataset and their counterparts on the outside will both see a modification of the range. ; Definition at line 321 of file RooCategory.cxx. ◆ clone(). TObject * RooCategory::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooCategory.h. ◆ DeclFileName(). static const char * RooCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 141 of file RooCategory.h. ◆ defineType() [1/2]. bool RooCategory::defineType ; (; const std::string & ; label). Define a state with given name. ; The lowest available positi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:55052,clear,clear,55052,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clear']
Usability,"de, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4868,clear,clearOnRedirect,4868,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,3,['clear'],['clearOnRedirect']
Usability,"de. rfio; ON; RFIO support, requires libshift from CASTOR >= 1.5.2. rpath; OFF; Set run-time library load path on executables and shared libraries (at installation area). runtime_cxxmodules; OFF; Enable runtime c++ modules. sapdb; ON; MaxDB/SapDB support, requires libsqlod and libsqlrte. shadowpw; ON; Shadow password support. shared; ON; Use shared 3rd party libraries if possible. soversion; OFF; Set version number in sonames (recommended). sqlite; ON; SQLite support, requires libsqlite3. srp; ON; SRP support, requires SRP source tree. ssl; ON; SSL encryption support, requires openssl. tbb; OFF; TBB multi-threading support, requires TBB. table; *; Build libTable contrib library. tcmalloc; OFF; Using the tcmalloc allocator. testing; OFF; Enable test suit of ROOT with CTest. thread; ON; Using thread library (cannot be disabled). tmva; ON; Build TMVA multi variate analysis library. unuran; *; UNURAN - package for generating non-uniform random numbers. vc; *; Vc adds a few new types for portable and intuitive SIMD programming. vdt; ON; VDT adds a set of fast and vectorisable mathematical functions. winrtdebug; OFF; Link against the Windows debug runtime library. xft; ON; Xft support (X11 antialiased fonts). xml; ON; XML parser interface. xrootd; ON; Build xrootd file server and its client (if supported). x11; *; X11 support. The default value for these options are platform dependent. CMake Generators; CMake can generate, in addition to standard makefiles, specific proejcts for various integrated development environments (IDEs) such as Xcode, Eclipse, Visual Studio, etc.. The available generators depend on the platform for which cmake have been build. To see the list of available generators do cmake --help .; Ninja; Generate a Ninja project with cmake -G Ninja /path/to/source/dir. Building ROOT with Ninja is faster.; Xcode; Generate the Xcode project with cmake -G Xcode /path/to/source/dir. Open the generated file with the Xcode application.; Visual Studio; Generate the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:12838,intuit,intuitive,12838,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['intuit'],['intuitive']
Usability,"de; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:72223,simpl,simple,72223,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"de;  WVE note: assumes nominal and alternates have identical structure, must add explicit check. ;  ; const RooArgList & lowList () const;  ; const RooAbsReal * nominalHist () const;  Return pointer to the nominal hist function. ;  ; const RooArgList & paramList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; bool positiveDefinite () const;  ; void printAllInterpCodes ();  ; void setAllInterpCodes (int code);  ; bool setBinIntegrator (RooArgSet &allVars);  ; void setInterpCode (RooAbsReal &param, int code, bool silent=false);  ; void setPositiveDefinite (bool flag=true);  ; void Streamer (TBuffer &) override;  Stream an object of class PiecewiseInterpolation. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:3950,simpl,simple,3950,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['simpl'],['simple']
Usability,"def std::vector<Bool_t, A> Cont_t;; 722 typedef typename Cont_t::iterator Iter_t;; 723 typedef typename Cont_t::value_type Value_t;; 724 typedef Environ<Iter_t> Env_t;; 725 typedef Env_t *PEnv_t;; 726 typedef Cont_t *PCont_t;; 727 typedef Value_t *PValue_t;; 728 ; 729 static void resize(void* obj,size_t n) {; 730 PCont_t c = PCont_t(obj);; 731 c->resize(n);; 732 }; 733 static void* feed(void* from, void *to, size_t size) {; 734 PCont_t c = PCont_t(to);; 735 PValue_t m = PValue_t(from);; 736 for (size_t i=0; i<size; ++i, ++m); 737 c->push_back(*m);; 738 return nullptr;; 739 }; 740 static int value_offset() {; 741 return 0;; 742 }; 743 };; 744 ; 745 // Need specialization for boolean references due to stupid STL std::vector<bool>; 746 template <class A> struct TCollectionProxyInfo::Address<std::vector<Bool_t, A>> {; 747 virtual ~Address() {}; 748 static void* address(typename std::vector<Bool_t, A>::const_reference) {; 749 R__ASSERT(false && ""Intentionally not implemented, should use VectorLooper or other functions specialized for ""; 750 ""vector<bool> instead"");; 751 return {};; 752 }; 753 };; 754 ; 755 template <typename Bitset_t> struct TCollectionProxyInfo::Type<Internal::TStdBitsetHelper<Bitset_t> > : public TCollectionProxyInfo::Address<const Bool_t &>; 756 {; 757 typedef Bitset_t Cont_t;; 758 typedef std::pair<size_t,Bool_t> Iter_t;; 759 typedef Bool_t Value_t;; 760 typedef Environ<Iter_t> Env_t;; 761 typedef Env_t *PEnv_t;; 762 typedef Cont_t *PCont_t;; 763 typedef Value_t *PValue_t;; 764 ; 765 virtual ~Type() {}; 766 ; 767 static inline PCont_t object(void* ptr) {; 768 return PCont_t(PEnv_t(ptr)->fObject);; 769 }; 770 static void* size(void* env) {; 771 PEnv_t e = PEnv_t(env);; 772 e->fSize = PCont_t(e->fObject)->size();; 773 return &e->fSize;; 774 }; 775 static void* clear(void* env) {; 776 object(env)->reset();; 777 return nullptr;; 778 }; 779 static void* first(void* env) {; 780 PEnv_t e = PEnv_t(env);; 781 PCont_t c = PCont_t(e->fObject);; 782 e->fIterator.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:26771,clear,clear,26771,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['clear'],['clear']
Usability,"defined states. Bool_t operator==(Int_t index); Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label); Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType &other, Bool_t printError); Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError); Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError); Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(RooCatType value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue(ostream& os) const; Print value (label name). void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:21542,clear,clearTypes,21542,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['clear'],['clearTypes']
Usability,"del encapulates the schema of an ntuple.Definition RNTupleModel.hxx:136; ROOT::Experimental::RNTupleModel::Createstatic std::unique_ptr< RNTupleModel > Create()Definition RNTupleModel.cxx:249; ROOT::Experimental::RNTupleWriterAn RNTuple that gets filled with entries (data) and writes them to storage.Definition RNTupleWriter.hxx:60; ROOT::Experimental::RNTupleWriter::Recreatestatic std::unique_ptr< RNTupleWriter > Recreate(std::unique_ptr< RNTupleModel > model, std::string_view ntupleName, std::string_view storage, const RNTupleWriteOptions &options=RNTupleWriteOptions())Throws an exception if the model is null.Definition RNTupleWriter.cxx:71; writerDefinition writer.py:1. Definition at line 161 of file RNTupleWriter.hxx. ◆ EnableMetrics(). void ROOT::Experimental::RNTupleWriter::EnableMetrics ; (; ). inline . Definition at line 137 of file RNTupleWriter.hxx. ◆ Fill() [1/2]. std::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; ). inline . The simplest user interface if the default entry that comes with the ntuple model is used. ; ReturnsThe number of uncompressed bytes written. ; Definition at line 105 of file RNTupleWriter.hxx. ◆ Fill() [2/2]. std::size_t ROOT::Experimental::RNTupleWriter::Fill ; (; REntry & ; entry). inline . Multiple entries can have been instantiated from the ntuple model. ; This method will perform a light check whether the entry comes from the ntuple's own model. ReturnsThe number of uncompressed bytes written. ; Definition at line 109 of file RNTupleWriter.hxx. ◆ FillNoFlush(). void ROOT::Experimental::RNTupleWriter::FillNoFlush ; (; REntry & ; entry, . RNTupleFillStatus & ; status . ). inline . Fill an entry into this ntuple, but don't commit the cluster. ; The calling code must pass an RNTupleFillStatus and check RNTupleFillStatus::ShouldFlushCluster. ; Definition at line 112 of file RNTupleWriter.hxx. ◆ FlushCluster(). void ROOT::Experimental::RNTupleWriter::FlushCluster ; (; ). inline . Flush so far filled entries to storage. ; Definiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html:8157,simpl,simplest,8157,doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleWriter.html,1,['simpl'],['simplest']
Usability,"del::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGaussModel.html:3151,clear,clearEvalErrorLog,3151,root/html526/RooGaussModel.html,https://root.cern,https://root.cern/root/html526/RooGaussModel.html,3,['clear'],['clearEvalErrorLog']
Usability,"depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:67681,clear,clearShapeDirty,67681,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,6,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"der, ""muons.fPt"");; // Here, too we would need the definition of the Muon class.; TTreeReaderArray<Muon> raMuons(reader, ""muons"");. Accessing Data; The TTreeReader checks whether the type you specify is the type that's stored in the branch, i.e. whether it can actually access the data through the reader object. The TTreeReaderValue gets its values like so:; // Loop through all the TTree's entries; while (reader.Next()) {; // behaves like an iterator; float missingET = *rvMissingET;; ...; }. A TTreeReaderArray allows you to get the size and access the n-th element:; while (reader.Next()) {; for (int iMuon = 0, nMuons = raMuonPt.GetSize(); iMuon < nMuons; ++iMuon) {; hist->Fill(raMuonPt[iMuon]);; }; }. Of course in C++11 you could also just do; while (reader.Next()) {; for (float pT: raMuonPt) {; hist->Fill(pT);; }; }. We will try all of this out later; you are welcome to write a little script to test this on our TTree.; . ‹ 6. Multivariate Analysis; up; 8. Efficiency Calculation ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/7-using-ttreereader.html:4859,guid,guidelines,4859,d/7-using-ttreereader.html,https://root.cern,https://root.cern/d/7-using-ttreereader.html,1,['guid'],['guidelines']
Usability,"derTDataLoader ;  CTDataLoader< AData, TReference< AReal > >;  CTDeepNetGeneric Deep Neural Network class ;  CTDenseLayerGeneric layer class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to pe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:79279,simpl,simple,79279,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,1,['simpl'],['simple']
Usability,"derived; 2877 if(!dynamic_cast<RooAbsRealLValue*>(var)) {; 2878 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: cannot plot variable \""""; 2879 << var->GetName() << ""\"" of type "" << var->ClassName() << std::endl;; 2880 return true;; 2881 }; 2882 ; 2883 // check if we actually depend on the plot variable; 2884 if(!this->dependsOn(*var)) {; 2885 coutE(Plotting) << ClassName() << ""::"" << GetName() << "":plotOn: WARNING: variable is not an explicit dependent: ""; 2886 << var->GetName() << std::endl;; 2887 }; 2888 ; 2889 return false ;; 2890}; 2891 ; 2892 ; 2893 ; 2894 ; 2895////////////////////////////////////////////////////////////////////////////////; 2896/// Utility function for plotOn() that constructs the set of; 2897/// observables to project when plotting ourselves as function of; 2898/// 'plotVar'. 'allVars' is the list of variables that must be; 2899/// projected, but may contain variables that we do not depend on. If; 2900/// 'silent' is cleared, warnings about inconsistent input parameters; 2901/// will be printed.; 2902 ; 2903void RooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars,; 2904 RooArgSet& projectedVars, bool silent) const; 2905{; 2906 cxcoutD(Plotting) << ""RooAbsReal::makeProjectionSet("" << GetName() << "") plotVar = "" << plotVar->GetName(); 2907 << "" allVars = "" << (allVars?(*allVars):RooArgSet()) << std::endl ;; 2908 ; 2909 projectedVars.removeAll() ;; 2910 if (!allVars) return ;; 2911 ; 2912 // Start out with suggested list of variables; 2913 projectedVars.add(*allVars) ;; 2914 ; 2915 // Take out plot variable; 2916 RooAbsArg *found= projectedVars.find(plotVar->GetName());; 2917 if(found) {; 2918 projectedVars.remove(*found);; 2919 ; 2920 // Take out eventual servers of plotVar; 2921 std::unique_ptr<RooArgSet> plotServers{plotVar->getObservables(&projectedVars)};; 2922 for(RooAbsArg * ps : *plotServers) {; 2923 RooAbsArg* tmp = projectedVars.find(ps->GetName()) ;; 2924 if (tmp) {; 2925 cxcoutD(Plotting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:126362,clear,cleared,126362,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['clear'],['cleared']
Usability,"des in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // display modes algorithm group [15]; float l_h_weight; // weight between shading according to fictive light source and; // according to channels counts, applies only for; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT modes group; int xlight; // x position of fictive light source, applies only for rainbowed display; // modes with shading according to light; int ylight; // y position of fictive light source, applies ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73415,simpl,simple,73415,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"des; Libraries. Function documentation; RooProfileLL(const char* name, const char* title, RooAbsReal& nll, const RooArgSet& observables); Constructor of profile likelihood given input likelihood nll w.r.t; the given set of variables. The input log likelihood is minimized w.r.t; to all other variables of the likelihood at each evaluation and the; value of the global log likelihood minimum is always subtracted. RooProfileLL(const RooProfileLL& other, const char* name = 0); Copy constructor. ~RooProfileLL(); Destructor. const RooArgSet& bestFitParams() const. const RooArgSet& bestFitObs() const. RooAbsReal* createProfile(const RooArgSet& paramsOfInterest); Optimized implementation of createProfile for profile likelihoods.; Return profile of original function in terms of stated parameters; of interest rather than profiling recursively. Double_t evaluate() const; Evaluate profile likelihood by minimizing likelihood w.r.t. all; parameters that are not considered observables of this profile; likelihood object. void validateAbsMin() const; Check that parameters and likelihood value for 'best fit' are still valid. If not,; because the best fit has never been calculated, or because constant parameters have; changed value or parameters have changed const/float status, the minimum is recalculated. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ). TObject* clone(const char* newname) const; { return new RooProfileLL(*this,newname); }. void setAlwaysStartFromMin(Bool_t flag); { _startFromMin = flag ; }. Bool_t alwaysStartFromMin() const; { return _startFromMin ; }. RooMinuit* minuit(); { return _minuit ; }. RooAbsReal& nll(); { return const_cast<RooAbsReal&>(_nll.arg()) ; }. void clearAbsMin(); { _absMinValid = kFALSE ; }. » Last changed: Tue Dec 8 17:03:18 2009 » Last generated: 2009-12-08 17:03; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProfileLL.html:35198,clear,clearAbsMin,35198,root/html526/RooProfileLL.html,https://root.cern,https://root.cern/root/html526/RooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"dients ();  ; const std::vector< Matrix_t > & GetWeightGradients () const;  ; Matrix_t & GetWeightGradientsAt (size_t i);  ; const Matrix_t & GetWeightGradientsAt (size_t i) const;  ; std::vector< Matrix_t > & GetWeights ();  ; const std::vector< Matrix_t > & GetWeights () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; virtual void Initialize ();  Initialize the weights and biases according to the given initialization method. ;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *nam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html:6571,learn,learningRate,6571,doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ding of operator[]. Objects can be directly accessed via an index. The array expands automatically when objects are added. At creation time one specifies the default array size (default = 16) and lower bound (default = 0). Resizing involves a re-allocation and a copy of the old array to the new. This can be costly if done too often. If possible, set initial size close to expected final size. Index validity is always checked (if you are 100% sure and maximum performance is needed you can use UnCheckedAt() instead of At() or operator[]). If the stored objects are sort able the array can be sorted using Sort(). Once sorted, efficient searching is possible via the BinarySearch() method. The figure shows the internal data structure of a TObjArray:. The internal data structure of a TObjArray. Iterating can be done using a TIter iterator or via a simple for loop:; for (int i = 0; i <= fArr.GetLast(); i++); if ((track = (TTrack*)fArr[i])) // or fArr.At(i); track->Draw();; Main features of TObjArray are simple, well-known array semantics. Overhead per element: none, except possible over sizing of fCont.; 16.8 TClonesArray An Array of Identical Objects; A TClonesArray is an array of identical (clone) objects. The memory for the objects stored in the array is allocated only once in the lifetime of the clones array. All objects must be of the same class. For the rest this class has the same properties as a TObjArray. The internal data structure of a TClonesArray. The figure above shows the internal data structure of a TClonesArray. The class is specially designed for repetitive data analysis tasks, where in a loop many times the same objects, are created and deleted. The only supported way to add objects to a TClonesArray is via the new with placement method. The different Add() methods of TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:853672,simpl,simple,853672,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"distribution with errors; scaleBias: scale factor applied to the bias; Data members required:; fA, fX0, fL; Data members modified:; those documented in SetInput(); and those documented in DoUnfold(Double_t); Return value:; maximum global correlation coefficient; NOTE!!! return value >=1.0 means error, and the result is junk. Overflow bins of the input distribution are ignored!. Int_t SetInput(const TH1* hist_y, Double_t scaleBias = 0., Double_t oneOverZeroError = 0., const TH2* hist_vyy = 0, const TH2* hist_vyy_inv = 0); Define the input data for subsequent calls to DoUnfold(Double_t); input: input distribution with errors; scaleBias: scale factor applied to the bias; oneOverZeroError: for bins with zero error, this number defines 1/error.; hist_vyy: if non-zero, defines the data covariance matrix; otherwise it is calculated from the data errors; hist_vyy_inv: if non-zero and if hist_vyy is set, defines the inverse of the data covariance matrix; Return value: number of bins with bad error; +10000*number of unconstrained output bins; Note: return values>=10000 are fatal errors,; for the given input, the unfolding can not be done!; Data members modified:; fY, fVyy, , fBiasScale; Data members cleared; fVyyInv, fNdf; + see ClearResults. Double_t DoUnfold(Double_t tau); Unfold with given value of regularisation parameter tau; tau: new tau parameter; required data members:; fA: matrix to relate x and y; fY: measured data points; fX0: bias on x; fBiasScale: scale factor for fX0; fV: inverse of covariance matrix for y; fL: regularisation conditions; modified data members:; fTauSquared and those documented in DoUnfold(void). Int_t ScanLcurve(Int_t nPoint, Double_t tauMin, Double_t tauMax, TGraph** lCurve, TSpline** logTauX = 0, TSpline** logTauY = 0); scan the L curve; nPoint: number of points on the resulting curve; tauMin: smallest tau value to study; tauMax: largest tau value to study; lCurve: the L curve as graph; logTauX: output spline of x-coordinates vs tau for the L c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:26493,clear,cleared,26493,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,2,['clear'],['cleared']
Usability,"ditor::fgEditorNamename of the default pad editor ""Ged""; static TGedEditor*fgFrameCreator; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static TVirtualPadEditor*TVirtualPadEditor::fgPadEditorsingleton editor dialog; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGedEditor* GetFrameCreator(); Returns TGedEditor that currently creates TGedFrames. void SetFrameCreator(TGedEditor* e); Set the TGedEditor that currently creates TGedFrames. TGedEditor(TCanvas* canvas = 0, UInt_t width = 175, UInt_t height = 20); Constructor of graphics editor. ~TGedEditor(); Editor destructor. void Update(TGedFrame* frame = 0); Virtual method that is called on any change in the dependent frames.; This implementation simply calls fPad Modified()/Update(). TGCompositeFrame* GetEditorTab(const char* name); Find or create tab with name. TGedTabInfo* GetEditorTabInfo(const char* name); Find or create tab with name. void CloseWindow(); Called when closed via WM close button. Calls Hide(). void ReinitWorkspace(); Clears windows in editor tab.; Unmap and withdraw currently shown frames and thus prepare for; construction of a new class layout or destruction. void SetGlobal(Bool_t global); Set editor global. void GlobalClosed(); Delete global editor if no canvas exists. void GlobalSetModel(TVirtualPad* , TObject* , Int_t ); Set canvas to global editor. void ConnectToCanvas(TCanvas* c); Connect this editor to the Selected signal of canvas 'c'. void DisconnectFromCanvas(); Disconnect this editor from the Selected signal of fCanvas. void SetCanvas(TCanvas* c); Change connection to another canvas. void SetModel(TVirtualPad* pad, TObject* obj, Int_t event); Activate object editors according to the selected object. void ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGedEditor.html:26639,simpl,simply,26639,root/html528/TGedEditor.html,https://root.cern,https://root.cern/root/html528/TGedEditor.html,4,['simpl'],['simply']
Usability,dleInput methods ;  CTMPWorkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStep;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elements of the output list ;  CTPackageDescription;  CTPacketizerThis class g,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:181182,simpl,simple,181182,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,dleInput methods ;  CTMPWorkerTreeFuncTemplated derivation of TMPWorkerTree handlign generic function tree processing ;  CTMPWorkerTreeSelTemplated derivation of TMPWorkerTree handlign selector tree processing ;  CTMrbSubevent_Caen;  CTMultiDimFitMultidimensional Fits in ROOT ;  CTMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects ;  CTMultiLayerPerceptron;  CTMutex;  CTMutexImp;  CTMySQLResult;  CTMySQLRow;  CTMySQLServer;  ►CTMySQLStatement;  CTParamData;  CTNamedBase class for all named ROOT classes ;  CTNDArray;  CTNDArrayRef;  CTNDArrayT;  CTNetFile;  CTNetFileStager;  CTNetSystem;  CTNetXNGFile;  CTNetXNGFileStager;  CTNetXNGSystem;  CTNeuron;  CTNewChainDlg;  CTNewQueryDlg;  CTNodeTNode description ;  CTNodeDivDescription of parameters to divide a 3-D geometry object ;  CTNonCopyable;  CTNonSplitBrowsableAllows a TBrowser to browse non-split branches as if they were split ;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorD,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:189749,simpl,simple,189749,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,2,['simpl'],['simple']
Usability,"dler*fInterruptHandler; TStringfSockPath; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance Chart:. TObject. TQObject. ←; TApplication. ←; TProofServ. TXHandler. ←; TXProofServ. Function documentation; TXProofServ(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TXProofServ(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleUrgentData(); Handle high priority data sent by the master or client. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. TProofServ::EQueryAction GetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); Get list of workers to be used from now on.; The list must be provided by the caller. Bool_t HandleError(const void* in = 0); Handle error on the input socket. Bool_t HandleInput(const void* in = 0); Handle asynchronous input on the input socket. void DisableTimeout(); Disable read timeout on the underlying socket. void EnableTimeout(); Enable read timeout on the underlying socket. void Terminate(Int_t status); Terminate the proof server. Int_t LockSession(const char* sessiontag, TProofLockPath** lck); Try locking query area of session tagged sessiontag.; The id of the locking file is returned in fid and must be; unlocked via UnlockQueryFile(fid). void ReleaseWorker(const char* ord); Send message to intermediate coordinator to release worker of last ordinal; ord. TXProofServ(Int_t* argc, char** argv, FILE* flog = 0). » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXProofServ.html:19261,resume,resume,19261,root/html602/TXProofServ.html,https://root.cern,https://root.cern/root/html602/TXProofServ.html,2,['resume'],['resume']
Usability,"dm; ; # For speed, bind and cache the Fill member functions,; histos = [ 'hpx', 'hpxpy', 'hprof', 'ntuple' ]; for name in histos:; exec('%sFill = %s.Fill' % (name,name)); ; # Fill histograms randomly.; px_ref, py_ref = ctypes.c_double(), ctypes.c_double(); kUPDATE = 1000; for i in range( 25000 ):; # Generate random values. Use ctypes to pass doubles by reference; rannor( px_ref, py_ref ); # Retrieve the generated values; px = px_ref.value; py = py_ref.value; ; pz = px*px + py*py; random = rndm(1); ; # Fill histograms.; hpx.Fill( px ); hpxpy.Fill( px, py ); hprof.Fill( px, pz ); ntuple.Fill( px, py, pz, random, i ); ; # Update display every kUPDATE events.; if i and i%kUPDATE == 0:; if i == kUPDATE:; hpx.Draw(); ; c1.Modified(); c1.Update(); ; if gSystem.ProcessEvents(): # allow user interrupt; break; ; # Destroy member functions cache.; for name in histos:; exec('del %sFill' % name); del histos; ; gBenchmark.Show( 'hsimple' ); ; # Save all objects in this file.; hpx.SetFillColor( 0 ); hfile.Write(); hpx.SetFillColor( 48 ); c1.Modified(); c1.Update(); ; # Note that the file is automatically closed when application terminates; # or when the file destructor is called.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TProfileProfile Histogram.Definition TProfile.h:32; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen, Enric Tejedor ; Definition in file hsimple.py. tutorialspyroothsimple.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8py.html:3361,simpl,simple,3361,doc/master/hsimple_8py.html,https://root.cern,https://root.cern/doc/master/hsimple_8py.html,1,['simpl'],['simple']
Usability,"do(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know ahead what character will be deleted.; To",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18433,undo,undo,18433,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"do-inverse is calculated . Tolerances and Scaling; The tolerance parameter (which is a member of this base class) plays a crucial role in all operations of the decomposition classes . It gives the user a powerful tool to monitor and steer the operations Its default value is sqrt(epsilon) where 1+epsilon = 1; If you do not want to be bothered by the following considerations, like in most other linear algebra packages, just set the tolerance with SetTol to an arbitrary small number .; The tolerance number is used by each decomposition method to decide whether the matrix is near singular, except of course SVD which can handle singular matrices . For each decomposition this will be checked in a different way; in LU the matrix is considered singular when, at some point in the decomposition, a diagonal element < fTol . Therefore, we had to set in the example above of the (10x10) Hilbert, which is near singular, the tolerance on 10e-12 . (The fact that we have to set the tolerance < sqrt(epsilon) is a clear indication that we are losing precision .); If the matrix is flagged as being singular, operations with the decomposition will fail and will return matrices/vectors that are invalid .; The observant reader will notice that by scaling the complete matrix by some small number the decomposition will detect a singular matrix . In this case the user will have to reduce the tolerance number by this factor . (For CPU time saving we decided not to make this an automatic procedure) .; Code for this could look as follows: const Double_t max_abs = Abs(a).Max();; const Double_t scale = TMath::Min(max_abs,1.);; a.SetTol(a.GetTol()*scale);; a#define a(i)Definition RSha256.hxx:99; double; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; For usage examples see $ROOTSYS/test/stressLinear.cxx ; Definition at line 33 of file TDecompBase.h. Public Member Functions;  TDecompBase ();  Default constructor. ;  ;  TDecompBase (const TDecompBa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDecompBase.html:3579,clear,clear,3579,doc/master/classTDecompBase.html,https://root.cern,https://root.cern/doc/master/classTDecompBase.html,1,['clear'],['clear']
Usability,"doUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube editor. ~TGeoTubeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Perform name change. void DoApply(); Slot for applying modifications. void DoModified(); Slot for signaling modifications. void DoUndo(); Slot for undoing last operation. void DoRmin(); Slot for rmin. void DoRmax(); Slot for rmax. void DoDz(); Slot for dz. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeEditor.html:21363,undo,undoing,21363,root/html534/TGeoTubeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTubeEditor.html,1,['undo'],['undoing']
Usability,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:50683,simpl,simply,50683,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,4,['simpl'],['simply']
Usability,"dobj, Int_t bufsize = 32000, Int_t splitlevel = 1); Create a new TTree BranchObject. Build a TBranchObject for an object of class classname.; addobj is the address of a pointer to an object of class classname.; IMPORTANT: classname must derive from TObject.; The class dictionary must be available (ClassDef in class header). This option requires access to the library where the corresponding class; is defined. Accessing one single data member in the object implies; reading the full object.; See the next Branch constructor for a more efficient storage; in case the entry consists of arrays of identical objects. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (eg 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. TBranch* BranchRef(); Build the optional branch supporting the TRefTable.; This branch will keep all the information to find the branches; containing referenced objects. At each Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:48346,simpl,simply,48346,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simply']
Usability,"domGenerator<TRandom3> rng(shuffleSeed);; 1440 ; 1441 // print weights before; 1442 if (fBuildNet && debug) {; 1443 Log() << ""Initial Deep Net Weights "" << Endl;; 1444 auto & weights_tensor = deepNet.GetLayerAt(0)->GetWeights();; 1445 for (size_t l = 0; l < weights_tensor.size(); ++l); 1446 weights_tensor[l].Print();; 1447 auto & bias_tensor = deepNet.GetLayerAt(0)->GetBiases();; 1448 bias_tensor[0].Print();; 1449 }; 1450 ; 1451 Log() << "" Start epoch iteration ..."" << Endl;; 1452 bool debugFirstEpoch = false;; 1453 bool computeLossInTraining = true; // compute loss in training or at test time; 1454 size_t nTrainEpochs = 0;; 1455 while (!converged) {; 1456 nTrainEpochs++;; 1457 trainingData.Shuffle(rng);; 1458 ; 1459 // execute all epochs; 1460 //for (size_t i = 0; i < batchesInEpoch; i += nThreads) {; 1461 ; 1462 Double_t trainingError = 0;; 1463 for (size_t i = 0; i < batchesInEpoch; ++i ) {; 1464 // Clean and load new batches, one batch for one slave net; 1465 //batches.clear();; 1466 //batches.reserve(nThreads);; 1467 //for (size_t j = 0; j < nThreads; j++) {; 1468 // batches.push_back(trainingData.GetTensorBatch());; 1469 //}; 1470 if (debugFirstEpoch) std::cout << ""\n\n----- batch # "" << i << ""\n\n"";; 1471 ; 1472 auto my_batch = trainingData.GetTensorBatch();; 1473 ; 1474 if (debugFirstEpoch); 1475 std::cout << ""got batch data - doing forward \n"";; 1476 ; 1477#ifdef DEBUG; 1478 ; 1479 Architecture_t::PrintTensor(my_batch.GetInput(),""input tensor"",true);; 1480 typename Architecture_t::Tensor_t tOut(my_batch.GetOutput());; 1481 typename Architecture_t::Tensor_t tW(my_batch.GetWeights());; 1482 Architecture_t::PrintTensor(tOut,""label tensor"",true) ;; 1483 Architecture_t::PrintTensor(tW,""weight tensor"",true) ;; 1484#endif; 1485 ; 1486 deepNet.Forward(my_batch.GetInput(), true);; 1487 // compute also loss; 1488 if (computeLossInTraining) {; 1489 auto outputMatrix = my_batch.GetOutput();; 1490 auto weights = my_batch.GetWeights();; 1491 trainingError += deepNet.Loss(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:58244,clear,clear,58244,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['clear'],['clear']
Usability,"domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does not starts with slash /, than top-name folder /Objects/ will be prepended. At any time one could unregister objects:; serv->Unregister(gr);; THttpServer does not take ownership over registered objects - they should be deleted by user.; If the objects content is changing in the application, one could enable monitoring flag in the browser - then objects view will be regularly updated.; 1.3 Command interface; THttpServer class provide simple interface to invoke command from web browser. One just register command like:; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"");; Element with name DoSomething will appear in the web browser and can be clicked. It will result in gROOT->ProcessLineSync(""SomeFunction()"") call. When registering command, one could specify icon name which will be displayed with the command.; serv->RegisterCommand(""/DoSomething"",""SomeFunction()"", ""/rootsys/icons/ed_execute.png"");; In example usage of images from $ROOTSYS/icons directory is shown. One could prepend button; string to the icon name to let browser show command as extra button. In last case one could hide command element from elements list:; serv->Hide(""/DoSomething"");; One can find example of command interface usage in tutorials/http/httpcontrol.C macro.; 1.4 Configuring user access; By default, the http server is open for anonymous access. One could restrict the access to the server for authenticated users only. First of all, one shou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:3252,simpl,simple,3252,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['simpl'],['simple']
Usability,"down the tree, one cycles through the axes used to select the splitting planes. (For example, the root would have an x-aligned plane, the root's children would both have y-aligned planes, the root's grandchildren would all have z-aligned planes, and so on.) At each step, the point selected to create the splitting plane is the median of the points being put into the kd-tree, with respect to their coordinates in the axis being used. (Note the assumption that we feed the entire set of points into the algorithm up-front.); This method leads to a balanced kd-tree, in which each leaf node is about the same distance from the root. However, balanced trees are not necessarily optimal for all applications. The following pseudo-code illustrates this canonical construction procedure (NOTE, that the procedure used by the TKDTree class is a bit different, the following pseudo-code is given as a simple illustration of the concept):; function kdtree (list of points pointList, int depth); {; if pointList is empty; return nil;; else; {; // Select axis based on depth so that axis cycles through all valid values; var int axis := depth mod k;; ; // Sort point list and choose median as pivot element; select median from pointList;; ; // Create node and construct subtrees; var tree_node node;; node.location := median;; node.leftChild := kdtree(points in pointList before median, depth+1);; node.rightChild := kdtree(points in pointList after median, depth+1);; return node;; }; }; pointsOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t pointsDefinition TGWin32VirtualXProxy.cxx:148; Our construction method is optimized to save memory, and differs a bit from the constraints above. In particular, the division axis is chosen as the one with the biggest spread, and the point to create the splitting plane is chosen so, that one of the two subtrees contains exactly 2^k terminal node",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:2980,simpl,simple,2980,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['simpl'],['simple']
Usability,"dows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoBBoxEditor.html:22304,undo,undoing,22304,root/html604/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html604/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"dows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for volume editor. ~TGeoBBoxEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Update editor for a new selected box. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current parameters. void DoModified(); Slot for modifying current parameters. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for Dx modification. void DoDy(); Slot for Dy modification. void DoDz(); Slot for Dz modification. void DoOx(); Slot for Ox modification. void DoOy(); Slot for Oy modification. void DoOz(); Slot for Oz modification. TGeoBBoxEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoBBoxEditor.html:22304,undo,undoing,22304,root/html602/TGeoBBoxEditor.html,https://root.cern,https://root.cern/root/html602/TGeoBBoxEditor.html,1,['undo'],['undoing']
Usability,"drawn with different graphics options in different pads. When a displayed histogram is deleted, its image is automatically removed from the pad. To create a copy of the histogram when drawing it, you can use TH1::DrawClone(). This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use TH1::DrawNormalized() to draw a normalized copy of a histogram.; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the new sum of weights (excluding under and overflow) is equal to norm .; Note that the returned normalized histogram is not added to the list of histograms in the current directory in memory. It is the user’s responsibility to delete this histogram. The kCanDelete bit is set for the returned object. If a pad containing this copy is cleared, the histogram will be automatically deleted. See “Draw Options” for the list of options.; 3.8.1 Setting the Style; Histograms use the current style gStyle, which is the global object of class TStyle. To change the current style for histograms, the TStyle class provides a multitude of methods ranging from setting the fill color to the axis tick marks. Here are a few examples:; void SetHistFillColor(Color_t color = 1); void SetHistFillStyle(Style_t styl = 0); void SetHistLineColor(Color_t color = 1); void SetHistLineStyle(Style_t styl = 0); void SetHistLineWidth(Width_t width = 1); When you change the current style and would like to propagate the change to a previously created histogram you can call TH1::UseCurrentStyle(). You will need to call UseCurrentStyle() on each histogram. When reading many histograms from a file and you wish to update them to the current style, you can use gROOT::ForceStyle and all histograms read after this call will be updated to use the current style. See “Gra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:83650,clear,cleared,83650,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['cleared']
Usability,"drenCount ; (; ). inlinefinalvirtual . Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 235 of file RLoopManager.hxx. ◆ InitNodes(). void RLoopManager::InitNodes ; (; ). private . Initialize all nodes of the functional graph before running the event loop. ; This method is called once per event-loop and performs generic initialization operations that do not depend on the specific processing slot (i.e. operations that are common for all threads). ; Definition at line 791 of file RLoopManager.cxx. ◆ InitNodeSlots(). void RLoopManager::InitNodeSlots ; (; TTreeReader * ; r, . unsigned int ; slot . ). private . Build TTreeReaderValues for all nodes This method loops over all filters, actions and other booked objects and calls their InitSlot method, to get them ready for running a task. ; Definition at line 728 of file RLoopManager.cxx. ◆ Jit(). void RLoopManager::Jit ; (; ). Add RDF nodes that require just-in-time compilation to the computation graph. ; This method also clears the contents of GetCodeToJit(). ; Definition at line 848 of file RLoopManager.cxx. ◆ JitDeclarations(). void ROOT::Detail::RDF::RLoopManager::JitDeclarations ; (; ). ◆ operator=() [1/2]. RLoopManager & ROOT::Detail::RDF::RLoopManager::operator= ; (; const RLoopManager & ; ). delete . ◆ operator=() [2/2]. RLoopManager & ROOT::Detail::RDF::RLoopManager::operator= ; (; RLoopManager && ; ). delete . ◆ PartialReport(). void ROOT::Detail::RDF::RLoopManager::PartialReport ; (; ROOT::RDF::RCutFlowReport & ; ); const. inlinefinalvirtual . End of recursive chain of calls, does nothing. ; Implements ROOT::Detail::RDF::RNodeBase.; Definition at line 233 of file RLoopManager.hxx. ◆ Register() [1/5]. void RLoopManager::Register ; (; RDefineBase * ; definePtr). Definition at line 984 of file RLoopManager.cxx. ◆ Register() [2/5]. void RLoopManager::Register ; (; RDFInternal::RActionBase * ; actionPtr). Definition at line 946 of file RLoopManager.cxx. ◆ Register() [3/5]. void RLoopManager::Register ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html:21903,clear,clears,21903,doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1RDF_1_1RLoopManager.html,1,['clear'],['clears']
Usability,"dth; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19118,progress bar,progress bar,19118,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-05-01 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewerEditor.html:24162,guid,guides,24162,root/html534/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html534/TGLViewerEditor.html,1,['guid'],['guides']
Usability,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-02 15:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGLViewerEditor.html:24984,guid,guides,24984,root/html604/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html604/TGLViewerEditor.html,1,['guid'],['guides']
Usability,"dths. void DoCameraOverlay(); Update viewer with GUI state. void DoCameraCenterExt(); Set external camera center. void DoCaptureCenter(); Capture camera-center via picking. void DoDrawCameraCenter(); Draw camera center. void UpdateCameraCenter(); Update current camera with GUI state. void DoAnnotation(); Create annotation via picking. void UpdateViewerAxes(Int_t id); Update viewer with GUI state. void UpdateViewerReference(); Update viewer with GUI state. TGNumberEntry* MakeLabeledNEntry(TGCompositeFrame* p, const char* name, Int_t labelw, Int_t nd = 7, Int_t s = 5); Helper function to create fixed width TGLabel and TGNumberEntry in same row. void CreateStyleTab(); Creates ""Style"" tab. void CreateGuidesTab(); Create ""Guides"" tab. void CreateClippingTab(); Create GUI controls - clip type (none/plane/box) and plane/box properties. void CreateExtrasTab(); Create Extra Tab controls - camera rotator and stereo. void UpdateReferencePosState(); Enable/disable reference position (x/y/z) number edits based on; reference check box. void SetGuides(); Configuration of guides GUI called from SetModel(). void SetRotatorMode(). void UpdateRotator(); Update rotator related variables. void DoRotatorStart(); Start auto-rotator. void DoRotatorStop(); Stop auto-rotator. void DoASavImageGUIBaseName(const char* t); Update base-name. void DoASavImageGUIOutMode(Int_t m); Update output mode. void DoASavImageStart(); Start auto-rotator image auto-save. void DoASavImageStop(); Stop auto-rotator image auto-save. void UpdateStereo(); Update stereo related variables. TGLViewerEditor(const TGLViewerEditor& ). void DetachFromPad(); {fIsInPad = kFALSE;}. » Author: Alja Mrak-Tadel, Matevz Tadel, Timur Pocheptsov 08/03/2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-06-30 14:54; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLViewerEditor.html:24984,guid,guides,24984,root/html602/TGLViewerEditor.html,https://root.cern,https://root.cern/root/html602/TGLViewerEditor.html,1,['guid'],['guides']
Usability,"dual axis but it does not give any hints about the correlations between the axes.; Avery simple technique allows to make the clusters appearing: Instead of painting solid lines we paint dotted lines. The cluttering of each individual line is reduced and the clusters show clearly as we can see on the next figure. The spacing between the dots is a parameter which can be adjusted in order to get the best results. Using dotted lines is a very simple method to reduce the cluttering. Interactivity is a very important aspect of the Parallel Coordinates plots. To really explore the data set it is essential to act directly with the events and the axes. For instance, changing the axes order may show clusters which were not visible in a different order. On the next figure the axes order has been changed interactively. We can see that many more clusters appear and all the “random spheres” we put in the data set are now clearly visible. Having moved the variables u,v,w after the variables x,y,z the correlation between these two sets of variables is clear also. Axis order is very important to show clusters. To pursue further data sets exploration we have implemented the possibility to define selections interactively. A selection is a set of ranges combined together. Within a selection, ranges along the same axis are combined with logical OR, and ranges on different axes with logical AND. A selection is displayed on top of the complete data set using its own color. Only the events fulfilling the selection criteria (ranges) are displayed. Ranges are defined interactively using cursors, like on the first axis on the figure. Several selections can be defined at the same time, each selection having its own color. Selections are set of ranges which can be defined interactively. Several selections can been defined. Each cluster is now clearly visible and the zone with crossing clusters is now understandable whereas, without any selection or with only a single one, it was not easy to und",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:614561,clear,clear,614561,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clear']
Usability,"duplicates and with the ability; to truncate the list by printEvalErrors. This is the standard mode of error logging; during MINUIT operations. If enableEvalErrorLogging() is false, all errors; reported through this method are passed for immediate printing through RooMsgService.; A string with server names and values is constructed automatically for error logging; purposes, unless a custom string with similar information is passed as argument. void clearEvalErrorLog(); Clear the stack of evaluation error messages. void printEvalErrors(ostream& os = std::cout, Int_t maxPerNode = 10000000); Print all outstanding logged evaluation error on the given ostream. If maxPerNode; is zero, only the number of errors for each source (object with unique name) is listed.; If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; per source of errors. A truncation message is shown if there were more errors logged; than shown. Int_t numEvalErrors(); Return the number of logged evaluation errors since the last clearing. void fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization choice is only fixed for those; RooAddPdf components that have the default 'automatic' interpretation of; coefficients (i.e. the interpretation is defined by the observables passed; to getVal()). If force is true, also RooAddPdf that already have a fixed; interpretation are changed to a new fixed interpretation. void fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); Fix the interpretation of the coefficient of any RooAddPdf component in; the expression tree headed by this object to the given set of observables. If the force flag is false, the normalization range choice is only fixed for those; RooAddPdf components that currently use the de",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:63138,clear,clearing,63138,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,7,['clear'],['clearing']
Usability,"d selectNormalization (const RooArgSet *depSet=nullptr, bool force=false);  Interface function to force use of a given set of observables to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProdPdf.html:74523,clear,clearShapeDirty,74523,doc/master/classRooProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooProdPdf.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"e & ; ). privatedelete . ◆ TGUndockedFrame() [2/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGWindow * ; p = nullptr, . TGDockableFrame * ; dockable = nullptr . ). Create the undocked (transient) frame. ; Definition at line 176 of file TGDockableFrame.cxx. ◆ ~TGUndockedFrame(). TGUndockedFrame::~TGUndockedFrame ; (; ). override . Delete undocked frame. Puts back dockable frame in its original container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 78 of file TGDockableFrame.h. ◆ FixSize(). void TGUndockedFrame::FixSize ; (; ). Fix the size of the undocked frame so it cannot be changed via the WM. ; Definition at line 203 of file TGDockableFrame.cxx. ◆ IsA(). TClass * TGUndockedFrame::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGTransientFrame.; Definition at line 78 of file TGDockableFrame.h. ◆ operator=(). TGUndockedFrame & TGUndockedFrame::operator= ; (; const TGUndockedFrame & ; ). privatedelete . ◆ Streamer(). void TGUndockedFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGTransientFrame. ◆ StreamerNVirtual(). void TGUndoc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:37491,undo,undocked,37491,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"e 'optStr' can contain a comma-separated list of servers for which the information is wanted. If ':lite:' (case insensitive) is specified in 'optStr' only the global information in the TFileCollection is retrieved; useful to only get the list of available datasets. ; Reimplemented in TProofLite.; Definition at line 10809 of file TProof.cxx. ◆ GetDataSetSrvMaps(). static TList * TProof::GetDataSetSrvMaps ; (; const TString & ; srvmaps). staticprivate . ◆ GetEnabledPackages(). TList * TProof::GetEnabledPackages ; (; ); const. inlineprotected . Definition at line 735 of file TProof.h. ◆ Getenv(). TString TProof::Getenv ; (; const char * ; env, . const char * ; ord = ""0"" . ). Get value of environment variable 'env' on node 'ord'. ; Definition at line 6644 of file TProof.cxx. ◆ GetEnvVars(). const TList * TProof::GetEnvVars ; (; ). static . Get environemnt variables. ; Definition at line 11751 of file TProof.cxx. ◆ GetFeedbackList(). TList * TProof::GetFeedbackList ; (; ); const. Return feedback list. ; Definition at line 10033 of file TProof.cxx. ◆ GetFileInCmd(). Bool_t TProof::GetFileInCmd ; (; const char * ; cmd, . TString & ; fn . ). staticprotected . Static method to extract the filename (if any) form a CINT command. ; Returns kTRUE and the filename in 'fn'; returns kFALSE if not found or not appliable. ; Definition at line 6495 of file TProof.cxx. ◆ GetGroup(). const char * TProof::GetGroup ; (; ); const. inline . Definition at line 907 of file TProof.h. ◆ GetImage(). const char * TProof::GetImage ; (; ); const. inline . Definition at line 910 of file TProof.h. ◆ GetInputData(). Int_t TProof::GetInputData ; (; TList * ; input, . const char * ; cachedir, . TString & ; emsg . ). staticprotected . Get the input data from the file defined in the input list. ; Definition at line 12413 of file TProof.cxx. ◆ GetInputList(). TList * TProof::GetInputList ; (; ). Get input list. ; Definition at line 9753 of file TProof.cxx. ◆ GetLastLog(). TMacro * TProof::GetLastLog ; (; )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:94682,feedback,feedback,94682,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"e () const;  Returns the name of undo command. ;  ; TClass * IsA () const override;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; void ls (Option_t *option="""") const override;  ls this command and merged commands ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void Redo (Option_t *option="""");  Execute command and then merge commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void Undo (Option_t *option="""");  Un-execute all merged commands and the command. ;  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:7617,undo,undo,7617,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"e (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::unique_ptr< RooRatio > makeRatio (const char *name, const char *title, RooArgList &nr, RooArgList &dr);  Return the RooRatio form of products and denominators of morphing functions. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:56012,clear,clearEvalErrorLog,56012,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['clear'],['clearEvalErrorLog']
Usability,"e . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:2246,simpl,simple,2246,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['simpl'],['simple']
Usability,"e . Find best visual, i.e. ; the one with the most planes and TrueColor or DirectColor. Sets fVisual, fDepth, fRootWin, fColormap, fBlackPixel and fWhitePixel. ; Definition at line 780 of file TGX11.cxx. ◆ FindColor(). Int_t TGX11::FindColor ; (; ULong_t ; pixel, . ULong_t * ; orgcolors, . Int_t ; ncolors . ). private . Returns index in orgcolors (and fNewColors) for pixel. ; Definition at line 3019 of file TGX11.cxx. ◆ FindRWindow(). Window_t TGX11::FindRWindow ; (; Window_t ; win, . Window_t ; dragwin, . Window_t ; input, . int ; x, . int ; y, . int ; maxd . ). overridevirtual . Recursively search in the children of Window for a Window which is at location x, y and is DND aware, with a maximum depth of maxd. ; Possibility to exclude dragwin and input. ; Reimplemented from TVirtualX.; Definition at line 2802 of file GX11Gui.cxx. ◆ FindUsableVisual(). void TGX11::FindUsableVisual ; (; RXVisualInfo * ; vlist, . Int_t ; nitems . ). private . Check if visual is usable, if so set fVisual, fDepth, fColormap, fBlackPixel and fWhitePixel. ; Definition at line 848 of file TGX11.cxx. ◆ FreeColor(). void TGX11::FreeColor ; (; Colormap_t ; cmap, . ULong_t ; pixel . ). overridevirtual . Free color cell with specified pixel value. ; Reimplemented from TVirtualX.; Definition at line 1391 of file GX11Gui.cxx. ◆ FreeFontNames(). void TGX11::FreeFontNames ; (; char ** ; fontlist). overridevirtual . Free list of font names. ; Reimplemented from TVirtualX.; Definition at line 2605 of file GX11Gui.cxx. ◆ FreeFontStruct(). void TGX11::FreeFontStruct ; (; FontStruct_t ; fs). overridevirtual . Free font structure returned by GetFontStruct(). ; Reimplemented from TVirtualX.; Definition at line 2123 of file GX11Gui.cxx. ◆ GetCharacterUp(). void TGX11::GetCharacterUp ; (; Float_t & ; chupx, . Float_t & ; chupy . ). overridevirtual . Return character up vector. ; Reimplemented from TVirtualX.; Definition at line 899 of file TGX11.cxx. ◆ GetColor(). XColor_t & TGX11::GetColor ; (; Int_t ; cid)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:74633,usab,usable,74633,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,1,['usab'],['usable']
Usability,"e . ◆ Randomize(). void TMultiLayerPerceptron::Randomize ; (; ); const. Randomize the weights. ; Definition at line 1239 of file TMultiLayerPerceptron.cxx. ◆ Result(). Double_t TMultiLayerPerceptron::Result ; (; Int_t ; event, . Int_t ; index = 0 . ); const. Computes the output for a given event. ; Look at the output neuron designed by index. ; Definition at line 1033 of file TMultiLayerPerceptron.cxx. ◆ SetData(). void TMultiLayerPerceptron::SetData ; (; TTree * ; data). Set the data source. ; Definition at line 590 of file TMultiLayerPerceptron.cxx. ◆ SetDelta(). void TMultiLayerPerceptron::SetDelta ; (; Double_t ; delta). Sets Delta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 720 of file TMultiLayerPerceptron.cxx. ◆ SetEpsilon(). void TMultiLayerPerceptron::SetEpsilon ; (; Double_t ; eps). Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 710 of file TMultiLayerPerceptron.cxx. ◆ SetEta(). void TMultiLayerPerceptron::SetEta ; (; Double_t ; eta). Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 700 of file TMultiLayerPerceptron.cxx. ◆ SetEtaDecay(). void TMultiLayerPerceptron::SetEtaDecay ; (; Double_t ; ed). Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ; Definition at line 730 of file TMultiLayerPerceptron.cxx. ◆ SetEventWeight(). void TMultiLayerPerceptron::SetEventWeight ; (; const char * ; branch). Set the event weight. ; Definition at line 606 of file TMultiLayerPerceptron.cxx. ◆ SetGammaDelta(). void TMultiLayerPerceptron::SetGammaDelta ; (; TMatrixD & ; gamma, . TMatrixD & ; delta, . Double_t * ; buffer . ). protected . Sets the gamma \((g_{(t+1)}-g_{(t)})\) and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:44963,learn,learning,44963,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"e : Separation; : -------------------------------; : 1 : m_bb : 9.511e-02; : 2 : m_wbb : 4.268e-02; : 3 : m_wwbb : 4.178e-02; : 4 : m_jjj : 2.825e-02; : 5 : m_jlv : 1.999e-02; : 6 : m_jj : 3.834e-03; : 7 : m_lv : 3.699e-03; : -------------------------------; Factory : Train method: Likelihood for Classification; : ; : ; : ␛[1m================================================================␛[0m; : ␛[1mH e l p f o r M V A m e t h o d [ Likelihood ] :␛[0m; : ; : ␛[1m--- Short description:␛[0m; : ; : The maximum-likelihood classifier models the data with probability ; : density functions (PDF) reproducing the signal and background; : distributions of the input variables. Correlations among the ; : variables are ignored.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : Required for good performance are decorrelated input variables; : (PCA transformation via the option ""VarTransform=Decorrelate""; : may be tried). Irreducible non-linear correlations may be reduced; : by precombining strongly correlated input variables, or by simply; : removing one of the variables.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : High fidelity PDF estimates are mandatory, i.e., sufficient training ; : statistics is required to populate the tails of the distributions; : It would be a surprise if the default Spline or KDE kernel parameters; : provide a satisfying fit to the data. The user is advised to properly; : tune the events per bin and smooth options in the spline cases; : individually per variable. If the KDE kernel is used, the adaptive; : Gaussian kernel may lead to artefacts, so please always also try; : the non-adaptive one.; : ; : All tuning parameters must be adjusted individually for each input; : variable!; : ; : <Suppress this message by specifying ""!H"" in the booking option>; : ␛[1m================================================================␛[0m; : ; : Filling reference histograms; : Building PDF out of reference histograms; : Elapsed time for t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html:16976,simpl,simply,16976,doc/master/TMVA__Higgs__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8C.html,2,['simpl'],['simply']
Usability,"e = 0, Bool_t useAxisBinning = kTRUE); TH1*GetDeltaSysTau(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; TH2*GetEmatrixInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysBackgroundUncorr(const char* bgrSource, const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); voidTUnfoldSys::GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidTUnfoldSys::GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); TH2*GetEmatrixSysUncorr(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); TH2*GetEmatrixTotal(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE); Double_tTUnfold::GetEpsMatrix() const; TH1*GetFoldedOutput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE, Bool_t addBgr = kFALSE) const; virtual const char*TObject::GetIconName() const; TH1*GetInput(const char* histogramName, const char* histogramTitle = 0, const char* distributionName = 0, const char* projectionMode = 0, Bool_t useAxisBinning = kTRUE) const; const TUnfoldBinning*GetInputBinning(const char* distribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:8680,clear,clearEmat,8680,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,3,['clear'],['clearEmat']
Usability,"e ASCII data file. ;  ; template Long64_t FillNtupleFromStream< Double_t, TNtupleD > (std::istream &, TNtupleD &, char, bool);  ; template Long64_t FillNtupleFromStream< Float_t, TNtuple > (std::istream &, TNtuple &, char, bool);  ; bool NextCharacterIsEOL (std::istream &input);  Either '\r' | '\n' or eof of some problem. ;  ; void SkipComment (std::istream &input);  Skips everything from '#' to (including) '\r' or '\n'. ;  ; void SkipEmptyLines (std::istream &input);  Skips empty lines (newline-characters), ws-lines (consisting only of whitespace characters + newline-characters). ;  ; void SkipWSCharacters (std::istream &input);  Skip whitespace characters, but not newline-characters we support ('\r' or '\n'). ;  . Function Documentation. ◆ FillNtupleFromStream(). template<class DataType , class Tuple > . Long64_t ROOT::TreeUtils::FillNtupleFromStream ; (; std::istream & ; inputStream, . Tuple & ; tuple, . char ; delimiter, . bool ; strictMode . ). Function to fill tuples (TNtuple/TNtupleD) from a simple ASCII data file. ; With auto and decltype - we can get rid of DataType parameter :) (or with a simple typedef inside ntuple class). An input file consists of non-empty lines (separated by newline-characters), possibly empty lines, and comments (treated as empty lines). Each non-empty line should contain N numbers - entry for a tuple. Non-strict mode lets you to have newline-characters inside a tuple's row (as it worked in ROOT prior to v5.3xxx). ; Definition at line 80 of file TreeUtils.cxx. ◆ FillNtupleFromStream< Double_t, TNtupleD >(). template Long64_t ROOT::TreeUtils::FillNtupleFromStream< Double_t, TNtupleD > ; (; std::istream & ; , . TNtupleD & ; , . char ; , . bool ;  . ). ◆ FillNtupleFromStream< Float_t, TNtuple >(). template Long64_t ROOT::TreeUtils::FillNtupleFromStream< Float_t, TNtuple > ; (; std::istream & ; , . TNtuple & ; , . char ; , . bool ;  . ). ◆ NextCharacterIsEOL(). bool ROOT::TreeUtils::NextCharacterIsEOL ; (; std::istream & ; input). Either",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html:1636,simpl,simple,1636,doc/master/namespaceROOT_1_1TreeUtils.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1TreeUtils.html,2,['simpl'],['simple']
Usability,"e Binary search tree including a volume search method. ; Definition at line 65 of file BinarySearchTree.h. Public Member Functions;  BinarySearchTree (const BinarySearchTree &b);  copy constructor that creates a true copy, i.e. a completely independent tree ;  ;  BinarySearchTree (void);  default constructor ;  ; virtual ~BinarySearchTree (void);  destructor ;  ; void CalcStatistics (TMVA::Node *n=nullptr);  calculate basic statistics (mean, rms for each variable) ;  ; virtual const char * ClassName () const;  ; void Clear (TMVA::Node *n=nullptr);  clear nodes ;  ; virtual Node * CreateNode (UInt_t) const;  ; virtual BinaryTree * CreateTree () const;  ; Double_t Fill (const std::vector< TMVA::Event * > &events, const std::vector< Int_t > &theVars, Int_t theType=-1);  create the search tree from the event collection using ONLY the variables specified in ""theVars"" ;  ; Double_t Fill (const std::vector< TMVA::Event * > &events, Int_t theType=-1);  create the search tree from the events in a TTree using ALL the variables specified included in the Event ;  ; UInt_t GetPeriode (void) const;  ; Double_t GetSumOfWeights (Int_t theType) const;  return the sum of event (node) weights ;  ; Double_t GetSumOfWeights (void) const;  return the sum of event (node) weights ;  ; void Insert (const Event *);  insert a new ""event"" in the binary tree ;  ; virtual TClass * IsA () const;  ; Float_t Max (Types::ESBType sb, UInt_t var);  access to Maximum for signal and background for each variable ;  ; Float_t Mean (Types::ESBType sb, UInt_t var);  access to mean for signal and background for each variable ;  ; Float_t Min (Types::ESBType sb, UInt_t var);  access to Minimum for signal and background for each variable ;  ; void NormalizeTree ();  Normalisation of tree. ;  ; Float_t RMS (Types::ESBType sb, UInt_t var);  access to RMS for signal and background for each variable ;  ; Float_t RMS (UInt_t var);  access to RMS for each variable ;  ; BinarySearchTreeNode * Search (Event *event) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html:893,clear,clear,893,doc/master/classTMVA_1_1BinarySearchTree.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1BinarySearchTree.html,1,['clear'],['clear']
Usability,"e Graph Example . i 0 0.000000 1.986693 ; i 1 0.100000 2.955202 ; i 2 0.200000 3.894183 ; i 3 0.300000 4.794255 ; i 4 0.400000 5.646425 ; i 5 0.500000 6.442177 ; i 6 0.600000 7.173561 ; i 7 0.700000 7.833269 ; i 8 0.800000 8.414710 ; i 9 0.900000 8.912074 ; i 10 1.000000 9.320391 ; i 11 1.100000 9.635582 ; i 12 1.200000 9.854497 ; i 13 1.300000 9.974950 ; i 14 1.400000 9.995736 ; i 15 1.500000 9.916648 ; i 16 1.600000 9.738476 ; i 17 1.700000 9.463001 ; i 18 1.800000 9.092974 ; i 19 1.900000 8.632094 ; ; from __future__ import print_function; from ROOT import TCanvas, TGraph; from ROOT import gROOT; from math import sin; from array import array; ; ; c1 = TCanvas( 'c1', 'A Simple Graph Example', 200, 10, 700, 500 ); ; c1.SetFillColor( 42 ); c1.SetGrid(); ; n = 20; x, y = array( 'd' ), array( 'd' ); ; for i in range( n ):; x.append( 0.1*i ); y.append( 10*sin( x[i]+0.2 ) ); print(' i %i %f %f ' % (i,x[i],y[i])); ; gr = TGraph( n, x, y ); gr.SetLineColor( 2 ); gr.SetLineWidth( 4 ); gr.SetMarkerColor( 4 ); gr.SetMarkerStyle( 21 ); gr.SetTitle( 'a simple graph' ); gr.GetXaxis().SetTitle( 'X title' ); gr.GetYaxis().SetTitle( 'Y title' ); gr.Draw( 'ACP' ); ; # TCanvas.Update() draws the frame, after which one can change it; c1.Update(); c1.GetFrame().SetFillColor( 21 ); c1.GetFrame().SetBorderSize( 12 ); c1.Modified(); c1.Update(); # If the graph does not appear, try using the ""i"" flag, e.g. ""python3 -i graph.py""; # This will access the interactive mode after executing the script, and thereby persist; # long enough for the graph to appear.; SetFillColorOption_t Option_t SetFillColorDefinition TGWin32VirtualXProxy.cxx:50; TCanvasThe Canvas class.Definition TCanvas.h:23; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; SetBorderSizec SetBorderSize(2); AuthorWim Lavrijsen ; Definition in file graph.py. tutorialspyrootgraph.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_8py.html:1284,simpl,simple,1284,doc/master/graph_8py.html,https://root.cern,https://root.cern/doc/master/graph_8py.html,1,['simpl'],['simple']
Usability,"e RWebWindow.cxx. Friends And Related Symbol Documentation. ◆ RFileDialog. friend class RFileDialog. friend . Definition at line 57 of file RWebWindow.hxx. ◆ RWebDisplayHandle. friend class RWebDisplayHandle. friend . Definition at line 56 of file RWebWindow.hxx. ◆ RWebWindowsManager. friend class RWebWindowsManager. friend . Definition at line 54 of file RWebWindow.hxx. ◆ RWebWindowWSHandler. friend class RWebWindowWSHandler. friend . Definition at line 55 of file RWebWindow.hxx. Member Data Documentation. ◆ fCallbacksThrdId. std::thread::id ROOT::RWebWindow::fCallbacksThrdId. private . ! thread id where callbacks should be invoked ; Definition at line 160 of file RWebWindow.hxx. ◆ fCallbacksThrdIdSet. bool ROOT::RWebWindow::fCallbacksThrdIdSet {false}. private . ! flag indicating that thread id is assigned ; Definition at line 161 of file RWebWindow.hxx. ◆ fClearOnClose. std::shared_ptr<void> ROOT::RWebWindow::fClearOnClose. private . ! entry which is cleared when last connection is closed ; Definition at line 176 of file RWebWindow.hxx. ◆ fClientVersion. std::string ROOT::RWebWindow::fClientVersion. private . ! configured client version, used as prefix in scripts URL ; Definition at line 169 of file RWebWindow.hxx. ◆ fConn. ConnectionsList_t ROOT::RWebWindow::fConn. private . ! list of all accepted connections ; Definition at line 150 of file RWebWindow.hxx. ◆ fConnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fConnCallback. private . ! callback for connect event ; Definition at line 157 of file RWebWindow.hxx. ◆ fConnCnt. unsigned ROOT::RWebWindow::fConnCnt {0}. private . ! counter of new connections to assign ids ; Definition at line 148 of file RWebWindow.hxx. ◆ fConnLimit. unsigned ROOT::RWebWindow::fConnLimit {1}. private . ! number of allowed active connections ; Definition at line 152 of file RWebWindow.hxx. ◆ fConnMutex. std::mutex ROOT::RWebWindow::fConnMutex. mutableprivate . ! mutex used to protect connection list ; Definition at line 151 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:53709,clear,cleared,53709,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"e RWebWindow.cxx. Friends And Related Symbol Documentation. ◆ RFileDialog. friend class RFileDialog. friend . Definition at line 59 of file RWebWindow.hxx. ◆ RWebDisplayHandle. friend class RWebDisplayHandle. friend . Definition at line 58 of file RWebWindow.hxx. ◆ RWebWindowsManager. friend class RWebWindowsManager. friend . Definition at line 56 of file RWebWindow.hxx. ◆ RWebWindowWSHandler. friend class RWebWindowWSHandler. friend . Definition at line 57 of file RWebWindow.hxx. Member Data Documentation. ◆ fCallbacksThrdId. std::thread::id ROOT::RWebWindow::fCallbacksThrdId. private . ! thread id where callbacks should be invoked ; Definition at line 163 of file RWebWindow.hxx. ◆ fCallbacksThrdIdSet. bool ROOT::RWebWindow::fCallbacksThrdIdSet {false}. private . ! flag indicating that thread id is assigned ; Definition at line 164 of file RWebWindow.hxx. ◆ fClearOnClose. std::shared_ptr<void> ROOT::RWebWindow::fClearOnClose. private . ! entry which is cleared when last connection is closed ; Definition at line 179 of file RWebWindow.hxx. ◆ fClientVersion. std::string ROOT::RWebWindow::fClientVersion. private . ! configured client version, used as prefix in scripts URL ; Definition at line 172 of file RWebWindow.hxx. ◆ fConn. ConnectionsList_t ROOT::RWebWindow::fConn. private . ! list of all accepted connections ; Definition at line 153 of file RWebWindow.hxx. ◆ fConnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fConnCallback. private . ! callback for connect event ; Definition at line 160 of file RWebWindow.hxx. ◆ fConnCnt. unsigned ROOT::RWebWindow::fConnCnt {0}. private . ! counter of new connections to assign ids ; Definition at line 151 of file RWebWindow.hxx. ◆ fConnLimit. unsigned ROOT::RWebWindow::fConnLimit {1}. private . ! number of allowed active connections ; Definition at line 155 of file RWebWindow.hxx. ◆ fConnMutex. std::mutex ROOT::RWebWindow::fConnMutex. mutableprivate . ! mutex used to protect connection list ; Definition at line 154 of fi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:52593,clear,cleared,52593,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"e TProofPlayer.h. ◆ DeleteDrawFeedback(). void TProofPlayer::DeleteDrawFeedback ; (; TDrawFeedback * ; f). overridevirtual . Delete draw feedback object. ; Implements TVirtualProofPlayer.; Definition at line 750 of file TProofPlayer.cxx. ◆ DrawCanvas(). Int_t TProofPlayer::DrawCanvas ; (; TObject * ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. ◆ DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet * ; set, . const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). overridevirtual . Draw (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 1658 of file TProofPlayer.cxx. ◆ Feedback(). void TProofPlayer::Feedback ; (; TList * ; objs). overridevirtual . Set feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 724 of file TProofPlayer.cxx. ◆ FeedBackCanvas(). void TProofPlayer::FeedBackCanvas ; (; const char * ; name, . Bool_t ; create . ). Create/destroy a named canvas for feedback. ; Definition at line 1765 of file TProofPlayer.cxx. ◆ Finalize() [1/2]. Long64_t TProofPlayer::Finalize ; (; Bool_t ; force = kFALSE, . Bool_t ; sync = kFALSE . ). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1571 of file TProofPlayer.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayer::Finalize ; (; TQueryResult * ; qr). overridevirtual . Finalize query (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 1580 of file TProofPlayer.cxx. ◆ GetCacheSize(). Long64_t TProofPlayer:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:28421,feedback,feedback,28421,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"e a form ""(TVirtualPad*,TObject*,Int_t,Int_t)"" root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C; file hlprint.C void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }; ; void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVirtualPadTVirtualPad is an abstract base class for the Pad and Canvas classes.Definition TVirtualPad.h:51; TVirtualPad::Updatevirtual void Update()=0. Highlight mode and simple user function; For more complex demo please see for example $ROOTSYS/tutorials/tree/temperature.C file. ; Definition at line 50 of file THistPainter.h. Public Member Functions;  THistPainter ();  Default constructor. ;  ;  ~THistPainter () override;  destructor. ;  ; virtual std::vector< THistRenderingRegion > ComputeRenderingRegions (TAxis *pAxis, Int_t nPixels, bool isLog);  Returns the rendering regions for an axis to use in the COL2 option. ;  ; virtual void DefineColorLevels (Int_t ndivz);  Define the color levels used to paint legos, surfaces etc.. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute the distance from the point px,py to a line. ;  ; void DrawPanel () override;  Display a panel with all histogram drawing options. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute the actions corresponding to event. ;  ; TList * GetContourList (Double_t contour) const override;  Get a contour (as a list of TGraphs) using the Delaunay triangulation. ;  ; char * GetObjectInfo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:131866,simpl,simple,131866,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"e a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. » Last changed: Mon Jul 4 15:35:39 2011 » Last generated: 2011-07-04 15:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPadPainter.html:6456,simpl,simply,6456,root/html530/TPadPainter.html,https://root.cern,https://root.cern/root/html530/TPadPainter.html,1,['simpl'],['simply']
Usability,"e a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. » Last changed: Thu Nov 3 20:21:02 2011 » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPadPainter.html:6456,simpl,simply,6456,root/html532/TPadPainter.html,https://root.cern,https://root.cern/root/html532/TPadPainter.html,1,['simpl'],['simply']
Usability,"e a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candledecay.C Candle Decay, illustrate a time development of a certain ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:121265,simpl,simple,121265,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,4,['simpl'],['simple']
Usability,"e a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that shows the usage of a TGSplitButton ;  splitterHorizontal.CThis macro gives an example of how to create a horizontal splitter ;  splitterVertical.CThis macro gives an example of how to create a vertical splitter ;  staffTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  statusBar.CThis macro gives an example of how to create a status bar related to an embedded canvas that shows the info of the selected object, exactly as the status bar of any canvas window ;  textEntries.CThis macro gives an example of how to set/change text entry attributes ;  textviewostream.CThis macro gives an example of how to use the TGTextViewostream widget ;  WorldMap.CThis macro shows how to use a TGImageMap class ;  ► hist;  candleplot.C Example of candle plot with 2-D histograms ;  candleplotop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:120498,simpl,simple,120498,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. virtual~TMapFile(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TObject* obj, const char* name = """"); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); Bool_tcd(const char* path = 0); static TClass*Class(); virtual co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMapFile.html:1762,simpl,simple,1762,root/html528/TMapFile.html,https://root.cern,https://root.cern/root/html528/TMapFile.html,6,['simpl'],['simple']
Usability,"e address space and can not be used by the; consumer process(es)). Consumer processes can map the memory region; from this file and access the objects stored in it via the Get(); method (which returns a copy of the object stored in the shared; memory with correct vtbl ptr set). Only objects of classes with a; Streamer() member function defined can be shared. I know the current implementation is not ideal (you need to copy to; and from the shared memory file) but the main problem is with the; class' virtual_table pointer. This pointer points to a table unique; for every process. Therefore, different options are:; 1) One could allocate an object directly in shared memory in the; producer, but the consumer still has to copy the object from; shared memory into a local object which has the correct vtbl; pointer for that process (copy ctor's can be used for creating; the local copy).; 2) Another possibility is to only allow objects without virtual; functions in shared memory (like simple C structs), or to; forbid (how?) the consumer from calling any virtual functions; of the objects in shared memory.; 3) A last option is to copy the object internals to shared memory; and copy them again from there. This is what is done in the; TMapFile (using the object Streamer() to make a deep copy).; Option 1) saves one copy, but requires solid copy ctor's (along the; full inheritance chain) to rebuild the object in the consumer. Most; classes don't provide these copy ctor's, especially not when objects; contain collections, etc. 2) is too limiting or dangerous (calling; accidentally a virtual function will segv). So since we have a; robust Streamer mechanism I opted for 3). Function Members (Methods); public:. ~TMapRec(); void*GetBuffer(Long_t offset = 0) const; Int_tGetBufSize() const; const char*GetClassName(Long_t offset = 0) const; const char*GetName(Long_t offset = 0) const; TMapRec*GetNext(Long_t offset = 0) const; TObject*GetObject() const; TMapRec(const char* name, const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMapRec.html:1743,simpl,simple,1743,root/html602/TMapRec.html,https://root.cern,https://root.cern/root/html602/TMapRec.html,2,['simpl'],['simple']
Usability,"e an extra day is added to February to make the year; 366 days long. If the year is the last year of a century, eg. 1700, 1800,; 1900, 2000, then it is only a leap year if it is exactly divisible by; 400. Therefore, 1900 wasn't a leap year but 2000 was. The reason for; these rules is to bring the average length of the calendar year into; line with the length of the Earth's orbit around the Sun, so that the; seasons always occur during the same months each year. Int_t GetZoneOffset(); Static method returning local (current) time zone offset from UTC.; This is the value in seconds one must add to the local time to arrive at; Coordinated Universal Time, so it is negative east of the Prime Meridian. void Add(const TTimeStamp& offset); Add ""offset"" as a delta time. void Print(Option_t* option = """") const; Print date and time. void Set(); Set Date/Time to current time as reported by the system.; No accounting for nanoseconds with std ANSI functions,; ns part faked so that subsequent calls simply add 1 to it; this ensures that calls within the same second come back; distinct (and sortable). Time is since Jan 1, 1970. void Set(Int_t year, Int_t month, Int_t day, Int_t hour, Int_t min, Int_t sec, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set Date/Time from components. Month & day both use normal 1..12 and 1..31 counting,; hours, min, sec run from 0 to 23, 59, 59 respectively,; secOffset provides method for adjusting for alternative timezones. ""year"" | 0 1 ... 37 | 38...69 | 70 .. 100 101 .. 137; true | 2000 2001 2037 | undefined | 1970 2000 2001 .. 2037. ""year"" | 138...1969 | 1970 .. 2037 | ...; true | undefined | 1970 .. 2037 | undefined. void Set(Int_t date, Int_t time, Int_t nsec, Bool_t isUTC, Int_t secOffset); Set date/time from integers of the form [yy]YYMMDD and HHMMSS,; assume UTC (UTC) components:. MM: 01=January .. 12=December; DD: 01 .. 31. HH: 00=midnight .. 23; MM: 00 .. 59; SS: 00 .. 69. Date must be in format 980418 or 19980418; 1001127 or 20001127 (i.e. year",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTimeStamp.html:8468,simpl,simply,8468,root/html528/TTimeStamp.html,https://root.cern,https://root.cern/root/html528/TTimeStamp.html,4,['simpl'],['simply']
Usability,"e and number of steps, the; : evolution of the path is defined by a cut-off parameter, tau.; : This parameter is unknown and depends on the training data.; : A large value will tend to give large weights to a few rules.; : Similarly, a small value will lead to a large set of rules; : with similar weights.; : ; : A final point is the model used; rules and/or linear terms.; : For a given training sample, the result may improve by adding; : linear terms. If best performance is obtained using only linear; : terms, it is very likely that the Fisher discriminant would be; : a better choice. Ideally the fitting procedure should be able to; : make this choice by giving appropriate weights for either terms.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : I. TUNING OF RULE ENSEMBLE:; : ; : ␛[1mForestType ␛[0m: Recommended is to use the default ""AdaBoost"".; : ␛[1mnTrees ␛[0m: More trees leads to more rules but also slow; : performance. With too few trees the risk is; : that the rule ensemble becomes too simple.; : ␛[1mfEventsMin ␛[0m; : ␛[1mfEventsMax ␛[0m: With a lower min, more large trees will be generated; : leading to more complex rules.; : With a higher max, more small trees will be; : generated leading to more simple rules.; : By changing this range, the average complexity; : of the rule ensemble can be controlled.; : ␛[1mRuleMinDist ␛[0m: By increasing the minimum distance between; : rules, fewer and more diverse rules will remain.; : Initially it is a good idea to keep this small; : or zero and let the fitting do the selection of; : rules. In order to reduce the ensemble size,; : the value can then be increased.; : ; : II. TUNING OF THE FITTING:; : ; : ␛[1mGDPathEveFrac ␛[0m: fraction of events in path evaluation; : Increasing this fraction will improve the path; : finding. However, a too high value will give few; : unique events available for error estimation.; : It is recommended to use the default = 0.5.; : ␛[1mGDTau ␛[0m: cutoff parameter ta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:54427,simpl,simple,54427,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['simpl'],['simple']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Fri Dec 2 14:26:59 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooProjectedPdf.html:44782,intuit,intuitively,44782,root/html532/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html532/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Mon Dec 7 13:48:46 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProjectedPdf.html:42489,intuit,intuitively,42489,root/html526/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html526/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Mon Jul 4 15:23:45 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooProjectedPdf.html:43525,intuit,intuitively,43525,root/html530/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html530/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Sat Oct 9 20:48:34 2010 » Last generated: 2010-10-09 20:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProjectedPdf.html:42965,intuit,intuitively,42965,root/html528/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html528/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e argument returned by reference is the unique code; defining this particular projection configuration. RooAbsPdf* createProjection(const RooArgSet& iset); Special version of RooAbsReal::createProjection that deals with; projections of projections. Instead of integrating twice, a new; RooProjectedPdf is returned that is configured to perform the; complete integration in one step. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to relegate integration of all observables to internal logic. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Mark all requested variables as internally integrated. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral represent by appropriate element of projection cache. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; No internal generator is implemented. void generateEvent(Int_t code); No internal generator is implemented. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t , Bool_t , Bool_t ); Intercept a server redirection all and update list of dependents if necessary; Specifically update the set proxy 'deps' which introduces the dependency; on server value dirty flags of ourselves. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. TObject* clone(const char* newname) const; { return new RooProjectedPdf(*this,newname); }. virtual ~RooProjectedPdf(); { }. void initGenerator(Int_t ); {}. Bool_t selfNormalized() const; { return kTRUE ; }. » Last changed: Tue Jun 2 15:33:10 2015 » Last generated: 2015-06-02 15:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooProjectedPdf.html:47951,intuit,intuitively,47951,root/html604/RooProjectedPdf.html,https://root.cern,https://root.cern/root/html604/RooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"e assumed to refer to the default fit range. ;  ; bool forceAnalyticalInt (const RooAbsArg &) const override;  Force RooRealIntegral to offer all observables for internal integration. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Determine which part (if any) of given integral can be performed analytically. ;  ; const RooArgSet & getCoefNormalization () const;  ; const char * getCoefRange () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  If all components that depend on obs are binned, so is their sum. ;  ; const RooArgList & pdfList () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Loop over components for plot sampling hints and merge them if there are multiple. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the product operator construction. ;  ; void resetErrorCounters (Int_t resetValue=10) override;  Reset error counter to given value, limiting the number of future error messages for this pdf to 'resetValue'. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooAddPdf with cache-and-track. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:5816,intuit,intuitively,5816,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['intuit'],['intuitively']
Usability,"e automatically available upon import of the ROOT module in a Notebook or at startup of a ROOT prompt kernel. We made it easier to use ROOT notebooks locally, by providing a ‘root –notebook’ command option to start a local notebook server customised with all the ROOT features.; New tutorials and code examples have been provided. The simplest example showing the integration of ROOT with the notebook technology can be found here and many more snippets here.; Support for capturing large outputs (stderr/stdout) coming from C++ libraries has been added.; JavaScript ROOT. support registered in THttpServer commands with arguments.; provide workaround for websites using require.js and older jquery-ui; support custom requests to remote objects, demonstrated in httptextlog.C tutorial; rewrite draw.htm (page for individual object drawing) to support all custom features as main gui does; See also the JSRoot 3.9 examples page and the JSRoot 3.9 release notes. Class Reference Guide; The ROOT reference guide is moving to the Doxygen system. Doxygen is the de-facto standard for code documentation. It offers many nice features we are now exploring and trying to get the best of them. Having MathJax rendered math formula is one of them. The documentation can be structured in a more logical way using groups. Still there is a lot to do but big progresses have been done. We developed also a Doxygen filter allowing to execute macros given as examples in the documentation and show the resulting picture directly in the documentation.; Tutorials; The tutorials in $ROOTSYS/tutorials are also presented on the web thanks to Doxygen. They are now part of the reference guide allowing nice cross-referencing with the classes documentation. Here also a filter has been developed to generate the resulting picture.; Build, Configuration and Testing Infrastructure; ROOT uses the CMake cross-platform build-generator tool as a primary build system. CMake does not build the project, it generates the files n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:22784,guid,guide,22784,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['guid'],['guide']
Usability,"e background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method returns the shifts of the unfolding result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37630,clear,clearEmat,37630,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"e box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); That's a special version working with wchar_t and required by TMathText (who uses utf-8(?)). void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image displayed in the canvas pointed by ""pad"" into a; binary file.; assert(pad != nullptr && ""SaveImage, parameter 'pad' is null"");; assert(fileName != nullptr && ""SaveImage, parameter 'fileName' is null"");. void DrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. TPadPainter(); Final overriders for TVirtualPadPainter pure virtual functions.; 1. Part, which simply delegates to TVirtualX.; Line attributes. TPadPainter(const TPadPainter& rhs); Let's make this clear:. » Author: Olivier Couet, Timur Pocheptsov 06/05/2009 » Copyright (C) 1995-2009, Rene Brun and Fons Rademakers. *; » Last changed: root/gpad:$Id$ » Last generated: 2015-06-30 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPadPainter.html:7698,simpl,simply,7698,root/html602/TPadPainter.html,https://root.cern,https://root.cern/root/html602/TPadPainter.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"e camera, Double_t fov, Double_t dolly, Double_t* center, Double_t hRotate, Double_t vRotate); Set a perspective camera to supplied configuration - note this; does not need to be the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:32035,guid,guides,32035,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,3,['guid'],['guides']
Usability,"e define now C as an assembly containing A and B, positioning the assembly into D,E and F will actually position only A and Bdirectly into these volumes, taking into account their combined transformations A/B to C and C to D/E/F. This looks much nicer, is it? In fact, it is and it is not. Of course, we managed to get rid of the ‘unnecessary’ volume C in our geometry, but we end-up with a more flat structure for D,E and F (more daughters inside). This can get much worse when extensively used, as in the case: assemblies of assemblies.; For deciding what to choose between using virtual containers or assemblies for a specific case, one can use for both cases, after the geometry was closed:; gGeoManager->SetTopVolume(ptr_D);; gGeoManager->Test();; gGeoManager->RestoreMasterVolume();; The ptr_D is a pointer to volume D containing the interesting structure. The test will provide the timing for classifying 1 million random points inside D.; 18.4.2.5 Examples of Volume Positioning; Now let us make a simple volume representing a copper wire. We suppose that a medium is already created (see TGeoMedium class on how to create media).; We will create a TUBE shape for our wire, having Rmin=0cm, Rmax=0.01cm and a half-length dZ=1cm:; TGeoTube *tube = new TGeoTube(""wire_tube"",0,0.01,1);; One may omit the name for the shape wire_tube, if no retrieving by name is further needed during geometry building. Different volumes having different names and materials can share the same shape.; Now let’s make the volume for our wire:; TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"",tube,; ptrCOPPER); //(*); (*) Do not bother to delete the media, shapes or volumes that you have created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would have been able to create our wire with a single line:; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"",ptrCOPPER,; 0,0.01,1); //(*); (*) The same applies for all p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:943759,simpl,simple,943759,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"e eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 38810 2011-04-12 16:22:59Z ganis $ » Last generated: 2011-07-04 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TEventIterTree.html:7688,learn,learning,7688,root/html530/TEventIterTree.html,https://root.cern,https://root.cern/root/html530/TEventIterTree.html,1,['learn'],['learning']
Usability,"e eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TEventIter.h 38810 2011-04-12 16:22:59Z ganis $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEventIterTree.html:7688,learn,learning,7688,root/html532/TEventIterTree.html,https://root.cern,https://root.cern/root/html532/TEventIterTree.html,1,['learn'],['learning']
Usability,"e example or the full tutorial here.; @ROOT.Numba.Declare([""float""], ""bool""); def myFilter(x):; return x > 10; ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""Numba::myFilter(x)"").Sum(""y""); print(sum.GetValue()); It also works with collections: RVec objects of fundamental types can be transparently converted to/from numpy arrays:; @ROOT.Numba.Declare(['RVec<float>', 'int'], 'RVec<float>'); def pypowarray(numpyvec, pow):; return numpyvec**pow; ; df.Define('array', 'ROOT::RVecF{1.,2.,3.}')\; .Define('arraySquared', 'Numba::pypowarray(array, 2)'); Note that this functionality requires the Python packages numba and cffi to be installed. Interoperability with NumPy; Conversion to NumPy arrays; Eventually, you probably would like to inspect the content of the RDataFrame or process the data further with Python libraries. For this purpose, we provide the AsNumpy() function, which returns the columns of your RDataFrame as a dictionary of NumPy arrays. See a simple example below or a full tutorial here.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); cols = df.Filter(""x > 10"").AsNumpy([""x"", ""y""]) # retrieve columns ""x"" and ""y"" as NumPy arrays; print(cols[""x""], cols[""y""]) # the values of the cols dictionary are NumPy arrays; Processing data stored in NumPy arrays; In case you have data in NumPy arrays in Python and you want to process the data with ROOT, you can easily create an RDataFrame using ROOT.RDF.FromNumpy. The factory function accepts a dictionary where the keys are the column names and the values are NumPy arrays, and returns a new RDataFrame with the provided columns.; Only arrays of fundamental types (integers and floating point values) are supported and the arrays must have the same length. Data is read directly from the arrays: no copies are performed.; # Read data from NumPy arrays; # The column names in the RDataFrame are taken from the dictionary keys; x, y = numpy.array([1, 2, 3]), numpy.array([4, 5, 6]); df = ROOT.RDF.FromNumpy({""x"": x, ""y""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:82724,simpl,simple,82724,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"e file, insert a “!” as the first character after the comment marks. It tells ROOT not to save that data member in a root file when saving the class. For example, in this version of Event, the fPt and fTransient data members are not persistent.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; ...; 11.3.3 The Pointer to Objects (//->); The string “->” in the comment field of the members *fH and *fTracks instruct the automatic Streamer to assume these will point to valid objects and the Streamerof the objects can be called rather than the more expensive R__b << fH. It is important to note that no check is done on the validity of the pointer value. In particular if the pointer points, directly or indirectly, back to the current object, this will result in an infinite recursion and the abrupt end of the process.; TClonesArray *fTracks; //->; TH1F *fH; //->; 11.3.4 Variable Length Array; When the Streamercomes across a pointer to a simple type, it assumes it is an array. Somehow, it has to know how many elements are in the array to reserve enough space in the buffer and write out the appropriate number of elements. This is done in the class definition. For example:; class Event : public TObject {; private:; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; ...; Float_t *fClosestDistance; //[fNvertex]; The array fClosestDistance is defined as a pointer of floating point numbers. A comment mark (//), and the number in square brackets tell the Streamerthe length of the array for this object. In general the syntax is:; <simple type> *<name>//[<length>]; The length cannot be an expression. If a variable is used, it needs to be an integer data member of the class. It must be defined ahead of its use, or in a base class.; The same notation also applies to variable length array of object and variable length array of pointer to objects.; MyObject *obj; //[fNojbs]; MyObject **objs; //[fDatas]; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:470115,simpl,simple,470115,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"e for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. TTeXDump(); TTeXDump(const char* filename, Int_t type = -113); virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTeXDump.html:1490,simpl,simple,1490,root/html534/TTeXDump.html,https://root.cern,https://root.cern/root/html534/TTeXDump.html,1,['simpl'],['simple']
Usability,"e for generating graphics. It is platform; and format-independent and works together with the most important TeX; backend drivers, including pdftex and dvips. It comes with a; user-friendly syntax layer called TikZ. To generate a such file it is enough to do:. gStyle->SetPaperSize(10.,10.);; hpx->Draw();; gPad->Print(""hpx.tex"");. Then, the generated file (hpx.tex) can be included in a; LaTeX document (simple.tex) in the following way:. \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}. Note the three directives needed at the top of the LaTeX file:. \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}. Then including the picture in the document is done with the; \input<\tt> directive.; The command pdflatex simple.tex will generate the; corresponding pdf file simple.pdf.; . Function Members (Methods); public:. virtual~TTeXDump(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); Int_tCMtoTeX(Double_t u); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; voidDefineMarkers(); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTeXDump.html:1514,simpl,simple,1514,root/html602/TTeXDump.html,https://root.cern,https://root.cern/root/html602/TTeXDump.html,2,['simpl'],['simple']
Usability,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__Fitter.html:9815,simpl,simple,9815,root/html530/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__Fitter.html,1,['simpl'],['simple']
Usability,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. bool LinearFit(const ROOT::Fit::BinData& data). do a linear fit on a set of bin-data. { return DoLinearFit(data); }. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Fit__Fitter.html:11178,simpl,simple,11178,root/html532/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html532/ROOT__Fit__Fitter.html,3,['simpl'],['simple']
Usability,"e given FCN function representing a multi-dimensional gradient function; interface (ROOT::Math::IMultiGradFunction). In this case the minimizer will use the; gradient information provided by the function.; For the options same consideration as in the previous method. bool FitFCN(const ROOT::Math::FitMethodGradFunction& fcn, const double* params = 0). Fit using a FitMethodGradFunction interface. Same as method above, but now extra information; can be taken from the function class. bool SetFCN(const ROOT::Math::IMultiGradFunction& fcn, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). Set the FCN function represented by a multi-dimensional gradient function interface; (ROOT::Math::IMultiGenFunction) and optionally the initial parameters; See also note above for the initial parameters for FitFCN. bool FitFCN(ROOT::Fit::Fitter::MinuitFCN_t fcn, int npar = 0, const double* params = 0, unsigned int dataSize = 0, bool chi2fit = false). bool EvalFCN(). Perform a simple FCN evaluation. FitResult will be modified and contain the value of the FCN. void SetFunction(const IModelFunction & func, bool useGradient = false). Set the fitted function (model function) from a parametric function interface. void SetFunction(const IModel1DFunction & func, bool useGradient = false). Set the fitted function from a parametric 1D function interface. bool CalculateHessErrors(). perform an error analysis on the result using the Hessian; Errors are obtaied from the inverse of the Hessian matrix; To be called only after fitting and when a minimizer supporting the Hessian calculations is used; otherwise an error (false) is returned.; A new FitResult with the Hessian result will be produced. bool CalculateMinosErrors(). perform an error analysis on the result using MINOS; To be called only after fitting and when a minimizer supporting MINOS is used; otherwise an error (false) is returned.; The result will be appended in the fit result class; Optionally a vector of parameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__Fitter.html:10746,simpl,simple,10746,root/html604/ROOT__Fit__Fitter.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__Fitter.html,1,['simpl'],['simple']
Usability,"e given initialization method. */; 106 virtual void Initialize();; 107 ; 108 /*! Computes activation of the layer for the given input. The input; 109 * must be in 3D tensor form with the different matrices corresponding to; 110 * different events in the batch. */; 111 virtual void Forward(Tensor_t &input, bool applyDropout = false) = 0;; 112 ; 113 /*! Backpropagates the error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5087,learn,learning,5087,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,5,['learn'],"['learning', 'learningRate']"
Usability,"e graph to be drawn in high resolution mode.; By default, the graph is drawn in low resolution; in case the number of points is greater than the number of; pixels in the current pad.; ; ""][""; ""Cutoff"" style. When this option is selected together with; H option, the first and last vertical lines of the histogram; are not drawn.; . . void PaintGraphAsymmErrors(TGraph* theGraph, Option_t* option). Paint this TGraphAsymmErrors with its current attributes.; . void PaintGraphBentErrors(TGraph* theGraph, Option_t* option). Paint this TGraphBentErrors with its current attributes.; . void PaintGraphErrors(TGraph* theGraph, Option_t* option). Paint this TGraphErrors with its current attributes.; . void PaintGraphPolar(TGraph* theGraph, Option_t* option). Paint this TGraphPolar with its current attributes.; . void PaintGraphQQ(TGraph* theGraph, Option_t* option). Paint this graphQQ. No options for the time being.; ; . void PaintGraphSimple(TGraph* theGraph, Option_t* option). Paint a simple graph, without errors bars.; ; . void PaintPolyLineHatches(TGraph* theGraph, Int_t n, const Double_t* x, const Double_t* y). Paint a polyline with hatches on one side showing an exclusion zone. x and y; are the the vectors holding the polyline and n the number of points in the; polyline and w the width of the hatches. w can be negative.; This method is not meant to be used directly. It is called automatically; according to the line style convention.; ; . void PaintStats(TGraph* theGraph, TF1* fit). Paint the statistics box with the fit info.; ; . void Smooth(TGraph* theGraph, Int_t npoints, Double_t* x, Double_t* y, Int_t drawtype). Smooth a curve given by N points.; ; The original code come from an underlaying routine for Draw based on the; CERN GD3 routine TVIPTE:; ; Author - Marlow etc. Modified by - P. Ward Date - 3.10.1973; ; This method draws a smooth tangentially continuous curve through; the sequence of data points P(I) I=1,N where P(I)=(X(I),Y(I)); the curve is approximated by a pol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:22740,simpl,simple,22740,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,2,['simpl'],['simple']
Usability,"e histogram from the ROOT File; TH1 *hpx = nullptr; // pointer to base class TH1 is enough; example->GetObject(""hpx"", hpx);; ; TCanvas *c1 = new TCanvas(""c1"",""Histogram Drawing Options"",200,10,700,900);; TPad *pad1 = new TPad(""pad1"",; ""The pad with the function"",0.03,0.62,0.50,0.92);; TPad *pad2 = new TPad(""pad2"",; ""The pad with the histogram"",0.51,0.62,0.98,0.92);; TPad *pad3 = new TPad(""pad3"",; ""The pad with the histogram"",0.03,0.02,0.97,0.57);; pad1->Draw();; pad2->Draw();; pad3->Draw();; ; // Draw a global picture title; TPaveLabel *title = new TPaveLabel(0.1,0.94,0.9,0.98,; ""Drawing options for one dimensional histograms"");; title->SetTextFont(52);; title->Draw();; ; // Draw histogram hpx in first pad with the default option.; pad1->cd();; pad1->GetFrame()->SetFillColor(18);; hpx->SetFillColor(45);; hpx->DrawCopy();; TPaveLabel *label1 = new TPaveLabel(-3.5,700,-1,800,""Default option"");; label1->Draw();; ; // Draw hpx as a lego. Clicking on the lego area will show; // a ""transparent cube"" to guide you rotating the lego in real time.; pad2->cd();; hpx->DrawCopy(""lego1"");; TPaveLabel *label2 = new TPaveLabel(-0.72,0.74,-0.22,0.88,""option Lego1"");; label2->Draw();; TPaveLabel *label2a = new TPaveLabel(-0.93,-1.08,0.25,-0.92,; ""Click on lego to rotate"");; label2a->Draw();; ; // Draw hpx with its errors and a marker.; pad3->cd();; pad3->SetGridx();; pad3->SetGridy();; hpx->SetMarkerStyle(21);; hpx->Draw(""e1p"");; TPaveLabel *label3 = new TPaveLabel(2,600,3.5,650,""option e1p"");; label3->Draw();; ; // The following illustrates how to add comments using a PaveText.; // Attributes of text/lines/boxes added to a PaveText can be modified.; // The AddText function returns a pointer to the added object.; TPaveText *pave = new TPaveText(-3.78,500,-1.2,750);; TText *t1=pave->AddText(""You can move"");; t1->SetTextColor(4);; t1->SetTextSize(0.05);; pave->AddText(""Title and Stats pads"");; pave->AddText(""X and Y axis"");; pave->AddText(""You can modify bin contents"");; pave->Draw();;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/h1ReadAndDraw_8C.html:1872,guid,guide,1872,doc/master/h1ReadAndDraw_8C.html,https://root.cern,https://root.cern/doc/master/h1ReadAndDraw_8C.html,1,['guid'],['guide']
Usability,"e interval in the fit residual case. ; Definition at line 207 of file TRatioPlot.h. ◆ GetConfidenceInterval2(). TGraphErrors * TRatioPlot::GetConfidenceInterval2 ; (; ); const. inline . Returns the graph for the 2 sigma confidence interval in the fit residual case. ; Definition at line 212 of file TRatioPlot.h. ◆ GetLowerPad(). TPad * TRatioPlot::GetLowerPad ; (; ); const. inline . Definition at line 215 of file TRatioPlot.h. ◆ GetLowerRefGraph(). TGraph * TRatioPlot::GetLowerRefGraph ; (; ); const. virtual . Returns the reference graph for the lower pad, which means the graph that is responsible for setting the coordinate system. ; It is the first graph added to the primitive list of the lower pad. This reference can be used to set the minimum and maximum of the lower pad. Note that TRatioPlot::Draw needs to have been called first, since the graphs are only created then.; ; void ratioplot3() {; gStyle->SetOptStat(0);; auto c1 = new TCanvas(""c1"", ""fit residual simple"");; c1->SetLogy();; auto h1 = new TH1D(""h1"", ""h1"", 50, -5, 5);; h1->FillRandom(""gaus"", 2000);; h1->Fit(""gaus"", ""0"");; h1->SetMinimum(0.001);; h1->GetXaxis()->SetTitle(""x"");; h1->GetYaxis()->SetTitle(""y"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefGraph()->SetMinimum(-2);; rp1->GetLowerRefGraph()->SetMaximum(2);; }; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::SetMinimumvirtual void SetMinimum(Double_t minimum=-1111)Definition TH1.h:405; ratioplot3Definition ratioplot3.py:1; . Definition at line 705 of file TRatioPlot.cxx. ◆ GetLowerRefXaxis(). TAxis * TRatioPlot::GetLowerRefXaxis ; (; ); const. Gets the x axis of the lower ref graph. ; Shortcut for:; rp->GetLowerRefGraph()->GetXaxis();. Definition at line 798 of file TRatioPlot.cxx. ◆ GetLowerRefYaxis(). TAxis * TRatioPlot::GetLowerRefYaxis ; (; ); const. Gets the y axis of the lower ref graph. ; Shortcut for:; rp->GetLowerRefGraph()->GetYaxis();. Definition at line 812 of file TRatioPlot.cxx. ◆ GetLowYaxis(). TAxis * TR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:33046,simpl,simple,33046,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['simpl'],['simple']
Usability,"e line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matrix; computation, but seems more powerful at least for less than 300; weights. Parameters are Tau and Reset, which defines the epochs where; the direction is reset to the steepes descent. How; to use it... TMLP is build from 3 classes: TNeuron, TSynapse and; TMultiLayerPerceptron. Only TMultiLayerPerceptron should be used; explicitly by the user.; TMultiLayerPerceptron will take examples from a TTree; given in the constructor. The network is described by a simple; string: The input/output layers are defined by giving the expression for; each neuron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:6305,simpl,simple,6305,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['simpl'],['simple']
Usability,"e list of predefined color names is the following:; kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; kTeal@ kTealDefinition Rtypes.h:67; kGray@ kGrayDefinition Rtypes.h:65; kPink@ kPinkDefinition Rtypes.h:67; kOrange@ kOrangeDefinition Rtypes.h:67; kBlack@ kBlackDefinition Rtypes.h:65; kGreen@ kGreenDefinition Rtypes.h:66; kWhite@ kWhiteDefinition Rtypes.h:65; kCyan@ kCyanDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; kAzure@ kAzureDefinition Rtypes.h:67; kViolet@ kVioletDefinition Rtypes.h:67; kSpring@ kSpringDefinition Rtypes.h:67; Note the special role of color kWhite (color number 0). It is the default background color also. For instance in a PDF or PS files (as paper is usually white) it is simply not painted. To have a white color behaving like the other color the simplest is to define an other white color not attached to the color index 0:; Int_t ci = TColor::GetFreeColorIndex();; TColor *color = new TColor(ci, 1., 1., 1.);. Bright and dark colors; Dark and bright colors are used to add 3D effects to graphical objects like TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; Two static functions are available that return the bright or dark color number corresponding to a given color index. If these variants don't already exist, they are created as needed: Int_t dark = TColor::GetColorDark(color_index);; Int_t bright = TColor::GetColorBright(color_index);; TColor::GetColorBrightstatic Int_t GetColorBright(Int_t color)Static function: Returns the bright color number corresponding to n If the TColor object does not exi...Definition TColor.cxx:2087; TColor::GetColorDarkstatic Int_t GetColorDark(Int_t color)Static function: Returns the dark color number corresponding to n If the TColor object does not exist...Definition TColor.cxx:2130. Accessible Color Schemes; Choosing an appro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTColor.html:5104,simpl,simplest,5104,doc/master/classTColor.html,https://root.cern,https://root.cern/doc/master/classTColor.html,1,['simpl'],['simplest']
Usability,"e most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3687; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::SortRVec< T > Sort(const RVec< T > &v)Return copy of RVec with elements sorted in ascending order.Definition RVec.hxx:2502. Manipulation of indices; It is also possible to manipulated the RVecs acting on their indices. For example, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html:4999,simpl,simply,4999,doc/v632/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"e most common mathematical functions are supported. It is possible to invoke them passing RVecs as arguments.; abs, fdim, fmod, remainder; floor, ceil, trunc, round, lround, llround; exp, exp2, expm1; log, log10, log2, log1p; pow; sqrt, cbrt; sin, cos, tan, asin, acos, atan, atan2, hypot; sinh, cosh, tanh, asinh, acosh; erf, erfc; lgamma, tgamma. If the VDT library is available, the following functions can be invoked. Internally the calculations are vectorized:; fast_expf, fast_logf, fast_sinf, fast_cosf, fast_tanf, fast_asinf, fast_acosf, fast_atanf; fast_exp, fast_log, fast_sin, fast_cos, fast_tan, fast_asin, fast_acos, fast_atan. Owning and adopting memory; RVec has contiguous memory associated to it. It can own it or simply adopt it. In the latter case, it can be constructed with the address of the memory associated to it and its length. For example: std::vector<int> myStlVec {1,2,3};; RVec<int> myRVec(myStlVec.data(), myStlVec.size());; In this case, the memory associated to myStlVec and myRVec is the same, myRVec simply ""adopted it"". If any method which implies a re-allocation is called, e.g. emplace_back or resize, the adopted memory is released and new one is allocated. The previous content is copied in the new memory and preserved. Sorting and manipulation of indices. Sorting; RVec complies to the STL interfaces when it comes to iterations. As a result, standard algorithms can be used, for example sorting: RVec<double> v{6., 4., 5.};; std::sort(v.begin(), v.end());; v@ vDefinition rootcling_impl.cxx:3699; For convenience, helpers are provided too: auto sorted_v = Sort(v);; auto reversed_v = Reverse(v);; ROOT::VecOps::ReverseRVec< T > Reverse(const RVec< T > &v)Return copy of reversed vector.Definition RVec.hxx:2481; ROOT::VecOps::SortRVec< T > Sort(const RVec< T > &v)Return copy of RVec with elements sorted in ascending order.Definition RVec.hxx:2502. Manipulation of indices; It is also possible to manipulated the RVecs acting on their indices. For example, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html:5000,simpl,simply,5000,doc/master/classROOT_1_1VecOps_1_1RVec.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1VecOps_1_1RVec.html,1,['simpl'],['simply']
Usability,"e name.Definition TTreeReaderValue.cxx:693; TBranchElementA Branch for the case of an object.Definition TBranchElement.h:39; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TDictionaryThis class defines an abstract interface that must be implemented by all classes that contain diction...Definition TDictionary.h:168; TLeafA TLeaf describes individual elements of a TBranch See TBranch structure in TTree.Definition TLeaf.h:57; TStringBasic string class.Definition TString.h:139; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderValue::operator->T * operator->()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:201; TTreeReaderValue::TTreeReaderValueTTreeReaderValue()=delete; TTreeReaderValue::GetT * Get()Return a pointer to the value of the current entry.Definition TTreeReaderValue.h:189; TTreeReaderValue::TTreeReaderValueTTreeReaderValue(TTreeReader &tr, const char *branchname)Definition TTreeReaderValue.h:180; TTreeReaderValue::operator*T & operator*()Return a reference to the value of the current entry.Definition TTreeReaderValue.h:206; TTreeReaderValue::NonConstT_ttypename std::remove_const< T >::type NonConstT_tDefinition TTreeReaderValue.h:178; TTreeReaderValue::GetDerivedTypeNameconst char * GetDerivedTypeName() const overrideGet the template argument as a string.Definition TTreeReaderValue.h:211; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; bool; int; ROOT::Minuit2::GradientParameterSpace::Internal@ Internal; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4. treetreeplayerincTTreeReaderValue.h. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:05 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:20255,simpl,simple,20255,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,1,['simpl'],['simple']
Usability,"e normalization of inputs/outputs; TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to use cross-entropy errors, which allows to train a network for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal over background discrimination). More than 50% of neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package originally written by Jerome Schwindling. MLPfit remains one of the fastest tool for neural networks studies, and this ROOT add-on will not try to compete on that. A clear and flexible Object Oriented implementation has been chosen over a faster but more difficult to maintain code. Nevertheless, the time penalty does not exceed a factor 2. The MLP; The multilayer perceptron is a simple feed-forward network with the following structure:. It is made of neurons characterized by a bias and weighted links between them (let's call those links synapses). The input neurons receive the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers. This is useful because of two theorems:. A linear combination of sigmoids can approximate any continuous function.; Trained with output = 1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X. Learning methods; The aim of all learning methods is to minimize the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:2513,clear,clear,2513,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['clear'],['clear']
Usability,e of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Long64_tTFileCacheRead::fNoCacheBytesReadNumber of bytes read by basket to fill cached tree; Int_tTFileCacheRead::fNoCacheReadCallsNumber of read calls by basket to fill cached tree; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch! Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:20523,learn,learning,20523,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['learn'],['learning']
Usability,"e of the fit. Only in cases where such a modification of fit behaviour is intentional,; this function should be used. RooArgSet* addColumns(const RooArgList& varList); Utility function to add multiple columns in one call; See addColumn() for details. RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void reserve(Int_t nEvt). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void forceCacheUpdate(). void recalculateCache(const RooArgSet* , Int_t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:15983,clear,cleared,15983,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,3,['clear'],['cleared']
Usability,"e ore more container; limits. Suppose we want to position the same box inside 2 different volumes; and we want the Z size to match the one of each container:. TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; container1->AddNode(pvol, 1);; container2->AddNode(pvol, 1);. Note that the third parameter of PVOL is negative, which does not make sense; as half-length on Z. This is interpreted as: when positioned, create a box; replacing all invalid parameters with the corresponding dimensions of the; container. This is also internally handled by the TGeoVolumeMulti class, which; does not need to be instantiated by users. Dividing volumes. Volumes can be divided according a pattern. The most simple division can; be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; the most simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have created; the initial box, this can be done like:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);. where SLICE is the name of the new family representing all slices and 1 is the; slicing axis. The meaning of the axis index is the following: for all volumes; having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all slices can; be represented by a single shape, only one volume is added to the family and; positioned N times inside",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:13135,simpl,simple,13135,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['simpl'],['simple']
Usability,"e parameters at the time of the call. ; also prints other relevant information such as function value, estimated distance to minimum, parameter errors, step sizes.; According to the value of IKODE, the printout is: IKODE=INKODE=; 0 only info about function value; 1 parameter values, errors, limits; 2 values, errors, step sizes, internal values; 3 values, errors, step sizes, first derivs.; 4 values, parabolic errors, MINOS errors. when INKODE=5, MNPRIN chooses IKODE=1,2, or 3, according to fISW[1] ; Definition at line 6304 of file TMinuit.cxx. ◆ mnpsdf(). void TMinuit::mnpsdf ; (; ). virtual . Calculates the eigenvalues of v to see if positive-def. ; if not, adds constant along diagonal to make positive. ; Definition at line 6494 of file TMinuit.cxx. ◆ mnrazz(). void TMinuit::mnrazz ; (; Double_t ; ynew, . Double_t * ; pnew, . Double_t * ; y, . Int_t & ; jh, . Int_t & ; jl . ). virtual . Called only by MNSIMP (and MNIMPR) to add a new point. ; and remove an old one from the current simplex, and get the estimated distance to minimum. ; Definition at line 6568 of file TMinuit.cxx. ◆ mnrn15(). void TMinuit::mnrn15 ; (; Double_t & ; val, . Int_t & ; inseed . ). virtual . This is a super-portable random number generator. ; It should not overflow on any 32-bit machine. The cycle is only ~10**9, so use with care! Note especially that VAL must not be undefined on input.; Set Default Starting Seed ; Definition at line 6619 of file TMinuit.cxx. ◆ mnrset(). void TMinuit::mnrset ; (; Int_t ; iopt). virtual . Resets function value and errors to UNDEFINED. . If IOPT=1,; If IOPT=0, sets only MINOS errors to undefined Called from MNCLER and whenever problem changes, for example after SET LIMITS, SET PARAM, CALL FCN 6 . Definition at line 6661 of file TMinuit.cxx. ◆ mnsave(). void TMinuit::mnsave ; (; ). virtual . Writes current parameter values and step sizes onto file ISYSSA. ; in format which can be reread by Minuit for restarting. The covariance matrix is also output if it exists.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:61971,simpl,simplex,61971,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['simpl'],['simplex']
Usability,"e paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'libpath' from the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveIncludePath(const char* incpath, Bool_t onClient = kFALSE); Remove 'incpath' from the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. void HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Handle lib, inc search paths modification request. TList * GetListOfPackages(); Get from the master the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this signal; to monitor the feedback object. void CloseProgressDialog(); Close progress dialog. void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset progress dialog. void StartupMessage(const char* msg, Bool_t status, Int_t done,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:69784,progress bar,progress bar,69784,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['progress bar'],['progress bar']
Usability,"e problem at hand, in particular along the borders; of the region of interest. This is because the algorithm presented; here, is a interpolation, rahter then a extrapolation; [5].; ; Also, the independent variables need to be linear; independent, since the procedure will perform poorly if they are not; [5]. One can find an linear transformation from ones; original variables to a set of linear independent variables; , using a Principal Components Analysis; (see TPrincipal), and; then use the transformed variable as input to this class [5]; [6].; ; H. Wind also outlines a method for parameterising a multidimensional; dependence over a multidimensional set of variables. An example; of the method from [5], is a follows (please refer to; [5] for a full discussion):; . Define ; are the 5 dependent; quantities that define a track.; ; Compute, for different values of ; , the tracks; through the magnetic field, and determine the corresponding; ; .; ; Use the simulated observations to determine, with a simple; approximation, the values of ; . We call these values; ; .; ; Determine from ; a set of at least five relevant; coordinates ; , using contrains, or; alternative:. Perform a Principal Component Analysis (using; TPrincipal), and use; to get a linear transformation; ; , so that; ; are constrained and linear independent.; ; Perform a Principal Component Analysis on; ; , to get linear; indenpendent (among themselves, but not independent of; ; ) quantities . For each component ; make a mutlidimensional fit,; using ; as the variables, thus determing a set of; coefficents ; .; . To process data, using this parameterisation, do; ; Test wether the observation ; within the domain of; the parameterization, using the result from the Principal Component; Analysis.; ; Determine ; as before.; ; Detetmine ; as before.; ; Use the result of the fit to determind ; .; ; Transform back to ; from ; , using; the result from the Principal Component Analysis.; . Testing the parameterization; . T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiDimFit.html:10875,simpl,simple,10875,root/html534/TMultiDimFit.html,https://root.cern,https://root.cern/root/html534/TMultiDimFit.html,3,['simpl'],['simple']
Usability,"e results or varied results:; hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); hx[""pt:down""].Draw(""SAME"");; hx[""pt:up""].Draw(""SAME"");; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::VariationsForRResultMap< T > VariationsFor(RResultPtr< T > resPtr)Produce all required systematic variations for the given result.Definition RDFHelpers.hxx:219; A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second to the tag ""up""). The full variation name will be composed of the varied column name and the variation tags (e.g. ""pt:down"", ""pt:up"" in this example). Python usage looks similar.; Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define calls for each variation and fill the histogram with values and cuts that depend on the variation.; There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and complex functors. The callable can be applied to zero or more existing columns and it will always receive their nominal value in input.; Varying multiple columns in lockstep; In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or ""in lockstep"":; df.Vary([""pt"", ""eta""],; ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; variationTags=[""down"", ""up""],; variationName=""ptAndEta""); The expression returns an RVec of two RVecs: each inner vect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:54857,simpl,simply,54857,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simply']
Usability,"e same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw().; ; {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }; ; Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture.; ; {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }; ; Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:; ; {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPostScript.html:4517,clear,clear,4517,root/html534/TPostScript.html,https://root.cern,https://root.cern/root/html534/TPostScript.html,6,['clear'],['clear']
Usability,"e spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display.; {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selectStr = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selectStr.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }; f#define f(i)Definition RSha256.hxx:104; TCanvasThe Canvas class.Definition TCanvas.h:23; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TSpiderSpider class.Definition TSpider.h:40; TSpider::Drawvoid Draw(Option_t *options="""") overrideDraw the spider.Definition TSpider.cxx:454; TSpider::TSpiderTSpider()Default constructor.Definition TSpider.cxx:76; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; c1return c1Definition legend1.C:41. Definition at line 40 of file TSpider.h. Public Member Functions;  TSpider ();  Default constructor. ;  ;  TSpider (TTree *tree, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=0, Long64_t firstentry=0);  Normal constructor. ;  ;  ~TSpider () override;  Destructor. ;  ; void AddSuperposed (TSpider *sp);  Allow to superpose several spider views. ;  ; void AddVariable (const char *varexp);  Add a variable to the plot from its expression. ;  ; void DeleteVariable (const char *varexp);  Delete a variable from its expression. ;  ; Int_t D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpider.html:1741,simpl,simple,1741,doc/master/classTSpider.html,https://root.cern,https://root.cern/doc/master/classTSpider.html,1,['simpl'],['simple']
Usability,e the bin volume; 629 const double* xlow = Coords( fNPoints-1 );; 630 ; 631 double binVolume = 1.0;; 632 for ( unsigned int j = 0; j < fDim; j++ ); 633 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20431,clear,clear,20431,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"e the current camera - though you will not see; the effect if it is not. 'camera' defines the persp camera - one of kCameraPerspXOZ, kCameraPerspYOZ, kCameraPerspXOY; 'fov' - field of view (lens angle) in degrees (clamped to 0.1 - 170.0); 'dolly' - distance from 'center'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLViewer.html:32210,guid,guides,32210,root/html528/TGLViewer.html,https://root.cern,https://root.cern/root/html528/TGLViewer.html,3,['guid'],['guides']
Usability,"e title on window. void FitCanvas(); Fit canvas container to current window size. void PrintCanvas(); Print the canvas. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. void ShowMenuBar(Bool_t show = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. TRootCanvas(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootCanvas.html:27732,undo,undocking,27732,root/html528/TRootCanvas.html,https://root.cern,https://root.cern/root/html528/TRootCanvas.html,3,['undo'],['undocking']
Usability,"e title on window. void FitCanvas(); Fit canvas container to current window size. void PrintCanvas(); Print the canvas. void EventInfo(Int_t event, Int_t px, Int_t py, TObject* selected); Display a tooltip with infos about the primitive below the cursor. void ShowMenuBar(Bool_t show = kTRUE); Show or hide menubar. void ShowStatusBar(Bool_t show = kTRUE); Show or hide statusbar. void ShowEditor(Bool_t show = kTRUE); Show or hide side frame. void CreateEditor(); Create embedded editor. void ShowToolBar(Bool_t show = kTRUE); Show or hide toolbar. void ShowToolTips(Bool_t show = kTRUE); Enable or disable tooltip info. Bool_t HasEditor() const; Returns kTRUE if the editor is shown. Bool_t HasMenuBar() const; Returns kTRUE if the menu bar is shown. Bool_t HasStatusBar() const; Returns kTRUE if the status bar is shown. Bool_t HasToolBar() const; Returns kTRUE if the tool bar is shown. Bool_t HasToolTips() const; Returns kTRUE if the tooltips are enabled. void AdjustSize(); Keep the same canvas size while docking/undocking toolbar. Bool_t HandleContainerButton(Event_t* ev); Handle mouse button events in the canvas container. Bool_t HandleContainerDoubleClick(Event_t* ev); Handle mouse button double click events in the canvas container. Bool_t HandleContainerConfigure(Event_t* ev); Handle configure (i.e. resize) event. Bool_t HandleContainerKey(Event_t* ev); Handle keyboard events in the canvas container. Bool_t HandleContainerMotion(Event_t* ev); Handle mouse motion event in the canvas container. Bool_t HandleContainerExpose(Event_t* ev); Handle expose events. Bool_t HandleContainerCrossing(Event_t* ev); Handle enter/leave events. Only leave is activated at the moment. Bool_t HandleDNDDrop(TDNDData* data); Handle drop events. Atom_t HandleDNDPosition(Int_t x, Int_t y, Atom_t action, Int_t xroot, Int_t yroot); Handle dragging position events. Atom_t HandleDNDEnter(Atom_t* typelist); Handle drag enter events. Bool_t HandleDNDLeave(); Handle drag leave events. void Activated(I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootCanvas.html:28003,undo,undocking,28003,root/html534/TRootCanvas.html,https://root.cern,https://root.cern/root/html534/TRootCanvas.html,3,['undo'],['undocking']
Usability,"e traversed backwards and upwards performing undo and redo operations. To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);; TQCommand::TQUndoManagerfriend class TQUndoManagerDefinition TQCommand.h:29; TQUndoManagerRecorder of operations for undo and redo.Definition TQCommand.h:103; TQUndoManager::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the stack of commands.Definition TQCommand.cxx:959; TQUndoManager::Add automatically invokes execution of command's Redo method. Use TQUndoManager::Undo to undo commands in history list. Redo is Undo for undo action. Use TQUndoManager::Redo method for that ; Definition at line 27 of file TQCommand.h. Public Member Functions;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; void Add (TObject *obj) override;  ; void Add (TObject *obj, Option_t *opt) override;  Add command to the list of merged commands. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual Bool_t CanRedo () const;  Returns kTRUE if Redo action is possible, kFALSE if it's not. ;  ; virtual Bool_t CanUndo () const;  Returns kTRUE if Undo action is possible, kFALSE if it's not. ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:4959,undo,undo,4959,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"e user is trying to set types only of existing columns; 363 ValidateColTypes(columns);; 364 ; 365 // Infer types of columns with first record; 366 InferColTypes(columns);; 367 ; 368 // rewind; 369 fCsvFile->Seek(fDataPos);; 370 } else {; 371 std::string msg = ""Could not infer column types of CSV file "";; 372 msg += fileName;; 373 throw std::runtime_error(msg);; 374 }; 375}; 376 ; 377void RCsvDS::FreeRecords(); 378{; 379 for (auto &record : fRecords) {; 380 for (size_t i = 0; i < record.size(); ++i) {; 381 void *p = record[i];; 382 const auto colType = fColTypes[fHeaders[i]];; 383 switch (colType) {; 384 case 'D': {; 385 delete static_cast<double *>(p);; 386 break;; 387 }; 388 case 'L': {; 389 delete static_cast<Long64_t *>(p);; 390 break;; 391 }; 392 case 'O': {; 393 delete static_cast<bool *>(p);; 394 break;; 395 }; 396 case 'T': {; 397 delete static_cast<std::string *>(p);; 398 break;; 399 }; 400 }; 401 }; 402 }; 403 fRecords.clear();; 404}; 405 ; 406////////////////////////////////////////////////////////////////////////; 407/// Destructor.; 408RCsvDS::~RCsvDS(); 409{; 410 FreeRecords();; 411}; 412 ; 413void RCsvDS::Finalize(); 414{; 415 fCsvFile->Seek(fDataPos);; 416 fProcessedLines = 0ULL;; 417 fEntryRangesRequested = 0ULL;; 418 FreeRecords();; 419}; 420 ; 421const std::vector<std::string> &RCsvDS::GetColumnNames() const; 422{; 423 return fHeaders;; 424}; 425 ; 426std::vector<std::pair<ULong64_t, ULong64_t>> RCsvDS::GetEntryRanges(); 427{; 428 // Read records and store them in memory; 429 auto linesToRead = fLinesChunkSize;; 430 FreeRecords();; 431 ; 432 std::string line;; 433 while ((-1LL == fLinesChunkSize || 0 != linesToRead) && fCsvFile->Readln(line)) {; 434 if (line.empty()) continue; // skip empty lines; 435 fRecords.emplace_back();; 436 FillRecord(line, fRecords.back());; 437 --linesToRead;; 438 }; 439 ; 440 if (!fColContainingEmpty.empty()) {; 441 std::string msg = """";; 442 for (const auto &col : fColContainingEmpty) {; 443 const auto colT = GetTypeName(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCsvDS_8cxx_source.html:13952,clear,clear,13952,doc/master/RCsvDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCsvDS_8cxx_source.html,1,['clear'],['clear']
Usability,"e width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TTreeInput.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeInput.html:22077,simpl,simple,22077,root/html528/TTreeInput.html,https://root.cern,https://root.cern/root/html528/TTreeInput.html,1,['simpl'],['simple']
Usability,"e width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TTreeInput.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeInput.html:22230,simpl,simple,22230,root/html530/TTreeInput.html,https://root.cern,https://root.cern/root/html530/TTreeInput.html,1,['simpl'],['simple']
Usability,"e width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGTextButton*fOkok button; char*fStrcutsaddress to store cuts string; char*fStrvarsaddress to store variables string; TGTextEntry*fTECutstext entry widget for cuts; TGTextEntry*fTEVarstext entry widget for variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeInput(const TGWindow* p, const TGWindow* main, char* strvars, char* strcuts); Create simple input dialog. ~TTreeInput(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TTreeInput(const TTreeInput& ). TTreeInput & operator=(const TTreeInput& ). » Author: David Gonzalez Maline 21/10/2008 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TTreeInput.h 26245 2008-11-17 16:32:49Z moneta $ » Last generated: 2011-11-03 20:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeInput.html:22230,simpl,simple,22230,root/html532/TTreeInput.html,https://root.cern,https://root.cern/root/html532/TTreeInput.html,1,['simpl'],['simple']
Usability,"e window. The objects/widgets receive the events and react to them according to the application functionality. The signals/slot communication mechanism is an advanced object communication concept; it largely replaces the concept of callback functions to handle actions in GUI’s. Signals and slots are just like any object-oriented methods implemented in C++. The objects are the instances of classes that don’t know anything about each other. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested in this information. On the other side there might be an object waiting for that signal and ready to react to it. This object disposes of special instruments to listen to the sent out signals. To have a communication we need a message transmission between the objects. In this simple example we use signals and slots. The code of the method TGButton::Clicked() is:; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; I.e. any button emits the signal Clicked() any time someone clicks on it. As you can see this method is virtual and could be overridden if you need to. In our simple example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system call gApplication->Terminate(0). We declare a new slot DoExit(), implement it to invoke the termination call and associate this slot with the signal Clicked() of the Exit button.; The code of example.C can be changed as follows:; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164071,simpl,simple,1164071,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoTranslationEditor.html:21285,undo,undoing,21285,root/html528/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html528/TGeoTranslationEditor.html,1,['undo'],['undoing']
Usability,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGeoTranslationEditor.html:21385,undo,undoing,21385,root/html530/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html530/TGeoTranslationEditor.html,1,['undo'],['undoing']
Usability,"e y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTranslationEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for translation editor. ~TGeoTranslationEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the new matrix. void DoName(); Slot for name. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying changes. void DoCancel(); Slot for cancelling last modifications non-applied. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last operation. void DoDx(); Slot for dx. void DoDy(); Slot for dx. void DoDz(); Slot for dx. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id: TGeoMatrixEditor.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoTranslationEditor.html:21385,undo,undoing,21385,root/html532/TGeoTranslationEditor.html,https://root.cern,https://root.cern/root/html532/TGeoTranslationEditor.html,1,['undo'],['undoing']
Usability,"e(). static const char * TMethodArg::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMethodArg::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 64 of file TMethodArg.h. ◆ DeclFileName(). static const char * TMethodArg::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 64 of file TMethodArg.h. ◆ GetDataMember(). TDataMember * TMethodArg::GetDataMember ; (; ); const. Returns TDataMember pointed by this methodarg. ; If you want to specify list of options or current value for your MethodArg (i.e. it is used as initial values in argument-asking dialogs popped up from context-meny),you can get this value from one of data members of the class.; The only restriction is, that this DataMember object must have its Getter/Setter methods set-up correctly - for details look at TDataMember. To learn how to specify the data member to which the argument should ""point"", look at TMethod. This is TMethod which sets up fDataMember, so it could work correctly. ; Definition at line 128 of file TMethodArg.cxx. ◆ GetDefault(). const char * TMethodArg::GetDefault ; (; ); const. Get default value of method argument. ; Definition at line 57 of file TMethodArg.cxx. ◆ GetFullTypeName(). const char * TMethodArg::GetFullTypeName ; (; ); const. Get full type description of method argument, e.g.: ""class TDirectory*"". ; Definition at line 74 of file TMethodArg.cxx. ◆ GetMethod(). TFunction * TMethodArg::GetMethod ; (; ); const. inline . Definition at line 52 of file TMethodArg.h. ◆ GetOptions(). TList * TMethodArg::GetOptions ; (; ); const. Returns list of possible options - according to pointed datamember. ; If there is no datamember field assigned to this methodarg - returns 0. ; Definition at line 110 of file TMethodArg.cxx. ◆ GetTypeInfo(). TypeInfo_t * TMethodArg::GetTypeInfo ; (; ); const. Get the TypeInfo of the method argument. ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMethodArg.html:16379,learn,learn,16379,doc/master/classTMethodArg.html,https://root.cern,https://root.cern/doc/master/classTMethodArg.html,1,['learn'],['learn']
Usability,"e(). void TProof::SetActive ; (; Bool_t ; = kTRUE). inline . Definition at line 988 of file TProof.h. ◆ SetAlias(). void TProof::SetAlias ; (; const char * ; alias = """"). virtual . Set an alias for this session. ; If reconnection is supported, the alias will be communicated to the remote coordinator so that it can be recovered when reconnecting ; Definition at line 10583 of file TProof.cxx. ◆ SetDataPoolUrl(). void TProof::SetDataPoolUrl ; (; const char * ; url). inline . Definition at line 1044 of file TProof.h. ◆ SetDataSetTreeName(). Int_t TProof::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). virtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented in TProofLite.; Definition at line 10766 of file TProof.cxx. ◆ SetDrawFeedbackOption(). void TProof::SetDrawFeedbackOption ; (; TDrawFeedback * ; f, . Option_t * ; opt . ). Set draw feedback option. ; Definition at line 10102 of file TProof.cxx. ◆ SetDSet(). void TProof::SetDSet ; (; TDSet * ; dset). inlineprotected . Definition at line 737 of file TProof.h. ◆ SetFeedback(). void TProof::SetFeedback ; (; TString & ; opt, . TString & ; optfb, . Int_t ; action . ). protected . Extract from opt in optfb information about wanted feedback settings. ; Feedback are removed from the input string opt. If action == 0, set up feedback accordingly, if action == 1 clean related feedback settings (using info in optfb, if available, or reparsing opt).; Feedback requirements are in the form <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>; The special name 'stats' triggers feedback about events and packets. The separator from the next option is either a ' ' or a ';'. Called interanally by TProof::Process. ; Definition at line 5232 of file TProof.cxx. ◆ SetInputDataFile(). void TProof::SetInputDataFile ; (; const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:142371,feedback,feedback,142371,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['feedback'],['feedback']
Usability,"e(file, ""MyTree"");. Compiling; You can also have your code compiled into a shared library, simply by adding a ""+"" behind the file name:; .x printTree.C+(file, ""MyTree"");. In the above example this will fail: we need to add the #includes for he compiler to be able to understand the code, while the interpreter has a lot of contextual knowledge and can automatically include headers and load libraries.; Expressions; You saw that with "".x"", ROOT prints the result of running the function while when using "".L"" and calling th function it does not. The way to trigger the printing of expression results is by omitting the trailing semicolon:; TMath::Gaus(1., 1., 1.). will print; (Double_t) 1.000000e+00. Help!; For TMath::Gaus() as well as for any other ROOT class or function, please check ROOT's reference guide.; Try to find the documentation for TTree::Print()!; We have now covered the basics - let's look at the tree's data!; . ‹ 1. Extracting an object from a TFile; up; 4. Histogramming ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/2-running-code-root.html:4058,guid,guidelines,4058,d/2-running-code-root.html,https://root.cern,https://root.cern/d/2-running-code-root.html,1,['guid'],['guidelines']
Usability,"e); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74743,feedback,feedback,74743,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['feedback'],['feedback']
Usability,"e); result = fitter.Result(); result.Print(ROOT.std.cout); ; c1 = ROOT.TCanvas(""Simfit"", ""Simultaneous fit of two histograms"", 10, 10, 700, 700); c1.Divide(1, 2); c1.cd(1); ROOT.gStyle.SetOptFit(1111); ; fB.SetFitResult(result, iparB); fB.SetRange(rangeB().first, rangeB().second); fB.SetLineColor(ROOT.kBlue); hB.GetListOfFunctions().Add(fB); hB.Draw(); ; c1.cd(2); fSB.SetFitResult(result, iparSB); fSB.SetRange(rangeSB().first, rangeSB().second); fSB.SetLineColor(ROOT.kRed); hSB.GetListOfFunctions().Add(fSB); hSB.Draw(); ; c1.SaveAs(""combinedFit.png""); ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::Chi2FCNChi2FCN class for binned fits using the least square methods.Definition Chi2FCN.h:46; ROOT::Fit::DataRangeclass describing the range in the coordinates it supports multiple range in a coordinate.Definition DataRange.h:35; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::WrappedMultiTF1TemplClass to Wrap a ROOT Function class (like TF1) in a IParamMultiFunction interface of multi-dimensions...Definition WrappedMultiTF1.h:48; object; ROOT::Fit::FillDatavoid FillData(BinData &dv, const TH1 *hist, TF1 *func=nullptr)fill the data vector from a TH1.Definition HFitInterface.cxx:107; TMatrixTAutoloadOps::AddTMatrixT< Element > & Add(TMatrixT< Element > &target, Element scalar, const TMatrixT< Element > &source)Modify addition: target += scalar * source.Definition TMatrixT.cxx:2936; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; AuthorJonas Rembser, Lorenzo Moneta (C++ version) ; Definition in file combinedFit.py. tutorialsfitcombinedFit.py. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/combinedFit_8py.html:5022,simpl,simple,5022,doc/master/combinedFit_8py.html,https://root.cern,https://root.cern/doc/master/combinedFit_8py.html,1,['simpl'],['simple']
Usability,"e);; 1000 setup.Append('\n');; 1001 }; 1002 setup.Chop(); // trim final `\n`; 1003 return setup;; 1004}; 1005 ; 1006////////////////////////////////////////////////////////////////////////////////; 1007/// It opens a Forum topic in a web browser with prefilled ROOT version; 1008///; 1009/// \param[in] type the issue type (only bug supported right now); 1010 ; 1011void TApplication::OpenForumTopic(const TString &type); 1012{; 1013 // https://meta.discourse.org/t/how-to-create-a-post-clicking-a-link/96197; 1014 ; 1015 if (type == ""bug"") {; 1016 //OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?title=topic%20title&body=topic%20body&category=category/subcategory&tags=email,planned\"""");; 1017 TString report_template =; 1018R""(___; 1019_Please read [tips for efficient and successful posting](https://root-forum.cern.ch/t/tips-for-efficient-and-successful-posting/28292) and [posting code](https://root-forum.cern.ch/t/posting-code-read-this-first/28293)_; 1020 ; 1021### Describe the bug; 1022<!--; 1023A clear and concise description of what the wrong behavior is.; 1024-->; 1025### Expected behavior; 1026<!--; 1027A clear and concise description of what you expected to happen.; 1028-->; 1029 ; 1030### To Reproduce; 1031<!--; 1032Steps to reproduce the behavior:; 10331. Your code that triggers the issue: at least a part; ideally something we can run ourselves.; 10342. Don't forget to attach the required input files!; 10353. How to run your code and / or build it, e.g. `root myMacro.C`, ...; 1036-->; 1037 ; 1038### Setup; 1039)""+GetSetup()+; 1040R""(; 1041<!--; 1042Please specify also how you obtained ROOT, such as `dnf install` / binary download / you built it yourself.; 1043-->; 1044 ; 1045### Additional context; 1046<!--; 1047Add any other context about the problem here.; 1048-->)"";; 1049 report_template = FormatHttpUrl(report_template);; 1050 ; 1051 OpenInBrowser(""\""https://root-forum.cern.ch/new-topic?category=ROOT&tags=bug&body=""+report_template+""&\"""");; 1052 } else ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:39109,clear,clear,39109,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['clear'],['clear']
Usability,"e, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1);  Create a new TTree BranchObject. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; virtual TBranch * Bronch (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=99);  Create a new TTree BranchElement. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long6",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:23908,undo,undo,23908,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['undo'],['undo']
Usability,"e, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=1);  Create a new TTree BranchObject. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; virtual TBranch * Bronch (const char *name, const char *classname, void *addobj, Int_t bufsize=32000, Int_t splitlevel=99);  Create a new TTree BranchElement. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; virtual TBasket * CreateBasket (TBranch *);  Create a basket for this tree and given branch. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; void Draw (Option_t *opt) override;  Default Draw method for all objects. ;  ; virtual void DropBaskets ();  Remove some baskets from memory. ;  ; virtual Int_t DropBranchFromCache (const char *bname, bool subbranches=false);  Remove the branch with name 'bname' from the Tree cache. ;  ; virtual Int_t DropBranchFromCache (TBranch *branch, bool subbranches=false);  Remove the branch b from the T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:16324,undo,undo,16324,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,3,['undo'],['undo']
Usability,"e->GetMatrix();; 1626 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1627 fGeoManager->SetPaintVolume(vcrt);; 1628 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1629 col = vcrt->GetLineColor();; 1630 wid = vcrt->GetLineWidth();; 1631 sty = vcrt->GetLineStyle();; 1632 vcrt->SetLineColor(node->GetLineColor());; 1633 vcrt->SetLineWidth(node->GetLineWidth());; 1634 vcrt->SetLineStyle(node->GetLineStyle());; 1635 ((TAttLine *)vcrt)->Modify();; 1636 PaintShape(*shape, option);; 1637 vcrt->SetLineColor(col);; 1638 vcrt->SetLineWidth(wid);; 1639 vcrt->SetLineStyle(sty);; 1640 } else {; 1641 PaintShape(*shape, option);; 1642 }; 1643 } else {; 1644 // Paint full branch, except top node; 1645 for (i = 1; i <= level; i++) {; 1646 vcrt = node->GetVolume(i);; 1647 if (!strstr(option, ""range"")); 1648 ((TAttLine *)vcrt)->Modify();; 1649 shape = vcrt->GetShape();; 1650 *matrix = node->GetMatrix(i);; 1651 fGeoManager->SetMatrixReflection(matrix->IsReflection());; 1652 fGeoManager->SetPaintVolume(vcrt);; 1653 if (!node->IsVolAttributes() && !strstr(option, ""range"")) {; 1654 col = vcrt->GetLineColor();; 1655 wid = vcrt->GetLineWidth();; 1656 sty = vcrt->GetLineStyle();; 1657 vcrt->SetLineColor(node->GetLineColor());; 1658 vcrt->SetLineWidth(node->GetLineWidth());; 1659 vcrt->SetLineStyle(node->GetLineStyle());; 1660 ((TAttLine *)vcrt)->Modify();; 1661 PaintShape(*shape, option);; 1662 vcrt->SetLineColor(col);; 1663 vcrt->SetLineWidth(wid);; 1664 vcrt->SetLineStyle(sty);; 1665 } else {; 1666 PaintShape(*shape, option);; 1667 }; 1668 }; 1669 }; 1670 fGeoManager->SetMatrixReflection(kFALSE);; 1671}; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// Print overlaps (see TGeoChecker::PrintOverlaps()); 1675 ; 1676void TGeoPainter::PrintOverlaps() const; 1677{; 1678 fChecker->PrintOverlaps();; 1679}; 1680 ; 1681////////////////////////////////////////////////////////////////////////////////; 1682/// Text progress bar.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:54736,progress bar,progress bar,54736,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"e. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdadelta< Architecture_t, Layer_t, DeepNet_t >Adadelta Optimizer class. ; This class represents the Adadelta Optimizer. ; Definition at line 45 of file Adadelta.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdadelta (DeepNet_t &deepNet, Scalar_t learningRate=1.0, Scalar_t rho=0.95, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdadelta ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredBiasUpdatesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredWeightUpdatesAt (size_t i);  ; Scalar_t GetRho () const;  Getters. ;  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:1116,learn,learningRate,1116,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learningRate']
Usability,"e. ; Reimplemented from RooAbsReal.; Definition at line 32 of file RooConstVar.h. ◆ IsA(). TClass * RooConstVar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 59 of file RooConstVar.h. ◆ isDerived(). bool RooConstVar::isDerived ; (; ); const. inlineoverridevirtual . Returns false, as the value of the constant doesn't depend on other objects. ; Reimplemented from RooAbsArg.; Definition at line 39 of file RooConstVar.h. ◆ Streamer(). void RooConstVar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooConstVar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 59 of file RooConstVar.h. ◆ translate(). void RooConstVar::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 61 of file RooConstVar.cxx. ◆ writeToStream(). void RooConstVar::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to stream. ; Reimplemented from RooAbsReal.; Definition at line 54 of file RooConstVar.cxx. Libraries for RooConstVar:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooConstVar.h; roofit/roofitco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooConstVar.html:62822,simpl,simple,62822,doc/master/classRooConstVar.html,https://root.cern,https://root.cern/doc/master/classRooConstVar.html,1,['simpl'],['simple']
Usability,"e. ;  ; virtual void CurrentChanged (TQCommand *c);  emit signal ;  ; TQCommand * GetCurrent () const;  Returns the last executed command. ;  ; TQCommand * GetCursor () const;  Returns a command correspondent to the current cursor position in stack. ;  ; UInt_t GetLimit () const;  Returns a maximum number of commands which could be located in stack. ;  ; TClass * IsA () const override;  ; Bool_t IsLogging () const;  Returns kTRUE if logging is ON. ;  ; void ls (Option_t *option="""") const override;  Lists all commands in stack. ;  ; void Redo (Option_t *option="""") override;  Performs redo action. Move cursor position forward in history stack. ;  ; virtual void SetLimit (UInt_t limit);  Returns a maximum number of commands which could be located in stack. ;  ; virtual void SetLogging (Bool_t on=kTRUE);  Start logging. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Undo (Option_t *option="""") override;  Performs undo action. Move cursor position backward in history stack. ;  ;  Public Member Functions inherited from TQCommand;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:1851,undo,undo,1851,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"e. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TBuffer3D. class TBuffer3D: public TObject. TBuffer3D. Generic 3D primitive description class - see TBuffer3DTypes for; producer classes. ; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:1178,clear,clear,1178,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,7,['clear'],['clear']
Usability,"e. Such a range is called ""bin"". Let's look at an example: draw the histogram of the momentum (""fPt"") of all electrons with an energy (""fE"") > 80 and fTriggered being true.; Binning; You can tell TTree::Draw() what the binning should be:; tree->Draw(""electrons.fE >> htemp(15, 0., 30.)"",...). will use 15 bins, where the lower bin border of the first bin is at 0. and the upper bin border of the highest is at 30.; Style; ROOT displays a few properties for the histogram in the box in the upper right. You can move things around in the graphical display (""canvas"") of the histogram. You can modify graphical properties of the canvas by showing the editor: in the menu, select ""View"", then ""Editor"". Click on the histogram to select it, then change its visual appearance to magenta line, 5 pixels width, with pink fill. Eeew. This is likely the only time in your life that you are allowed to use this color combination - enjoy! :-); . ‹ 2. Running code in ROOT; up; 3. Examining a TTree's data ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/4-histogramming.html:3661,guid,guidelines,3661,d/4-histogramming.html,https://root.cern,https://root.cern/d/4-histogramming.html,1,['guid'],['guidelines']
Usability,"e0.C Simple Event class example ;  tree1.C This example is a variant of hsimple.C but using a TTree instead of a TNtuple ;  tree2.C This example illustrates how to make a Tree from variables or arrays in a C struct ;  tree2a.C This example is the same as tree2.C, but uses a class instead of a C-struct ;  tree3.C Example of a Tree where branches are variable length arrays A second Tree is created and filled in parallel ;  tree4.C This example writes a tree with objects of the class Event ;  treefriend.C Illustrates how to use Tree friends: ;  treegetval.C Illustrates how to retrieve TTree variables in arrays ;  tv3.C;  tvdemo.C;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:158064,simpl,simple,158064,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"e::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TCollection::(anonymous)TCollection::kIsOwner. Class Charts. Inheritance Chart:. TObject. ←; TCollection. ←; TSeqCollection. ←; TList. TQObject. ←; TQCommand. ←. TQUndoManager. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:18719,undo,undo,18719,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"e::SetEstimate. A possible recipee is to do; tree->SetEstimate(tree->GetEntries());; You must call SetEstimate if the expected number of selected rows; is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accomodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:82453,simpl,simple,82453,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"e::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoHypeEditor.html:22325,undo,undoing,22325,root/html604/TGeoHypeEditor.html,https://root.cern,https://root.cern/root/html604/TGeoHypeEditor.html,1,['undo'],['undoing']
Usability,"e::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for Hype editor. ~TGeoHypeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoRin(); Slot for Rin. void DoRout(); Slot for Rout. void DoDz(); Slot for Z. void DoStIn(); Slot for StIn. void DoStOut(); Slot for StOut. TGeoHypeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoHypeEditor.html:22325,undo,undoing,22325,root/html602/TGeoHypeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoHypeEditor.html,1,['undo'],['undoing']
Usability,"e::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressMemoryPlot.html:25165,clear,clear,25165,root/html604/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html604/TProofProgressMemoryPlot.html,1,['clear'],['clear']
Usability,"e::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled; static TGMainFrame::(anonymous)TGMainFrame::kDontCallClose. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300); Main constructor. ~TProofProgressMemoryPlot(); Destructor. TGListBox* BuildLogList(TGFrame* parent); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void Clear(Option_t* = 0); Clear the canvases. void DoPlot(); Draw the plot from the logs. TGraph * DoAveragePlot(Int_t& max_el, Int_t& min_el); Create the average plots. Int_t ParseLine(TString l, Long64_t& v, Long64_t& r, Long64_t& e); Extract from line 'l' the virtual memory 'v', the resident memory 'r' and the; number of events 'e'.; The line is assumed to be in the form; ""... Memory 130868 virtual 31540 ... event 5550""; The fields are only filled if >= 0 .; Return 0 on success, -1 if any of the values coudl not be filled (the output; fields are not touched in such a case). TGraph * DoWorkerPlot(TProofLogElem* ple); Make a memory consumption graph for a worker. TGraph * DoMasterPlot(TProofLogElem* ple); a master or submaster log; display without meaningful labels for now. void Select(Int_t id); actions of select all/clear all button. TGraph* DoAveragePlotOld(Int_t& max_el, Int_t& min_el). TProofProgressMemoryPlot(TProofProgressDialog* d, Int_t w = 700, Int_t h = 300). » Author: Anna Kreshuk 18/07/2008 » Copyright (C) 1995-2003, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressMemoryPlot.html:25165,clear,clear,25165,root/html602/TProofProgressMemoryPlot.html,https://root.cern,https://root.cern/root/html602/TProofProgressMemoryPlot.html,1,['clear'],['clear']
Usability,"e; 2564 return h;; 2565}; 2566 ; 2567////////////////////////////////////////////////////////////////////////////////; 2568/// Return size of the formula along X in pad coordinates when the text precision; 2569/// is smaller than 3.; 2570 ; 2571Double_t TLatex::GetXsize(); 2572{; 2573 if (!gPad) return 0.;; 2574 TString newText = GetTitle();; 2575 if( newText.Length() == 0) return 0;; 2576 ; 2577 // The text is a TMathText.; 2578 if ( newText.Contains(""\\"") ) {; 2579 TMathText tm(0., 0., newText.Data());; 2580 return tm.GetXsize();; 2581 }; 2582 ; 2583 fError = nullptr;; 2584 if (CheckLatexSyntax(newText)) {; 2585 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2586 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2587 return 0;; 2588 }; 2589 fError = nullptr;; 2590 ; 2591 const Char_t *text = newText.Data() ;; 2592 Double_t angle_old = GetTextAngle();; 2593 TLatexFormSize fs = FirstParse(0,GetTextSize(),text);; 2594 SetTextAngle(angle_old);; 2595 fTabSize.clear();; 2596 return TMath::Abs(gPad->AbsPixeltoX(Int_t(fs.Width())) - gPad->AbsPixeltoX(0));; 2597}; 2598 ; 2599////////////////////////////////////////////////////////////////////////////////; 2600/// Return text size in pixels; 2601 ; 2602void TLatex::GetBoundingBox(UInt_t &w, UInt_t &h, Bool_t angle); 2603{; 2604 if (!gPad) return;; 2605 TString newText = GetTitle();; 2606 if( newText.Length() == 0) return;; 2607 ; 2608 // The text is a TMathText.; 2609 if ( newText.Contains(""\\"") ) {; 2610 TMathText tm(0., 0., newText.Data());; 2611 tm.GetBoundingBox(w, h);; 2612 return;; 2613 }; 2614 ; 2615 fError = nullptr;; 2616 if (CheckLatexSyntax(newText)) {; 2617 std::cout<<""\n*ERROR<TLatex>: ""<<fError<<std::endl;; 2618 std::cout<<""==> ""<<GetTitle()<<std::endl;; 2619 return;; 2620 }; 2621 fError = nullptr;; 2622 ; 2623 if (angle) {; 2624 Int_t cBoxX[4], cBoxY[4];; 2625 Int_t ptx, pty;; 2626 if (TestBit(kTextNDC)) {; 2627 ptx = gPad->UtoPixel(fX);; 2628 pty = gPad->VtoPixel(fY);; 2629 } else {; 2630 ptx = gPad->XtoAbsPi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:92160,clear,clear,92160,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['clear'],['clear']
Usability,"e; 5 = X; 6 = Diamond; 7 = Triangle. cg(enable,color) channel grid. In addition to the surface drawn using any above given algorithm one can display grid using the color parameter. The parameter enable can be set to:. 0 = Grid not drawn; 1 = Grid drawn. See example spectrumpainter.C. Definition at line 7674 of file TSpectrum2Painter.cxx. ◆ SetAngles(). void TSpectrum2Painter::SetAngles ; (; Int_t ; alpha, . Int_t ; beta, . Int_t ; view . ). Sets angles of the view: . alpha - angles of display,alpha+beta must be less or equal to 90, alpha- angle between base line of Canvas and right lower edge of picture base plane; beta - angle between base line of Canvas and left lower edge of picture base plane; view - rotation angle of the view, it can be 0, 90, 180, 270 degrees . Definition at line 7117 of file TSpectrum2Painter.cxx. ◆ SetBezier(). void TSpectrum2Painter::SetBezier ; (; Int_t ; bezier). Sets on/off Bezier smoothing: . bezier - determines Bezier interpolation (applies only for simple display modes group for grid, x_lines, y_lines display modes) . Definition at line 7205 of file TSpectrum2Painter.cxx. ◆ SetChanGrid(). void TSpectrum2Painter::SetChanGrid ; (; Int_t ; enable, . Int_t ; color . ). This function sets enables/disables drawing of channel grid and sets its color: -enable - decides whether the channel grid is shown or not -color - color of channel grid. ; Definition at line 7271 of file TSpectrum2Painter.cxx. ◆ SetChanMarks(). void TSpectrum2Painter::SetChanMarks ; (; Int_t ; enable, . Int_t ; color, . Int_t ; width, . Int_t ; height, . Int_t ; style . ). Sets enables/disables drawing of channel marks and sets their attributes: . enable - decides whether the channel marks are shown or not; color - color of channel marks; width - width of channel marks in pixels; height - height of channel marks in pixels; style - style of channel marks (dot, cross, star, rectangle, X, diamond, triangle) . Definition at line 7244 of file TSpectrum2Painter.cxx. ◆ SetColorAl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:51731,simpl,simple,51731,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability,"e; 5.14 MnUserParameters; 5.15 MnUserParameterState; 5.16 MnPrint.h. 6 How to get the right answer from M; 6.1 Which minimizer to use; 6.2 Floating point precision; 6.3 Parameter limits; 6.4 Fixing and releasing parameters; 6.5 Interpretation of parameter errors; 6.6 Convergence in \(\mbox{MIGRAD}\), and positive–definiteness; 6.7 Additional trouble–shooting. 7 A complete example; 7.1 The user’s \(\mbox{FCN}\); 7.2 The user’s main program. Minuit 2; *** Fred JAMES and Matthias WINKLER CERN, Geneva ***; 1 Foreword; 1.1 What M is intended to do; M is conceived as a tool to find the minimum value of a multi-parameter function (the “\(\mbox{FCN}\)”) and analyze the shape of the function around the minimum. The principal application is foreseen for statistical analysis, working on chisquare or log-likelihood functions, to compute the best-fit parameter values and uncertainties, including correlations between the parameters. It is especially suited to handle difficult problems, including those which may require guidance in order to find the correct solution.; 1.2 What M is not intended to do; Although M will of course solve easy problems faster than complicated ones, it is not intended for the repeated solution of identically parametrized problems (such as track fitting in a detector) where a specialized program will in general be much more efficient.; 1.3 Further remarks; M was initially written in Fortran around 1975-1980 at CERN by Fred James @bib-MINUIT. Its main field of usage is statistical data analysis of experimental data recorded at CERN, but it is also used by people doing data analysis outside CERN or outside high energy physics (HEP). In 2002 Fred James started a project aiming to re-implement M in an object-oriented way using .; More information about recent developments, releases and installation can be obtained from the M homepage @bib-C++MINUIT.; The names of M applications are written in capital letters (e.g. \(\mbox{MIGRAD}\), \(\mbox{MINOS}\), \(\mbox{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:2045,guid,guidance,2045,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,1,['guid'],['guidance']
Usability,"e; 60 ; 61////////////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:3953,simpl,simply,3953,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['simpl'],['simply']
Usability,"e; Inherited Members; Includes; Libraries. Function documentation; void SetFunction( Function & f). double Integral(const ROOT::Math::IGenFunction& f, double a, double b). double Integral(double a, double b). double IntegralCauchy(const ROOT::Math::IGenFunction& f, double a, double b, double c). IntegratorOneDim(ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, unsigned int rule = 0); constructors. Constructor of one dimensional Integrator, default type is adaptive. @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL kADAPTIVE type). Possible type values are : kGAUSS (simple Gauss method), kADAPTIVE (from GSL), kADAPTIVESINGULAR (from GSL), kNONADAPTIVE (from GSL); Possible rule values are kGAUS15 (rule = 1), kGAUS21( rule = 2), kGAUS31(rule =3), kGAUS41 (rule=4), kGAUS51 (rule =5), kGAUS61(rule =6); lower rules are indicated for singular functions while higher for smooth functions to get better accuracies. NOTE: When the default values are passed, the values used are taken from the default defined in ROOT::Math::IntegratorOneDimOptions. IntegratorOneDim(const ROOT::Math::IGenFunction& f, ROOT::Math::IntegrationOneDim::Type type = IntegrationOneDim::kDEFAULT, double absTol = 0, double relTol = 0, unsigned int size = 0, int rule = 0). Constructor of one dimensional Integrator passing a function interface. @param f integration function (1D interface). It is copied inside; @param type integration type (adaptive, non-adaptive, etc..); @param absTol desired absolute Error; @param relTol desired relative Error; @param size maximum number of sub-intervals; @param rule Gauss-Kronrod integration rule (only for GSL ADAPTIVE type). NOTE: When the default values are passed, the values used are taken from the defa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html:4966,simpl,simple,4966,root/html528/ROOT__Math__IntegratorOneDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IntegratorOneDim.html,6,['simpl'],['simple']
Usability,"e;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; Int_t ReinitSelector (TQueryResult *qr) override;  Reinitialize fSelector using the selector files in the query result. ;  ; void RemoveQueryResult (const char *ref) override;  Remove all query result instances referenced 'ref' from the list of results. ;  ; void RestorePreviousQuery () override;  ; Int_t SavePart",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:6123,learn,learning,6123,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,3,['learn'],['learning']
Usability,"e;; 1038 if ((hype->GetStIn() == 0) && (hype->GetStOut() == 0)); 1039 return countTubeFaces({hype->GetRmax(), hype->GetRmax()}, {hype->GetRmin(), hype->GetRmin()});; 1040 int radiusSegments = GetUsedNSegments(4), heightSegments = 30;; 1041 return radiusSegments * (heightSegments + 1) * ((hype->GetRmin() > 0.) ? 4 : 2);; 1042 } else if (shape->IsA() == TGeoTessellated::Class()) {; 1043 auto tess = (TGeoTessellated *)shape;; 1044 int numfaces = 0;; 1045 for (int i = 0; i < tess->GetNfacets(); ++i) {; 1046 if (tess->GetFacet(i).GetNvert() == 4); 1047 numfaces += 2;; 1048 else; 1049 numfaces += 1;; 1050 }; 1051 return numfaces;; 1052 } else if (shape->IsA() == TGeoScaledShape::Class()) {; 1053 auto scaled = (TGeoScaledShape *)shape;; 1054 return CountShapeFaces(scaled->GetShape());; 1055 } else if (shape->IsA() == TGeoCompositeShape::Class()) {; 1056 auto comp = (TGeoCompositeShape *)shape;; 1057 if (!comp->GetBoolNode()); 1058 return 0;; 1059 return CountShapeFaces(comp->GetBoolNode()->GetLeftShape()) +; 1060 CountShapeFaces(comp->GetBoolNode()->GetRightShape());; 1061 }; 1062 ; 1063 // many of simple shapes have 12 faces; 1064 return 12;; 1065}; 1066 ; 1067/////////////////////////////////////////////////////////////////////; 1068/// Find description object and create render information; 1069 ; 1070RGeomDescription::ShapeDescr &RGeomDescription::MakeShapeDescr(TGeoShape *shape); 1071{; 1072 auto &elem = FindShapeDescr(shape);; 1073 ; 1074 if (elem.nfaces == 0) {; 1075 ; 1076 int boundary = 3; //; 1077 if (shape->IsComposite()) {; 1078 // composite is most complex for client, therefore by default build on server; 1079 boundary = 1;; 1080 } else if (!shape->IsCylType()) {; 1081 // simple box geometry is compact and can be delivered as raw; 1082 boundary = 2;; 1083 }; 1084 ; 1085 if (IsBuildShapes() < boundary) {; 1086 elem.nfaces = 1;; 1087 elem.fShapeInfo.shape = shape;; 1088 } else {; 1089 ; 1090 int old_nsegm = -1;; 1091 if (fCfg.nsegm > 0 && gGeoManager) {; 1092 old_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:31718,simpl,simple,31718,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['simpl'],['simple']
Usability,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:59; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:171412,simpl,simple,171412,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['simpl'],['simple']
Usability,"e< T; ROOT::InternalDefinition TErrorDefaultHandler.hxx:16; ROOT::Internal::GetSymInLibImtstatic Func_t GetSymInLibImt(const char *funcname)Definition TROOT.cxx:401; ROOT::Internal::gGetROOTstatic GetROOTFun_t gGetROOTDefinition TROOT.cxx:399; ROOT::Internal::gROOTLocalR__EXTERN TROOT * gROOTLocalDefinition TROOT.h:379; ROOT::Internal::DisableParBranchProcessingvoid DisableParBranchProcessing()Globally disables the IMT use case of parallel branch processing, deactivating the corresponding lock...Definition TROOT.cxx:434; ROOT::Internal::ErrorSystemMsgHandlerFunc_tstd::function< const char *()> ErrorSystemMsgHandlerFunc_tRetrieves the error string associated with the last system error.Definition TError.h:60; ROOT::Internal::IsImplicitMTEnabledImplstatic Bool_t & IsImplicitMTEnabledImpl()Keeps track of the status of ImplicitMT w/o resorting to the load of libImt.Definition TROOT.cxx:463; ROOT::Internal::MinimalErrorHandlervoid MinimalErrorHandler(int level, Bool_t abort, const char *location, const char *msg)A very simple error handler that is usually replaced by the TROOT default error handler.Definition TError.cxx:67; ROOT::Internal::GetROOTFun_tTROOT *(* GetROOTFun_t)()Definition TROOT.cxx:397; ROOT::Internal::SetErrorSystemMsgHandlerErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h)Returns the previous system error message handler.Definition TError.cxx:56; ROOT::Internal::EnableParBranchProcessingvoid EnableParBranchProcessing()Globally enables the parallel branch processing, which is a case of implicit multi-threading (IMT) in...Definition TROOT.cxx:420; ROOT::Internal::IsParBranchProcessingEnabledBool_t IsParBranchProcessingEnabled()Returns true if parallel branch processing is enabled.Definition TROOT.cxx:447; ROOT::Internal::GetROOT2TROOT * GetROOT2()Definition TROOT.cxx:387; ROOT::Internal::GetROOT1TROOT * GetROOT1()Definition TROOT.cxx:380; ROOT::Internal::ReleaseDefaultErrorHandlervoid ReleaseDefaultErrorHandler()Destructs r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:171588,simpl,simple,171588,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['simpl'],['simple']
Usability,"e=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containing a Higgs boson. Starting with a TFile containing two TTrees: one for the signal, the other for the background, a simple script is used:; void mlpHiggs(Int_t ntrain=100) {; if (!gROOT->GetClass(""TMultiLayerPerceptron"")); gSystem->Load(""libMLP"");; // prepare inputs - the 2 trees are merged into one, and a; // ""type"" branch, equal to 1 for the signal and 0 for the; // background is added; TFile input(""mlpHiggs.root"");; TTree *signal = (TTree *)input.Get(""sig_filtered"");; TTree *background = (TTree *)input.Get(""bg_filtered"");; TTree *simu = new TTree(""MonteCarlo"",; ""Filtered Monte Carlo Events"");; ...; Since the input is a TTree and we are starting from two different TTrees (with different names), they are first merged into one, and a “type” branch is added, that says whether there is a signal or a background event. Those irrelevant details are skipped here.; ...; TMultiLayerPerceptron *mlp = new TMultiLayerPerceptron(; ""msumf,ptsumf, acolin, acopl:8:type"",""ptsumf"",simu,; ""Entry$%2"",""Entry$/2"");; mlp->Train(ntrain, ""text,graph,update=10"");; The neural network is instantiated and trained. “ptsumf” is used as a weight, and the standard event lists are explicit. The network that is then build has four",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:238200,simpl,simple,238200,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"e> Template of Lazy Symmeytric class; TMatrixTSymLazy<float> Template of Lazy Symmeytric class; TMehrotraSolver Mehrotra Qp Solver class; TMemStat a user interface class of MemStat; TMemberInspector ABC for inspecting class data members; TMemberStreamer ; TMergerInfo Basic info on merger, i.e. worker serving as merger; TMessage Message buffer class; TMessageHandler Generic message handler; TMethod Dictionary for a class member function (method); TMethodArg Dictionary for a method argument; TMethodBrowsable Helper object to browse methods; TMethodCall Method calling interface; TMinuit The MINUIT minimisation package; TMinuitMinimizer Implementation of Minimizer interface using TMinuit ; TMixture Mixtures used in the Geometry Shapes; TModuleDocInfo documentation for a group of classes; TMonitor Monitor activity on a set of TSocket objects; TMultiDimFit Multi dimensional fit class; TMultiGraph A collection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetSystem Directory handler for NetSystem; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.; TNtupleD A simple tree with branches of floats.; TObjArray An array of objects; TObjArrayIter Object array iterator; TObjString Collectable string class; TObject Basic ROOT object; TObjectRefSpy Spy object reference for deletion; TObjectSet TDataSet wrapper for TObject class objects; TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:109063,simpl,simple,109063,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['simpl'],['simple']
Usability,"e? ROOT is not a particularly good framework that is written in a language that isn't quite C++. If you are going to break away and make/use/write cling, then fix the poor design decisions: cling will probably break compatibility anyways despite your best efforts, so you might as well take the time and effort to refactor and clean up the code base. A simple example, taken from this website: """""" TFFTComplex One of the interface classes to the FFTW package, can be used directly or via the TVirtualFFT class. Only the basic interface of FFTW is implemented. Computes complex input/output discrete Fourier transforms (DFT) in one or more dimensions. For the detailed information on the computed transforms please refer to the FFTW manual, chapter ""What FFTW really computes"". How to use it: 1) Create an instance of TFFTComplex - this will allocate input and output arrays (unless an in-place transform is specified) 2) Run the Init() function with the desired flags and settings ... """""" This is simply poor design. This should look like: root::Fft, removing the T, using a namespace, using templates instead of inheritence, etc. But also, notice that you have to run an Init function. Why? That is specifically what the constructor is for. Why does everything in ROOT know how to draw itself? Why does everything in ROOT have 100 methods, for ""quick access"" to other objects that do the actual work of those methods? These are questions that should be asked. But most of all, if you aren't going to fix these problems, why bother migrating at all? You fail to treat this migration as what it actually is. You are migrating to a new language, not a new version of a language. ROOT isn't written in C++. It's written in CINT. I am just frustrated to see this happen, because I know this community can do better. Maybe I'll make a draft of some smaller changes that need to be made and submit them to the mailing list. But honestly, I'm not very hopeful about this migration. Submitted by Anonymous (n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:11371,simpl,simply,11371,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"eAll(""**"",""^"");; 1774 formula.ReplaceAll(""++"",""@""); // for linear functions; 1775 formula.ReplaceAll("" "","""");; 1776 HandlePolN(formula);; 1777 HandleParametrizedFunctions(formula);; 1778 HandleParamRanges(formula);; 1779 HandleFunctionArguments(formula);; 1780 HandleExponentiation(formula);; 1781 // ""++"" wil be dealt with Handle Linear; 1782 HandleLinear(formula);; 1783 // special case for ""--"" and ""++""; 1784 // (""++"" needs to be written with whitespace that is removed before but then we re-add it again; 1785 formula.ReplaceAll(""--"",""- -"");; 1786 formula.ReplaceAll(""++"",""+ +"");; 1787}; 1788 ; 1789////////////////////////////////////////////////////////////////////////////////; 1790/// prepare the formula to be executed; 1791/// normally is called with fFormula; 1792 ; 1793Bool_t TFormula::PrepareFormula(TString &formula); 1794{; 1795 fFuncs.clear();; 1796 fReadyToExecute = false;; 1797 ExtractFunctors(formula);; 1798 ; 1799 // update the expression with the new formula; 1800 fFormula = formula;; 1801 // save formula to parse variable and parameters for Cling; 1802 fClingInput = formula;; 1803 // replace all { and }; 1804 fFormula.ReplaceAll(""{"","""");; 1805 fFormula.ReplaceAll(""}"","""");; 1806 ; 1807 // std::cout << ""functors are extracted formula is "" << std::endl;; 1808 // std::cout << fFormula << std::endl << std::endl;; 1809 ; 1810 fFuncs.sort();; 1811 fFuncs.unique();; 1812 ; 1813 // use inputFormula for Cling; 1814 ProcessFormula(fClingInput);; 1815 ; 1816 // for pre-defined functions (need after processing); 1817 if (fNumber != 0) SetPredefinedParamNames();; 1818 ; 1819 return fReadyToExecute && fClingInitialized;; 1820}; 1821 ; 1822////////////////////////////////////////////////////////////////////////////////; 1823/// Extracts functors from formula, and put them in fFuncs.; 1824/// Simple grammar:; 1825/// - `<function>` := name(arg1,arg2...); 1826/// - `<variable>` := name; 1827/// - `<parameter>` := [number]; 1828/// - `<name>` := String containing lower and ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:68024,clear,clear,68024,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['clear'],['clear']
Usability,eCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; TTree*fOwner! pointer to the owner Tree/chain; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; Long64_tfZipBytes! Total compressed size of branches in cache; static Int_tfgLearnEntriesNumber of entries used for learning mode.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:17103,learn,learning,17103,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['learn'],['learning']
Usability,"eCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); Long64_tfTotalUnzipBytes! The total sum of the currently unzipped blks; TTree*TTreeCache::fTree! pointer to the current Tree; Long64_tfUnzipBufferSize! Max Size for the ready unzipped blocks (default is 2*fBufferSize); char**fUnzipChunks! [fNseek] Individual unzipped chunks. Their summed size is kept under control.; TCondition*fUnzipDoneConditionUsed to wait for an unzip tour to finish. Gives the Async feel.; Int_t*fUnzipLen! [fNseek] Length of the unzipped buffers; TCondition*fUnzipStartConditionUsed to signal the threads to start.; unsigned char*fUnzipStatus! [fNSeek] For each blk, tells us if it's unzipped or pending; TThread*fUnzipThread[10]; Long64_tTTreeCache::fZipBytes! Total compressed size of branches in cache; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:13662,learn,learning,13662,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,1,['learn'],['learning']
Usability,"eCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:15507,undo,undo,15507,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,3,['undo'],['undo']
Usability,"eCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidInit(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidTCollection::PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidPrintCollectionHeader(Option_t* option) const. private:. TQCommand&operator=(const TQCommand&). Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQCommand.html:15651,undo,undo,15651,root/html534/TQCommand.html,https://root.cern,https://root.cern/root/html534/TQCommand.html,1,['undo'],['undo']
Usability,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sat Jun 20 17:29:22 2015 » Last generated: 2015-06-20 17:29; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsArg.html:45984,clear,clearShapeDirty,45984,root/html604/RooAbsArg.html,https://root.cern,https://root.cern/root/html604/RooAbsArg.html,1,['clear'],['clearShapeDirty']
Usability,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Sun Jun 28 16:37:40 2015 » Last generated: 2015-06-28 16:37; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:44288,clear,clearShapeDirty,44288,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,1,['clear'],['clearShapeDirty']
Usability,"eDirty() const; Returns true of value has been invalidated by server value change. Bool_t isValueDirtyAndClear() const; Returns true of value has been invalidated by server value change. Bool_t isValueOrShapeDirtyAndClear() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { if (_operMode==Auto && !inhibitDirty()) setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueAndShapeDirty() const. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. const TNamed* namePtr() const. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE). void attachToVStore(RooVectorDataStore& vstore). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). void setLocalNoDirtyInhibit(Bool_t flag) const; { _localNoInhibitDirty = flag ; }. Bool_t localNoDirtyInhibit() const; { return _localNoInhibitDirty ; }. » Last changed: Tue Jun 30 14:29:52 2015 » Last generated: 2015-06-30 14:29; This page has been automatically generated. For comments or suggestions r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:45984,clear,clearShapeDirty,45984,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,1,['clear'],['clearShapeDirty']
Usability,"eElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooObjCacheManager.html:4783,clear,clearOnRedirect,4783,root/html532/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html532/RooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"eForCameraInterest. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveBoxSetGL(); Default constructor. ~TEveBoxSetGL(); Destructor. Int_t PrimitiveType() const; Return GL primitive used to render the boxes, based on the; render-mode specified in the model object. void MakeOriginBox(Float_t p[][3], Float_t dx, Float_t dy, Float_t dz) const; Fill array p to represent a box (0,0,0) - (dx,dy,dz). void RenderBoxStdNorm(const Float_t p[][3]) const; Render a box specified by points in array p with standard; axis-aligned normals. void RenderBoxAutoNorm(const Float_t p[][3]) const; Render box, calculate normals on the fly from first three points. void MakeDisplayList() const; Create a display-list for rendering a single box, based on the; current box-type.; Some box-types don't benefit from the display-list rendering and; so display-list is not created. Bool_t ShouldDLCache(const TGLRnrCtx& rnrCtx) const; Determines if display-list will be used for rendering.; Virtual from TGLLogicalShape. void DLCacheDrop(); Called when display lists have been destroyed externally and the; internal display-list data needs to be cleare.; Virtual from TGLLogicalShape. void DLCachePurge(); Called when display-lists need to be returned to the system.; Virtual from TGLLogicalShape. Bool_t SetModel(TObject* obj, Option_t* opt = 0); Set model object.; Virtual from TGLObject. void RenderBoxes(TGLRnrCtx& rnrCtx) const; GL rendering for all box-types. void DirectDraw(TGLRnrCtx& rnrCtx) const; Actual rendering code.; Virtual from TGLLogicalShape. void Render(TGLRnrCtx& rnrCtx); Interface for direct rendering from classes that include TEveBoxSet; as a member. TEveBoxSetGL(const TEveBoxSetGL& ). TEveBoxSetGL& operator=(const TEveBoxSetGL& ). » Last changed: root/eve:$Id$ » Last generated: 2015-03-13 19:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveBoxSetGL.html:5733,clear,cleare,5733,root/html534/TEveBoxSetGL.html,https://root.cern,https://root.cern/root/html534/TEveBoxSetGL.html,1,['clear'],['cleare']
Usability,eFrame.h. Member Data Documentation. ◆ fButtons. TGCompositeFrame* TGDockableFrame::fButtons. protected . container containing dock and hide buttons ; Definition at line 97 of file TGDockableFrame.h. ◆ fContainer. TGCompositeFrame* TGDockableFrame::fContainer. protected . container containing dockable frame ; Definition at line 96 of file TGDockableFrame.h. ◆ fDeleted. Bool_t TGDockableFrame::fDeleted. protected . kTRUE if it is being deleted ; Definition at line 93 of file TGDockableFrame.h. ◆ fDockButton. TGDockButton* TGDockableFrame::fDockButton. protected . dock button ; Definition at line 98 of file TGDockableFrame.h. ◆ fDockName. TString TGDockableFrame::fDockName. protected . name of frame ; Definition at line 95 of file TGDockableFrame.h. ◆ fEnableHide. Bool_t TGDockableFrame::fEnableHide. protected . if frame can be hidden ; Definition at line 91 of file TGDockableFrame.h. ◆ fEnableUndock. Bool_t TGDockableFrame::fEnableUndock. protected . if frame can be undocked ; Definition at line 92 of file TGDockableFrame.h. ◆ fFixedSize. Bool_t TGDockableFrame::fFixedSize. protected . kTRUE if fixed size when undocked ; Definition at line 94 of file TGDockableFrame.h. ◆ fFrame. TGUndockedFrame* TGDockableFrame::fFrame. protected . undocked frame ; Definition at line 100 of file TGDockableFrame.h. ◆ fHidden. Bool_t TGDockableFrame::fHidden. protected . if frame is hidden ; Definition at line 90 of file TGDockableFrame.h. ◆ fHideButton. TGDockHideButton* TGDockableFrame::fHideButton. protected . hide button ; Definition at line 99 of file TGDockableFrame.h. ◆ fHints. TGLayoutHints* TGDockableFrame::fHints. protected . layout hints ; Definition at line 101 of file TGDockableFrame.h. ◆ fLb. TGLayoutHints* TGDockableFrame::fLb. protected . Definition at line 102 of file TGDockableFrame.h. ◆ fLc. TGLayoutHints * TGDockableFrame::fLc. protected . layout hints ; Definition at line 102 of file TGDockableFrame.h. Libraries for TGDockableFrame:. [legend]; The documentation for,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGDockableFrame.html:40124,undo,undocked,40124,doc/master/classTGDockableFrame.html,https://root.cern,https://root.cern/doc/master/classTGDockableFrame.html,1,['undo'],['undocked']
Usability,"eKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-02 15:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TCollectionPropertyBrowsable.html:10129,simpl,simply,10129,root/html604/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html604/TCollectionPropertyBrowsable.html,1,['simpl'],['simply']
Usability,"eKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TStringfDrawstring to send to TTree::Draw(), NOT by GetScope()!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Browse(TBrowser* b); Browses a TCollectionPropertyBrowsable. The only difference to; the generic TVirtualBranchBrowsable::Browse is our fDraw. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); If the element to browse (given by either parent of branch) contains; a collection (TClonesArray or something for which a TVirtualCollectionProxy; exists), we will add some special objects to the browser. For now there is; just one object ""@size"", returning the size of the collection (as in; std::list::size(), or TClonesArray::GetEntries()).; The objects we create are simply used to forward strings (like ""@size"") to; TTreeFormula via our Browse method. These strings are stored in fName. void Register(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... void Unregister(); Wrapper for the registration method. Needed against MSVC, which; assigned different addr to the same method, depending on what; translation unit you're in... ~TCollectionPropertyBrowsable(); {}. const char* GetDraw() const; return the string passed to TTree::Draw. TCollectionPropertyBrowsable(const char* name, const char* title, const char* draw, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); constructor, which sets the name and title according to the parameters; (and thus differently than our base class TVirtualBranchBrowsable). » Author: Axel Naumann 14/10/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-06-30 14:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionPropertyBrowsable.html:10129,simpl,simply,10129,root/html602/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html,1,['simpl'],['simply']
Usability,"eMap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<bool>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<bool>::size_type __n); vector<long>::const_referencevector<long>::at(vector<bool>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back() const; TTable::iteratorBegin(); TTable::iteratorBegin() const; vector<long>::iteratorvector<long>::begin(); vector<long>::const_iteratorvector<long>::begin() const; virtual voidTObject::Browse(TBrowser* b); vector<bool>::size_typevector<long>::capacity() const; vector<long>::const_iteratorvector<long>::cbegin() const; vector<long>::const_iteratorvector<long>::cend() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidvector<long>::clear(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vector<long>::const_reverse_iteratorvector<long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __positi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableMap.html:2442,clear,clear,2442,root/html602/TTableMap.html,https://root.cern,https://root.cern/root/html602/TTableMap.html,1,['clear'],['clear']
Usability,"eMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooCacheManager (Int_t maxSize=2);  Constructor for simple caches without RooAbsArg payload. ;  ;  RooCacheManager (RooAbsArg *owner, Int_t maxSize=2);  Constructor for simple caches with RooAbsArg derived payload. ;  ;  ~RooCacheManager () override;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload object indexed on nset,uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastIndex () const;  Return index of slot used in last get or set operation. ;  ; void reset ();  Clear the cache. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:2741,simpl,simple,2741,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['simpl'],['simple']
Usability,"eName=nullptr) const override;  Return analytical integral represent by appropriate element of projection cache. ;  ; std::unique_ptr< RooAbsArg > compileForNormSet (RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const override;  ; RooAbsPdf * createProjection (const RooArgSet &iset) override;  Special version of RooAbsReal::createProjection that deals with projections of projections. ;  ; bool forceAnalyticalInt (const RooAbsArg &dep) const override;  Force RooRealIntegral to relegate integration of all observables to internal logic. ;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &analVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Mark all requested variables as internally integrated. ;  ; void initGenerator (Int_t) override;  Interface for one-time initialization to setup the generator for the specified code. ;  ; TClass * IsA () const override;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the integration operation. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:2488,intuit,intuitively,2488,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['intuit'],['intuitively']
Usability,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:55439,clear,clearShapeDirty,55439,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,399,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreamerPass2 ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedReal.html:55360,clear,clearShapeDirty,55360,doc/master/classRooCachedReal.html,https://root.cern,https://root.cern/doc/master/classRooCachedReal.html,3,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,"eName=nullptr, bool force=false);  Interface function to force use of a given normalization range to interpret function value. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)Activate associated tree branch ;  ; void syncCache (const RooArgSet *set=nullptr) override;  ; double traceEval (const RooArgSet *set) const;  Calculate current value of object, with error tracing wrapper. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:54663,clear,clearShapeDirty,54663,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,6,['clear'],"['clearShapeDirty', 'clearValueAndShapeDirty', 'clearValueDirty']"
Usability,eOutputindicates a potential tranformation of the output values before further computation DIRECT does not further transformation; SIGMOID applies a sigmoid transformation to each output value (to create a probability); SOFTMAX applies a softmax transformation to all output values (mutually exclusive probability) . Definition at line 122 of file NeuralNet.cxx. ◆ LayerData() [5/6]. TMVA::DNN::LayerData::LayerData ; (; const LayerData & ; other). inline . copy c'tor of LayerData ; Definition at line 515 of file NeuralNet.h. ◆ LayerData() [6/6]. TMVA::DNN::LayerData::LayerData ; (; LayerData && ; other). inline . move c'tor of LayerData ; Definition at line 538 of file NeuralNet.h. Member Function Documentation. ◆ activationFunction(). std::shared_ptr< std::function< double(double)> > TMVA::DNN::LayerData::activationFunction ; (; ); const. inline . Definition at line 607 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::LayerData::clear ; (; ). inline . clear the values and the deltas ; Definition at line 576 of file NeuralNet.h. ◆ clearDropOut(). void TMVA::DNN::LayerData::clearDropOut ; (; ). inline . clear the drop-out-data for this layer ; Definition at line 620 of file NeuralNet.h. ◆ computeProbabilities(). LayerData::container_type TMVA::DNN::LayerData::computeProbabilities ; (; ); const. private . compute the probabilities from the node values ; Definition at line 140 of file NeuralNet.cxx. ◆ deltasBegin() [1/2]. iterator_type TMVA::DNN::LayerData::deltasBegin ; (; ). inline . returns iterator to the begin of the deltas (back-propagation) ; Definition at line 591 of file NeuralNet.h. ◆ deltasBegin() [2/2]. const_iterator_type TMVA::DNN::LayerData::deltasBegin ; (; ); const. inline . returns const iterator to the begin of the deltas (back-propagation) ; Definition at line 594 of file NeuralNet.h. ◆ deltasEnd() [1/2]. iterator_type TMVA::DNN::LayerData::deltasEnd ; (; ). inline . returns iterator to the end of the deltas (back-propagation) ; Definition at line 592 o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:10954,clear,clear,10954,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:2330,clear,clearValueDirty,2330,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsString.html:2089,clear,clearValueDirty,2089,root/html532/RooAbsString.html,https://root.cern,https://root.cern/root/html532/RooAbsString.html,1,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategory.html:2261,clear,clearValueDirty,2261,root/html532/RooAbsCategory.html,https://root.cern,https://root.cern/root/html532/RooAbsCategory.html,1,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBinningCategory.html:2100,clear,clearValueDirty,2100,root/html532/RooBinningCategory.html,https://root.cern,https://root.cern/root/html532/RooBinningCategory.html,5,['clear'],['clearValueDirty']
Usability,"eProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::dependentOverlaps(const RooArgSet* depList, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStringVar.html:1984,clear,clearValueDirty,1984,root/html532/RooStringVar.html,https://root.cern,https://root.cern/root/html532/RooStringVar.html,1,['clear'],['clearValueDirty']
Usability,"eProp)RooAbsArg; CheckedHash()TObjectinline; checkObservables(const RooArgSet *nset) constRooAbsArgvirtual; chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataHist &data, const RooLinkedList &cmdList)RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooLinkedList &cmdList)RooAbsRealvirtual; Class()RooAbsPdfstatic; Class_Name()RooAbsPdfstatic; Class_Version()RooAbsPdfinlinestatic; ClassName() constTObjectvirtual; cleanBranchName() constRooAbsArgprotected; Clear(Option_t *option="""") overrideTNamedvirtual; clearEvalErrorLog()RooAbsRealstatic; clearShapeDirty() constRooAbsArginlineprotected; clearValueAndShapeDirty() constRooAbsArginlineprotected; clearValueDirty() constRooAbsArginlineprotected; clients() constRooAbsArginline; Clone(const char *newname=nullptr) const overrideRooAbsArginlinevirtual; clone(const char *newname=nullptr) const =0RooAbsArgpure virtual; cloneTree(const char *newname=nullptr) constRooAbsArgvirtual; CollectErrors enum valueRooAbsReal; Compare(const TObject *other) const overrideRooAbsArgvirtual; compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const overrideRooAbsPdfvirtual; ConfigChange enum valueRooAbsArg; constRooAbsArg; constRooAbsArg; ConstOpCode enum nameRooAbsArg; constOptimizeTestStatistic(ConstOpCode opcode, bool doAlsoTrackingOpt=true)RooAbsArgvirtual; ContentsOption enum nameRooPrintable; Copy(TObject &named) const overrideTNamedvirtual; copyCache(const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) overrideRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:5978,clear,clearEvalErrorLog,5978,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['clear'],['clearEvalErrorLog']
Usability,"ePtr;  CTConfigurationBase class of the Configurations ;  CTConfiguredAction;  CTIDNode;  CTLoopConfigurationBase class of the Configurations for the member wise looping routines ;  CTNestedIDs;  ►Nwriter;  Cwriter;  C_x3d_data_;  C_x3d_sizeof_;  CAnyCollectionProxy;  CAnyCollectionStreamer;  CBalancerInfo;  Cbasic_string_view;  CBasicRNNLayerGeneric implementation ;  ►CBidirMMapPipeBidirMMapPipe creates a bidirectional channel between the current process and a child it forks ;  CPollEntryFor poll() interface ;  CBinaryOpPolicy;  CBinomialNeymanInterval;  CBinomialProbHelper;  CClassificationClass to perform two class classification ;  CClassificationResultClass to save the results of the classifier ;  CColorStruct_t;  CCompareAsc;  CcompareBAasc;  CcompareBAdesc;  CCompareDesc;  CContDistFree functions adapter needed by UNURAN for onedimensional continuous distributions ;  CContextSmall helper to keep current directory context ;  CCpuInfo_t;  CDebuggingSamplerDebuggingSampler is a simple implementation of the DistributionCreator interface used for debugging ;  CDebuggingTestStatDebuggingTestStat is a simple implementation of the DistributionCreator interface used for debugging ;  CDiscrDistFree functions adapter needed by UNURAN for one-dimensional discrete distribution ;  CEvent_t;  CExceptionContext_t;  CFeldmanCousinsBinomialInterval;  CFeldmanCousinsSorter;  CFileStat_t;  CFontAttributes_t;  CFontMetrics_t;  CFoption_t;  Cfuncptr_and_voidptr_t;  CGcCache_t;  CGCValues_t;  CGraphCreatorHelperHelper class that provides the operation graph nodes ;  CGraphNodeClass used to create the operation graph to be printed in the dot representation ;  Cgroup;  Ch1analysis;  Ch1analysisTreeReader;  Chash< std::experimental::basic_string_view< _CharT, _Traits > >;  CHelperOps;  CHEPEVT_DEFHEPEVT common block ;  CHit;  CHoption_tHistogram option structure ;  CHparam_tHistogram parameters structure ;  CJet;  CJetEvent;  CMemInfo_t;  ►CMemPoolForRooSetsMemory pool for RooArgSet an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:95241,simpl,simple,95241,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"eReadCalls;  Number of read calls by basket to fill cached tree. ;  ; Int_t fNseek;  Number of blocks to be prefetched. ;  ; Int_t fNtot;  Total size of prefetched blocks. ;  ; Long64_t * fPos;  [fNb] start of long buffers ;  ; TFilePrefetch * fPrefetch;  ! Object that does the asynchronous reading in another thread ;  ; Long64_t fPrefetchedBlocks;  Number of blocks prefetched. ;  ; Int_t fReadCalls;  Number of read calls for this cache. ;  ; Long64_t * fSeek;  [fNseek] Position on file of buffers to be prefetched ;  ; Int_t * fSeekIndex;  [fNseek] sorted index table of fSeek ;  ; Int_t * fSeekLen;  [fNseek] Length of buffers to be prefetched ;  ; Int_t * fSeekPos;  [fNseek] Position of sorted blocks in fBuffer ;  ; Int_t fSeekSize;  Allocated size of fSeek. ;  ; Long64_t * fSeekSort;  [fNseek] Position on file of buffers to be prefetched (sorted) ;  ; Int_t * fSeekSortLen;  [fNseek] Length of buffers to be prefetched (sorted) ;  . Static Protected Attributes; static Int_t fgLearnEntries = 100;  number of entries used for learning mode ;  . Private Member Functions;  TTreeCache (const TTreeCache &)=delete;  this class cannot be copied ;  ; bool CalculateMissCache ();  Calculate the appropriate miss cache to fetch; helper function for FillMissCache. ;  ; TBranch * CalculateMissEntries (Long64_t, int, bool);  Given an file read, try to determine the corresponding branch. ;  ; bool CheckMissCache (char *buf, Long64_t pos, int len);  Check the miss cache for a particular buffer, fetching if deemed necessary. ;  ; bool FillMissCache ();  Fill the miss cache from the current set of active branches. ;  ; IOPos FindBranchBasketPos (TBranch &, Long64_t entry);  Given a branch and an entry, determine the file location (offset / size) of the corresponding basket. ;  ; TTreeCache & operator= (const TTreeCache &)=delete;  ; bool ProcessMiss (Long64_t pos, int len);  ! Given a file read not in the miss cache, handle (possibly) loading the data. ;  . Additional Inherited Members;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:32165,learn,learning,32165,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"eTracker Class ReferenceRooFit » RooFit Core. ; Meta object that tracks value changes in a given set of RooAbsArgs by registering itself as value client of these objects. ; The change tracker can perform an additional validation step where it also compares the numeric values of the tracked arguments with reference values to ensure that values have actually changed. This may be useful in case some of the tracked observables are in binned datasets where each observable propagates a valueDirty flag when an event is loaded even though usually only one observable actually changes. ; Definition at line 23 of file RooChangeTracker.h. Public Member Functions;  RooChangeTracker ()=default;  ;  RooChangeTracker (const char *name, const char *title, const RooArgSet &trackSet, bool checkValues=false);  Constructor. ;  ;  RooChangeTracker (const RooChangeTracker &other, const char *name=nullptr);  Copy constructor. ;  ; TObject * clone (const char *newname) const override;  ; bool hasChanged (bool clearState);  Returns true if state has changed since last call with clearState=true. ;  ; TClass * IsA () const override;  ; RooArgSet parameters () const;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:1291,clear,clearState,1291,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,2,['clear'],['clearState']
Usability,"eTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses, Otherwise just call the iterator's destructor. ;  ; Next_t GetFunctionNext (Bool_t read=kTRUE) override;  See typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end() 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end. ;  ; ULong_t GetIncrement () const override;  Return the offset between two consecutive value_types (memory layout). ;  ; virtual TClass * GetOnFileClass () const;  ; TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions (Int_t version) override;  Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ;  ; EDataType GetType () const override;  If the content is a simple numerical value, return its type (see TDataType) ;  ; TClass * GetValueClass () const override;  Return a pointer to the TClass representing the content. ;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions () override;  Return the set of action necessary to stream out this collection member-wise. ;  ; Bool_t HasPointers () const override;  Return true if the content is of type 'pointer to'. ;  ; void Insert (const void *data, void *container, size_t size) override;  Insert data into the container where data is a C-style array of the actual type contained in the collection of the given size. ;  ; virtual void operator() (TBuffer &refBuffer, void *pObject);  TClassStreamer IO overload. ;  ; void PopProxy () override;  Remove the last object. ;  ; void PushProxy (void *objstart) override;  Add an object. ;  ; Bool_t Reset () override;  Reset the info gathered from StreamerInfos and value's TClass. ;  ; virtual void Resize (UInt_t n, Bool_t force_delete);  Resize the container. ;  ; virtual void SetOnFileClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenCollectionStreamer.html:4202,simpl,simple,4202,doc/master/classTGenCollectionStreamer.html,https://root.cern,https://root.cern/doc/master/classTGenCollectionStreamer.html,1,['simpl'],['simple']
Usability,"eTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses, Otherwise just call the iterator's destructor. ;  ; Next_t GetFunctionNext (Bool_t read=kTRUE) override;  See typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end() 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end. ;  ; ULong_t GetIncrement () const override;  Return the offset between two consecutive value_types (memory layout). ;  ; virtual TClass * GetOnFileClass () const;  ; TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions (Int_t version) override;  Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ;  ; EDataType GetType () const override;  If the content is a simple numerical value, return its type (see TDataType) ;  ; TClass * GetValueClass () const override;  Return a pointer to the TClass representing the content. ;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions () override;  Return the set of action necessary to stream out this collection member-wise. ;  ; Bool_t HasPointers () const override;  Return true if the content is of type 'pointer to'. ;  ; void Insert (const void *data, void *container, size_t size) override;  Insert data into the container where data is a C-style array of the actual type contained in the collection of the given size. ;  ; virtual void operator() (TBuffer &refBuffer, void *pObject);  TClassStreamer IO overload. ;  ; void PopProxy () override;  Remove the last object. ;  ; void PushProxy (void *objstart) override;  Add an object. ;  ; Bool_t Reset () override;  Reset the info gathered from StreamerInfos and value's TClass. ;  ; virtual void SetOnFileClass (TClass *cl);  ; UInt_t Size () const override;  Return the current size of the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEmulatedCollectionProxy.html:7984,simpl,simple,7984,doc/master/classTEmulatedCollectionProxy.html,https://root.cern,https://root.cern/doc/master/classTEmulatedCollectionProxy.html,2,['simpl'],['simple']
Usability,"eTwoIterators_t)(void *begin, void *end); If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses, Otherwise just call the iterator's destructor. ;  ; Next_t GetFunctionNext (Bool_t read=kTRUE) override;  See typedef void* (*Next_t)(void *iter, void *end); iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end() 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end. ;  ; ULong_t GetIncrement () const override;  Return the offset between two consecutive value_types (memory layout). ;  ; virtual TClass * GetOnFileClass () const;  ; TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions (Int_t version) override;  Return the set of action necessary to stream in this collection member-wise coming from the old value class layout refered to by 'version'. ;  ; EDataType GetType () const override;  If the content is a simple numerical value, return its type (see TDataType) ;  ; TClass * GetValueClass () const override;  Return a pointer to the TClass representing the content. ;  ; TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions () override;  Return the set of action necessary to stream out this collection member-wise. ;  ; Bool_t HasPointers () const override;  Return true if the content is of type 'pointer to'. ;  ; void Insert (const void *data, void *container, size_t size) override;  Insert data into the container where data is a C-style array of the actual type contained in the collection of the given size. ;  ; virtual void operator() (TBuffer &refBuffer, void *pObject);  TClassStreamer IO overload. ;  ; void PopProxy () override;  Remove the last object. ;  ; void PushProxy (void *objstart) override;  Add an object. ;  ; virtual void ReadBuffer (TBuffer &b, void *obj);  ; virtual void ReadBuffer (TBuffer &b, void *obj, const TClass *onfileClass);  ; Bool_t Reset () override;  Reset the info gathered from StreamerInfos and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGenBitsetProxy.html:3771,simpl,simple,3771,doc/master/classTGenBitsetProxy.html,https://root.cern,https://root.cern/doc/master/classTGenBitsetProxy.html,7,['simpl'],['simple']
Usability,"eWeightFile, TDirectory* theTargetDir = __null); constructor from weight file. void Init( void ); default initialisation. void DeclareOptions(); define the options (their key words) that can be set in the option string. format of function string:; ""x0*(0)+((1)/x1)**(2)...""; where ""[i]"" are the parameters, and ""xi"" the input variables. format of parameter string:; ""(-1.2,3.4);(-2.3,4.55);...""; where the numbers in ""(a,b)"" correspond to the a=min, b=max parameter ranges;; each parameter defined in the function string must have a corresponding range. void CreateFormula(); translate formula string into TFormula, and parameter string into par ranges. void ProcessOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". ~MethodFDA( void ); destructor. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); FDA can handle classification with 2 classes and regression with one regression-target. void ClearAll( void ); delete and clear all class members. void Train( void ); FDA training. void PrintResults(const TString& , vector<Double_t>& , const Double_t ) const; display fit parameters; check maximum length of variable name. Double_t EstimatorFunction(vector<Double_t>& ); compute estimator for given parameter set (to be minimised); const Double_t sumOfWeights[] = { fSumOfWeightsSig, fSumOfWeightsBkg, fSumOfWeights };. Double_t InterpretFormula(const TMVA::Event* , vector<double>::iterator begin, vector<double>::iterator end); formula interpretation. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); returns MVA value for given event. const std::vector<Float_t>& GetRegressionValues(). const std::vector<Float_t>& GetMulticlassValues(). void CalculateMulticlassValues(const TMVA::Event*& evt, vector<Double_t>& parameters, vector<Float_t>& values); calculate the values for multiclass. void ReadWeightsFromStream(istream& i); read back the training results from a file (stream). void AddWeightsXMLT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodFDA.html:20240,clear,clear,20240,root/html602/TMVA__MethodFDA.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodFDA.html,2,['clear'],['clear']
Usability,"e_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add chain to data set. void RemoveChain(TChain* chain); Remove chain from data set. void GetLog(Int_t start = -1, Int_t end = -1); Ask for remote logs in the range [start, end]. If start == -1 all the; messages not yet received are sent bac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74972,feedback,feedback,74972,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['feedback'],['feedback']
Usability,"e_t* working_space, Int_t num, Int_t hartley, Int_t direction, Int_t zt_clear). AUXILIARY FUNCION. This function calculates Fourier based transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -hartley-1 if it is Hartley transform, 0 othewise; -direction-forward or inverse transform. void BitReverseHaar(Double_t* working_space, Int_t shift, Int_t num, Int_t start). AUXILIARY FUNCION. This function carries out bir-reverse reordering for Haar transform; Function parameters:; -working_space-pointer to vector of processed data; -shift-shift of position of processing; -start-initial position of processed data; -num-length of processed data. int GeneralExe(Double_t* working_space, Int_t zt_clear, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates generalized (mixed) transforms of different degrees; Function parameters:; -working_space-pointer to vector of transformed data; -zt_clear-flag to clear imaginary data before staring; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). int GeneralInv(Double_t* working_space, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates inverse generalized (mixed) transforms; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). void Transform(const Double_t* source, Double_t* destVector). ONE-DIMENSIONAL TRANSFORM FUNCTION; This function transforms the source spectrum. The calling program; should fill in input parameters.; Transformed data are written into dest spectrum. Function parameters:; source-pointer to the vector of source spectrum, its length should; be size except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transform. These need 2*size length to supply real and; imaginary coefficients.; des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumTransform.html:11664,clear,clear,11664,root/html602/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html602/TSpectrumTransform.html,2,['clear'],['clear']
Usability,"e_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6615,clear,clearEvalErrorLog,6615,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,3,['clear'],['clearEvalErrorLog']
Usability,"e_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooAbsRe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsPdf.html:6613,clear,clearValueDirty,6613,root/html532/RooAbsPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsPdf.html,1,['clear'],['clearValueDirty']
Usability,"e_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsAnaConvPdf.html:4256,clear,clearShapeDirty,4256,root/html532/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsAnaConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"e_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:3356,clear,clearShapeDirty,3356,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,1,['clear'],['clearShapeDirty']
Usability,"e_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:2957,clear,clearShapeDirty,2957,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,3,['clear'],['clearShapeDirty']
Usability,"e`) or not (`false`). It should perform ""read-only"" operations on the; 501columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 502when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 503names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 504certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 505loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 506 ; 507RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 508in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 509entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 510each entry: after the first access it simply serves a cached result.; 511 ; 512\anchor named-filters-and-cutflow-reports; 513#### Named filters and cutflow reports; 514An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 515work as usual, but also keep track of how many entries they accept and reject.; 516 ; 517Statistics are retrieved through a call to the Report() method:; 518 ; 519- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 520named filters declared up to that point; 521- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 522relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 523 ; 524Stats are stored in the same order as named filters have been added to the graph, and *refer to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:31191,simpl,simply,31191,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"e`) or not (`false`). It should perform ""read-only"" operations on the; 541columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 542when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 543names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 544certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 545loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 546 ; 547RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 548in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 549entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 550each entry: after the first access it simply serves a cached result.; 551 ; 552\anchor named-filters-and-cutflow-reports; 553#### Named filters and cutflow reports; 554An optional string parameter `name` can be passed to the Filter() method to create a **named filter**. Named filters; 555work as usual, but also keep track of how many entries they accept and reject.; 556 ; 557Statistics are retrieved through a call to the Report() method:; 558 ; 559- when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all; 560named filters declared up to that point; 561- when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport>; 562relative all named filters in the section of the chain between the main RDataFrame and that node (included).; 563 ; 564Stats are stored in the same order as named filters have been added to the graph, and *refer to the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:32831,simpl,simply,32831,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of TTrees or with tools such as TTree::Draw, TTree::Process, TSelector, TTreeReader and RDataFrame when in the learning phase. The learning phase is by default 100 entries. It can be changed via TTreeCache::SetLearnEntries.; The usage of a TTreeCache can considerably improve the runtime performance at the price of a modest investment in memory, in particular when the TTree is accessed remotely, e.g. via a high latency network.; For each TTree being processed a TTreeCache object is created. This object is automatically deleted when the Tree is deleted or when the file is deleted. The user can change the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:2495,learn,learning,2495,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"ead Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2105 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2127 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2144 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches. The default prefilling behavior can be controlled by setting TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. . Definition at line 2159 of file TTreeCache.cxx. ◆ SetOptimizeMisses(). void TTreeCache::SetOptimizeMisses ; (; bool ; opt). Start of methods for the miss cache. ; Enable / disable the miss cache.; The first time this is called on a TTreeCache object, the corresponding data structures will be allocated. Subsequent enable / disables will simply turn the fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:49429,learn,learning,49429,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"ead and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; TTree*fOwner! pointer to the owner Tree/chain; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; Bool_tfReadDirectionSet! read direction established; Bool_tfReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of sorted blocks in fBuffer; Int_tTFileCacheRead::fSeekSizeAllocated size of fSeek; Long64_t*TFileCacheRead::fSeekSort[fNseek] Position on file of buffers to be prefetched (sorted); Int_t*TFileCacheRead::fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted); TTree*fTree! pointer to the current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the bra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:19094,learn,learning,19094,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,1,['learn'],['learning']
Usability,"eadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:156050,simpl,simple,156050,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"eadWeightsFromStream() [3/3]. virtual void TMVA::MethodBase::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::MethodBase.; Definition at line 266 of file MethodBase.h. ◆ ReadWeightsFromXML(). void TMVA::MethodTMlpANN::ReadWeightsFromXML ; (; void * ; wghtnode). virtual . rebuild temporary textfile from xml weightfile and load this file into MLP ; Implements TMVA::MethodBase.; Definition at line 379 of file MethodTMlpANN.cxx. ◆ SetHiddenLayer(). void TMVA::MethodTMlpANN::SetHiddenLayer ; (; TString ; hiddenlayer = """"). inline . Definition at line 81 of file MethodTMlpANN.h. ◆ Streamer(). virtual void TMVA::MethodTMlpANN::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodTMlpANN::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 121 of file MethodTMlpANN.h. ◆ Train(). void TMVA::MethodTMlpANN::Train ; (; void ; ). virtual . performs TMlpANN training available learning methods: . TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once so merge the training and testing trees from the MVA factory first: ; Implements TMVA::MethodBase.; Definition at line 260 of file MethodTMlpANN.cxx. Member Data Documentation. ◆ fHiddenLayer. TString TMVA::MethodTMlpANN::fHiddenLayer. private . string containing the hidden layer structure ; Definition at line 111 of file MethodTMlpANN.h. ◆ fLayerSpec. TString TMVA::MethodTMlpANN::fLayerSpec. private . Layer specification option. ; Definition at line 106 of file MethodTMlpANN.h. ◆ fLearningMethod. TString TMVA::MethodTMlpANN::fLearningMethod. private . the learning method (given via option string) ; Definition at line 116 of file MethodTMlpANN.h. ◆ fLocalTrainingTree. TTree* TMVA::Method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html:35435,learn,learning,35435,doc/master/classTMVA_1_1MethodTMlpANN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodTMlpANN.html,1,['learn'],['learning']
Usability,"eal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooIntegralMorph.html:6574,clear,clearEvalError,6574,root/html534/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html534/RooIntegralMorph.html,3,['clear'],['clearEvalError']
Usability,"eal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:3786,clear,clearShapeDirty,3786,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,3,['clear'],['clearShapeDirty']
Usability,"ean and sigma parameters; the algorithm works on the same principle as in multivariate case -; it finds a subset of size hh with smallest sigma, and then returns mean and; sigma of this subset. Int_t GetBDPoint(); returns the breakdown point of the algorithm. Double_t GetChiQuant(Int_t i) const; returns the chi2 quantiles. void GetCovariance(TMatrixDSym& matr); returns the covariance matrix. void GetCorrelation(TMatrixDSym& matr); returns the correlation matrix. const TVectorD* GetHyperplane() const; if the points are on a hyperplane, returns this hyperplane. void GetHyperplane(TVectorD& vec); if the points are on a hyperplane, returns this hyperplane. void GetMean(TVectorD& means); return the estimate of the mean. void GetRDistances(TVectorD& rdist); returns the robust distances (helps to find outliers). Int_t GetNOut(); returns the number of outliers. void AddToSscp(TMatrixD& sscp, TVectorD& vec); update the sscp matrix with vector vec. void ClearSscp(TMatrixD& sscp); clear the sscp matrix, used for covariance and mean calculation. void Classic(); called when h=n. Returns classic covariance matrix; and mean. void Covar(TMatrixD& sscp, TVectorD& m, TMatrixDSym& cov, TVectorD& sd, Int_t nvec); calculates mean and covariance. void Correl(); transforms covariance matrix into correlation matrix. void CreateSubset(Int_t ntotal, Int_t htotal, Int_t p, Int_t* index, TMatrixD& data, TMatrixD& sscp, Double_t* ndist); creates a subset of htotal elements from ntotal elements; first, p+1 elements are drawn randomly(without repetitions); if their covariance matrix is singular, more elements are; added one by one, until their covariance matrix becomes regular; or it becomes clear that htotal observations lie on a hyperplane; If covariance matrix determinant!=0, distances of all ntotal elements; are calculated, using formula d_i=Sqrt((x_i-M)*S_inv*(x_i-M)), where; M is mean and S_inv is the inverse of the covariance matrix; htotal points with smallest distances are included in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRobustEstimator.html:13826,clear,clear,13826,root/html528/TRobustEstimator.html,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html,6,['clear'],['clear']
Usability,eanVariance;  CNetNeural net ;  CSettingsSettings for the training of the neural net ;  CSteepestSteepest Gradient Descent algorithm (SGD) ;  CTBatchTBatch ;  CTBatchIteratorTBatchIterator ;  CTCpuThe TCpu architecture class ;  ►CTCpuBufferTCpuBuffer ;  CTDestructor;  CTCpuMatrixThe TCpuMatrix class ;  CTCudaThe TCuda architecture class ;  ►CTCudaDeviceBufferTCudaDeviceBuffer ;  CTDestructor;  CTCudaDeviceReferenceTCudaDeviceReference ;  ►CTCudaHostBufferTCudaHostBuffer ;  CTDestructor;  CTCudaMatrixTCudaMatrix Class ;  CTDataLoaderTDataLoader ;  CTDeviceTDevice ;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTSharedLayerLayer class width shared weight and bias layers ;  ►NkNN;  CEvent;  CModulekNN;  CNode;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidation;  CCrossValidationResult;  CDataInputHandlerClass that contains all the data information ;  CDataLoader;  CDataSetClass that contains all ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:69305,simpl,simple,69305,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ean} \\; 51 \end{align}; 52 \f]; 53 The bin content is always the mean of the Y values, but errors change depending on options:; 54 \f[; 55 \begin{align}; 56 \text{GetBinContent}(j) &= h(j) \\; 57 \text{GetBinError}(j) &=; 58 \begin{cases}; 59 e(j) &\text{if option="""" (default). Error of the mean of all y values.} \\; 60 s(j) &\text{if option=""s"". Standard deviation of all y values.} \\; 61 \begin{cases} e(j) &\text{if } h(j) \ne 0 \\ 1/\sqrt{12 N} &\text{if } h(j)=0 \end{cases} &\text{if option=""i"". This is useful for storing integers such as ADC counts.} \\; 62 1/\sqrt{W(j)} &\text{if option=""g"". Error of a weighted mean for combining measurements with variances of } w. \\; 63 \end{cases}; 64 \end{align}; 65 \f]; 66 In the special case where s(j) is zero (eg, case of 1 entry only in one bin); 67 the bin error e(j) is computed from the average of the s(j) for all bins if; 68 the static function TProfile::Approximate() has been called.; 69 This simple/crude approximation was suggested in order to keep the bin; 70 during a fit operation. But note that this approximation is not the default behaviour.; 71 See also TProfile::BuildOptions for more on error options.; 72 ; 73 ### Creating and drawing a profile histogram; 74~~~{.cpp}; 75{; 76 auto c1 = new TCanvas(""c1"",""Profile histogram example"",200,10,700,500);; 77 auto hprof = new TProfile(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; 78 Float_t px, py, pz;; 79 for ( Int_t i=0; i<25000; i++) {; 80 gRandom->Rannor(px,py);; 81 pz = px*px + py*py;; 82 hprof->Fill(px,pz,1);; 83 }; 84 hprof->Draw();; 85}; 86~~~; 87*/; 88 ; 89////////////////////////////////////////////////////////////////////////////////; 90/// Default constructor for Profile histograms; 91 ; 92TProfile::TProfile(); 93{; 94 BuildOptions(0,0,"""");; 95}; 96 ; 97////////////////////////////////////////////////////////////////////////////////; 98/// Default destructor for Profile histograms; 99 ; 100TProfile::~TProfile(); 101{; 102}; 103 ; 104/////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:3182,simpl,simple,3182,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['simpl'],['simple']
Usability,"earningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26281,learn,learningRate,26281,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,ease 5.12/00d - 2006-09-02. Release 5.12/00 - 2006-07-14. Release 5.11/06 - 2006-06-07. Release 5.11/04 - 2006-05-31. Release 5.11/02 - 2006-05-08. Release 5.10/00 - 2006-03-02. Release 5.08/00 - 2005-12-15. Release 5.06/00 - 2005-10-31. Release 5.04/00 - 2005-09-20. Release 5.02/00 - 2005-07-05. Version 4 ; ; Release 4.04/02 - 2005-05-14. Release 4.03/04 - 2005-04-06. Release 4.03/02 - 2005-02-10. Release 4.02/00 - 2004-12-17. Release 4.01/04 - 2004-11-20. Release 4.01/02 - 2004-09-24. Release 4.00/08 - 2004-07-11. Release 4.00/06a - 2004-07-11. Release 4.00/06 - 2004-07-11. Release 4.00/04 - 2004-05-04. Release 4.00/03 - 2004-03-25. Release 4.00/02 - 2004-02-20. Release 4.00/01 - 2004-02-02. Version 3 ; ; Release 3.10/02 - 2004-01-23. Release 3.10/01a - 2004-01-23. Release 3.10/01 - 2004-01-23. Release 3.05/07a - 2003-08-06. Release 3.05/07 - 2003-07-27. Release 3.05/06 - 2003-07-18. Release 3.05/05 - 2003-05-08. Release 3.05/04 - 2003-04-21. Release 3.05/03 - 2003-03-11. Release 3.05/02 - 2003-02-12. Release 3.04/02 - 2002-12-18. Release 3.04/01 - 2002-12-11. Release 3.03/09b - 2002-11-05. Release 3.03/09a - 2002-10-31. Release 3.03/09 - 2002-09-18. Release 3.02/07 - 2002-02-06. . Release notes can be found on the respective release page; release notes for old releases can be found here. ; . Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/releases.html:8325,guid,guidelines,8325,d/releases.html,https://root.cern,https://root.cern/d/releases.html,1,['guid'],['guidelines']
Usability,"eates :; // - a one dimensional histogram; // - a two dimensional histogram; // - a profile histogram; // - a tree; //; // These objects are filled with some random numbers and saved on a file.; ; #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h""; ; //__________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");; ; // Create some histograms and a profile histogram; TH1F hpx(""hpx"",""This is the px distribution"",100,-4,4);; TH2F hpxpy(""hpxpy"",""py ps px"",40,-4,4,40,-4,4);; TProfile hprof(""hprof"",""Profile of pz versus px"",100,-4,4,0,20);; ; // Define some simple structures; typedef struct {Float_t x,y,z;} POINT;; typedef struct {; Int_t ntrack,nseg,nvertex;; UInt_t flag;; Float_t temperature;; } EVENTN;; POINT point;; EVENTN eventn;; ; // Create a ROOT Tree; TTree tree(""T"",""An example of ROOT tree with a few branches"");; tree.Branch(""point"",&point,""x:y:z"");; tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; ; Float_t px,py,pz;; ; // Here we start a loop on 1000 events; for ( Int_t i=0; i<1000; i++) {; gRandom->Rannor(px,py);; pz = px*px + py*py;; const auto random = gRandom->::Rndm(1);; ; // Fill histograms; hpx.Fill(px);; hpxpy.Fill(px,py,1);; hprof.Fill(px,pz,1);; ; // Fill structures; point.x = 10*(random-1);; point.y = 5*random;; point.z = 20*random;; eventn.ntrack = Int_t(100*random);; eventn.nseg = Int_t(2*eventn.ntrack);; eventn.nvertex = 1;; eventn.flag = Int_t(random+0.5);; eventn.temperature = 20+random;; ; // Fill the tree. For each event, save ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:12628,simpl,simple,12628,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simple']
Usability,"eation date, 3 - file modification date; utc - select timeZone to ‘UTC’; datex - X position of date; datey - Y position of date; optfile - plot file name on the canvas, 1 - file name, 2 - full file URL, 3 - object item name; opttitle - disable/enable drawing of object title in the canvas; nomenu - disable context menu; notouch - disable touch events handling; progress - switch progress display mode between ‘off’, ‘on’ and ‘modal’. For instance:. https://root.cern/js/latest/?file=../files/hsimple.root&item=hpx;1; https://root.cern/js/latest/?file=../files/hsimple.root&nobrowser&item=hpxpy;1&opt=colz; https://root.cern/js/latest/?file=../files/hsimple.root&noselect&layout=grid2x2&item=hprof;1. Following layouts are supported:. simple - available space used for single object (default); flex - creates as many frames as necessary, each can be individually moved/enlarged; tabs - tabs for each object drawing; gridNxM - fixed-size grid with NxM frames; vertN - N frames sorted in vertical direction (like gridi1xN); horizN - N frames sorted in horizontal direction (like gridiNx1); vert121 - 3 frames sorted in vertical direction, second frame divided on two sub-frames; horiz32_12 - 2 horizontal frames with 3 and 2 subframes, and 1/3 and 2/3 as relative size. When specifying files, items or opts parameters, array of strings could be provided like files=['file1.root','file2.root']. One could skip quotes when specifying elements names items=[file1.root/hpx,file2.root/hpy] or opts=['',colz].; As item name, URL to existing image can be provided like item=img:http://server/image.png. Such image will be just inserted in the existing layout. One could specify option ""scale"" to automatically scale image to available space.; Many examples of URL string usage can be found on JSROOT API examples page.; One can very easy integrate JSROOT graphic into arbitrary HTML pages using a iframe tag:; <iframe width=""700"" height=""400""; src=""https://root.cern/js/latest/?nobrowser&file=https://root.cern",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:4353,simpl,simple,4353,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['simpl'],['simple']
Usability,"ec"": 1.5,; 1486 ""sample_category"" = ""MC_background""; 1487 }; 1488 }; 1489 }; 1490}; 1491~~~; 1492 ; 1493The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1494For example, to access luminosity information (stored as a double):; 1495 ; 1496~~~{.python}; 1497df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1498~~~; 1499 ; 1500or sample_category information (stored as a string):; 1501 ; 1502~~~{.python}; 1503df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1504~~~; 1505 ; 1506or directly the filename:; 1507 ; 1508~~~{.python}; 1509df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1510~~~; 1511 ; 1512An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1513provides a corresponding exemplary JSON file for the dataset specification.; 1514 ; 1515\anchor progressbar; 1516### Adding a progress bar ; 1517 ; 1518A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1519The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1520and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1521n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1522 ; 1523ProgressBar is added after creating the dataframe object (df):; 1524~~~{.cpp}; 1525ROOT::RDataFrame df(""tree"", ""file.root"");; 1526ROOT::RDF::Experimental::AddProgressBar(df);; 1527~~~; 1528 ; 1529Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1530For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1531with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:85552,progress bar,progress bar,85552,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,2,['progress bar'],['progress bar']
Usability,"ec"": 1.5,; 1526 ""sample_category"" = ""MC_background""; 1527 }; 1528 }; 1529 }; 1530}; 1531~~~; 1532 ; 1533The metadata information from the specification file can be then accessed using the DefinePerSample function.; 1534For example, to access luminosity information (stored as a double):; 1535 ; 1536~~~{.python}; 1537df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); 1538~~~; 1539 ; 1540or sample_category information (stored as a string):; 1541 ; 1542~~~{.python}; 1543df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); 1544~~~; 1545 ; 1546or directly the filename:; 1547 ; 1548~~~{.python}; 1549df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); 1550~~~; 1551 ; 1552An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also; 1553provides a corresponding exemplary JSON file for the dataset specification.; 1554 ; 1555\anchor progressbar; 1556### Adding a progress bar ; 1557 ; 1558A progress bar showing the processed event statistics can be added to any RDataFrame program.; 1559The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing ; 1560and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every ; 1561n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled. ; 1562 ; 1563ProgressBar is added after creating the dataframe object (df):; 1564~~~{.cpp}; 1565ROOT::RDataFrame df(""tree"", ""file.root"");; 1566ROOT::RDF::Experimental::AddProgressBar(df);; 1567~~~; 1568 ; 1569Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility ; 1570For example, it can be called at any computational node, such as Filter or Define, not only the head node,; 1571with no change to the ProgressBar function itself (please see the [Efficient analysis in Python](#python) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:87232,progress bar,progress bar,87232,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['progress bar'],['progress bar']
Usability,"ec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs cell /afs/cern.ch/sw/root/<version>/<platform>. To use them, simply modify your shell environment accordingly. For Unix:; export PATH=$ROOTSYS/bin:$PYTHONDIR/bin:$PATH; export LD_LIBRARY_PATH=$ROOTSYS/lib:$PYTHONDIR/lib:$LD_LIBRARY_PATH; export PYTHONPATH=$ROOTSYS/lib:$PYTHONPATH; For Windows:; set PATH=%ROOTSYS%/bin;%PYTHONDIR%/bin;%PATH%; set PYTHONPATH=%ROOTSYS%/bin;%PYTHONPATH%; where $ROOTSYS should be set to /afs/cern.ch/sw/root/<version>/<platform>, and PYTHONDIR to /afs/cern.ch/sw/lcg/external/Python/2.3.4/<platform> with <version> and <platform> as appropriate. Note that the latest version of Python is 2.4.1.; 19.1.4.2 Building from Source; The standard installation instructions for building ROOT from source apply, with the addition that the build of PyROOT needs to be enabled at the configuration step. First, follow the instructions for obtaining and unpacking the source, and setting up the build environment.; Then, use the following command to configure the build process (of course, feel free to add any additional flags you may need):; $ ./configure <a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1047078,simpl,simply,1047078,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"eclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 52 of file TXMLPlayer.h. ◆ ElementGetter(). const char * TXMLPlayer::ElementGetter ; (; TClass * ; cl, . const char * ; membername, . int ; specials = 0 . ). protected . produce code to access member of given class. ; Parameter specials has following meaning: 0 - nothing special 1 - cast to data type 2 - produce pointer on given member 3 - skip casting when produce pointer by buf.P() function ; Definition at line 333 of file TXMLPlayer.cxx. ◆ ElementSetter(). const char * TXMLPlayer::ElementSetter ; (; TClass * ; cl, . const char * ; membername, . char * ; endch . ). protected . Produce code to set value to given data member. ; endch should be output after value is specified. ; Definition at line 392 of file TXMLPlayer.cxx. ◆ GetBasicTypeName(). TString TXMLPlayer::GetBasicTypeName ; (; TStreamerElement * ; el). protected . return simple data types for given TStreamerElement object ; Definition at line 260 of file TXMLPlayer.cxx. ◆ GetBasicTypeReaderMethodName(). TString TXMLPlayer::GetBasicTypeReaderMethodName ; (; Int_t ; type, . const char * ; realname . ). protected . return functions name to read simple data type from xml file ; Definition at line 293 of file TXMLPlayer.cxx. ◆ GetMemberTypeName(). TString TXMLPlayer::GetMemberTypeName ; (; TDataMember * ; member). protected . returns name of simple data type for given data member ; Definition at line 222 of file TXMLPlayer.cxx. ◆ GetStreamerName(). TString TXMLPlayer::GetStreamerName ; (; TClass * ; cl). protected . returns streamer function name for given class ; Definition at line 150 of file TXMLPlayer.cxx. ◆ IsA(). TClass * TXMLPlayer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 52 of file TXMLPlayer.h. ◆ ProduceCode(). Bool_t TXMLPlayer::ProduceCode ; (; TList * ; cllist, . const char * ; filename . ). Produ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLPlayer.html:13589,simpl,simple,13589,doc/master/classTXMLPlayer.html,https://root.cern,https://root.cern/doc/master/classTXMLPlayer.html,1,['simpl'],['simple']
Usability,"ect 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj, Bool_t& merged); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerRemote.html:19364,feedback,feedback,19364,root/html532/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html532/TProofPlayerRemote.html,4,['feedback'],['feedback']
Usability,"ect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t MakeSelector (const char *selfile);  Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reportin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:21109,feedback,feedback,21109,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"ect can be requested and displayed in the web browser. There are many benefits of such approach:. standard http interface to ROOT application; no any temporary ROOT files to access data; user interface running in all browsers. 1.1 Starting the HTTP server; To start the http server, at any time, create an instance of the THttpServer class like:; serv = new THttpServer(""http:8080"");; This will start a civetweb-based http server on the port 8080. Then one should be able to open the address “http://localhost:8080” in any modern browser (IE9, Firefox, Chrome, Opera) and browse objects created in application. By default, the server can access files, canvases, and histograms via the gROOT pointer. All those objects can be displayed with JSROOT graphics.; There is a snapshot (frozen copy) of such server, running in tutorials/http/httpserver.C macro from ROOT tutorial.; <iframe width=“800” height=“500” src=“https://root.cern.ch/js/3.6/httpserver.C/?layout=simple&item=Canvases/c1”> ; One could specify several options when creating http server. They could be add as additional URL parameters to the constructor arguments like:; serv = new THttpServer(""http:8080?loopback&thrds=2"");; Following parameters are supported:. thrds=N - number of threads used by the civetweb (default is 5); top=name - configure top name, visible in the web browser; auth_file=filename - authentication file name, created with htdigets utility; auth_domain=domain - authentication domain; loopback - bind specified port to loopback 127.0.0.1 address; debug - enable debug mode, server always returns html page with request info. If necessary, one could bind http server to specific IP address like:; new THttpServer(""http:192.168.1.17:8080""); 1.2 Registering objects; At any time, one could register other objects with the command:; TGraph* gr = new TGraph(10);; gr->SetName(""gr1"");; serv->Register(""graphs/subfolder"", gr);; One should specify sub-folder name, where objects will be registered. If sub-folder name does",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/HttpServer/HttpServer.html:1776,simpl,simple,1776,root/html534/guides/HttpServer/HttpServer.html,https://root.cern,https://root.cern/root/html534/guides/HttpServer/HttpServer.html,1,['simpl'],['simple']
Usability,"ect editor in a transient frame. Closing these transient frames will not delete, but just hide existing opened editors for later reuse. Their lifetime is determined by the canvas to which the manager editor is attached to, since these will be destroyed together. Editors for shapes, materials, media, matrices; For most editors, the functionalities Apply and Undo are provided.; For shapes, changing any of the shape parameters will activate the ""Apply"" button only if the check button ""Delayed draw"" is checked, otherwise the changes are immediately applied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:141323,undo,undoable,141323,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['undo'],['undoable']
Usability,"ect to the weights. Exploiting the well-known properties of the derivative, especially the derivative of compound functions, one can write:. for a neuron: product of the local derivative with the weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative of the output neuron. This computation is called back-propagation of the errors. A loop over all examples is called an epoch. Six learning methods are implemented.; Stochastic minimization:; is the most trivial learning method. This is the Robbins-Monro stochastic approximation applied to multilayer perceptrons. The weights are updated after each example according to the formula: \(w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)\); with; \(\Delta w_{ij}(t) = - \eta(d e_p / d w_{ij} + \delta) + \epsilon \Delta w_{ij}(t-1)\); The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent with fixed step size (batch learning):; It is the same as the stochastic minimization, but the weights are updated after considering all the examples, with the total derivative dEdw. The parameters for this method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm:; Weights are set to the minimum along the line defined by the gradient. The only parameter for this method is Tau. Lower tau = higher precision = slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the Polak-Ribiere updating formula:; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; Conjugate gradients with the Fletcher-Reeves updating formula:; Weights are set to the minimum along the line defined by the conjugate gradient. Parameters are Tau and Reset, which defines the epochs where the direction is reset to the steepest descent.; Broyden, Fletcher, Goldfarb, Shanno (BFGS) method:; Implies the computation of a NxN matrix compu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:4764,learn,learning,4764,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"ect(name, tree);; if (tree) {; tree->Print();; return 0;; } else {; Error(""printTree()"", ""Cannot find tree %s!"", name);; return -1;; }; }. You can now run this as; .x printTree.C(file, ""MyTree"");. This is equivalent to; .L printTree.C; printTree(file, ""MyTree"");. Compiling; You can also have your code compiled into a shared library, simply by adding a ""+"" behind the file name:; .x printTree.C+(file, ""MyTree"");. In the above example this will fail: we need to add the #includes for he compiler to be able to understand the code, while the interpreter has a lot of contextual knowledge and can automatically include headers and load libraries.; Expressions; You saw that with "".x"", ROOT prints the result of running the function while when using "".L"" and calling th function it does not. The way to trigger the printing of expression results is by omitting the trailing semicolon:; TMath::Gaus(1., 1., 1.). will print; (Double_t) 1.000000e+00. Help!; For TMath::Gaus() as well as for any other ROOT class or function, please check ROOT's reference guide.; Try to find the documentation for TTree::Print()!; We have now covered the basics - let's look at the tree's data!; . ‹ 1. Extracting an object from a TFile; up; 4. Histogramming ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/2-running-code-root.html:3312,guid,guide,3312,d/2-running-code-root.html,https://root.cern,https://root.cern/d/2-running-code-root.html,1,['guid'],['guide']
Usability,"ect::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TMethod*fMethodpointer to a method. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TMethodBrowsable(const TBranch* branch, TMethod* m, const TVirtualBranchBrowsable* parent = 0); Constructor.; Links a TBranchElement to a TMethod, allowing the TBrowser to; browse simple methods. The c'tor sets the name for a method ""Class::Method(params) const""; to ""Method(params)"", title to TMethod::GetPrototype. void GetBrowsableMethodsForClass(TClass* cl, TList& list); Given a class, this methods fills list with TMethodBrowsables; for the class and its base classes, and returns the number of; added elements. If called from a TBranch::Browse overload, ""branch""; should be set to the calling TBranch, otherwise ""parent"" should; be set to the TVirtualBranchBrowsable being browsed, and branch; should be the branch of the parent. Int_t GetBrowsables(TList& list, const TBranch* branch, const TVirtualBranchBrowsable* parent = 0); This methods fills list with TMethodBrowsables; for the branch's or parent's class and its base classes, and returns; the number of added elements. If called from a TBranch::Browse; overload, ""branch"" should be set to the calling TBranch, otherwise; ""parent"" should be set to the TVirtualBranchBrowsable being brows",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodBrowsable.html:9597,simpl,simple,9597,root/html602/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TMethodBrowsable.html,2,['simpl'],['simple']
Usability,"ect::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Timer.html:8094,progress bar,progress bar,8094,root/html604/TMVA__Timer.html,https://root.cern,https://root.cern/root/html604/TMVA__Timer.html,2,['progress bar'],['progress bar']
Usability,"ect::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. Bool_tfColourfulOutputflag for use of colors; TMVA::MsgLogger*fLoggerthe output logger; Int_tfNcountsreference number of ""counts""; TStringfPrefixprefix for outputs; static const TStringfgClassNameused for output; static const Int_tfgNbinsnumber of bins in progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE); constructor. Timer(Int_t ncounts, const char* prefix = """", Bool_t colourfulOutput = kTRUE); standard constructor: ncounts gives the total number of counts that; the loop will iterate through. At each call of the timer, the current; number of counts is provided by the user, so that the timer can obtain; the due time from linearly interpolating the spent time. ~Timer( void ); destructor. void Init(Int_t ncounts); timer initialisation. void Reset( void ); resets timer. Double_t ElapsedSeconds( void ); computes elapsed tim in seconds. TString GetElapsedTime(Bool_t Scientific = kTRUE); returns pretty string with elaplsed time. TString GetLeftTime(Int_t icounts); returns pretty string with time left. void DrawProgressBar(); draws the progressbar. void DrawProgressBar(TString ); draws a string in the progress bar. void DrawProgressBar(Int_t , const TString& comment = """"); draws progress bar in color or B&W; caution:. TString SecToText(Double_t , Bool_t ) const; pretty string output. Timer(const char* prefix = """", Bool_t colourfulOutput = kTRUE). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2006: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Timer.html:8086,progress bar,progress bar,8086,root/html602/TMVA__Timer.html,https://root.cern,https://root.cern/root/html602/TMVA__Timer.html,2,['progress bar'],['progress bar']
Usability,"ected . Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ; Definition at line 1915 of file TProofPlayer.cxx. ◆ IsA(). TClass * TProofPlayerRemote::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 366 of file TProofPlayer.h. ◆ IsClient(). Bool_t TProofPlayerRemote::IsClient ; (; ); const. overridevirtual . Is the player running on the client? ; Reimplemented from TProofPlayer.; Definition at line 4223 of file TProofPlayer.cxx. ◆ JoinProcess(). Bool_t TProofPlayerRemote::JoinProcess ; (; TList * ; workers). overridevirtual . Prepares the given list of new workers to join a progressing process. ; Returns kTRUE on success, kFALSE otherwise. ; Reimplemented from TProofPlayer.; Definition at line 2533 of file TProofPlayer.cxx. ◆ MergeFeedback(). TList * TProofPlayerRemote::MergeFeedback ; (; ). protected . Merge feedback lists. ; Definition at line 3926 of file TProofPlayer.cxx. ◆ MergeOutput(). void TProofPlayerRemote::MergeOutput ; (; Bool_t ; savememvalues = kFALSE). overridevirtual . Merge objects in output the lists. ; Reimplemented from TProofPlayer.; Definition at line 3114 of file TProofPlayer.cxx. ◆ MergeOutputFiles(). Bool_t TProofPlayerRemote::MergeOutputFiles ; (; ). protected . Merge output in files. ; Definition at line 2582 of file TProofPlayer.cxx. ◆ NotifyMemory(). void TProofPlayerRemote::NotifyMemory ; (; TObject * ; obj). protected . Printout the memory record after merging object 'obj' This record is used by the memory monitor. ; Definition at line 3593 of file TProofPlayer.cxx. ◆ Process() [1/2]. Long64_t TProofPlayerRemote::Process ; (; TDSet * ; dset, . const char * ; selector_file, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:31837,feedback,feedback,31837,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 * ; ematrix, . const char * ; name, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance contribution from background normalisation uncertainty ; Parameters. [in,out]ematrixoutput histogram ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram prior to adding the covariance matrix contribution. this method returns the uncertainties on the unfolding result arising from the background source source and its normalisation uncertainty. See method SubtractBackground() how to set the normalisation uncertainty ; the array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:38142,clear,clearEmat,38142,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,1,['clear'],['clearEmat']
Usability,"ectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Get variable buffer. TTreeFormula* GetVar(Int_t i) const; Get variable formula. void InitArrays(Int_t newsize); Initialization of the primitive type arrays if the new size is bigger than the available space. UInt_t SplitNames(const TString& varexp, vector<TString>& names); Build Index array for names in varexp.; This will allocated a C style array of TString and Ints. Bool_t Notify(); This function is called at the first entry of a new tree in a chain. void ProcessFill(Long64_t entry); Called in the entry loop for all entries accepted by Select. void ProcessFillMultiple(Long64_t entry); Call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelectorDraw.html:9526,simpl,simplest,9526,root/html528/TSelectorDraw.html,https://root.cern,https://root.cern/root/html528/TSelectorDraw.html,1,['simpl'],['simplest']
Usability,"ectedRows][fDimension] Local buffer for the variables; Int_tfValSize; TTreeFormula**fVar![fDimension] Array of pointers to variables formula; Bool_t*fVarMultiple![fDimension] true if fVar[i] has a variable index; Double_t*fVmax![fDimension] Maxima of varexp columns; Double_t*fVmin![fDimension] Minima of varexp columns; Double_t*fW![fSelectedRows]Local buffer for weights; Double_tfWeightTree weight (see TTree::SetWeight). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSelectorDraw(); Default selector constructor. ~TSelectorDraw(); Selector destructor. void Begin(TTree* tree); Called everytime a loop on the tree(s) starts. void ClearFormula(); Delete internal buffers. Bool_t CompileVariables(const char* varexp = """", const char* selection = """"); Compile input variables and selection expression. varexp is an expression of the general form e1:e2:e3; where e1,etc is a formula referencing a combination of the columns; Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x). selection is an expression with a combination of the columns; Example:; selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized. Return kFALSE if any of the variable is not compilable. Double_t* GetVal(Int_t i) const; Return the last values corresponding to the i-th component; of the formula being processed (where the component are ':' separated).; The actual number of entries is:; GetSelectedRows() % tree->GetEstimate(); Note GetSelectedRows currently returns the actual number of values plotted; and thus if the formula contains arrays, this number might be greater than; the number of entries in the trees.; By default TTree::Draw creates the arrays obtained; with all GetVal and GetW with a length corresponding to the; parameter fEstimate. By default fEstimate=10000 and can be modified; via TTree::SetEstim",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSelectorDraw.html:9632,simpl,simplest,9632,root/html530/TSelectorDraw.html,https://root.cern,https://root.cern/root/html530/TSelectorDraw.html,3,['simpl'],['simplest']
Usability,"ection of TGraph objects; TMultiLayerPerceptron a Neural Network; TMutex Mutex lock class; TMutexImp Mutex lock implementation ABC; TMySQLResult MySQL query result; TMySQLRow One row of MySQL query result; TMySQLServer Connection to MySQL server; TMySQLStatement SQL statement class for MySQL DB; TNDArray Base for n-dimensional array; TNDArrayRef<Long64_t> subdimension of a TNDArray; TNDArrayRef<ULong64_t> subdimension of a TNDArray; TNDArrayRef<char> subdimension of a TNDArray; TNDArrayRef<double> subdimension of a TNDArray; TNDArrayRef<float> subdimension of a TNDArray; TNDArrayRef<int> subdimension of a TNDArray; TNDArrayRef<long> subdimension of a TNDArray; TNDArrayRef<short> subdimension of a TNDArray; TNDArrayRef<unsigned int> subdimension of a TNDArray; TNDArrayRef<unsigned long> subdimension of a TNDArray; TNDArrayRef<unsigned short> subdimension of a TNDArray; TNDArrayT<Long64_t> N-dimensional array; TNDArrayT<ULong64_t> N-dimensional array; TNDArrayT<char> N-dimensional array; TNDArrayT<double> N-dimensional array; TNDArrayT<float> N-dimensional array; TNDArrayT<int> N-dimensional array; TNDArrayT<long> N-dimensional array; TNDArrayT<short> N-dimensional array; TNDArrayT<unsigned int> N-dimensional array; TNDArrayT<unsigned long> N-dimensional array; TNDArrayT<unsigned short> N-dimensional array; TNamed The basis for a named object (name, title); TNetFile A ROOT file that reads/writes via a rootd server; TNetFileStager Implementation for a 'rootd' backend; TNetSystem Directory handler for NetSystem; TNetXNGFile ROOT class definition; TNetXNGFileStager ! Interface to a 'XRD' staging; TNetXNGSystem ROOT class definition; TNeuron Neuron for MultiLayerPerceptrons; TNewChainDlg New chain dialog; TNewQueryDlg New query dialog; TNode Description of parameters to position a 3-D geometry object; TNodeDiv Description of parameters to divide a 3-D geometry object; TNonSplitBrowsable Helper object to browse unsplit objects; TNtuple A simple tree with branches of floats.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:117040,simpl,simple,117040,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['simpl'],['simple']
Usability,"ection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TGraphA TGraph is an object made of two arrays X and Y with npoints each.Definition TGraph.h:41; TGraph::SetPointvirtual void SetPoint(Int_t i, Double_t x, Double_t y)Set x and y values for point number i.Definition TGraph.cxx:2342; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::SetBinContentvirtual void SetBinContent(Int_t bin, Double_t content)Set bin content see convention for numbering bins in TH1::GetBin In case the bin number is greater th...Definition TH1.cxx:9222; TListA doubly linked list.Definition TList.h:38; TList::AtTObject * At(Int_t idx) const overrideReturns the object at position idx. Returns 0 if idx is out of range.Definition TList.cxx:355; TMVA::BinarySearchTreeA simple Binary search tree including a volume search method.Definition BinarySearchTree.h:65; TMVA::Config::WriteOptionsReferenceBool_t WriteOptionsReference() constDefinition Config.h:65; TMVA::Configurable::CheckForUnusedOptionsvoid CheckForUnusedOptions() constchecks for unused options in option stringDefinition Configurable.cxx:270; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMVA::EventDefinition Event.h:51; TMVA::Event::GetValueFloat_t GetValue(UInt_t ivar) constreturn value of i'th variableDefinition Event.cxx:236; TMVA::FitterBaseBase class for TMVA fitters.Definition FitterBase.h:51; TMVA::FitterBase::SetIPythonInteractivevoid SetIPythonInteractive(bool *ExitFromTraining, UInt_t *fIPyMaxIter_, UInt_t *fIPyCurrentIter_)Definition FitterBase.h:73; TMVA::FitterBase::RunDouble_t Run()estimator function interface for fittingDefinition FitterBase.cxx:74; TMVA::GeneticFitterFitter using a Genetic Algorithm.Definition GeneticFitter.h:44; TMVA::Interval",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:76905,simpl,simple,76905,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['simpl'],['simple']
Usability,"ection::sort(Bool_t ascend = kTRUE); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; voidRooAbsCollection::takeOwnership(); Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteToFile(const char* fileName) const; virtual voidwriteToStream(ostream& os, Bool_t compact, const char* section = 0) const. protected:. Bool_tRooAbsCollection::addServerClonesToList(const RooAbsArg& var); Bool_tcheckForDup(const RooAbsArg& arg, Bool_t silent) const; voidRooAbsCollection::clearStructureTags(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidRooAbsCollection::makeStructureTag(); voidRooAbsCollection::makeTypedStructureTag(); voidTObject::MakeZombie(); voidRooAbsCollection::safeDeleteList(); TNamed*RooAbsCollection::structureTag(); TNamed*RooAbsCollection::typedStructureTag(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_tRooAbsCollection::_allRRVAll contents are RRV; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; Bool_tRooAbsCollection::_ownContFlag to identif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgSet.html:12961,clear,clearStructureTags,12961,root/html532/RooArgSet.html,https://root.cern,https://root.cern/root/html532/RooArgSet.html,1,['clear'],['clearStructureTags']
Usability,"ection; if (reqSections & TBuffer3D::kRaw) {; //buffer.SetSectionsValid(TBuffer3D::kRaw);; }; ; return buffer;; }; ; class Box : public Shape; {; public:; Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ);; ~Box() override {};; ; TBuffer3D & GetBuffer3D(UInt_t reqSections) override;; ; private:; Double_t fDX, fDY, fDZ; // Half lengths; ; ClassDefOverride(Box,0);; };; ; ClassImp(Box);; ; Box::Box(Int_t color, Double_t x, Double_t y, Double_t z,; Double_t dX, Double_t dY, Double_t dZ) :; Shape(color,x,y,z),; fDX(dX), fDY(dY), fDZ(dZ); {}; ; TBuffer3D & Box::GetBuffer3D(UInt_t reqSections); {; static TBuffer3D buffer(TBuffer3DTypes::kGeneric);; ; // Complete kCore section - this could be moved to Shape base class; if (reqSections & TBuffer3D::kCore) {; buffer.ClearSectionsValid();; buffer.fID = this;; buffer.fColor = fColor; // Color index - see gROOT->GetColor(); buffer.fTransparency = 0; // Transparency 0 (opaque) - 100 (fully transparent); ; // Complete local/master transformation matrix - simple x/y/z; // translation. Easiest way to set identity then override the; // translation components; buffer.SetLocalMasterIdentity();; buffer.fLocalMaster[12] = fX;; buffer.fLocalMaster[13] = fY;; buffer.fLocalMaster[14] = fZ;; buffer.fLocalFrame = kTRUE; // Local frame; ; buffer.fReflection = kFALSE;; buffer.SetSectionsValid(TBuffer3D::kCore);; }; // Complete kBoundingBox section; if (reqSections & TBuffer3D::kBoundingBox) {; Double_t origin[3] = { fX, fY, fZ };; Double_t halfLength[3] = { fDX, fDY, fDZ };; buffer.SetAABoundingBox(origin, halfLength);; buffer.SetSectionsValid(TBuffer3D::kBoundingBox);; }; // No kShapeSpecific section; ; // Complete kRawSizes section; if (reqSections & TBuffer3D::kRawSizes) {; buffer.SetRawSizes(8, 3*8, 12, 3*12, 6, 6*6);; buffer.SetSectionsValid(TBuffer3D::kRawSizes);; }; // Complete kRaw section; if (reqSections & TBuffer3D::kRaw) {; // Points (8); // 3 components: x,y,z; buffer.fPnts[ 0] = fX - fDX; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/viewer3DLocal_8C.html:4984,simpl,simple,4984,doc/master/viewer3DLocal_8C.html,https://root.cern,https://root.cern/doc/master/viewer3DLocal_8C.html,1,['simpl'],['simple']
Usability,"ectionProxy::CheckFunctions() const; virtual voidTGenCollectionProxy::DeleteItem(Bool_t force, void* ptr) const; voidExpand(UInt_t nCurr, UInt_t left); TGenCollectionProxy*TGenCollectionProxy::Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent); voidReadItems(int nElements, TBuffer& b); voidShrink(UInt_t nCurr, UInt_t left, Bool_t force); voidWriteItems(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEmulatedCollectionProxy.html:4340,clear,clear,4340,root/html532/TEmulatedCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TEmulatedCollectionProxy.html,1,['clear'],['clear']
Usability,"ector< double > m_dropOutDefinition NeuralNet.h:850; TMVA::DNN::Settings::m_minProgressdouble m_minProgresscurrent limits for the progress barDefinition NeuralNet.h:833; TMVA::DNN::Settings::cyclevirtual void cycle(double progress, TString text)Definition NeuralNet.h:799; TMVA::DNN::Settings::setProgressLimitsvirtual void setProgressLimits(double minProgress=0, double maxProgress=100)Definition NeuralNet.h:790; TMVA::DNN::Settings::m_maxProgressdouble m_maxProgresscurrent limits for the progress barDefinition NeuralNet.h:834; TMVA::DNN::Settings::endTrainCyclevirtual void endTrainCycle(double)callback for monitoring and loggingDefinition NeuralNet.h:788; TMVA::DNN::Settings::count_dEsize_t count_dEDefinition NeuralNet.h:843; TMVA::DNN::Settings::drawSamplevirtual void drawSample(const std::vector< double > &, const std::vector< double > &, const std::vector< double > &, double)callback for monitoring and loggingDefinition NeuralNet.h:807; TMVA::DNN::Settings::learningRatedouble learningRate() constget the learning rateDefinition NeuralNet.h:771; TMVA::DNN::Settings::m_dropRepetitionsdouble m_dropRepetitionsDefinition NeuralNet.h:849; TMVA::DNN::Settings::dropFractionsconst std::vector< double > & dropFractions() constDefinition NeuralNet.h:762; TMVA::DNN::Settings::addPointvoid addPoint(std::string histoName, double x)for monitoringDefinition NeuralNet.h:821; TMVA::DNN::Settings::~Settingsvirtual ~Settings()d'torDefinition NeuralNet.cxx:261; TMVA::DNN::Settings::m_convergenceCountsize_t m_convergenceCountDefinition NeuralNet.h:857; TMVA::DNN::Settings::m_regularizationEnumRegularization m_regularizationDefinition NeuralNet.h:847; TMVA::DNN::Settings::repetitionsint repetitions() consthow many steps have to be gone until the batch is changedDefinition NeuralNet.h:773; TMVA::DNN::Settings::m_minErrordouble m_minErrorDefinition NeuralNet.h:859; TMVA::DNN::Settings::testSamplevirtual void testSample(double, double, double, double)virtual function to be used for monitorin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:74593,learn,learningRatedouble,74593,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['learn'],"['learning', 'learningRate', 'learningRatedouble']"
Usability,"ectory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCFunction1Binding.html:45370,clear,clearEvalErrorLog,45370,doc/master/classRooCFunction1Binding.html,https://root.cern,https://root.cern/doc/master/classRooCFunction1Binding.html,42,['clear'],['clearEvalErrorLog']
Usability,"ects () const;  Return list of all generic objects in the workspace. ;  ; RooArgSet allPdfs () const;  Return set with all probability density function objects. ;  ; RooArgSet allResolutionModels () const;  Return set with all resolution model objects. ;  ; RooArgSet allVars () const;  Return set with all variable objects. ;  ; RooAbsArg * arg (RooStringView name) const;  Return RooAbsArg with given name. A null pointer is returned if none is found. ;  ; RooArgSet argSet (RooStringView nameList) const;  Return set of RooAbsArgs matching to given list of names. ;  ; bool cancelTransaction ();  Cancel an ongoing import transaction. ;  ; RooCategory * cat (RooStringView name) const;  Retrieve discrete variable (RooCategory) with given name. A null pointer is returned if not found. ;  ; RooAbsCategory * catfunc (RooStringView name) const;  Retrieve discrete function (RooAbsCategory) with given name. A null pointer is returned if not found. ;  ; bool cd (const char *path=nullptr);  ; void clearStudies ();  Remove all RooStudyManager modules. ;  ; TObject * Clone (const char *newname="""") const override;  TObject::Clone() needs to be overridden. ;  ; bool commitTransaction ();  ; const RooArgSet & components () const;  ; RooAbsData * data (RooStringView name) const;  Retrieve dataset (binned or unbinned) with given name. A null pointer is returned if not found. ;  ; bool defineSet (const char *name, const char *contentList);  Define a named set in the workspace through a comma separated list of names of objects already in the workspace. ;  ; bool defineSet (const char *name, const RooArgSet &aset, bool importMissing=false);  Define a named RooArgSet with given constituents. ;  ; RooAbsData * embeddedData (RooStringView name) const;  Retrieve dataset (binned or unbinned) with given name. A null pointer is returned if not found. ;  ; RooExpensiveObjectCache & expensiveObjectCache ();  ; bool extendSet (const char *name, const char *newContents);  Define a named set in the wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWorkspace.html:4134,clear,clearStudies,4134,doc/master/classRooWorkspace.html,https://root.cern,https://root.cern/doc/master/classRooWorkspace.html,1,['clear'],['clearStudies']
Usability,"ects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's see it in action.; 59# We will now use the `MyClass` class for the first time from Python: we will; 60# create a new instance of that class. At this moment, the pythonizor will; 61# execute and modify the class - pythonizors are always lazily run when a given; 62# class is used for the first time from a Python script.; 63my_object = ROOT.MyClass(); 64 ; 65# Since the pythonizor already executed, we should now see the new behaviour.; 66# For that purpose, let's print `my_object` (should show ""This is a MyClass; 67# object"").; 68print(my_object); 69 ; 70# The previous example is just a simple one, but there are many ways in which a; 71# class can be pythonized. Typical examples are the redefinition of dunder; 72# methods (e.g. `__iter__` and `__next__` to make your objects iterable from; 73# Python). If you need some inspiration, many ROOT classes are pythonized in; 74# the way we just saw; their pythonizations can be seen at:; 75# https://github.com/root-project/root/tree/master/bindings/pyroot/pythonizations/python/ROOT/pythonization; 76 ; 77# The @pythonization decorator offers a few more options when it comes to; 78# matching classes that you want to pythonize. We saw that we can match a; 79# single class, but we can also specify a list of classes to pythonize.; 80#; 81# The following code defines a couple of new classes:; 82ROOT.gInterpreter.Declare('''; 83namespace NS {; 84 class Class1 {};; 85 class Class2 {};; 86}; 87'''); 88 ; 89# Note that these classes belong to the `NS` namespace. As mentioned above, the; 90# @pythonization decorator accepts a parameter with the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:3495,simpl,simple,3495,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionMethodBrowsable(const TCollectionMethodBrowsable&); virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionMethodBrowsable.html:1433,simpl,simple,1433,root/html526/TCollectionMethodBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionMethodBrowsable.html,5,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TCollectionPropertyBrowsable(const TCollectionPropertyBrowsable&); virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCollectionPropertyBrowsable.html:1446,simpl,simple,1446,root/html526/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html526/TCollectionPropertyBrowsable.html,5,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TMethodBrowsable(const TMethodBrowsable&); virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Brow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMethodBrowsable.html:1410,simpl,simple,1410,root/html528/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html528/TMethodBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TNonSplitBrowsable(const TNonSplitBrowsable&); virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNonSplitBrowsable.html:1416,simpl,simple,1416,root/html528/TNonSplitBrowsable.html,https://root.cern,https://root.cern/root/html528/TNonSplitBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable(const TVirtualBranchBrowsable&); virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:1414,simpl,simple,1414,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,4,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionMethodBrowsable.html:1433,simpl,simple,1433,root/html602/TCollectionMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionMethodBrowsable.html,2,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TCollectionPropertyBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TCollectionPropertyBrowsable.html:1446,simpl,simple,1446,root/html602/TCollectionPropertyBrowsable.html,https://root.cern,https://root.cern/root/html602/TCollectionPropertyBrowsable.html,2,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TMethodBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMethodBrowsable.html:1410,simpl,simple,1410,root/html602/TMethodBrowsable.html,https://root.cern,https://root.cern/root/html602/TMethodBrowsable.html,2,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TNonSplitBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTVirtualBranchBrowsable::Browse(TBrowser* b); static TClass*Class(); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNonSplitBrowsable.html:1416,simpl,simple,1416,root/html602/TNonSplitBrowsable.html,https://root.cern,https://root.cern/root/html602/TNonSplitBrowsable.html,2,['simpl'],['simple']
Usability,"ects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchBrowsable(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualBranchBrowsable.html:1438,simpl,simple,1438,root/html602/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html,2,['simpl'],['simple']
Usability,"ecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; voidGetBackground(TH1* bgr, const char* bgrSource = 0, const Int_t* binMap = 0, Int_t includeError = 3, Bool_t clearHist = kTRUE) const; voidTUnfold::GetBias(TH1* bias, const Int_t* binMap = 0) const; Double_tTUnfold::GetChi2A() const; Double_tTUnfold::GetChi2L() const; Double_tGetChi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:5928,clear,clearEmat,5928,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,3,['clear'],['clearEmat']
Usability,"ed . Add widget catched from external scripts. ; Definition at line 573 of file RBrowser.cxx. ◆ AddInitWidget(). void RBrowser::AddInitWidget ; (; const std::string & ; kind). protected . Create new widget and send init message to the client. ; Definition at line 592 of file RBrowser.cxx. ◆ AddRCanvas(). void ROOT::RBrowser::AddRCanvas ; (; ). inline . Definition at line 86 of file RBrowser.hxx. ◆ AddTCanvas(). void ROOT::RBrowser::AddTCanvas ; (; ). inline . Definition at line 85 of file RBrowser.hxx. ◆ AddWidget(). std::shared_ptr< RBrowserWidget > RBrowser::AddWidget ; (; const std::string & ; kind). protected . Creates new widget. ; Definition at line 541 of file RBrowser.cxx. ◆ CheckWidgtesModified(). void RBrowser::CheckWidgtesModified ; (; ). protected . Check if any widget was modified and update if necessary. ; Definition at line 752 of file RBrowser.cxx. ◆ ClearOnClose(). void RBrowser::ClearOnClose ; (; const std::shared_ptr< void > & ; handle). Set handle which will be cleared when connection is closed. ; Definition at line 975 of file RBrowser.cxx. ◆ CloseTab(). void RBrowser::CloseTab ; (; const std::string & ; name). protected . Close and delete specified widget. ; Definition at line 618 of file RBrowser.cxx. ◆ FindWidget(). std::shared_ptr< RBrowserWidget > RBrowser::FindWidget ; (; const std::string & ; name, . const std::string & ; kind = """" . ); const. protected . Find widget by name or kind. ; Definition at line 602 of file RBrowser.cxx. ◆ GetActiveWidget(). std::shared_ptr< RBrowserWidget > ROOT::RBrowser::GetActiveWidget ; (; ); const. inlineprotected . Definition at line 54 of file RBrowser.hxx. ◆ GetCatchWindowShow(). bool ROOT::RBrowser::GetCatchWindowShow ; (; ); const. inline . Is RWebWindow::Show calls catched for embeding of created widgets. ; Definition at line 102 of file RBrowser.hxx. ◆ GetCurrentWorkingDirectory(). std::string RBrowser::GetCurrentWorkingDirectory ; (; ). protected . Return the current directory of ROOT. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RBrowser.html:6445,clear,cleared,6445,doc/v632/classROOT_1_1RBrowser.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RBrowser.html,1,['clear'],['cleared']
Usability,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query information frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionQueryFrame.html:20543,progress bar,progress bar,20543,root/html534/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html534/TSessionQueryFrame.html,3,['progress bar'],['progress bar']
Usability,"ed by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fBtnAbortabort process button; TGTextButton*fBtnFinalizefinalize query button; TGTextButton*fBtnRetrieveretrieve query button; TGTextButton*fBtnSavesave query button; TGTextButton*fBtnShowLogshow log button; TGTextButton*fBtnStopstop process button; TGTextButton*fBtnSubmitsubmit query button; TQueryDescription*fDescquery description; TRootEmbeddedCanvas*fECanvasnode statistics embeded canvas; Long64_tfEntriesnumber of events/entries to process; TGCompositeFrame*fFA; TGCompositeFrame*fFB; TGCompositeFrame*fFCthree tabs element; TEditQueryFrame*fFDfourth tab element (edit query frame); Int_tfFilesnumber of files processed; Long64_tfFirstfirst event/entry to process; TGTextView*fInfoTextViewsummary on current query; TGLabel*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feed",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:20249,progress bar,progress bar,20249,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,9,['progress bar'],['progress bar']
Usability,"ed columns. ; Implemented in ROOT::Experimental::Internal::RPageNullSink, ROOT::Experimental::Internal::RPageSinkBuf, and ROOT::Experimental::Internal::RPagePersistentSink. Member Data Documentation. ◆ fCompressor. std::unique_ptr<RNTupleCompressor> ROOT::Experimental::Internal::RPageSink::fCompressor. protected . Helper to zip pages and header/footer; includes a 16MB (kMAXZIPBUF) zip buffer. ; There could be concrete page sinks that don't need a compressor. Therefore, and in order to stay consistent with the page source, we leave it up to the derived class whether or not the compressor gets constructed. ; Definition at line 280 of file RPageStorage.hxx. ◆ fIsInitialized. bool ROOT::Experimental::Internal::RPageSink::fIsInitialized = false. private . Flag if sink was initialized. ; Definition at line 291 of file RPageStorage.hxx. ◆ fOnDatasetCommitCallbacks. std::vector<Callback_t> ROOT::Experimental::Internal::RPageSink::fOnDatasetCommitCallbacks. private . Definition at line 292 of file RPageStorage.hxx. ◆ fOptions. std::unique_ptr<RNTupleWriteOptions> ROOT::Experimental::Internal::RPageSink::fOptions. protected . Definition at line 275 of file RPageStorage.hxx. ◆ fSealPageBuffer. std::vector<unsigned char> ROOT::Experimental::Internal::RPageSink::fSealPageBuffer. private . Used as destination buffer in the simple SealPage overload. ; Definition at line 293 of file RPageStorage.hxx. ◆ fWritePageMemoryManager. RWritePageMemoryManager ROOT::Experimental::Internal::RPageSink::fWritePageMemoryManager. private . Used in ReservePage to maintain the page buffer budget. ; Definition at line 296 of file RPageStorage.hxx. Libraries for ROOT::Experimental::Internal::RPageSink:. [legend]; The documentation for this class was generated from the following files:; tree/ntuple/v7/inc/ROOT/RPageStorage.hxx; tree/ntuple/v7/src/RPageStorage.cxx. ROOTExperimentalInternalRPageSink. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:14 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html:18828,simpl,simple,18828,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSink.html,1,['simpl'],['simple']
Usability,"ed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuations in the unfolded spectrum. The optimal regularisation can be determined following guidelines in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] using the distribution of the |d_i|<\tt> that can be obtained by tsvdunf->GetD() and/or using pseudo-experiments.; ; Covariance matrices on the measured spectrum (for either the total uncertainties or individual sources of uncertainties) can be propagated to covariance matrices using the GetUnfoldCovMatrix method, which uses pseudo experiments for the propagation. In addition, GetAdetCovMatrix allows for the propagation of the statistical uncertainties on the response matrix using pseudo experiments. The covariance matrix corresponding to Bcov is also computed as described in Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] and can be obtained from tsvdunf->GetXtau() and its (regularisation independent) inverse from tsvdunf->GetXinv(). The distribution of singular values can be retrieved using tsvdunf->GetSV().; ; See also the tutorial for a toy example.; ; . Function Members (Methods); public:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSVDUnfold.html:2084,guid,guidelines,2084,root/html534/TSVDUnfold.html,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html,3,['guid'],['guidelines']
Usability,"ed for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTrapEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for para editor. ~TGeoTrapEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. Bool_t IsDelayed() const; Check if shape drawing is delayed. void DoName(); Slot for name. void DoApply(); Slot for applying current settings. void DoModified(); Slot for notifying modifications. void DoUndo(); Slot for undoing last operation. void DoH1(); Slot for H1. void DoBl1(); Slot for Bl1. void DoTl1(); Slot for Tl1. void DoDz(); Slot for Z. void DoSc1(); Slot for H2. void DoSc2(); Slot for H2. void DoAlpha1(); Slot for alpha1. void DoTheta(); Slot for theta. void DoPhi(); Slot for phi. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTrapEditor.html:21991,undo,undoing,21991,root/html534/TGeoTrapEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTrapEditor.html,1,['undo'],['undoing']
Usability,"ed int ipar = 0; ipar < npar; ++ipar) {; 161 const ParameterSettings & par = fconfig.ParSettings(ipar);; 162 if (par.IsFixed() ) fFixedParams[ipar] = true;; 163 else nfree++;; 164 if (par.IsBound() ) {; 165 double lower = (par.HasLowerLimit()) ? par.LowerLimit() : - std::numeric_limits<double>::infinity() ;; 166 double upper = (par.HasUpperLimit()) ? par.UpperLimit() : std::numeric_limits<double>::infinity() ;; 167 fBoundParams[ipar] = fParamBounds.size();; 168 fParamBounds.push_back(std::make_pair(lower,upper));; 169 }; 170 }; 171 // check if nfree (from FitConfig) and fNFree (from minimizer) are consistent; 172 if (nfree != fNFree ) {; 173 MATH_ERROR_MSG(""FitResult"",""FitConfiguration and Minimizer result are not consistent"");; 174 std::cout << ""Number of free parameters from FitConfig = "" << nfree << std::endl;; 175 std::cout << ""Number of free parameters from Minimizer = "" << fNFree << std::endl;; 176 }; 177 ; 178 // if flag is binned compute a chi2 when a chi2 function is given; 179 if (fitType == 1) {; 180 if (chi2func == nullptr); 181 fChi2 = fVal;; 182 else {; 183 // compute chi2 equivalent for likelihood fits; 184 // NB: empty bins are considered; 185 fChi2 = (*chi2func)(&fParams[0]);; 186 }; 187 }; 188 else if (fitType == 3) {; 189 // case of binned likelihood fits (use Baker-Cousins chi2); 190 fChi2 = 2 * fVal;; 191 }; 192 ; 193 // fill error matrix; 194 // if minimizer provides error provides also error matrix; 195 // clear in case of re-filling an existing result; 196 if (!fCovMatrix.empty()) fCovMatrix.clear();; 197 if (!fGlobalCC.empty()) fGlobalCC.clear();; 198 ; 199 if (min->Errors() != nullptr) {; 200 ; 201 fErrors = std::vector<double>(min->Errors(), min->Errors() + npar ) ;; 202 ; 203 if (fCovStatus != 0) {; 204 unsigned int r = npar * ( npar + 1 )/2;; 205 fCovMatrix.reserve(r);; 206 for (unsigned int i = 0; i < npar; ++i); 207 for (unsigned int j = 0; j <= i; ++j); 208 fCovMatrix.push_back(min->CovMatrix(i,j) );; 209 }; 210 // minos errors are se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:6788,clear,clear,6788,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['clear'],['clear']
Usability,"ed is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:25857,learn,learning,25857,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['learn'],['learning']
Usability,"ed object. RooPlot* GetPosteriorPlot(bool norm = false, double precision = 0.01) const; return a RooPlot with the posterior and the credibility region; NOTE: User takes ownership of the returned object. void SetIntegrationType(const char* type); set the integration type (possible type are) :; 1D integration ( used when only one nuisance and when the posterior is scanned):; adaptive , gauss, nonadaptive; multidim:; ADAPTIVE, adaptive numerical integration; The parameter numIters (settable with SetNumIters) is the max number of function calls.; It can be reduced to make teh integration faster but it will be difficult to reach the required tolerance; VEGAS MC integration method based on importance sampling - numIters is number of function calls; Extra Vegas parameter can be set using IntegratorMultiDimOptions class; MISER MC integration method based on stratified sampling; See also http://en.wikipedia.org/wiki/Monte_Carlo_integration for VEGAS and MISER description; PLAIN simple MC integration method, where the max number of calls can be specified using SetNumIters(numIters). Extra integration types are:. TOYMC:; evaluate posterior by generating toy MC for the nuisance parameters. It is a MC; integration, where the function is sampled according to the nuisance. It is convenient to use when all; the nuisance are uncorrelated and it is efficient to generate them; The toy are generated by default for each poi values; (this method has been proposed and provided by J.P Chou); 1-TOYMC : same method as before but in this case the toys are generated only one time and then used for; each poi value. It can be convenient when the generation time is much larger than the evaluation time,; otherwise it is recoomended to re-generate the toy for each poi scanned point of the posterior function. ROOFIT:; use roofit default integration methods which will produce a nested integral (not reccomended for more; than 1 nuisance parameters). if type = 0 use default specified via class Integrato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__BayesianCalculator.html:13030,simpl,simple,13030,root/html530/RooStats__BayesianCalculator.html,https://root.cern,https://root.cern/root/html530/RooStats__BayesianCalculator.html,5,['simpl'],['simple']
Usability,"ed to _any_ kind of plot (components, asymmetries, efficiencies; // etc..); model.plotOn(frame, VisualizeError(*r, 1), FillColor(kOrange), Components(""bkg""));; model.plotOn(frame, VisualizeError(*r, 1, false), DrawOption(""L""), LineWidth(2), LineColor(kRed), Components(""bkg""),; LineStyle(kDashed));; ; // Overlay central value; model.plotOn(frame);; model.plotOn(frame, Components(""bkg""), LineStyle(kDashed));; d->plotOn(frame);; frame->SetMinimum(0);; ; // V i s u a l i z e p a r t i a l f i t e r r o r; // ------------------------------------------------------; ; // Make plot frame; RooPlot *frame2 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (m,m2)""));; ; // Visualize partial error. For partial error visualization the covariance matrix is first reduced as follows; // ___ -1; // Vred = V22 = V11 - V12 * V22 * V21; //; // Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; // are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; // is the Shur complement of V22, calculated as shown above; //; // (Note that Vred is _not_ a simple sub-matrix of V); ; // Propagate partial error due to shape parameters (m,m2) using linear and sampling method; model.plotOn(frame2, VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; model.plotOn(frame2, Components(""bkg""), VisualizeError(*r, RooArgSet(m, m2), 2), FillColor(kCyan));; ; model.plotOn(frame2);; model.plotOn(frame2, Components(""bkg""), LineStyle(kDashed));; frame2->SetMinimum(0);; ; // Make plot frame; RooPlot *frame3 = x.frame(Bins(40), Title(""Visualization of 2-sigma partial error from (s,s2)""));; ; // Propagate partial error due to yield parameter using linear and sampling method; model.plotOn(frame3, VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; model.plotOn(frame3, Components(""bkg""), VisualizeError(*r, RooArgSet(s, s2), 2), FillColor(kGreen));; ; model.plotOn(frame3);; model.plotO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8C.html:4519,simpl,simple,4519,doc/master/rf610__visualerror_8C.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8C.html,1,['simpl'],['simple']
Usability,"ed to suggest the type of action that; 104one can do on this object. Clicking with the right mouse button on an object; 105pops-up a contextmenu with a complete list of actions possible on this object.; 106 ; 107A graphical editor may be started from the canvas ""View"" menu under the menu; 108entry ""Toolbar"".; 109 ; 110An interactive HELP is available by clicking on the HELP button at the top right; 111of the canvas. It gives a short explanation about the canvas' menus.; 112 ; 113A canvas may be automatically divided into pads via `TPad::Divide`.; 114 ; 115At creation time, no matter if in interactive or batch mode, the constructor; 116defines the size of the canvas window (including the size of the window; 117manager's decoration). To define precisely the graphics area size of a canvas in; 118the interactive mode, the following four lines of code should be used:; 119~~~ {.cpp}; 120 {; 121 Double_t w = 600;; 122 Double_t h = 600;; 123 auto c = new TCanvas(""c"", ""c"", w, h);; 124 c->SetWindowSize(w + (w - c->GetWw()), h + (h - c->GetWh()));; 125 }; 126~~~; 127and in the batch mode simply do:; 128~~~ {.cpp}; 129 c->SetCanvasSize(w,h);; 130~~~; 131 ; 132If the canvas size exceeds the window size, scroll bars will be added to the canvas; 133This allows to display very large canvases (even bigger than the screen size). The; 134Following example shows how to proceed.; 135~~~ {.cpp}; 136 {; 137 auto c = new TCanvas(""c"",""c"");; 138 c->SetCanvasSize(1500, 1500);; 139 c->SetWindowSize(500, 500);; 140 }; 141~~~; 142*/; 143 ; 144////////////////////////////////////////////////////////////////////////////////; 145/// Canvas default constructor.; 146 ; 147TCanvas::TCanvas(Bool_t build) : TPad(), fDoubleBuffer(0); 148{; 149 fPainter = nullptr;; 150 fWindowTopX = 0;; 151 fWindowTopY = 0;; 152 fWindowWidth = 0;; 153 fWindowHeight = 0;; 154 fCw = 0;; 155 fCh = 0;; 156 fXsizeUser = 0;; 157 fYsizeUser = 0;; 158 fXsizeReal = kDefaultCanvasSize;; 159 fYsizeReal = kDefaultCanvasSize;; 160 fHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:4135,simpl,simply,4135,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['simpl'],['simply']
Usability,"ed to the integrand of which the integral is requested. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumFunc to more intuitively reflect the contents of the product operator construction. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound to this RooAbsReal with give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumFunc.html:3204,simpl,simple,3204,doc/v632/classRooRealSumFunc.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumFunc.html,2,['simpl'],['simple']
Usability,"ed when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:2001,learn,learning,2001,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['learn'],['learning']
Usability,"ed) return;; 6391 }; 6392 ; 6393 // Get Primitives; 6394 prims = gPad->GetListOfPrimitives();; 6395 n = TMath::Min(15,prims->GetSize());; 6396 Int_t lineColor = TColor::GetColor(239, 202, 0);; 6397 ; 6398 TAttBBox2D *cur = dynamic_cast<TAttBBox2D *>( object );; 6399 if (cur) {; 6400 //create invisible TPad above gPad; 6401 if (!tmpGuideLinePad){; 6402 tmpGuideLinePad = new TPad(""tmpGuideLinePad"", ""tmpGuideLinePad"", 0, 0, 1, 1);; 6403 Double_t x1, y1, x2, y2;; 6404 gPad->GetRange(x1, y1, x2, y2);; 6405 tmpGuideLinePad->Range(x1, y1, x2, y2);; 6406 tmpGuideLinePad->SetFillStyle(0);; 6407 tmpGuideLinePad->SetFillColor(0);; 6408 tmpGuideLinePad->Draw();; 6409 tmpGuideLinePad->cd();; 6410 gPad->GetRange(x1, y1, x2, y2);; 6411 }; 6412 if (cling && !log) threshold = 7;; 6413 else threshold = 1;; 6414 ; 6415 Rectangle_t BBox = cur->GetBBox();; 6416 TPoint center = cur->GetBBoxCenter();; 6417 ; 6418 otherDist.clear();; 6419 curDist.clear();; 6420 ; 6421 switch (event) {; 6422 ; 6423 case kButton1Down:; 6424 case kButton1Motion:; 6425 MX = gPad->GetX1() + 0.5 * (gPad->GetX2()-gPad->GetX1());; 6426 MY = gPad->GetY1() + 0.5 * (gPad->GetY2()-gPad->GetY1());; 6427 pMX = gPad->XtoPixel(MX);; 6428 pMY = gPad->YtoPixel(MY);; 6429 // Middlelines; 6430 if (TMath::Abs(pMX-center.GetX())<threshold) {; 6431 if (cling && (!resize)) {; 6432 cur->SetBBoxCenterX(pMX);; 6433 center = cur->GetBBoxCenter();; 6434 BBox = cur->GetBBox();; 6435 center = cur->GetBBoxCenter();; 6436 }; 6437 L = new TLine(MX, gPad->GetY1(), MX, gPad->GetY2());; 6438 L->SetBit(kCanDelete);; 6439 L->SetLineColor(lineColor);; 6440 L->Draw();; 6441 }; 6442 if (TMath::Abs(pMY-center.GetY())<threshold) {; 6443 if (cling && (!resize)) {; 6444 cur->SetBBoxCenterY(pMY);; 6445 center = cur->GetBBoxCenter();; 6446 BBox = cur->GetBBox();; 6447 center = cur->GetBBoxCenter();; 6448 }; 6449 L = new TLine(gPad->GetX1(), MY, gPad->GetX2(), MY);; 6450 L->SetBit(kCanDelete);; 6451 L->SetLineColor(lineColor);; 6452 L->Draw();; 6453 }; 64",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:211468,clear,clear,211468,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['clear'],['clear']
Usability,"ed). Since TGeoTube derives brom the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:4346,learn,learned,4346,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,9,['learn'],['learned']
Usability,"ed). Since TGeoTube derives from the base shape class, we can provide it to the volume; constructor :. TGeoVolume *wire_co = new TGeoVolume(""WIRE_CO"", tube, ptrCOPPER);. Do not bother to delete neither the media, shapes or volumes that you have; created since all will be automatically cleaned on exit by the manager class.; If we would have taken a look inside TGeoManager::MakeTube() method, we would; have been able to create our wire with a single line :. TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);. The same applies for all primitive shapes, for which there can be found; corresponding MakeSHAPE() methods. Their usage is much more convenient unless; a shape has to be shared between more volumes. Let's make now an aluminium wire; having the same shape, supposing that we have created the copper wire with the; line above :. TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);. Now that we have learned how to create elementary volumes, let's see how we; can create a geometrical hierarchy. Positioning volumes. When creating a volume one does not specify if this will contain or not other; volumes. Adding daughters to a volume implies creating those and adding them; one by one to the list of daughters. Since the volume has to know the position; of all its daughters, we will have to supply at the same time a geometrical; transformation with respect to its local reference frame for each of them.; The objects referencing a volume and a transformation are called NODES and; their creation is fully handled by the modeler. They represent the link; elements in the hierarchy of volumes. Nodes are unique and distinct geometrical; objects ONLY from their container point of view. Since volumes can be replicated; in the geometry, the same node may be found on different branches. /*. */. An important observation is that volume objects are owned by the TGeoManager; class. This stores a list of all volumes in the geometry, that is c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:4366,learn,learned,4366,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['learn'],['learned']
Usability,"ed* set2RangeName = 0); Bool_tcontainsSet1(const RooArgSet* set1); Int_tentries() const; Int_tindex(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); voidinitialize(const RooNormSetCache& other); virtual TClass*IsA() const; const RooArgSet*lastSet1() const; const RooArgSet*lastSet2() const; const RooNameSet&nameSet1() const; const RooNameSet&nameSet2() const; RooNormSetCache&operator=(const RooNormSetCache&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. ULong_t_max!; RooNameSet_name1!; RooNameSet_name2!; ULong_t_next!; map<pair<const RooArgSet*,const RooArgSet*>,unsigned long>_pairToIdx!; vector<pair<const RooArgSet*,const RooArgSet*> >_pairs!; TNamed*_set2RangeName!. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNormSetCache(ULong_t max = 32). ~RooNormSetCache(); Destructor. void clear(); Clear contents. void add(const RooArgSet* set1, const RooArgSet* set2 = 0); Add given pair of RooArgSet pointers to our store. Bool_t autoCache(const RooAbsArg* self, const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0, Bool_t autoRefill = kTRUE); If RooArgSets set1 and set2 or sets with similar contents have; been seen by this cache manager before return kFALSE If not,; return kTRUE. If sets have not been seen and doRefill is true,; update cache reference to current input sets. RooNormSetCache(ULong_t max = 32). Int_t index(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); Match range name first. Bool_t contains(const RooArgSet* set1, const RooArgSet* set2 = 0, const TNamed* set2RangeName = 0); { return (index(set1,set2,set2RangeName) >= 0); }. Bool_t containsSet1(const RooArgSet* set1). const RooArgSet* lastSet1() const; { return _pairs.empty()?0:_pairs.back().first; }. const RooArgSet* lastSet2() const; { return _pairs.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNormSetCache.html:2474,clear,clear,2474,root/html534/RooNormSetCache.html,https://root.cern,https://root.cern/root/html534/RooNormSetCache.html,1,['clear'],['clear']
Usability,"ed. Unless overridden by derived classes, this always returns false. ;  ; double maxVal (Int_t code) const override;  Return maximum value for set of observables identified by code assigned in getMaxVal. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &obs, double xlo, double xhi) const override;  Return sampling hint for making curves of (projections) of this function as the recursive division strategy of RooCurve cannot deal efficiently with the vertical lines that occur in a non-interpolated histogram. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCdfBoundaries (bool flag);  ; void setInterpolationOrder (Int_t order);  ; void setUnitNorm (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class RooHistPdf. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, const char *title=nullptr);  Constructor with name and title only. ;  ;  ~RooAbsPdf () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). ;  ; virtual RooAbsGenContext * autoGenContext (const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") const;  ; virtual RooAbsGenContext * binnedGenContext (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistPdf.html:4156,simpl,simple,4156,doc/master/classRooHistPdf.html,https://root.cern,https://root.cern/doc/master/classRooHistPdf.html,1,['simpl'],['simple']
Usability,"ed.Definition TCanvas.cxx:2476; TCanvas::fBatchBool_t fBatch! True when in batchmodeDefinition TCanvas.h:59; TCanvas::fUseGLBool_t fUseGL! True when rendering is with GLDefinition TCanvas.h:62; TCanvas::GetEventYInt_t GetEventY() const overrideDefinition TCanvas.h:137; TCanvas::fEventXInt_t fEventX! Last X mouse position in canvasDefinition TCanvas.h:46; TCanvas::IsBatchBool_t IsBatch() const overrideDefinition TCanvas.h:171; TCanvas::DrawCloneTObject * DrawClone(Option_t *option="""") const overrideDraw a clone of this canvas A new canvas is created that is a clone of this canvas.Definition TCanvas.cxx:907; TCanvas::fXsizeRealSize_t fXsizeRealCurrent size of canvas along X in CM.Definition TCanvas.h:35; TCanvas::HasMenuBarBool_t HasMenuBar() constDefinition TCanvas.h:168; TCanvas::GetCanvasPainterTVirtualPadPainter * GetCanvasPainter()Access and (probably) creation of pad painter.Definition TCanvas.cxx:2616; TCanvas::HighlightConnectvirtual void HighlightConnect(const char *slot)This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot.Definition TCanvas.cxx:1631; TCanvas::PickTPad * Pick(Int_t px, Int_t py, TObjLink *&pickobj) overrideSearch for an object at pixel position px,py.Definition TCanvas.h:183; TCanvas::Closevoid Close(Option_t *option="""") overrideClose canvas.Definition TCanvas.cxx:788; TCanvas::SetFixedAspectRatiovoid SetFixedAspectRatio(Bool_t fixed=kTRUE) overrideFix canvas aspect ratio to current value if fixed is true.Definition TCanvas.cxx:2016; TCanvas::Resizevirtual void Resize(Option_t *option="""")Recompute canvas parameters following a X11 Resize.Definition TCanvas.cxx:1668; TCanvas::GetHighLightColorColor_t GetHighLightColor() const overrideDefinition TCanvas.h:138; TCanvas::GetShowToolBarBool_t GetShowToolBar() constDefinition TCanvas.h:149; TCanvas::DrawEventStatusvoid DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject *selected)Report name and title of primitive below the cursor.Definition TCanvas.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8h_source.html:19205,simpl,simplification,19205,doc/master/TCanvas_8h_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8h_source.html,1,['simpl'],['simplification']
Usability,"edBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredBiasUpdatesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightUpdates ();  ; std::vector< Matrix_t > & GetPastSquaredWeightUpdatesAt (size_t i);  ; Scalar_t GetRho () const;  Getters. ;  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fEpsilon;  The Smoothing term used to avoid division by zero. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasGradients;  The accumulation of the square of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredBiasUpdates;  The accumulation of the square of the past bias updates associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastSquaredWeightGradients;  The accumulation of the square of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html:2391,learn,learningRate,2391,doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdadelta.html,1,['learn'],['learningRate']
Usability,"edCalculator::fPdf; Double_tRooStats::CombinedCalculator::fSizesize of the test (eg. specified rate of Type I error). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ProfileLikelihoodCalculator(); default constructor. ProfileLikelihoodCalculator(RooAbsData& data, RooAbsPdf& pdf, const RooArgSet& paramsOfInterest, Double_t size = 0.050000000000000003, const RooArgSet* nullParams = 0); constructor from pdf and parameters; the pdf must contain eventually the nuisance parameters. ProfileLikelihoodCalculator(RooAbsData& data, RooStats::ModelConfig& model, Double_t size = 0.050000000000000003); construct from a ModelConfig. Assume data model.GetPdf() will provide full description of model including; constraint term on the nuisances parameters. ~ProfileLikelihoodCalculator(); destructor; cannot delete prod pdf because it will delete all the composing pdf's; if (fOwnPdf) delete fPdf;; fPdf = 0;. void DoReset() const; reset and clear fit result; to be called when a new model or data are set in the calculator. RooAbsReal * DoGlobalFit() const; perform a global fit of the likelihood letting with all parameter of interest and; nuisance parameters; keep the list of fitted parameters. RooFitResult * DoMinimizeNLL(RooAbsReal* nll); Minimizer the given NLL using the default options. LikelihoodInterval* GetInterval() const; Main interface to get a RooStats::ConfInterval.; It constructs a profile likelihood ratio and uses that to construct a RooStats::LikelihoodInterval. HypoTestResult* GetHypoTest() const; Main interface to get a HypoTestResult.; It does two fits:; the first lets the null parameters float, so it's a maximum likelihood estimate; the second is to the null (fixing null parameters to their specified values): eg. a conditional maximum likelihood; the ratio of the likelihood at the conditional MLE to the MLE is the profile likelihood ratio.; Wilks' theorem is used to get p-values. ProfileLikelihoodCalculator(); default constructor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html:7606,clear,clear,7606,root/html602/RooStats__ProfileLikelihoodCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__ProfileLikelihoodCalculator.html,2,['clear'],['clear']
Usability,"edGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4716,clear,clearShapeDirty,4716,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,2,['clear'],['clearShapeDirty']
Usability,"edStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddOutput (TList *out) override;  Incorporate output list (may not be used in this class). ;  ; Int_t AddOutputObject (TObject *obj) override;  Incorporate output object (may not be used in this class). ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; Long64_t DrawSelect (TDSet *set, const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:2783,feedback,feedback,2783,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"ed_ptr will be removed.Definition RCanvas.cxx:225; ROOT::Experimental::RCanvas::ResolveSharedPtrsvoid ResolveSharedPtrs()To resolve problem with storing of shared pointers Call this method when reading canvas from the file...Definition RCanvas.cxx:299; ROOT::Experimental::RCanvas::Runvoid Run(double tm=0.)Run canvas functionality for given time (in seconds)Definition RCanvas.cxx:285; ROOT::Experimental::RCanvas::IncModifieduint64_t IncModified()Definition RCanvas.hxx:82; ROOT::Experimental::RCanvas::GetUIDstd::string GetUID() constReturn unique identifier for the canvas Used in iPython display.Definition RCanvas.cxx:199; ROOT::Experimental::RCanvas::CreateJSONstd::string CreateJSON()Provide JSON which can be used for offline display.Definition RCanvas.cxx:211; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RCanvas::ClearOnClosevoid ClearOnClose(const std::shared_ptr< void > &handle)Set handle which will be cleared when connection is closed.Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::Updatevoid Update(bool async=false, CanvasCallback_t callback=nullptr)update drawingDefinition RCanvas.cxx:78; ROOT::Experimental::RCanvas::Hidevoid Hide()Hide all canvas displays.Definition RCanvas.cxx:171; ROOT::Experimental::RChangeAttrRequest::Processstd::unique_ptr< RDrawableReply > Process() overrideApply attributes changes to the drawable Return mask with actions which were really applied.Definition RCanvas.cxx:327; TStringBasic string class.Definition TString.h:139; TString::Dataconst char * Data() constDefinition TString.h:376; TString::HashUInt_t Hash(ECaseCompare cmp=kExact) constReturn hash value.Definition TString.cxx:677; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; int; nconst Int_t nDefinition lege",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:15861,clear,cleared,15861,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['clear'],['cleared']
Usability,"eded in; 270// the dictionary.; 271#include ""TQClass.h""; 272#endif; 273 ; 274 ; 275//---- ClassImpQ macro ----------------------------------------------; 276//; 277// This macro used to correspond to the ClassImp macro and should be used; 278// for classes derived from TQObject instead of the ClassImp macro.; 279// This macro makes it possible to have a single connection from; 280// all objects of the same class.; 281// *** It is now obsolete ***; 282 ; 283#define ClassImpQ(name) \; 284 ClassImp(name); 285 ; 286#endif; R__EXTERN#define R__EXTERNDefinition DllImport.h:26; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; ClassDef#define ClassDef(name, id)Definition Rtypes.h:342; ClassDefOverride#define ClassDefOverride(name, id)Definition Rtypes.h:346; TList.h; TQClass.h; gTQSenderR__EXTERN void * gTQSenderDefinition TQObject.h:46; ConnectCINTBool_t ConnectCINT(TQObject *sender, const char *signal, const char *slot)Global function which simplifies making connection in interpreted ROOT session.Definition TQObject.cxx:1069; TString.h; TVirtualQConnection.h; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TCollection::IsEmptyvirtual Bool_t IsEmpty() constDefinition TCollection.h:188; TIterDefinition TCollection.h:235; TListA doubly linked list.Definition TList.h:38; TList::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this list using its name.Definition TList.cxx:576; TQObjSenderDefinition TQObject.h:233; TQObjSender::SetSendervirtual void SetSender(void *sender)Definition TQObject.h:250; TQObjSender::fSenderClassTString fSenderClassDefinition TQObject.h:237; TQObjSender::TQObjSenderTQObjSender(const TQObjSender &)=delete; TQObjSender::~TQObjSendervirtual ~TQObjSender()Definition TQObject.h:248; TQObjSender::operator=TQObjSender & operator=(const TQObjSender &)=delete; TQObjSender::SetSenderClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8h_source.html:10681,simpl,simplifies,10681,doc/master/TQObject_8h_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8h_source.html,1,['simpl'],['simplifies']
Usability,"edia; The class TGeoMedium describes tracking media properties. This has a pointer to a material and the additional data members representing the properties related to tracking.; TGeoMedium(const char *name,Int_t numed,TGeoMaterial *mat,; Double_t *params=0);; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23. name: name assigned to the medium; mat: pointer to a material; params: array of additional parameters. Another constructor allows effectively defining tracking parameters in GEANT3 style:; TGeoMedium(const char *name,Int_t numed,Int_t imat,Int_t ifield,; Double_t fieldm,Double_t tmaxfd,Double_t stemax,; Double_t deemax,Double_t epsil,Double_t stmin);; This constructor is reserved for creating tracking media from the VMC interface [...]:. numed: user-defined medium index; imat: unique ID of the material; others: see G3 documentation. Looking at our simple world example, one can see that for creating volumes one needs to create tracking media before. The way to proceed for those not interested in performing tracking with external MC's is to define and use only one dummy tracking medium as in the example (or a NULL pointer). User Interface for Handling Materials and Media; The TGeoManager class contains the API for accessing and handling defined materials:; TGeoManager::GetMaterial(name);; TGeoManager::GetMaterialTGeoMaterial * GetMaterial(const char *matname) constSearch for a named material. All trailing blanks stripped.Definition TGeoManager.cxx:3011; . Classes; class  TGeoElement;  Base class for chemical elements. More...;  ; class  TGeoMaterial;  Base class describing materials. More...;  ; class  TGeoMedium;  Media are used to store properties related to tracking and which are useful only when using geometry with a particle transport MC package (via VMC). More...;  ; class  TGeoMixture;  Mixtures of elements. More...;  . ROOT master - Reference Guide Generated on Tue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Materials__classes.html:12647,simpl,simple,12647,doc/master/group__Materials__classes.html,https://root.cern,https://root.cern/doc/master/group__Materials__classes.html,1,['simpl'],['simple']
Usability,"edirection) plugin for the new ROOT Browser; TGCompositeFrame Base class for composite widgets (menubars, etc.); TGContainer Canvas container; TGDMLParse imports GDML using DOM and binds it to ROOT; TGDMLRefl helper class used for the storage of reflected solids; TGDMLWrite imports GDML using DOM and binds it to ROOT; TGDNDManager The main Drag and Drop Manager; TGDimension Dimension object (width, height); TGDockButton Dock button; TGDockHideButton Hide dock button; TGDockableFrame Dockable widget; TGDoubleHSlider Horizontal double slider widget; TGDoubleSlider Double slider widget abstract base class; TGDoubleVSlider Vertical double slider widget; TGDragWindow Window used for dragging; TGEventHandler Abstract event handler; TGFSComboBox Combo box widget for file system path; TGFileBrowser File browser.; TGFileContainer Container containing file system objects; TGFileDialog File selection dialog; TGFileInfo ; TGFileItem Class representing file system object; TGFont GUI font description; TGFontDialog Font selection dialog; TGFontDialog::FontProp_t ; TGFontPool Font pool; TGFontTypeComboBox Font type combobox widget; TGFrame Base class for simple widgets (button, etc.); TGFrameElement Base class used in GUI containers; TGFrameElementPack Class used in TGPack.; TGGC Graphics context; TGGCPool Graphics context pool; TGGotoDialog Goto line dialog used by TGTextEdit widget; TGGroupFrame A composite frame with border and title; TGHButtonGroup A button group with one horizontal row; TGHProgressBar Horizontal progress bar widget; TGHScrollBar Horizontal scrollbar widget; TGHSlider Horizontal slider widget; TGHSplitter A horizontal frame splitter; TGHeaderFrame Header frame with buttons and splitters; TGHorizontal3DLine A horizontal 3D separator line; TGHorizontalFrame Composite frame with horizontal child layout; TGHorizontalLayout Horizontal layout manager; TGHotString Graphics string with hot character; TGHtml HTML widget; TGHtmlBrowser very simple html browser; TGIcon Ic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:76118,simpl,simple,76118,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,4,['simpl'],['simple']
Usability,"edo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of redo arguments. ; Definition at line 768 of file TQCommand.cxx. ◆ GetNUargs(). Int_t TQCommand::GetNUargs ; (; ); const. Returns a number of undo arguments. ; Definition at line 776 of file TQCommand.cxx. ◆ Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:36859,undo,undo,36859,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"edrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Protected Attributes inherited from TBrowserImp; TBrowser * fBrowser {nullptr};  TBrowser associated with this implementation. ;  ; Bool_t fShowCycles {kFALSE};  Show object cycle numbers in browser. ;  . Private Member Functions;  TRootBrowserLite (const TRootBrowserLite &)=delete;  ; void AddToHistory (TGListTreeItem *item);  helper method to track history ;  ; void BrowseTextFile (const char *file);  browse text file ;  ; void Chdir (TGListTreeItem *item);  Make object associated with item the current directory. ;  ; void ClearHistory ();  clear navigation history ;  ; void CreateBrowser (const char *name);  Create the actual browser. ;  ; void DeleteListTreeItem (TGListTreeItem *item);  delete list tree item, remove it from history ;  ; void DisplayDirectory ();  Display current directory in second label, fLbl2. ;  ; void DisplayTotal (Int_t total, Int_t selected);  Display in statusbar total number of objects and number of selected objects in IconBox. ;  ; void HideTextEdit ();  hide text edit ;  ; void HighlightListLevel ();  helper method to track history ;  ; Bool_t HistoryBackward ();  go to the past ;  ; Bool_t HistoryForward ();  go to the future ;  ; void IconBoxAction (TObject *obj);  Default action when double clicking on icon. ;  ; void ListTreeHighlight (TGListTreeItem *item);  Open tree item and list in iconbox its contents. ;  ; TRootBrowserLite & operator= (const TRootBrowserLite &)=delete;  ; void Search ();  starts serach dialog ;  ; void SetViewMode (Int_t new_mode, Bool_t force=kFALSE);  Set iconbox's view mode and update menu and too",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRootBrowserLite.html:35383,clear,clear,35383,doc/master/classTRootBrowserLite.html,https://root.cern,https://root.cern/doc/master/classTRootBrowserLite.html,1,['clear'],['clear']
Usability,"edvirtual . Set up feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite.; Definition at line 1642 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayer::StopFeedback ; (; ). virtual . Stop feedback (may not be used in this class). ; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, and TProofPlayerSlave.; Definition at line 1650 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayer::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop the process after this event. ; If timeout is positive, start a timer firing after timeout seconds to hard-stop time-expensive events. ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 287 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayer::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote, and TProofPlayerLite.; Definition at line 689 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayer::StoreOutput ; (; TList * ; out). overridevirtual . Store output list (may not be used in this class). ; Implements TVirtualProofPlayer.; Reimplemented in TProofPlayerRemote.; Definition at line 681 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TProofPlayerLocal, TProofPlayerRemote, TProofPlayerSlave, TProofPlayerSuperMaster, and TProofPlayerLite. ◆ StreamerNVirtual(). void TProofPlayer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 228 of file TProofPlayer.h. ◆ UpdateAutoBin(). void TProofPlayer::UpdateAutoBin ; (; const char * ; name, . Double_t & ; xmin, . Double_t & ; xmax, . Double_t & ; y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:42975,feedback,feedback,42975,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"ee(); destructor. void SetParentTreeInNodes(TMVA::Node* n = NULL); descend a tree to find all its leaf nodes, fill max depth reached in the; tree at the same time. TMVA::DecisionTree* CreateFromXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); re-create a new tree (decision tree or search tree) from XML. UInt_t BuildTree(const TMVA::DecisionTree::EventConstList& eventSample, TMVA::DecisionTreeNode* node = NULL); building the decision tree by recursively calling the splitting of; one (root-) node into two daughter nodes (returns the number of nodes). void FillTree(const TMVA::DecisionTree::EventList& eventSample); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void FillEvent(const TMVA::Event& event, TMVA::DecisionTreeNode* node); fill the existing the decision tree structure by filling event; in from the top node and see where they happen to end up. void ClearTree(); clear the tree nodes (their S/N, Nevents etc), just keep the structure of the tree. UInt_t CleanTree(TMVA::DecisionTreeNode* node = NULL); remove those last splits that result in two leaf nodes that; are both of the type (i.e. both signal or both background); this of course is only a reasonable thing to do when you use; ""YesOrNo"" leafs, while it might loose s.th. if you use the; purity information in the nodes.; --> hence I don't call it automatically in the tree building. Double_t PruneTree(const TMVA::DecisionTree::EventConstList* validationSample = NULL); prune (get rid of internal nodes) the Decision tree to avoid overtraining; serveral different pruning methods can be applied as selected by the; variable ""fPruneMethod"". void ApplyValidationSample(const TMVA::DecisionTree::EventConstList* validationSample) const; run the validation sample through the (pruned) tree and fill in the nodes; the variables NSValidation and NBValidadtion (i.e. how many of the Signal; and Background events from the validation sample. Thi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__DecisionTree.html:10455,clear,clear,10455,root/html534/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html534/TMVA__DecisionTree.html,1,['clear'],['clear']
Usability,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();. Weights histograms. Weights histograms (for a motivation see the above publication) can be specified; for the individual MC sources through; fit->SetWeight(parameter #, pointer to weights histogram);; and unset by specifying a null pointer. Obtaining fit results. The fit is car",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFractionFitter.html:3163,simpl,simplify,3163,root/html528/TFractionFitter.html,https://root.cern,https://root.cern/root/html528/TFractionFitter.html,1,['simpl'],['simplify']
Usability,"eed to be made for the fit procedure to be carried out:. (1) The total number of events in each template is not too small; (so that its Poisson uncertainty can be neglected).; (2) The number of events in each bin is much smaller than the total; number of events in each template (so that multinomial; uncertainties can be replaced with Poisson uncertainties). Biased fit uncertainties may result if these conditions are not fulfilled; (see e.g. arXiv:0803.2711). Instantiation. A fit object is instantiated through; TFractionFitter* fit = new TFractionFitter(data, mc);; A number of basic checks (intended to ensure that the template histograms; represent the same ""kind"" of distribution as the data one) are carried out.; The TVirtualFitter object is then addressed and all fit parameters (the; template fractions) declared (initially unbounded). Applying constraints. Fit parameters can be constrained through; fit->Constrain(parameter #, lower bound, upper bound);; Setting lower bound = upper bound = 0 removes the constraint (a la Minuit);; however, a function; fit->Unconstrain(parameter #); is also provided to simplify this. Setting parameter values. The function; TVirtualFitter* vFit = fit->GetFitter();; is provided for direct access to the TVirtualFitter object. This allows to; set and fix parameter values, and set step sizes directly. Restricting the fit range. The fit range can be restricted through; fit->SetRangeX(first bin #, last bin #);; and freed using; fit->ReleaseRangeX();; For 2D histograms the Y range can be similarly restricted using; fit->SetRangeY(first bin #, last bin #);; fit->ReleaseRangeY();; and for 3D histograms also; fit->SetRangeZ(first bin #, last bin #);; fit->ReleaseRangeZ();; It is also possible to exclude individual bins from the fit through; fit->ExcludeBin(bin #);; where the given bin number is assumed to follow the TH1::GetBin() numbering.; Any bins excluded in this way can be included again using the corresponding; fit->IncludeBin(bin #);. Weig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFractionFitter.html:3163,simpl,simplify,3163,root/html530/TFractionFitter.html,https://root.cern,https://root.cern/root/html530/TFractionFitter.html,5,['simpl'],['simplify']
Usability,"eed; 2446 BookMethod(subseedloader, theMethod, methodTitle, theOption);; 2447 ; 2448 // Train/Test/Evaluation; 2449 TrainAllMethods();; 2450 TestAllMethods();; 2451 EvaluateAllMethods();; 2452 ; 2453 // getting ROC; 2454 SSROC = GetROCIntegral(ybitset.to_string(), methodTitle);; 2455 importances[ny] += SROC - SSROC;; 2456 ; 2457 // cleaning information; 2458 TMVA::MethodBase *ssmethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[ybitset.to_string().c_str()][0][0]);; 2459 TMVA::ResultsClassification *ssresults = (TMVA::ResultsClassification *)ssmethod->Data()->GetResults(; 2460 ssmethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2461 delete ssresults;; 2462 delete subseedloader;; 2463 this->DeleteAllMethods();; 2464 fMethodsMap.clear();; 2465 }; 2466 }; 2467 std::cout << ""--- Variable Importance Results (Short)"" << std::endl;; 2468 return GetImportance(nbits, importances, varNames);; 2469}; 2470 ; 2471////////////////////////////////////////////////////////////////////////////////; 2472 ; 2473TH1F *TMVA::Factory::EvaluateImportanceRandom(DataLoader *loader, UInt_t nseeds, Types::EMVA theMethod,; 2474 TString methodTitle, const char *theOption); 2475{; 2476 TRandom3 *rangen = new TRandom3(0); // Random Gen.; 2477 ; 2478 uint64_t x = 0;; 2479 uint64_t y = 0;; 2480 ; 2481 // getting number of variables and variable names from loader; 2482 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2483 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2484 ; 2485 long int range = pow(2, nbits);; 2486 ; 2487 // vector to save importances; 2488 std::vector<Double_t> importances(nbits);; 2489 for (int i = 0; i < nbits; i++); 2490 importances[i] = 0;; 2491 ; 2492 Double_t SROC, SSROC; // computed ROC value; 2493 for (UInt_t n = 0; n < nseeds; n++) {; 2494 x = rangen->Integer(range);; 2495 ; 2496 std::bitset<32> xbitset(x);; 2497 if (x == 0); 2498 continue; // data loader need at least one variable; 2499 ; 2500 // creating lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:102483,clear,clear,102483,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"een. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: Visible daughters. By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume.; 18.7.3 Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad. myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; 18.7.3.1 Clipping Ra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1011178,simpl,simple,1011178,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"eenDefinition Rtypes.h:66; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; qfloat * qDefinition THbookFile.cxx:89; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAnglevirtual void SetTextAngle(Float_t tangle=0)Set the text angle.Definition TAttText.h:43; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TF11-Dim function classDefinition TF1.h:233; TH1I1-D histogram with an int per channel (see TH1 documentation)Definition TH1.h:540; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH2I2-D histogram with an int per channel (see TH1 documentation)Definition TH2.h:225; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TTextBase class for several text objects.Definition TText.h:22; TText::DrawTextvirtual TText * DrawText(Double_t x, Double_t y, const char *text)Draw this text with new coordinates.Definition TText.cxx:176; . The candle reduces the information coming from a whole distribution into few values. Independently from the number of entries or the significance of the underlying distribution a candle will always look like a candle. So candle plots should be used carefully in particular with unknown distributions. The definition of a candle is based on unbinned data. Here, candles are created from binned data. Because of this, the deviation is connected to the bin width used. The calculation of the quantiles normally done on unbinned data ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:56021,simpl,simple,56021,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"efault Constructor. ; Definition at line 313 of file TTreeCache.cxx. ◆ TTreeCache() [3/3]. TTreeCache::TTreeCache ; (; TTree * ; tree, . Int_t ; buffersize = 0 . ). Constructor. ; Definition at line 320 of file TTreeCache.cxx. ◆ ~TTreeCache(). TTreeCache::~TTreeCache ; (; ). override . Destructor. (in general called by the TFile destructor) ; Definition at line 332 of file TTreeCache.cxx. Member Function Documentation. ◆ AddBranch() [1/2]. Int_t TTreeCache::AddBranch ; (; const char * ; bname, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ; It works in exactly the same way as TTree::SetBranchStatus so you probably want to look over there for details about the use of bname with regular expressions. The branches are taken with respect to the Owner of this TTreeCache (i.e. the original Tree) NB: if bname=""*"" all branches are put in the cache and the learning phase stopped Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 446 of file TTreeCache.cxx. ◆ AddBranch() [2/2]. Int_t TTreeCache::AddBranch ; (; TBranch * ; b, . bool ; subbranches = false . ). overridevirtual . Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ; The branch is added even if we are outside of the training phase. Returns:; 0 branch added or already included; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 376 of file TTreeCache.cxx. ◆ CalculateMissCache(). bool TTreeCache::CalculateMissCache ; (; ). private . Calculate the appropriate miss cache to fetch; helper function for FillMissCache. . ◆ CalculateMissEntries(). TBranch * TTreeCache::CalculateMissEntries ; (; Long64_t ; pos, . int ; len, . bool ; all . ). private . Given an file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:35142,learn,learning,35142,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"eference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Classes |; Public Member Functions |; Static Public Attributes |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RNTupleDescriptor Class ReferenceNTuple-related classes. ; The on-storage meta-data of an ntuple. ; Represents the on-disk (on storage) information about an ntuple. The meta-data consists of a header and one or several footers. The header carries the ntuple schema, i.e. the fields and the associated columns and their relationships. The footer(s) carry information about one or several clusters. For every cluster, a footer stores its location and size, and for every column the range of element indexes as well as a list of pages and page locations.; The descriptor provide machine-independent (de-)serialization of headers and footers, and it provides lookup routines for ntuple objects (pages, clusters, ...). It is supposed to be usable by all RPageStorage implementations.; The serialization does not use standard ROOT streamers in order to not let it depend on libCore. The serialization uses the concept of frames: header, footer, and substructures have a preamble with version numbers and the size of the writte struct. This allows for forward and backward compatibility when the meta-data evolves. ; Definition at line 528 of file RNTupleDescriptor.hxx. Classes; class  RClusterDescriptorIterable;  Used to loop over all the clusters of an ntuple (in unspecified order) More...;  ; class  RClusterGroupDescriptorIterable;  Used to loop over all the cluster groups of an ntuple (in unspecified order) More...;  ; class  RColumnDescriptorIterable;  Used to loop over a field's associated columns. More...;  ; struct  RCreateModelOptions;  Modifiers passed to CreateModel More...;  ; class  RExtraTypeInfoDescriptorIterable;  Used to loop over all the extra type info record of an ntuple (in unspecified order) More...;  ; class  RFieldDes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html:1043,usab,usable,1043,doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,1,['usab'],['usable']
Usability,"efine first somewhere, as a code comment or in a separate page a ; group using the \defgroup tag. ; Example; /**; \defgroup Hist Histogram Library;  ; The Histogram library is documented in the class TH1.;  ; */; Then one needs to add in the class description comments the \ingroup tag. For example in the class TH1, which is part of the Hist group one should add; /**; \class TH1; \ingroup Hist ; ....; */; Include additional documentation pages in HTML or Markdown format; One can add extra pages for the documentation in HTML or Markdown format (preferable) in the package/doc directory (e.g. hist/doc). These page could be used to; provide a general documentation of the package. The pages should be included in a file with name as the package name and the .md or .html suffix (e.g. hist.md).; The file should contain, in addition to the package description, the Doxygen command \page [name] [title] which defines the internal page name (used to reference that page) and ; the page title.; For example; /**;  ; \page HistPage The Histogram Library;  ; This page provides a description of the Histogram library. ;  ; */; Inside page you can reference to groups or other pages using the Doxygen commands \subpage [refname] [""text""] and \ref [refname] [""text""]. ; See as example the existing math/doc/Math.md file. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/formatting-comments-doxygen.html:11302,guid,guidelines,11302,d/formatting-comments-doxygen.html,https://root.cern,https://root.cern/d/formatting-comments-doxygen.html,1,['guid'],['guidelines']
Usability,"efinition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:94106,usab,usable,94106,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['usab'],['usable']
Usability,"efinition at line 492 of file TClass.h. ◆ GetTypeInfo(). const std::type_info * TClass::GetTypeInfo ; (; ); const. inline . Definition at line 496 of file TClass.h. ◆ HasConsistentHashMember(). Bool_t TClass::HasConsistentHashMember ; (; ). inline . Return 'true' if we can guarantee that if this class (or any class in this class inheritance hierarchy) overload TObject::Hash it also starts the RecursiveRemove process from its own destructor. ; Definition at line 501 of file TClass.h. ◆ HasCustomStreamerMember(). Bool_t TClass::HasCustomStreamerMember ; (; ); const. inline . The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ; Definition at line 508 of file TClass.h. ◆ HasDataMemberInfo(). Bool_t TClass::HasDataMemberInfo ; (; ); const. inline . Definition at line 407 of file TClass.h. ◆ HasDefaultConstructor(). Bool_t TClass::HasDefaultConstructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:94107,usab,usable,94107,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['usab'],['usable']
Usability,"eft); TGenCollectionProxy*TGenCollectionProxy::Initialize() const; virtual TGenCollectionProxy*TEmulatedCollectionProxy::InitializeEx(); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(int nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(int nElements, TBuffer& b). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodTGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of the key_type; stringTGenCollectionProxy::fNameName of the class being proxied.; TGenCollectionProxy::MethodTGenCollectionProxy::fNextCont",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEmulatedMapProxy.html:4544,clear,clear,4544,root/html528/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html528/TEmulatedMapProxy.html,2,['clear'],['clear']
Usability,"egration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 77 of file RooExponential.cxx. ◆ IsA(). TClass * RooExponential::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 55 of file RooExponential.h. ◆ negateCoefficient(). bool RooExponential::negateCoefficient ; (; ); const. inline . Definition at line 39 of file RooExponential.h. ◆ Streamer(). void RooExponential::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooExponential::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 55 of file RooExponential.h. ◆ translate(). void RooExponential::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 116 of file RooExponential.cxx. ◆ variable(). RooAbsReal const & RooExponential::variable ; (; ); const. inline . Get the x variable. ; Definition at line 34 of file RooExponential.h. Member Data Documentation. ◆ _negateCoefficient. bool RooExponential::_negateCoefficient = false. protected . Definition at line 48 of file RooExponential.h. ◆ c. RooRealProxy RooExponential::c. protected . Definition at line 47 of file RooExpone",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExponential.html:78567,simpl,simple,78567,doc/master/classRooExponential.html,https://root.cern,https://root.cern/doc/master/classRooExponential.html,1,['simpl'],['simple']
Usability,"egularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:6065,clear,clear,6065,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['clear'],['clear']
Usability,"eight = 1.0 . ). private . update the network based on how closely the output matched the desired output ; Definition at line 1302 of file MethodMLP.cxx. ◆ UpdateNetwork() [2/2]. void TMVA::MethodMLP::UpdateNetwork ; (; Double_t ; desired, . Double_t ; eventWeight = 1.0 . ). private . update the network based on how closely the output matched the desired output ; Definition at line 1286 of file MethodMLP.cxx. ◆ UpdatePriors(). void TMVA::MethodMLP::UpdatePriors ; (; ). private . zjh ; Definition at line 1454 of file MethodMLP.cxx. ◆ UpdateRegulators(). void TMVA::MethodMLP::UpdateRegulators ; (; ). private . zjh ; Definition at line 1468 of file MethodMLP.cxx. ◆ UpdateSynapses(). void TMVA::MethodMLP::UpdateSynapses ; (; ). private . update synapse error fields and adjust the weights (if in sequential mode) ; Definition at line 1412 of file MethodMLP.cxx. Member Data Documentation. ◆ fBatchSize. Int_t TMVA::MethodMLP::fBatchSize. private . batch size, only matters if in batch learning mode ; Definition at line 192 of file MethodMLP.h. ◆ fBPMode. EBPTrainingMode TMVA::MethodMLP::fBPMode. private . backprop learning mode (sequential or batch) ; Definition at line 190 of file MethodMLP.h. ◆ fBpModeS. TString TMVA::MethodMLP::fBpModeS. private . backprop learning mode option string (sequential or batch) ; Definition at line 191 of file MethodMLP.h. ◆ fCalculateErrors. bool TMVA::MethodMLP::fCalculateErrors. private . compute inverse hessian matrix at the end of the training ; Definition at line 165 of file MethodMLP.h. ◆ fDecayRate. Double_t TMVA::MethodMLP::fDecayRate. private . decay rate for above learning rate ; Definition at line 189 of file MethodMLP.h. ◆ fDeviationsFromTargets. std::vector<std::pair<Float_t,Float_t> >* TMVA::MethodMLP::fDeviationsFromTargets. private . deviation from the targets, event weight ; Definition at line 204 of file MethodMLP.h. ◆ fEpochMon. Bool_t TMVA::MethodMLP::fEpochMon. private . create and fill epoch-wise monitoring histograms (mak",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:49829,learn,learning,49829,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"eight; 114 int GetHeight() const { return fHeight; }; 115 ; 116 /// Display the canvas.; 117 void Show(const std::string &where = """");; 118 ; 119 /// returns true if Show() method was called; 120 bool IsShown() const { return fShown; }; 121 ; 122 /// clear IsShown() flag; 123 void ClearShown() { fShown = false; }; 124 ; 125 /// Returns window name used to display canvas; 126 std::string GetWindowAddr() const;; 127 ; 128 /// Returns window URL which can be used for connection; 129 std::string GetWindowUrl(bool remote);; 130 ; 131 /// Hide all canvas displays; 132 void Hide();; 133 ; 134 /// Remove canvas from global canvas lists, will be destroyed when shared_ptr will be removed; 135 void Remove();; 136 ; 137 /// Insert panel into the canvas, canvas should be shown at this moment; 138 template <class PANEL>; 139 bool AddPanel(std::shared_ptr<PANEL> &panel); 140 {; 141 if (!fPainter) return false;; 142 return fPainter->AddPanel(panel->GetWindow());; 143 }; 144 ; 145 /// Get modify counter; 146 uint64_t GetModified() const { return fModified; }; 147 ; 148 // Set newest version to all primitives; 149 void Modified() { SetDrawableVersion(IncModified()); }; 150 ; 151 /// Set newest version to specified drawable; 152 void Modified(std::shared_ptr<RDrawable> drawable); 153 {; 154 // TODO: may be check that drawable belong to the canvas; 155 if (drawable); 156 drawable->SetDrawableVersion(IncModified());; 157 }; 158 ; 159 // Return if canvas was modified and not yet updated; 160 bool IsModified() const;; 161 ; 162 /// update drawing; 163 void Update(bool async = false, CanvasCallback_t callback = nullptr);; 164 ; 165 /// returns true if Update() method was called; 166 bool IsUpdated() const { return fUpdated; }; 167 ; 168 /// clear IsUpdated() flag; 169 void ClearUpdated() { fUpdated = false; }; 170 ; 171 /// Run canvas functionality for given time (in seconds); 172 void Run(double tm = 0.);; 173 ; 174 /// Save canvas in image file; 175 bool SaveAs(const std::string &filenam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:4221,clear,clear,4221,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,2,['clear'],['clear']
Usability,"eightDecay = 1e-5, . TMVA::DNN::EnumRegularization ; _regularization = TMVA::DNN::EnumRegularization::NONE, . MinimizerType ; _eMinimizerType = MinimizerType::fSteepest, . double ; _learningRate = 1e-5, . double ; _momentum = 0.3, . int ; _repetitions = 3, . bool ; _multithreading = true . ). c'tor ; Definition at line 232 of file NeuralNet.cxx. ◆ ~Settings(). TMVA::DNN::Settings::~Settings ; (; ). virtual . d'tor ; Definition at line 261 of file NeuralNet.cxx. Member Function Documentation. ◆ addPoint() [1/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x . ). inline . for monitoring ; Definition at line 821 of file NeuralNet.h. ◆ addPoint() [2/2]. void TMVA::DNN::Settings::addPoint ; (; std::string ; histoName, . double ; x, . double ; y . ). inline . for monitoring ; Definition at line 822 of file NeuralNet.h. ◆ batchSize(). size_t TMVA::DNN::Settings::batchSize ; (; ); const. inline . mini-batch size ; Definition at line 767 of file NeuralNet.h. ◆ clear(). void TMVA::DNN::Settings::clear ; (; std::string ; histoName). inline . for monitoring ; Definition at line 824 of file NeuralNet.h. ◆ computeResult(). virtual void TMVA::DNN::Settings::computeResult ; (; const Net & ; , . std::vector< double > & ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 809 of file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:6030,clear,clear,6030,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['clear'],['clear']
Usability,"el () const override;  ; Int_t GetVisOption () const override;  ; const char * GetVolumeInfo (const TGeoVolume *volume, Int_t px, Int_t py) const override;  Get some info about the current selected volume. ;  ; void GrabFocus (Int_t nfr=0, Double_t dlong=0, Double_t dlat=0, Double_t dpsi=0) override;  Move focus to current volume. ;  ; Bool_t IsExplodedView () const override;  ; Bool_t IsPaintingShape () const override;  ; Bool_t IsRaytracing () const override;  ; TH2F * LegoPlot (Int_t ntheta=60, Double_t themin=0., Double_t themax=180., Int_t nphi=90, Double_t phimin=0., Double_t phimax=360., Double_t rmin=0., Double_t rmax=9999999, Option_t *option="""") override;  Generate a lego plot fot the top volume, according to option. ;  ; void Lock (Bool_t flag=kTRUE);  ; void ModifiedPad (Bool_t update=kFALSE) const override;  Check if a pad and view are present and send signal ""Modified"" to pad. ;  ; void OpProgress (const char *opname, Long64_t current, Long64_t size, TStopwatch *watch=nullptr, Bool_t last=kFALSE, Bool_t refresh=kFALSE, const char *msg="""") override;  Text progress bar. ;  ; void Paint (Option_t *option="""") override;  Paint current geometry according to option. ;  ; void PaintNode (TGeoNode *node, Option_t *option="""", TGeoMatrix *global=nullptr) override;  Paint recursively a node and its content according to visualization options. ;  ; void PaintOverlap (void *ovlp, Option_t *option="""") override;  Paint an overlap. ;  ; void PaintPhysicalNode (TGeoPhysicalNode *node, Option_t *option="""");  Paints a physical node associated with a path. ;  ; Bool_t PaintShape (const TGeoShape &shape, Option_t *option) const;  Paint the supplied shape into the current 3D viewer. ;  ; void PaintShape (TGeoShape *shape, Option_t *option="""") override;  Paint an overlap. ;  ; void PaintVolume (TGeoVolume *vol, Option_t *option="""", TGeoMatrix *global=nullptr) override;  Paint recursively a node and its content according to visualization options. ;  ; void PrintOverlaps () const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoPainter.html:6276,progress bar,progress bar,6276,doc/master/classTGeoPainter.html,https://root.cern,https://root.cern/doc/master/classTGeoPainter.html,1,['progress bar'],['progress bar']
Usability,"el branch is created for each element of the TObjArray.; If splitlevel = 2, one top level branch is created for each array element. If one of the array elements is a TCollection, one top level branch will be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor for TClonesArray is called. The collection itself cannot be a TClonesArray. If name is given, all branch names will be prefixed with name_.; IMPORTANT NOTE1: This function should not be called if splitlevel<1. IMPORTANT NOTE2: The branches created by this function will have names corresponding to the collection or object names. It is important to give names to collections to avoid misleading branch names or identical branch names. By default collections have a name equal to the corresponding class name, e.g. the default name of TList is “TList”.; 12.13 Examples for Writing and Reading Trees; The following sections are examples of writing and reading trees increasing in complexity from a simple tree with a few variables to a tree containing folders and complex Event objects. Each example has a named script in the $ROOTSYS/tutorials/tree directory. They are called tree1.C to tree4.C. The examples are:. tree1.C: a tree with several simple (integers and floating point) variables.; tree2.C: a tree built from a C structure (struct). This example uses the Geant3 C wrapper as an example of a FORTRAN common block ported to C with a C structure.; tree3.C: in this example, we will show how to extend a tree with a branch from another tree with the Friends feature. These trees have branches with variable length arrays. Each entry has a variable number of tracks, and each track has several variables.; tree4.C: a tree with a class (Event). The class Event is defined in $ROOTSYS/test. In this example we first encounter the impact of splitting a branch. Each script contains the main function, with the same name as the file (i.e. tree1), the function to write ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:550858,simpl,simple,550858,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"el*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query status. void UpdateInfos(); Update que",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionQueryFrame.html:21102,feedback,feedback,21102,root/html528/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html528/TSessionQueryFrame.html,2,['feedback'],['feedback']
Usability,"el*fLabInfosinfos on current process; TGLabel*fLabStatusactual process status; Bool_tfModifiedkTRUE if settings have changed; Long64_tfPrevProcessedused for progress bar; Long64_tfPrevTotalused for progress bar; TGLabel*fRaterate of process in events/sec; TCanvas*fStatsCanvasnode statistics canvas; TSessionQueryFrame::EQueryStatusfStatusstatus of actual query; TGTab*fTabmain tab frame; TGLabel*fTotaltotal progress info; TSessionViewer*fViewerpointer on main viewer; TGHProgressBar*frmProgcurrent process progress bar. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionQueryFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionQueryFrame(); Destructor. void Build(TSessionViewer* gui); Build query informations frame. void Modified(Bool_t mod = kTRUE); Notify changes in query editor settings. void Feedback(TList* objs); Feedback function connected to Feedback signal.; Used to update feedback histograms. void UpdateHistos(TList* objs); Update feedback histograms. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); New version of Progress (just forward to the old version; for the time being). void ProgressLocal(Long64_t total, Long64_t processed); Update progress bar and status labels. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void ResetProgressDialog(const char* selec, Int_t files, Long64_t first, Long64_t entries); Reset progress frame information fields. void OnBtnFinalize(); Finalize query. void OnBtnStop(); Stop processing query. void OnBtnShowLog(); Show query log. void OnBtnRetrieve(); Retrieve query. void OnBtnAbort(); Abort processing query. void OnBtnSubmit(); Submit query. void UpdateButtons(TQueryDescription* desc); Update buttons state for the current query ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionQueryFrame.html:21377,feedback,feedback,21377,root/html532/TSessionQueryFrame.html,https://root.cern,https://root.cern/root/html532/TSessionQueryFrame.html,1,['feedback'],['feedback']
Usability,"el, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_t_debug; TFile*_refFile; list<std::pair<RooPlot*,std::string> >_regPlots; list<std::pair<RooFitResult*,std::string> >_regResults; list<std::pair<TH1*,std::string> >_regTH; list<std::pair<RooTable*,std::string> >_regTables; list<std::pair<Double_t,std::string> >_regValues; list<std::pair<RooWorkspace*,std::string> >_regWS; Int_t_verb; Bool_t_write; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static TDirectory*gMemDir. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooUnitTest(). void regPlot(RooPlot* frame, const char* refName). void regResult(RooFitResult* r, const char* refName). void regValue(Double_t value, const char* refName). void regTable(RooTable* t, const char* refName). void regWS(RooWorkspace* ws, const char* refName). void regTH(TH1* h, const char* refName). RooWorkspace* getWS(const char* refName). Bool_t areTHidentical(TH1* htest, TH1* href). Bool_t runCompTests(). void setSilentMode(). void clearSilentMode(). Bool_t runTest(). void setMemDir(TDirectory* memDir); Set gMemDir to memDir. void setDebug(Bool_t flag); { _debug = flag ; }. Bool_t isTestAvailable(); { return kTRUE ; }. Bool_t testCode(). Double_t htol(); { return 5e-4 ; }. Double_t ctol(); { return 2e-3 ; }. Double_t fptol(); { return 1e-3 ; }. Double_t fctol(); { return 1e-3 ; }. Double_t vtol(); { return 1e-3 ; }. » Last changed: Tue Mar 10 17:21:08 2015 » Last generated: 2015-03-10 17:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooUnitTest.html:7683,clear,clearSilentMode,7683,root/html534/RooUnitTest.html,https://root.cern,https://root.cern/root/html534/RooUnitTest.html,1,['clear'],['clearSilentMode']
Usability,"el; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGTextButton*fCancelcancel button; TGLabel*fLabeltext entry label; TGTextButton*fOkok button; char*fRetStraddress to store return string; TGTextEntry*fTEtext entry widget. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGInputDialog(const TGWindow* p = 0, const TGWindow* main = 0, const char* prompt = 0, const char* defval = 0, char* retstr = 0, UInt_t options = kVerticalFrame); Create simple input dialog. It is important to know that the case where the constructor in; which all the variables are initialized to their default values is; only used for the TBrowser to inspect on the classes. For normal; use the only variable that should be free is options. Variables prompt, defval are the content of the input dialog while; retstr has to be initialized to a char[256]. In case these are not; initialized, they will show default values while retstr will be; automatically allocated by the dialog. However this will make; impossible to retrieve the value entered by the dialog. To see TGInputDialog in use see:; $ROOTSYS/tutorials/testInputDialog.cxx. ~TGInputDialog(); Cleanup dialog. Bool_t ProcessMessage(Long_t msg, Long_t parm1, Long_t ); Handle button and text enter events. TGInputDialog(const TGInputDialog& ). TGInputDialog & operator=(const TGInputDialog& ). » Author: David Gonzalez Mali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGInputDialog.html:22100,simpl,simple,22100,root/html528/TGInputDialog.html,https://root.cern,https://root.cern/root/html528/TGInputDialog.html,4,['simpl'],['simple']
Usability,"elSize(h->GetZaxis()->GetLabelSize());; 4520 palette->SetTitleOffset(h->GetZaxis()->GetTitleOffset());; 4521 palette->SetTitleSize(h->GetZaxis()->GetTitleSize());; 4522 palette->SetNdivisions(h->GetZaxis()->GetNdivisions());; 4523 palette->SetTitle(h->GetZaxis()->GetTitle());; 4524 palette->SetTitleColor(h->GetZaxis()->GetTitleColor());; 4525 palette->SetTitleFont(h->GetZaxis()->GetTitleFont());; 4526 ; 4527 functions->AddFirst(palette);; 4528 }; 4529 if (palette) palette->Paint();; 4530 }; 4531 ; 4532 // Draw markers; 4533 auto nbcol = gStyle->GetNumberOfColors();; 4534 int logx = gPad->GetLogx();; 4535 int logy = gPad->GetLogy();; 4536 int logz = gPad->GetLogz();; 4537 if (theColor && logz) {; 4538 if (minc>0) minc = log10(minc);; 4539 if (maxc>0) maxc = log10(maxc);; 4540 }; 4541 theScatter->SetMarkerColor(theScatter->GetMarkerColor());; 4542 theScatter->TAttMarker::Modify();; 4543 double x,y,c,ms;; 4544 int nc;; 4545 for (int i=0; i<n; i++) {; 4546 if (theColor) {; 4547 if (logz) {; 4548 if (theColor[i]>0) c = log10(theColor[i]);; 4549 else continue;; 4550 } else {; 4551 c = theColor[i];; 4552 }; 4553 if (c<minc) continue;; 4554 if (c>maxc) continue;; 4555 nc = TMath::Nint(((c-minc)/(maxc-minc))*(nbcol-1));; 4556 if (nc > nbcol-1) nc = nbcol-1;; 4557 theScatter->SetMarkerColor(gStyle->GetColorPalette(nc));; 4558 }; 4559 if (theSize) {; 4560 ms = (MaxMarkerSize-MinMarkerSize)*((theSize[i]-mins)/(maxs-mins))+MinMarkerSize;; 4561 theScatter->SetMarkerSize(ms);; 4562 }; 4563 if (theColor || theSize) theScatter->TAttMarker::Modify();; 4564 if (logx) {; 4565 if (theX[i]>0) x = log10(theX[i]);; 4566 else break;; 4567 } else {; 4568 x = theX[i];; 4569 }; 4570 if (logy) {; 4571 if (theY[i]>0) y = log10(theY[i]);; 4572 else break;; 4573 } else {; 4574 y = theY[i];; 4575 }; 4576 gPad->PaintPolyMarker(1,&x,&y);; 4577 }; 4578}; 4579 ; 4580 ; 4581////////////////////////////////////////////////////////////////////////////////; 4582/// Paint a simple graph, without errors bars.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:161199,simpl,simple,161199,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simple']
Usability,"eld() when recreating a field / model from the stored descriptor. ; Definition at line 179 of file RFieldBase.hxx. ◆ fOnDiskTypeChecksum. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeChecksum = 0. protected . TClass checksum cached from the descriptor after a call to ConnectPageSource(). ; Only set for classes with dictionaries. ; Definition at line 246 of file RFieldBase.hxx. ◆ fOnDiskTypeVersion. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeVersion = kInvalidTypeVersion. protected . C++ type version cached from the descriptor after a call to ConnectPageSource() ; Definition at line 243 of file RFieldBase.hxx. ◆ fParent. RFieldBase* ROOT::Experimental::RFieldBase::fParent. protected . Sub fields point to their mother field. ; Definition at line 222 of file RFieldBase.hxx. ◆ fPrincipalColumn. Internal::RColumn* ROOT::Experimental::RFieldBase::fPrincipalColumn = nullptr. protected . All fields that have columns have a distinct main column. ; E.g., for simple fields (float, int, ...), the principal column corresponds to the field type. For collection fields except fixed-sized arrays, the main column is the offset field. Class fields have no column of their own. When reading, points to any column of the column team of the active representation. Usually, this is just the first column. When writing, points to the first column index of the currently active (not suppressed) column representation. ; Definition at line 229 of file RFieldBase.hxx. ◆ fReadCallbacks. std::vector<ReadCallback_t> ROOT::Experimental::RFieldBase::fReadCallbacks. protected . List of functions to be called after reading a value. ; Definition at line 241 of file RFieldBase.hxx. ◆ fState. EState ROOT::Experimental::RFieldBase::fState = EState::kUnconnected. private . Changed by ConnectTo[Sink,Source], reset by Clone() ; Definition at line 183 of file RFieldBase.hxx. ◆ fStructure. ENTupleStructure ROOT::Experimental::RFieldBase::fStructure. private . The role of this field in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:56277,simpl,simple,56277,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['simpl'],['simple']
Usability,"elegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y). void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawText(Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPadPainter.html:5900,simpl,simple,5900,root/html602/TPadPainter.html,https://root.cern,https://root.cern/root/html602/TPadPainter.html,1,['simpl'],['simple']
Usability,"elegate to gVirtualX. Float_t GetTextMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint Polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TPadPainter.html:5900,simpl,simple,5900,root/html604/TPadPainter.html,https://root.cern,https://root.cern/root/html604/TPadPainter.html,1,['simpl'],['simple']
Usability,"element of type STL container; TStreamerSTLstring Streamer element of type C++ string; TStreamerString Streamer element of type TString; TString Basic string class; TStringLong Long string class (more than 255 chars); TStringToken String tokenizer using PCRE for finding next tokens.; TStructNode Node with information about class; TStructNodeEditor GUI fo editing TStructNode; TStructNodeProperty Class with nodes color property; TStructViewer A 3D struct viewer; TStructViewerGUI A GUI fo 3D struct viewer ; TStyle A collection of all graphics attributes; TStyleDialog Dialog box used by the TStyleManager class; TStyleManager Graphical User Interface for managing styles; TStylePreview Preview window used by the TStyleManager class; TSubString ; TSynapse simple weighted bidirectionnal connection between 2 neurons; TSysEvtHandler ABC for handling system events; TSystem ABC defining a generic interface to the OS; TSystemDirectory A system directory; TSystemFile A system file; TTF Interface to TTF font handling; TTRAP TRAP shape; TTRD1 TRD1 shape; TTRD2 TRD2 shape; TTUBE TUBE shape; TTUBS TUBS shape; TTVLVContainer A dragging-capable LVContainer; TTVLVEntry Item that goes into the tree list view widget; TTVRecord A draw record for TTreeViewer; TTVSession A tree viewer session; TTabCom Perform command line completion when hitting <TAB>; TTable vector of the C structures; TTable3Points A 3-D Points; TTable::iterator ; TTableDescriptor descrpitor defining the internal layout of TTable objects; TTableIter Iterator over ""sorted"" TTable objects; TTableMap ""Map"" array for TTable object; TTablePadView3D ; TTablePoints Defines the TTable as an element of ""event"" geometry; TTableRange Range used in TGTable.; TTableSorter Is an ""observer"" class to sort the TTable objects; TTask Base class for tasks; TTeXDump Tex driver; TText Text; TTextEditor text editor; TThread Thread class; TThreadFactory Thread factory ABC; TThreadImp ThreadImp class; TTime Basic time type with milli second precis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:135007,simpl,simple,135007,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['simpl'],['simple']
Usability,"elete); virtual voidSetOnFileClass(TClass* cl); virtual voidSetValueClass(TClass* newcl); virtual UInt_tSize() const; virtual UInt_tSizeof() const; virtual voidStreamer(TBuffer& refBuffer); virtual voidStreamer(TBuffer& refBuffer, void* pObject, int siz). protected:. voidCheckFunctions() const; virtual voidDeleteItem(Bool_t force, void* ptr) const; TGenCollectionProxy*Initialize(Bool_t silent) const; virtual TGenCollectionProxy*InitializeEx(Bool_t silent). private:. TGenCollectionProxy(). Data Members; public:. enum { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodfClearMethod cache for container accessors: clear container; TGenCollectionProxy::MethodfCollectMethod to collect objects from container; void*fConstructContainer accessors: block construct; map<std::string,TObjArray*>*fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0fCreateEnvMethod to allocate an Environment holder.; void*fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*fEnvAddress of the currently proxied object; void*fFeedContainer accessors: block feed; TGenCollectionProxy::MethodfFirstContainer accessors: generic iteration: first; void*fFunctionCreateIterators; void*fFunctionDeleteTwoIterators; TGenCollectionProxy::Value*fKeyDescriptor of the key_type; stringfNameName of the class being proxied.; TGenCollectionProxy::MethodfNextContainer accessors: generic iteration: next; TClass*fOnFileClassOn file class; Bool_tfPointersFlag to indicate if containee has pointers (key or value); UInt_tTVirtualCollectionProxy::fProperties; vector<ROOT::TCollectionProxyInfo::EnvironBase*,allocator<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGenCollectionProxy.html:3888,clear,clear,3888,root/html532/TGenCollectionProxy.html,https://root.cern,https://root.cern/root/html532/TGenCollectionProxy.html,1,['clear'],['clear']
Usability,"eleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tfNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:17041,undo,undo,17041,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,8,['undo'],"['undo', 'undoing']"
Usability,"elf. In case the object member is a TClonesArray,; the mechanism described in case C is applied to this array.; if splitlevel=0, the object is serialized in the branch buffer. ==> Case C. TBranch *branch = tree->Branch(branchname,clonesarray, bufsize, splitlevel); clonesarray is the address of a pointer to a TClonesArray.; The TClonesArray is a direct access list of objects of the same class.; For example, if the TClonesArray is an array of TTrack objects,; this function will create one subbranch for each data member of; the object TTrack. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with only one branch). /*. */. A simple example with histograms and a tree*-*-*-; *-* ===========================================. This program creates :; - a one dimensional histogram; - a two dimensional histogram; - a profile histogram; - a tree. These objects are filled with some random numbers and saved on a file. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. #include ""TFile.h""; #include ""TH1.h""; #include ""TH2.h""; #include ""TProfile.h""; #include ""TRandom.h""; #include ""TTree.h"". //______________________________________________________________________________; main(int argc, char **argv); {; // Create a new ROOT binary machine independent file.; // Note that this file may contain any kind of ROOT objects, histograms,trees; // pictures, graphics objects, detector geometries, tracks, events, etc..; // This file is now becoming the current directory.; TFile hfile(""htree.root"",""RECREATE"",""Demo ROOT file with histograms & trees"");. // Create some histograms and a profile histogram; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:4395,simpl,simple,4395,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,1,['simpl'],['simple']
Usability,"ellow, kPink, etc are defined in the header file; 147Rtypes.h that is included in all ROOT other header files. It is better; 148to use these keywords in user code instead of hardcoded color numbers, e.g.:; 149 ; 150~~~ {.cpp}; 151 myObject.SetFillColor(kRed);; 152 myObject.SetFillColor(kYellow-10);; 153 myLine.SetLineColor(kMagenta+2);; 154~~~; 155 ; 156Begin_Macro(source); 157{; 158 auto w = new TColorWheel();; 159 auto cw = new TCanvas(""cw"",""cw"",0,0,400,400);; 160 w->SetCanvas(cw);; 161 w->Draw();; 162}; 163End_Macro; 164 ; 165The complete list of predefined color names is the following:; 166 ; 167~~~ {.cpp}; 168kWhite = 0, kBlack = 1, kGray = 920, kRed = 632, kGreen = 416,; 169kBlue = 600, kYellow = 400, kMagenta = 616, kCyan = 432, kOrange = 800,; 170kSpring = 820, kTeal = 840, kAzure = 860, kViolet = 880, kPink = 900; 171~~~; 172 ; 173Note the special role of color `kWhite` (color number 0). It is the default; 174background color also. For instance in a PDF or PS files (as paper is usually white); 175it is simply not painted. To have a white color behaving like the other color the; 176simplest is to define an other white color not attached to the color index 0:; 177 ; 178~~~ {.cpp}; 179 Int_t ci = TColor::GetFreeColorIndex();; 180 TColor *color = new TColor(ci, 1., 1., 1.);; 181~~~; 182 ; 183\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:5874,simpl,simply,5874,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['simpl'],['simply']
Usability,"elope:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ Envelope(). Envelope::Envelope ; (; const TString & ; name, . DataLoader * ; dataloader = nullptr, . TFile * ; file = nullptr, . const TString ; options = """" . ). protected . Constructor for the initialization of Envelopes, differents Envelopes may needs differents constructors then this is a generic one protected. ; Parameters. namethe name algorithm. ; dataloaderTMVA::DataLoader object with the data. ; fileoptional file to save the results. ; optionsextra options for the algorithm. . Definition at line 40 of file Envelope.cxx. ◆ ~Envelope(). Envelope::~Envelope ; (; ). Default destructor. ; Definition at line 62 of file Envelope.cxx. Member Function Documentation. ◆ BookMethod() [1/2]. void TMVA::Envelope::BookMethod ; (; TString ; methodName, . TString ; methodTitle, . TString ; options = """" . ). virtual . Method to book the machine learning method to perform the algorithm. ; Parameters. methodNameString with the name of the mva method ; methodTitleString with the method title. ; optionsString with the options for the method. . Definition at line 163 of file Envelope.cxx. ◆ BookMethod() [2/2]. void TMVA::Envelope::BookMethod ; (; Types::EMVA ; method, . TString ; methodTitle, . TString ; options = """" . ). virtual . Method to book the machine learning method to perform the algorithm. ; Parameters. methodenum TMVA::Types::EMVA with the type of the mva method ; methodTitleString with the method title. ; optionsString with the options for the method. . Definition at line 152 of file Envelope.cxx. ◆ Class(). static TClass * TMVA::Envelope::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Envelope::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::Envelope::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Envelope.html:17952,learn,learning,17952,doc/master/classTMVA_1_1Envelope.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Envelope.html,1,['learn'],['learning']
Usability,"els ;  hlabels2.C 2-D histograms with alphanumeric labels ;  hlHisto1.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto2.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hlHisto3.CThis tutorial demonstrates how the highlight mechanism can be used on a ntuple ;  hlHisto4.CThis tutorial demonstrates how the highlight mechanism can be used on an histogram ;  hstack.C Example of stacked histograms: class THStack ;  hsum.C Histograms filled and drawn in a loop ;  hsumTimer.C Demo of Timers ;  legendautoplaced.C The legend can be placed automatically in the current pad in an empty space found at painting time ;  logscales.C Draw parametric functions with log scales ;  multicolor.C Use a THStack to show a 2-D hist with cells with different colors ;  ratioplot1.C Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot1.py Example creating a simple ratio plot of two histograms using the pois division option ;  ratioplot2.C Example of a fit residual plot ;  ratioplot2.py Example of a fit residual plot ;  ratioplot3.C Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot3.py Example which shows how you can get the graph of the lower plot and set the y axis range for it ;  ratioplot4.C Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot4.py Example that shows custom dashed lines on the lower plot, specified by a vector of floats ;  ratioplot5.C Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot5.py Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors ;  ratioplot6.C Example showing a fit residual plot, where the separation margin has been set to 0 ;  ratioplot6.py Exa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:127721,simpl,simple,127721,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"em path; TGFileBrowser File browser.; TGFileContainer Container containing file system objects; TGFileDialog File selection dialog; TGFileInfo ; TGFileItem Class representing file system object; TGFont GUI font description; TGFontDialog Font selection dialog; TGFontDialog::FontProp_t ; TGFontPool Font pool; TGFontTypeComboBox Font type combobox widget; TGFrame Base class for simple widgets (button, etc.); TGFrameElement Base class used in GUI containers; TGFrameElementPack Class used in TGPack.; TGGC Graphics context; TGGCPool Graphics context pool; TGGotoDialog Goto line dialog used by TGTextEdit widget; TGGroupFrame A composite frame with border and title; TGHButtonGroup A button group with one horizontal row; TGHProgressBar Horizontal progress bar widget; TGHScrollBar Horizontal scrollbar widget; TGHSlider Horizontal slider widget; TGHSplitter A horizontal frame splitter; TGHeaderFrame Header frame with buttons and splitters; TGHorizontal3DLine A horizontal 3D separator line; TGHorizontalFrame Composite frame with horizontal child layout; TGHorizontalLayout Horizontal layout manager; TGHotString Graphics string with hot character; TGHtml HTML widget; TGHtmlBrowser very simple html browser; TGIcon Icon GUI class; TGIconLBEntry Icon + text listbox entry; TGIdleHandler Idle event handler; TGImageMap Clickable image (like MAP in HTML); TGInputDialog Simple input dialog; TGInsets Inset (left, right, top, bottom); TGL5DDataSet Class to read data from TTree and create TGL5DPainter.; TGL5DDataSetEditor GUI for editing OpenGL 5D Viewer attributes; TGLAdapter Allow plot-painters to be used for gl-inpad and gl-viewer.; TGLAnnotation GL-annotation.; TGLAutoRotator Short description.; TGLAxis a GL Axis; TGLAxisPainter GL axis painter.; TGLAxisPainterBox Painter of GL axes for a 3D box.; TGLBContainer Listbox container; TGLBEntry Basic listbox entry; TGLBoundingBox a 3D orientated bounding box; TGLBoxCut Cuts away part of a plot.; TGLBoxPainter Box painter; TGLCamera Camera abs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:74484,progress bar,progress bar,74484,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,"['progress bar', 'simpl']","['progress bar', 'simple']"
Usability,"ember Functions;  LayerData (const LayerData &other);  copy c'tor of LayerData ;  ;  LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (LayerData &&other);  move c'tor of LayerData ;  ;  LayerData (size_t inputSize);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, iterator_type itGradientBegin, std::shared_ptr< std::function< double(double)> > activationFunction, std::shared_ptr< std::function< double(double)> > inverseActivationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, std::shared_ptr< std::function< double(double)> > activationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  ~LayerData ();  ; std::shared_ptr< std::function< double(double)> > activationFunction () const;  ; void clear ();  clear the values and the deltas ;  ; void clearDropOut ();  clear the drop-out-data for this layer ;  ; iterator_type deltasBegin ();  returns iterator to the begin of the deltas (back-propagation) ;  ; const_iterator_type deltasBegin () const;  returns const iterator to the begin of the deltas (back-propagation) ;  ; iterator_type deltasEnd ();  returns iterator to the end of the deltas (back-propagation) ;  ; const_iterator_type deltasEnd () const;  returns const iterator to the end of the deltas (back-propagation) ;  ; const_dropout_iterator dropOut () const;  return the begin of the drop-out information ;  ; iterator_type gradientsBegin ();  returns iterator to the begin of the gradients ;  ; const_iterator_type gradientsBegin () const;  returns const iterator to the begin of the gradients ;  ; bool hasDropOut () const;  has this layer drop-out turned on? ;  ; std::shared_ptr< std::function< double(double)> > inverseActivationFunction () const;  ; ModeOutputValues outputMod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:1929,clear,clear,1929,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"embers; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600). void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: c52dc6cb225c25e34d388329d41570a484d98ce0 $ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressLog.html:26292,clear,clear,26292,root/html604/TProofProgressLog.html,https://root.cern,https://root.cern/root/html604/TProofProgressLog.html,1,['clear'],['clear']
Usability,"embers; Includes; Libraries. Function documentation; TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. TProofProgressLog(const char* url = 0, Int_t sessionidx = 0, Int_t w = 700, Int_t h = 600); Create a window frame for log messages. void Init(Int_t w = 700, Int_t h = 600); Init window frame for log messages. ~TProofProgressLog(); Destructor. void Popup(); Show log window. void Clear(Option_t* = 0); Clear log window. void LoadBuffer(const char* buffer); Load a text buffer in the window. void LoadFile(const char* file); Load a file in the window. void AddBuffer(const char* buffer); Add text to the window. void CloseWindow(); Handle close button or when closed via window manager action. void BuildLogList(Bool_t create = kFALSE); Build the list of workers. For this, extract the logs and take the names; of TProofLogElements. void DoLog(Bool_t grep = kFALSE); Display logs. 'grep' is set to kTRUE if it is invoked by pressing the; 'Filter' button. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void SaveToFile(); Save the logs to a file; Only the name of the file is taken, no expansion. void SetGrepView(); Sets the view of grep filters according to the value of checkboxes. void NoLineEntry(); Enable/disable the line number entry. void Select(Int_t id, Bool_t all = kTRUE); actions of select all/clear all button. void Rebuild(); Rebuild the log info for a new entered session. TProofProgressLog(TProofProgressDialog* d, Int_t w = 700, Int_t h = 600). void SetUrl(const char* url); slots. { fSessionUrl = url; }. » Author: G Ganis, Aug 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: c52dc6cb225c25e34d388329d41570a484d98ce0 $ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressLog.html:26292,clear,clear,26292,root/html602/TProofProgressLog.html,https://root.cern,https://root.cern/root/html602/TProofProgressLog.html,1,['clear'],['clear']
Usability,"ement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); Constructor.; The base-class TEveWindowFrame is constructed without a frame so; a default composite-frame is instantiated and stored in fGUIFrame.; Cleanup is set to no-cleanup as viewers need to be zapped with some; more care. ~TEveViewer(); Destructor. void InitInternal(); Initialize static data-members according to running conditions. void PreUndock(); Virtual function called before a window is undocked.; On mac we have to force recreation of gl-context. void PostDock(); Virtual function called after a window is docked.; On mac we have to force recreation of gl-context. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveViewer icon. void SetGLViewer(TGLViewer* viewer, TGFrame* frame); Set TGLViewer that is represented by this object.; The old gl-viewer is deleted. TGLSAViewer* SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE); Spawn new GLViewer and adopt it. TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); Spawn new GLViewer and adopt it. void Redraw(Bool_t resetCameras = kFALSE); Redraw viewer immediately. void SwitchStereo(); Switch stereo mode.; This only works TGLSAViewers and, of course, with stereo support; provided by the OpenGL driver. void AddScene(TEveScene* scene); Add 'scene' to the list of scenes. void RemoveElementLocal(TEveElement* el); Remove element 'el' from the list of child",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveViewer.html:24040,undo,undocked,24040,root/html602/TEveViewer.html,https://root.cern,https://root.cern/root/html602/TEveViewer.html,1,['undo'],['undocked']
Usability,"ement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveViewer(const char* n = ""TEveViewer"", const char* t = """"); Constructor.; The base-class TEveWindowFrame is constructed without a frame so; a default composite-frame is instantiated and stored in fGUIFrame.; Cleanup is set to no-cleanup as viewers need to be zapped with some; more care. ~TEveViewer(); Destructor. void InitInternal(); Initialize static data-members according to running conditions. void PreUndock(); Virtual function called before a window is undocked.; On mac we have to force recreation of gl-context. void PostDock(); Virtual function called after a window is docked.; On mac we have to force recreation of gl-context. const TGPicture* GetListTreeIcon(Bool_t open = kFALSE); Return TEveViewer icon. void SetGLViewer(TGLViewer* viewer, TGFrame* frame); Set TGLViewer that is represented by this object.; The old gl-viewer is deleted. TGLSAViewer* SpawnGLViewer(TGedEditor* ged = 0, Bool_t stereo = kFALSE, Bool_t quad_buf = kTRUE); Spawn new GLViewer and adopt it. TGLEmbeddedViewer* SpawnGLEmbeddedViewer(TGedEditor* ged = 0, Int_t border = 0); Spawn new GLViewer and adopt it. void Redraw(Bool_t resetCameras = kFALSE); Redraw viewer immediately. void SwitchStereo(); Switch stereo mode.; This only works TGLSAViewers and, of course, with stereo support; provided by the OpenGL driver. void AddScene(TEveScene* scene); Add 'scene' to the list of scenes. void RemoveElementLocal(TEveElement* el); Remove element 'e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveViewer.html:24065,undo,undocked,24065,root/html604/TEveViewer.html,https://root.cern,https://root.cern/root/html604/TEveViewer.html,1,['undo'],['undocked']
Usability,"emented from RooAbsPdf.; Definition at line 55 of file RooChebychev.h. ◆ selectNormalizationRange(). void RooChebychev::selectNormalizationRange ; (; const char * ; rangeName = nullptr, . bool ; force = false . ). overridevirtual . Interface function to force use of a given normalization range to interpret function value. ; Needed for functions or p.d.f.s whose shape depends on the choice of normalization such as RooAddPdf ; Reimplemented from RooAbsReal.; Definition at line 66 of file RooChebychev.cxx. ◆ Streamer(). void RooChebychev::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooChebychev::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 55 of file RooChebychev.h. ◆ translate(). void RooChebychev::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 93 of file RooChebychev.cxx. Member Data Documentation. ◆ _coefList. RooListProxy RooChebychev::_coefList. private . Definition at line 46 of file RooChebychev.h. ◆ _refRangeName. TNamed* RooChebychev::_refRangeName = nullptr. mutableprivate . Definition at line 47 of file RooChebychev.h. ◆ _x. RooRealProxy RooChebychev::_x. private . Definition at line 45 of file RooChebychev.h. Libraries for RooChebychev:. [legend]; The docu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChebychev.html:78573,simpl,simple,78573,doc/master/classRooChebychev.html,https://root.cern,https://root.cern/doc/master/classRooChebychev.html,1,['simpl'],['simple']
Usability,"emented: meaningful only in the remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofPlayer.html:21651,feedback,feedback,21651,root/html602/TProofPlayer.html,https://root.cern,https://root.cern/root/html602/TProofPlayer.html,1,['feedback'],['feedback']
Usability,"en a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::AddSpectatorvoid AddSpectator(const TString &expression, const TString &title="""", const TString &unit="""", Double_t min=0, Double_t max=0)user inserts target in data set infoDefinition DataLoader.cxx:524; TMVA::DataLoader::SetBackgroundWeightExpressionvoid SetBackgroundWeightExpression(const TString &variable)Definition DataLoader.cxx:556; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::Envelope::BookMethodvirtual void BookMethod(TString methodname, TString methodtitle, TString options="""")Method to book the machine learning method to perform the algorithm.Definition Envelope.cxx:163; TMVA::Experimental::ClassificationDefinition Classification.h:162; TMVA::Experimental::Classification::GetResultsstd::vector< ClassificationResult > & GetResults()Return the vector of TMVA::Experimental::ClassificationResult objects.Definition Classification.cxx:945; TMVA::Experimental::Classification::Evaluatevirtual void Evaluate()Method to perform Train/Test over all ml method booked.Definition Classification.cxx:248; TMVA::Tools::Instancestatic Tools & Instance()Definition Tools.cxx:71; TMVA::Types::kBDT@ kBDTDefinition Types.h:86; TMVA::Types::kSVM@ kSVMDefinition Types.h:89; TMultiGraphA TMultiGraph is a collection of TGraph (or derived) objects.Definition TMultiGraph.h:34; TStringBasic string class.Definition TString.h:139; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Classification.html:5245,learn,learning,5245,doc/master/classTMVA_1_1Classification.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Classification.html,1,['learn'],['learning']
Usability,"en looping over a TTree with a friend with a larger number of entries, the loop spans all entries in the friend; [#7143] - TTreeProcessorMT: Fails when iterating over different treenames within same ROOT file; [#7039] - TExecutor: handling of non-IMT/… case; [#6933] - ROOT 6.22 should reject TBB 2021.1.1 and above during configuration (fails to compile); [#6765] - PyROOT breaks if ROOT objects are unpickled in a multiprocess environment; [#6915] - roottest-python-regression-regression requires OpenGL but still run when it is disable; [#6472] - TThreadExecutor::Map should be able to accept const std::vector arguments; [#6363] - [IMT] ROOT::GetThreadPoolSize does not reflect tbb::global_control settings; [#7055] - Fatal error after running make install when built against LLVM 9; [#7067] - RooFit RooAbsArg::graphVizTree produces invalid dot files for graph titles including spaces; [#7115] - regex_error when selecting pdf components to plot; [#7164] - TGSpeedo mean value calculation; [#7195] - ROOT crash when parameter by value passed to slot: StrDup; [#7240] - [RF] Batch mode returns broken logarithms when -DVDT=OFF; [#7180] - TGCommandLinePlugin Up-Down Arrows and Tab Keys; [#7181] - RDataFrame Snapshot of friend trees; [#7258] - [RF] Update crystal ball shapes in RooFit; [#7086] - [DF] Section of RDF reference guide about RDF+RVec; [#7182] - Range not considered when computing integral of RooParamHistFunc; [#7547] - [DF] Crash in lazy jitted Snapshot; [#7010] - fifo in $CWD causes TCanvas to hang on macOS; [#7676] - hadd reverses order of object cycles; [#6343] - Problem with using namespace std in generated dictionary files; [#7657] - New dictionary-related crash in 6.24.00-patches; [#7718] - PyROOT in root 6.24 branch hangs while loading CMSSW library; [#7090] - Apple M1: bug in jitting argument of type short; [#6802] - Allow to pass Bearer token authentication header to Davix client; [#7345] - Issue building built-in libafterimage; [#6812] - root REPL problem with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:44691,guid,guide,44691,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['guid'],['guide']
Usability,"en name. If no such object; is found return a null pointer. TObject* FindObject(const TObject* obj); Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg); Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name); Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. RooLinkedListIter iterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Mon Dec 7 13:48:08 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinkedList.html:8792,simpl,simple,8792,root/html526/RooLinkedList.html,https://root.cern,https://root.cern/root/html526/RooLinkedList.html,1,['simpl'],['simple']
Usability,"en signal efficiencyDefinition MethodCuts.cxx:551; TMVA::MethodCuts::PrintCutsvoid PrintCuts(Double_t effS) constprint cutsDefinition MethodCuts.cxx:465; TMVA::MinuitFitter/Fitter using MINUITDefinition MinuitFitter.h:48; TMVA::PDFPDF wrapper for histograms; uses user-defined spline interpolation.Definition PDF.h:63; TMVA::PDF::kSpline2@ kSpline2Definition PDF.h:70; TMVA::ResultsClass that is the base-class for a vector of result.Definition Results.h:57; TMVA::Results::Storevoid Store(TObject *obj, const char *alias=nullptr)Definition Results.cxx:86; TMVA::Results::GetHistTH1 * GetHist(const TString &alias) constDefinition Results.cxx:136; TMVA::SimulatedAnnealingFitterFitter using a Simulated Annealing Algorithm.Definition SimulatedAnnealingFitter.h:49; TMVA::TSpline1Linear interpolation of TGraph.Definition TSpline1.h:43; TMVA::TimerTiming information for training and evaluation of MVA methods.Definition Timer.h:58; TMVA::Timer::DrawProgressBarvoid DrawProgressBar(Int_t, const TString &comment="""")draws progress bar in color or B&W caution:Definition Timer.cxx:202; TMVA::Tools::ParseFormatLineTList * ParseFormatLine(TString theString, const char *sep="":"")Parse the string and cut into labels separated by "":"".Definition Tools.cxx:401; TMVA::Tools::Colorconst TString & Color(const TString &)human readable color stringsDefinition Tools.cxx:828; TMVA::Tools::ReadAttrvoid ReadAttr(void *node, const char *, T &value)read attribute from xmlDefinition Tools.h:329; TMVA::Tools::AddCommentBool_t AddComment(void *node, const char *comment)Definition Tools.cxx:1132; TMVA::Tools::GetChildvoid * GetChild(void *parent, const char *childname=nullptr)get child nodeDefinition Tools.cxx:1150; TMVA::Tools::AddAttrvoid AddAttr(void *node, const char *, const T &value, Int_t precision=16)add attribute to xmlDefinition Tools.h:347; TMVA::Tools::AddChildvoid * AddChild(void *parent, const char *childname, const char *content=nullptr, bool isRootNode=false)add child nodeDefinition Tools.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodCuts_8cxx_source.html:83685,progress bar,progress bar,83685,doc/master/MethodCuts_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodCuts_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"en to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need to write a specialized streamer for a class. One reason is that it may be necessary to execute some code before or after data is read or written, for example, to initialize some non-persistent data members after the persistent data is read. In this case, the custom streamer can use the StreamerInfo record to decompose a self-identifying object in the exact same manner as the generated streamer would have done. An example is given (for the Event class) in the Root User's Guide (URL below) (Input/Output chapter, Streamers subchapter). On the other hand, if the user needs to write a stream",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:8991,simpl,simple,8991,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,1,['simpl'],['simple']
Usability,"en to the buffer directly. Eventually the buffer contains all simple data members of all the classes that make up this particular object. Data members that are references (as MyClass &fObj;) are never saved, it is always the responsibility of the object’s constructor to set them properly.; 11.3.1 Automatically Generated Streamers; A Streamerusually calls other Streamers: the Streamerof its parents and data members. This architecture depends on all classes having Streamers, because eventually they will be called. To ensure that a class has a Streamer, rootcling automatically creates one in the ClassDef macro that is defined in $ROOTSYS/include/Rtypes.h. ClassDef defines several methods for any class, and one of them is the Streamer. The automatically generated Streameris complete and can be used as long as no customization is needed.; The Event class is defined in $ROOTSYS/test/Event.h. Looking at the class definition, we find that it inherits from TObject. It is a simple example of a class with diverse data members.; class Event : public TObject {; private:; TDirectory *fTransient; //! current directory; Float_t fPt; //! transient value; char fType[20];; Int_t fNtrack;; Int_t fNseg;; Int_t fNvertex;; UInt_t fFlag;; Float_t fTemperature;; EventHeader fEvtHdr; //|| don't split; TClonesArray *fTracks; //->; TH1F *fH; //->; Int_t fMeasures[10];; Float_t fMatrix[4][4];; Float_t *fClosestDistance; //[fNvertex]; ...; The Event class is added to the dictionary by the rootcling utility. This is the rootcling statement in the $ROOTSYS/test/Makefile:; @rootcling -f EventDict.cxx -c Event.h EventLinkDef.h; The EventDict.cxx file contains the automatically generated Streamerfor Event:; void Event::Streamer(TBuffer &R__b){; // Stream an object of class Event.; if (R__b.IsReading()) {; Event::Class()->ReadBuffer(R__b, this);; } else {; Event::Class()->WriteBuffer(R__b, this);; }; }; When writing an Event object, TClass::WriteBuffer is called. WriteBuffer writes the current version ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:467773,simpl,simple,467773,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"en(""root://my.server.org/data/file.root"",""new""); root[] TFile *f3 = TFile::Open(""http://root.cern.ch/files/hsimple.root""); root[] f3.ls(); TDavixFile** http://root.cern.ch/files/hsimple.root; TDavixFile* http://root.cern.ch/files/hsimple.root; KEY: TH1F hpx;1 This is the px distribution; KEY: TH2F hpxpy;1 py vs px; KEY: TProfile hprof;1 Profile of pz versus px; KEY: TNtuple ntuple;1 Demo ntuple; root[] hpx.Draw(); 11.8 XML Interface; A new module xml as implemented by Sergey Linev (GSI). It is an optional package that can be used to save a canvas into file.xml file format instead of file.root. XML files do not have any advantages compared to the normal ROOT files, except that the information in these files can be edited via a normal editor. The main motivation for this new format is to facilitate the communication with other non ROOT applications. Currently writing and reading XML files is limited to ROOT applications. It is our intention to develop a simple reader independent of the ROOT libraries that could be used as an example for real applications.; The XML format should be used only for small data volumes, typically histogram files, pictures, geometries, calibrations. The XML file is built in memory before being dumped to disk. Like for normal ROOT files, XML files use the same I/O mechanism exploiting the ROOT/Cling dictionary. Any class having a dictionary can be saved in XML format. This first implementation does not support subdirectories or trees.; The shared library libRXML.so may be loaded dynamically via gSystem->Load(""libRXML""). This library is also automatically loaded by the plug-in manager as soon a XML file is created. To create an XTM file, simply specify a filename with an .xml extension when calling TFile::Open. TFile::Open will recognize that you are trying to open an XML file and return a TXMLFile object. When a XML file is open in write mode, one can use the normal TObject::Write to write an object in the file.; // example of a session saving",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:517893,simpl,simple,517893,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"enFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24060,simpl,simple,24060,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['simpl'],['simple']
Usability,"ename = ""https://root.cern/js/files/hsimple.root"";; let file = await openFile(filename);; let obj = await file.readObject(""hpxpy;1"");; await draw(""drawing"", obj, ""colz"");; </script>; Here the default location https://root.cern/js/latest/ is specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:23956,simpl,simple,23956,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,1,['simpl'],['simple']
Usability,"ename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >Adagrad Optimizer class. ; This class represents the Adagrad Optimizer. ; Definition at line 45 of file Adagrad.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdagrad (DeepNet_t &deepNet, Scalar_t learningRate=0.01, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdagrad ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:1678,learn,learningRate,1678,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['learn'],['learningRate']
Usability,"ence< Real_t >::SymmetricReluDerivative ; (; TMatrixT< AReal > & ; B, . const TMatrixT< AReal > & ; A . ). inlinestatic . Definition at line 157 of file ActivationFunctions.hxx. ◆ Tanh(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::Tanh ; (; TMatrixT< AReal > & ; B). inlinestatic . Definition at line 109 of file ActivationFunctions.hxx. ◆ TanhDerivative(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::TanhDerivative ; (; TMatrixT< AReal > & ; B, . const TMatrixT< AReal > & ; A . ). inlinestatic . Definition at line 125 of file ActivationFunctions.hxx. ◆ UpdateParams(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::UpdateParams ; (; TMatrixT< AReal > & ; x, . TMatrixT< AReal > & ; tildeX, . TMatrixT< AReal > & ; y, . TMatrixT< AReal > & ; z, . TMatrixT< AReal > & ; fVBiases, . TMatrixT< AReal > & ; fHBiases, . TMatrixT< AReal > & ; fWeights, . TMatrixT< AReal > & ; VBiasError, . TMatrixT< AReal > & ; HBiasError, . AReal ; learningRate, . size_t ; fBatchSize . ). static . Definition at line 48 of file DenoisePropagation.hxx. ◆ UpdateParamsLogReg(). template<typename AReal > . void TMVA::DNN::TReference< Real_t >::UpdateParamsLogReg ; (; TMatrixT< AReal > & ; input, . TMatrixT< AReal > & ; output, . TMatrixT< AReal > & ; difference, . TMatrixT< AReal > & ; p, . TMatrixT< AReal > & ; fWeights, . TMatrixT< AReal > & ; fBiases, . AReal ; learningRate, . size_t ; fBatchSize . ). static . Definition at line 191 of file DenoisePropagation.hxx. Member Data Documentation. ◆ fgRandomGen. template<typename Real_t > . TRandom * TMVA::DNN::TReference< Real_t >::fgRandomGen = nullptr. staticprivate . Definition at line 55 of file Reference.h. tmva/tmva/inc/TMVA/DNN/Architectures/Reference.h; tmva/tmva/src/DNN/Architectures/Reference/ActivationFunctions.hxx; tmva/tmva/src/DNN/Architectures/Reference/Arithmetic.hxx; tmva/tmva/src/DNN/Architectures/Reference/DenoisePropagation.hxx; tmva/tmva/src/DNN/Architectures/Reference/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html:45581,learn,learningRate,45581,doc/master/classTMVA_1_1DNN_1_1TReference.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReference.html,1,['learn'],['learningRate']
Usability,"enceSteps ; (; size_t ; steps). inline . Setters. ; Definition at line 153 of file DLMinimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 155 of file DLMinimizers.h. ◆ SetTestInterval(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetTestInterval ; (; size_t ; interval). inline . Definition at line 154 of file DLMinimizers.h. ◆ Step() [1/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 182 of file DLMinimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Step ; (; DeepNet_t & ; master, . std::vector< DeepNet_t > & ; nets, . std::vector< TTensorBatch< Architecture_t > > & ; batches . ). Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 246 of file DLMinimizers.h. ◆ StepLoss(). template<typename Architecture_t > . auto TMVA::DNN::TDLGradientDescent< Architecture_t >::StepLoss ; (; DeepNet_t & ; deepNet, . std::vector< Matrix_t > & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Same as Step(...) but als",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:8257,learn,learning,8257,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,1,['learn'],['learning']
Usability,ency of the filters applied ;  df004_cutFlowReport.py This tutorial shows how to get information about the efficiency of the filters applied ;  df005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  df006_ranges.C This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df006_ranges.py This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with RDataFrame ;  df008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with RDataFrame ;  df009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  df010_trivialDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df010_trivialDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df012_DefinesAndFiltersAsStrings.C ;  df012_DefinesAndFiltersAsStrings.py ;  df013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  df014_CSVDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df014_CSVDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df015_LazyDataSource.C Thi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:99525,simpl,simpler,99525,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simpler']
Usability,"ency"" and label the axis pEff->SetTitle(""My Efficiency;x label;eff""); ; Reimplemented from TNamed.; Definition at line 3726 of file TEfficiency.cxx. ◆ SetTotalEvents(). Bool_t TEfficiency::SetTotalEvents ; (; Int_t ; bin, . Double_t ; events . ). Sets the number of total events in the given global bin. ; returns ""true"" if the number of total events has been updated otherwise ""false"" ist returned; Note: - requires: fPassedHistogram->GetBinContent(bin) <= events ; Definition at line 3760 of file TEfficiency.cxx. ◆ SetTotalHistogram(). Bool_t TEfficiency::SetTotalHistogram ; (; const TH1 & ; rTotal, . Option_t * ; opt . ). Sets the histogram containing all events. ; The given histogram is cloned and stored internally as histogram containing all events. The given histogram has to be consistent with the current fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)). The method returns whether the fTotalHistogram has been replaced (true) or not (false).; Note: The list of associated functions fFunctions is cleared.; Option:; ""f"": force the replacement without checking the consistency This can lead to inconsistent histograms and useless results or unexpected behaviour. But sometimes it might be the only way to change the histograms. If you use this option, you should ensure that the fPassedHistogram is replaced by a consistent one (with respect to rTotal) as well. . Definition at line 3791 of file TEfficiency.cxx. ◆ SetUseWeightedEvents(). void TEfficiency::SetUseWeightedEvents ; (; Bool_t ; on = kTRUE). Definition at line 3825 of file TEfficiency.cxx. ◆ SetWeight(). void TEfficiency::SetWeight ; (; Double_t ; weight). Sets the global weight for this TEfficiency object. ; Note: - weight has to be positive ( > 0) ; Definition at line 3843 of file TEfficiency.cxx. ◆ Streamer(). void TEfficiency::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TEfficiency::StreamerNVirtual ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEfficiency.html:112396,clear,cleared,112396,doc/master/classTEfficiency.html,https://root.cern,https://root.cern/doc/master/classTEfficiency.html,1,['clear'],['cleared']
Usability,"end feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Additional Inherited Members;  Public Types inherited from TProofPlayer; enum  EStatusBits { kDispatchOneEvent = (1ULL << ( 15 )); , kIsProcessing = (1ULL << ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:22125,feedback,feedback,22125,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['feedback'],['feedback']
Usability,"end feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bool_t &w80r, Bool_t &w80v, TString &wmsg);  Check the memory usage, if requested. ;  ; virtual Int_t DrawCanvas (TObject *obj);  Draw the object if it is a canvas. ;  ; void * GetSender () override;  ; void MapOutputListToDataMembers () const;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual const char * GetSenderClassName () const;  . Protected Attributes; TDSet * fDSet;  ; ErrorHandlerFunc_t fErrorHandler;  tdset for current processing ;  ; TList * fFeedback;  ; TList * fFeedbackLists;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:20418,feedback,feedback,20418,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ensible default value here; auto df_default = df.DefaultValueFor(""col"", default_value).Define(""twice"", ""col * 2"");; auto df_filtered = df.FilterAvailable(""col"").Define(""twice"", ""col * 2"");; ; // Same number of total entries as the input dataset, with defaulted values; df_default.Display({""twice""})->Print();; // Only keep the entries where ""col"" has values; df_filtered.Display({""twice""})->Print();; Further considerations; Note that working with missing values is currently supported with a TTree-based data source. Support of this functionality for other data sources may come in the future. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performance even further, you can also pre-compile a C++ library with full code optimizations and load the function into the RDataFrame computation as follows.; ROOT.gSystem.Load(""path/to/myLibrary.so"") # Library with the myFilter function; ROOT.gInterprete",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:86817,simpl,simple,86817,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"ent Tree branches. When a top level object (eg Event *event) is a tree/graph of many objects,; the normal ROOT Streaming mechanism ensures that only one copy of each object; in the tree/graph is written to the output buffer to avoid circular; dependencies.; However if the object event is split into several files or into several; branches of one or more Trees, normal C++ pointers cannot be used because; each I/O operation will write the referenced objects.; When a TRef is used to point to a TObject *robj, for example in a class with; TRef fRef;; one can do:; fRef = robj; //to set the pointer; This TRef and robj can be written with two different I/O calls; in the same or different files, in the same or different branches of a Tree. If the TRef is read and the referenced object has not yet been read,; the TRef will return a null pointer. As soon as the referenced object; will be read, the TRef will point to it. If the referenced object is; contained in a TTree it can be autoloaded using the TBranchRef mechanism,; which is set up by simply calling TTree::BranchRef(). TRef also supports the complex situation where a TFile is updated; multiple times on the same machine or a different machine. How does it work. A TRef is itself a TObject with an additional transient pointer fPID.; When the statement fRef = robj is executed, the following actions happen:; - The pointer fPID is set to the current TProcessID.; - The current ObjectNumber (see below) is incremented by one.; - robj::fUniqueID is set to ObjectNumber.; - In the fPID object, the element fObjects[ObjectNumber] is set to robj; - ref::fUniqueID is also set to ObjectNumber.; After having set fRef, one can immediatly return the value of robj; using fRef.GetObject(). This function returns directly fObjects[fUniqueID]; from the fPID object. When the TRef is written, the process id number pidf of fPID is written; in addition to the TObject part of TRef (fBits,fUniqueID).; When the TRef is read, its pointer fPID is set to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRef.html:1616,simpl,simply,1616,root/html528/TRef.html,https://root.cern,https://root.cern/root/html528/TRef.html,6,['simpl'],['simply']
Usability,"ent direction (nx,ny,nz). This direction is stored as Double_t fCurrentDirection[3] by the navigator and it represents a direction in the global frame. It can be retrieved with:; Const Double_t *cdir = gGeoManager->GetCurrentDirection();; TGeoManager::GetCurrentDirectionconst Double_t * GetCurrentDirection() constDefinition TGeoManager.h:502; The direction can be initialized in a similar manner as the current point:; gGeoManager->SetCurrentDirection(nx,ny,nz);; // or:; gGeoManager->SetCurrentDirection(Double_t *dir);; TGeoManager::SetCurrentDirectionvoid SetCurrentDirection(Double_t *dir)Definition TGeoManager.h:518. Initializing the State; Setting the initial point and direction is not enough for initializing tracking. The modeller needs to find out where the initial point is located in the geometrical hierarchy. Due to the containment based architecture of the model, this is the deepest positioned object containing the point. For illustrating this, imagine that we have a simple structure with a top volume A and another one Bpositioned inside. Since Ais a top volume, its associated node A_1 will define MARS and our simple hierarchy of nodes (positioned volumes) will be: /A_1/B_1. Suppose now that the initial point is contained by B_1. This implies by default that the point is also contained by A_1, since B_1 have to be fully contained by this. After searching the point location, the modeller will consider that the point is located inside B_1, which will be considered as the representative object (node) for the current state. This is stored as: TGeoNode *TGeoNavigator::fCurrentNode and can be asked from the manager class only after the ‘'Where am I?’` was completed:; TGeoNode *current = gGeoManager->GetCurrentNode();; TGeoManager::GetCurrentNodeTGeoNode * GetCurrentNode() constDefinition TGeoManager.h:499; In order to find the location of the current point inside the hierarchy of nodes, after setting this point it is mandatory to call the ‘‘Where am I?’` method:; gGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:70688,simpl,simple,70688,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"ent variables seen so far. void ClearFiles(); Close all files. void ClearGlobalFunctions(); Forget all global functions seen so far.; Not needed anymore. Use gROOT->GetListOfGlobalFunctions(). void ClearGlobals(); Forget all global variables seen so far.; With teh new implamentation the list is gROOT->GetListOfGlobals(true). void ClearPragmas(); Forget all pragmas seen so far. void ClearSysIncFiles(); Close system files. void ClearUsers(); Forget all user seen so far. void ClearAll(); clears all lists; except for user names and system include files. void RehashClasses(); Do the class rehash. void RehashCppDirectives(); Cpp rehashing. void RehashEnvVars(); Environemnt variables rehashing. void RehashFiles(); Close files. void RehashGlobalFunctions(); Reload global functions. void RehashGlobals(); Reload globals. void RehashPragmas(); Reload pragmas. void RehashSysIncFiles(); Reload system include files. void RehashUsers(); Reload users. void RehashAll(); clears and then rebuilds all lists; except for user names and system include files. const TSeqCollection * GetListOfClasses(); Return the list of classes. const TSeqCollection * GetListOfCppDirectives(); Return the list of CPP directives. const TSeqCollection * GetListOfFilesInPath(const char[] path); ""path"" should be initialized with a colon separated list of; system directories. const TSeqCollection * GetListOfEnvVars(); Uses ""env"" (Unix) or ""set"" (Windows) to get list of environment variables. const TSeqCollection * GetListOfGlobals(); Return the list of globals. TCollection * GetListOfGlobalFunctions(); Return the list of global functions. const TSeqCollection * GetListOfPragmas(); Return the list of pragmas. const TSeqCollection * GetListOfSysIncFiles(); Return the list of system include files. const TSeqCollection * GetListOfUsers(); reads from ""/etc/passwd"". Char_t AllAgreeOnChar(int i, const TSeqCollection* pList, Int_t& nGoodStrings); [static utility function]. if all the strings in ""*pList"" have the same it",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTabCom.html:8729,clear,clears,8729,root/html602/TTabCom.html,https://root.cern,https://root.cern/root/html602/TTabCom.html,2,['clear'],['clears']
Usability,"ent); TList*fUnAllocatednodes with unallocated files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPacketizerAdaptive(TDSet* dset, TList* slaves, Long64_t first, Long64_t num, TList* input, TProofProgressStatus* st); Constructor. ~TPacketizerAdaptive(); Destructor. void InitStats(); (re)initialise the statistics; called at the begining or after a worker dies. void RemoveUnAllocNode(TPacketizerAdaptive::TFileNode* ); Remove unallocated node. void RemoveActive(TPacketizerAdaptive::TFileStat* file); Remove file from the list of actives. void RemoveActiveNode(TPacketizerAdaptive::TFileNode* ); Remove node from the list of actives. void Reset(); Reset the internal data structure for packet distribution. void ValidateFiles(TDSet* dset, TList* slaves, Long64_t maxent = -1, Bool_t byfile = kFALSE); Check existence of file/dir/tree an get number of entries.; Assumes the files have been setup. Int_t CalculatePacketSize(TObject* slstat, Long64_t cachesz, Int_t learnent); The result depends on the fStrategy. Int_t AddProcessed(TSlave* sl, TProofProgressStatus* st, Double_t latency, TList** listOfMissingFiles = 0); To be used by GetNextPacket but also in reaction to kPROOF_STOPPROCESS; message (when the worker was asked to stop processing during a packet).; returns the #entries intended in the last packet - #processed entries. TDSetElement * GetNextPacket(TSlave* sl, TMessage* r); Get next packet;; A meaningfull difference to TPacketizer is the fact that this; packetizer, for each worker, tries to predict whether the worker; will finish processing it's local files before the end of the query.; If yes, it allocates, to those workers, files from non-slave filenodes; or from slaves that are overloaded. The check is done every time a new; file needs to be assigned. Int_t GetActiveWorkers(); Return the number of workers still processing. Float_t GetCurrentRate(Bool_t& all); Get Estimation of the current rate; just summing the current rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TPacketizerAdaptive.html:12588,learn,learnent,12588,root/html530/TPacketizerAdaptive.html,https://root.cern,https://root.cern/root/html530/TPacketizerAdaptive.html,5,['learn'],['learnent']
Usability,"ent. More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:2999,simpl,simple,2999,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['simpl'],['simple']
Usability,"entQuery (TQueryResult *q) override;  Set current query and save previous value. ;  ; void SetDispatchTimer (Bool_t on=kTRUE) override;  Enable/disable the timer to dispatch pening events while processing. ;  ; void SetDrawFeedbackOption (TDrawFeedback *f, Option_t *opt) override;  Set draw feedback option. ;  ; void SetExitStatus (EExitStatus st) override;  ; void SetInitTime () override;  ; void SetMaxDrawQueries (Int_t max) override;  ; void SetMerging (Bool_t=kTRUE) override;  ; void SetOutputFilePath (const char *fp) override;  ; void SetProcessing (Bool_t on=kTRUE);  Set processing bit according to 'on'. ;  ; void SetStopTimer (Bool_t on=kTRUE, Bool_t abort=kFALSE, Int_t timeout=0) override;  Enable/disable the timer to stop/abort processing. ;  ; virtual void StopFeedback ();  Stop feedback (may not be used in this class). ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop the process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback list (may not be used in this class). ;  ; void StoreOutput (TList *out) override;  Store output list (may not be used in this class). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateAutoBin (const char *name, Double_t &xmin, Double_t &xmax, Double_t &ymin, Double_t &ymax, Double_t &zmin, Double_t &zmax) override;  Update automatic binning parameters for given object ""name"". ;  ; void UpdateProgressInfo () override;  Update fProgressStatus. ;  ;  Public Member Functions inherited from TVirtualProofPlayer;  TVirtualProofPlayer ();  ;  ~TVirtualProofPlayer () override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:7721,feedback,feedback,7721,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"entStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTCollection::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTSeqCollection::Changed(); static Int_tTQObject::CheckConnectArgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTList::DeleteLink(TObjLink* lnk); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TObjLink**TList::DoSort(TObjLink** head, Int_t n); TObjLink*TList::FindLink(const TObject* obj, Int_t& idx) const; virtual const char*TCollection::GetCollectionEntryName(TObject* entry) const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; virtual voidTQCommand::Init(const char* cl, void* object, const char* redo, const char* undo); TObjLink*TList::LinkAt(Int_t idx) const; Bool_tTList::LnkCompare(TObjLink* l1, TObjLink* l2); voidTObject::MakeZombie(); virtual TObjLink*TList::NewLink(TObject* obj, TObjLink* prev = NULL); virtual TObjLink*TList::NewOptLink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:15884,undo,undo,15884,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,4,['undo'],['undo']
Usability,"entation. ; . Function Members (Methods); public:. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); virtual~RooObjCacheManager(); Int_tRooCacheManager<RooAbsCacheElement>::cacheSize() const; static TClass*Class(); virtual voidfindConstantNodes(const RooArgSet&, RooArgSet&, RooLinkedList&); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); RooAbsCacheElement*RooCacheManager<RooAbsCacheElement>::getObjByIndex(Int_t index) const; virtual voidinsertObjectHook(RooAbsCacheElement&); virtual TClass*IsA() const; Int_tRooCacheManager<RooAbsCacheElement>::lastIndex() const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet1ByIndex(Int_t index) const; const RooNameSet*RooCacheManager<RooAbsCacheElement>::nameSet2ByIndex(Int_t index) const; RooObjCacheManager&operator=(const RooObjCacheManager&); virtual voidoperModeHook(); virtual voidoptimizeCacheMode(const RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooCacheManager<RooAbsCacheElement>::reset(); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tRooCacheManager<RooAbsCacheElement>::setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidRooCacheManager<RooAbsCacheElement>::sterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooObjCacheManager.html:1058,clear,clearCacheOnServerRedirect,1058,root/html528/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html528/RooObjCacheManager.html,1,['clear'],['clearCacheOnServerRedirect']
Usability,"entation. ◆ AddColumn(). void TRobustEstimator::AddColumn ; (; Double_t * ; col). adds a column to the data matrix it is assumed that the column has size fN variable fVarTemp keeps the number of columns l already added ; Definition at line 171 of file TRobustEstimator.cxx. ◆ AddRow(). void TRobustEstimator::AddRow ; (; Double_t * ; row). adds a vector to the data matrix it is supposed that the vector is of size fNvar ; Definition at line 192 of file TRobustEstimator.cxx. ◆ AddToSscp(). void TRobustEstimator::AddToSscp ; (; TMatrixD & ; sscp, . TVectorD & ; vec . ). protected . update the sscp matrix with vector vec ; Definition at line 779 of file TRobustEstimator.cxx. ◆ Classic(). void TRobustEstimator::Classic ; (; ). protected . called when h=n. ; Returns classic covariance matrix and mean ; Definition at line 809 of file TRobustEstimator.cxx. ◆ ClearSscp(). void TRobustEstimator::ClearSscp ; (; TMatrixD & ; sscp). protected . clear the sscp matrix, used for covariance and mean calculation ; Definition at line 796 of file TRobustEstimator.cxx. ◆ Correl(). void TRobustEstimator::Correl ; (; ). protected . transforms covariance matrix into correlation matrix ; Definition at line 850 of file TRobustEstimator.cxx. ◆ Covar(). void TRobustEstimator::Covar ; (; TMatrixD & ; sscp, . TVectorD & ; m, . TMatrixDSym & ; cov, . TVectorD & ; sd, . Int_t ; nvec . ). protected . calculates mean and covariance ; Definition at line 827 of file TRobustEstimator.cxx. ◆ CreateOrtSubset(). void TRobustEstimator::CreateOrtSubset ; (; TMatrixD & ; dat, . Int_t * ; index, . Int_t ; hmerged, . Int_t ; nmerged, . TMatrixD & ; sscp, . Double_t * ; ndist . ). protected . creates a subset of hmerged vectors with smallest orthogonal distances to the hyperplane hyp[1]*(x1-mean[1])+...+hyp[nvar]*(xnvar-mean[nvar])=0 This function is called in case when less than fH samples lie on a hyperplane. ; Definition at line 968 of file TRobustEstimator.cxx. ◆ CreateSubset(). void TRobustEstimator::CreateSu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:21165,clear,clear,21165,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['clear'],['clear']
Usability,"ented with doxygen comments */; class Undocumented { };; ; /*! Class that is inherited using public inheritance */; class PublicBase : public Truncated { };; ; /*! A template class */; template<class T> class Templ { };; ; /*! Class that is inherited using protected inheritance */; class ProtectedBase { };; ; /*! Class that is inherited using private inheritance */; class PrivateBase { };; ; /*! Class that is used by the Inherited class */; class Used { };; ; /*! Super class that inherits a number of other classes */; class Inherited : public PublicBase,; protected ProtectedBase,; private PrivateBase,; public Undocumented,; public Templ<int>; {; private:; Used *m_usedClass;; };; This will result in the following graph:; This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.The boxes in the above graph have the following meaning: . A filled gray box represents the struct or class for which the graph is generated. . A box with a black border denotes a documented struct or class. . A box with a gray border denotes an undocumented struct or class. . A box with a red border denotes a documented struct or class forwhich not all inheritance/containment relations are shown. A graph is truncated if it does not fit within the specified boundaries. . The arrows have the following meaning: . A blue arrow is used to visualize a public inheritance relation between two classes. . A dark green arrow is used for protected inheritance. . A dark red arrow is used for private inheritance. . A purple dashed arrow is used if a class is contained or used by another class. The arrow is labelled with the variable(s) through which the pointed class or struct is accessible. . A yellow dashed arrow denotes a relation between a template instance and the template class it was instantiated from. The arrow is labelled with the template parameters of the instance. . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:50 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/graph_legend.html:1475,undo,undocumented,1475,doc/master/graph_legend.html,https://root.cern,https://root.cern/doc/master/graph_legend.html,1,['undo'],['undocumented']
Usability,"enter'; 'center' - world position from which dolly/hRotate/vRotate are measured; camera rotates round this, always facing in (in center of viewport); 'hRotate' - horizontal rotation from initial configuration in degrees; 'hRotate' - vertical rotation from initial configuration in degrees. void ReinitializeCurrentCamera(const TGLVector3& hAxis, const TGLVector3& vAxis, Bool_t redraw = kTRUE); Change base-vectors defining the camera-base transformation of current; camera. hAxis and vAxis are the default directions for forward; (inverted) and upwards. TGLAutoRotator* GetAutoRotator(); Get the auto-rotator for this viewer. void SetAutoRotator(TGLAutoRotator* ar); Set the auto-rotator for this viewer. The old rotator is deleted. void GetGuideState(Int_t& axesType, Bool_t& axesDepthTest, Bool_t& referenceOn, Double_t* referencePos) const; Fetch the state of guides (axes & reference markers) into arguments. void SetGuideState(Int_t axesType, Bool_t axesDepthTest, Bool_t referenceOn, const Double_t* referencePos); Set the state of guides (axes & reference markers) from arguments. void SetDrawCameraCenter(Bool_t x); Draw camera look at and rotation point. const TGLPhysicalShape * GetSelected() const; Return selected physical shape. void MouseOver(TGLPhysicalShape* ); Emit MouseOver signal. void MouseOver(TGLPhysicalShape* , UInt_t state); Emit MouseOver signal. void MouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void ReMouseOver(TObject* obj, UInt_t state); Emit MouseOver signal. void UnMouseOver(TObject* obj, UInt_t state); Emit UnMouseOver signal. void Clicked(TObject* obj); Emit Clicked signal. void Clicked(TObject* obj, UInt_t button, UInt_t state); Emit Clicked signal with button id and modifier state. void ReClicked(TObject* obj, UInt_t button, UInt_t state); Emit ReClicked signal with button id and modifier state. void UnClicked(TObject* obj, UInt_t button, UInt_t state); Emit UnClicked signal with button id and modifier state. void MouseIdle(TGLPhysical",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLViewer.html:34095,guid,guides,34095,root/html534/TGLViewer.html,https://root.cern,https://root.cern/root/html534/TGLViewer.html,2,['guid'],['guides']
Usability,"entry widget; TGNumberFormat Class defining namespace for several enums used by TGNumberEntry; TGObject ROOT GUI base class; TGPack Horizontal or vertical stack of frames.; TGPasswdDialog Dialog for entering passwords; TGPicture Pictures and icons used by the GUI classes; TGPictureButton A picture button widget; TGPicturePool Picture and icon cache; TGPopupMenu Popup menu; TGPosition Position object (x and y are Int_t); TGPrintDialog Print dialog used by TGTextEdit widget; TGProgressBar Progress bar abstract base class; TGQt Interface to Qt GUI; TGRadioButton A radio button widget; TGRecorder GUI class of the event recorder.; TGRectMap Rectangle used in TMap; TGRectangle Rectangle object; TGRedirectOutputGuard Exception safe output redirection; TGRegion Describes a region; TGRegionWithId Region with id, tooltip text and popup menu; TGResourcePool Graphics resource pool; TGRowLayout Row layout manager; TGSFile Read a ROOT file from the Google Storage cloud; TGScrollBar Scrollbar widget; TGScrollBarElement Scrollbar element (head, tail, slider); TGSearchDialog Text search dialog used by TGTextEdit widget; TGSearchType ; TGSelectBox TreeView dialog widget; TGSelectedPicture Selected looking picture; TGShapedFrame Shaped composite frame; TGShutter Shutter widget; TGShutterItem Shutter widget item; TGSimpleTable A simple table that owns it's interface.; TGSimpleTableInterface Interface to data in a 2D array of Double_t; TGSlider Slider widget abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ClassIndex.html:85351,simpl,simple,85351,root/html532/ClassIndex.html,https://root.cern,https://root.cern/root/html532/ClassIndex.html,1,['simpl'],['simple']
Usability,"ents TVirtualPad.; Definition at line 163 of file TCanvas.h. ◆ GetXsizeReal(). Size_t TCanvas::GetXsizeReal ; (; ); const. inline . Definition at line 155 of file TCanvas.h. ◆ GetXsizeUser(). Size_t TCanvas::GetXsizeUser ; (; ); const. inline . Definition at line 153 of file TCanvas.h. ◆ GetYsizeReal(). Size_t TCanvas::GetYsizeReal ; (; ); const. inline . Definition at line 156 of file TCanvas.h. ◆ GetYsizeUser(). Size_t TCanvas::GetYsizeUser ; (; ); const. inline . Definition at line 154 of file TCanvas.h. ◆ HandleInput(). void TCanvas::HandleInput ; (; EEventType ; event, . Int_t ; px, . Int_t ; py . ). virtual . Handle Input Events. ; Handle input events, like button up/down in current canvas. ; Definition at line 1232 of file TCanvas.cxx. ◆ HasMenuBar(). Bool_t TCanvas::HasMenuBar ; (; ); const. inline . Definition at line 168 of file TCanvas.h. ◆ HighlightConnect(). void TCanvas::HighlightConnect ; (; const char * ; slot). virtual . This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot. ; Slot has to be defined ""UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)"" all parameters of UserFunction are taken from TCanvas::Highlighted ; Definition at line 1629 of file TCanvas.cxx. ◆ Highlighted(). void TCanvas::Highlighted ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; x, . Int_t ; y . ). virtual . Emit Highlighted() signal. . pad is pointer to pad with highlighted histogram or graph; obj is pointer to highlighted histogram or graph; x is highlighted x bin for 1D histogram or highlighted x-th point for graph; y is highlighted y bin for 2D histogram (for 1D histogram or graph not in use) . Definition at line 1610 of file TCanvas.cxx. ◆ Iconify(). void TCanvas::Iconify ; (; ). Iconify canvas. ; Definition at line 1477 of file TCanvas.cxx. ◆ Init(). void TCanvas::Init ; (; ). protected . Initialize the TCanvas members. Called by all constructors. ; Definition at line 534 of file TCanvas.cxx. ◆ IsA(). TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:78191,simpl,simplification,78191,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['simpl'],['simplification']
Usability,"ents TVirtualPad.; Definition at line 163 of file TCanvas.h. ◆ GetXsizeReal(). Size_t TCanvas::GetXsizeReal ; (; ); const. inline . Definition at line 155 of file TCanvas.h. ◆ GetXsizeUser(). Size_t TCanvas::GetXsizeUser ; (; ); const. inline . Definition at line 153 of file TCanvas.h. ◆ GetYsizeReal(). Size_t TCanvas::GetYsizeReal ; (; ); const. inline . Definition at line 156 of file TCanvas.h. ◆ GetYsizeUser(). Size_t TCanvas::GetYsizeUser ; (; ); const. inline . Definition at line 154 of file TCanvas.h. ◆ HandleInput(). void TCanvas::HandleInput ; (; EEventType ; event, . Int_t ; px, . Int_t ; py . ). virtual . Handle Input Events. ; Handle input events, like button up/down in current canvas. ; Definition at line 1234 of file TCanvas.cxx. ◆ HasMenuBar(). Bool_t TCanvas::HasMenuBar ; (; ); const. inline . Definition at line 168 of file TCanvas.h. ◆ HighlightConnect(). void TCanvas::HighlightConnect ; (; const char * ; slot). virtual . This is ""simplification"" for function TCanvas::Connect with Highlighted signal for specific slot. ; Slot has to be defined ""UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)"" all parameters of UserFunction are taken from TCanvas::Highlighted ; Definition at line 1631 of file TCanvas.cxx. ◆ Highlighted(). void TCanvas::Highlighted ; (; TVirtualPad * ; pad, . TObject * ; obj, . Int_t ; x, . Int_t ; y . ). virtual . Emit Highlighted() signal. . pad is pointer to pad with highlighted histogram or graph; obj is pointer to highlighted histogram or graph; x is highlighted x bin for 1D histogram or highlighted x-th point for graph; y is highlighted y bin for 2D histogram (for 1D histogram or graph not in use) . Definition at line 1612 of file TCanvas.cxx. ◆ Iconify(). void TCanvas::Iconify ; (; ). Iconify canvas. ; Definition at line 1479 of file TCanvas.cxx. ◆ Init(). void TCanvas::Init ; (; ). protected . Initialize the TCanvas members. Called by all constructors. ; Definition at line 537 of file TCanvas.cxx. ◆ IsA(). TClass ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:78567,simpl,simplification,78567,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['simpl'],['simplification']
Usability,"enu-hiding enabled by default. If you dislike this, add the following line to rootrc file (or set corresponding gEnv entry in application initialization): Eve.Viewer.HideMenus: off. Definition at line 30 of file TEveViewer.h. Public Member Functions;  TEveViewer (const char *n=""TEveViewer"", const char *t="""");  Constructor. ;  ;  ~TEveViewer () override;  Destructor. ;  ; virtual void AddScene (TEveScene *scene);  Add 'scene' to the list of scenes. ;  ; TObject * GetEditorObject (const TEveException &eh=""TEveViewer::GetEditorObject "") const override;  Object to be edited when this is selected, returns the TGLViewer. ;  ; TGLViewer * GetGLViewer () const;  ; const TGPicture * GetListTreeIcon (Bool_t open=kFALSE) override;  Return TEveViewer icon. ;  ; Bool_t HandleElementPaste (TEveElement *el) override;  Receive a pasted object. ;  ; TClass * IsA () const override;  ; void PostDock () override;  Virtual function called after a window is docked. ;  ; void PreUndock () override;  Virtual function called before a window is undocked. ;  ; void Redraw (Bool_t resetCameras=kFALSE);  Redraw viewer immediately. ;  ; void RemoveElementLocal (TEveElement *el) override;  Remove element 'el' from the list of children and also remove appropriate GLScene from GLViewer's list of scenes. ;  ; void RemoveElementsLocal () override;  Remove all children, forwarded to GLViewer. ;  ; void SetGLViewer (TGLViewer *viewer, TGFrame *frame);  Set TGLViewer that is represented by this object. ;  ; TGLEmbeddedViewer * SpawnGLEmbeddedViewer (TGedEditor *ged=nullptr, Int_t border=0);  Spawn new GLViewer and adopt it. ;  ; TGLSAViewer * SpawnGLViewer (TGedEditor *ged=nullptr, Bool_t stereo=kFALSE, Bool_t quad_buf=kTRUE);  Spawn new GLViewer and adopt it. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void SwitchStereo ();  Switch stereo mode. ;  ;  Public Member Functions inherited from TEveWindowFrame;  TEveWindowFrame (TGFrame *frame, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveViewer.html:1832,undo,undocked,1832,doc/master/classTEveViewer.html,https://root.cern,https://root.cern/doc/master/classTEveViewer.html,1,['undo'],['undocked']
Usability,"eomData.hxx:244; ROOT::RGeomDescription::SetHighlightedItembool SetHighlightedItem(const std::vector< int > &stack)Definition RGeomData.hxx:405; ROOT::RGeomDescription::SetPreferredOfflinevoid SetPreferredOffline(bool on)Set preference of offline operations.Definition RGeomData.hxx:358; ROOT::RGeomDescription::SelectTopbool SelectTop(const std::vector< std::string > &path)Select top node by path Used by the client to change active node Returns true if selected node was ch...Definition RGeomData.cxx:1946; ROOT::RGeomDescription::GetMaxVisNodesint GetMaxVisNodes() constReturns maximal visible number of nodes, ignored when non-positive.Definition RGeomData.hxx:319; ROOT::RGeomDescription::GetVisLevelint GetVisLevel() constReturns maximal visible level.Definition RGeomData.hxx:329; ROOT::RGeomDescription::GetMaxVisFacesint GetMaxVisFaces() constReturns maximal visible number of faces, ignored when non-positive.Definition RGeomData.hxx:324; ROOT::RGeomDescription::ClearCachevoid ClearCache()Clear cached data, need to be clear when connection broken.Definition RGeomData.cxx:1381; ROOT::RGeomDescription::GetDrawJsonstd::string GetDrawJson() constDefinition RGeomData.hxx:382; ROOT::RGeomDescription::ClearDescriptionvoid ClearDescription()Clear geometry description.Definition RGeomData.cxx:478; ROOT::RGeomDescription::MakeStackByIdsstd::vector< int > MakeStackByIds(const std::vector< int > &ids)Creates stack for given array of ids, first element always should be 0.Definition RGeomData.cxx:1621; ROOT::RGeomDescription::SetMaxVisFacesvoid SetMaxVisFaces(int cnt)Set maximal number of faces which should be selected for drawing.Definition RGeomData.hxx:322; ROOT::RGeomDescription::IsPreferredOfflinebool IsPreferredOffline() constIs offline operations preferred.Definition RGeomData.hxx:361; ROOT::RGeomDescription::fShapesstd::vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::GetSearchstd::string GetSearch() constDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RGeomData_8hxx_source.html:25896,clear,clear,25896,doc/v632/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RGeomData_8hxx_source.html,1,['clear'],['clear']
Usability,"eomData.hxx:244; ROOT::RGeomDescription::SetHighlightedItembool SetHighlightedItem(const std::vector< int > &stack)Definition RGeomData.hxx:407; ROOT::RGeomDescription::SetPreferredOfflinevoid SetPreferredOffline(bool on)Set preference of offline operations.Definition RGeomData.hxx:358; ROOT::RGeomDescription::SelectTopbool SelectTop(const std::vector< std::string > &path)Select top node by path Used by the client to change active node Returns true if selected node was ch...Definition RGeomData.cxx:1946; ROOT::RGeomDescription::GetMaxVisNodesint GetMaxVisNodes() constReturns maximal visible number of nodes, ignored when non-positive.Definition RGeomData.hxx:319; ROOT::RGeomDescription::GetVisLevelint GetVisLevel() constReturns maximal visible level.Definition RGeomData.hxx:329; ROOT::RGeomDescription::GetMaxVisFacesint GetMaxVisFaces() constReturns maximal visible number of faces, ignored when non-positive.Definition RGeomData.hxx:324; ROOT::RGeomDescription::ClearCachevoid ClearCache()Clear cached data, need to be clear when connection broken.Definition RGeomData.cxx:1381; ROOT::RGeomDescription::GetDrawJsonstd::string GetDrawJson() constDefinition RGeomData.hxx:384; ROOT::RGeomDescription::ClearDescriptionvoid ClearDescription()Clear geometry description.Definition RGeomData.cxx:478; ROOT::RGeomDescription::MakeStackByIdsstd::vector< int > MakeStackByIds(const std::vector< int > &ids)Creates stack for given array of ids, first element always should be 0.Definition RGeomData.cxx:1621; ROOT::RGeomDescription::SetMaxVisFacesvoid SetMaxVisFaces(int cnt)Set maximal number of faces which should be selected for drawing.Definition RGeomData.hxx:322; ROOT::RGeomDescription::IsPreferredOfflinebool IsPreferredOffline() constIs offline operations preferred.Definition RGeomData.hxx:361; ROOT::RGeomDescription::fShapesstd::vector< ShapeDescr > fShapes! shapes with created descriptionsDefinition RGeomData.hxx:253; ROOT::RGeomDescription::GetSearchstd::string GetSearch() constDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8hxx_source.html:26147,clear,clear,26147,doc/master/RGeomData_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8hxx_source.html,1,['clear'],['clear']
Usability,"eom_cms.C tutorial. ;  ; file  geom_cms_stereo.C;  Shows CMS geometry in stereo mode. ;  ; file  geom_default.C;  Demonstrates usage of ""Default"" geometry alias. ;  ; file  geom_lhcb.C;  Shows LHCB geometry. ;  ; file  glplot.C;  Preliminary demo for showing Timur's GL plots in EVE. ;  ; file  glplot_geom.C;  Demonstrates how to combine Timur's GL plots with other scene elements. ;  ; file  hierarchical_scene.C;  ; file  histobrowser.C;  Demonstrates how to use EVE as a histogram browser. ;  ; file  jetcone.C;  Demonstrates usage of TEveJetCone class. ;  ; file  lineset.C;  Demonstrates usage of class TEveStraightLineSet. ;  ; file  lineset.C;  Demonstrates usage of class REveStraightLineSet. ;  ; file  MultiView.C;  Multi-view (3d, rphi, rhoz) service class using EVE Window Manager. ;  ; file  overlay_palette.C;  ; file  overlay_test.C;  Demonstrates usage of TEveBox class. ;  ; file  pack.C;  Demonstrates usage of class TGPack. ;  ; file  paramlist.C;  Demonstrates usage of simple configuration via TEveParamList class. ;  ; file  pointset.C;  Demonstrates usage of class TEvePointSet. ;  ; file  projection.C;  Demonstrates usage of automatic 2D projections - class TEveProjectionManager. ;  ; file  projection_prescale.C;  Demonstrates usage pre-scaling for automatic 2D projections. ;  ; file  pythia_display.C;  Demo showing H -> ZZ -> 4 mu generated by Pythia. ;  ; file  quadset.C;  Demonstates usage of 2D digit class TEveQuadSet. ;  ; file  run_alice_esd.C;  Complex example showing ALICE ESD track visualization. ;  ; file  run_alice_esd_split.C;  Complex example showing ALICE ESD visualization in several views. ;  ; file  selection_sigs.C;  Test signals from TEveSelection class. ;  ; file  show_extract.C;  Helper script for showing of extracted / simplified geometries. ;  ; file  SplitGLView.C;  Helper classes for the alice_esd_split.C demo. ;  ; file  text.C;  Demonstrates usage of class TEveText - 2D & 3D text in GL. ;  ; file  track.C;  Demonstrates usage of TEve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__eve.html:3061,simpl,simple,3061,doc/master/group__tutorial__eve.html,https://root.cern,https://root.cern/doc/master/group__tutorial__eve.html,1,['simpl'],['simple']
Usability,"ep ; (; Net_t & ; master, . std::vector< Net_t > & ; nets, . std::vector< TBatch< Architecture_t > > & ; batches . ). inline . Perform multiple optimization steps simultaneously. ; Performs the backprop algorithm on the input batches given in batches on the neural networks given in nets. The forward and backward propagation steps are executed in an interleaving manner in order to exploit potential batch-level parallelism for asynchronous device calls. ; Definition at line 374 of file Minimizers.h. ◆ Step() [2/2]. template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::Step ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). inline . Perform a single optimization step on a given batch. ; Propagates the input matrix forward through the net, evaluates the loss and propagates the gradients backward through the net. The computed gradients are scaled by the learning rate \(\alpha\) and subtracted from the weights and bias values of each layer. ; Definition at line 331 of file Minimizers.h. ◆ StepLoss() [1/2]. template<typename Architecture_t > . template<typename Net_t > . Scalar_t TMVA::DNN::TGradientDescent< Architecture_t >::StepLoss ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ). Same as Step(...) but also evaluate the loss on the given training data. ; Note that this requires synchronization between host and device. . ◆ StepLoss() [2/2]. template<typename Architecture_t > . template<typename Net_t > . auto TMVA::DNN::TGradientDescent< Architecture_t >::StepLoss ; (; Net_t & ; net, . Matrix_t & ; input, . const Matrix_t & ; output, . const Matrix_t & ; weights . ); -> Scalar_t. inline . Definition at line 352 of file Minimizers.h. ◆ StepMomentum(). template<typename Architecture_t > . template<typename Net_t > . void TMVA::DNN::TGradientDescent< Architecture_t >::StepMomentum ; (; Net_t & ; master, . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html:9938,learn,learning,9938,doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TGradientDescent.html,1,['learn'],['learning']
Usability,"epresent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches. An important observation is that volume objects are owned by the TGeoManager class. This stores a list of all volumes in the geometry, that is cleaned upon destruction.; Let's consider positioning now our wire in the middle of a gas chamber. We need first to define the gas chamber :; TGeoVolume *chamber = gGeoManager->MakeTube(""CHAMBER"", ptrGAS, 0, 1, 1);; Now we can put the wire inside :; chamber->AddNode(wire_co, 1);; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; If we inspect now the chamber volume in a browser, we will notice that it has one daughter. Of course the gas has some container also, but let's keep it like that for the sake of simplicity. The full prototype of AddNode() is :; TGeoVolume::AddNode(TGeoVolume *daughter, Int_t usernumber,; TGeoMatrix *matrix=gGeoIdentity); gGeoIdentityR__EXTERN TGeoIdentity * gGeoIdentityDefinition TGeoMatrix.h:537; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; int; Since we did not supplied the third argument, the wire will be positioned with an identity transformation inside the chamber. One will notice that the inner radii of the wire and chamber are both zero - therefore, aren't the two volumes overlapping ? The answer is no, the modeler is even relaying on the fact that any daughter is fully contained by its mother. On the other hand, neither of the nodes positioned inside a volume should overlap with each other. We will see that there are allowed some exceptions to those rules. Overlapping volumes; Positioning volumes that does not overlap their neighbours nor extrude their container is sometimes quite strong",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:6629,simpl,simplicity,6629,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['simpl'],['simplicity']
Usability,"er class ;  CTDeviceTDevice ;  CTDLGradientDescent;  CTGradientDescent;  CTLayerGeneric layer class ;  CTNetGeneric neural network class ;  CTReferenceThe reference architecture class ;  CTReshapeLayer;  CTRMSPropRMSProp Optimizer class ;  CTSGDStochastic Batch Gradient Descent Optimizer class ;  CTSharedLayerLayer class width shared weight and bias layers ;  CTTensorBatchTTensorBatch ;  CTTensorBatchIteratorTTensorBatchIterator ;  CTTensorDataLoaderTTensorDataLoader ;  CTTensorDataLoader< AData, TReference< AReal > >;  CVGeneralLayerGeneric General Layer class ;  CVOptimizerGeneric Optimizer class ;  ►NExperimental;  CClassification;  CClassificationResult;  ►NkNN;  CEvent;  CModulekNN;  CNodeThis file contains binary tree and global function template that searches tree for k-nearest neigbors ;  CAbsoluteDeviationLossFunctionAbsolute Deviation Loss Function ;  CAbsoluteDeviationLossFunctionBDTAbsolute Deviation BDT Loss Function ;  CAbsValue;  CBDTEventWrapper;  CBinarySearchTreeA simple Binary search tree including a volume search method ;  CBinarySearchTreeNodeNode for the BinarySearch or Decision Trees ;  CBinaryTreeBase class for BinarySearch and Decision Trees ;  CCCPrunerA helper class to prune a decision tree using the Cost Complexity method (see Classification and Regression Trees by Leo Breiman et al) ;  ►CCCTreeWrapper;  CCCTreeNode;  CClassifierFactoryThis is the MVA factory ;  CClassInfoClass that contains all the information of a class ;  Ccompose_binary_t;  Ccompose_unary_t;  ►CConfigSingleton class for global configuration settings used by TMVA ;  CIONames;  CVariablePlotting;  CConfigurable;  CConvergenceTestCheck for convergence ;  CCostComplexityPruneToolA class to prune a decision tree using the Cost Complexity method ;  CCrossEntropyImplementation of the CrossEntropy as separation criterion ;  CCrossValidationClass to perform cross validation, splitting the dataloader into folds ;  CCrossValidationFoldResult;  CCrossValidationResultClass to save ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:82827,simpl,simple,82827,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['simpl'],['simple']
Usability,"er collection have a size of one, the arguments are always synchronized without checking if they have the same name. . Definition at line 305 of file RooAbsCollection.cxx. ◆ begin(). const_iterator RooAbsCollection::begin ; (; ); const. inline . Definition at line 253 of file RooAbsCollection.h. ◆ canBeAdded(). virtual bool RooAbsCollection::canBeAdded ; (; const RooAbsArg & ; arg, . bool ; silent . ); const. protectedpure virtual . Determine whether it's possible to add a given RooAbsArg to the collection or not. ; Implemented in RooArgSet, and RooArgList. ◆ Class(). static TClass * RooAbsCollection::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCollection::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCollection::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 432 of file RooAbsCollection.h. ◆ clear(). void RooAbsCollection::clear ; (; ). inline . Clear contents. If the collection is owning, it will also delete the contents. ; Definition at line 282 of file RooAbsCollection.h. ◆ clearStructureTags(). void RooAbsCollection::clearStructureTags ; (; ). inlineprotected . Definition at line 392 of file RooAbsCollection.h. ◆ clone(). virtual TObject * RooAbsCollection::clone ; (; const char * ; newname); const. pure virtual . Implemented in RooArgList, and RooArgSet. ◆ Clone(). TObject * RooAbsCollection::Clone ; (; const char * ; newname = nullptr); const. inlineoverridevirtual . Make a clone of an object using the Streamer facility. ; If the object derives from TNamed, this function is called by TNamed::Clone. TNamed::Clone uses the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:35974,clear,clear,35974,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clear']
Usability,"er of bytes in the object name. … -> …; | Name; | lName bytes with the name of the object. … -> …; | lTitle; | Number of bytes in the object title. … -> …; | Title; | Title of the object. … -> …; | DATA; | Data bytes associated to the object. You see a reference to TKey. It is explained in detail in the next section.; 11.1.4 The Class Description List (StreamerInfo List); The histogram records are followed by the StreamerInfo list of class descriptions. The list contains the description of each class that has been written to file.; 20010404/092347 At:5854 N=2390 StreamerInfo CX = 3.41; The class description is recursive, because to fully describe a class, its ancestors and object data members have to be described also. In demo.root, the class description list contains the description for:. TH1F; all classes in the TH1F inheritance tree; all classes of the object data members; all classes in the object data members’ inheritance tree. This description is implemented by the TStreamerInfo class, and is often referred to as simply StreamerInfo. You can print a file’s StreamerInfolist with the TFile::ShowStreamerInfo method. Below is an example of the output. Only the first line of each class description is shown. The demo.root example contains only TH1F objects. Here we see the recursive nature of the class description; it contains the StreamerInfoof all the classes needed to describe TH1F.; root[] f.ShowStreamerInfo(); StreamerInfo for class: TH1F, version=1; BASE TH1 offset=0 type= 0 1-Dim histogram base class; BASE TArrayF offset=0 type= 0 Array of floats. StreamerInfo for class: TH1, version=3; BASE TNamed offset=0 type=67 The basis for named object(name,title); BASE TAttLine offset=0 type=0 Line attributes; BASE TAttFill offset=0 type=0 Fill area attributes; BASE TAttMarker offset=0 type=0 Marker attributes; Int_t fNcells offset=0 type=3 number bins(1D),cells(2D)+U/Overflows; TAxis fXaxis offset=0 type=61 X axis descriptor; TAxis fYaxis offset=0 type=61 Y axis descri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:436607,simpl,simply,436607,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"er offers many options to paint 1D, 2D and 3D histograms.; When the Draw() method of a histogram is called for the first time (TH1::Draw), it creates a THistPainter object and saves a pointer to this ""painter"" as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. Each histogram having its own painter (rather than a central singleton painter painting all histograms), allows two histograms to be drawn in two threads without overwriting the painter's values.; When a displayed histogram is filled again, there is no need to call the Draw() method again; the image will be refreshed the next time the pad will be updated.; A pad is updated after one of these three actions:. a carriage control on the ROOT command line,; a click inside the pad,; a call to TPad::Update. By default a call to TH1::Draw() clears the pad of all objects before drawing the new image of the histogram. One can use the SAME option to leave the previous display intact and superimpose the new histogram. The same histogram can be drawn with different graphics options in different pads.; When a displayed histogram is deleted, its image is automatically removed from the pad.; To create a copy of the histogram when drawing it, one can use TH1::DrawClone(). This will clone the histogram and allow to change and delete the original one without affecting the clone. Histograms' plotting options; Most options can be concatenated with or without spaces or commas, for example: h->Draw(""E1 SAME"");; The options are not case sensitive: h->Draw(""e1 same"");; The default drawing option can be set with TH1::SetOption and retrieve using TH1::GetOption: root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; root [1] h->Draw(""E""); // Draw ""h"" using error bars; root [3] h->SetOption(""E""); // Change the default drawing option for ""h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:3934,clear,clears,3934,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['clear'],['clears']
Usability,"er one can browse all ROOT objects.Definition TBrowser.h:37; TTask<div class=""legacybox""><h2>Legacy Code</h2> TTask is a legacy interface: there will be no bug fixes n...Definition TTask.h:35; TTask::TTaskTTask()Default constructor invoked when reading a TTask object from a file.Definition TTask.cxx:98; TTask::Addvirtual void Add(TTask *task)Add TTask to this.Definition TTask.cxx:176; . Definition at line 35 of file TTask.h. Public Member Functions;  TTask ();  Default constructor invoked when reading a TTask object from a file. ;  ;  TTask (const char *name, const char *title);  Standard constructor. ;  ;  TTask (const TTask &task);  Copy constructor. ;  ; virtual ~TTask ();  Delete a task and its subtasks. ;  ; virtual void Abort ();  Abort current tree of tasks. ;  ; virtual void Add (TTask *task);  Add TTask to this. ;  ; void Browse (TBrowser *b) override;  Browse the list of tasks. ;  ; virtual void CleanTasks ();  Reset tasks state: breakpoints and execute flags also invokes the Clear function of each task to clear all data structures created by a previous execution of a task. ;  ; void Clear (Option_t *option="""") override;  Recursively call the Clear function of this task and its subtasks. ;  ; virtual void Continue ();  Resume execution at the current break point. ;  ; virtual void Exec (Option_t *option);  Dummy Execute. ;  ; virtual void ExecuteTask (Option_t *option=""0"");  Execute main task and its subtasks. ;  ; virtual void ExecuteTasks (Option_t *option);  Execute all the subtasks of a task. ;  ; Int_t GetBreakin () const;  ; Int_t GetBreakout () const;  ; TList * GetListOfTasks () const;  ; TClass * IsA () const override;  ; Bool_t IsActive () const;  ; Bool_t IsFolder () const override;  Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ;  ; void ls (Option_t *option=""*"") const override;  List the tree of tasks. ;  ; TTask & operator= (const TTask &tt);  Assignment operator. ;  ; void SetActive (Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTask.html:4338,clear,clear,4338,doc/master/classTTask.html,https://root.cern,https://root.cern/doc/master/classTTask.html,1,['clear'],['clear']
Usability,"er redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedirect = flag ; }. » Last changed: Sat Jun 20 16:42:31 2015 » Last generated: 2015-06-20 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:5809,clear,clearOnRedirect,5809,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,2,['clear'],"['clearObsList', 'clearOnRedirect']"
Usability,"er redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedirect = flag ; }. » Last changed: Sat Jun 20 17:30:22 2015 » Last generated: 2015-06-20 17:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooObjCacheManager.html:5820,clear,clearOnRedirect,5820,root/html604/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html604/RooObjCacheManager.html,2,['clear'],"['clearObsList', 'clearOnRedirect']"
Usability,"er redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedirect = flag ; }. » Last changed: Tue Jun 30 14:34:43 2015 » Last generated: 2015-06-30 14:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:5820,clear,clearOnRedirect,5820,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,2,['clear'],"['clearObsList', 'clearOnRedirect']"
Usability,"er to array of redo arguments. ; Definition at line 752 of file TQCommand.cxx. ◆ GetRedoName(). const char * TQCommand::GetRedoName ; (; ); const. Returns the name of redo command. ; Definition at line 736 of file TQCommand.cxx. ◆ GetStatus(). Int_t TQCommand::GetStatus ; (; ); const. Returns a number of sequential undo or redo operations. ; Definition at line 792 of file TQCommand.cxx. ◆ GetTitle(). const char * TQCommand::GetTitle ; (; ); const. overridevirtual . Returns command description. ; By default, ""ClassName::RedoName(args)_ClassName::UndoName(args)"" ; Reimplemented from TObject.; Definition at line 713 of file TQCommand.cxx. ◆ GetUndo(). TQConnection * TQCommand::GetUndo ; (; ); const. inline . Definition at line 76 of file TQCommand.h. ◆ GetUndoArgs(). Long_t * TQCommand::GetUndoArgs ; (; ); const. Returns a pointer to array of undo arguments. ; Definition at line 760 of file TQCommand.cxx. ◆ GetUndoName(). const char * TQCommand::GetUndoName ; (; ); const. Returns the name of undo command. ; Definition at line 744 of file TQCommand.cxx. ◆ Init(). void TQCommand::Init ; (; const char * ; cl, . void * ; object, . const char * ; redo, . const char * ; undo . ). protectedvirtual . Common protected method used in several constructors. ; Definition at line 120 of file TQCommand.cxx. ◆ IsA(). TClass * TQCommand::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TList.; Reimplemented in TQUndoManager.; Definition at line 98 of file TQCommand.h. ◆ IsEqual(). Bool_t TQCommand::IsEqual ; (; const TObject * ; obj); const. overridevirtual . Equal comparison. ; The commands are equal if they are applied to the same object and have the same Redo/Undo actions; More complicated commands might want to override this function. ; Reimplemented from TObject.; Definition at line 418 of file TQCommand.cxx. ◆ IsExecuting(). Bool_t TQCommand::IsExecuting ; (; ); const. Returns kTRUE if command execution is in progress. ; Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:39213,undo,undo,39213,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"er(const char* par, const char* value); Set input list parameter. If the parameter is already; set it will be set to the new value. void SetParameter(const char* par, Int_t value); Set an input list parameter. void SetParameter(const char* par, Long_t value); Set an input list parameter. void SetParameter(const char* par, Long64_t value); Set an input list parameter. void SetParameter(const char* par, Double_t value); Set an input list parameter. TObject * GetParameter(const char* par) const; Get specified parameter. A parameter set via SetParameter() is either; a TParameter or a TNamed or 0 in case par is not defined. void DeleteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:74571,feedback,feedback,74571,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['feedback'],['feedback']
Usability,"er, using ROOT geometry class. ;  ; file  na49.C;  This file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  ; file  na49geomfile.C;  Before executing this macro, the file makegeometry.C must have been executed. ;  ; file  na49view.C;  This macro generates with 2 views of the NA49 detector using the old obsolete geometry package. ;  ; file  parallel_world.C;  Misaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated. ;  ; file  RadioNuclides.C;  Macro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package. ;  ; file  robot.C;  Drawing a famous Korean robot, TaekwonV, using ROOT geometry class. ;  ; file  rootgeom.C;  Definition of a simple geometry (the 4 ROOT characters) ;  ; file  runplugin.C;  Creates and runs a simple iterator plugin connected to TGeoPainter iterator. ;  ; file  shapes.C;  The old geometry shapes (see script geodemo.C) ;  ; file  shapesAnim.C;  Macro illustrating how to animate a geometry picture using a Timer. ;  ; file  south_gate.C;  Drawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class. ;  ; file  station1.C;  Drawing a space station, using ROOT geometry class. ;  ; file  station2.C;  Drawing a space station (version 2), using ROOT geometry class. ;  ; file  tank.C;  Drawing a fine tank, using ROOT geometry class. ;  ; file  tessellatedNav.C;  Macro allowing to vizualize tessellations from Wavefront's .obj format. ;  ; file  testoptical.C;  Tests importing/exporting optical surfaces from GDML. ;  ; file  visualizeWavefrontObj.C;  Macro allowing to vizualize tessellations from Wavefront's .obj format. ;  ; file  xtruDraw.C;  Draw a ""representative"" TXTRU shape. ;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__geom.html:2148,simpl,simple,2148,doc/master/group__tutorial__geom.html,https://root.cern,https://root.cern/doc/master/group__tutorial__geom.html,1,['simpl'],['simple']
Usability,"er. ; Definition at line 45 of file Adam.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdam (DeepNet_t &deepNet, Scalar_t learningRate=0.001, Scalar_t beta1=0.9, Scalar_t beta2=0.999, Scalar_t epsilon=1e-7);  Constructor. ;  ;  ~TAdam ()=default;  Destructor. ;  ; Scalar_t GetBeta1 () const;  Getters. ;  ; Scalar_t GetBeta2 () const;  ; Scalar_t GetEpsilon () const;  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentBiases ();  ; std::vector< Matrix_t > & GetFirstMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetFirstMomentWeights ();  ; std::vector< Matrix_t > & GetFirstMomentWeightsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentBiases ();  ; std::vector< Matrix_t > & GetSecondMomentBiasesAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetSecondMomentWeights ();  ; std::vector< Matrix_t > & GetSecondMomentWeightsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Step ();  Performs one step of optimization. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html:2001,learn,learningRate,2001,doc/master/classTMVA_1_1DNN_1_1TAdam.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdam.html,1,['learn'],['learningRate']
Usability,"er. In addition, it provides the; possibilities for compiling, executing or interrupting a running; macro. This class can be used in following ways:; - with file name as argument:; new TGTextEditor(""hsimple.C"");; - with a TMacro* as argument:; TMacro *macro = new TMacro(""hsimple.C"");; new TGTextEditor(macro);. Basic Features:. New Document. To create a new blank document, select File menu / New, or click; the New toolbar button. It will create a new instance of; TGTextEditor. Open/Save File. To open a file, select File menu / Open or click on the Open; toolbar button. This will bring up the standard File Dialog for; opening files.; If the current document has not been saved yet, you will be asked; either to save or abandon the changes.; To save the file using the same name, select File menu / Save or; the toolbar Save button. To change the file name use File menu /; Save As... or corresponding SaveAs button on the toolbar. Text Selection. You can move the cursor by simply clicking on the desired location; with the left mouse button. To highlight some text, press the mouse; and drag the mouse while holding the left button pressed.; To select a word, double-click on it;; to select the text line - triple-click on it;; to select all do quadruple-click. Cut, Copy, Paste. After selecting some text, you can cut or copy it to the clipboard.; A subsequent paste operation will insert the contents of the; clipboard at the current cursor location. Text Search. The editor uses a standard Search dialog. You can specify a forward; or backward search direction starting from the current cursor; location according to the selection made of a case sensitive mode; or not. The last search can be repeated by pressing F3. Text Font. You can change the text font by selecting Edit menu / Set Font.; The Font Dialog pops up and shows the Name, Style, and Size of any; available font. The selected font sample is shown in the preview; area. Executing Macros. You can execute the currently loaded m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTextEditor.html:1447,simpl,simply,1447,root/html528/TGTextEditor.html,https://root.cern,https://root.cern/root/html528/TGTextEditor.html,6,['simpl'],['simply']
Usability,"er.h. ◆ Process() [3/4]. Long64_t TProofPlayerLocal::Process ; (; TDSet * ; set, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; firstentry = 0 . ). inlineoverridevirtual . Process specified TDSet on PROOF worker with TSelector object The return value is -1 in case of error and TSelector::GetStatus() in case of success. ; Reimplemented from TProofPlayer.; Definition at line 254 of file TProofPlayer.h. ◆ Process() [4/4]. Long64_t TProofPlayerLocal::Process ; (; TSelector * ; selector, . Long64_t ; nentries = -1, . Option_t * ; option = """" . ). Process the specified TSelector object 'nentries' times. ; Used to test the PROOF interator mechanism for cycle-driven selectors in a local session. The return value is -1 in case of error and TSelector::GetStatus() in case of success. ; Definition at line 1852 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerLocal::SetupFeedback ; (; ). inlineoverrideprotectedvirtual . Set up feedback (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 240 of file TProofPlayer.h. ◆ StopFeedback(). void TProofPlayerLocal::StopFeedback ; (; ). inlineoverrideprotectedvirtual . Stop feedback (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 241 of file TProofPlayer.h. ◆ Streamer(). void TProofPlayerLocal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer. ◆ StreamerNVirtual(). void TProofPlayerLocal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 258 of file TProofPlayer.h. Member Data Documentation. ◆ fIsClient. Bool_t TProofPlayerLocal::fIsClient. private . Definition at line 237 of file TProofPlayer.h. proof/proofplayer/inc/TProofPlayer.h; proof/proofplayer/src/TProofPlayer.cxx. TProofPlayerLocal. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:27469,feedback,feedback,27469,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,2,['feedback'],['feedback']
Usability,"er::fToltolerance (absolute); doubleROOT::Math::Minimizer::fUperror scale ; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized ; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html:5507,clear,clear,5507,root/html528/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html,3,['clear'],['clear']
Usability,"erCopy(seedloader, loader);; 2398 ; 2399 // Booking Seed; 2400 BookMethod(seedloader, theMethod, methodTitle, theOption);; 2401 ; 2402 // Train/Test/Evaluation; 2403 TrainAllMethods();; 2404 TestAllMethods();; 2405 EvaluateAllMethods();; 2406 ; 2407 // getting ROC; 2408 SROC = GetROCIntegral(xbitset.to_string(), methodTitle);; 2409 ; 2410 // cleaning information to process sub-seeds; 2411 TMVA::MethodBase *smethod = dynamic_cast<TMVA::MethodBase *>(fMethodsMap[xbitset.to_string().c_str()][0][0]);; 2412 TMVA::ResultsClassification *sresults = (TMVA::ResultsClassification *)smethod->Data()->GetResults(; 2413 smethod->GetMethodName(), Types::kTesting, Types::kClassification);; 2414 delete sresults;; 2415 delete seedloader;; 2416 this->DeleteAllMethods();; 2417 fMethodsMap.clear();; 2418 ; 2419 // removing global result because it is requiring a lot of RAM for all seeds; 2420 ; 2421 for (uint32_t i = 0; i < VIBITS; ++i) {; 2422 if (x & (1 << i)) {; 2423 y = x & ~(uint64_t(1) << i);; 2424 std::bitset<VIBITS> ybitset(y);; 2425 // need at least one variable; 2426 // NOTE: if sub-seed is zero then is the special case; 2427 // that count in xbitset is 1; 2428 uint32_t ny = static_cast<uint32_t>(log(x - y) / 0.693147);; 2429 if (y == 0) {; 2430 importances[ny] = SROC - 0.5;; 2431 continue;; 2432 }; 2433 ; 2434 // creating loader for sub-seed; 2435 TMVA::DataLoader *subseedloader = new TMVA::DataLoader(ybitset.to_string());; 2436 // adding variables from sub-seed; 2437 for (int index = 0; index < nbits; index++) {; 2438 if (ybitset[index]); 2439 subseedloader->AddVariable(varNames[index], 'F');; 2440 }; 2441 ; 2442 // Loading Dataset; 2443 DataLoaderCopy(subseedloader, loader);; 2444 ; 2445 // Booking SubSeed; 2446 BookMethod(subseedloader, theMethod, methodTitle, theOption);; 2447 ; 2448 // Train/Test/Evaluation; 2449 TrainAllMethods();; 2450 TestAllMethods();; 2451 EvaluateAllMethods();; 2452 ; 2453 // getting ROC; 2454 SSROC = GetROCIntegral(ybitset.to_string(), methodTitle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:100782,clear,clear,100782,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['clear'],['clear']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategoryLValue.html:2282,clear,clearValueDirty,2282,root/html528/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html528/RooAbsCategoryLValue.html,2,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; Roo1DTable*createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:2213,clear,clearValueDirty,2213,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,2,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:2041,clear,clearValueDirty,2041,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,2,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBinningCategory.html:2052,clear,clearValueDirty,2052,root/html528/RooBinningCategory.html,https://root.cern,https://root.cern/root/html528/RooBinningCategory.html,10,['clear'],['clearValueDirty']
Usability,"erList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsString::createFundamental(const char* newname = 0) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsArg::dependentOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStringVar.html:1936,clear,clearValueDirty,1936,root/html528/RooStringVar.html,https://root.cern,https://root.cern/root/html528/RooStringVar.html,2,['clear'],['clearValueDirty']
Usability,"erMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel threads, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. Mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v626/namespaceROOT.html:3041,simpl,simple,3041,doc/v626/namespaceROOT.html,https://root.cern,https://root.cern/doc/v626/namespaceROOT.html,1,['simpl'],['simple']
Usability,"erNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters as a C++ statement(s) on output stream out. ;  ; void SetBarColor (const char *color=""blue"");  Set progress bar color. ;  ; virtual void SetBarColor (Pixel_t color);  Set progress bar color. ;  ; void SetBarType (EBarType type);  Set bar type. ;  ; void SetFillType (EFillType type);  Set fill type. ;  ; void SetForegroundColor (Pixel_t pixel) override;  Change text color drawing. ;  ; void SetMax (Float_t max);  ; void SetMin (Float_t min);  ; void SetPosition (Float_t pos);  Set progress position between [min,max]. ;  ; void SetRange (Float_t min, Float_t max);  Set min and max of progress bar. ;  ; virtual void ShowPos (Bool_t on);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Bool_t UsePercent () const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:2591,progress bar,progress bar,2591,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"eractive painting ;  ; Long64_t fCanvVersion {1};  ! actual canvas version, changed with every new Modified() call ;  ; UInt_t fClientBits {0};  ! latest status bits from client like editor visible or not ;  ; UInt_t fColorsHash {0};  ! last hash of colors/palette ;  ; Long64_t fColorsVersion {0};  ! current colors/palette version, checked every time when new snapshot created ;  ; Bool_t fFixedSize {kFALSE};  ! is canvas size fixed ;  ; std::vector< std::unique_ptr< ROOT::RWebDisplayHandle > > fHelpHandles;  ! array of handles for help widgets ;  ; Int_t fJsonComp {0};  ! compression factor for messages send to the client ;  ; Bool_t fLongerPolling {kFALSE};  ! when true, make longer polling in blocking operations ;  ; ObjectSelectSignal_t fObjSelectSignal;  ! signal emitted when new object selected in the pad ;  ; PadClickedSignal_t fPadClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; PadClickedSignal_t fPadDblClickedSignal;  ! signal emitted when simple mouse click performed on the pad ;  ; std::map< TPad *, PadStatus > fPadsStatus;  ! map of pads in canvas and their status flags ;  ; Int_t fPaletteDelivery {1};  ! colors palette delivery 0:never, 1:once, 2:always, 3:per subpad ;  ; Int_t fPrimitivesMerge {100};  ! number of PS primitives, which will be merged together ;  ; Bool_t fProcessingData {kFALSE};  ! flag used to prevent blocking methods when process data is invoked ;  ; Bool_t fReadOnly {kFALSE};  !< configured display ;  ; Int_t fStyleDelivery {0};  ! gStyle delivery to clients: 0:never, 1:once, 2:always ;  ; UInt_t fStyleHash {0};  ! last hash of gStyle ;  ; Long64_t fStyleVersion {0};  ! current gStyle object version, checked every time when new snapshot created ;  ; Int_t fTF1UseSave {1};  ! use save buffer for TF1/TF2, 0:off, 1:prefer, 2:force ;  ; TWebCanvasTimer * fTimer {nullptr};  ! timer to submit control messages ;  ; UpdatedSignal_t fUpdatedSignal;  ! signal emitted when canvas updated or state is changed ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:14963,simpl,simple,14963,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,1,['simpl'],['simple']
Usability,"erations. They take as input argument the name of a column of the dataset to watch for missing values. Like Filter, they will either keep or discard an entire entry based on whether a condition returns true or false. Specifically:. FilterAvailable: the condition is whether the value of the column is present. If so, the entry is kept. Otherwise if the value is missing the entry is discarded.; FilterMissing: the condition is whether the value of the column is missing. If so, the entry is kept. Otherwise if the value is present the entry is discarded. df = ROOT.RDataFrame(dataset); ; # Anytime an entry from ""col"" is missing, the entire entry will be filtered out; df_available = df.FilterAvailable(""col""); df_available = df_available.Define(""twice"", ""col * 2""); ; # Conversely, if we want to select the entries for which the column has missing; # values, we do the following; df_missingcol = df.FilterMissing(""col""); # Following operations in the same branch of the computation graph clearly; # cannot access that same column, since there would be no value to read; df_missingcol = df_missingcol.Define(""observable"", ""othercolumn * 2""); ROOT::RDataFrame df{dataset};; ; // Anytime an entry from ""col"" is missing, the entire entry will be filtered out; auto df_available = df.FilterAvailable(""col"");; auto df_twicecol = df_available.Define(""twice"", ""col * 2"");; ; // Conversely, if we want to select the entries for which the column has missing; // values, we do the following; auto df_missingcol = df.FilterMissing(""col"");; // Following operations in the same branch of the computation graph clearly; // cannot access that same column, since there would be no value to read; auto df_observable = df_missingcol.Define(""observable"", ""othercolumn * 2"");; DefaultValueFor; DefaultValueFor creates a node of the computation graph which just forwards the values of the columns necessary for other downstream nodes, when they are available. In case a value of the input column passed to this function is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:83121,clear,clearly,83121,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['clear'],['clearly']
Usability,"erator_type. typedef container_type::iterator TMVA::DNN::Net::iterator_type. Definition at line 1066 of file NeuralNet.h. Constructor & Destructor Documentation. ◆ Net() [1/2]. TMVA::DNN::Net::Net ; (; ). inline . c'tor ; Definition at line 1074 of file NeuralNet.h. ◆ Net() [2/2]. TMVA::DNN::Net::Net ; (; const Net & ; other). inline . d'tor ; Definition at line 1085 of file NeuralNet.h. Member Function Documentation. ◆ addLayer() [1/2]. void TMVA::DNN::Net::addLayer ; (; Layer && ; layer). inline . Definition at line 1095 of file NeuralNet.h. ◆ addLayer() [2/2]. void TMVA::DNN::Net::addLayer ; (; Layer & ; layer). inline . add a layer (layout) ; Definition at line 1094 of file NeuralNet.h. ◆ backPropagate(). template<typename Settings > . void TMVA::DNN::Net::backPropagate ; (; std::vector< std::vector< LayerData > > & ; layerPatternData, . const Settings & ; settings, . size_t ; trainFromLayer, . size_t ; totalNumWeights . ); const. Definition at line 1355 of file NeuralNet.icc. ◆ clear(). void TMVA::DNN::Net::clear ; (; ). inline . Definition at line 1251 of file NeuralNet.h. ◆ compute(). template<typename Weights > . std::vector< double > TMVA::DNN::Net::compute ; (; const std::vector< double > & ; input, . const Weights & ; weights . ); const. compute the net with the given input and the given weights ; compute the neural net; Parameters. inputthe input data ; weightsthe weight data . Definition at line 1037 of file NeuralNet.icc. ◆ computeError(). template<typename ItWeight > . std::tuple< double, double > TMVA::DNN::Net::computeError ; (; const Settings & ; settings, . std::vector< LayerData > & ; lastLayerData, . Batch & ; batch, . ItWeight ; itWeightBegin, . ItWeight ; itWeightEnd . ); const. Definition at line 1321 of file NeuralNet.icc. ◆ dE(). void TMVA::DNN::Net::dE ; (; ). ◆ dropOutWeightFactor(). template<typename WeightsType , typename DropProbabilities > . void TMVA::DNN::Net::dropOutWeightFactor ; (; WeightsType & ; weights, . const DropProbabilitie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html:8247,clear,clear,8247,doc/master/classTMVA_1_1DNN_1_1Net.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Net.html,1,['clear'],['clear']
Usability,"erbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4756,clear,clearValueAndShapeDirty,4756,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,2,['clear'],['clearValueAndShapeDirty']
Usability,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial mo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:960,learn,learning,960,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['learn'],['learning']
Usability,"erceptron. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MLP; » TMultiLayerPerceptron. class TMultiLayerPerceptron: public TObject. TMultiLayerPerceptron. This class describes a neural network.; There are facilities to train the network and use the output. The input layer is made of inactive neurons (returning the; optionaly normalized input) and output neurons are linear.; The type of hidden neurons is free, the default being sigmoids.; (One should still try to pass normalized inputs, e.g. between [0.,1]). The basic input is a TTree and two (training and test) TEventLists.; Input and output neurons are assigned a value computed for each event; with the same possibilities as for TTree::Draw().; Events may be weighted individualy or via TTree::SetWeight().; 6 learning methods are available: kStochastic, kBatch,; kSteepestDescent, kRibierePolak, kFletcherReeves and kBFGS. This implementation, written by C. Delaere, is *inspired* from; the mlpfit package from J.Schwindling et al. with some extensions:; * the algorithms are globally the same; * in TMultilayerPerceptron, there is no limitation on the number of; layers/neurons, while MLPFIT was limited to 2 hidden layers; * TMultilayerPerceptron allows you to save the network in a root file, and; provides more export functionalities; * TMultilayerPerceptron gives more flexibility regarding the normalization of; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial mov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:960,learn,learning,960,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['learn'],['learning']
Usability,ered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_RNN_Classification.py;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_SOFIE_Inference.py;   This macro provides an example of using a trained model with Keras and make inference using SOFIE directly from Numpy This macro uses as input a Keras model generated with the TMVA_Higgs_Classification.C tutorial You need to run that macro before this one. ;  ; file  TMVA_SOFIE_Keras.C;   This macro provides a simple example for the parsing of Keras .h5 file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_Keras_HiggsModel.C;   This macro run the SOFIE parser on the Keras model obtaining running TMVA_Higgs_Classification.C You need to run that macro before this one ;  ; file  TMVA_SOFIE_Models.py;   Example of inference with SOFIE using a set of models trained with Keras. ;  ; file  TMVA_SOFIE_ONNX.C;   This macro provides a simple example for the parsing of ONNX files into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_PyTorch.C;   This macro provides a simple example for the parsing of PyTorch .pt file into RModel object and further generating the .hxx header files for inference. ;  ; file  TMVA_SOFIE_RDataFrame.C;   This macro provides an example of using a trained model with Keras and make inference using SOFIE and RDataFrame This macro uses as input a Keras model generated with the TMVA_Higgs_C,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:3122,simpl,simple,3122,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,"erence Guide, “How To’s”, a list of publications and example applications.; 1.7.1 Class Reference Guide; The top of any class reference page lets you jump to different parts of the documentation. The first line links to the class index and the index for the current module (a group of classes, often a library). The second line links to the ROOT homepage and the class overviews. The third line links the source information - a HTML version of the source and header file as well as the CVS (the source management system used for the ROOT development) information of the files. The last line links the different parts of the current pages. Example of function documentation, with automatically generated LaTeX-like graphics. Inheritance tree, showing what the current class derives from, and which classes inherit from it. HTML version of the source file linking all types and most functions. 2 Getting Started; We begin by showing you how to use ROOT interactively. There are two examples to click through and learn how to use the GUI. We continue by using the command line, and explaining the coding conventions, global variables and the environment setup. If you have not installed ROOT, you can do so by following the instructions in the appendix, or on the ROOT web site: http://root.cern.ch/root/Availability.html; 2.1 Setting the Environment Variables; Before you can run ROOT you need to set the environment variable ROOTSYS and change your path to include root/bin and library path variables to include root/lib. Please note: the syntax is for bash, if you are running tcsh you will have to use setenv instead of export. Define the variable $ROOTSYS to the directory where you unpacked the ROOT:. $ export ROOTSYS=$HOME/root. Add ROOTSYS/bin to your PATH:. $ export PATH=$PATH:$ROOTSYS/bin. Setting the Library Path. On HP-UX, before executing the interactive module, you must set the library path:; $ export SHLIB_PATH=$SHLIB_PATH:$ROOTSYS/lib; On AIX, before executing the interactive modul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:30196,learn,learn,30196,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['learn'],['learn']
Usability,"ergeOutput' limiting the memory; consumption. void NotifyMemory(TObject* obj); Printout the memory record after merging object 'obj'; This record is used by the memory monitor. void SetLastMergingMsg(TObject* obj); Set the message to be notified in case of exception. Int_t Incorporate(TObject* obj, TList* out, Bool_t& merged); Incorporate object 'newobj' in the list 'outlist'.; The object is merged with an object of the same name already existing in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerRemote.html:18772,feedback,feedback,18772,root/html528/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html528/TProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. » Last changed: Mon Dec 7 13:48:13 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMappedCategory.html:22308,intuit,intuitively,22308,root/html526/RooMappedCategory.html,https://root.cern,https://root.cern/root/html526/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. » Last changed: Mon Jul 4 15:23:19 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMappedCategory.html:22558,intuit,intuitively,22558,root/html530/RooMappedCategory.html,https://root.cern,https://root.cern/root/html530/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"eritance; Inherited Members; Includes; Libraries. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. » Last changed: Thu Nov 3 20:08:36 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMappedCategory.html:22943,intuit,intuitively,22943,root/html532/RooMappedCategory.html,https://root.cern,https://root.cern/root/html532/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"erited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; void ApproximatePosterior () const;  approximate posterior in nbins using a TF1 scan the poi values and evaluate the posterior at each point and save the result in a cloned TF1 For each point the posterior is evaluated by integrating the nuisance parameters ;  ; void ClearAll () const;  clear all cached pdf objects ;  ; void ComputeIntervalFromApproxPosterior (double c1, double c2) const;  compute the interval using the approximate posterior function ;  ; void ComputeIntervalFromCdf (double c1, double c2) const;  internal function compute the interval using Cdf integration ;  ; void ComputeIntervalUsingRooFit (double c1, double c2) const;  internal function compute the interval using RooFit ;  ; void ComputeShortestInterval () const;  compute the shortest interval from the histogram representing the posterior ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Attributes; TF1 * fApproxPosterior;  TF1 representing the scanned posterior function. ;  ; double fBrfPrecision;  root finder precision ;  ; RooArgSet fConditionalObs;  conditional observables ;  ; RooAbsData * fData;  data set ;  ; RooArgSet fGlobalObs;  global observables ;  ; RooAbsReal * fIntegratedLikelihood;  integrated likelihood function, i.e - unnormalized posterior function ;  ; TString fIntegrationType;  ; double fLeftSideFraction",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html:17328,clear,clear,17328,doc/master/classRooStats_1_1BayesianCalculator.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1BayesianCalculator.html,1,['clear'],['clear']
Usability,"erivative type; 82 fFunctions.reserve(2);; 83}; 84 ; 85GSLMultiRootFinder::GSLMultiRootFinder(const char * name) :; 86 fIter(0), fStatus(-1), fPrintLevel(0),; 87 fType(0), fUseDerivAlgo(false),; 88 fSolver(nullptr); 89{; 90 // constructor for a string; 91 fFunctions.reserve(2);; 92 SetType(name);; 93}; 94 ; 95GSLMultiRootFinder::~GSLMultiRootFinder(); 96{; 97 // delete function wrapper; 98 ClearFunctions();; 99 if (fSolver) delete fSolver;; 100}; 101 ; 102void GSLMultiRootFinder::SetType(const char * name) {; 103 // set type using a string; 104 std::pair<bool,int> type = GetType(name);; 105 fUseDerivAlgo = type.first;; 106 fType = type.second;; 107}; 108 ; 109 ; 110int GSLMultiRootFinder::AddFunction(const ROOT::Math::IMultiGenFunction & func) {; 111 // add a new function in the vector; 112 ROOT::Math::IMultiGenFunction * f = func.Clone();; 113 if (!f) return 0;; 114 fFunctions.push_back(f);; 115 return fFunctions.size();; 116}; 117 ; 118void GSLMultiRootFinder::ClearFunctions() {; 119 // clear the function list; 120 for (unsigned int i = 0; i < fFunctions.size(); ++i) {; 121 if (fFunctions[i] != nullptr ) delete fFunctions[i];; 122 fFunctions[i] = nullptr;; 123 }; 124 fFunctions.clear();; 125}; 126 ; 127void GSLMultiRootFinder::Clear() {; 128 // clear the function list and the solver; 129 ClearFunctions();; 130 if (fSolver) Clear();; 131 fSolver = nullptr;; 132}; 133 ; 134 ; 135const double * GSLMultiRootFinder::X() const {; 136 // return x; 137 return (fSolver != nullptr) ? fSolver->X() : nullptr;; 138}; 139const double * GSLMultiRootFinder::Dx() const {; 140 // return x; 141 return (fSolver != nullptr) ? fSolver->Dx() : nullptr;; 142}; 143const double * GSLMultiRootFinder::FVal() const {; 144 // return x; 145 return (fSolver != nullptr) ? fSolver->FVal() : nullptr;; 146}; 147const char * GSLMultiRootFinder::Name() const {; 148 // get GSL name; 149 return (fSolver != nullptr) ? fSolver->Name().c_str() : """";; 150}; 151 ; 152// bool GSLMultiRootFinder::AddFunction( c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:3901,clear,clear,3901,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,1,['clear'],['clear']
Usability,"ern (const LayerContainer& _layers,; 1222 std::vector<LayerData>& layerData) const; 1223 {; 1224 size_t idxLayer = 0, idxLayerEnd = _layers.size ();; 1225 for (; idxLayer < idxLayerEnd; ++idxLayer); 1226 {; 1227 LayerData& prevLayerData = layerData.at (idxLayer);; 1228 LayerData& currLayerData = layerData.at (idxLayer+1);; 1229 ; 1230 forward (prevLayerData, currLayerData);; 1231 ; 1232 applyFunctions (currLayerData.valuesBegin (), currLayerData.valuesEnd (), currLayerData.activationFunction ());; 1233 }; 1234 }; 1235 ; 1236 ; 1237 ; 1238 ; 1239 template <typename LayerContainer, typename LayerPatternContainer>; 1240 void Net::forwardBatch (const LayerContainer& _layers,; 1241 LayerPatternContainer& layerPatternData,; 1242 std::vector<double>& valuesMean,; 1243 std::vector<double>& valuesStdDev,; 1244 size_t trainFromLayer) const; 1245 {; 1246 valuesMean.clear ();; 1247 valuesStdDev.clear ();; 1248 ; 1249 // ---------------------------------- loop over layers and pattern -------------------------------------------------------; 1250 for (size_t idxLayer = 0, idxLayerEnd = layerPatternData.size (); idxLayer < idxLayerEnd-1; ++idxLayer); 1251 {; 1252 bool doTraining = idxLayer >= trainFromLayer;; 1253 ; 1254 // get layer-pattern data for this and the corresponding one from the next layer; 1255 std::vector<LayerData>& prevLayerPatternData = layerPatternData.at (idxLayer);; 1256 std::vector<LayerData>& currLayerPatternData = layerPatternData.at (idxLayer+1);; 1257 ; 1258 size_t numPattern = prevLayerPatternData.size ();; 1259 size_t numNodesLayer = _layers.at (idxLayer).numNodes ();; 1260 ; 1261 std::vector<MeanVariance> means (numNodesLayer);; 1262 // ---------------- loop over layerDatas of pattern compute forward ----------------------------; 1263 for (size_t idxPattern = 0; idxPattern < numPattern; ++idxPattern); 1264 {; 1265 const LayerData& prevLayerData = prevLayerPatternData.at (idxPattern);; 1266 LayerData& currLayerData = currLayerPatternData.at (idxPattern);; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:40569,clear,clear,40569,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['clear'],['clear']
Usability,"erride;  Get bin name of an outpt bin. ;  ; void RegularizeDistributionRecursive (const TUnfoldBinning *binning, ERegMode regmode, EDensityMode densityMode, const char *distribution, const char *axisSteering);  recursively add regularisation conditions for this node and its children ;  ; void RegularizeOneDistribution (const TUnfoldBinning *binning, ERegMode regmode, EDensityMode densityMode, const char *axisSteering);  regularize the distribution fof the given node ;  ;  Protected Member Functions inherited from TUnfoldSys; void ClearResults (void) override;  Clear all data members which depend on the unfolding results. ;  ; void DoBackgroundSubtraction (void);  perform background subtraction ;  ; void GetEmatrixFromVyy (const TMatrixDSparse *vyy, TH2 *ematrix, const Int_t *binMap, Bool_t clearEmat);  propagate an error matrix on the input vector to the unfolding result ;  ; TMatrixDSparse * GetSummedErrorMatrixXX (void);  determine total error matrix on the vector x ;  ; TMatrixDSparse * GetSummedErrorMatrixYY (void);  determine total error matrix on the vector Ax ;  ; virtual TMatrixDSparse * PrepareCorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2, const TMatrixDSparse *dsys);  propagate correlated systematic shift to an output vector ;  ; virtual void PrepareSysError (void);  Matrix calculations required to propagate systematic errors. ;  ; virtual TMatrixDSparse * PrepareUncorrEmat (const TMatrixDSparse *m1, const TMatrixDSparse *m2);  propagate uncorrelated systematic errors to a covariance matrix ;  ; void ScaleColumnsByVector (TMatrixDSparse *m, const TMatrixTBase< Double_t > *v) const;  scale columns of a matrix by the corresponding rows of a vector ;  ; void VectorMapToHist (TH1 *hist_delta, const TMatrixDSparse *delta, const Int_t *binMap);  map delta to hist_delta, possibly summing up bins ;  ;  Protected Member Functions inherited from TUnfold; void AddMSparse (TMatrixDSparse *dest, Double_t f, const TMatrixDSparse *src) const;  add a sparse ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:32279,clear,clearEmat,32279,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['clear'],['clearEmat']
Usability,"erridevirtual . Handle animation timer. ; Reimplemented from TGWindow.; Definition at line 5011 of file TSessionViewer.cxx. ◆ IsA(). TClass * TSessionViewer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGMainFrame.; Definition at line 631 of file TSessionViewer.h. ◆ IsAutoSave(). Bool_t TSessionViewer::IsAutoSave ; (; ); const. inline . Definition at line 605 of file TSessionViewer.h. ◆ IsBusy(). Bool_t TSessionViewer::IsBusy ; (; ); const. inline . Definition at line 604 of file TSessionViewer.h. ◆ LogMessage(). void TSessionViewer::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Load/append a log msg in the log frame. ; Definition at line 5051 of file TSessionViewer.cxx. ◆ MyHandleMenu(). void TSessionViewer::MyHandleMenu ; (; Int_t ; id). Handle session viewer custom popup menus. ; Definition at line 5500 of file TSessionViewer.cxx. ◆ OnCascadeMenu(). void TSessionViewer::OnCascadeMenu ; (; ). Handle feedback histograms configuration menu. ; Definition at line 5564 of file TSessionViewer.cxx. ◆ OnListTreeClicked(). void TSessionViewer::OnListTreeClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn, . Int_t ; x, . Int_t ; y . ). Handle mouse clicks in list tree. ; Definition at line 4635 of file TSessionViewer.cxx. ◆ OnListTreeDoubleClicked(). void TSessionViewer::OnListTreeDoubleClicked ; (; TGListTreeItem * ; entry, . Int_t ; btn . ). Handle mouse double clicks in list tree (connect to server). ; Definition at line 4895 of file TSessionViewer.cxx. ◆ ProcessMessage(). Bool_t TSessionViewer::ProcessMessage ; (; Longptr_t ; msg, . Longptr_t ; parm1, . Longptr_t ;  . ). overridevirtual . Handle messages send to the TSessionViewer object. ; E.g. all menu entries messages. ; Reimplemented from TGCompositeFrame.; Definition at line 5627 of file TSessionViewer.cxx. ◆ QueryResultReady(). void TSessionViewer::QueryResultReady ; (; char * ; query). Handle signal ""query result ready"" coming from Proof sessio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionViewer.html:46779,feedback,feedback,46779,doc/master/classTSessionViewer.html,https://root.cern,https://root.cern/doc/master/classTSessionViewer.html,1,['feedback'],['feedback']
Usability,"error propagation). Double_t CLsError() const; Returns an estimate of the error on CLs through combination of the; errors on CLb and CLsplusb:. void UpdatePValue(const RooStats::SamplingDistribution* distr, Double_t& pvalue, Double_t& perror, Bool_t pIsRightTail); updates the pvalue if sufficient data is available. void Print(Option_t* = """") const; Print out some information about the results; Note: use Alt/Null labels for the hypotheses here as the Null; might be the s+b hypothesis. Double_t NullPValue() const; Return p-value for null hypothesis. { return fNullPValue; }. Double_t AlternatePValue() const; Return p-value for alternate hypothesis. { return fAlternatePValue; }. Double_t CLb() const; Convert NullPValue into a ""confidence level"". { return !fBackgroundIsAlt ? NullPValue() : AlternatePValue(); }. Double_t CLsplusb() const; Convert AlternatePValue into a ""confidence level"". { return !fBackgroundIsAlt ? AlternatePValue() : NullPValue(); }. Double_t CLs() const; CLs is simply CLs+b/CLb (not a method, but a quantity). Double_t Significance() const; familiar name for the Null p-value in terms of 1-sided Gaussian significance. {return RooStats::PValueToSignificance( NullPValue() ); }. SamplingDistribution* GetNullDistribution(void); { return fNullDistr; }. SamplingDistribution* GetAltDistribution(void); { return fAltDistr; }. RooDataSet* GetNullDetailedOutput(void); { return fNullDetailedOutput; }. RooDataSet* GetAltDetailedOutput(void); { return fAltDetailedOutput; }. RooDataSet* GetFitInfo(void); { return fFitInfo; }. Double_t GetTestStatisticData(void); { return fTestStatisticData; }. const RooArgList* GetAllTestStatisticsData(void); { return fAllTestStatisticsData; }. void SetAltDetailedOutput(RooDataSet* d); { fAltDetailedOutput = d; }. void SetNullDetailedOutput(RooDataSet* d); { fNullDetailedOutput = d; }. void SetFitInfo(RooDataSet* d); { fFitInfo = d; }. Bool_t GetPValueIsRightTail(void); { return fPValueIsRightTail; }. void SetBackgroundAsAlt(Bool_t l ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HypoTestResult.html:10710,simpl,simply,10710,root/html534/RooStats__HypoTestResult.html,https://root.cern,https://root.cern/root/html534/RooStats__HypoTestResult.html,1,['simpl'],['simply']
Usability,"error. Must only be called directly at the corresponding; 114 * call to Forward(...). */; 115 virtual void Backward(Tensor_t &gradients_backward, const Tensor_t &activations_backward ) = 0;; 116 ///// std::vector<Matrix_t> &inp1, std::vector<Matrix_t> &inp2) = 0;; 117 ; 118 /*! Reset some training flags after a loop on all batches; 119 Some layer (e.g. batchnormalization) might need to implement the function in case some operations; 120 are needed after looping an all batches */; 121 virtual void ResetTraining() {}; 122 ; 123 /*! Updates the weights and biases, given the learning rate */; 124 void Update(const Scalar_t learningRate);; 125 ; 126 /*! Updates the weights, given the gradients and the learning rate, */; 127 void UpdateWeights(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 128 ; 129 /*! Updates the biases, given the gradients and the learning rate. */; 130 void UpdateBiases(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 131 ; 132 /*! Updates the weight gradients, given some other weight gradients and learning rate. */; 133 void UpdateWeightGradients(const std::vector<Matrix_t> &weightGradients, const Scalar_t learningRate);; 134 ; 135 /*! Updates the bias gradients, given some other weight gradients and learning rate. */; 136 void UpdateBiasGradients(const std::vector<Matrix_t> &biasGradients, const Scalar_t learningRate);; 137 ; 138 /*! Copies the weights provided as an input. */; 139 void CopyWeights(const std::vector<Matrix_t> &otherWeights);; 140 ; 141 /*! Copies the biases provided as an input. */; 142 void CopyBiases(const std::vector<Matrix_t> &otherBiases);; 143 ; 144 /*! Copy all trainable weight and biases from another equivalent layer but with different architecture; 145 The function can copy also extra parameters in addition to weights and biases if they are return; 146 by the function GetExtraLayerParameters */; 147 template <typename Arch>; 148 void CopyParameters(const VGeneralLayer<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:5496,learn,learningRate,5496,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"errors; bool fix_position[MAX_NUMBER_OF_PEAKS1]; // logical vector which allows to fix appropriate positions (not fit). However they are present in the estimated functional; double amp_init[MAX_NUMBER_OF_PEAKS1]; // initial values of peaks amplitudes, input parameters; double amp_calc[MAX_NUMBER_OF_PEAKS1]; // calculated values of fitted amplitudes, output parameters; double amp_err[MAX_NUMBER_OF_PEAKS1]; // amplitude errors; bool fix_amp[MAX_NUMBER_OF_PEAKS1]i; // logical vector, which allows to fix appropriate amplitudes (not fit). However they are present in the estimated functional; double area[MAX_NUMBER_OF_PEAKS1]; // calculated areas of peaks; double area_err[MAX_NUMBER_OF_PEAKS1]; // errors of peak areas; double sigma_init; // sigma parameter, see peak shape function; double sigma_calc;; double sigma_err;; bool fix_sigma;; double t_init // t parameter, see peak shape function; double t_calc;; double t_err;; bool fix_t;; double b_init // b parameter, see peak shape function; double b_calc;; double b_err;; bool fix_b;; double s_init; // s parameter, see peak shape function; double s_calc;; double s_err;; bool fix_s;; double a0_init; // background is estimated as a0+a1*x+a2*x*x; double a0_calc;; double a0_err;; bool fix_a0;; double a1_init;; double a1_calc;; double a1_err;; bool fix_a1;; double a2_init;; double a2_calc;; double a2_err;; bool fix_a2;; };; As an example we present a simple 1-dimensional synthetic spectrum with 5 peaks. The fit (obtained using above-given awmi fitting function) is given in Figure 5.1. The chi-square achieved in this fit was 0.76873. The input value of the fit (positions of peaks and their amplitudes) were estimated using peak searching function. Fit obtained using above given awmi fitting function. Let us go to a more complicated fit with a lot of overlapping peaks as in Figure 5.2. The initial positions of peaks were determined from original data, using peak searching function. The fit is not very good, as there are some peaks mis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:41729,simpl,simple,41729,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"ers (structure); 1247 ; 1248 void removeLayer () { m_layers.pop_back (); } ///< remove one layer; 1249 ; 1250 ; 1251 void clear () ///< clear one layer; 1252 {; 1253 m_layers.clear ();; 1254 m_eErrorFunction = ModeErrorFunction::SUMOFSQUARES;; 1255 }; 1256 ; 1257 ; 1258 template <typename OutIterator>; 1259 void initializeWeights (WeightInitializationStrategy eInitStrategy,; 1260 OutIterator itWeight); ///< initialize the weights with the given strategy; 1261 ; 1262 protected:; 1263 ; 1264 void fillDropContainer (DropContainer& dropContainer, double dropFraction, size_t numNodes) const; ///< prepare the drop-out-container (select the nodes which are to be dropped out); 1265 ; 1266 ; 1267 private:; 1268 ; 1269 ModeErrorFunction m_eErrorFunction; ///< denotes the error function; 1270 size_t m_sizeInput; ///< input size of this DNN; 1271 size_t m_sizeOutput; ///< output size of this DNN; 1272 std::vector<Layer> m_layers; ///< layer-structure-data; 1273 ; 1274 protected:; 1275 // variables for JsMVA (interactive training in jupyter notebook); 1276 IPythonInteractive *fInteractive = nullptr;; 1277 bool * fExitFromTraining = nullptr;; 1278 UInt_t *fIPyMaxIter = nullptr, *fIPyCurrentIter = nullptr;; 1279 ; 1280 public:; 1281 ; 1282 // setup ipython interactive variables; 1283 void SetIpythonInteractive(IPythonInteractive* fI, bool* fE, UInt_t *M, UInt_t *C){; 1284 fInteractive = fI;; 1285 fExitFromTraining = fE;; 1286 fIPyMaxIter = M;; 1287 fIPyCurrentIter = C;; 1288 }; 1289 };; 1290 ; 1291 ; 1292 ; 1293 ; 1294typedef std::tuple<Settings&, Batch&, DropContainer&> pass_through_type;; 1295 ; 1296 ; 1297 ; 1298 ; 1299 ; 1300 ; 1301 ; 1302 } // namespace DNN; 1303} // namespace TMVA; 1304 ; 1305 ; 1306// include the implementations (in header file, because they are templated); 1307#include ""TMVA/NeuralNet.icc""; 1308 ; 1309#endif; 1310 ; Monitoring.h; NeuralNet.icc; Pattern.h; R#define R(a, b, c, d, e, f, g, h, i)Definition RSha256.hxx:110; e#define e(i)Definition RSha256.hxx:10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:45973,clear,clear,45973,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clear']
Usability,"ers: find the mapping of data members to otuput list entries in the output list and apply it. ; Definition at line 2766 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerRemote::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster.; Definition at line 4095 of file TProofPlayer.cxx. ◆ StopFeedback(). void TProofPlayerRemote::StopFeedback ; (; ). overrideprotectedvirtual . Stop reporting of feedback objects. ; Reimplemented from TProofPlayer.; Definition at line 4118 of file TProofPlayer.cxx. ◆ StopProcess(). void TProofPlayerRemote::StopProcess ; (; Bool_t ; abort, . Int_t ; timeout = -1 . ). overridevirtual . Stop process after this event. ; Reimplemented from TProofPlayer.; Definition at line 3325 of file TProofPlayer.cxx. ◆ StoreFeedback(). void TProofPlayerRemote::StoreFeedback ; (; TObject * ; slave, . TList * ; out . ). overridevirtual . Store feedback results from the specified slave. ; Reimplemented from TProofPlayer.; Definition at line 4034 of file TProofPlayer.cxx. ◆ StoreOutput(). void TProofPlayerRemote::StoreOutput ; (; TList * ; out). overridevirtual . Store received output list. ; Reimplemented from TProofPlayer.; Definition at line 3852 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerRemote::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayer.; Reimplemented in TProofPlayerSuperMaster. ◆ StreamerNVirtual(). void TProofPlayerRemote::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 366 of file TProofPlayer.h. Member Data Documentation. ◆ fDSet. TDSet* TProofPlayerRemote::fDSet. protected . Definition at line 288 of file TProofPlayer.h. ◆ fErrorHandler. ErrorHandlerFunc_t TProofPlayerRemote::fErrorHandler. protected . tdset for current processing ; Definition at line 289 of file TProofPlayer.h. ◆ fFeedback. TList* TP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:37514,feedback,feedback,37514,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"ert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; virtual void printMetaArgs (std::ostream &) const;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; RooWorkspace * workspace () const;  ; const RefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:38268,clear,clear,38268,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,29,['clear'],['clear']
Usability,"ert additional information when printed in the context of a tree structure. ;  ; void printComponentTree (const char *indent="""", const char *namePat=nullptr, Int_t nLevel=999);  Print tree structure of expression tree on given ostream, only branch nodes are printed. ;  ; void printDirty (bool depth=true) const;  Print information about current value dirty state information. ;  ; virtual void printMetaArgs (std::ostream &) const;  ; void printName (std::ostream &os) const override;  Print object name. ;  ; void printTitle (std::ostream &os) const override;  Print object title. ;  ; void printTree (std::ostream &os, TString indent="""") const override;  Print object tree structure. ;  ; bool recursiveCheckObservables (const RooArgSet *nset) const;  Recursively call checkObservables on all nodes in the expression tree. ;  ; void removeStringAttribute (const Text_t *key);  Delete a string attribute with a given key. ;  ; void resetDataToken ();  ; void setAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setDataToken (std::size_t index);  Sets the token for retrieving results in the BatchMode. For internal use only. ;  ; void setLocalNoDirtyInhibit (bool flag) const;  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetNameTitle (const char *name, const char *title) override;  Set all the TNamed parameters (name and title). ;  ; void setProhibitServerRedirect (bool flag);  ; void setStringAttribute (const Text_t *key, const Text_t *value);  Associate string 'value' to this object under key 'key'. ;  ; void setTransientAttribute (const Text_t *name, bool value=true);  Set (default) or clear a named boolean attribute of this object. ;  ; void setWorkspace (RooWorkspace &ws);  ; const std::map< std::string, std::string > & stringAttributes () const;  ; const std::set< std::string > & transientAttributes () const;  ; virtual void translate (RooFit::Detail::CodeSquashCon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:28006,clear,clear,28006,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,102,['clear'],['clear']
Usability,"erverList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:5012,clear,clearValueDirty,5012,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,2,['clear'],['clearValueDirty']
Usability,"es a category object has. In computations, values are expected to change often, while shapes remain mostly constant (unless e.g. a new range is set for an observable).; Nodes of a computation graph are connected using instances of RooAbsProxy. If Node B declares a member RooTemplateProxy<TypeOfNodeA>, Node A will be registered as a server of values to Node B, and Node B will know that it is a client of node A. Using functions like dependsOn(), or getObservables() / getParameters(), the relation of A --> B can be queried. Using graphVizTree(), one can create a visualisation of the expression tree.; An instance of RooAbsArg can have named attributes. It also has flags to indicate that either its value or its shape were changed (= it is dirty). RooAbsArg provides functionality to manage client/server relations in a computation graph (clientServerInterface), and helps propagating value/shape changes through the graph. RooAbsArg implements interfaces for inspecting client/server relationships (clientServerInterface) and setting/clearing/querying named attributes. Caching of values; The values of nodes in the computation graph are cached in RooFit. If a value is used in two nodes of a graph, it doesn't need to be recomputed. If a node acquires a new value, it notifies its consumers (""clients"") that their cached values are dirty. See the functions in optimisationInterface for details. A node uses its isValueDirty() and isShapeDirty() functions to decide if a computation is necessary. Caching can be vetoed globally by setting a bit using setDirtyInhibit(). This will make computations slower, but all the nodes of the computation graph will be evaluated irrespective of whether their state is clean or dirty. Using setOperMode(), caching can also be enabled/disabled for single nodes. ; Definition at line 79 of file RooAbsArg.h. Classes; struct  ProxyListCache;  . Public Types; enum  CacheMode { Always =0; , NotAdvised =1; , Never =2; };  ; enum  ConstOpCode { Activate =0; , DeAc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:2291,clear,clearing,2291,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['clear'],['clearing']
Usability,"es a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVACrossValidationApplication.C This macro provides an example of how to use TMVA for k-folds cross evaluation in application ;  TMVACrossValidationRegression.C This macro provides an example of how to use TMVA for k-folds cross evaluation ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMinimalClassification.C Minimal self-contained example for setting up TMVA with binary classification ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram and an ntuple ;  basic2.C Create can ntuple reading data from an ascii file ;  bill.C Benchmark comparing row-wise and column-wise storage performance ;  cernbuild.C Read data (CERN staff) from an ascii file and create a root file with a Tree ;  cernstaff.C Playing",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:159743,simpl,simple,159743,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,2,['simpl'],['simple']
Usability,"es can be accessed from your PC, from the web and from large-scale file delivery systems used e.g. in the GRID. ROOT trees spread over several files can be chained and accessed as a unique object, allowing for loops over huge amounts of data.; Mine data Powerful mathematical and statistical tools are provided to operate on your data. The full power of a C++ application and of parallel processing is available for any kind of data manipulation. Data can also be generated following any statistical distribution and modeled, making it possible to simulate complex systems.; Publish results Results can be displayed with histograms, scatter plots, fitting functions. ROOT graphics may be adjusted real-time by few mouse clicks. Publication-quality figures can be saved in PDF or other formats.; Run interactively or build your own application You can use the Cling C++ interpreter for your interactive sessions and to write macros, or you can compile your program to run at full speed. In both cases, you can also create a graphical user interface.; Use ROOT within other languages ROOT provides a set of bindings in order to seamlessly integrate with existing languages such as Python, R and Mathematica. Save dataAccess dataProcess dataShow resultsInteractive or built applicationIntegration with other languages. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/about-root.html:4191,guid,guidelines,4191,d/about-root.html,https://root.cern,https://root.cern/d/about-root.html,1,['guid'],['guidelines']
Usability,"es for the subsequent evaluation of the; test statistics. RooAbsData* GenerateToyDataImportanceSampling(RooArgSet& paramPoint, double& weight) const; This method generates a toy data set for importance sampling for the given parameter point taking; global observables into account.; The values of the generated global observables remain in the pdf's variables.; They have to have those values for the subsequent evaluation of the; test statistics. RooAbsData* Generate(RooAbsPdf& pdf, RooArgSet& observables, const RooDataSet* protoData = NULL, int forceEvents = 0) const; This is the generate function to use in the context of the ToyMCSampler; instead of the standard RooAbsPdf::generate(...).; It takes into account whether the number of events is given explicitly; or whether it should use the expected number of events. It also takes; into account the option to generate a binned data set (ie RooDataHist). void ClearCache(); clear the cache obtained from the pdf used for speeding the toy and global observables generation; needs to be called every time the model pdf (fPdf) changes. ToyMCSampler(); Proof constructor. Do not use. ToyMCSampler(RooStats::TestStatistic& ts, Int_t ntoys). void SetAlwaysUseMultiGen(Bool_t flag); { fgAlwaysUseMultiGen = flag ; }. void SetUseMultiGen(Bool_t flag); { fUseMultiGen = flag ; }. RooAbsData* GenerateToyData(RooArgSet& paramPoint) const; generates toy data; without weight. SamplingDistribution* AppendSamplingDistribution(RooArgSet& allParameters, RooStats::SamplingDistribution* last, Int_t additionalMC); Extended interface to append to sampling distribution more samples. Double_t EvaluateTestStatistic(RooAbsData& data, RooArgSet& nullPOI); Main interface to evaluate the test statistic on a dataset. TestStatistic* GetTestStatistic() const; { return fTestStat; }. Double_t ConfidenceLevel() const; { return 1. - fSize; }. void Initialize(RooAbsArg& , RooArgSet& , RooArgSet& ); { return fNToys; }. void SetNToys(const Int_t ntoy); { fNToys = ntoy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__ToyMCSampler.html:6660,clear,clear,6660,root/html532/RooStats__ToyMCSampler.html,https://root.cern,https://root.cern/root/html532/RooStats__ToyMCSampler.html,1,['clear'],['clear']
Usability,"es for using signals/slots mechanism in a standalone executable program do not differ from what was described previously. Let’s remind that. a slot can be any class method with a generated Cling dictionary; a slot can be a function with a dictionary. Detailed information how to generate a dictionary can be found on http://root.cern.ch/root/CintGenerator.html; The following example demonstrates how to use signals/slots mechanism in a standalone executable program on linux platform with the gcc compiler.; tst.C; #include <TQObject.h>; #include <RQ_OBJECT.h>. class A {; RQ_OBJECT(""A""); private:; Int_t fValue;; public:; A() : fValue(0) { }; ~A() { }; void SetValue(Int_t value); // *SIGNAL*; void PrintValue() const { printf(""value = %d\n"", fValue); }; };; void A::SetValue(Int_t value) { // Set new value; // Emit signal ""SetValue(Int_t)"" with a single parameter; if (value != fValue) {; fValue = value;; Emit(""SetValue(Int_t)"", fValue);; }; }; // Main program; #ifdef STANDALONE; int main(int argc, char **argv) {; A* a = new A();; A* b = new A();; a->Connect(""SetValue(Int_t)"", ""A"", b, ""SetValue(Int_t)"");; printf(""n******* Test of SetValue(Int_t) signal *******n"");; b->SetValue(10);; printf(""nt***** b before ******n"");; b->PrintValue();; a->SetValue(20);; printf(""t***** b after a->SetValue(20) ******n"");; b->PrintValue();; return 0;; }; #endif; ACLiC simplifies this procedure and allows the dictionary generation by:; root[] .L tst.C++; It will create the shared library tst_C.so.; The next line will create an executable:; g++ -otst tst.C `root-config --cflags --libs` ./tst_C.so -DSTANDALONE; The library tst_C.so is a dynamically loaded library and should be located in $LD_LIBRARY_PATH. The current working directory should be added to $LD_LIBRARY_PATH via:; export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./; To run it, you just do:; ./tst; 25.8 Widgets in Detail; 25.8.1 Buttons; Buttons are a popular group of widgets designed to provide specific interfaces for user interaction. TGButton",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1175266,simpl,simplifies,1175266,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simplifies']
Usability,"es in the projection is set to the number of entries of the 2-D histogram, otherwise the number of entries is incremented by 1 for all non empty cells.; The option can also be used to specify the projected profile error type. Values which can be used are 's', 'i', or 'g'. See TProfile::BuildOptions for details ; Definition at line 1389 of file TProfile2D.cxx. ◆ ProjectionXY(). TH2D * TProfile2D::ProjectionXY ; (; const char * ; name = ""_pxy"", . Option_t * ; option = ""e"" . ); const. Project this profile2D into a 2-D histogram along X,Y. ; The projection is always of the type TH2D. if option ""E"" is specified the errors of the projected histogram are computed and set to be equal to the errors of the profile. Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram will be equal to the GetBinEntries(bin) of the profile,; if option ""C=E"" the bin contents of the projection are set to the bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the product of the bin content of the profile and the entries. With this option the returned histogram will be equivalent to the one obtained by filling directly a TH2D using the 3-rd value as a weight. This option makes sense only for profile filled with all weights =1. When the profile is weighted (filled with weights different than 1) the bin error of the projected histogram (obtained using this option ""W"") cannot be correctly computed from the information stored in the profile. In that case the obtained histogram contains as bin error square the weighted sum of the square of the profiled observable (TProfile2D::fSumw2[bin] ) . Definition at line 1287 of file TProfile2D.cxx. ◆ PutStats(). void TProfile2D::PutStats ; (; Double_t * ; stats). overridevirtual . Replace current statistics with the values in array stats. ; Reimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile2D.html:96486,simpl,simply,96486,doc/master/classTProfile2D.html,https://root.cern,https://root.cern/doc/master/classTProfile2D.html,1,['simpl'],['simply']
Usability,"es of the event; int fEventSize; // size (in bytes) of the event; };. The data members of the Particle class describe the particle properties as shown below:; class Particle {; public:; double fPosX,fPosY,fPosZ; // particle position nearest to interaction point; double fMomentum; // particle momentum; double fMomentumPhi; // particle direction (phi); double fMomentumEta; // particle direction (eta); Long64_t fTags[128]; // particle tags; };. The TTree contains a branch event, which in turn contains the branches fParticles and fEventSize. It simply reflects the layout of class EventData. Each TTree entry has one object of type class EventData, which in turn has a collection of particles. Each tree entry can have a different number of particles. There are 200 TTree entries containing a total of 22994 particles.; If you are curious how we generated the TTree: the script is in our git repository.; . ‹ Introductory Tutorials; up; Accessing a TTree With a TBrowser ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meet-ttree.html:4896,guid,guidelines,4896,d/meet-ttree.html,https://root.cern,https://root.cern/d/meet-ttree.html,1,['guid'],['guidelines']
Usability,"es the optional argument to set a new name to the newly created object.; If the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirectory. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented from TObject.; Definition at line 46 of file RooFitResult.h. ◆ conditionalCovarianceMatrix(). TMatrixDSym RooFitResult::conditionalCovarianceMatrix ; (; const RooArgList & ; params); const. Return a reduced covariance matrix, which is calculated as. . \[; V_\mathrm{red} = \bar{V_{22}} = V_{11} - V_{12} \cdot V_{22}^{-1} \cdot V_{21},; \]. where \( V_{11},V_{12},V_{21},V_{22} \) represent a block decomposition of the covariance matrix into observables that are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and \( \bar{V_{22}} \) is the Shur complement of \( V_{22} \), calculated as shown above.; (Note that \( V_\mathrm{red} \) is not a simple sub-matrix of \( V \)) ; Definition at line 1170 of file RooFitResult.cxx. ◆ constPars(). const RooArgList & RooFitResult::constPars ; (; ); const. inline . Return list of constant parameters. ; Definition at line 103 of file RooFitResult.h. ◆ correlation() [1/5]. const RooArgList * RooFitResult::correlation ; (; const char * ; parname); const. Return the set of correlation coefficients of parameter 'par' with all other floating parameters. ; Definition at line 411 of file RooFitResult.cxx. ◆ correlation() [2/5]. double RooFitResult::correlation ; (; const char * ; parname1, . const char * ; parname2 . ); const. Return the correlation between parameters 'par1' and 'par2'. ; Definition at line 390 of file RooFitResult.cxx. ◆ correlation() [3/5]. const RooArgList * RooFitResult::correlation ; (; const RooAbsArg & ; par); const. inline . Return pointer to list of correlations of all parameters with par. ; Definition at line 122 of file RooFitResult.h. ◆ correlation() [4/5]. double RooFitResult::cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFitResult.html:24026,simpl,simple,24026,doc/master/classRooFitResult.html,https://root.cern,https://root.cern/doc/master/classRooFitResult.html,1,['simpl'],['simple']
Usability,"es(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual RooResolutionModel*RooResolutionModel::convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGaussModel.html:3384,clear,clearEvalError,3384,root/html534/RooGaussModel.html,https://root.cern,https://root.cern/root/html534/RooGaussModel.html,9,['clear'],['clearEvalError']
Usability,"es, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file GeneralLayer.h. Member Data Documentation. ◆ fActivationGradients. template<typename Architecture_t > . Tensor_t TMVA::DNN::VGeneralLayer< Architecture_t >::fActivationGradients. protected . Gradients w.r.t. the activations of this layer. ; Definition at line 78 of file GeneralLayer.h. ◆ fBatchSize. template<typename Architecture_t > . size_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26625,learn,learningRate,26625,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"es. Bool_t operator==(Int_t index) const; Equality operator with a integer (compares with state index number). Bool_t operator==(const char* label) const; Equality operator with a string (compares with state label string). Bool_t operator==(const RooAbsArg& other); Equality operator with another RooAbsArg. Only functional; is also a RooAbsCategory, will return true if index is the same. Bool_t isValidIndex(Int_t index) const; Check if state with given index is defined. Bool_t isValidLabel(const char* label) const; Check if state with given name is defined. const RooCatType* defineType(const char* label); Define a new state with given name. The lowest available; integer number is assigned as index value. const RooCatType* defineTypeUnchecked(const char* label, Int_t index); Internal version of defineType that does not check if type; already exists. const RooCatType* defineType(const char* label, Int_t index); Define new state with given name and index number. void clearTypes(); Delete all currently defined states. const RooCatType* lookupType(const RooCatType& type, Bool_t printError = kFALSE) const; Find our type that matches the specified type, or return 0 for no match. const RooCatType* lookupType(Int_t index, Bool_t printError = kFALSE) const; Find our type corresponding to the specified index, or return 0 for no match. const RooCatType* lookupType(const char* label, Bool_t printError = kFALSE) const; Find our type corresponding to the specified label, or return 0 for no match. Bool_t isValid() const; Check if current value is a valid state. Bool_t isValid(const RooCatType& value) const; Check if given state is defined for this object. Roo1DTable* createTable(const char* label) const; Create a table matching the shape of this category. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to ostream. void printValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:21682,clear,clearTypes,21682,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,3,['clear'],['clearTypes']
Usability,"es. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. Entry& operator=(const RooMappedCategory& ). » Last changed: Tue Jun 30 14:33:57 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:25576,intuit,intuitively,25576,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"es; # passing the cuts, if any.; b1b2_cut = d.Filter(cutb1b2); minVal = b1b2_cut.Min('b1'); maxVal = b1b2_cut.Max('b1'); meanVal = b1b2_cut.Mean('b1'); nonDefmeanVal = b1b2_cut.Mean(""b2""); print('The mean is always included between the min and the max: {0} <= {1} <= {2}'.format(minVal.GetValue(), meanVal.GetValue(), maxVal.GetValue())); ; # `Histo1D` action; # The `Histo1D` action allows to fill an histogram. It returns a TH1F filled; # with values of the column that passed the filters. For the most common; # types, the type of the values stored in the column is automatically; # guessed.; hist = d.Filter(cutb1).Histo1D('b1'); print('Filled h {0} times, mean: {1}'.format(hist.GetEntries(), hist.GetMean())); ; # Express your chain of operations with clarity!; # We are discussing an example here but it is not hard to imagine much more; # complex pipelines of actions acting on data. Those might require code; # which is well organised, for example allowing to conditionally add filters; # or again to clearly separate filters and actions without the need of; # writing the entire pipeline on one line. This can be easily achieved.; # We'll show this re-working the `Count` example:; cutb1_result = d.Filter(cutb1);; cutb1b2_result = d.Filter(cutb1b2);; cutb1_cutb1b2_result = cutb1_result.Filter(cutb1b2); ; # Now we want to count:; evts_cutb1_result = cutb1_result.Count(); evts_cutb1b2_result = cutb1b2_result.Count(); evts_cutb1_cutb1b2_result = cutb1_cutb1b2_result.Count(); ; print('Events passing cutb1: {}'.format(evts_cutb1_result.GetValue())); print('Events passing cutb1b2: {}'.format(evts_cutb1b2_result.GetValue())); print('Events passing both: {}'.format(evts_cutb1_cutb1b2_result.GetValue())); ; # Calculating quantities starting from existing columns; # Often, operations need to be carried out on quantities calculated starting; # from the ones present in the columns. We'll create in this example a third; # column, the values of which are the sum of the *b1* and *b2* ones, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df001__introduction_8py.html:3401,clear,clearly,3401,doc/master/df001__introduction_8py.html,https://root.cern,https://root.cern/doc/master/df001__introduction_8py.html,1,['clear'],['clearly']
Usability,"escribing current object ; Reimplemented from TSelector.; Definition at line 60 of file TSelectorEntries.h. ◆ Notify(). bool TSelectorEntries::Notify ; (; ). overridevirtual . This function is called at the first entry of a new tree in a chain. ; Reimplemented from TSelector.; Definition at line 136 of file TSelectorEntries.cxx. ◆ Process(). bool TSelectorEntries::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TSelectorEntries::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used. ; Reimplemented from TSelector.; Definition at line 161 of file TSelectorEntries.cxx. ◆ SetObject(). void TSelectorEntries::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 54 of file TSelectorEntries.h. ◆ SetOption(). void TSelectorEntries::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 53 of file TSelectorEntries.h. ◆ SetSelection(). void TSelectorEntries::SetSelection ; (; const char * ; selection). virtual . Set the selection expression. ; Definition at line 198 of file TSelectorEntries.cxx. ◆ SlaveBegin(). void TSelectorEntries::SlaveBegin ; (; TTree * ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorEntries.html:18127,simpl,simple,18127,doc/master/classTSelectorEntries.html,https://root.cern,https://root.cern/doc/master/classTSelectorEntries.html,1,['simpl'],['simple']
Usability,"escription; Write and read STL vectors in a tree. . ; #include <vector>; ; #include ""TFile.h""; #include ""TTree.h""; #include ""TCanvas.h""; #include ""TFrame.h""; #include ""TH1F.h""; #include ""TBenchmark.h""; #include ""TRandom.h""; #include ""TSystem.h""; ; void write(); {; ; TFile *f = TFile::Open(""hvector.root"",""RECREATE"");; ; if (!f) { return; }; ; // Create one histograms; TH1F *hpx = new TH1F(""hpx"",""This is the px distribution"",100,-4,4);; hpx->SetFillColor(48);; ; std::vector<float> vpx;; std::vector<float> vpy;; std::vector<float> vpz;; std::vector<float> vrand;; ; // Create a TTree; TTree *t = new TTree(""tvec"",""Tree with vectors"");; t->Branch(""vpx"",&vpx);; t->Branch(""vpy"",&vpy);; t->Branch(""vpz"",&vpz);; t->Branch(""vrand"",&vrand);; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; gRandom->SetSeed();; const Int_t kUPDATE = 1000;; for (Int_t i = 0; i < 25000; i++) {; Int_t npx = (Int_t)(gRandom->Rndm(1)*15);; ; vpx.clear();; vpy.clear();; vpz.clear();; vrand.clear();; ; for (Int_t j = 0; j < npx; ++j) {; ; Float_t px,py,pz;; gRandom->Rannor(px,py);; pz = px*px + py*py;; Float_t random = gRandom->Rndm(1);; ; hpx->Fill(px);; ; vpx.emplace_back(px);; vpy.emplace_back(py);; vpz.emplace_back(pz);; vrand.emplace_back(random);; ; }; if (i && (i%kUPDATE) == 0) {; if (i == kUPDATE) hpx->Draw();; c1->Modified();; c1->Update();; if (gSystem->ProcessEvents()); break;; }; t->Fill();; }; f->Write();; ; delete f;; }; ; ; void read(); {; ; TFile *f = TFile::Open(""hvector.root"",""READ"");; ; if (!f) { return; }; ; TTree *t; f->GetObject(""tvec"",t);; ; std::vector<float> *vpx = nullptr;; ; // Create a new canvas.; TCanvas *c1 = new TCanvas(""c1"",""Dynamic Filling Example"",200,10,700,500);; ; const Int_t kUPDATE = 1000;; ; TBranch *bvpx = nullptr;; t->SetBranchAddress(""vpx"",&vpx,&bvpx);; ; ; // Create one histograms; TH1F *h = new TH1F(""h"",""This is the px distribution"",100,-4,4);; h->SetFillColor(48);; ; for (Int_t i = 0; i < 25000; i++) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hvector_8C.html:1185,clear,clear,1185,doc/master/hvector_8C.html,https://root.cern,https://root.cern/doc/master/hvector_8C.html,1,['clear'],['clear']
Usability,"escription; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool::ObjBuildConfig. class RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html:1102,simpl,simple,1102,root/html526/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html,4,['simpl'],['simple']
Usability,"esn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. Measurement(const char* Name, const char* Title = """"). void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov dataset); add an Asimov Dataset. { fAsimovDatasets.push_ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html:12565,clear,clear,12565,root/html602/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__Measurement.html,2,['clear'],['clear']
Usability,"esolutionModel::basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&RooResolutionModel::basisConvVar() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidRooResolutionModel::cleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual RooResolutionModel*convolution(RooFormulaVar* basis, RooAbsArg* owner) const; RooRealVar&RooResolutionModel::convVar() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:3476,clear,clearEvalErrorLog,3476,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"espaces; Using comments to document the code; Source file layout. Header file layout; Implementation file layout. Preferred Coding Style. Indentation; Placing Braces and Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Taligent guide is quite reasonable. Of course, no class data member should ever be public. Make the data fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .icc files increases the build time, the complexity of the build system and, more importantly, increases the number of files one possibly has to scan to find a piece of code.; Declaration Order; In the class definition we first declare all private data members, followed by the private static members, the private methods and the private static methods. Then the protected members and methods and finally the public methods (no public data members). We put private members first since that is the language default and it gives the developer a quick v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:3021,guid,guide,3021,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['guid'],['guide']
Usability,"ess (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti);  Get query progress information. ;  ; void Progress (Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses);  Get query progress information. ;  ; void PutLog (TQueryResult *qr);  Display log of query pq into the log window frame. ;  ; void QueryResultReady (const char *ref);  Notify availability of a query result. ;  ; Int_t Remove (const char *queryref, Bool_t all=kFALSE);  Send remove request for the query specified by ref. ;  ; Int_t Remove (Int_t query, Bool_t all=kFALSE);  Send remove request for the qry-th query in fQueries. ;  ; void RemoveChain (TChain *chain);  Remove chain from data set. ;  ; Int_t RemoveDynamicPath (const char *libpath, Bool_t onClient=kFALSE);  Remove 'libpath' from the lib path search. ;  ; void RemoveFeedback (const char *name);  Remove object from feedback list. ;  ; Int_t RemoveIncludePath (const char *incpath, Bool_t onClient=kFALSE);  Remove 'incpath' from the inc path search. ;  ; void ResetProgressDialog (const char *sel, Int_t sz, Long64_t fst, Long64_t ent);  Reset progress dialog. ;  ; void ResetProgressDialogStatus ();  ; Int_t Retrieve (const char *queryref, const char *path=0);  Send retrieve request for the query specified by ref. ;  ; Int_t Retrieve (Int_t query, const char *path=0);  Send retrieve request for the qry-th query in fQueries. ;  ; Int_t SavePerfTree (const char *pf=0, const char *qref=0);  Save performance information from TPerfStats to file 'pf'. ;  ; void SendDataSetStatus (const char *msg, UInt_t n, UInt_t tot, Bool_t st);  Send or notify data set status. ;  ; Bool_t SendingLogToWindow () const;  ; void SendLogToWindow (Bool_t mode);  ; void SetActive (Bool_t=kTRUE);  ; virtual void SetAlias (const char *alias="""");  Set an alias for this session. ;  ; void SetDataPoolUrl (c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:15724,feedback,feedback,15724,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,"essDialog::EQueryStatusfStatus; TGTextButton*fStop; TGTextBuffer*fTextQuery; TGLabel*fTimeLab; TGLabel*fTitleLab; TGraph*fTotSGraph; TGLabel*fTotal; TGTextButton*fUpdtSpeedo; static Bool_tfgKeepDefault; static Bool_tfgLogQueryDefault; static TStringfgTextQueryDefault. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofProgressDialog(TProof* proof, const char* selector, Int_t files, Long64_t first, Long64_t entries); Create PROOF processing progress dialog. void ToggleOdometerInfos(); Toggle information displayed in Analog Meter. void ToggleThreshold(). void ResetProgressDialog(const char* sel, Int_t sz, Long64_t fst, Long64_t ent); Reset dialog box preparing for new query. void Progress(Long64_t total, Long64_t processed); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Update progress bar and status labels.; Use ""processed == total"" or ""processed < 0"" to indicate end of processing. Float_t AdjustBytes(Float_t mbs, TString& sf); Transform MBs to GBs ot TBs and get the correct suffix. ~TProofProgressDialog(); Cleanup dialog. void CloseWindow(); Called when dialog is closed. void DisableAsyn(); Disable the asyn switch when an external request for going asynchronous is issued. void IndicateStop(Bool_t aborted); Indicate that Cancel or Stop was clicked. void LogMessage(const char* msg, Bool_t all); Load/append a log msg in the log frame, if open. void DoClose(); Close dialog. void DoLog(); Ask proof session for logs. void DoKeep(Bool_t on); Handle keep toggle button. void DoSetLogQuery(Bool_t on); Handle log-current-query-only toggle button. void DoStop(); Handle Stop button. void DoAbort(); Handle Cancel button. void DoAsyn(); Handle Asyn button. void DoPlotRateGraph(); Handle Plot Rate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofProgressDialog.html:3942,progress bar,progress bar,3942,root/html528/TProofProgressDialog.html,https://root.cern,https://root.cern/root/html528/TProofProgressDialog.html,4,['progress bar'],['progress bar']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2010-12-15 15:10 » Last generated: 2010-12-15 15:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/MATH_Index.html:4353,guid,guide,4353,root/html528/MATH_Index.html,https://root.cern,https://root.cern/root/html528/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2011-07-04 15:18 » Last generated: 2011-07-04 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/MATH_Index.html:4353,guid,guide,4353,root/html530/MATH_Index.html,https://root.cern,https://root.cern/root/html530/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2011-12-02 14:26 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/MATH_Index.html:4353,guid,guide,4353,root/html532/MATH_Index.html,https://root.cern,https://root.cern/root/html532/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2015-06-30 14:20 » Last generated: 2015-06-30 14:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/MATH_Index.html:4350,guid,guide,4350,root/html602/MATH_Index.html,https://root.cern,https://root.cern/root/html602/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2015-09-08 16:58 » Last generated: 2015-09-08 16:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/MATH_Index.html:4353,guid,guide,4353,root/html534/MATH_Index.html,https://root.cern,https://root.cern/root/html534/MATH_Index.html,3,['guid'],['guide']
Usability,"ession templates to achieve an high level optimization. Physics Vectors: classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:. Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. Unuran: package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions. ; Foam: multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW: library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of (FFTW).; MLP: library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlpfit package.; Quadp: optimization library with linear and quadratic programming methods. It is based on the Matrix package.; Statistic classes for computing limits and confidence levels.; More detailed is provided here. Some of these classes are currently provided by libPhysics. Further information is available at the following links:. ROOT Mathematical Library Web page; ROOT Math doxygen class documentation; The Math chapter in the user guide; The Linear Algebra chapter in the user guide; The Physics Vector chapter in the user guide; Inventory of Math functions and algorithms. Last modified: Thu Mar 5 16:03:07 CET 2009 . ; MATH Modules; FFTW; FOAM; FUMILI; GENETIC; GENVECTOR; MATHCORE; MATHMORE; MATRIX; MINUIT; MINUIT2; MLP; PHYSICS; QUADP; SMATRIX; SPLOT; UNURAN. » Last changed: 2015-09-08 17:32 » Last generated: 2015-09-08 17:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/MATH_Index.html:4350,guid,guide,4350,root/html604/MATH_Index.html,https://root.cern,https://root.cern/root/html604/MATH_Index.html,3,['guid'],['guide']
Usability,"estBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. TQueryDescription*fActQuerycurrent (actual) query; TStringfAddressserver address; Bool_tfAttachedkTRUE if attached; Bool_tfAutoEnableenable packages at session startup time; TStringfConfigFileconfiguration file name; Bool_tfConnectedkTRUE if connected; Bool_tfLocalkTRUE if session is local; Int_tfLogLevellog (debug) level; TStringfNamesession name; Int_tfNbHistosnumber of feedback histos; TList*fPackageslist of packages; Int_tfPortcommunication port; TProof*fProofpointer on TProof used by this session; TProofMgr*fProofMgrProof sessions manager; TList*fQuerieslist of queries in this session; Bool_tfSynckTRUE if in sync mode; TStringfTagsession unique identifier; TStringfUserNameuser name (on server). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; const char * GetName() const; { return fQueryName; }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionDescription.html:5655,feedback,feedback,5655,root/html534/TSessionDescription.html,https://root.cern,https://root.cern/root/html534/TSessionDescription.html,1,['feedback'],['feedback']
Usability,"ested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development ROOT 7. For the first time since 20 year (i.e. ever), the ROOT team plans to break backward compatibility for crucial interfaces - once.; This new major version of ROOT will make ROOT much simpler and safer to use: we want to increase clarity and usability.; If you are a physicist, please read on - this is about your ROOT.; The ROOT team will be releasing parts of ROOT 7 throughout the coming years.; Previews will gradually sneak into the ROOT sources, in the namespace ROOT::Experimental for those parts that are not yet cast in stone, and in the namespace ROOT for those that are.; We will use standard C++ types, standard interface behavior (e.g. with respect to ownership and thread safety), good documentation and tests: we are trying to be nice!; Feedback; The main point of the meeting and this page is to solicit your feedback. Most of it has been taken care of in the code already.; Building ROOT 7; Pre-requisites; Support for the c++14 standard is required. Usage of g++ >= 5 or clang >= 3.4 is recommended.; Relevant cmake variables; The CMAKE_CXX_STANDARD cmake variables must be set to at least 14.; Building from source would look similar to this:; $ mkdir root7_build; $ cd root7_build; $ cmake -DCMAKE_CXX_STANDARD=14 path/to/root/source; $ cmake --build . -- -j4. Examples; See the relevant tutorials, for instance for drawing and styling the new histograms.; The new interfaces are not about shortening your code - but about robustness. Here are a few examples of what can go wrong with the ROOT6 interfaces:; ROOT6 interfaces, showing what can go wrong.; #include ""TFile.h""#include ""TH2.h""#include ""TTreeReader.h""#include ""TTreeReaderArray.h""#include ""TTree.h"" // Another function. Who knows what it does in a month from n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/root-7.html:2685,feedback,feedback,2685,d/root-7.html,https://root.cern,https://root.cern/d/root-7.html,1,['feedback'],['feedback']
Usability,"estingEventVector->end()) < Int_t(cls+1) ) {; 1424 if( ( testingEventVector->end() - itTarget ) < Int_t(cls+1) ) {; 1425 itTarget = testingEventVector->end();; 1426 testingEventVector->insert( itTarget, itEvent, itEventEnd ); // fill in the rest without mixing; 1427 break;; 1428 }else{; 1429 itTarget += cls+1;; 1430 testingEventVector->insert( itTarget, (*itEvent) ); // fill event; 1431 }; 1432 }; 1433 }; 1434 }else{; 1435 for( UInt_t cls = 0; cls < dsi.GetNClasses(); ++cls ){; 1436 trainingEventVector->insert( trainingEventVector->end(), tmpEventVector[Types::kTraining].at(cls).begin(), tmpEventVector[Types::kTraining].at(cls).end() );; 1437 testingEventVector->insert ( testingEventVector->end(), tmpEventVector[Types::kTesting].at(cls).begin(), tmpEventVector[Types::kTesting].at(cls).end() );; 1438 }; 1439 }; 1440 // delete the tmpEventVector (but not the events therein); 1441 tmpEventVector[Types::kTraining].clear();; 1442 tmpEventVector[Types::kTesting].clear();; 1443 ; 1444 tmpEventVector[Types::kMaxTreeType].clear();; 1445 ; 1446 if (mixMode == ""RANDOM"") {; 1447 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""shuffling events""<<Endl;; 1448 ; 1449 std::shuffle(trainingEventVector->begin(), trainingEventVector->end(), rndm);; 1450 std::shuffle(testingEventVector->begin(), testingEventVector->end(), rndm);; 1451 }; 1452 ; 1453 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""trainingEventVector "" << trainingEventVector->size() << Endl;; 1454 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""testingEventVector "" << testingEventVector->size() << Endl;; 1455 ; 1456 // create dataset; 1457 DataSet* ds = new DataSet(dsi);; 1458 ; 1459 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal training tree"" << Endl;; 1460 ds->SetEventCollection(trainingEventVector, Types::kTraining );; 1461 // Log() << kINFO << Form(""Dataset[%s] : "",dsi.GetName()) << ""Create internal testing tree"" << Endl;; 1462 ds->SetEventCollection(te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:65618,clear,clear,65618,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"et abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-editable text viewer widget; TGTextViewStreamBuf Specialization of std::streambuf; TGTextViewostream Specialization of TGTextView and std::ostream; TGTileLayout Tile layout manager; TGToolBar A bar containing picture buttons; TGToolTip One or multiple lines help text; TGTransientFrame Frame for dialog (transient) windows; TGTreeLBEntry TGFSComboBox entry; TGTreeTable A TGTable that owns it's TTreeTableIngeface.; TGTripleHSlider Horizontal triple slider widget; TGTripleVSlider Vertical triple slider widget; TGUndockedFrame Undocked frame; TGUnknownWindowHandler Abstract event handler for unknown windows; TGVButtonGroup A button group with one vertical column; TGVFileSplitter A vertical file frame splitter; TGVProgressBar Vertical progress bar widget; TGVScrollBar Vertical scrollbar widget; TGVSlider",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:88526,simpl,simple,88526,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,2,['simpl'],['simple']
Usability,"et abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-editable text viewer widget; TGTileLayout Tile layout manager; TGToolBar A bar containing picture buttons; TGToolTip One or multiple lines help text; TGTransientFrame Frame for dialog (transient) windows; TGTreeLBEntry TGFSComboBox entry; TGTreeTable A TGTable that owns it's TTreeTableIngeface.; TGTripleHSlider Horizontal triple slider widget; TGTripleVSlider Vertical triple slider widget; TGUndockedFrame Undocked frame; TGUnknownWindowHandler Abstract event handler for unknown windows; TGVButtonGroup A button group with one vertical column; TGVFileSplitter A vertical file frame splitter; TGVProgressBar Vertical progress bar widget; TGVScrollBar Vertical scrollbar widget; TGVSlider Vertical slider widget; TGVSplitter A vertical frame splitter; TGVertical3DLine A vertical 3D separator line; TGVertic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html524/ClassIndex.html:79374,simpl,simple,79374,root/html524/ClassIndex.html,https://root.cern,https://root.cern/root/html524/ClassIndex.html,5,['simpl'],['simple']
Usability,"et abstract base class; TGSpeedo Base class for analog meter widget; TGSplitButton a split button widget; TGSplitFrame Splittable composite frame; TGSplitTool Split frame tool utility; TGSplitter A frame splitter abstract base class; TGStatusBar Status bar widget; TGString Graphics string; TGTRA GTRA shape; TGTab Tab widget; TGTabElement Little tab on tab widget; TGTabLayout Layout manager for TGTab widget; TGTable A table used to visualize data from diffent sources.; TGTableCell A single cell in a TGTable.; TGTableFrame A frame used internally by TGTable.; TGTableHeader Header for use in TGTable.; TGTableHeaderFrame A frame used internally by TGTable.; TGTableLayout Table layout manager; TGTableLayoutHints Class describing GUI table layout hints; TGText Text used by TGTextEdit; TGTextBuffer Text buffer used by widgets like TGTextEntry, etc.; TGTextButton A text button widget; TGTextEdit Text edit widget; TGTextEditor Simple text editor using TGTextEdit widget; TGTextEntry The TGTextEntry widget is a simple line editor for inputting text; TGTextLBEntry Text listbox entry; TGTextLayout Keep track of string measurement information.; TGTextLine Line in TGText; TGTextView Non-editable text viewer widget; TGTileLayout Tile layout manager; TGToolBar A bar containing picture buttons; TGToolTip One or multiple lines help text; TGTransientFrame Frame for dialog (transient) windows; TGTreeLBEntry TGFSComboBox entry; TGTripleHSlider Horizontal triple slider widget; TGTripleVSlider Vertical triple slider widget; TGUndockedFrame Undocked frame; TGUnknownWindowHandler Abstract event handler for unknown windows; TGVButtonGroup A button group with one vertical column; TGVFileSplitter A vertical file frame splitter; TGVProgressBar Vertical progress bar widget; TGVScrollBar Vertical scrollbar widget; TGVSlider Vertical slider widget; TGVSplitter A vertical frame splitter; TGVertical3DLine A vertical 3D separator line; TGVerticalFrame Composite frame with vertical child layout; TGVert",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:84288,simpl,simple,84288,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,1,['simpl'],['simple']
Usability,"et()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:3740,clear,clearEvalErrorLog,3740,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"et()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:4186,clear,clearEvalErrorLog,4186,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,et.h:649; TMVA::DNN::LayerData::gradientsBeginconst_iterator_type gradientsBegin() constreturns const iterator to the begin of the gradientsDefinition NeuralNet.h:604; TMVA::DNN::LayerData::inverseActivationFunctionstd::shared_ptr< std::function< double(double)> > inverseActivationFunction() constDefinition NeuralNet.h:608; TMVA::DNN::LayerData::deltasEnditerator_type deltasEnd()returns iterator to the end of the deltas (back-propagation)Definition NeuralNet.h:592; TMVA::DNN::LayerData::m_valueGradientsstd::vector< double > m_valueGradientsstores the gradients of the values (nodes)Definition NeuralNet.h:643; TMVA::DNN::LayerData::m_itConstWeightBeginconst_iterator_type m_itConstWeightBeginconst iterator to the first weight of this layer in the weight vectorDefinition NeuralNet.h:648; TMVA::DNN::LayerData::valueGradientsEnditerator_type valueGradientsEnd()returns iterator to the end of the gradients of the node valuesDefinition NeuralNet.h:598; TMVA::DNN::LayerData::clearvoid clear()clear the values and the deltasDefinition NeuralNet.h:576; TMVA::DNN::LayerData::activationFunctionstd::shared_ptr< std::function< double(double)> > activationFunction() constDefinition NeuralNet.h:607; TMVA::DNN::LayerData::computeProbabilitiescontainer_type computeProbabilities() constcompute the probabilities from the node valuesDefinition NeuralNet.cxx:140; TMVA::DNN::LayerData::deltasEndconst_iterator_type deltasEnd() constreturns const iterator to the end of the deltas (back-propagation)Definition NeuralNet.h:595; TMVA::DNN::LayerData::m_hasDropOutbool m_hasDropOutdropOut is turned on?Definition NeuralNet.h:646; TMVA::DNN::LayerData::m_isInputLayerbool m_isInputLayeris this layer an input layerDefinition NeuralNet.h:654; TMVA::DNN::LayerData::m_sizesize_t m_sizeDefinition NeuralNet.h:637; TMVA::DNN::LayerData::hasDropOutbool hasDropOut() consthas this layer drop-out turned on?Definition NeuralNet.h:622; TMVA::DNN::LayerData::valueGradientsBeginconst_iterator_type valueGradientsBegin,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:58910,clear,clearvoid,58910,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,3,['clear'],"['clear', 'clearvoid']"
Usability,"et<TTree>(""treeName"");; 287 ; 288RDataFrame d1(""treeName"", ""file.root"");; 289RDataFrame d2(""treeName"", f); // same as TTreeReader; 290RDataFrame d3(*t);; 291 ; 292// multiple files -- all constructors are equivalent; 293TChain chain(""myTree"");; 294chain.Add(""file1.root"");; 295chain.Add(""file2.root"");; 296 ; 297RDataFrame d4(""myTree"", {""file1.root"", ""file2.root""});; 298std::vector<std::string> files = {""file1.root"", ""file2.root""};; 299RDataFrame d5(""myTree"", files);; 300RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed as-is to TChain's constructor; 301RDataFrame d7(chain);; 302~~~; 303Additionally, users can construct an RDataFrame with no data source by passing an integer number. This is the number of rows that; 304will be generated by this RDataFrame.; 305~~~{.cpp}; 306RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now); 307d.Foreach([] { static int i = 0; std::cout << i++ << std::endl; }); // silly example usage: count to ten; 308~~~; 309This is useful to generate simple datasets on the fly: the contents of each event can be specified with Define() (explained below). For example, we have used this method to generate [Pythia](https://pythia.org/) events and write them to disk in parallel (with the Snapshot action).; 310 ; 311For data sources other than TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):; 312 ; 313~~~{.cpp}; 314auto df = ROOT::RDF::FromCSV(""input.csv"");; 315// use df as usual; 316~~~; 317 ; 318### Filling a histogram; 319Let's now tackle a very common task, filling a histogram:; 320~~~{.cpp}; 321// Fill a TH1D with the ""MET"" branch; 322RDataFrame d(""myTree"", ""file.root"");; 323auto h = d.Histo1D(""MET"");; 324h->Draw();; 325~~~; 326The first line creates an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"".; 327 ; 328Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be pre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:18458,simpl,simple,18458,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"et<TTree>(""treeName"");; 291 ; 292RDataFrame d1(""treeName"", ""file.root"");; 293RDataFrame d2(""treeName"", f); // same as TTreeReader; 294RDataFrame d3(*t);; 295 ; 296// multiple files -- all constructors are equivalent; 297TChain chain(""myTree"");; 298chain.Add(""file1.root"");; 299chain.Add(""file2.root"");; 300 ; 301RDataFrame d4(""myTree"", {""file1.root"", ""file2.root""});; 302std::vector<std::string> files = {""file1.root"", ""file2.root""};; 303RDataFrame d5(""myTree"", files);; 304RDataFrame d6(""myTree"", ""file*.root""); // the glob is passed as-is to TChain's constructor; 305RDataFrame d7(chain);; 306~~~; 307Additionally, users can construct an RDataFrame with no data source by passing an integer number. This is the number of rows that; 308will be generated by this RDataFrame.; 309~~~{.cpp}; 310RDataFrame d(10); // a RDF with 10 entries (and no columns/branches, for now); 311d.Foreach([] { static int i = 0; std::cout << i++ << std::endl; }); // silly example usage: count to ten; 312~~~; 313This is useful to generate simple datasets on the fly: the contents of each event can be specified with Define() (explained below). For example, we have used this method to generate [Pythia](https://pythia.org/) events and write them to disk in parallel (with the Snapshot action).; 314 ; 315For data sources other than TTrees and TChains, RDataFrame objects are constructed using ad-hoc factory functions (see e.g. FromCSV(), FromSqlite(), FromArrow()):; 316 ; 317~~~{.cpp}; 318auto df = ROOT::RDF::FromCSV(""input.csv"");; 319// use df as usual; 320~~~; 321 ; 322### Filling a histogram; 323Let's now tackle a very common task, filling a histogram:; 324~~~{.cpp}; 325// Fill a TH1D with the ""MET"" branch; 326RDataFrame d(""myTree"", ""file.root"");; 327auto h = d.Histo1D(""MET"");; 328h->Draw();; 329~~~; 330The first line creates an RDataFrame associated to the TTree ""myTree"". This tree has a branch named ""MET"".; 331 ; 332Histo1D() is an *action*; it returns a smart pointer (a ROOT::RDF::RResultPtr, to be pre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:18900,simpl,simple,18900,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"et<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvPdf.html:4871,clear,clearShapeDirty,4871,root/html532/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html532/RooNumConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"et<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:4871,clear,clearShapeDirty,4871,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"et<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooNumConvPdf.html:4871,clear,clearShapeDirty,4871,root/html530/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html530/RooNumConvPdf.html,1,['clear'],['clearShapeDirty']
Usability,"etElement*GetNextPacket(Long64_t totalEntries = -1); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual voidGetOptions(Int_t* argc, char** argv); const char*GetOrdinal() const; const char*GetPackageDir() const; const char*GetPrefix() const; TProof*GetProof() const; Int_tGetProtocol() const; Int_tGetQuerySeqNum() const; Float_tGetRealTime() const; static Long_tGetResMemMax(); const char*GetService() const; const char*GetSessionDir() const; const char*GetSessionTag() const; TSignalHandler*TApplication::GetSignalHandler() const; TSocket*GetSocket() const; virtual const char*TObject::GetTitle() const; const char*GetTopSessionTag() const; Int_tGetTotSessions() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetUser() const; static Long_tGetVirtMemMax(); const char*GetWorkDir() const; virtual TProofServ::EQueryActionGetWorkers(TList* workers, Int_t& prioritychange, Bool_t resume = kFALSE); virtual voidHandleException(Int_t sig); virtual voidTApplication::HandleIdleTimer()SIGNAL ; virtual voidHandleSigPipe(); virtual voidHandleSocketInput(); virtual Int_tHandleSocketInput(TMessage* mess, Bool_t all); virtual voidHandleTermination(); virtual Bool_tTApplication::HandleTermInput(); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual voidHandleUrgentData(); virtual Bool_tTQObject::HasConnection(const char* signal_name) const; virtual ULong_tTObject::Hash() const; virtual voidTApplication::Hide(); virtual voidTQObject::HighPriority(const char* signal_name, const char* slot_name = 0); virtual voidTApplication::Iconify(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual voidTApplication::Init(); voidTApplication::InitializeGraphics(); TObjArray*TApplication::InputFiles() const; virtual voidTObject::Ins",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:7090,resume,resume,7090,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,3,['resume'],['resume']
Usability,"etMin (const char *name, double value);  Set minimum of name range to given value. ;  ; void setMin (double value);  ; void setRange (const char *name, double min, double max);  Set a fit or plotting range. ;  ; void setRange (const char *name, RooAbsReal &min, RooAbsReal &max);  Set or modify a parameterised range, i.e., a range the varies in dependence of parameters. ;  ; void setRange (double min, double max);  Set the limits of the default range. ;  ; void setRange (RooAbsReal &min, RooAbsReal &max);  Set parameterised limits of the default range. See setRange(const char*, RooAbsReal&, RooAbsReal&). ;  ; void setVal (double value) override;  Set value of variable to 'value'. ;  ; void setVal (double value, const char *rangeName) override;  Set value of variable to value. ;  ; void Streamer (TBuffer &) override;  Stream an object of class RooRealVar. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; std::size_t valueResetCounter () const;  Returns how many times the value of this RooRealVar was reset. ;  ; void writeToStream (std::ostream &os, bool compact) const override;  Write object contents to given stream. ;  ;  Public Member Functions inherited from RooAbsRealLValue;  RooAbsRealLValue ();  ;  RooAbsRealLValue (const char *name, const char *title, const char *unit="""");  Constructor. ;  ;  RooAbsRealLValue (const RooAbsRealLValue &other, const char *name=nullptr);  Copy constructor. ;  ; TH1F * createHistogram (const char *name, const char *yAxisLabel) const;  Create an empty 1D-histogram with appropriate scale and labels for this variable. ;  ; TH1F * createHistogram (const char *name, const char *yAxisLabel, const RooAbsBinning &bins) const;  Create an empty 1D-histogram with appropriate scale and labels for this variable. ;  ; TH1F * ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:6015,simpl,simple,6015,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['simpl'],['simple']
Usability,"etPoint(0, (1*TMath::Pi())/4., 0.05);; 494 grP1->SetPoint(1, (2*TMath::Pi())/4., 0.10);; 495 grP1->SetPoint(2, (3*TMath::Pi())/4., 0.15);; 496 grP1->SetPoint(3, (4*TMath::Pi())/4., 0.20);; 497 grP1->SetPoint(4, (5*TMath::Pi())/4., 0.25);; 498 grP1->SetPoint(5, (6*TMath::Pi())/4., 0.30);; 499 grP1->SetPoint(6, (7*TMath::Pi())/4., 0.35);; 500 grP1->SetPoint(7, (8*TMath::Pi())/4., 0.40);; 501 ; 502 grP1->SetMarkerStyle(20);; 503 grP1->SetMarkerSize(1.);; 504 grP1->SetMarkerColor(4);; 505 grP1->SetLineColor(4);; 506 grP1->Draw(""ALP"");; 507 ; 508 // Update, otherwise GetPolargram returns 0; 509 c46->Update();; 510 grP1->GetPolargram()->SetToRadian();; 511}; 512End_Macro; 513 ; 514\anchor GrP5; 515### Colors automatically picked in palette; 516 ; 517\since **ROOT version 6.09/01**; 518 ; 519When several graphs are painted in the same canvas or when a multi-graph is drawn,; 520it might be useful to have an easy and automatic way to choose; 521their color. The simplest way is to pick colors in the current active color; 522palette. Palette coloring for histogram is activated thanks to the options `PFC`; 523(Palette Fill Color), `PLC` (Palette Line Color) and `PMC` (Palette Marker Color).; 524When one of these options is given to `TGraph::Draw` the graph get its color; 525from the current color palette defined by `gStyle->SetPalette(...)`. The color; 526is determined according to the number of objects having palette coloring in; 527the current pad.; 528 ; 529Begin_Macro(source); 530../../../tutorials/graphs/graphpalettecolor.C; 531End_Macro; 532 ; 533Begin_Macro(source); 534../../../tutorials/graphs/multigraphpalettecolor.C; 535End_Macro; 536 ; 537\anchor GrP6; 538### Reverse graphs' axis; 539 ; 540\since **ROOT version 6.09/03**; 541 ; 542When a TGraph is drawn, the X-axis is drawn with increasing values from left to; 543right and the Y-axis from bottom to top. The two options `RX` and `RY` allow to; 544change this order. The option `RX` allows to draw the X-axis with increa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:20558,simpl,simplest,20558,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['simpl'],['simplest']
Usability,"etROCIntegral(const UInt_t points=41)Calculates the ROC integral (AUC)Definition ROCCurve.cxx:248; TMVA::ROCCurve::GetROCCurveTGraph * GetROCCurve(const UInt_t points=100)Returns a new TGraph containing the ROC curve.Definition ROCCurve.cxx:274; TMVA::RankingRanking for variables in method (implementation)Definition Ranking.h:48; TMVA::Ranking::Printvirtual void Print() constget maximum length of variable namesDefinition Ranking.cxx:111; TMVA::ResultsClassificationClass that is the base-class for a vector of result.Definition ResultsClassification.h:48; TMVA::ResultsMulticlassClass which takes the results of a multiclass classification.Definition ResultsMulticlass.h:55; TMVA::ResultsClass that is the base-class for a vector of result.Definition Results.h:57; TMVA::Tools::FormattedOutputvoid FormattedOutput(const std::vector< Double_t > &, const std::vector< TString > &, const TString titleVars, const TString titleValues, MsgLogger &logger, TString format=""%+1.3f"")formatted output of simple tableDefinition Tools.cxx:887; TMVA::Tools::ROOTVersionMessagevoid ROOTVersionMessage(MsgLogger &logger)prints the ROOT release number and dateDefinition Tools.cxx:1325; TMVA::Tools::UsefulSortDescendingvoid UsefulSortDescending(std::vector< std::vector< Double_t > > &, std::vector< TString > *vs=nullptr)sort 2D vector (AND in parallel a TString vector) in such a way that the ""first vector is sorted"" and...Definition Tools.cxx:564; TMVA::Tools::SplitStringstd::vector< TString > SplitString(const TString &theOpt, const char separator) constsplits the option string at 'separator' and fills the list 'splitV' with the primitive stringsDefinition Tools.cxx:1199; TMVA::Tools::Colorconst TString & Color(const TString &)human readable color stringsDefinition Tools.cxx:828; TMVA::Tools::GetCorrelationMatrixconst TMatrixD * GetCorrelationMatrix(const TMatrixD *covMat)turns covariance into correlation matrixDefinition Tools.cxx:324; TMVA::Tools::kHtmlLink@ kHtmlLinkDefinition Tools.h:212; TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:133241,simpl,simple,133241,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['simpl'],['simple']
Usability,"etRefTable (TRefTable *table);  Static function setting the current TRefTable. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Protected Member Functions; Int_t AddInternalIdxForPID (TProcessID *procid);  Add the internal index for fProcessIDs, fAllocSize, etc given a PID. ;  ; virtual Int_t ExpandForIID (Int_t iid, Int_t newsize);  Expand fParentIDs to newsize for internel ProcessID index iid. ;  ; void ExpandPIDs (Int_t numpids);  Expand the arrays of managed PIDs. ;  ; Int_t FindPIDGUID (const char *guid) const;  Get fProcessGUIDs' index of the TProcessID with GUID guid. ;  ; Int_t GetInternalIdxForPID (Int_t pid) const;  Get the index for fProcessIDs, fAllocSize, etc given a PID. ;  ; Int_t GetInternalIdxForPID (TProcessID *procid) const;  Get the index for fProcessIDs, fAllocSize, etc given a PID. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Int_t * fAllocSize;  number of known ProcessIDs ;  ; Int_t fDefaultSize;  current parent ID in fParents (latest call to SetParent) ;  ; std::vector< Int_t > fMapPIDtoInternal;  ; Int_t * fN;  [fNumPIDs] allocated size of array fParentIDs for each ProcessID ;  ; Int_t fNumPIDs;  ; TObject * fOwner;  ; Int_t fParentID;  [fNumPIDs][fAllocSize] array of Parent IDs ;  ; Int_t ** fParentIDs;  [fNumPIDs] current maximum number of IDs in array fParentIDs for each ProcessID ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRefTable.html:12734,guid,guid,12734,doc/master/classTRefTable.html,https://root.cern,https://root.cern/doc/master/classTRefTable.html,2,['guid'],['guid']
Usability,"etTime(ms);; 68 }; 69 Bool_t IsSlow() const { return fSlow; }; 70 ; 71 /// timeout handler; 72 /// used to process http requests in main ROOT thread; 73 void Timeout() override; 74 {; 75 Int_t nprocess = fServer.ProcessRequests();; 76 ; 77 if (nprocess > 0) {; 78 fSlowCnt = 0;; 79 if (IsSlow()); 80 SetSlow(kFALSE);; 81 } else if (!IsSlow() && (fSlowCnt++ > 10)) {; 82 SetSlow(kTRUE);; 83 }; 84 }; 85};; 86 ; 87 ; 88/** \class THttpServer; 89\ingroup http; 90 ; 91Online http server for arbitrary ROOT application; 92 ; 93Idea of THttpServer - provide remote http access to running; 94ROOT application and enable HTML/JavaScript user interface.; 95Any registered object can be requested and displayed in the browser.; 96There are many benefits of such approach:; 97 ; 981. standard http interface to ROOT application; 992. no any temporary ROOT files when access data; 1003. user interface running in all browsers; 101 ; 102To start http server simply create instance; 103of the THttpServer class like:; 104 ; 105 serv = new THttpServer(""http:8080"");; 106 ; 107This will starts civetweb-based http server with http port 8080.; 108Than one should be able to open address ""http://localhost:8080""; 109in any modern web browser (Firefox, Chrome, Opera, ...) and browse objects,; 110created in ROOT application. By default, server can access files,; 111canvases and histograms via `gROOT` pointer. All such objects; 112can be displayed with JSROOT graphics.; 113 ; 114At any time one could register other objects with the command:; 115 ; 116 TGraph* gr = new TGraph(10);; 117 gr->SetName(""gr1"");; 118 serv->Register(""graphs/subfolder"", gr);; 119 ; 120If objects content is changing in the application, one could; 121enable monitoring flag in the browser - than objects view; 122will be regularly updated.; 123 ; 124More information: https://root.cern/root/htmldoc/guides/HttpServer/HttpServer.html; 125*/; 126 ; 127ClassImp(THttpServer);; 128 ; 129/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:2805,simpl,simply,2805,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['simpl'],['simply']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQCommand(const TQCommand& com); TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:2752,undo,undo,2752,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. TQUndoManager(); virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:2751,undo,undo,2751,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,4,['undo'],['undo']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQCommand(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:2776,undo,undo,2776,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,2,['undo'],['undo']
Usability,"etUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo to undo commands in history list.; Redo is Undo for undo action. Use TQUndoManager::Redo method for that. Function Members (Methods); public:. virtual~TQUndoManager(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAdd(TObject* obj, Option_t* opt); virtual voidTList::AddAfter(const TObject* after, TObject* obj); virtual voidTList::AddAfter(TObjLink* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidTList::AddAt(TObject* obj, Int_t idx); virtual voidTList::AddBefore(const TObject* before, TObject* obj); virtual voidTList::AddBefore(TObjLink* before, TObject* obj); virtual voidTList::AddFirst(TObject* obj); vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:2775,undo,undo,2775,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,2,['undo'],['undo']
Usability,"etWeightGradientsAt (size_t i);  ; const Matrix_t & GetWeightGradientsAt (size_t i) const;  ; std::vector< Matrix_t > & GetWeights ();  ; const std::vector< Matrix_t > & GetWeights () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:7455,learn,learningRate,7455,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"eta, phi);; 234 auto particle = new TParticle(0, 0, 0, 0, 0, 0,; 235 px, py, pz, std::sqrt(px*px + py*py + pz*pz + 80*80),; 236 0, 0, 0, 0 );; 237 ; 238 int pdg = 11 * (r.Integer(2) > 0 ? 1 : -1);; 239 particle->SetPdgCode(pdg);; 240 ; 241 list->Add(particle);; 242 }; 243 fListData.push_back(list);; 244 }; 245 ; 246 void MakeRecHits(int N); 247 {; 248 TRandom &r = *gRandom;; 249 r.SetSeed(0);; 250 TList* list = new TList();; 251 list->SetName(""RecHits"");; 252 ; 253 for (int i = 1; i <= N; ++i); 254 {; 255 float pt = r.Uniform(0.5, 10);; 256 float x = r.Uniform(-200, 200);; 257 float y = r.Uniform(-200, 200);; 258 float z = r.Uniform(-500, 500);; 259 auto rechit = new RecHit(pt, x, y, z);; 260 list->Add(rechit);; 261 }; 262 fListData.push_back(list);; 263 }; 264 ; 265 void Clear(); 266 {; 267 for (auto &l : fListData); 268 delete l;; 269 fListData.clear();; 270 }; 271 ; 272 void Create(); 273 {; 274 Clear();; 275 MakeJets(4);; 276 MakeParticles(100);; 277 MakeRecHits(20);; 278 ; 279 // refill calo data from jet list; 280 TList* jlist = fListData[0];; 281 TList* elist = new TList();; 282 elist->SetName(""ECAL"");; 283 fListData.push_back(elist);; 284 TList* hlist = new TList();; 285 hlist->SetName(""HCAL"");; 286 fListData.push_back(hlist);; 287 for (int i = 0; i <= jlist->GetLast(); ++i) {; 288 const Jet* j = (Jet*)jlist->At(i);; 289 float offX = j->Eta();; 290 float offY = j->Phi() > TMath::Pi() ? j->Phi() - TMath::TwoPi() : j->Phi();; 291 for (int k=0; k<20; ++k) {; 292 double x, y, v;; 293 x = gRandom->Uniform(-j->GetEtaSize(), j->GetEtaSize());; 294 y = gRandom->Uniform(-j->GetPhiSize(),j->GetPhiSize());; 295 v = j->Pt();; 296 auto etower = new RCaloTower(offX + x, offY + y, v + gRandom->Uniform(2,3));; 297 elist->Add(etower);; 298 auto htower = new RCaloTower(offX + x, offY + y, v + gRandom->Uniform(1,2));; 299 hlist->Add(htower);; 300 }; 301 }; 302 fCaloData->DataChanged();; 303 eventId++;; 304 }; 305};; 306 ; 307 ; 308//=============================================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/collection__proxies_8C_source.html:8751,clear,clear,8751,doc/master/collection__proxies_8C_source.html,https://root.cern,https://root.cern/doc/master/collection__proxies_8C_source.html,1,['clear'],['clear']
Usability,"etail described in [4], [5]. It allows to identify automatically the peaks in a spectrum with the presence of the continuous background and statistical fluctuations - noise. The algorithm is based on smoothed second differences that are compared to its standard deviations. Therefore it is necessary to pass a parameter of sigma to the peak searching function. The algorithm is selective to the peaks with the given sigma. The form of the basic peak searching function is; Int-t Search1(const float *spectrum,; int size,; double sigma);; This function searches for peaks in source spectrum. The number of found peaks and their positions are written into structure pointed by one_dim_peak structure pointer.; Function parameters:. source pointer to the vector of source spectrum; p pointer to the one_dim_peak structure pointer; size length of source spectrum; sigma sigma of searched peaks. The structure one_dim_peak has the form:; struct one_dim_peak{; int number_of_peaks;; double position[MAX_NUMBER_OF_PEAKS1];; };; An example of simple one-dimensional spectrum with identified peaks is given in Figure 3.1. Simple one-dimensional spectrum with identified peaks. An example of 1-dimensional experimental spectrum with many identified peaks is given in Figure 3.2. 1-dimensional experimental spectrum with many identified peaks. However when we have noisy data the number of peaks can be enormous. One such an example is given in Figure 3.3. Therefore it can be useful to have possibility to set a threshold value and to consider only the peaks higher than this threshold (see Figure 3.4, only three peaks were identified, threshold=50.) The value in the center of the peak value[i] minus the average value in two symmetrically positioned channels (channels i-3*sigma, i+3*sigma) must be greater than threshold. Otherwise the peak is ignored. With noisy data the number of peaks can be enormous. Iwth threshold=50, only three peaks were identified. An alternative approach was proposed in [6].. T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:16471,simpl,simple,16471,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"eteParameters(const char* wildcard); Delete the input list parameters specified by a wildcard (e.g. PROOF_*); or exact name (e.g. PROOF_MaxSlavesPerNode). void ShowParameters(const char* wildcard = ""PROOF_*"") const; Show the input list parameters specified by the wildcard.; Default is the special PROOF control parameters (PROOF_*). void AddFeedback(const char* name); Add object to feedback list. void RemoveFeedback(const char* name); Remove object from feedback list. void ClearFeedback(); Clear feedback list. void ShowFeedback() const; Show items in feedback list. TList * GetFeedbackList() const; Return feedback list. TTree * GetTreeHeader(TDSet* tdset); Creates a tree header (a tree with nonexisting files) object for; the DataSet. TDrawFeedback * CreateDrawFeedback(); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. TList * GetOutputNames(); FIXME: to be written. void Browse(TBrowser* b); Build the PROOF's structure in the browser. void SetPlayer(TVirtualProofPlayer* player); Set a new PROOF player. TVirtualProofPlayer * MakePlayer(const char* player = 0, TSocket* s = 0); Construct a TProofPlayer object. The player string specifies which; player should be created: remote, slave, sm (supermaster) or base.; Default is remote. Socket is needed in case a slave player is created. void AddChain(TChain* chain); Add chain to data set. void RemoveChain(TChain* chain); Remove chain from data set. void GetLog(Int_t start = -1, Int_t end = -1); Ask for remote logs in the range [start, end]. If start == -1 all the; messages not yet received are sent back. TMacro * GetLastLog(); Fill a TMacro with the log lines since the last reading (fLogFileR); Return (TMacro *)0 if no line was logged.; The returned TMacro must be deleted by the caller. void PutLog(TQueryResult* qr); Displ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:75207,feedback,feedback,75207,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,['feedback'],['feedback']
Usability,"ethod Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Analysis of PDEFoam discriminant (PDEFoam or Mahalanobis approach); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::OptimizeCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ClassIndex.html:100783,simpl,simple,100783,root/html528/ClassIndex.html,https://root.cern,https://root.cern/root/html528/ClassIndex.html,2,['simpl'],['simple']
Usability,"ethod Interface; TMVA::Interval Interval definition, continous and discrete; TMVA::KDEKernel Kernel density estimator for PDF smoothing; TMVA::MCFitter Fitter using Monte Carlo sampling of parameters ; TMVA::MethodANNBase Base class for TMVA ANNs; TMVA::MethodBDT Analysis of Boosted Decision Trees; TMVA::MethodBase Virtual base class for all TMVA method; TMVA::MethodBayesClassifier Friedman's BayesClassifier method ; TMVA::MethodBoost ; TMVA::MethodCFMlpANN Interface for Clermond-Ferrand artificial neural network; TMVA::MethodCFMlpANN_Utils Implementation of Clermond-Ferrand artificial neural network; TMVA::MethodCategory ; TMVA::MethodCommittee Analysis of Boosted MVA methods; TMVA::MethodCompositeBase ; TMVA::MethodCuts Multivariate optimisation of signal efficiency; TMVA::MethodDT Analysis of Decision Trees ; TMVA::MethodFDA Function Discriminant Analysis; TMVA::MethodFisher Analysis of Fisher discriminant (Fisher or Mahalanobis approach) ; TMVA::MethodHMatrix H-Matrix method, a simple comparison of chi-squared estimators for signal and background; TMVA::MethodKNN k Nearest Neighbour classifier; TMVA::MethodLD Linear discriminant analysis; TMVA::MethodLikelihood Likelihood analysis (""non-parametric approach"") ; TMVA::MethodMLP Multi-layer perceptron implemented specifically for TMVA; TMVA::MethodPDEFoam Multi-dimensional probability density estimator using TFoam (PDE-Foam); TMVA::MethodPDERS Multi-dimensional probability density estimator range search (PDERS) method; TMVA::MethodRuleFit Friedman's RuleFit method; TMVA::MethodSVM Support Vector Machine; TMVA::MethodTMlpANN Implementation of interface for TMultiLayerPerceptron; TMVA::MinuitFitter Fitter using a Genetic Algorithm; TMVA::MinuitWrapper Wrapper around TMinuit; TMVA::MisClassificationError Implementation of the MisClassificationError as separation criterion; TMVA::MsgLogger Ostringstream derivative to redirect and format logging output; TMVA::Node Node for the BinarySearch or Decision Trees; TMVA::Optimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:101971,simpl,simple,101971,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,4,['simpl'],['simple']
Usability,"ethod for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf709_BarlowBeeston.py;   Implementing the Barlow-Beeston method for taking into account the statistical uncertainty of a Monte-Carlo fit template. ;  ; file  rf710_roopoly.C;   Taylor expansion of RooFit functions using the taylorExpand function with RooPolyFunc ;  ; file  rf710_roopoly.py;   Taylor expansion of RooFit functions using the taylorExpand function ;  ; file  rf711_lagrangianmorph.C;   Morphing effective field theory distributions with RooLagrangianMorphFunc A morphing function as a function of one coefficient is setup and can be used to obtain the distribution for any value of the coefficient. ;  ; file  rf711_lagrangianmorph.py;   Morphing effective field theory distributions with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.C;   Performing a simple fit with RooLagrangianMorphFunc. ;  ; file  rf712_lagrangianmorphfit.py;   Performing a simple fit with RooLagrangianMorphFunc ;  ; file  rf801_mcstudy.C;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf801_mcstudy.py;   Validation and MC studies: toy Monte Carlo study that perform cycles of event generation and fitting ;  ; file  rf802_mcstudy_addons.C;   Validation and MC studies: RooMCStudy - using separate fit and generator models, using the chi^2 calculator model Running a biased fit model against an optimal fit. ;  ; file  rf803_mcstudy_addons2.C;   Validation and MC studies: RooMCStudy - Using the randomizer and profile likelihood add-on models ;  ; file  rf804_mcstudy_constr.C;   Validation and MC studies: using RooMCStudy on models with constrains ;  ; file  rf901_numintconfig.C;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are executed ;  ; file  rf901_numintconfig.py;   Numeric algorithm tuning: configuration and customization of how numeric (partial) integrals are ex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__roofit.html:22768,simpl,simple,22768,doc/master/group__tutorial__roofit.html,https://root.cern,https://root.cern/doc/master/group__tutorial__roofit.html,1,['simpl'],['simple']
Usability,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7352 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7353 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7354 ""TQClass"", ""TGlobal"" };; 7355 ; 7356 if (cname && cname[0]) {; 7357 for (auto cursor : handVerified) {; 7358 if (strcmp(cname, cursor) == 0); 7359 return true;; 7360 }; 7361 }; 7362 return false;; 7363}; 7364 ; 7365////////////////////////////////////////////////////////////////////////////////; 7366/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7367/// classes in the class hierarchy that overload TObject::Hash do call; 7368/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7369/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7370 ; 7371Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7372{; 7373 return clRef.HasConsistentHashMember();; 7374}; 7375 ; 7376////////////////////////////////////////////////////////////////////////////////; 7377/// Return true if we have access to a constructor usable for I/O. This is; 7378/// typically the default constructor but can also be a constructor specifically; 7379/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7380/// argument). In other words, if this routine returns true, TClass::New is; 7381/// guarantee to succeed.; 7382/// To know if the class described by this TClass has a default constructor; 7383/// (public or not), use; 7384/// \code{.cpp}; 7385/// cl->GetProperty() & kClassHasDefaultCtor; 7386/// \endcode; 7387/// To know if the class described by this TClass has a public default; 7388/// constructor use:; 7389/// \code{.cpp}; 7390/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7391/// \endcode; 7392 ; 7393Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7394{; 7395 ; 7396 if (fNew) return kTRUE;; 7397 ; 7398 if (HasInterpreterInfo()) {; 7399 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:283369,usab,usable,283369,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['usab'],['usable']
Usability,"ethod"", ""ROOT::Internal::TCheckHashRecursiveRemoveConsistency"",; 7419 ""TCheckHashRecursiveRemoveConsistency"", ""TGWindow"",; 7420 ""TDirectory"", ""TDirectoryFile"", ""TObject"", ""TH1"",; 7421 ""TQClass"", ""TGlobal"" };; 7422 ; 7423 if (cname && cname[0]) {; 7424 for (auto cursor : handVerified) {; 7425 if (strcmp(cname, cursor) == 0); 7426 return true;; 7427 }; 7428 }; 7429 return false;; 7430}; 7431 ; 7432////////////////////////////////////////////////////////////////////////////////; 7433/// Return true is the Hash/RecursiveRemove setup is consistent, i.e. when all; 7434/// classes in the class hierarchy that overload TObject::Hash do call; 7435/// ROOT::CallRecursiveRemoveIfNeeded in their destructor.; 7436/// i.e. it is safe to call the Hash virtual function during the RecursiveRemove operation.; 7437 ; 7438Bool_t ROOT::Internal::HasConsistentHashMember(TClass &clRef); 7439{; 7440 return clRef.HasConsistentHashMember();; 7441}; 7442 ; 7443////////////////////////////////////////////////////////////////////////////////; 7444/// Return true if we have access to a constructor usable for I/O. This is; 7445/// typically the default constructor but can also be a constructor specifically; 7446/// marked for I/O (for example a constructor taking a TRootIOCtor* as an; 7447/// argument). In other words, if this routine returns true, TClass::New is; 7448/// guarantee to succeed.; 7449/// To know if the class described by this TClass has a default constructor; 7450/// (public or not), use; 7451/// \code{.cpp}; 7452/// cl->GetProperty() & kClassHasDefaultCtor; 7453/// \endcode; 7454/// To know if the class described by this TClass has a public default; 7455/// constructor use:; 7456/// \code{.cpp}; 7457/// gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; 7458/// \endcode; 7459 ; 7460Bool_t TClass::HasDefaultConstructor(Bool_t testio) const; 7461{; 7462 ; 7463 if (fNew) return kTRUE;; 7464 ; 7465 if (HasInterpreterInfo()) {; 7466 R__LOCKGUARD(gInterpreterMutex);;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:286120,usab,usable,286120,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['usab'],['usable']
Usability,"ethod. A virtual initGenerator() method is also called just before the; first call to generateEvent(). void initGenerator(const RooArgSet& theEvent); Interface function to initialize context for generation for given; set of observables. void printName(ostream& os) const; Print name of context. void printTitle(ostream& os) const; Print title of context. void printClassName(ostream& os) const; Print class name of context. void printArgs(ostream& os) const; Print arguments of context, i.e. the observables being generated in this context. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Interface for multi-line printing. void setProtoDataOrder(Int_t* lut); Set the traversal order of prototype data to that in the lookup tables; passed as argument. The LUT must be an array of integers with the same; size as the number of entries in the prototype dataset and must contain; integer values in the range [0,Nevt-1]. void resampleData(Double_t& ratio); Rescale existing output buffer with given ratio. Int_t defaultPrintContents(Option_t* opt) const; Define default contents when printing. RooPrintable::StyleOption defaultPrintStyle(Option_t* opt) const; Define default print style. RooAbsGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE). Bool_t isValid() const; If true generator context is in a valid state. void setVerbose(Bool_t verbose = kTRUE); Set/clear verbose messaging. Bool_t isVerbose() const; If true verbose messaging is active. void Print(Option_t* options = 0) const; Print context information on stdout. void setExpectedData(Bool_t ); {}. void generateEvent(RooArgSet& theEvent, Int_t remaining). » Last changed: Tue Jun 30 14:30:07 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsGenContext.html:12108,clear,clear,12108,root/html602/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html602/RooAbsGenContext.html,1,['clear'],['clear']
Usability,ethods); public:. TGeoIterator(TGeoVolume* top); TGeoIterator(const TGeoIterator& iter); virtual~TGeoIterator(); static TClass*Class(); const TGeoMatrix*GetCurrentMatrix() const; Int_tGetIndex(Int_t i) const; Int_tGetLevel() const; TGeoNode*GetNode(Int_t level) const; voidGetPath(TString& path) const; TGeoVolume*GetTopVolume() const; Int_tGetType() const; TGeoIteratorPlugin*GetUserPlugin() const; virtual TClass*IsA() const; TGeoNode*Next(); TGeoNode*operator()(); TGeoIterator&operator=(const TGeoIterator& iter); voidReset(TGeoVolume* top = 0); voidSetPluginAutoexec(Bool_t mode); voidSetTopName(const char* name); voidSetType(Int_t type); voidSetUserPlugin(TGeoIteratorPlugin* plugin); virtual voidShowMembers(TMemberInspector& insp); voidSkip(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. TGeoIterator(). private:. voidIncreaseArray(). Data Members; private:. Int_t*fArrayArray of node indices for the current path; Int_tfLevelCurrent level in the tree; TGeoHMatrix*fMatrixCurrent global matrix; Bool_tfMustResumePrivate flag to resume from current node.; Bool_tfMustStopPrivate flag to signal that the iterator has finished.; TGeoIteratorPlugin*fPluginUser iterator plugin; Bool_tfPluginAutoexecPlugin automatically executed during next() ; TGeoVolume*fTopTop volume of the iterated branch; TStringfTopNameUser name for top; Int_tfTypeType of iteration. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoIterator(TGeoVolume* top); Geometry iterator for a branch starting with a TOP node. TGeoIterator(const TGeoIterator& iter); Copy ctor. ~TGeoIterator(); Destructor. TGeoIterator & operator=(const TGeoIterator& iter); Assignment. TGeoNode * Next(); Returns next node. TGeoNode * operator()(); Returns next node. const TGeoMatrix * GetCurrentMatrix() const; Returns global matrix for current node. TGeoNode * GetNode(Int_t level) const; Returns current node at a given level. void GetPath(TString& path) const;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoIterator.html:4319,resume,resume,4319,root/html528/TGeoIterator.html,https://root.cern,https://root.cern/root/html528/TGeoIterator.html,3,['resume'],['resume']
Usability,"eturn a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Static Public Attributes; static constexpr value_type NoCatIdx = std::numeric_limits<value_type>::min();  . Protected Member Functions; value_type evaluate () const override;  Evaluate the category state and return. ;  ; const RooMappedCategoryCache * getOrCreateCache () const;  ; void recomputeShape () override;  When the input category changes states, the cached state mappings are invalidated. ;  ;  Protected Member Functions inherited from RooAbsCategory; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach the category index and label as branches to the given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  Attach the category index and label to as branches to the given vector store. ;  ; void clearTypes ();  Delete all currently defined states. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValueDirty=true) override;  Copy the cached value from given source and raise dirty flag. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label);  Define a new state with given label. ;  ; virtual const std::map< std::string, RooAbsCategory::value_type >::value_type & defineState (const std::string &label, value_type index);  Define new state with given name and index number. ;  ; void defineStateUnchecked (const std::string &label, value_type index);  Internal version of defineState() that does not check if type already exists. ;  ; void fillTreeBranch (TTree &t) override;  Fill tree branches associated with current object with current value. ;  ; bool isValid () const override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; RooCatType * retrieveLegacyState (value_ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:35627,clear,clearTypes,35627,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['clear'],['clearTypes']
Usability,"eturn an asymmetric and non-zero lower; error for the case b1=b2. The function return kFALSE if the divide operation failed. void Draw(Option_t* option = """"); Draw this histogram with options. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See the THistPainter class for a description of all the drawing options. TH1 * DrawCopy(Option_t* option = """") const; -*-*-*-*-*Copy this histogram and Draw in the current pad*-*-*-*-*-*-*-*. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object. See Draw for the list of options. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1 * DrawNormalized(Option_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:65438,clear,clears,65438,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,1,['clear'],['clears']
Usability,"eturn an asymmetric and non-zero lower; error for the case b1=b2. The function return kFALSE if the divide operation failed. void Draw(Option_t* option = """"); Draw this histogram with options. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; When an histogram drawn in a pad is deleted, the histogram is; automatically removed from the pad or pads where it was drawn.; If an histogram is drawn in a pad, then filled again, the new status; of the histogram will be automatically shown in the pad next time; the pad is updated. One does not need to redraw the histogram.; To draw the current version of an histogram in a pad, one can use; h->DrawCopy();; This makes a clone of the histogram. Once the clone is drawn, the original; histogram may be modified or deleted without affecting the aspect of the; clone.; By default, TH1::Draw clears the current pad. One can use TH1::SetMaximum and TH1::SetMinimum to force a particular; value for the maximum or the minimum scale on the plot. TH1::UseCurrentStyle can be used to change all histogram graphics; attributes to correspond to the current selected style.; This function must be called for each histogram.; In case one reads and draws many histograms from a file, one can force; the histograms to inherit automatically the current graphics style; by calling before gROOT->ForceStyle();. See the THistPainter class for a description of all the drawing options. TH1 * DrawCopy(Option_t* option = """", const char* name_postfix = ""_copy"") const; Copy this histogram and Draw in the current pad. Once the histogram is drawn into the pad, any further modification; using graphics input will be made on the copy of the histogram,; and not to the original object.; By default a postfix ""_copy"" is added to the histogram name. Pass an empty postfix in case; you want to draw an histogram with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:66608,clear,clears,66608,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,2,['clear'],['clears']
Usability,"eturns the previous block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void DoRedraw () override;  Draw horizontal progress bar. ;  ;  Protected Member Functions inherited from TGFrame; virtual void Draw3dRectangle (UInt_t type, Int_t x, Int_t y, UInt_t w, UInt_t h);  Draw 3D rectangle on the frame border. ;  ; TString GetOptionString () const;  Returns a frame option string - used in SavePrimitive(). ;  ; const TGResourcePool * GetResourcePool () const;  ; void * GetSender () override;  ; virtual void StartGuiBuilding (Bool_t on=kTRUE);  Go into GUI building mode. ;  ;  Protected Member Functions inherited from TGWindow;  TGWindow (const TGWindow &tgw);  ;  TGWindow (Window_t id);  ; TGWindow & operator= (const TGWindow &tgw);  ;  Protected Member Functions inherited from TGObject; TGObject & operator= (const TGObject &tgo);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inher",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:24201,progress bar,progress bar,24201,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"euron, separated by comas. Hidden layers are just described; by the number of neurons. The layers are separated by colons.; In addition, input/output layer formulas can be preceded by '@' (e.g ""@out""); if one wants to also normalize the data from the TTree.; Input and outputs are taken from the TTree given as second argument.; Expressions are evaluated as for TTree::Draw(), arrays are expended in; distinct neurons, one for each index.; This can only be done for fixed-size arrays.; If the formula ends with ""!"", softmax functions are used for the output layer.; One defines the training and test datasets by TEventLists. Example:; TMultiLayerPerceptron(""x,y:10:5:f"",inputTree);; Both the TTree and the TEventLists can be defined in; the constructor, or later with the suited setter method. The lists; used for training and test can be defined either explicitly, or via; a string containing the formula to be used to define them, exactly as; for a TCut.; The learning method is defined using the; TMultiLayerPerceptron::SetLearningMethod() . Learning methods are :; TMultiLayerPerceptron::kStochastic, ; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS; A weight can be assigned to events, either in the constructor, either; with TMultiLayerPerceptron::SetEventWeight(). In addition, the TTree weight; is taken into account.; Finally, one starts the training with; TMultiLayerPerceptron::Train(Int_t nepoch, Option_t* options). The; first argument is the number of epochs while option is a string that; can contain: ""text"" (simple text output) , ""graph""; (evoluting graphical training curves), ""update=X"" (step for; the text/graph output update) or ""+"" (will skip the; randomisation and start from the previous values). All combinations; are available. . Example:; net.Train(100,""text, graph, update=10"").; When the neural net is trained, it can be used; directly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:7355,learn,learning,7355,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['learn'],['learning']
Usability,"evel combination. Int_t activeStream(const RooAbsArg* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. Int_t activeStream(const TObject* self, RooFit::MsgTopic topic, RooFit::MsgLevel level); Find appropriate logging stream for message from given object with given topic and message level. ostream& log(const RooAbsArg* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with RooAbsArg object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. ostream& log(const TObject* self, RooFit::MsgLevel level, RooFit::MsgTopic topic, Bool_t skipPrefix); Log error message associated with TObject object self at given level and topic. If skipPrefix; is true the standard RooMsgService prefix is not added. void Print(Option_t* options = 0) const; Print configuration of message service. If ""v"" option is given also; inactive streams are listed. StreamConfig& getStream(Int_t id); { return _streams[id] ; }. Int_t numStreams() const; { return _streams.size() ; }. void reset(); { cleanup() ; }. void setGlobalKillBelow(RooFit::MsgLevel level); { _globMinLevel = level ; }. RooFit::MsgLevel globalKillBelow() const; { return _globMinLevel ; }. void showPid(Bool_t flag); { _showPid = flag ; }. Bool_t silentMode() const; Print level support for RooFit-related messages that are not routed through RooMsgService (such as Minuit printouts). { return _silentMode ; }. void setSilentMode(Bool_t flag); { _silentMode = flag ; }. Int_t errorCount() const; { return _errorCount ; }. void clearErrorCount(); { _errorCount = 0 ; }. RooMsgService(); Private ctor -- singleton class. » Last changed: Mon Dec 7 13:48:17 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooMsgService.html:12194,clear,clearErrorCount,12194,root/html526/RooMsgService.html,https://root.cern,https://root.cern/root/html526/RooMsgService.html,1,['clear'],['clearErrorCount']
Usability,"evel=99);  Add a new branch, and infer the data type from the array addobj being passed. ;  ; template<class T > ; TBranch * Branch (const char *name, T *obj, Int_t bufsize=32000, Int_t splitlevel=99);  Add a new branch, and infer the data type from the type of obj being passed. ;  ; virtual TBranch * BranchRef ();  Build the optional branch supporting the TRefTable. ;  ; void Browse (TBrowser *) override;  Browse content of the TTree. ;  ; virtual Int_t BuildIndex (const char *majorname, const char *minorname=""0"");  Build a Tree Index (default is TTreeIndex). ;  ; TStreamerInfo * BuildStreamerInfo (TClass *cl, void *pointer=nullptr, bool canOptimize=true);  Build StreamerInfo for class cl. ;  ; virtual TFile * ChangeFile (TFile *file);  Called by TTree::Fill() when file has reached its maximum fgMaxTreeSize. ;  ; virtual TTree * CloneTree (Long64_t nentries=-1, Option_t *option="""");  Create a clone of this tree and copy nentries. ;  ; virtual void CopyAddresses (TTree *, bool undo=false);  Set branch addresses of passed tree equal to ours. ;  ; virtual Long64_t CopyEntries (TTree *tree, Long64_t nentries=-1, Option_t *option="""", bool needCopyAddresses=false);  Copy nentries from given tree to this tree. ;  ; virtual TTree * CopyTree (const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Copy a tree with selection. ;  ; Int_t Debug () const;  ; void Delete (Option_t *option="""") override;  Delete this tree from memory or/and disk. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Called by TKey and TObject::Clone to automatically add us to a directory when we are read from a file. ;  ; virtual Long64_t Draw (const char *varexp, const char *selection, Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Draw expression varexp for entries and objects that pass a (optional) selection. ;  ; virtual Long64_t Draw (const char *varexp, const TCut &selection, Option_t *option="""", Long64_t nentries=kMaxEn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeSQL.html:6095,undo,undo,6095,doc/master/classTTreeSQL.html,https://root.cern,https://root.cern/doc/master/classTTreeSQL.html,1,['undo'],['undo']
Usability,"eventn;; 316 ; 317 // Create a ROOT Tree; 318 TTree tree(""T"",""An example of ROOT tree with a few branches"");; 319 tree.Branch(""point"",&point,""x:y:z"");; 320 tree.Branch(""eventn"",&eventn,""ntrack/I:nseg:nvertex:flag/i:temperature/F"");; 321 tree.Branch(""hpx"",""TH1F"",&hpx,128000,0);; 322 ; 323 Float_t px,py,pz;; 324 ; 325 // Here we start a loop on 1000 events; 326 for ( Int_t i=0; i<1000; i++) {; 327 gRandom->Rannor(px,py);; 328 pz = px*px + py*py;; 329 const auto random = gRandom->::Rndm(1);; 330 ; 331 // Fill histograms; 332 hpx.Fill(px);; 333 hpxpy.Fill(px,py,1);; 334 hprof.Fill(px,pz,1);; 335 ; 336 // Fill structures; 337 point.x = 10*(random-1);; 338 point.y = 5*random;; 339 point.z = 20*random;; 340 eventn.ntrack = Int_t(100*random);; 341 eventn.nseg = Int_t(2*eventn.ntrack);; 342 eventn.nvertex = 1;; 343 eventn.flag = Int_t(random+0.5);; 344 eventn.temperature = 20+random;; 345 ; 346 // Fill the tree. For each event, save the 2 structures and 3 objects; 347 // In this simple example, the objects hpx, hprof and hpxpy are slightly; 348 // different from event to event. We expect a big compression factor!; 349 tree->Fill();; 350 }; 351 // End of the loop; 352 ; 353 tree.Print();; 354 ; 355 // Save all objects in this file; 356 hfile.Write();; 357 ; 358 // Close the file. Note that this is automatically done when you leave; 359 // the application upon file destruction.; 360 hfile.Close();; 361 ; 362 return 0;; 363}; 364~~~; 365*/; 366 ; 367#include <ROOT/RConfig.hxx>; 368#include ""TTree.h""; 369 ; 370#include ""ROOT/TIOFeatures.hxx""; 371#include ""TArrayC.h""; 372#include ""TBufferFile.h""; 373#include ""TBaseClass.h""; 374#include ""TBasket.h""; 375#include ""TBranchClones.h""; 376#include ""TBranchElement.h""; 377#include ""TBranchObject.h""; 378#include ""TBranchRef.h""; 379#include ""TBrowser.h""; 380#include ""TClass.h""; 381#include ""TClassEdit.h""; 382#include ""TClonesArray.h""; 383#include ""TCut.h""; 384#include ""TDataMember.h""; 385#include ""TDataType.h""; 386#include ""TDirectory.h""; 38",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:15573,simpl,simple,15573,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['simpl'],['simple']
Usability,"evious block status. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Connect (const char *sender_class, const char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; Bool_t HandleTimer (TTimer *timer) override;  Send progress and feedback to client. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects and progress messages. ;  ;  Protected Member Functions inherited from TProofPlayerRemote; TProof * GetProof () const;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:19894,feedback,feedback,19894,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"ew TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);. THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);. cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");. return cst1;; }; Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces.; The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates.; In the following example the options ""FB"" and ""BB"" suppress the ; ""Front Box"" and ""Back Box"" around the plot. Picture; Source. {; TCanvas *c2 = new TCanvas(""c2"",""c2"",600,400);; TF3 *f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFillColor(30);; f3->SetLineColor(15);; f3->Draw(""FBBB"");; return c2;; }; Associated functions drawing; An associated function is created by TH1::Fit. More than on fitted; function can be associated with one histogram (see TH1::Fit).; A TF1 object f1 can be added to the list of associated; functions of an histogram h without calling TH1::Fit; simply doing:. h->GetListOfFunctions()->Add(f1);. or. h->GetListOfFunctions()->Add(f1,someoption);. To retrieve a function by name from this list, do:. TF1 *f1 = (TF1*)h->GetListOfFunctions()->FindObject(name);. or. TF1 *f1 = h->GetFunction(name);. Associated functions are automatically painted when an histogram is drawn.; To avoid the painting of the associated functions the option HIST; should be added to the list of the options used to paint the histogram.; Drawing using OpenGL; The class TGLHistPainter allows to paint data set using the OpenGL 3D; graphics library. The plotting options start with GL keyword.; In addition, in order to inform canvases that OpenGL should be used to render; 3D representations, the following option should be set:. gStyle->SetCanvasPreferGL(true);. General information: plot types and supported options; The following types of plots are provided:; For lego plots the supported options are:. ""GLLEGO""; Draw a l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THistPainter.html:69632,simpl,simply,69632,root/html530/THistPainter.html,https://root.cern,https://root.cern/root/html530/THistPainter.html,1,['simpl'],['simply']
Usability,"ew TObjArray();; a1->SetName(""a1"");; l->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; l->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = new TObjArray();; a2->SetName(""a2"");; l->Add(a2);; TH1S *ha2a = new TH1S(""ha2a"",""ha2"",100,0,1);; TH1S *ha2b = new TH1S(""ha2b"",""ha2"",100,0,1);; a2->Add(ha2a);; a2->Add(ha2b);. T.Branch(l,16000,2);; T.Print();; }. Int_t Branch(const char* folder, Int_t bufsize = 32000, Int_t splitlevel = 99); Create one branch for each element in the folder.; Returns the total number of branches created. TBranch* Branch(const char* name, void* address, const char* leaflist, Int_t bufsize = 32000); Create a new TTree Branch. This Branch constructor is provided to support non-objects in; a Tree. The variables described in leaflist may be simple; variables or structures. // See the two following; constructors for writing objects in a Tree. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. * address is the address of the first item of a structure.; * leaflist is the concatenation of all the variable names and types; separated by a colon character :; The variable name and the variable type are separated by a slash (/).; The variable type may be 0,1 or 2 characters. If no type is given,; the type of the variable is assumed to be the same as the previous; variable. If the first variable does not have a type, it is assumed; of type F by default. The list of currently supported types is given below:; - C : a character string terminated by the 0 character; - B : an 8 bit signed integer (Char_t); - b : an 8 bit unsigned integer (UChar_t); - S : a 16 bit signed integer (Short_t); - s : a 16 bit unsigned integer (UShort_t); - I : a 32 bit signed integer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:44037,simpl,simple,44037,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"ew dimensions. It relies heavily on ROOT package, borrowing persistency of classes from ROOT. mFOAM can be easily used from the ROOT shell. For more difficult problems the full FOAM may be better. How to run application programs ?; The application program can be run in two modes: it can be simply interpreted by CLING or compiled. The first method is simpler but results in slower execution. The second method employs ACLiC - The Automatic Compiler of Libraries, which automatizes the process of compilation and linking.; In /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials there are 3 demonstration programs:; foam_kanwa.C; is a simple example how to run FOAM in interactive mode. To run this macro issue the following simple command from the Linux shell:; root foam_kanwa.C; or from CLING:; root [0] .x foam_kanwa.C; Simulation will start and graphical canvas with plot of the distribution function appear. In this example we defined the distribution function simply as a global function function Camel2.; foam_demo.C; shows usage of FOAM in compiled mode, which is the preferred method. The integrand function is defined now as a Density method from class TFDISTR inheriting from abstract class TFoamIntegrand. User can modify interface to integrand function according to their needs but they should always remember to define Density method which provides the density distribution. Enter CLING interpreter and type:; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; to load FOAM library, compile and execute macro foam_demo.C. A shared object foam_demo_C.so is created in the current directory. At the end of exploration phase FOAM object including distribution function will be written to disk.; foam_demopers.C; demonstrates persistency of FOAM classes. To run this macro type:; root [0] .x foam_demopers.C; Program reads the FOAM object from disk, checks its consistency and prints geometry of cells. Next starts the the generation. It ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__FOAM.html:1467,simpl,simply,1467,doc/master/group__tutorial__FOAM.html,https://root.cern,https://root.cern/doc/master/group__tutorial__FOAM.html,1,['simpl'],['simply']
Usability,"ewer - ignore return cannot do more; viewer->AddObject(buffer);; }; }; TBuffer3DSphereSphere description class - see TBuffer3DTypes for producer classes Supports hollow and cut spheres.Definition TBuffer3D.h:130; TBuffer3D::kNone@ kNoneDefinition TBuffer3D.h:49; TBuffer3D::kRaw@ kRawDefinition TBuffer3D.h:54; TBuffer3D::kRawSizes@ kRawSizesDefinition TBuffer3D.h:53; int; ShapeSpecific: If the viewer can directly display the buffer without filling of the kRaw/kRawSizes section it will not need to request client side tessellation. Currently we provide the following various shape specific classes, which the OpenGL viewer can take advantage of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. OpenGL only supports solid spheres at present - cut/hollow ones will be requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the viewers require updating to be able to take advantage of them. The number of native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer requiring one internally (OpenGL) will build one for you if you do not provide. However to do this the viewer will force you to provide the raw tessellation, and the resulting box will be axis aligned with the overall scene, which is non-ideal for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(), for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference frames: fLocalFrame & fLocalMaster. fLocalFrame indicates if any positions in the buffer (bounding box and tessellation vertexes) are in local or master (world frame). fLocalMaster is a standard 4x4 transl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:5892,clear,clear,5892,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['clear'],['clear']
Usability,"ewer to suspend redraws etc, and after; the EndScene the viewer will reset the camera to frame the new scene and redraw.; [x3d viewer does not support changing of scenes - objects added after the; first Open/CloseScene pair will be ignored.]; Filling TBuffer3D and Adding to Viewer; The viewers behind the TVirtualViewer3D interface differ greatly in their; capabilities e.g. Some know how to draw certain shapes natively (e.g. spheres/tubes in; OpenGL) - others always require a raw tessellation description of points/lines/segments.; Some; need the 3D object positions in the global frame, others can cope with; local frames + a translation matrix - which can give considerable performance; benefits. To cope with these situations the object buffer is filled out in negotiation; with the viewer. TBuffer3D classes are conceptually divided into enumerated; sections Core, BoundingBox, Raw etc (see TBuffer3D.h for more details). . The SectionsValid() / SetSectionsValid / ClearSectionsValid() methods of TBuffer3D; are used to test/set/clear these section valid flags.; The sections found in TBuffer3D (Core/BoundingBox/Raw Sizes/Raw); are sufficient to describe any tessellated shape in a generic fashion. An additional ShapeSpecific section; in derived shape specific classes allows a more abstract shape description; (""a sphere of inner radius x, outer radius y""). This enables a viewer; which knows how to draw (tessellate) the shape itself to do so, which can bring; considerable performance and quality benefits, while providing a generic fallback; suitable for all viewers.; The rules for client negotiation with the viewer are:. If suitable specialized TBuffer3D class exists, use it, otherwise use; TBuffer3D.; Complete the mandatory Core section.; Complete the ShapeSpecific section; if applicable.; Complete the BoundingBox if you can.; Pass this buffer to the viewer using; one of the AddObject() methods - see below. If the viewer requires more sections to be completed (Raw/RawSizes) A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:3229,clear,clear,3229,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,6,['clear'],['clear']
Usability,"ewtopic.php?f=3&t=13299; 1215 if (e1sq) w1 = 1./ e1sq;; 1216 else if (h1->fSumw2.fN) {; 1217 w1 = 1.E200; // use an arbitrary huge value; 1218 if (y1 == 0 ) { // use an estimated error from the global histogram scale; 1219 double sf = (s1[0] != 0) ? s1[1]/s1[0] : 1;; 1220 w1 = 1./(sf*sf);; 1221 }; 1222 }; 1223 if (e2sq) w2 = 1./ e2sq;; 1224 else if (h2->fSumw2.fN) {; 1225 w2 = 1.E200; // use an arbitrary huge value; 1226 if (y2 == 0) { // use an estimated error from the global histogram scale; 1227 double sf = (s2[0] != 0) ? s2[1]/s2[0] : 1;; 1228 w2 = 1./(sf*sf);; 1229 }; 1230 }; 1231 ; 1232 double y = (w1*y1 + w2*y2)/(w1 + w2);; 1233 UpdateBinContent(i, y);; 1234 if (fSumw2.fN) {; 1235 double err2 = 1./(w1 + w2);; 1236 if (err2 < 1.E-200) err2 = 0; // to remove arbitrary value when e1=0 AND e2=0; 1237 fSumw2.fArray[i] = err2;; 1238 }; 1239 }; 1240 } else { // case of simple histogram addition; 1241 Double_t c1sq = c1 * c1;; 1242 Double_t c2sq = c2 * c2;; 1243 for (Int_t i = 0; i < fNcells; ++i) { // Loop on cells (bins including underflows/overflows); 1244 UpdateBinContent(i, c1 * h1->RetrieveBinContent(i) + c2 * h2->RetrieveBinContent(i));; 1245 if (fSumw2.fN) {; 1246 fSumw2.fArray[i] = c1sq * h1->GetBinErrorSqUnchecked(i) + c2sq * h2->GetBinErrorSqUnchecked(i);; 1247 }; 1248 }; 1249 }; 1250 ; 1251 if (resetStats) {; 1252 // statistics need to be reset in case coefficient are negative; 1253 ResetStats();; 1254 }; 1255 else {; 1256 // update statistics (do here to avoid changes by SetBinContent) FIXME remove???; 1257 PutStats(s3);; 1258 SetEntries(nEntries);; 1259 }; 1260 ; 1261 return kTRUE;; 1262}; 1263 ; 1264////////////////////////////////////////////////////////////////////////////////; 1265/// Increment bin content by 1.; 1266/// Passing an out-of-range bin leads to undefined behavior; 1267 ; 1268void TH1::AddBinContent(Int_t); 1269{; 1270 AbstractMethod(""AddBinContent"");; 1271}; 1272 ; 1273////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:49262,simpl,simple,49262,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['simpl'],['simple']
Usability,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:137656,learn,learning,137656,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['learn'],['learning']
Usability,"ex();; tree.SetTreeIndex(newIndex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& b); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:125403,learn,learning,125403,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,3,['learn'],['learning']
Usability,"ex);; tree.Draw();; tree.SetTreeIndex(oldIndex);; tree.Draw(); etc. void SetWeight(Double_t w = 1, Option_t* option = """"); Set tree weight. The weight is used by TTree::Draw to automatically weight each; selected entry in the resulting histogram. For example the equivalent of:. T.Draw(""x"", ""w""). is:. T.SetWeight(w);; T.Draw(""x"");. This function is redefined by TChain::SetWeight. In case of a; TChain, an option ""global"" may be specified to set the same weight; for all trees in the TChain instead of the default behaviour; using the weights of each tree in the chain (see TChain::SetWeight). void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. Int_t StopCacheLearningPhase(); stop the cache learning phase; Returns 0 learning phase stopped or not active; -1 on error. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:139670,learn,learning,139670,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['learn'],['learning']
Usability,"example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default; the name of the object = title = formula itself.; old.SetName(""old"").; then, old can be reused in a new expression.; TFormula new(""x*old"") is equivalent to:; TFormula new(""x*sin(x*(x<0.5 || x>1))""). Up to 4 dimensions are supported (indicated by x, y, z, t); An expression may have 0 parameters or a list of parameters; indicated by the sequence [par_number]. A graph showing the logic to compile and analyze a formula; is shown in TFormula::Compile and TFormula::Analyze.; Once a formula has been compiled, it can be evaluated for a given; set of parameters. see graph in TFormula::EvalPar. This class is the base class for the function classes TF1,TF2 and TF3.; It is also used by the ntuple selection mechanism TNtupleFormula. In version 7 of TFormula, the usage of fOper has been changed; to improve the performance of TFormula::EvalPar.; Conceptually, fOper was changed from a simple array of Int_t; to an array of composite values.; For example a 'ylandau(5)' operation used to be encoded as 4105;; it is now encoded as (klandau >> kTFOperShit) + 5; Any class inheriting from TFormula and using directly fOper (which; is now a private data member), needs to be updated to take this; in consideration. The member functions recommended to set and; access fOper are: SetAction, GetAction, GetActionParam; For more performant access to the information, see the implementation; TFormula::EvalPar. CHANGING DEFAULT SETTINGS. When creating complex formula , it may be necessary to increase; some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?. This is a frequently asked question.; C++ is a strongly typed language. There is no way for TFormula (without; recompiling this class) to know about all possible user defined data types.; This also apply to the case of a static class function.; Because TMath is a special and fre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFormula.html:2234,simpl,simple,2234,root/html534/TFormula.html,https://root.cern,https://root.cern/root/html534/TFormula.html,3,['simpl'],['simple']
Usability,"examples for the training and testing of the TMVA classifiers. ;  ; file  TMVAClassificationApplication.C;   This macro provides a simple example on how to use the trained classifiers within an analysis module ;  ; file  TMVAClassificationCategory.C;   This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode. ;  ; file  TMVAClassificationCategoryApplication.C;   This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  ; file  TMVACrossValidation.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ; file  TMVACrossValidationApplication.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation in application. ;  ; file  TMVACrossValidationRegression.C;   This macro provides an example of how to use TMVA for k-folds cross evaluation. ;  ; file  TMVAGAexample.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA ;  ; file  TMVAGAexample2.C;   This executable gives an example of a very simple use of the genetic algorithm of TMVA. ;  ; file  TMVAMinimalClassification.C;   Minimal self-contained example for setting up TMVA with binary classification. ;  ; file  TMVAMulticlass.C;   This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  ; file  TMVAMulticlassApplication.C;   This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  ; file  TMVAMultipleBackgroundExample.C;   This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algorithm. ;  ; file  TMVARegression.C;   This macro provides examples ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:6127,simpl,simple,6127,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['simpl'],['simple']
Usability,"experiment's data. You don't need a library with these classes (though ROOT will print ""Warning in : no dictionary for class EventData/Particle is available"") because a TTree knows what data is stored inside. The EventData class contains a vector (std::vector) of particles represented by a ""Particle"" class and the total size (in bytes) of the event itself:; class EventData {; public:; std::vector<Particle> fParticles; // particles of the event; int fEventSize; // size (in bytes) of the event; };. The data members of the Particle class describe the particle properties as shown below:; class Particle {; public:; double fPosX,fPosY,fPosZ; // particle position nearest to interaction point; double fMomentum; // particle momentum; double fMomentumPhi; // particle direction (phi); double fMomentumEta; // particle direction (eta); Long64_t fTags[128]; // particle tags; };. The TTree contains a branch event, which in turn contains the branches fParticles and fEventSize. It simply reflects the layout of class EventData. Each TTree entry has one object of type class EventData, which in turn has a collection of particles. Each tree entry can have a different number of particles. There are 200 TTree entries containing a total of 22994 particles.; If you are curious how we generated the TTree: the script is in our git repository.; . ‹ Introductory Tutorials; up; Accessing a TTree With a TBrowser ›. Navigate through this book; Meet a TTree; Accessing a TTree With a TBrowser; Using TTree::Draw() to access a TTree; TTree and Its Data; Using a Macro to Read a TTree; Histogramming; Fit Panel; Compiling Your Code (also known as ACLiC); Accessing a TTree With a TSelector; Histogramming in a Selector; Using a TSelector with PROOF; The End. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Subm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/meet-ttree.html:3891,simpl,simply,3891,d/meet-ttree.html,https://root.cern,https://root.cern/d/meet-ttree.html,1,['simpl'],['simply']
Usability,"expr Version_t TBinomialEfficiencyFitter::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 73 of file TBinomialEfficiencyFitter.h. ◆ ComputeFCN(). void TBinomialEfficiencyFitter::ComputeFCN ; (; Double_t & ; f, . const Double_t * ; par . ). private . Compute the likelihood. ; Definition at line 329 of file TBinomialEfficiencyFitter.cxx. ◆ DeclFileName(). static const char * TBinomialEfficiencyFitter::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 73 of file TBinomialEfficiencyFitter.h. ◆ EvaluateFCN(). Double_t TBinomialEfficiencyFitter::EvaluateFCN ; (; const Double_t * ; par). inline . Definition at line 67 of file TBinomialEfficiencyFitter.h. ◆ Fit(). TFitResultPtr TBinomialEfficiencyFitter::Fit ; (; TF1 * ; f1, . Option_t * ; option = """" . ). Carry out the fit of the given function to the given histograms. ; If option ""I"" is used, the fit function will be averaged over the bin (the default is to evaluate it simply at the bin center).; If option ""R"" is used, the fit range will be taken from the fit function (the default is to use the entire histogram).; If option ""S"" a TFitResult object is returned and it can be used to obtain additional fit information, like covariance or correlation matrix.; Note that all parameter values, limits, and step sizes are copied from the input fit function f1 (so they should be set before calling this method. This is particularly relevant for the step sizes, taken to be the ""error"" set on input, as a null step size usually fixes the corresponding parameter. That is protected against, but in such cases an arbitrary starting step size will be used, and the reliability of the fit should be questioned). If parameters are to be fixed, this should be done by specifying non-null parameter limits, with lower limits larger than upper limits.; On output, f1 contains the fitted parameters and errors, as well as the number of degrees",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html:17221,simpl,simply,17221,doc/master/classTBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/doc/master/classTBinomialEfficiencyFitter.html,1,['simpl'],['simply']
Usability,"ext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html:3326,clear,clearValueAndShapeDirty,3326,root/html534/RooCFunction1PdfBinding_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction1PdfBinding_double_double_.html,32,['clear'],['clearValueAndShapeDirty']
Usability,"ext*binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:6988,clear,clearValueDirty,6988,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,2,['clear'],['clearValueDirty']
Usability,"ext::PopExpiredMargins ; (; SHtmlMargin_t ** ; ppMarginStack, . int ; y . ). protected . Pop all expired margins from the stack. ; An expired margin is one with a non-negative bottom parameter that is less than the value ""y"". ""y"" is the Y-coordinate of the top edge the next line of text to by positioned. What this function does is check to see if we have cleared any obstacles (an obstacle is an <IMG ALIGN=left> or <IMG ALIGN=right>) and expands the margins if we have. ; Definition at line 152 of file TGHtmlLayout.cxx. ◆ PopIndent(). void TGHtmlLayoutContext::PopIndent ; (; ). Adjust (pop) ident. ; Definition at line 1168 of file TGHtmlLayout.cxx. ◆ PopMargin(). void TGHtmlLayoutContext::PopMargin ; (; SHtmlMargin_t ** ; ppMargin, . int ; tag . ). protected . Pop as many margins as necessary until the margin that was created with ""tag"" is popped off. ; Update the layout context to move past obstacles, if necessary.; If there are some margins on the stack that contain non-negative bottom fields, that means there are some obstacles that we have not yet cleared. If these margins get popped off the stack, then we have to be careful to advance the 'bottom' value so that the next line of text will clear the obstacle. ; Definition at line 119 of file TGHtmlLayout.cxx. ◆ PopOneMargin(). void TGHtmlLayoutContext::PopOneMargin ; (; SHtmlMargin_t ** ; ppMargin). protected . Pop one margin off of the given margin stack. ; Definition at line 99 of file TGHtmlLayout.cxx. ◆ PushIndent(). void TGHtmlLayoutContext::PushIndent ; (; ). Adjust (push) ident. ; Definition at line 1156 of file TGHtmlLayout.cxx. ◆ PushMargin(). void TGHtmlLayoutContext::PushMargin ; (; SHtmlMargin_t ** ; ppMargin, . int ; indent, . int ; mbottom, . int ; tag . ). protected . Push a new margin onto the given margin stack. ; If the ""bottom"" parameter is non-negative, then this margin will automatically expire for all text that is placed below the y-coordinate given by ""bottom"". This feature is used for <IMG AL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHtmlLayoutContext.html:18878,clear,cleared,18878,doc/master/classTGHtmlLayoutContext.html,https://root.cern,https://root.cern/doc/master/classTGHtmlLayoutContext.html,1,['clear'],['cleared']
Usability,"extMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t indexDefinition TGWin32VirtualXProxy.cxx:168; x2Option_t Option_t TPoint TPoint const char x2Definition TGWin32VirtualXProxy.cxx:70; x1Option_t Option_t TPoint TPoint const char x1Definition TGWin32VirtualXProxy.cxx:70; namechar name[80]Definition TGX11.cxx:110; nentriesint nentriesDefinition THbookFile.cxx:91; TLeaf.h; TNtuple.h; TTree.h; TreeUtils.h; TBranchA TTree is a list of TBranches.Definition TBranch.h:93; TBranch::SetAddressvirtual void SetAddress(void *add)Set address of this branch.Definition TBranch.cxx:2682; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TCollection::Browsevoid Browse(TBrowser *b) overrideBrowse this collection (called by TBrowser).Definition TCollection.cxx:248; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::ReadStreamLong64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ') overrideRead from filename as many columns as variables in the ntuple the function returns the number of rows...Definition TNtuple.cxx:220; TNtuple::~TNtuple~TNtuple() overrideDefault destructor for an Ntuple.Definition TNtuple.cxx:103; TNtuple::IsATClass * IsA() const overrideDefinition TNtuple.h:61; TNtuple::ResetBranchAddressesvoid ResetBranchAddresses() overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:147; TNtuple::fNvarInt_t fNvarNumber of columns.Definition TNtuple.h:31; TNtuple::ResetBranchAddressvoid ResetBranchAddress(TBranch *) overrideReset the branch addresses to the internal fArgs array.Definition TNtuple.cxx:133; TNtuple::Classstatic TClass * Class(); TNtuple::Browsevoid Browse(TBrowser *b) overrideBrowse content of the ntuple.Definition TNtuple.cxx:158; TN",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TNtuple_8cxx_source.html:9837,simpl,simple,9837,doc/master/TNtuple_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TNtuple_8cxx_source.html,1,['simpl'],['simple']
Usability,"extMagnitude() const; Delegate to gVirtualX. void SetTextAlign(Short_t align); Delegate to gVirtualX. void SetTextAngle(Float_t tangle); Delegate to gVirtualX. void SetTextColor(Color_t tcolor); Delegate to gVirtualX. void SetTextFont(Font_t tfont); Delegate to gVirtualX. void SetTextSize(Float_t tsize); Delegate to gVirtualX. void SetTextSizePixels(Int_t npixels); Delegate to gVirtualX. Int_t CreateDrawable(UInt_t w, UInt_t h); Create a gVirtualX Pixmap. void ClearDrawable(); Clear the current gVirtualX window. void CopyDrawable(Int_t id, Int_t px, Int_t py); Copy a gVirtualX pixmap. void DestroyDrawable(); Close the current gVirtualX pixmap. void SelectDrawable(Int_t device); Select the window in which the graphics will go. void DrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); Paint a simple line. void DrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); Paint a simple line in normalized coordinates. void DrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); Paint a simple box. void DrawFillArea(Int_t n, const Double_t* x, const Double_t* y); Paint filled area. void DrawFillArea(Int_t n, const Float_t* x, const Float_t* y); Paint filled area. void DrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); Paint polyline. void DrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); Paint polyline. void DrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); Paint polyline in normalized coordinates. void DrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); Paint polymarker. void DrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); Paint polymarker. void DrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); Paint text. void DrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); Paint text in normalized coordinates. void SaveImage(TVirtualPad* pad, const char* fileName, Int_t type) const; Save the image ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPadPainter.html:5348,simpl,simple,5348,root/html528/TPadPainter.html,https://root.cern,https://root.cern/root/html528/TPadPainter.html,3,['simpl'],['simple']
Usability,"ey.cxx. ◆ ReadKeyBuffer(). void TKey::ReadKeyBuffer ; (; char *& ; buffer). Decode input buffer. ; Definition at line 1231 of file TKey.cxx. ◆ ReadObj(). TObject * TKey::ReadObj ; (; ). virtual . To read a TObject* from the file. ; The object associated to this key is read from the file into memory Once the key structure is read (via Streamer) the class identifier of the object is known. Using the class identifier we find the TClass object for this class. A TClass object contains a full description (i.e. dictionary) of the associated class. In particular the TClass object can create a new object of the class type it describes. This new object now calls its Streamer function to rebuilt itself.; Use TKey::ReadObjectAny to read any object non-derived from TObject. Note; A C style cast can only be used in the case where the final class of this object derives from TObject as a first inheritance, otherwise one must use a dynamic_cast.; Example1: simplified case; class MyClass : public TObject, public AnotherClass; TObjectMother of all ROOT objects.Definition TObject.h:41; then on return, one get away with using: MyClass *obj = (MyClass*)key->ReadObj();; Example2: Usual case (recommended unless performance is critical); MyClass *obj = dynamic_cast<MyClass*>(key->ReadObj());; which support also the more complex inheritance like: class MyClass : public AnotherClass, public TObject; Of course, dynamic_cast<> can also be used in the example 1. ; Reimplemented in TKeySQL, and TKeyXML.; Definition at line 759 of file TKey.cxx. ◆ ReadObject(). template<typename T > . T * TKey::ReadObject ; (; ). inline . To read an object (non deriving from TObject) from the file. ; This is more user friendly version of TKey::ReadObjectAny. See TKey::ReadObjectAny for more details. ; Definition at line 103 of file TKey.h. ◆ ReadObjectAny(). void * TKey::ReadObjectAny ; (; const TClass * ; expectedClass). virtual . To read an object (non deriving from TObject) from the file. ; If expectedClass is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKey.html:28547,simpl,simplified,28547,doc/master/classTKey.html,https://root.cern,https://root.cern/doc/master/classTKey.html,1,['simpl'],['simplified']
Usability,"e . ). overridevirtual . Read object contents from given stream. ; Reimplemented from RooAbsReal.; Definition at line 186 of file RooGenericPdf.cxx. ◆ redirectServersHook(). bool RooGenericPdf::redirectServersHook ; (; const RooAbsCollection & ; newServerList, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursive . ). overrideprotectedvirtual . Propagate server changes to embedded formula object. ; Reimplemented from RooAbsPdf.; Definition at line 147 of file RooGenericPdf.cxx. ◆ Streamer(). void RooGenericPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooGenericPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 80 of file RooGenericPdf.h. ◆ translate(). void RooGenericPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 205 of file RooGenericPdf.cxx. ◆ writeToStream(). void RooGenericPdf::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to given stream. ; Reimplemented from RooAbsReal.; Definition at line 196 of file RooGenericPdf.cxx. Member Data Documentation. ◆ _actualVars. RooListProxy RooGenericPdf::_actualVars. protected . Definition at line 67 of file RooGenericPdf.h. ◆ _formE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGenericPdf.html:80859,simpl,simple,80859,doc/master/classRooGenericPdf.html,https://root.cern,https://root.cern/doc/master/classRooGenericPdf.html,1,['simpl'],['simple']
Usability,"f (IsGoodForAutoParseMap(*cxxRcd)){; 3247 headersDeclsMap[autoParseKey] = headers;; 3248 headersDeclsMap[annotatedRcd.GetRequestedName()] = headers;; 3249 } else {; 3250 ROOT::TMetaUtils::Info(nullptr, ""Class %s is not included in the set of autoparse keys.\n"", autoParseKey.c_str());; 3251 }; 3252 ; 3253 // Propagate to the classes map only if this is not a template.; 3254 // The header is then used as autoload key and we want to avoid duplicates.; 3255 if (!llvm::isa<clang::ClassTemplateSpecializationDecl>(cxxRcd)){; 3256 headersClassesMap[autoParseKey] = headersDeclsMap[autoParseKey];; 3257 headersClassesMap[annotatedRcd.GetRequestedName()] = headersDeclsMap[annotatedRcd.GetRequestedName()];; 3258 }; 3259 }; 3260 }; 3261 ; 3262 // The same for the typedefs:; 3263 for (auto & tDef : tDefDecls) {; 3264 if (clang::CXXRecordDecl *cxxRcd = tDef->getUnderlyingType()->getAsCXXRecordDecl()) {; 3265 autoParseKey = """";; 3266 visitedDecls.clear();; 3267 std::list<std::string> headers(RecordDecl2Headers(*cxxRcd, interp, visitedDecls));; 3268 headers.push_back(ROOT::TMetaUtils::GetFileName(*tDef, interp));; 3269 // remove duplicates, also if not subsequent; 3270 buffer.clear();; 3271 headers.remove_if([&buffer](const std::string & s) {; 3272 return !buffer.insert(s).second;; 3273 });; 3274 GetMostExternalEnclosingClassNameFromDecl(*tDef, autoParseKey, interp);; 3275 if (autoParseKey.empty()) autoParseKey = tDef->getQualifiedNameAsString();; 3276 headersDeclsMap[autoParseKey] = headers;; 3277 }; 3278 }; 3279 ; 3280 // The same for the functions:; 3281 for (auto & func : funcDecls) {; 3282 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*func, interp)};; 3283 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*func)] = headers;; 3284 }; 3285 ; 3286 // The same for the variables:; 3287 for (auto & var : varDecls) {; 3288 std::list<std::string> headers = {ROOT::TMetaUtils::GetFileName(*var, interp)};; 3289 headersDeclsMap[ROOT::TMetaUtils::GetQualifiedName(*var)] =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:129926,clear,clear,129926,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['clear'],['clear']
Usability,"f TObjArray and its base classes are not supported.; 16.8.1 The Idea Behind TClonesArray; To reduce the very large number of new and delete calls in large loops like this (O(100000) x O(10000) times new/delete):; TObjArray a(10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); a[i] = new TTrack(x,y,z,...);; ...; }; ...; a.Delete();; }; You better use a TClonesArray which reduces the number of new/delete calls to only O(10000):; TClonesArray a(""TTrack"", 10000);; while (TEvent *ev = (TEvent *)next()) { // O(100000); for (int i = 0; i < ev->Ntracks; i++) { // O(10000); TTrack *track = (Track*)a.ConstructedAt(i);; track->Set(x,y,z,...);; ...; }; ...; a.Clear(); // Or Clear(""C"") if the track objects must be returned (via Track::Clear) to a default state.; }; Considering that a pair of new/delete calls on average cost about 70 ms, O(109) new/deletes will save about 19 hours. For the other collections, see the class reference guide on the web and the test program $ROOTSYS/test/tcollex.cxx.; 16.9 Template Containers and STL; Some people dislike polymorphic containers because they are not truly “type safe”. In the end, the compiler leaves it the user to ensure that the types are correct. This only leaves the other alternative: creating a new class each time a new (container organization) / (contained object) combination is needed. To say the least this could be very tedious. Most people faced with this choice would, for each type of container:; Define the class leaving a dummy name for the contained object type. When a particular container was needed, copy the code and then do a global search and replace for the contained class. C++ has a built in template scheme that effectively does just this. For example:; template<class T>; class ArrayContainer {; private:; T *member[10];; ...; };; This is an array container with a 10-element array of pointers to T, it could hold up to 10 T objects. This array is flawed becau",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:855465,guid,guide,855465,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['guid'],['guide']
Usability,"f any (matching 'dataset', if defined). ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on a data set which is stored on the master with name 'dsetname'. ;  ; virtual Long64_t DrawSelect (TDSet *dset, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0);  Execute the specified drawing action on a data set (TDSet). ;  ; virtual Int_t Echo (const char *str);  Sends a string t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:5532,feedback,feedback,5532,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"f blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); Update pointer to current Tree and recompute pointers to the branches in the cache. TTreeCache(const TTreeCache& ). TTreeCache& operator=(const TTreeCache& ). Bool_t IsLearning() const; {return fIsLearning;}. » Author: Rene Brun 04/06/2006 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCache.h 39275 2011-05-19 18:17:3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:22291,learn,learning,22291,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['learn'],['learning']
Usability,"f entries of the whole distribution). Candle plots like these are usually called ""notched candle plots"".; In case the significance of the median is greater that the size of the box, the box will have an unnatural shape. Usually it means the chart has not enough data, or that representing this uncertainty is not useful; The Mean; The mean can be drawn as a dashed line or as a circle or not drawn at all. The mean is the arithmetic average of the values in the distribution. It is calculated using GetMean(). Because histograms are binned data, the mean value can differ from a calculation on the raw-data. If the distribution is large enough and gaussian shaped the mean will be exactly the median.; The Whiskers; The whiskers represent the part of the distribution not covered by the box. The upper 25% and the lower 25% of the distribution are located within the whiskers. Two representations are available. A simple one (using w=1) defining the lower whisker from the lowest data value to the bottom of the box, and the upper whisker from the top of the box to the highest data value. In this representation the whisker-lines are dashed.; A more complex one having a further restriction. The whiskers are still connected to the box but their length cannot exceed \( 1.5\times iqr \). So it might be that the outermost part of the underlying distribution will not be covered by the whiskers. Usually these missing parts will be represented by the outliers (see points). Of course the upper and the lower whisker may differ in length. In this representation the whiskers are drawn as solid lines. SinceROOT version 6.11/01; Using the static function TCandle::SetWhiskerRange(double) the whisker definition w=1 will be overwritten. E.g. using a whisker-range of 0.95 and w=1 will redefine the area of the lower whisker to the upper whisker in order to cover 95% of the distribution inside that candle. The static function will affect all candle-charts in the running program. Default is 1.; If the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:61710,simpl,simple,61710,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simple']
Usability,"f events from a ROOT dataset into a basic PyTorch workflow. ;  ; file  RBatchGenerator_TensorFlow.py;   Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ;  ; file  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ; file  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ; file  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ; file  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ; file  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ; file  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ; file  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ; file  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_RNN_Classification.C;   TMVA Classification Example Using a Recurrent Neural Network ;  ; file  TMVA_RNN_Classification.py;   TMVA Classific",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:1710,learn,learning,1710,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['learn'],['learning']
Usability,"f file NeuralNet.h. ◆ convergenceCount(). size_t TMVA::DNN::Settings::convergenceCount ; (; ); const. inline . returns the current convergence count ; Definition at line 827 of file NeuralNet.h. ◆ convergenceSteps(). size_t TMVA::DNN::Settings::convergenceSteps ; (; ); const. inline . how many steps until training is deemed to have converged ; Definition at line 766 of file NeuralNet.h. ◆ create() [1/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max . ). inline . for monitoring ; Definition at line 819 of file NeuralNet.h. ◆ create() [2/2]. void TMVA::DNN::Settings::create ; (; std::string ; histoName, . int ; bins, . double ; min, . double ; max, . int ; bins2, . double ; min2, . double ; max2 . ). inline . for monitoring ; Definition at line 820 of file NeuralNet.h. ◆ cycle(). virtual void TMVA::DNN::Settings::cycle ; (; double ; progress, . TString ; text . ). inlinevirtual . Parameters. textadvance on the progress bar; progressthe new value; texta label . Definition at line 799 of file NeuralNet.h. ◆ drawSample(). virtual void TMVA::DNN::Settings::drawSample ; (; const std::vector< double > & ; , . const std::vector< double > & ; , . const std::vector< double > & ; , . double ;  . ). inlinevirtual . callback for monitoring and logging ; Definition at line 807 of file NeuralNet.h. ◆ dropFractions(). const std::vector< double > & TMVA::DNN::Settings::dropFractions ; (; ); const. inline . Definition at line 762 of file NeuralNet.h. ◆ dropRepetitions(). size_t TMVA::DNN::Settings::dropRepetitions ; (; ); const. inline . Definition at line 761 of file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:7357,progress bar,progress bar,7357,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['progress bar'],['progress bar']
Usability,"f file TGFont.h. ◆ DistanceToText(). Int_t TGTextLayout::DistanceToText ; (; Int_t ; x, . Int_t ; y . ); const. Computes the distance in pixels from the given point to the given text layout. ; Non-displaying space characters that occur at the end of individual lines in the text layout are ignored for hit detection purposes.; The return value is 0 if the point (x, y) is inside the text layout. If the point isn't inside the text layout then the return value is the distance in pixels from the point to the text item.; x, y – Coordinates of point to check, with respect to the upper-left corner of the text layout (in pixels). ; Definition at line 1191 of file TGFont.cxx. ◆ DrawText(). void TGTextLayout::DrawText ; (; Drawable_t ; dst, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . Int_t ; firstChar, . Int_t ; lastChar . ); const. Use the information in the TGTextLayout object to display a multi-line, justified string of text. ; This procedure is useful for simple widgets that need to display single-font, multi-line text and want TGFont to handle the details.; dst – Window or pixmap in which to draw. gc – Graphics context to use for drawing text. x, y – Upper-left hand corner of rectangle in which to draw (pixels). firstChar – The index of the first character to draw from the given text item. 0 specfies the beginning. lastChar – The index just after the last character to draw from the given text item. A number < 0 means to draw all characters. ; Definition at line 923 of file TGFont.cxx. ◆ IntersectText(). Int_t TGTextLayout::IntersectText ; (; Int_t ; x, . Int_t ; y, . Int_t ; w, . Int_t ; h . ); const. Determines whether a text layout lies entirely inside, entirely outside, or overlaps a given rectangle. ; Non-displaying space characters that occur at the end of individual lines in the text layout are ignored for intersection calculations.; The return value is -1 if the text layout is entirely outside of the rectangle, 0 if it overlaps, and 1 if it is entirely inside of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextLayout.html:15343,simpl,simple,15343,doc/master/classTGTextLayout.html,https://root.cern,https://root.cern/doc/master/classTGTextLayout.html,1,['simpl'],['simple']
Usability,"f file TGProgressBar.h. ◆ DeclFileName(). static const char * TGHProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 118 of file TGProgressBar.h. ◆ DoRedraw(). void TGHProgressBar::DoRedraw ; (; ). overrideprotectedvirtual . Draw horizontal progress bar. ; Implements TGProgressBar.; Definition at line 265 of file TGProgressBar.cxx. ◆ GetDefaultSize(). TGDimension TGHProgressBar::GetDefaultSize ; (; ); const. inlineoverridevirtual . std::cout << fWidth << ""x"" << fHeight << std::endl; ; Reimplemented from TGFrame.; Definition at line 110 of file TGProgressBar.h. ◆ IsA(). TClass * TGHProgressBar::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TGFrame.; Definition at line 118 of file TGProgressBar.h. ◆ SavePrimitive(). void TGHProgressBar::SavePrimitive ; (; std::ostream & ; out, . Option_t * ; option = """" . ). overridevirtual . Save a horizontal progress bar as a C++ statement(s) on output stream out. ; Reimplemented from TGFrame.; Definition at line 464 of file TGProgressBar.cxx. ◆ ShowPosition(). void TGHProgressBar::ShowPosition ; (; Bool_t ; set = kTRUE, . Bool_t ; percent = kTRUE, . const char * ; format = ""%.2f"" . ). Show postion text, either in percent or formatted according format. ; Definition at line 253 of file TGProgressBar.cxx. ◆ Streamer(). void TGHProgressBar::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame. ◆ StreamerNVirtual(). void TGHProgressBar::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 118 of file TGProgressBar.h. Libraries for TGHProgressBar:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGProgressBar.h; gui/gui/src/TGProgressBar.cxx. TGHProgressBar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:16 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:33775,progress bar,progress bar,33775,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"f file TGSplitFrame.cxx. ◆ Undocked(). void TGSplitFrame::Undocked ; (; TGFrame * ; frame). Emit Undocked() signal. ; Definition at line 711 of file TGSplitFrame.cxx. ◆ UnSplit(). void TGSplitFrame::UnSplit ; (; const char * ; which). Close (unmap and remove from the list of frames) the frame contained in this split frame. ; Definition at line 720 of file TGSplitFrame.cxx. ◆ VSplit(). void TGSplitFrame::VSplit ; (; UInt_t ; w = 0). virtual . Vertically split the frame. ; Definition at line 452 of file TGSplitFrame.cxx. Member Data Documentation. ◆ fFirst. TGSplitFrame* TGSplitFrame::fFirst. protected . Pointer to the first child (if any) ; Definition at line 87 of file TGSplitFrame.h. ◆ fFrame. TGFrame* TGSplitFrame::fFrame. protected . Pointer to the embedded frame (if any) ; Definition at line 84 of file TGSplitFrame.h. ◆ fHRatio. Float_t TGSplitFrame::fHRatio. protected . Height ratio between the first child and this. ; Definition at line 91 of file TGSplitFrame.h. ◆ fSecond. TGSplitFrame* TGSplitFrame::fSecond. protected . Pointer to the second child (if any) ; Definition at line 88 of file TGSplitFrame.h. ◆ fSplitter. TGSplitter* TGSplitFrame::fSplitter. protected . Pointer to the (H/V) Splitter (if any) ; Definition at line 86 of file TGSplitFrame.h. ◆ fSplitTool. TGSplitTool* TGSplitFrame::fSplitTool. protected . SplitFrame Tool. ; Definition at line 89 of file TGSplitFrame.h. ◆ fUndocked. TGTransientFrame* TGSplitFrame::fUndocked. protected . Main frame used when ""undocking"" frame. ; Definition at line 85 of file TGSplitFrame.h. ◆ fWRatio. Float_t TGSplitFrame::fWRatio. protected . Width ratio between the first child and this. ; Definition at line 90 of file TGSplitFrame.h. Libraries for TGSplitFrame:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGSplitFrame.h; gui/gui/src/TGSplitFrame.cxx. TGSplitFrame. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:35 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGSplitFrame.html:42447,undo,undocking,42447,doc/master/classTGSplitFrame.html,https://root.cern,https://root.cern/doc/master/classTGSplitFrame.html,1,['undo'],['undocking']
Usability,"f file TUnfoldSys.cxx. ◆ GetDeltaSysTau(). Bool_t TUnfoldSys::GetDeltaSysTau ; (; TH1 * ; hist_delta, . const Int_t * ; binMap = nullptr . ). correlated one-sigma shifts from shifting tau ; Parameters. [out]hist_deltahistogram to store shifts ; [in]sourceidentifier of the background source ; [in]binMap(default=nullptr) remapping of histogram bins. returns true if the background source was found. ; This method returns the shifts of the unfolding result induced by varying the normalisation of the identified background by one sigma. ; the array binMap is explained with the method GetOutput(). ; Definition at line 1086 of file TUnfoldSys.cxx. ◆ GetEmatrixFromVyy(). void TUnfoldSys::GetEmatrixFromVyy ; (; const TMatrixDSparse * ; vyy, . TH2 * ; ematrix, . const Int_t * ; binMap, . Bool_t ; clearEmat . ). protected . propagate an error matrix on the input vector to the unfolding result ; Parameters. [in]vyyinput error matrix ; [in,out]ematrixhistogram to be updated ; [in]binMapmapping of histogram bins ; [in]clearEmatif set, clear histogram before adding this covariance contribution . Definition at line 1250 of file TUnfoldSys.cxx. ◆ GetEmatrixInput(). void TUnfoldSys::GetEmatrixInput ; (; TH2 * ; ematrix, . const Int_t * ; binMap = nullptr, . Bool_t ; clearEmat = kTRUE . ). covariance matrix contribution from input measurement uncertainties ; Parameters. [in,out]ematrixoutput histogram ; [in]binMap(default=nullptr) remapping of histogram bins ; [in]clearEmat(default=true) if true, clear the histogram. this method returns the covariance contributions to the unfolding result from the uncertainties or covariance of the input data. In many cases, these are the ""statistical uncertainties"". ; The array binMap is explained with the method GetOutput(). The flag clearEmat may be used to add covariance matrices from several uncertainty sources. ; Definition at line 1207 of file TUnfoldSys.cxx. ◆ GetEmatrixSysBackgroundScale(). void TUnfoldSys::GetEmatrixSysBackgroundScale ; (; TH2 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldSys.html:37381,clear,clearEmatif,37381,doc/master/classTUnfoldSys.html,https://root.cern,https://root.cern/doc/master/classTUnfoldSys.html,2,['clear'],"['clear', 'clearEmatif']"
Usability,"f file Timer.h. ◆ Reset(). void TMVA::Timer::Reset ; (; void ; ). resets timer ; Definition at line 127 of file Timer.cxx. ◆ SecToText(). TString TMVA::Timer::SecToText ; (; Double_t ; seconds, . Bool_t ; Scientific . ); const. private . pretty string output ; Definition at line 262 of file Timer.cxx. ◆ Streamer(). virtual void TMVA::Timer::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::Timer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 99 of file Timer.h. Member Data Documentation. ◆ fColourfulOutput. Bool_t TMVA::Timer::fColourfulOutput. private . flag for use of colors ; Definition at line 84 of file Timer.h. ◆ fgClassName. const TString TMVA::Timer::fgClassName = ""Timer"". staticprivate . used for output ; Definition at line 93 of file Timer.h. ◆ fgNbins. const Int_t TMVA::Timer::fgNbins = 16. staticprivate . number of bins in progress bar ; Definition at line 94 of file Timer.h. ◆ fLogger. MsgLogger* TMVA::Timer::fLogger. mutableprivate . ! the output logger ; Definition at line 96 of file Timer.h. ◆ fNcounts. Int_t TMVA::Timer::fNcounts. private . reference number of ""counts"" ; Definition at line 82 of file Timer.h. ◆ fOutputToFile. Bool_t TMVA::Timer::fOutputToFile. private . Definition at line 89 of file Timer.h. ◆ fPrefix. TString TMVA::Timer::fPrefix. private . prefix for outputs ; Definition at line 83 of file Timer.h. ◆ fPreviousProgress. Int_t TMVA::Timer::fPreviousProgress. private . Definition at line 87 of file Timer.h. ◆ fPreviousTimeEstimate. TString TMVA::Timer::fPreviousTimeEstimate. private . Definition at line 88 of file Timer.h. ◆ fProgressBarStringLength. Int_t TMVA::Timer::fProgressBarStringLength. private . Definition at line 91 of file Timer.h. Libraries for TMVA::Timer:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/Timer.h; tmva/tmva/src/Timer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:17355,progress bar,progress bar,17355,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,1,['progress bar'],['progress bar']
Usability,"f getting batches of events from a ROOT dataset as Python generators of numpy arrays. ;  ; file  RBatchGenerator_PyTorch.py;   Example of getting batches of events from a ROOT dataset into a basic PyTorch workflow. ;  ; file  RBatchGenerator_TensorFlow.py;   Example of getting batches of events from a ROOT dataset into a basic TensorFlow workflow. ;  ; file  tmva001_RTensor.C;   This tutorial illustrates the basic features of the RTensor class, RTensor is a std::vector-like container with additional shape information. ;  ; file  tmva002_RDataFrameAsTensor.C;   This tutorial shows how the content of an RDataFrame can be converted to an RTensor object. ;  ; file  tmva003_RReader.C;   This tutorial shows how to apply with the modern interfaces models saved in TMVA XML files. ;  ; file  tmva004_RStandardScaler.C;   This tutorial illustrates the usage of the standard scaler as preprocessing method. ;  ; file  tmva100_DataPreparation.py;   This tutorial illustrates how to prepare ROOT datasets to be nicely readable by most machine learning methods. ;  ; file  tmva101_Training.py;   This tutorial show how you can train a machine learning model with any package reading the training data directly from ROOT files. ;  ; file  tmva102_Testing.py;   This tutorial illustrates how you can test a trained BDT model using the fast tree inference engine offered by TMVA and external tools such as scikit-learn. ;  ; file  tmva103_Application.C;   This tutorial illustrates how you can conveniently apply BDTs in C++ using the fast tree inference engine offered by TMVA. ;  ; file  TMVA_CNN_Classification.C;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_CNN_Classification.py;   TMVA Classification Example Using a Convolutional Neural Network ;  ; file  TMVA_Higgs_Classification.C;   Classification example of TMVA based on public Higgs UCI dataset ;  ; file  TMVA_Higgs_Classification.py;   Classification example of TMVA based on public Higgs UCI dataset ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__tmva.html:1611,learn,learning,1611,doc/master/group__tutorial__tmva.html,https://root.cern,https://root.cern/doc/master/group__tutorial__tmva.html,1,['learn'],['learning']
Usability,"f parameters for a polynom. ; Definition at line 1679 of file TGraph.cxx. ◆ InsertPoint(). Int_t TGraph::InsertPoint ; (; ). virtual . Insert a new point at the mouse position. ; Definition at line 1699 of file TGraph.cxx. ◆ InsertPointBefore(). void TGraph::InsertPointBefore ; (; Int_t ; ipoint, . Double_t ; x, . Double_t ; y . ). virtual . Insert a new point with coordinates (x,y) before the point number ipoint. ; Definition at line 1749 of file TGraph.cxx. ◆ Integral(). Double_t TGraph::Integral ; (; Int_t ; first = 0, . Int_t ; last = -1 . ); const. virtual . Integrate the TGraph data within a given (index) range. ; Note that this function computes the area of the polygon enclosed by the points of the TGraph. The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon, since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point with the first one. It is clear that the order of the point is essential in defining the polygon. Also note that the segments should not intersect.; NB:; if last=-1 (default) last is set to the last point.; if (first <0) the first point (0) is taken. Method:; There are many ways to calculate the surface of a polygon. It all depends on what kind of data you have to deal with. The most evident solution would be to divide the polygon in triangles and calculate the surface of them. But this can quickly become complicated as you will have to test every segments of every triangles and check if they are intersecting with a current polygon's segment or if it goes outside the polygon. Many calculations that would lead to many problems... The solution (implemented by R.Brun); Fortunately for us, there is a simple way to solve this problem, as long as the polygon's segments don't intersect. It takes the x coordinate of the current vertex and multiply it by the y coordinate of the next vertex. Then it subtracts from it the result of the y coordinate of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:61350,clear,clear,61350,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['clear'],['clear']
Usability,"f parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in this RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) const; Return a p.d.f that represents the fit result as a multi-variate probability densisty; function on the floating fit parameters, including correlations. void SetName(const char* name); Change name of RooFitResult object. void SetNameTitle(const char* name, const char* title); Change name and title of RooFitResult object. void printName(ostream& os) const; Print name of fit result. void printTitle(ostream& os) const; Print title of fit result. void printClassName(ostream& os) const; Print class name of fit result. void printArgs(ostream& os) const; Print arguments of fit result, i.e. the parameters of the fit. void printValue(ostream& os) const; Print the value of the fit result, i.e.g the status, minimized FCN, edm and covariance quality code. Int_t defaultPrintContents(Option_t* opt) const; Configure default contents to be print",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFitResult.html:16540,simpl,simple,16540,root/html602/RooFitResult.html,https://root.cern,https://root.cern/root/html602/RooFitResult.html,2,['simpl'],['simple']
Usability,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2072 of file TTreeCache.cxx. ◆",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:47673,simpl,simply,47673,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"f selected branches, and recheck if pos is now in the list. Returns:; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache. This function overloads TFileCacheRead::ReadBuffer. . Reimplemented from TFileCacheRead.; Definition at line 2027 of file TTreeCache.cxx. ◆ ReadBufferNormal(). Int_t TTreeCache::ReadBufferNormal ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Old method ReadBuffer before the addition of the prefetch mechanism. ; Definition at line 1927 of file TTreeCache.cxx. ◆ ReadBufferPrefetch(). Int_t TTreeCache::ReadBufferPrefetch ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). virtual . Used to read a chunk from a block previously fetched. ; It will call FillBuffer even if the cache lookup succeeds, because it will try to prefetch the next block as soon as we start reading from the current block. ; Definition at line 1986 of file TTreeCache.cxx. ◆ ResetCache(). void TTreeCache::ResetCache ; (; ). virtual . This will simply clear the cache. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2040 of file TTreeCache.cxx. ◆ ResetMissCache(). void TTreeCache::ResetMissCache ; (; ). Reset all the miss cache training. ; The contents of the miss cache will be emptied as well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Long64_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:47677,simpl,simply,47677,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,2,"['clear', 'simpl']","['clear', 'simply']"
Usability,"f struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/err.h>; 1748#include <openssl/opensslv.h>; 1749#include <openssl/pem.h>; 1750#include <openssl/ssl.h>; 1751#include <openssl/tls1.h>; 1752#include <openssl/x509.h>; 1753 ; 1754#if defined(WOLFSSL_VERSION); 1755/* Additional defines for WolfSSL, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.; 1767 *; 1768 * #define OPENSSL_free free */; 1769#define free free; 1770// disable for boringssl; 1771#define CONF_modules_unload(a) ((void)0); 1772#define ENGINE_cleanup() ((void)0); 1773#endif; 1774 ; 1775/* If OpenSSL headers are included, automatically select the API version */; 1776#if (OPENSSL_VERSION_NUMBER >= 0x30000000L); 1777#if !defined(OPENSSL_API_3_0); 1778#define OPENSSL_API_3_0; 1779#endif; 1780#define OPENSSL_REMOVE_THREAD_STATE(); 1781#else; 1782#if (OPENSSL_VERSION_NUMBER >= 0x10100000L); 1783#if !defined(OPENSSL_API_1_1); 1784#define OPENSSL_API_1_1; 1785#endif; 1786#define OPENSSL_REMOVE_THREAD_STATE(); 1787#else; 1788#if !defined(OPENSSL_API_1_0); 1789#define OPENSSL_API_1_0; 1790#endif; 1791#define OPENSSL_REMOVE_THREAD_STATE() ERR_remove_thread_state(NULL); 1792#endif; 1793#endif; 1794 ; 1795 ; 1796#else; 1797/* SSL loaded dynamically from DLL / shared object */; 1798/* Add all prototypes here,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:54194,simpl,simply,54194,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['simpl'],['simply']
Usability,"f the file.; 829///; 830/// - The buffer is written to the file.; 831///; 832/// Bufsize can be given to force a given buffer size to write this object.; 833/// By default, the buffersize will be taken from the average buffer size; 834/// of all objects written to the current file so far.; 835///; 836/// If a name is specified, it will be the name of the key.; 837/// If name is not given, the name of the key will be the name as returned; 838/// by GetName().; 839///; 840/// The option can be a combination of: kSingleKey, kOverwrite or kWriteDelete; 841/// Using the kOverwrite option a previous key with the same name is; 842/// overwritten. The previous key is deleted before writing the new object.; 843/// Using the kWriteDelete option a previous key with the same name is; 844/// deleted only after the new object has been written. This option; 845/// is safer than kOverwrite but it is slower.; 846/// NOTE: Neither kOverwrite nor kWriteDelete reduces the size of a TFile--; 847/// the space is simply freed up to be overwritten; in the case of a TTree,; 848/// it is more complicated. If one opens a TTree, appends some entries,; 849/// then writes it out, the behaviour is effectively the same. If, however,; 850/// one creates a new TTree and writes it out in this way,; 851/// only the metadata is replaced, effectively making the old data invisible; 852/// without deleting it. TTree::Delete() can be used to mark all disk space; 853/// occupied by a TTree as free before overwriting its metadata this way.; 854/// The kSingleKey option is only used by TCollection::Write() to write; 855/// a container with a single key instead of each object in the container; 856/// with its own key.; 857///; 858/// An object is read from the file into memory via TKey::Read() or; 859/// via TObject::Read().; 860///; 861/// The function returns the total number of bytes written to the file.; 862/// It returns 0 if the object cannot be written.; 863 ; 864Int_t TObject::Write(const char *name, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:30885,simpl,simply,30885,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['simpl'],['simply']
Usability,"f the ged-editor; TGeoTabManager*TGeoGedFrame::fTabMgrtab manager corresponding to ged-editor; TGTextButton*TGeoTubeEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoTubeSegEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for tube segment editor. ~TGeoTubeSegEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected object. void DoPhi1(); Slot for phi1. void DoPhi2(); Slot for phi2. void DoPhi(); Slot for phi slider. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoTubeSegEditor.html:21938,undo,undoing,21938,root/html534/TGeoTubeSegEditor.html,https://root.cern,https://root.cern/root/html534/TGeoTubeSegEditor.html,1,['undo'],['undoing']
Usability,"f the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; TProof * GetProof () const;  ; Bool_t HandleTimer (TTimer *timer) override;  Send feedback objects to client. ;  ; Int_t InitPacketizer (TDSet *dset, Long64_t nentries, Long64_t first, const char *defpackunit, const char *defpackdata);  Init the packetizer Return 0 on success (fPacketizer is correctly initialized), -1 on failure. ;  ; TList * MergeFeedback ();  Merge feedback lists. ;  ; Bool_t MergeOutputFiles ();  Merge output in files. ;  ; void NotifyMemory (TObject *obj);  Printout the memory record after merging object 'obj' This record is used by the memory monitor. ;  ; virtual Bool_t SendSelector (const char *selector_file);  Send the selector file(s) to master or worker nodes. ;  ; void SetLastMergingMsg (TObject *obj);  Set the message to be notified in case of exception. ;  ; void SetSelectorDataMembersFromOutputList ();  Set the selector's data members: find the mapping of data members to otuput list entries in the output list and apply it. ;  ; void SetupFeedback () override;  Setup reporting of feedback objects. ;  ; void StopFeedback () override;  Stop reporting of feedback objects. ;  ;  Protected Member Functions inherited from TProofPlayer; Int_t AssertSelector (const char *selector_file);  Make sure that a valid selector object Return -1 in case of problems, 0 otherwise. ;  ; Bool_t CheckMemUsage (Long64_t &mfreq, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerRemote.html:19690,feedback,feedback,19690,doc/master/classTProofPlayerRemote.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"f the values in the first line do not use the /[type] syntax, all variables are assumed to be of type ""F"". If the filename ends with extensions .csv or .CSV and a delimiter is not specified (besides ' '), the delimiter is automatically set to ','.; Lines in the input file starting with ""#"" are ignored. Leading whitespace for each column data is skipped. Empty lines are skipped.; A TBranch object is created for each variable in the expression. The total number of rows read from the file is returned. FILLING a TTree WITH MULTIPLE INPUT TEXT FILES; To fill a TTree with multiple input text files, proceed as indicated above for the first input file and omit the second argument for subsequent calls T.ReadFile(""file1.dat"",""branch descriptor"");; T.ReadFile(""file2.dat"");. Definition at line 7564 of file TTree.cxx. ◆ ReadStream(). Long64_t TTree::ReadStream ; (; std::istream & ; inputStream, . const char * ; branchDescriptor = """", . char ; delimiter = ' ' . ). virtual . Create or simply read branches from an input stream. ; See alsoreference information for TTree::ReadFile ; Reimplemented in TNtuple, and TNtupleD.; Definition at line 7615 of file TTree.cxx. ◆ RecursiveRemove(). void TTree::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Make sure that obj (which is being deleted or will soon be) is no longer referenced by this TTree. ; Reimplemented from TObject.; Definition at line 7881 of file TTree.cxx. ◆ Refresh(). void TTree::Refresh ; (; ). virtual . Refresh contents of this tree and its branches from the current status on disk. ; One can call this function in case the tree file is being updated by another process. ; Reimplemented in TTreeSQL.; Definition at line 7916 of file TTree.cxx. ◆ RegisterExternalFriend(). void TTree::RegisterExternalFriend ; (; TFriendElement * ; fe). virtual . Record a TFriendElement that we need to warn when the chain switches to a new file (typically this is because this chain is a friend of another TChain) ; Definition at line 7957 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:195157,simpl,simply,195157,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['simpl'],['simply']
Usability,"f undo method Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");; For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color; ; com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);; Color_tshort Color_tDefinition RtypesCore.h:85; TQCommand::SetRedoArgsvirtual void SetRedoArgs(Int_t nargs,...)Set redo parameters.Definition TQCommand.cxx:508; TQCommand::SetUndoArgsvirtual void SetUndoArgs(Int_t nargs,...)Set undo parameters.Definition TQCommand.cxx:542; 1st argument - the number of undo, redo parameters the other arguments - undo, redo values Since the number of undo,redo parameters is the same one can use com->SetArgs(1, new_color, old_color);; TQCommand::SetArgsvirtual void SetArgs(Int_t nargs,...)Set do/redo and undo parameters.Definition TQCommand.cxx:465. Undo, redo method execution com->Redo(); // execute redo method; com->Undo(); // execute undo method; TQCommand::Undovirtual void Undo(Option_t *option="""")Un-execute all merged commands and the command.Definition TQCommand.cxx:626; TQCommand::Redovirtual void Redo(Option_t *option="""")Execute command and then merge commands.Definition TQCommand.cxx:588. Merged commands It possible to group several commands together so an end user can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; gPad#define gPadDefinition TVirtualPad.h:308; TQCommand::Addvoid Add(TObject *obj, Option_t *opt) overrideAdd command to the list of merged commands.Definition TQCommand.cxx:360. Macro ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:2493,undo,undo,2493,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"f which the integral is requested. ; For certain operator p.d.f it is useful to overload this function rather than analyticalIntegralWN() as the additional normalization information may be useful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 2361 of file RooProdPdf.cxx. ◆ initialize(). void RooFixedProdPdf::initialize ; (; ). inlineprivate . Definition at line 2380 of file RooProdPdf.cxx. ◆ selfNormalized(). bool RooFixedProdPdf::selfNormalized ; (; ); const. inlineoverridevirtual . Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ; Always returns false, unless a PDF overrides this function. ; Reimplemented from RooAbsPdf.; Definition at line 2334 of file RooProdPdf.cxx. ◆ translate(). void RooFixedProdPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. inlineoverridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 2343 of file RooProdPdf.cxx. Member Data Documentation. ◆ _cache. std::unique_ptr<RooProdPdf::CacheElem> RooFixedProdPdf::_cache. private . Definition at line 2401 of file RooProdPdf.cxx. ◆ _normSet. RooArgSet RooFixedProdPdf::_normSet. private . Definition at line 2400 of file RooProdPdf.cxx. ◆ _prodPdf. std::unique_ptr<RooProdPdf> RooFixedProdPdf::_prodPdf. private . Definition at line 2403 of file RooProdPdf.cxx. ◆ _servers",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFixedProdPdf.html:79305,simpl,simple,79305,doc/master/classRooFixedProdPdf.html,https://root.cern,https://root.cern/doc/master/classRooFixedProdPdf.html,1,['simpl'],['simple']
Usability,"f with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 680 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPdf::setExtended ; (; bool ; extended). inlineprivate . Definition at line 136 of file RooRealSumPdf.h. ◆ setFloor(). void RooRealSumPdf::setFloor ; (; bool ; flag). inline . Definition at line 62 of file RooRealSumPdf.h. ◆ setFloorGlobal(). static void RooRealSumPdf::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 64 of file RooRealSumPdf.h. ◆ Streamer(). void RooRealSumPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooRealSumPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file RooRealSumPdf.h. ◆ translate(). void RooRealSumPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 331 of file RooRealSumPdf.cxx. ◆ translateImpl(). std::string RooRealSumPdf::translateImpl ; (; RooFit::Detail::CodeSquashContext & ; ctx, . RooAbsArg const * ; klass, . RooArgList const & ; funcList, . RooArgList const & ; coefList, . bool ; normalize = false . ). staticprivate . Definition at line 300 of file RooRealSumPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddition. friend class RooAddition. friend . Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealSumPdf.html:91025,simpl,simple,91025,doc/master/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/master/classRooRealSumPdf.html,1,['simpl'],['simple']
Usability,"f with cache-and-track. ; Reimplemented from RooAbsArg.; Definition at line 687 of file RooRealSumPdf.cxx. ◆ setExtended(). void RooRealSumPdf::setExtended ; (; bool ; extended). inlineprivate . Definition at line 136 of file RooRealSumPdf.h. ◆ setFloor(). void RooRealSumPdf::setFloor ; (; bool ; flag). inline . Definition at line 62 of file RooRealSumPdf.h. ◆ setFloorGlobal(). static void RooRealSumPdf::setFloorGlobal ; (; bool ; flag). inlinestatic . Definition at line 64 of file RooRealSumPdf.h. ◆ Streamer(). void RooRealSumPdf::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooRealSumPdf::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 138 of file RooRealSumPdf.h. ◆ translate(). void RooRealSumPdf::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 333 of file RooRealSumPdf.cxx. ◆ translateImpl(). std::string RooRealSumPdf::translateImpl ; (; RooFit::Detail::CodeSquashContext & ; ctx, . RooAbsArg const * ; klass, . RooArgList const & ; funcList, . RooArgList const & ; coefList, . bool ; normalize = false . ). staticprivate . Definition at line 302 of file RooRealSumPdf.cxx. Friends And Related Symbol Documentation. ◆ RooAddition. friend class RooAddition. friend . Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:92146,simpl,simple,92146,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,1,['simpl'],['simple']
Usability,"f""Gaussian::gauss(x[-5,15], mu[0,4], {sigma})""); ws.factory(""Uniform::uniform(x)""); ws[""mu""].setVal(mu_observed); ws.Print(""v""); obs_data = ws[""gauss""].generate(ws[""x""], 1000); obs_data.SetName(""obs_data""); ws.Import(obs_data, Silence=True); ; return ws; ; ; # The ""observed"" data; mu_observed = 2.5; sigma = 1.5; workspace = build_ws(mu_observed, sigma); x_var = workspace[""x""]; mu_var = workspace[""mu""]; gauss = workspace[""gauss""]; uniform = workspace[""uniform""]; obs_data = workspace[""obs_data""]; ; # Training the model; model = SBI(workspace); model.model_data(""gauss"", ""x"", ""mu"", n_samples_train); model.reference_data(""uniform"", ""x"", n_samples_train); model.preprocessing(); model.train_classifier(); sbi_model = model; ; ; # Compute the likelihood ratio of the classifier for analysis purposes; def learned_likelihood_ratio(x, mu):; n = max(len(x), len(mu)); X = np.zeros((n, 2)); X[:, 0] = x; X[:, 1] = mu; prob = sbi_model.classifier.predict_proba(X)[:, 1]; return prob / (1 - prob); ; ; # Compute the learned likelihood ratio; llhr_learned = ROOT.RooFit.bindFunction(""MyBinFunc"", learned_likelihood_ratio, x_var, mu_var); ; # Compute the real likelihood ratio; llhr_calc = ROOT.RooFormulaVar(""llhr_calc"", ""x[0] / x[1]"", [gauss, uniform]); ; # Create the exact negative log likelihood functions for Gaussian model; nll_gauss = gauss.createNLL(obs_data); ROOT.SetOwnership(nll_gauss, True); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", llhr_learned, True); ; nllr_learned = pdf_learned.createNLL(obs_data); ROOT.SetOwnership(nllr_learned, True); ; # Compute the morphed nll; morphing(ROOT.RooMomentMorphFuncND.Linear); nll_morph = workspace[""morph""].createNLL(obs_data); ROOT.SetOwnership(nll_morph, True); ; # Plot the negative logarithmic summed likelihood; frame1 = mu_var.frame(Title=""NLL of SBI vs. Morphing;mu;NLL"", Range=(2.2, 2.8)); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:6561,learn,learned,6561,doc/master/rf615__simulation__based__inference_8py.html,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html,1,['learn'],['learned']
Usability,"f& other, const char* name) :; 261 RooAbsReal(other,name),; 262 _normMgr(other._normMgr,this), _selectComp(other._selectComp), _normRange(other._normRange); 263{; 264 resetErrorCounters() ;; 265 setTraceCounter(other._traceCount) ;; 266 ; 267 if (other._specGeneratorConfig) {; 268 _specGeneratorConfig = std::make_unique<RooNumGenConfig>(*other._specGeneratorConfig);; 269 }; 270}; 271 ; 272 ; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// Destructor; 276 ; 277RooAbsPdf::~RooAbsPdf(); 278{; 279}; 280 ; 281 ; 282double RooAbsPdf::normalizeWithNaNPacking(double rawVal, double normVal) const {; 283 ; 284 if (normVal < 0. || (normVal == 0. && rawVal != 0)) {; 285 //Unreasonable normalisations. A zero integral can be tolerated if the function vanishes, though.; 286 const std::string msg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:10952,clear,clearValueAndShapeDirty,10952,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"f("" Fn+Arrow_Right : move cursor to end of line [Ctrl+E]"");; 1310 #else; 1311 Printf("" End : move cursor to end of line [Ctrl+E]"");; 1312 #endif; 1313 Printf("" Ctrl+Arrow_Left : jump to previous word [Esc,B] [Alt,B]"" FOOTNOTE);; 1314 Printf("" Ctrl+Arrow_Right : jump to next word [Esc,F] [Alt,F]"" FOOTNOTE);; 1315 ; 1316 Printf("" Backspace : delete previous character [Ctrl+H]"");; 1317 Printf("" Del : delete next character [Ctrl+D]"");; 1318 Printf("" Esc,Backspace : delete previous word [Ctrl+W] [Esc,Ctrl+H] [Alt+Backspace] [Esc,Del] [Esc,Ctrl+Del]"" FOOTNOTE);// Del is 0x7F on macOS; 1319 Printf("" Ctrl+Del : delete next word [Esc,D] [Alt,D]"" FOOTNOTE);; 1320 Printf("" Ctrl+U : cut all characters between cursor and start of line"");; 1321 Printf("" Ctrl+K : cut all characters between cursor and end of line"");; 1322 ; 1323 Printf("" Ctrl+T : transpose characters"");; 1324 Printf("" Esc,C : character to upper and jump to next word"");; 1325 Printf("" Esc,L : word to lower case and jump to its end"");; 1326 Printf("" Esc,U : word to upper case and jump to its end"");; 1327 Printf("" Ctrl+Shift+C : copy clipboard content"");; 1328 Printf("" Ctrl+Shift+V : paste clipboard content [Ctrl+Y] [Alt+Y]"");; 1329 #ifdef R__MACOSX; 1330 Printf("" Fn+Enter : toggle overwrite mode"");; 1331 #else; 1332 Printf("" Ins : toggle overwrite mode"");; 1333 #endif; 1334 ; 1335 Printf("" Ctrl+_ : undo last keypress action"");; 1336 Printf("" Tab : autocomplete command or print suggestions [Ctrl+I] [Esc,Tab]"");; 1337 Printf("" Enter : execute command [Ctrl+J] [Ctrl+M]"");; 1338 Printf("" Ctrl+L : clear prompt screen"");; 1339 Printf("" Ctrl+D : quit ROOT (if empty line)"");; 1340 Printf("" Ctrl+C : send kSigInt interrupt signal"");; 1341 Printf("" Ctrl+Z : send kSigStop pause job signal"");; 1342 ; 1343 Printf("" Arrow_Down : navigate downwards in command history [Ctrl+N]"");; 1344 Printf("" Arrow_Up : navigate upwards in command history [Ctrl+P]"");; 1345 Printf("" Ctrl+R ; Ctrl+S : search command in your history by typing a string.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:53790,undo,undo,53790,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,3,"['clear', 'pause', 'undo']","['clear', 'pause', 'undo']"
Usability,"f);; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility For example, it can be called at any computational node, such as Filter or Define, not only the head node, with no change to the ProgressBar function itself (please see the Efficient analysis in Python section for appropriate usage in Python): ROOT::RDataFrame df(""tree"", ""file.root"");; auto df_1 = ROOT::RDF::RNode(df.Filter(""x>1""));; ROOT::RDF::Experimental::AddProgressBar(df_1);; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefinition InterfaceUtils.hxx:57; Examples of implemented progress bars can be seen by running Higgs to Four Lepton tutorial and Dimuon tutorial. Efficient analysis in Python; You can use RDataFrame in Python thanks to the dynamic Python/C++ translation of PyROOT. In general, the interface is the same as for C++, a simple example follows.; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); sum = df.Filter(""x > 10"").Sum(""y""); print(sum.GetValue()). User code in the RDataFrame workflow; C++ code; In the simple example that was shown above, a C++ expression is passed to the Filter() operation as a string (""x > 0""), even if we call the method from Python. Indeed, under the hood, the analysis computations run in C++, while Python is just the interface language.; To perform more complex operations that don't fit into a simple expression string, you can just-in-time compile C++ functions - via the C++ interpreter cling - and use those functions in an expression. See the following snippet for an example:; # JIT a C++ function from Python; ROOT.gInterpreter.Declare(""""""; bool myFilter(float x) {; return x > 10;; }; """"""); ; df = ROOT.RDataFrame(""myTree"", ""myFile.root""); # Use the function in an RDF operation; sum = df.Filter(""myFilter(x)"").Sum(""y""); print(sum.GetValue()); To increase the performa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:79831,simpl,simple,79831,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"f->IsA() == TLeafD::Class()) {; 9433 ltype = 5;; 9434 }; 9435 if (leaf->IsA() == TLeafC::Class()) {; 9436 len = 1;; 9437 ltype = 5;; 9438 };; 9439 printf("" %-15s = "", leaf->GetName());; 9440 for (Int_t l = 0; l < len; l++) {; 9441 leaf->PrintValue(l);; 9442 if (l == (len - 1)) {; 9443 printf(""\n"");; 9444 continue;; 9445 }; 9446 printf("", "");; 9447 if ((l % ltype) == 0) {; 9448 printf(""\n "");; 9449 }; 9450 }; 9451 }; 9452}; 9453 ; 9454////////////////////////////////////////////////////////////////////////////////; 9455/// Start the TTreeViewer on this tree.; 9456///; 9457/// - ww is the width of the canvas in pixels; 9458/// - wh is the height of the canvas in pixels; 9459 ; 9460void TTree::StartViewer(); 9461{; 9462 GetPlayer();; 9463 if (fPlayer) {; 9464 fPlayer->StartViewer(600, 400);; 9465 }; 9466}; 9467 ; 9468////////////////////////////////////////////////////////////////////////////////; 9469/// Stop the cache learning phase; 9470///; 9471/// Returns:; 9472/// - 0 learning phase stopped or not active; 9473/// - -1 on error; 9474 ; 9475Int_t TTree::StopCacheLearningPhase(); 9476{; 9477 if (!GetTree()) {; 9478 if (LoadTree(0)<0) {; 9479 Error(""StopCacheLearningPhase"",""Could not load a tree"");; 9480 return -1;; 9481 }; 9482 }; 9483 if (GetTree()) {; 9484 if (GetTree() != this) {; 9485 return GetTree()->StopCacheLearningPhase();; 9486 }; 9487 } else {; 9488 Error(""StopCacheLearningPhase"", ""No tree is available. Could not stop cache learning phase"");; 9489 return -1;; 9490 }; 9491 ; 9492 TFile *f = GetCurrentFile();; 9493 if (!f) {; 9494 Error(""StopCacheLearningPhase"", ""No file is available. Could not stop cache learning phase"");; 9495 return -1;; 9496 }; 9497 TTreeCache *tc = GetReadCache(f,true);; 9498 if (!tc) {; 9499 Error(""StopCacheLearningPhase"", ""No cache is available. Could not stop learning phase"");; 9500 return -1;; 9501 }; 9502 tc->StopLearningPhase();; 9503 return 0;; 9504}; 9505 ; 9506///////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:364499,learn,learning,364499,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,['learn'],['learning']
Usability,"f->_args[idx].c_str()) ; }. RooCategory& as_CAT(UInt_t idx); { checkIndex(idx) ; return _of->asCAT(_of->_args[idx].c_str()) ; }. RooAbsCategoryLValue& as_CATLV(UInt_t idx); { checkIndex(idx) ; return _of->asCATLV(_of->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return _of->asCATFUNC(_of->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return _of->asSET(_of->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return _of->asLIST(_of->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return _of->asDATA(_of->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return _of->asDHIST(_of->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return _of->asDSET(_of->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return _of->asOBJ(_of->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return _of->asSTRING(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Mon Dec 7 13:47:37 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:24128,clear,clearError,24128,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"f->_args[idx].c_str()) ; }. RooCategory& as_CAT(UInt_t idx); { checkIndex(idx) ; return _of->asCAT(_of->_args[idx].c_str()) ; }. RooAbsCategoryLValue& as_CATLV(UInt_t idx); { checkIndex(idx) ; return _of->asCATLV(_of->_args[idx].c_str()) ; }. RooAbsCategory& as_CATFUNC(UInt_t idx); { checkIndex(idx) ; return _of->asCATFUNC(_of->_args[idx].c_str()) ; }. RooArgSet as_SET(UInt_t idx); { checkIndex(idx) ; return _of->asSET(_of->_args[idx].c_str()) ; }. RooArgList as_LIST(UInt_t idx); { checkIndex(idx) ; return _of->asLIST(_of->_args[idx].c_str()) ; }. RooAbsData& as_DATA(UInt_t idx); { checkIndex(idx) ; return _of->asDATA(_of->_args[idx].c_str()) ; }. RooDataHist& as_DHIST(UInt_t idx); { checkIndex(idx) ; return _of->asDHIST(_of->_args[idx].c_str()) ; }. RooDataSet& as_DSET(UInt_t idx); { checkIndex(idx) ; return _of->asDSET(_of->_args[idx].c_str()) ; }. TObject& as_OBJ(UInt_t idx); { checkIndex(idx) ; return _of->asOBJ(_of->_args[idx].c_str()) ; }. const char* as_STRING(UInt_t idx); { checkIndex(idx) ; return _of->asSTRING(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx); { checkIndex(idx) ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx); { checkIndex(idx) ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. Int_t as_INT(UInt_t idx, Int_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asINT(_of->_args[idx].c_str()) ; }. Double_t as_DOUBLE(UInt_t idx, Double_t defVal); { checkIndex(idx) ; if (idx>_of->_args.size()-1) return defVal ; return _of->asDOUBLE(_of->_args[idx].c_str()) ; }. void logError(); { _errorCount++ ; }. std::map<std::string,IFace*>& hooks(); Hooks for other tools. void clearError(); { _errorCount = 0 ; }. Int_t errorCount(); { return _errorCount ; }. » Last changed: Thu Dec 2 14:53:26 2010 » Last generated: 2010-12-02 14:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFactoryWSTool.html:24286,clear,clearError,24286,root/html528/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html528/RooFactoryWSTool.html,1,['clear'],['clearError']
Usability,"f...Definition TSystem.cxx:4194; The user may sometimes try to compile a script before it has loaded all the needed shared libraries. In this case we want to be helpful and output a list of the unresolved symbols. So if the loading of the created shared library fails, we will try to build a executable that contains the script. The linker should then output a list of missing symbols.; To support this we provide a TSystem::SetMakeExe() function, that sets the directive telling how to create an executable. The loader will need to be informed of all the libraries available. The information about the libraries that has been loaded by .L and TSystem::Load() is accessible to the script compiler. However, the information about the libraries that have been selected at link time by the application builder (like the root libraries for root.exe) are not available and need to be explicitly listed in fLinkedLibs (either by default or by a call to TSystem::SetLinkedLibs()).; To simplify customization we could also add to the .rootrc support for the variables Unix.*.Root.IncludePath: -I$ROOTSYS/include; WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; ; Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; I#define I(x, y, z); And also support for MakeSharedLibs() and MakeExe().; (the ... have to be replaced by the actual values and are here only to shorten this comment).; Note that the default behavior is to remove libraries when closing ROOT, ie TSystem::CleanCompiledMacros() is called in the TROOT destructor. The default behavior of .L script.C+ is the opposite one, leaving things after closing, without removing. In other words, .L always passes the 'k' option behind the scenes. ; Definition at line 2836 of file TSystem.cxx. ◆ ConcatFileName(). char * TSystem::ConcatFileName ; (; const char * ; dir, . const char * ; name . ). virtual . Concatenate a directory and a file name. User must delete returned string. ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:45747,simpl,simplify,45747,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['simpl'],['simplify']
Usability,"f.C and StressProof.cxx in conjunction with ProcFileElements and ProofEventProc ;  finalizeProof.CMacro to finalize queries run with the macro tutorials/runProof ;  getProof.CAttaches to a PROOF session, possibly at the indicated URL ;  ProcFileElements.CClass to hold information about the processed elements of a file ;  ProcFileElements.hClass to hold information about the processed elements of a file ;  ProofAux.CSelector used for auxiliary actions in the PROOF tutorials ;  ProofAux.hSelector used for auxiliary actions in the PROOF tutorials ;  ProofEvent.CSelector for generic processing with Event ;  ProofEvent.hSelector for generic processing with Event ;  ProofEventProc.CSelector to process trees containing Event structures ;  ProofEventProc.hSelector to process trees containing Event structures ;  ProofFriends.CSelector to process tree friends ;  ProofFriends.hSelector to process tree friends ;  ProofNtuple.CSelector to fill a simple ntuple ;  ProofNtuple.hSelector to fill a simple ntuple ;  ProofPythia.CSelector to generate Monte Carlo events with Pythia8 ;  ProofPythia.hSelector to generate Monte Carlo events with Pythia8 ;  ProofSimple.CSelector to fill a set of histograms ;  ProofSimple.hSelector to fill a set of histograms ;  ProofSimpleFile.CSelector to fill a set of histograms and merging via file ;  ProofSimpleFile.hSelector to fill a set of histograms and merging via file ;  ProofStdVect.CSelector for generic processing with stdlib collections ;  ProofStdVect.hSelector for generic processing with stdlib collections ;  ProofTests.CAuxilliary selector used to test PROOF functionality ;  ProofTests.hAuxilliary selector used to test PROOF functionality ;  runProof.CMacro to run examples of analysis on PROOF, corresponding to the TSelector implementations found under <ROOTSYS>/tutorials/proof ;  ► pyroot;  benchmarks.pyRun benchmarks macros ;  demo.pyTo run, do an ""execfile( '<path-to>/demo.py' )"" or ""python <path-to>/demo.py"" ;  demoshelp.py Display demo h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:136514,simpl,simple,136514,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"f2(myf1);. // wrapping a class member function; ROOT::Math::Functor1D f3(&myf1,&MyFunction1D::Eval);. cout << f1(2) << endl;; cout << f2(2) << endl;; cout << f3(2) << endl;. return 0;; }; 13.7.4.2 Wrapping One Dimensional Gradient Functions; The ROOT::Math::GradFunctor1D class is used to wrap one-dimensional gradient functions. It can be constructed in three different ways: * Any object implementing both double operator()( double) for the function evaluation and double Derivative(double) for the function derivative. * Any object implementing any member function like Foo::XXX(double ) for the function evaluation and any other member function like Foo::YYY(double ) for the derivative. * Any two function objects implementing double operator()( double ) . One object provides the function evaluation, the other the derivative. One or both function object can be a free C function of type double ()(double ).; 13.7.4.3 Wrapping Multi-dimensional Functions; The class ROOT::Math::Functor is used to wrap in a very simple and convenient way multi-dimensional function objects. It can wrap all the following types: * Any C++ callable object implementing double operator()( const double * ). * A free C function of type double ()(const double * ). * A member function with the correct signature like Foo::Eval(const double * ). In this case one pass the object pointer and a pointer to the member function (&Foo::Eval).; The function dimension is required when constructing the functor.; Example of using Functor:; #include ""Math/Functor.h"". class MyFunction {. public:; double operator()(const double *x) const {; return x[0]+x[1];; }. double Eval(const double * x) const { return x[0]+x[1]; }; };. double freeFunction(const double * x ); {; return x[0]+x[1];; }. int main(); {; // test directly calling the function object; MyFunction myf;. // test from a free function pointer; ROOT::Math::Functor f1(&freeFunction,2);. // test from function object; ROOT::Math::Functor f2(myf,2);. // test from a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:696378,simpl,simple,696378,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"f; inputs/outputs; * TMultilayerPerceptron provides, thanks to Andrea Bocci, the possibility to; use cross-entropy errors, which allows to train a network for pattern; classification based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly choosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been choosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:2508,clear,clear,2508,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,3,['clear'],['clear']
Usability,"fCollectFunc(collect_func),; 562 fCreateEnv(create_env),; 563 fCreateIterators(getIterators),fCopyIterator(copyIterator),fNext(next),; 564 fDeleteSingleIterator(deleteSingleIterator),fDeleteTwoIterators(deleteTwoIterators); 565 {; 566 }; 567 ; 568 /// Generate proxy from template; 569 template <class T> static TCollectionProxyInfo* Generate(const T&) {; 570 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 571 // template (used to described the behavior of the stl collection.; 572 // Typical use looks like:; 573 // ::ROOT::Detail::TCollectionProxyInfo::Generate(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 574 ; 575 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 576 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 577 return new TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 578 sizeof(TYPENAME T::Iter_t),; 579 (((char*)&p->second)-((char*)&p->first)),; 580 T::value_offset(),; 581 T::size,; 582 T::resize,; 583 T::clear,; 584 T::first,; 585 T::next,; 586 T::construct,; 587 T::destruct,; 588 T::feed,; 589 T::collect,; 590 T::Env_t::Create,; 591 T::Iterators_t::create,; 592 T::Iterators_t::copy,; 593 T::Iterators_t::next,; 594 T::Iterators_t::destruct1,; 595 T::Iterators_t::destruct2);; 596 }; 597 ; 598 template <class T> static TCollectionProxyInfo Get(const T&) {; 599 ; 600 // Generate a TCollectionProxyInfo given a TCollectionProxyInfo::Type; 601 // template (used to described the behavior of the stl collection.; 602 // Typical use looks like:; 603 // ::ROOT::Detail::TCollectionProxyInfo::Get(TCollectionProxyInfo::Pushback< std::vector<string> >()));; 604 ; 605 PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>* p =; 606 (PairHolder<TYPENAME T::Value_t, TYPENAME T::Value_t>*)0x1000;; 607 return TCollectionProxyInfo(typeid(TYPENAME T::Cont_t),; 608 sizeof(TYPENAME T::Iter_t),; 609 (((char*)&p->second)-((char*)&p->first)),; 610 T::value_offset(),; 611 T::size,; 612 T::resize,; 613 T::clear,; 614 T::firs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html:20434,clear,clear,20434,doc/master/TCollectionProxyInfo_8h_source.html,https://root.cern,https://root.cern/doc/master/TCollectionProxyInfo_8h_source.html,1,['clear'],['clear']
Usability,"fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fScreenNumber) ? ""default"" :; 833 ""custom"");; 834}; 835 ; 836////////////////////////////////////////////////////////////////////////////////; 837/// Dummy error handler for X11. Used by FindUsableVisual().; 838 ; 839static Int_t DummyX11ErrorHandler(Display *, XErrorEvent *); 840{; 841 return 0;; 842}; 843 ; 844////////////////////////////////////////////////////////////////////////////////; 845/// Check if visual is usable, if so set fVisual, fDepth, fColormap,; 846/// fBlackPixel and fWhitePixel.; 847 ; 848void TGX11::FindUsableVisual(RXVisualInfo *vlist, Int_t nitems); 849{; 850 Int_t (*oldErrorHandler)(Display *, XErrorEvent *) =; 851 XSetErrorHandler(DummyX11ErrorHandler);; 852 ; 853 XSetWindowAttributes attr;; 854 memset(&attr, 0, sizeof(attr));; 855 ; 856 Window root = RootWindow((Display*)fDisplay, fScreenNumber);; 857 ; 858 for (Int_t i = 0; i < nitems; i++) {; 859 Window w = None, wjunk;; 860 UInt_t width, height, ujunk;; 861 Int_t junk;; 862 ; 863 // try and use default colormap when possible; 864 if (vlist[i].visual == DefaultVisual((Display*)fDisplay, fScreenNumber)) {; 865 attr.colormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 866 } else {; 867 attr.colormap = XCreateColormap((Display*)fDisplay, root, vlist[i].visual, AllocNone);; 868 }; 869 ; 870 static XColor black_xcol = { 0, 0x0000, 0x0000, 0x0000, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:27289,usab,usable,27289,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['usab'],['usable']
Usability,"fNRargsnumber of redo arguments; Int_tfNUargsnumber of undo arguments; TStringfNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:17786,undo,undo,17786,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"fStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case ""undo""; can parameter be omitted. Example:; TQCommand(gPad, ""SetFillStyle(Style_t)"");. TQCommand(const TQCommand& com); Copy constructor. ~TQCommand(); dtor. TQCommand * GetCommand(); Return a command which is doing redo/undo action. This static method allows to set undo parameters dynamically, i.e.; during execution of Redo function. Example:; For redo actions like TGTextEdit::DelChar() it is not possible to; know",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:18383,undo,undo,18383,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"fTabMgrtab manager corresponding to ged-editor; Double_tTGeoTrapEditor::fThetaiInitial theta; Double_tTGeoTrapEditor::fTl1iInitial half length in x at low z and y high edge; Double_tfTwistiInitial twist angle; TGTextButton*TGeoTrapEditor::fUndoUndo-Button; UInt_tTGFrame::fWidthframe width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoGtraEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for gtra editor. ~TGeoGtraEditor(); Destructor. void SetModel(TObject* obj); Connect to a given twisted trapezoid. void DoApply(); Slot for applying current settings. void DoUndo(); Slot for undoing last operation. void DoTwist(); Change the twist angle. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoGtraEditor.html:22534,undo,undoing,22534,root/html534/TGeoGtraEditor.html,https://root.cern,https://root.cern/root/html534/TGeoGtraEditor.html,1,['undo'],['undoing']
Usability,"fTitleobject title; static TPythia6*fgInstance. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPythia6(); TPythia6 constructor: creates a TClonesArray in which it will store all; particles. Note that there may be only one functional TPythia6 object; at a time, so it's not use to create more than one instance of it. TPythia6(const TPythia6& ); { }. ~TPythia6(); Destroys the object, deletes and disposes all TMCParticles currently on list. TPythia6* Instance(); model of automatic memory cleanup suggested by Jim Kowalkovski:; destructor for local static variable `cleaner' is always called in the end; of the job thus deleting the only TPythia6 instance. void GenerateEvent(); generate event and copy the information from /HEPEVT/ to fPrimaries. void OpenFortranFile(int lun, char* name); interface with fortran i/o. void CloseFortranFile(int lun); interface with fortran i/o. TObjArray * ImportParticles(Option_t* option = """"); Fills TObjArray fParticles list with particles from common LUJETS; Old contents of a list are cleared. This function should be called after; any change in common LUJETS, however GetParticles() method calls it; automatically - user don't need to care about it. In case you make a call; to LuExec() you must call this method yourself to transfer new data from; common LUJETS to the fParticles list. Int_t ImportParticles(TClonesArray* particles, Option_t* option = """"); Default primary creation method. It reads the /HEPEVT/ common block which; has been filled by the GenerateEvent method. If the event generator does; not use the HEPEVT common block, This routine has to be overloaded by; the subclasses.; The function loops on the generated particles and store them in; the TClonesArray pointed by the argument particles.; The default action is to store only the stable particles (ISTHEP = 1); This can be demanded explicitly by setting the option = ""Final""; If the option = ""All"", all the particles are stored. void Initiali",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia6.html:12978,clear,cleared,12978,root/html528/TPythia6.html,https://root.cern,https://root.cern/root/html528/TPythia6.html,3,['clear'],['cleared']
Usability,"fUseRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodMLP.html:23506,learn,learning,23506,root/html602/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodMLP.html,10,"['clear', 'learn']","['clear', 'learning']"
Usability,"fault kIndexesBasic); Normally these functions should be called immidiately after TSQLFile constructor. When objects data written to database, by default START TRANSACTION/COMMIT; SQL commands are used before and after data storage. If TSQLFile detects; any problems, ROLLBACK command will be used to restore; previous state of data base. If transactions not supported by SQL server,; they can be disabled by SetUseTransactions(kTransactionsOff). Or user; can take responsibility to use transactions function to hime. By default only indexes for basic tables are created.; In most cases usage of indexes increase perfomance to data reading,; but it also can increase time of writing data to database.; There are several modes of index usage available in SetUseIndexes() method. There is MakeSelectQuery(TClass*) method, which; produces SELECT statement to get objects data of specified class.; Difference from simple statement like:; mysql> SELECT * FROM TH1I_ver1; that not only data for that class, but also data from parent classes; will be extracted from other tables and combined in single result table.; Such select query can be usufull for external access to objects data. Up to now MySQL 4.1 and Oracle 9i were tested.; Some extra work is required for other SQL databases.; Hopefully, this should be straigthforward. Known problems and open questions.; 1) TTree is not supported by TSQLFile. There is independent development; of TTreeSQL class, which allows to store trees directly in SQL database; 2) TClonesArray is store objects in raw format,; which can not be accessed outside ROOT.; This will be changed later.; 3) TDirectory cannot work. Hopefully, will (changes in ROOT basic I/O is required); 4) Streamer infos are not written to file, therefore schema evolution; is not yet supported. All eforts are done to enable this feature in; the near future. Example how TSQLFile can be used:. example of a session saving data to a SQL data base. const char* dbname = ""mysql://host.domain:330",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:5030,simpl,simple,5030,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['simpl'],['simple']
Usability,"fer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndexLast slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSizeMaximum size; RooNormSetCache*RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen; list<RooArgSet*>_optCacheObsList! list of all optCacheObservables owned; RooArgSet*_optCacheObservables! current optCacheObservables ; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:3724,clear,clearCacheOnServerRedirect,3724,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,4,['clear'],"['clearCacheOnServerRedirect', 'cleared']"
Usability,"fer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLeafD(); Default constructor for LeafD*-*-*-*-*-*-*-*-; *-* ============================. TLeafD(TBranch* parent, const char* name, const char* type); Create a LeafD*-*-; *-* ==============; -. ~TLeafD(); Default destructor for a LeafD*-*-*-*-*-*-; *-* ===============================. void Export(TClonesArray* list, Int_t n); -*Export element from local leaf buffer to ClonesArray; *-* ====================================================. void FillBasket(TBuffer& b); -*-*-*-*Pack leaf elements in Basket output buffer; *-* ==========================================. void Import(TClonesArray* list, Int_t n); -*Import element from ClonesArray into local leaf buffer; *-* ======================================================. void PrintValue(Int_t i = 0) const; Prints leaf value. void ReadBasket(TBuffer& b); -*-*-*-*-*Read leaf elements from Basket input buffer; *-* ===========================================. void ReadBasketExport(TBuffer& b, TClonesArray* list, Int_t n); -*-*-*-*-*Read leaf elements from Basket input buffer; and export buffer to TClonesArray objects. void ReadValue(istream& s, Char_t delim = ' '); read a double from istream s and store it into the branch buffer. void SetAddress(void* add = 0); -*-*-*-*-*Set leaf buffer data address; *-* ============================. Double_t GetValue(Int_t i = 0) const; if leaf is a simple type, i must be set to 0; if leaf is an array, i is the array element number to be returned. { return fValue[i]; }. TLeafD(). const char * GetTypeName() const; {return ""Double_t"";}. void * GetValuePointer() const; {return fValue;}. » Author: Rene Brun 12/01/96 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id$ » Last generated: 2015-03-14 16:42; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLeafD.html:9236,simpl,simple,9236,root/html534/TLeafD.html,https://root.cern,https://root.cern/root/html534/TLeafD.html,1,['simpl'],['simple']
Usability,"ference Manual . ; User's Guides . ; HowTo . ; Courses . ; Building ROOT . ; Tutorials . ; Javascript Root . ; ROOT and Spark . ; Publications . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Documentation » Courses » Introductory Tutorials Histogramming in a Selector. Preparation; As previously, we provide a ready-made TSelector derived class in a simple source file. So please download also the following source file and save it where you can find it: EventDataSelector.C (or wget http://root-mirror.github.io/training/intro/EventDataSelector.C).; This selector contains all the necessary steps to read the data from the tree branches, like the number of particles, the X position of each particle PosX[nparticles], and the absolute momentum of each particle Momentum[nparticles].; Now quit and restart ROOT (to make sure everybody starts from the same point). Then open the file again:; root[0] TFile::Open(""http://root.cern/files/introtutorials/eventdata.root"");. Adding a Data Member; Just like for the sum of event sizes, you need to add a data member to the class. As in Histogramming, we want to histogram the particles' fPosX; the type of the data member should thus be TH1F*. Don't forget to initialize the histogram pointer to 0 in the constructor, again just like for the event size sum.; Creating the Hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/histogramming-selector.html:2023,simpl,simple,2023,d/histogramming-selector.html,https://root.cern,https://root.cern/d/histogramming-selector.html,1,['simpl'],['simple']
Usability,"ference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Types |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t > Class Template Reference. ; template<typename Architecture_t, typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>>; class TMVA::DNN::TAdagrad< Architecture_t, Layer_t, DeepNet_t >Adagrad Optimizer class. ; This class represents the Adagrad Optimizer. ; Definition at line 45 of file Adagrad.h. Public Types; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  ;  Public Types inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; using Matrix_t = typename Architecture_t::Matrix_t;  ; using Scalar_t = typename Architecture_t::Scalar_t;  . Public Member Functions;  TAdagrad (DeepNet_t &deepNet, Scalar_t learningRate=0.01, Scalar_t epsilon=1e-8);  Constructor. ;  ;  ~TAdagrad ()=default;  Destructor. ;  ; Scalar_t GetEpsilon () const;  Getters. ;  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredBiasGradients ();  ; std::vector< Matrix_t > & GetPastSquaredBiasGradientsAt (size_t i);  ; std::vector< std::vector< Matrix_t > > & GetPastSquaredWeightGradients ();  ; std::vector< Matrix_t > & GetPastSquaredWeightGradientsAt (size_t i);  ;  Public Member Functions inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >;  VOptimizer (Scalar_t learningRate, DeepNet_t &deepNet);  Constructor. ;  ; virtual ~VOptimizer ()=default;  Virtual Destructor. ;  ; size_t GetGlobalStep () const;  ; Layer_t * GetLayerAt (size_t i);  ; std::vector< Layer_t * > & GetLayers ();  ; Scalar_t GetLearningRate () const;  Getters. ;  ; void IncrementGlobalStep ();  Increments the global step. ;  ; void SetLearningRate (size_t learningRate);  Setters. ;  ; void Ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html:1109,learn,learningRate,1109,doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TAdagrad.html,1,['learn'],['learningRate']
Usability,"ferent data (used by MethodCategory::GetMvaValues)Definition MethodBase.h:448; TMVA::MethodDLDefinition MethodDL.h:89; TMVA::MethodDL::TensorImpl_ttypename ArchitectureImpl_t::Tensor_t TensorImpl_tDefinition MethodDL.h:108; TMVA::MethodDL::fBatchHeightsize_t fBatchHeightThe height of the batch used to train the deep net.Definition MethodDL.h:183; TMVA::MethodDL::GetHelpMessagevoid GetHelpMessage() constDefinition MethodDL.cxx:2342; TMVA::MethodDL::fLossFunctionDNN::ELossFunction fLossFunctionThe loss function.Definition MethodDL.h:190; TMVA::MethodDL::fInputShapestd::vector< size_t > fInputShapeContains the batch size (no.Definition MethodDL.h:178; TMVA::MethodDL::fLayoutStringTString fLayoutStringThe string defining the layout of the deep net.Definition MethodDL.h:194; TMVA::MethodDL::SetInputDepthvoid SetInputDepth(int inputDepth)Setters.Definition MethodDL.h:286; TMVA::MethodDL::fYHatstd::unique_ptr< MatrixImpl_t > fYHatDefinition MethodDL.h:208; TMVA::MethodDL::Trainvoid Train()Methods for training the deep learning network.Definition MethodDL.cxx:1659; TMVA::MethodDL::GetBatchHeightsize_t GetBatchHeight() constDefinition MethodDL.h:263; TMVA::MethodDL::GetMvaValuesvirtual std::vector< Double_t > GetMvaValues(Long64_t firstEvt, Long64_t lastEvt, Bool_t logProgress)Evaluate the DeepNet on a vector of input values stored in the TMVA Event class Here we will evaluate...Definition MethodDL.cxx:2022; TMVA::MethodDL::fWeightInitializationStringTString fWeightInitializationStringThe string defining the weight initialization method.Definition MethodDL.h:197; TMVA::MethodDL::ParseMaxPoolLayervoid ParseMaxPoolLayer(DNN::TDeepNet< Architecture_t, Layer_t > &deepNet, std::vector< DNN::TDeepNet< Architecture_t, Layer_t > > &nets, TString layerString, TString delim)Pases the layer string and creates the appropriate max pool layer.Definition MethodDL.cxx:768; TMVA::MethodDL::fXInputTensorImpl_t fXInputDefinition MethodDL.h:206; TMVA::MethodDL::fRandomSeedsize_t fRandomSeedThe r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:103509,learn,learning,103509,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['learn'],['learning']
Usability,"ffect.; “NOL” No OutLine: do not draw the slices’ outlines; any property over the slices’ line is ignored. The method SetLabelFormat() is used to customize the label format. The format string must contain one of these modifiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Hor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135531,simpl,simple,135531,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ffer : "", char_buffer). # However, you can turn the buffer into a string very easily with as_string():; print(""struct.char_buffer.as_string(): "", char_buffer.as_string()); The output of this script with ROOT 6.32:; struct.char_buffer : <cppyy.LowLevelView object at 0x74c7a2682fb0>; struct.char_buffer.as_string(): foo; Deprecate the attribute pythonization of TDirectory in favor of item-getting syntax; The new recommended way to get objects from a TFile or any TDirectory in general is now via __getitem__:; tree = my_file[""my_tree""] # instead of my_file.my_tree; This is more consistent with other Python collections (like dictionaries), makes sure that member functions can’t be confused with branch names, and easily allows you to use string variables as keys.; With the new dictionary-like syntax, you can also get objects with names that don’t qualify as a Python variable. Here is a short demo:; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; The old pythonization with the __getattr__ syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34.; Removal of Python 2 support; ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8. As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer usable, e.g. root-config --python2-version; cmake -Dpyroot-python2. The cmake build system now looks for the standard Python3 package and previously custom Python-r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:21873,simpl,simple,21873,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['simpl'],['simple']
Usability,"ffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; virtual Bool_t Divide (TF1 *f1, Double_t c1=1);  Performs the operation: this = this/(c1*f1) if errors are defined (see TH1::Sumw2), errors are also recalc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1C.html:3940,clear,cleared,3940,doc/master/classTH1C.html,https://root.cern,https://root.cern/doc/master/classTH1C.html,7,['clear'],['cleared']
Usability,"ffer. ;  ; virtual Bool_t CanExtendAllAxes () const;  Returns true if all axes are extendable. ;  ; virtual Double_t Chi2Test (const TH1 *h2, Option_t *option=""UU"", Double_t *res=nullptr) const;  \( \chi^{2} \) test for comparing weighted and unweighted histograms. ;  ; virtual Double_t Chi2TestX (const TH1 *h2, Double_t &chi2, Int_t &ndf, Int_t &igood, Option_t *option=""UU"", Double_t *res=nullptr) const;  The computation routine of the Chisquare test. ;  ; virtual Double_t Chisquare (TF1 *f1, Option_t *option="""") const;  Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ;  ; virtual void ClearUnderflowAndOverflow ();  Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ;  ; TObject * Clone (const char *newname="""") const override;  Make a complete copy of the underlying object. ;  ; virtual Double_t ComputeIntegral (Bool_t onlyPositive=false);  Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ;  ; void Copy (TObject &hnew) const override;  Copy this histogram structure to newth1. ;  ; virtual void DirectoryAutoAdd (TDirectory *);  Perform the automatic addition of the histogram to the given directory. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; virtual Bool_t Divide (const TH1 *h1);  Divide this histogram by h1. ;  ; virtual Bool_t Divide (const TH1 *h1, const TH1 *h2, Double_t c1=1, Double_t c2=1, Option_t *option="""");  Replace contents of this histogram by the division of h1 by h2. ;  ; virtual Bool_t Divide (TF1 *f1, Double_t c1=1);  Performs the oper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:26640,clear,cleared,26640,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['clear'],['cleared']
Usability,"fference_type = ptrdiff_t;  ; using iterator = T *;  ; using pointer = T *;  ; using reference = T &;  ; using reverse_iterator = std::reverse_iterator< iterator >;  ; using size_type = size_t;  ; using value_type = T;  ;  Public Types inherited from ROOT::Internal::VecOps::SmallVectorBase; using Size_T = int32_t;  . Public Member Functions;  RVecImpl (const RVecImpl &)=delete;  ;  ~RVecImpl ();  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void append (in_iter in_start, in_iter in_end);  Add the specified range to the end of the SmallVector. ;  ; void append (size_type NumInputs, const T &Elt);  Append NumInputs copies of Elt to the end. ;  ; void append (std::initializer_list< T > IL);  ; template<typename in_iter , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<in_iter>::iterator_category, std::input_iterator_tag>::value>::type> ; void assign (in_iter in_start, in_iter in_end);  ; void assign (size_type NumElts, const T &Elt);  ; void assign (std::initializer_list< T > IL);  ; void clear ();  ; template<typename... ArgTypes> ; reference emplace_back (ArgTypes &&...Args);  ; iterator erase (const_iterator CI);  ; iterator erase (const_iterator CS, const_iterator CE);  ; iterator insert (iterator I, const T &Elt);  ; template<typename ItTy , typename = typename std::enable_if<std::is_convertible< typename std::iterator_traits<ItTy>::iterator_category, std::input_iterator_tag>::value>::type> ; iterator insert (iterator I, ItTy From, ItTy To);  ; iterator insert (iterator I, size_type NumToInsert, const T &Elt);  ; void insert (iterator I, std::initializer_list< T > IL);  ; iterator insert (iterator I, T &&Elt);  ; RVecImpl & operator= (const RVecImpl &RHS);  ; RVecImpl & operator= (RVecImpl &&RHS);  ; void pop_back_n (size_type NumItems);  ; T pop_back_val ();  ; void reserve (size_type N",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html:2299,clear,clear,2299,doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Detail_1_1VecOps_1_1RVecImpl.html,1,['clear'],['clear']
Usability,"fferent sequences..); 137 Bool_t color = kFALSE;; 138 Bool_t drawProgressBar = kFALSE;; 139#else; 140 Bool_t color = !gROOT->IsBatch();; 141 Bool_t drawProgressBar = kTRUE;; 142#endif; 143 DeclareOptionRef(fVerbose, ""V"", ""Verbose flag"");; 144 DeclareOptionRef(fVerboseLevel = TString(""Info""), ""VerboseLevel"", ""VerboseLevel (Debug/Verbose/Info)"");; 145 AddPreDefVal(TString(""Debug""));; 146 AddPreDefVal(TString(""Verbose""));; 147 AddPreDefVal(TString(""Info""));; 148 DeclareOptionRef(color, ""Color"", ""Flag for coloured screen output (default: True, if in batch mode: False)"");; 149 DeclareOptionRef(; 150 fTransformations, ""Transformations"",; 151 ""List of transformations to test; formatting example: \""Transformations=I;D;P;U;G,D\"", for identity, ""; 152 ""decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations"");; 153 DeclareOptionRef(fCorrelations, ""Correlations"", ""boolean to show correlation in output"");; 154 DeclareOptionRef(fROC, ""ROC"", ""boolean to show ROC in output"");; 155 DeclareOptionRef(silent, ""Silent"",; 156 ""Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory ""; 157 ""class object (default: False)"");; 158 DeclareOptionRef(drawProgressBar, ""DrawProgressBar"",; 159 ""Draw progress bar to display training, testing and evaluation schedule (default: True)"");; 160 DeclareOptionRef(fModelPersistence, ""ModelPersistence"",; 161 ""Option to save the trained model in xml file or using serialization"");; 162 ; 163 TString analysisType(""Auto"");; 164 DeclareOptionRef(analysisType, ""AnalysisType"",; 165 ""Set the analysis type (Classification, Regression, Multiclass, Auto) (default: Auto)"");; 166 AddPreDefVal(TString(""Classification""));; 167 AddPreDefVal(TString(""Regression""));; 168 AddPreDefVal(TString(""Multiclass""));; 169 AddPreDefVal(TString(""Auto""));; 170 ; 171 ParseOptions();; 172 CheckForUnusedOptions();; 173 ; 174 if (Verbose()); 175 fLogger->SetMinType(kVERBOSE);; 176 if (fVerboseLevel.CompareTo(""Debug"") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:6325,progress bar,progress bar,6325,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"fferent sequences..); 227 Bool_t color = kFALSE;; 228 Bool_t drawProgressBar = kFALSE;; 229#else; 230 Bool_t color = !gROOT->IsBatch();; 231 Bool_t drawProgressBar = kTRUE;; 232#endif; 233 DeclareOptionRef(fVerbose, ""V"", ""Verbose flag"");; 234 DeclareOptionRef(fVerboseLevel = TString(""Info""), ""VerboseLevel"", ""VerboseLevel (Debug/Verbose/Info)"");; 235 AddPreDefVal(TString(""Debug""));; 236 AddPreDefVal(TString(""Verbose""));; 237 AddPreDefVal(TString(""Info""));; 238 DeclareOptionRef(color, ""Color"", ""Flag for coloured screen output (default: True, if in batch mode: False)"");; 239 DeclareOptionRef(; 240 fTransformations, ""Transformations"",; 241 ""List of transformations to test; formatting example: \""Transformations=I;D;P;U;G,D\"", for identity, ""; 242 ""decorrelation, PCA, Uniform and Gaussianisation followed by decorrelation transformations"");; 243 DeclareOptionRef(fCorrelations, ""Correlations"", ""boolean to show correlation in output"");; 244 DeclareOptionRef(fROC, ""ROC"", ""boolean to show ROC in output"");; 245 DeclareOptionRef(silent, ""Silent"",; 246 ""Batch mode: boolean silent flag inhibiting any output from TMVA after the creation of the factory ""; 247 ""class object (default: False)"");; 248 DeclareOptionRef(drawProgressBar, ""DrawProgressBar"",; 249 ""Draw progress bar to display training, testing and evaluation schedule (default: True)"");; 250 DeclareOptionRef(fModelPersistence, ""ModelPersistence"",; 251 ""Option to save the trained model in xml file or using serialization"");; 252 ; 253 TString analysisType(""Auto"");; 254 DeclareOptionRef(analysisType, ""AnalysisType"",; 255 ""Set the analysis type (Classification, Regression, Multiclass, Auto) (default: Auto)"");; 256 AddPreDefVal(TString(""Classification""));; 257 AddPreDefVal(TString(""Regression""));; 258 AddPreDefVal(TString(""Multiclass""));; 259 AddPreDefVal(TString(""Auto""));; 260 ; 261 ParseOptions();; 262 CheckForUnusedOptions();; 263 ; 264 if (Verbose()); 265 fLogger->SetMinType(kVERBOSE);; 266 if (fVerboseLevel.CompareTo(""Debug"") ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:10235,progress bar,progress bar,10235,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"fficiency object does not; belong to any directory and will not be written to file during the; next TFile::Write() command. void SetName(const char* name); sets the name. Note: The names of the internal histograms are set to ""name + _total"" and; ""name + _passed"" respectively. Bool_t SetPassedEvents(Int_t bin, Int_t events); sets the number of passed events in the given global bin. returns ""true"" if the number of passed events has been updated; otherwise ""false"" ist returned. Note: - requires: 0 <= events <= fTotalHistogram->GetBinContent(bin). Bool_t SetPassedHistogram(const TH1& rPassed, Option_t* opt); sets the histogram containing the passed events. The given histogram is cloned and stored internally as histogram containing; the passed events. The given histogram has to be consistent with the current; fTotalHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fPassedHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fTotalHistogram is replaced by a; consistent one (with respect to rPassed) as well. void SetStatisticOption(TEfficiency::EStatOption option); sets the statistic option which affects the calculation of the confidence interval. Options:; - kFCP (=0)(default): using the Clopper-Pearson interval (recommended by PDG); sets kIsBayesian = false; see also ClopperPearson; - kFNormal (=1) : using the normal approximation; sets kIsBayesian = false; see also Normal; - kFWilson (=2) : using the Wilson interval; sets kIsBayesian = false; see also Wilson; - kFAC (=3) : using the Agresti-Coull interval; sets kIsBayesian = false; see also AgrestiCoull; - kFFC (=4) : using the Feldman-Cousins frequent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEfficiency.html:63101,clear,cleared,63101,root/html532/TEfficiency.html,https://root.cern,https://root.cern/root/html532/TEfficiency.html,4,['clear'],['cleared']
Usability,"ffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:2190,clear,clearValueAndShapeDirty,2190,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"ffset=452, len=8, method=0; i=10, fContour type= 62, offset=516, len=1, method=1081287804; i=11, fSumw2 type= 62, offset=528, len=1, method=1081287924; i=12, fOption type= 65, offset=540, len=1, method=1081288044; i=13, fFunctions type= 63, offset=548, len=1, method=1081288164; 11.5.4 Optimized StreamerInfo; The entries starting with “i = 0” is the optimized format of the StreamerInfo. Consecutive data members of the same simple type and size are collapsed and read at once into an array for performance optimization.; i= 0, TNamed type= 67, offset= 0, len=1, method=0; i= 1, TAttLine type= 0, offset= 28, len=1, method=142484480; i= 2, TAttFill type= 0, offset= 40, len=1, method=142496992; i= 3, TAttMarker type= 0, offset= 48, len=1, method=142509704; For example, the five data members beginning with fEntiesand the three data members beginning with fMaximum, are put into an array called fEntries (i = 9) with the length 8.; i= 9, fEntries type= 28, offset=452, len=8, method=0; Only simple type data members are combined, object data members are not combined. For example the three axis data members remain separate. The “method” is a handle to the method that reads the object.; 11.5.5 Automatic Schema Evolution; When a class is defined in ROOT, it must include the ClassDef macro as the last line in the header file inside the class definition. The syntax is:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particular version of the class. When a class has version 0 it is not stored in a root file but its base class(es) is(are). The reason can be that this class has no data members worth saving or all real info is in the base classes. The version number is written to the file in the Streamer by the call TBuffer::WriteVersion. You, as the designer of the class, do not need to do any manual modification in the Streamer. ROOT schema evolution mechanism is automatic and handled by the StreamerInfo.; 11.5.6 Manual Data Model Evolution Capabilities; The au",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:497135,simpl,simple,497135,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"fgInit = kFALSE;  ; static UInt_t fgLastButton = 0;  ; static Time_t fgLastClick = 0;  ; static const TGGC * fgShadowGC = nullptr;  ; static UInt_t fgUserColor = 0;  ; static const TGGC * fgWhiteGC = nullptr;  ; static Pixel_t fgWhitePixel = 0;  ;  Static Protected Attributes inherited from TGWindow; static Int_t fgCounter = 0;  counter of created windows in SavePrimitive ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TGDockableFrame.h>. Inheritance diagram for TGUndockedFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TGUndockedFrame() [1/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGUndockedFrame & ; ). privatedelete . ◆ TGUndockedFrame() [2/2]. TGUndockedFrame::TGUndockedFrame ; (; const TGWindow * ; p = nullptr, . TGDockableFrame * ; dockable = nullptr . ). Create the undocked (transient) frame. ; Definition at line 176 of file TGDockableFrame.cxx. ◆ ~TGUndockedFrame(). TGUndockedFrame::~TGUndockedFrame ; (; ). override . Delete undocked frame. Puts back dockable frame in its original container. ; Definition at line 193 of file TGDockableFrame.cxx. Member Function Documentation. ◆ Class(). static TClass * TGUndockedFrame::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGUndockedFrame::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGUndockedFrame::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 78 of file TGDockableFrame.h. ◆ CloseWindow(). void TGUndockedFrame::CloseWindow ; (; ). overridevirtual . Close undocked frame (called via WM close button). ; Reimplemented from TGMainFrame.; Definition at line 213 of file TGDockableFrame.cxx. ◆ DeclFileName(). static const char * TGUndockedFrame::DeclFileName ; (; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGUndockedFrame.html:36688,undo,undocked,36688,doc/master/classTGUndockedFrame.html,https://root.cern,https://root.cern/doc/master/classTGUndockedFrame.html,1,['undo'],['undocked']
Usability,"fication based on Bayesian posterior probability. . Introduction. Neural Networks are more and more used in various fields for data; analysis and classification, both for research and commercial; institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal; over background discrimination). More than 50% of neural networks are multilayer perceptrons. This; implementation of multilayer perceptrons is inspired from the; MLPfit; package originaly written by Jerome Schwindling. MLPfit remains; one of the fastest tool for neural networks studies, and this ROOT; add-on will not try to compete on that. A clear and flexible Object; Oriented implementation has been chosen over a faster but more; difficult to maintain code. Nevertheless, the time penalty does not; exceed a factor 2. The; MLP. The multilayer perceptron is a simple feed-forward network with; the following structure:. It is made of neurons characterized by a bias and weighted links; between them (let's call those links synapses). The input neurons; receive the inputs, normalize them and forward them to the first; hidden layer. Each neuron in any subsequent layer first computes a linear; combination of the outputs of the previous layer. The output of the; neuron is then function of that combination with f being; linear for output neurons or a sigmoid for hidden layers. This is; useful because of two theorems:. A linear combination of sigmoids can approximate any; continuous function.; Trained with output = 1 for the signal and 0 for the; background, the approximated function of inputs X is the probability; of signal, knowing X. Learning; methods. The aim of all learning methods is to minimize the total error on; a set of weighted examples. The error is defined as the sum in; quadrature, devided by two, of the error on each individual output; neuron.; In a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMultiLayerPerceptron.html:2727,simpl,simple,2727,root/html534/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html534/TMultiLayerPerceptron.html,3,['simpl'],['simple']
Usability,"fied connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datapointer to binary data ; lennumber of bytes in data . Definition at line 1630 of file RWebWindow.cxx. ◆ SendBinary() [2/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . std::string && ; data . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to be std-moved to SubmitData function . Definition at line 1619 of file RWebWindow.cxx. ◆ SetCallBacks(). void RWebWindow::SetCallBacks ; (; WebWindowConnectCallback_t ; conn, . WebWindowDataCallback_t ; data, . WebWindowConnectCallback_t ; disconn = nullptr . ). Set call-backs function for connect, data and disconnect events. ; Definition at line 1772 of file RWebWindow.cxx. ◆ SetClearOnClose(). void RWebWindow::SetClearOnClose ; (; const std::shared_ptr< void > & ; handle = nullptr). Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ; Definition at line 1764 of file RWebWindow.cxx. ◆ SetClientVersion(). void RWebWindow::SetClientVersion ; (; const std::string & ; vers). Set client version, used as prefix in scripts URL When changed, web browser will reload all related JS files while full URL will be different Default is empty value - no extra string in URL Version should be string like ""1.2"" or ""ver1.subv2"" and not contain any special symbols. ; Definition at line 1289 of file RWebWindow.cxx. ◆ SetConnectCallBack(). void RWebWindow::SetConnectCallBack ; (; WebWindowConnectCallback_t ; func). Set call-back function for new connection. ; Definition at line 1743 of file RWebWindow.cxx. ◆ SetConnLimit(). void RWebWindow::SetConnLimit ; (; unsigned ; lmt = 0). Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ; Definition at line 693 of file RWebWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:42565,clear,cleared,42565,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"fied connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datapointer to binary data ; lennumber of bytes in data . Definition at line 1672 of file RWebWindow.cxx. ◆ SendBinary() [2/2]. void RWebWindow::SendBinary ; (; unsigned ; connid, . std::string && ; data . ). Send binary data to specified connection. ; Parameters. connidconnection id, when 0 - data will be send to all connections ; datadata to be std-moved to SubmitData function . Definition at line 1661 of file RWebWindow.cxx. ◆ SetCallBacks(). void RWebWindow::SetCallBacks ; (; WebWindowConnectCallback_t ; conn, . WebWindowDataCallback_t ; data, . WebWindowConnectCallback_t ; disconn = nullptr . ). Set call-backs function for connect, data and disconnect events. ; Definition at line 1814 of file RWebWindow.cxx. ◆ SetClearOnClose(). void RWebWindow::SetClearOnClose ; (; const std::shared_ptr< void > & ; handle = nullptr). Set handle which is cleared when last active connection is closed Typically can be used to destroy web-based widget at such moment. ; Definition at line 1806 of file RWebWindow.cxx. ◆ SetClientVersion(). void RWebWindow::SetClientVersion ; (; const std::string & ; vers). Set client version, used as prefix in scripts URL When changed, web browser will reload all related JS files while full URL will be different Default is empty value - no extra string in URL Version should be string like ""1.2"" or ""ver1.subv2"" and not contain any special symbols. ; Definition at line 1331 of file RWebWindow.cxx. ◆ SetConnectCallBack(). void RWebWindow::SetConnectCallBack ; (; WebWindowConnectCallback_t ; func). Set call-back function for new connection. ; Definition at line 1785 of file RWebWindow.cxx. ◆ SetConnLimit(). void RWebWindow::SetConnLimit ; (; unsigned ; lmt = 0). Configure maximal number of allowed connections - 0 is unlimited Will not affect already existing connections Default is 1 - the only client is allowed. ; Definition at line 694 of file RWebWindow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:41449,clear,cleared,41449,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['clear'],['cleared']
Usability,"fiers:. %txt : to print the text label associated with the slice. %val : to print the numeric value of the slice. %frac : to print the relative fraction of this slice. %perc : to print the % of this slice. mypie->SetLabelFormat(""%txt (%frac)"");; See the macro $ROOTSYS/tutorials/graphics/piechart.C . The picture generated by tutorial macro piechart.C. 3.21 The User Interface for Histograms; The classes T H1 Editor and T H2 Editor provides the user interface for setting histogram’s attributes and rebinning interactively.; 3.21.1 TH1Editor. 3.21.1.1 The Style Tab; 3.21.1.1.1 Title; sets the title of the histogram.; 3.21.1.1.2 Plot; draw a 2D or 3D plot; according to the dimension, different drawing possibilities can be set.; 3.21.1.1.3 Error; add different error bars to the histogram (no errors, simple, etc.).; 3.21.1.1.4 Add; further things which can be added to the histogram (None, simple/smooth line, fill area, etc.); 3.21.1.2 2-D Plot; 3.21.1.2.1 Simple Drawing; draw a simple histogram without errors (= “HIST” draw option). In combination with some other draw options an outer line is drawn on top of the histogram; 3.21.1.2.2 Show markers; draw a marker on to of each bin (=“P” draw option).; 3.21.1.2.3 Draw bar chart; draw a bar chart (=“B” draw option).; 3.21.1.2.4 Bar option; draw a bar chart (=“BAR” draw option); if selected, it will show an additional interface elements for bars: width, offset, percentage and the possibility to draw horizontal bars.; 3.21.1.3 3-D Plot; 3.21.1.3.1 Add; set histogram type Lego-Plot or Surface draw (Lego, Lego1.2, Surf, Surf1…5).; 3.21.1.3.2 Coords; set the coordinate system (Cartesian, Spheric, etc.).; 3.21.1.3.3 Error; same as for 2D plot.; 3.21.1.3.4 Bar; set the bar attributes: width and offset.; 3.21.1.3.5 Horizontal Bar; draw a horizontal bar chart.; 3.21.1.4 The Binning tab; The binning tab has two different layouts. One is for a histogram, which is not drawn from an ntuple. The other one is available for a histogram, which ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:135712,simpl,simple,135712,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,file NeuralNet.h. ◆ endTestCycle(). virtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer shall be used (e.g. SGD) ; Definition at line 774 of file NeuralNet.h. ◆ momentum(). double TMVA::DNN::Settings::momentum ; (; ); const. inline . get the momentum (e.g. for SGD) ; Definition at line 772 of file NeuralNet.h. ◆ pads(). void TMVA::DNN::Settings::pads ; (; int ; numPads). inline . preparation for monitoring ; Definition at line 818 of file NeuralNet.h. ◆ plot(). void TMVA::DNN::Settings::plot ;,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:9000,learn,learningRate,9000,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['learn'],['learningRate']
Usability,"file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 513 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1107 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . const std::string & ; key, . std::unique_ptr< RWebDisplayHandle > & ; handle . ). private . Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ; Definition at line 482 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:23318,simpl,simpler,23318,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['simpl'],['simpler']
Usability,"file RWebWindow.hxx. Constructor & Destructor Documentation. ◆ RWebWindow(). RWebWindow::RWebWindow ; (; ). RWebWindow constructor Should be defined here because of std::unique_ptr<RWebWindowWSHandler> ; Definition at line 76 of file RWebWindow.cxx. ◆ ~RWebWindow(). RWebWindow::~RWebWindow ; (; ). RWebWindow destructor Closes all connections and remove window from manager. ; Definition at line 85 of file RWebWindow.cxx. Member Function Documentation. ◆ _CanTrustIn(). bool RWebWindow::_CanTrustIn ; (; std::shared_ptr< WebConn > & ; conn, . const std::string & ; hash, . const std::string & ; ntry, . bool ; remote, . bool ; test_first_time . ). private . Check if provided hash, ntry parameters from the connection request could be accepted. ; Parameters. hash- provided hash value which should match with HMAC hash for generated before connection key ; ntry- connection attempt number provided together with request, must come in increasing order ; remote- boolean flag indicating if request comming from remote (via real http), for local displays like Qt5 or CEF simpler connection rules are applied ; test_first_time- true if hash/ntry tested for the first time, false appears only with websocket when connection accepted by server . Definition at line 514 of file RWebWindow.cxx. ◆ _MakeSendHeader(). std::string RWebWindow::_MakeSendHeader ; (; std::shared_ptr< WebConn > & ; conn, . bool ; txt, . const std::string & ; data, . int ; chid . ). private . Internal method to prepare text part of send data Should be called under locked connection mutex. ; Definition at line 1140 of file RWebWindow.cxx. ◆ AddDisplayHandle(). unsigned RWebWindow::AddDisplayHandle ; (; bool ; headless_mode, . const std::string & ; key, . std::unique_ptr< RWebDisplayHandle > & ; handle . ). private . Add display handle and associated key Key is large random string generated when starting new window When client is connected, key should be supplied to correctly identify it. ; Definition at line 483 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:22921,simpl,simpler,22921,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['simpl'],['simpler']
Usability,"file RooTreeDataStore.cxx. ◆ attachBuffers(). void RooTreeDataStore::attachBuffers ; (; const RooArgSet & ; extObs). overridevirtual . Implements RooAbsDataStore.; Definition at line 1036 of file RooTreeDataStore.cxx. ◆ attachCache(). void RooTreeDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overrideprivatevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 229 of file RooTreeDataStore.cxx. ◆ cacheArgs(). void RooTreeDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). overridevirtual . Cache given RooAbsArgs with this tree: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 950 of file RooTreeDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooTreeDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 121 of file RooTreeDataStore.h. ◆ changeObservableName(). bool RooTreeDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Change name of internal observable named 'from' into 'to'. ; Implements RooAbsDataStore.; Definition at line 712 of file RooTreeDataStore.cxx. ◆ checkInit(). void RooTreeDataStore::checkInit ; (; ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 1080 of file RooTreeDataStore.cxx. ◆ Class(). static TClass * RooTreeDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooTreeDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooTreeDataStore.html:28357,clear,cleared,28357,doc/master/classRooTreeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooTreeDataStore.html,1,['clear'],['cleared']
Usability,"file RooVectorDataStore.cxx. ◆ weight() [1/3]. double RooVectorDataStore::weight ; (; ); const. inlineoverridevirtual . Return the weight of the last-retrieved data point. ; Implements RooAbsDataStore.; Definition at line 111 of file RooVectorDataStore.h. ◆ weight() [2/3]. virtual double RooAbsDataStore::weight ; (; ); const. virtual . Implements RooAbsDataStore. ◆ weight() [3/3]. double RooAbsDataStore::weight ; (; Int_t ; index); const. inline . Definition at line 66 of file RooAbsDataStore.h. ◆ weightError() [1/2]. void RooVectorDataStore::weightError ; (; double & ; lo, . double & ; hi, . RooAbsData::ErrorType ; etype = RooAbsData::Poisson . ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 425 of file RooVectorDataStore.cxx. ◆ weightError() [2/2]. double RooVectorDataStore::weightError ; (; RooAbsData::ErrorType ; etype = RooAbsData::Poisson); const. overridevirtual . Return the error of the current weight. ; Parameters. [in]etypeSwitch between simple Poisson or sum-of-weights statistics . Implements RooAbsDataStore.; Definition at line 390 of file RooVectorDataStore.cxx. ◆ weightVar(). RooRealVar * RooVectorDataStore::weightVar ; (; const RooArgSet & ; allVars, . const char * ; wgtName . ). private . Utility function for constructors Return pointer to weight variable if it is defined. ; Definition at line 125 of file RooVectorDataStore.cxx. Friends And Related Symbol Documentation. ◆ RooAbsCategory. friend class RooAbsCategory. friend . Definition at line 547 of file RooVectorDataStore.h. ◆ RooAbsReal. friend class RooAbsReal. friend . Definition at line 546 of file RooVectorDataStore.h. ◆ RooRealVar. friend class RooRealVar. friend . Definition at line 548 of file RooVectorDataStore.h. Member Data Documentation. ◆ _cache. RooVectorDataStore* RooVectorDataStore::_cache = nullptr. private . ! Optimization cache ; Definition at line 586 of file RooVectorDataStore.h. ◆ _cacheOwner. RooAbsArg* RooVectorDataStore::_cacheOwner = nullptr. pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:38936,simpl,simple,38936,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['simpl'],['simple']
Usability,file TH1Editor.h. ◆ fDim. TGRadioButton* TH1Editor::fDim. protected . 2D-Plot RadioButton ; Definition at line 42 of file TH1Editor.h. ◆ fDim0. TGRadioButton* TH1Editor::fDim0. protected . 3D-Plot RadioButton ; Definition at line 43 of file TH1Editor.h. ◆ fDim0lh. TGLayoutHints* TH1Editor::fDim0lh. protected . layout hints for 3D-Plot RadioButton ; Definition at line 45 of file TH1Editor.h. ◆ fDimGroup. TGHButtonGroup* TH1Editor::fDimGroup. protected . Radiobuttongroup to change 2D <-> 3D-Plot. ; Definition at line 41 of file TH1Editor.h. ◆ fDimlh. TGLayoutHints* TH1Editor::fDimlh. protected . layout hints for 2D-Plot RadioButton ; Definition at line 44 of file TH1Editor.h. ◆ fErrorCombo. TGComboBox* TH1Editor::fErrorCombo. protected . Error combo box. ; Definition at line 48 of file TH1Editor.h. ◆ fHist. TH1* TH1Editor::fHist. protected . histogram object ; Definition at line 36 of file TH1Editor.h. ◆ fHistOnOff. TGCheckButton* TH1Editor::fHistOnOff. protected . Draw a simple histogram with default options. ; Definition at line 49 of file TH1Editor.h. ◆ fMake. Bool_t TH1Editor::fMake. private . Definition at line 95 of file TH1Editor.h. ◆ fMakeB. Bool_t TH1Editor::fMakeB. private . Definition at line 96 of file TH1Editor.h. ◆ fMakeHBar. TGCheckButton* TH1Editor::fMakeHBar. protected . Draw Horizontal Bar Chart. ; Definition at line 54 of file TH1Editor.h. ◆ fOffsetNumberEntry. TGNumberEntryField* TH1Editor::fOffsetNumberEntry. protected . Shows the offset to the origin of the histogram. ; Definition at line 76 of file TH1Editor.h. ◆ fOldOffset. Double_t TH1Editor::fOldOffset. private . Definition at line 114 of file TH1Editor.h. ◆ fP1NDCold. Float_t TH1Editor::fP1NDCold[3]. private . Definition at line 101 of file TH1Editor.h. ◆ fP1old. Float_t TH1Editor::fP1old[3]. private . Definition at line 105 of file TH1Editor.h. ◆ fP2NDCold. Float_t TH1Editor::fP2NDCold[3]. private . Definition at line 102 of file TH1Editor.h. ◆ fP2old. Float_t TH1Editor::fP2old[3]. private ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1Editor.html:59226,simpl,simple,59226,doc/master/classTH1Editor.html,https://root.cern,https://root.cern/doc/master/classTH1Editor.html,1,['simpl'],['simple']
Usability,"file containing the SWAN usage statistics during July 2017 ;  timeSeriesFromCSV.py This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  timeSeriesFromCSV_TDF.C This macro illustrates the use of the time axis on a TGraph with data read from a text file containing the SWAN usage statistics during July 2017 ;  waves.C Hint: Spherical waves ;  zdemo.C This macro is an example of graphs in log scales with annotations ;  zones.C Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  zones.py Example of script showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  ► gui;  buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ;  buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ;  buttonsLayout.CThis macro gives an example of different buttons' layout ;  buttonTest.CThis macro gives an example of how to set/change text button attributes ;  calendar.CThis macro gives an example of how to use html widget to display tabular data ;  CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ;  customContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample showing how to customize a context menu for a class ;  drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to us",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:117377,simpl,simple,117377,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,3,['simpl'],['simple']
Usability,"file. When providing these; in a script, HistFactory doesn't load the histogram from the file; right away. Instead, once all such histograms have been supplied,; one should run this method to open all ROOT files and to copy and; save all necessary histograms. Measurement(); Measurement( const Measurement& other ); // Copy. void SetOutputFilePrefix(const string& prefix); set output prefix. { fOutputFilePrefix = prefix; }. std::string GetOutputFilePrefix(); retrieve prefix for output files. { return fOutputFilePrefix; }. void SetPOI(const string& POI); insert PoI at beginning of vector of PoIs. { fPOI.insert( fPOI.begin(), POI ); }. void AddPOI(const string& POI); append parameter to vector of PoIs. { fPOI.push_back(POI); }. std::string GetPOI(unsigned int i = 0); get name of PoI at given index. { return fPOI.at(i); }. std::vector<std::string>& GetPOIList(); get vector of PoI names. { return fPOI; }. void ClearConstantParams(); empty vector of constant parameters. { fConstantParams.clear(); }. std::vector< std::string >& GetConstantParams(); get vector of all constant parameters. { return fConstantParams; }. std::map<std::string, double>& GetParamValues(); get map: parameter name <--> parameter value. { return fParamValues; }. void ClearParamValues(); clear map of parameter values. { fParamValues.clear(); }. void AddFunctionObject(const RooStats::HistFactory::PreprocessFunction function); add a preprocess function object. { fFunctionObjects.push_back( function ); }. void SetFunctionObjects(vector<RooStats::HistFactory::PreprocessFunction> objects); get vector of defined function objects. { fFunctionObjects = objects; }. std::vector< RooStats::HistFactory::PreprocessFunction >& GetFunctionObjects(); { return fFunctionObjects; }. std::vector< RooStats::HistFactory::Asimov >& GetAsimovDatasets(); get vector of defined Asimov Datasets. { return fAsimovDatasets; }. void AddAsimovDataset(RooStats::HistFactory::Asimov dataset); add an Asimov Dataset. { fAsimovDatasets.push_ba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html:11948,clear,clear,11948,root/html534/RooStats__HistFactory__Measurement.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__Measurement.html,1,['clear'],['clear']
Usability,"file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » GVIZ3D; » TStructViewer. class TStructViewer: public TObject. TStructViewer viewer represents class, struct or other type as an object in 3D space.; At the top of the scene we can see objects which is our pointer. Under it we see; pointers and collection elements. Collection must inherit from TCollection; or be STL collecion. We can change the number of visible levels or objects on the scene with the GUI or; methods. The size of geometry objects is proportional to the memory taken by this object; or to the number of members inside this object. An easy way to find some class in the viewer is to change the color of the type.; We can connect for example a TF2 class with red color or connect all classes; inheriting from TF2 by adding plus to name. For example typename ""TF2+"" tells us; that all classes inheriting from TF2 will be red. Navigation in viewer is very simple like in usual GLViewer. When you put the mouse over; some object you can see some information about it (e.g. name, size, actual level).; When you double click this object, it becames top object on scene.; Undo and redo operation are supported. In this picture we can see TStructViewer with pointer to TList which contains; other collections and objects of various classes. Other screenshot presents opened TStructNodeEditor. Function Members (Methods); public:. TStructViewer(void* ptr = NULL, const char* clname = NULL); virtual~TStructViewer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TStructViewer.html:1113,simpl,simple,1113,root/html530/TStructViewer.html,https://root.cern,https://root.cern/root/html530/TStructViewer.html,3,['simpl'],['simple']
Usability,"fileLL::RooProfileLL ; (; const RooProfileLL & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 73 of file RooProfileLL.cxx. Member Function Documentation. ◆ alwaysStartFromMin(). bool RooProfileLL::alwaysStartFromMin ; (; ); const. inline . Definition at line 31 of file RooProfileLL.h. ◆ bestFitObs(). const RooArgSet & RooProfileLL::bestFitObs ; (; ); const. Definition at line 98 of file RooProfileLL.cxx. ◆ bestFitParams(). const RooArgSet & RooProfileLL::bestFitParams ; (; ); const. Definition at line 89 of file RooProfileLL.cxx. ◆ Class(). static TClass * RooProfileLL::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooProfileLL::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooProfileLL::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 70 of file RooProfileLL.h. ◆ clearAbsMin(). void RooProfileLL::clearAbsMin ; (; ). inline . Definition at line 42 of file RooProfileLL.h. ◆ clone(). TObject * RooProfileLL::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 28 of file RooProfileLL.h. ◆ createProfile(). RooFit::OwningPtr< RooAbsReal > RooProfileLL::createProfile ; (; const RooArgSet & ; paramsOfInterest). overridevirtual . Optimized implementation of createProfile for profile likelihoods. ; Return profile of original function in terms of stated parameters of interest rather than profiling recursively. ; Reimplemented from RooAbsReal.; Definition at line 112 of file RooProfileLL.cxx. ◆ DeclFileName(). static const char * RooProfileLL::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 70 of file RooProfileLL.h. ◆ evaluate(). double RooProfileLL::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate profile likelihood by minimizing likelihood w.r.t. ; all par",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooProfileLL.html:63034,clear,clearAbsMin,63034,doc/master/classRooProfileLL.html,https://root.cern,https://root.cern/doc/master/classRooProfileLL.html,1,['clear'],['clearAbsMin']
Usability,"fineSlot() works just as well with single-thread execution: in that case slot will always be 0. . DefineSlotEntry() Same as DefineSlot(), but the entry number is passed in addition to the slot number. This is meant as a helper in case the expression depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:4571,guid,guide,4571,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['guid'],['guide']
Usability,"finition FitConfig.h:109; ROOT::Fit::FitResultclass containing the result of the fit and all the related information (fitted parameter values,...Definition FitResult.h:47; ROOT::Fit::FitterFitter class, entry point for performing all type of fits.Definition Fitter.h:77; ROOT::Fit::Fitter::LikelihoodFitbool LikelihoodFit(const std::shared_ptr< UnBinData > &data, bool extended=false, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Un-binned Likelihood fit using a shared_ptr for NOT copying the input data.Definition Fitter.h:229; ROOT::Fit::Fitter::LinearFitbool LinearFit(const BinData &data)Do a linear fit copying the input data.Definition Fitter.h:247; ROOT::Fit::Fitter::LeastSquareFitbool LeastSquareFit(const std::shared_ptr< BinData > &data, const ROOT::EExecutionPolicy &executionPolicy=ROOT::EExecutionPolicy::kSequential)Fit a binned data set using a least square fit NOT copying the input data.Definition Fitter.h:179; ROOT::Fit::Fitter::EvalFCNbool EvalFCN()Perform a simple FCN evaluation.Definition Fitter.cxx:288; ROOT::Fit::Fitter::fExtObjFunctionconst ROOT::Math::IMultiGenFunction * fExtObjFunction! pointer to an external FCNDefinition Fitter.h:576; ROOT::Fit::Fitter::operator=Fitter & operator=(const Fitter &)=deleteAssignment operator (disabled, class is not copyable); ROOT::Fit::Fitter::FitFCNbool FitFCN()Perform a fit with the previously set FCN function.Definition Fitter.cxx:269; ROOT::Fit::Fitter::DoUpdateFitConfigvoid DoUpdateFitConfig()Definition Fitter.cxx:860; ROOT::Fit::Fitter::DoMinimizationbool DoMinimization(std::unique_ptr< ObjFunc_t > f, const ROOT::Math::IMultiGenFunction *chifunc=nullptr)do minimizationDefinition Fitter.cxx:836; ROOT::Fit::Fitter::DoSetFCNbool DoSetFCN(bool useExtFCN, const ROOT::Math::IMultiGenFunction &fcn, const double *params, unsigned int dataSize, int fitType)Set Objective function.Definition Fitter.cxx:137; ROOT::Fit::Fitter::fDataSizeint fDataSizesize of data sets (need for Fumili or LM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8h_source.html:30027,simpl,simple,30027,doc/master/Fitter_8h_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8h_source.html,1,['simpl'],['simple']
Usability,"finition TDataType.h:44; TEnvThe TEnv class reads config files, by default named .rootrc.Definition TEnv.h:124; TFileHandlerDefinition TSysEvtHandler.h:65; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TGX11This class is the basic interface to the X11 (Xlib) graphics system.Definition TGX11.h:80; TGaxisThe axis painter class.Definition TGaxis.h:24; TGeometryTGeometry description.Definition TGeometry.h:39; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; THashListTHashList implements a hybrid collection class consisting of a hash table and a list to store TObject...Definition THashList.h:34; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; THtmlLegacy ROOT documentation system.Definition THtml.h:40; TKeyBook space in a file, create I/O buffers, to fill them, (un)compress them.Definition TKey.h:28; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TLinkSpecial TText object used to show hyperlinks.Definition TLink.h:17; TListA doubly linked list.Definition TList.h:38; TMethodArgEach ROOT method (see TMethod) has a linked list of its arguments.Definition TMethodArg.h:36; TMethodEach ROOT class (see TClass) has a linked list of methods.Definition TMethod.h:38; TMinuitDefinition TMinuit.h:27; TObjectTableThis class registers all instances of TObject and its derived classes in a hash table.Definition TObjectTable.h:35; TObjectMother of all ROOT objects.Definition TObject.h:41; TOrdCollectionOrdered collection.Definition TOrdCollection.h:32; TPadThe most important graphics class in the ROOT system.Definition TPad.h:28; TPaveLabelA Pave (see TPave) with a text centered in the Pave.Definition TPaveLabel.h:20; TPaveTextA Pave (see TPave) with text, lines or/and boxes inside.Definition TPaveText.h:21; TPaveA TBox with a bordersize and a shadow option.Definition TPave.h:19; TPostScriptIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObjectTable.html:5157,simpl,simple,5157,doc/master/classTObjectTable.html,https://root.cern,https://root.cern/doc/master/classTObjectTable.html,1,['simpl'],['simple']
Usability,"finition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoVolume.cxx:588; TGeoVolume::SelectVolumevoid SelectVolume(Bool_t clear=kFALSE)Select this volume as matching an arbitrary criteria.Definition TGeoVolume.cxx:2325; TGeoVolume::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoVolume.cxx:1792; TGeoVolume::Classstatic TClass * Class(); TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::ClearShapevoid ClearShape()Clear the shape of this volume from the list held by the current manager.Definition TGeoVolume.cxx:668; TGeoVolume::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the volume.Definition TGeoVolume.cxx:1498; TGeoVolume::VisibleDaughtersvoid VisibleDaughters(Bool_t vis=kTRUE)set visibility for daughtersDefinition TGeoVolume.cxx:2453; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGeoVolume.cxx:2227; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8cxx_source.html:146400,clear,clear,146400,doc/master/TGeoVolume_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8cxx_source.html,1,['clear'],['clear']
Usability,"finition TGeoVolume.cxx:1812; TGeoVolume::UnmarkSavedvoid UnmarkSaved()Reset SavePrimitive bits.Definition TGeoVolume.cxx:1699; TGeoVolume::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute mouse actions on this volume.Definition TGeoVolume.cxx:1710; TGeoVolume::CloneVolumevirtual TGeoVolume * CloneVolume() constClone this volume.Definition TGeoVolume.cxx:1831; TGeoVolume::SetFindervoid SetFinder(TGeoPatternFinder *finder)Definition TGeoVolume.h:244; TGeoVolume::GetNdaughtersInt_t GetNdaughters() constDefinition TGeoVolume.h:362; TGeoVolume::IsValidBool_t IsValid() constDefinition TGeoVolume.h:154; TGeoVolume::Grabvoid Grab()Definition TGeoVolume.h:136; TGeoVolume::CheckGeometryvoid CheckGeometry(Int_t nrays=1, Double_t startx=0, Double_t starty=0, Double_t startz=0) constShoot nrays with random directions from starting point (startx, starty, startz) in the reference fram...Definition TGeoVolume.cxx:588; TGeoVolume::SelectVolumevoid SelectVolume(Bool_t clear=kFALSE)Select this volume as matching an arbitrary criteria.Definition TGeoVolume.cxx:2325; TGeoVolume::GetPointerNameconst char * GetPointerName() constProvide a pointer name containing uid.Definition TGeoVolume.cxx:1792; TGeoVolume::GetNodesTObjArray * GetNodes()Definition TGeoVolume.h:169; TGeoVolume::SetTransparencyvoid SetTransparency(Char_t transparency=0)Definition TGeoVolume.h:376; TGeoVolume::ClearShapevoid ClearShape()Clear the shape of this volume from the list held by the current manager.Definition TGeoVolume.cxx:668; TGeoVolume::SetFWExtensionvoid SetFWExtension(TGeoExtension *ext)Connect framework defined extension to the volume.Definition TGeoVolume.cxx:1498; TGeoVolume::VisibleDaughtersvoid VisibleDaughters(Bool_t vis=kTRUE)set visibility for daughtersDefinition TGeoVolume.cxx:2453; TGeoVolume::Releasevoid Release()Definition TGeoVolume.h:137; TGeoVolume::FindOverlapsvoid FindOverlaps() constloop all nodes marked as overlaps and find overlapping brothersDefinition TGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoVolume_8h_source.html:38888,clear,clear,38888,doc/master/TGeoVolume_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoVolume_8h_source.html,1,['clear'],['clear']
Usability,"finition at line 105 of file TSelectorDraw.cxx. ◆ Class(). static TClass * TSelectorDraw::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TSelectorDraw::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TSelectorDraw::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 121 of file TSelectorDraw.h. ◆ ClearFormula(). void TSelectorDraw::ClearFormula ; (; ). protectedvirtual . Delete internal buffers. ; Definition at line 941 of file TSelectorDraw.cxx. ◆ CompileVariables(). bool TSelectorDraw::CompileVariables ; (; const char * ; varexp = """", . const char * ; selection = """" . ). protectedvirtual . Compile input variables and selection expression. ; varexp is an expression of the general form e1:e2:e3 where e1,etc is a formula referencing a combination of the columns; Example: varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim distribution of y versus sqrt(x); selection is an expression with a combination of the columns; Example: selection = ""x<y && sqrt(z)>3.2""; in a selection all the C++ operators are authorized; Return false if any of the variable is not compilable. ; Definition at line 976 of file TSelectorDraw.cxx. ◆ DeclFileName(). static const char * TSelectorDraw::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 121 of file TSelectorDraw.h. ◆ GetAction(). virtual Int_t TSelectorDraw::GetAction ; (; ); const. inlinevirtual . Definition at line 80 of file TSelectorDraw.h. ◆ GetCleanElist(). virtual bool TSelectorDraw::GetCleanElist ; (; ); const. inlinevirtual . Definition at line 81 of file TSelectorDraw.h. ◆ GetDimension(). virtual Int_t TSelectorDraw::GetDimension ; (; ); const. inlinevirtual . Definition at line 82 of file TSelectorDraw.h. ◆ GetDrawFlag(). virtual Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelectorDraw.html:18695,simpl,simplest,18695,doc/master/classTSelectorDraw.html,https://root.cern,https://root.cern/doc/master/classTSelectorDraw.html,1,['simpl'],['simplest']
Usability,"finition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weight gradients, given some other weight gradients and learning rate. ; Definition at line 438 of file GeneralLayer.h. ◆ UpdateWeights(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeights ; (; const std::vector< Matrix_t > & ; weightGradients, . const Scalar_t ; learningRate . ). Updates the weights, given the gradients and the learning rate,. ; Definition at line 418 of file GeneralLayer.h. ◆ WriteMatrixToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteMatrixToXML ; (; void * ; node, . const char * ; name, . const Matrix_t & ; matrix . ). Definition at line 521 of file GeneralLayer.h. ◆ WriteTensorToXML(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::WriteTensorToXML ; (; void * ; node, . const char * ; name, . const std::vector< Matrix_t > & ; tensor . ). helper functions for XML ; Definition at line 496 of file GeneralLayer.h. Member Data Documentation. ◆ fActivationGradients. template<typename Architecture_t > . Tensor_t TMVA::DNN::VGeneralLayer< Architecture_t >::fActivationGradients. protected . Gradients w.r.t. the activations of this layer. ; Definition at line 78 of file GeneralLayer.h. ◆ fBatchSize. template<typename Architecture_t > . size_t TMVA::DNN::VGeneralLayer< Architecture_t >::fBatchS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:26692,learn,learning,26692,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learning']
Usability,"finition at line 730 of file TEventIter.cxx. Member Function Documentation. ◆ Class(). static TClass * TEventIterTree::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEventIterTree::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEventIterTree::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 188 of file TEventIter.h. ◆ DeclFileName(). static const char * TEventIterTree::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 188 of file TEventIter.h. ◆ GetCacheSize(). Long64_t TEventIterTree::GetCacheSize ; (; ). overridevirtual . Return the size in bytes of the cache, if any Return -1 if not used. ; Implements TEventIter.; Definition at line 742 of file TEventIter.cxx. ◆ GetLearnEntries(). Int_t TEventIterTree::GetLearnEntries ; (; ). overridevirtual . Return the number of entries in the learning phase. ; Implements TEventIter.; Definition at line 751 of file TEventIter.cxx. ◆ GetNextEvent(). Long64_t TEventIterTree::GetNextEvent ; (; ). overridevirtual . Get next event. ; Implements TEventIter.; Definition at line 1189 of file TEventIter.cxx. ◆ GetNextPacket(). Int_t TEventIterTree::GetNextPacket ; (; Long64_t & ; first, . Long64_t & ; num . ). overridevirtual . Get loop range. ; Implements TEventIter.; Definition at line 1009 of file TEventIter.cxx. ◆ GetTrees(). TTree * TEventIterTree::GetTrees ; (; TDSetElement * ; elem). private . Create a Tree for the main TDSetElement and for all the friends. ; Returns the main tree or 0 in case of an error. ; Definition at line 760 of file TEventIter.cxx. ◆ IsA(). TClass * TEventIterTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEventIter.; Definition at line 188 of file TEventIter.h. ◆ Load(). TTree * TEventIterTree::Load ; (; TDSetElement * ; elem, . B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEventIterTree.html:14371,learn,learning,14371,doc/master/classTEventIterTree.html,https://root.cern,https://root.cern/doc/master/classTEventIterTree.html,1,['learn'],['learning']
Usability,"finition of a method; 76 // that will discern whether a Box is included into another one; 77 class BoxContainer; 78 {; 79 private:; 80 const Box& fBox;; 81 public:; 82 //Constructs the BoxContainer object with a Box that is meant; 83 //to include another one that will be provided later; 84 BoxContainer(const Box& b): fBox(b) {}; 85 ; 86 bool operator() (const Box& b1); 87 { return operator()(fBox, b1); }; 88 ; 89 // Looks if b2 is included in b1; 90 bool operator() (const Box& b1, const Box& b2); 91 {; 92 bool isIn = true;; 93 vector<double>::const_iterator boxit = b2.fMin.begin();; 94 vector<double>::const_iterator bigit = b1.fMax.begin();; 95 while ( isIn && boxit != b2.fMin.end() ); 96 {; 97 if ( (*boxit) >= (*bigit) ) isIn = false;; 98 ++boxit;; 99 ++bigit;; 100 }; 101 ; 102 boxit = b2.fMax.begin();; 103 bigit = b1.fMin.begin();; 104 while ( isIn && boxit != b2.fMax.end() ); 105 {; 106 if ( (*boxit) <= (*bigit) ) isIn = false;; 107 ++boxit;; 108 ++bigit;; 109 }; 110 ; 111 return isIn;; 112 }; 113 };; 114 ; 115 // Another helper class to be used in std::for_each to simplify; 116 // the code later. It implements the operator() to know if a; 117 // specified Box is big enough to contain any 'space' inside.; 118 class AreaComparer; 119 {; 120 public:; 121 AreaComparer(vector<double>::iterator iter):; 122 fThereIsArea(true),; 123 fIter(iter),; 124 fLimit(8 * std::numeric_limits<double>::epsilon()); 125 {};; 126 ; 127 void operator() (double value); 128 {; 129 if ( fabs(value- (*fIter)) < fLimit ); 130// if ( TMath::AreEqualRel(value, (*fIter), fLimit) ); 131 fThereIsArea = false;; 132 ; 133 ++fIter;; 134 }; 135 ; 136 bool IsThereArea() { return fThereIsArea; }; 137 ; 138 private:; 139 bool fThereIsArea;; 140 vector<double>::iterator fIter;; 141 double fLimit;; 142 };; 143 ; 144 ; 145 // This is the key of the SparseData structure. This method; 146 // will, by recursion, divide the area passed as an argument in; 147 // min and max into pieces to insert the Box defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:3545,simpl,simplify,3545,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,1,['simpl'],['simplify']
Usability,"fit panel!; First, we draw the distribution of the vertex position along X for all muons. Do that into a histogram that has 20 bins and runs from -10 to +10. Now open the fit panel and click the histogram. We want to fit a Gaussian distribution - and hat's already selected by default. Se just press ""Fit"". Looks good, right?; Fit Parameters; As mentioned before, fitting means finding the optimal set of parameters. In the menu, select ""Options"", ""Fit Parameters"" (and resize the statistics box to make its content readable). You will see the values that the minimizer has found optimal, for instance it chose 1.2 as the mean of the Gaussian and 1.041 as the width.; These values are the crucial ones for physicists: they reduce the large amount of data into just a few parameters, describing the distribution even better than the original histogram. Fitting (or ""parametrization"") is thus a cornerstone of any physics analysis.; . ‹ 3. Examining a TTree's data; up; 6. Multivariate Analysis ›. Navigate through this book; 0. Setting up ROOT; 1. Extracting an object from a TFile; 2. Running code in ROOT; 4. Histogramming; 3. Examining a TTree's data; 5. Fitting; 6. Multivariate Analysis; 7. Using the TTreeReader; 8. Efficiency Calculation; 9. Fitting By Coding; 10. Go Parallel!; TutorialSelector.C; 11. Done!. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/5-fitting.html:4273,guid,guidelines,4273,d/5-fitting.html,https://root.cern,https://root.cern/d/5-fitting.html,1,['guid'],['guidelines']
Usability,"fixing shapes with negative parameters (run-...Definition TGeoManager.cxx:1480; Now we are really done with geometry building stage, but we would like to see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; kMagenta@ kMagentaDefinition Rtypes.h:66; TGeoManager::SetTopVisiblevoid SetTopVisible(Bool_t vis=kTRUE)make top volume visible on screenDefinition TGeoManager.cxx:2396. Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at rootgeom.C. You will notice that this is a bit more complex that just creating the ""world"" since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: ""OK, I understand the first lines that load the libGeom library and create; a geometry manager object. I also recognize from the previous example the following; lines creating some materials and media, but what about the geometrical transformations below?""; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on ""containment"". This is accomplished by ""positioning"" some volumes ""inside"" others. Any volume is an un-positioned object in the sense that it defines only a ""local frame"" (matching the one of its ""shape""). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a ""local geometrical ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:7842,learn,learn,7842,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['learn'],['learn']
Usability,"fo);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gOptDictionaryFileName.c_str(),; 3643 moduleName.c_str(), moduleName.c_str());; 3644 }; 3645 }; 3646 ; 3647 // All methods below just forward to the child and the default method.; 3648 virtual void clear() override; 3649 {; 3650 fChild->clear();; 3651 DiagnosticConsumer::clear();; 3652 }; 3653 ; 3654 virtual void BeginSourceFile(const clang::LangOptions &LangOpts, const clang::Preprocessor *PP) override; 3655 {; 3656 fChild->BeginSourceFile(LangOpts, PP);; 3657 DiagnosticConsumer::BeginSourceFile(LangOpts, PP);; 3658 }; 3659 ; 3660 virtual void EndSourceFile() override; 3661 {; 3662 fChild->EndSourceFile();; 3663 DiagnosticConsumer::EndSourceFile();; 3664 }; 3665 ; 3666 virtual void finish() override; 3667 {; 3668 fChild->finish();; 3669 DiagnosticConsumer::finish();; 3670 }; 3671 ; 3672 virtual bool IncludeInDiagnosticCounts() const override { return fChild->IncludeInDiagnosticCounts(); }; 3673};; 3674 ; 3675static void MaybeSuppressWin32CrashDialogs() {; 3676#if defined(_WIN32) && defined(_MSC_VER); 3677 // Suppress error dialogs to avoid hangs on build nodes.; 3678 // One can use an environment variable (Cling_GuiOnAssert) to enable; 3679 // the error dialogs.; 3680 const char *EnablePopups = getenv(""Cling_GuiOnAssert"");; 3681 if (EnablePopups == nullptr || EnablePopups[0] == '0') {; 3682 ::_set_error_mode(_OUT_TO_STDERR);; 3683 _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3684 _CrtSetReportFile(_CRT_WARN, _CRTDBG_FILE_STDERR);; 3685 _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_FILE | _CRTDBG_MODE_DEBUG);; 3686 _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);; 3687 _CrtSe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:145866,clear,clear,145866,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,3,['clear'],['clear']
Usability,"foldSys ;  testUnfold5a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  concurrentfill.cxx;  draw.cxx;  histops.cxx;  histspeedtest.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3tasks.CThis script is a representation using TTasks of the Geant3 simulation program This example uses directly TTask objects ;  hsimple.C This program creates : ;  htmlex.CThis file demonstrates how THtml can document sources ;  MyTasks.cxxA set of classes deriving from TTask ;  regexp.CA regular expression,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:160827,simpl,simple,160827,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"for defining the placement of a volume with respect to its container reference frame. This frame will be called 'master' and the frame of the positioned volume - 'local'. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as 'volumes-inside-volumes', the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{12} & r_{13} & 0 \\; r_{21} & r_{22} & r_{23} & 0 \\; r_{31} & r_{32} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; t_x & t_y & t_z & 1; \end{array}; \right|; \]. Scale:. \[; \left|\begin{array}{cccc}; s_x & 0 & 0 & 0 \\; 0 & s_y & 0 & 0 \\; 0 & 0 & s_z & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse rotation:. \[; \left|\begin{array}{cccc}; r_{11} & r_{21} & r_{31} & 0 \\; r_{12} & r_{22} & r_{32} & 0 \\; r_{13} & r_{23} & r_{33} & 0 \\; 0 & 0 & 0 & 1; \end{array}; \right|; \]. Inverse translation:. \[; \left|\begin{array}{cccc}; 1 & 0 & 0 & 0 \\; 0 & 1 & 0 & 0 \\; 0 & 0 & 1 & 0 \\; -t_x & -t_y & -t_z & 1; \end{array}; \right|; \]. Inverse scale:. \[; \left|\begin{array}{cccc}; \frac{1}{s_x} & 0 & 0 & 0 \\; 0 & \frac{1}{s_y} & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:54657,simpl,simple,54657,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"for defining the placement of a volume with respect to its container reference frame. This frame will be called ‘master’ and the frame of the positioned volume - ‘local’. If T is a transformation used for positioning volume daughters, then: MASTER = T * LOCAL; Therefore Tis used to perform a local to master conversion, while T-1 for a master to local conversion. The second use case is the computation of the global transformation of a given object in the geometry. Since the geometry is built as ‘volumes-inside-volumes’, the global transformation represents the pile-up of all local transformations in the corresponding branch. Once a given object in the hierarchy becomes the current one, the conversion from master to local coordinates or the other way around can be done from the manager class.; A general homogenous transformation is defined as a 4x4 matrix embedding a rotation, a translation and a scale. The advantage of this description is that each basic transformation can be represented as a homogenous matrix, composition being performed as simple matrix multiplication.; Rotation: \(\left|\begin{array}{cccc} r_{11} & r_{12} & r_{13} & 0 \\ r_{21} & r_{22} & r_{23} & 0 \\ r_{31} & r_{32} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Translation: \(\left|\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ t_x & t_y & t_z & 1 \end{array} \right|\) Scale: \(\left|\begin{array}{cccc} s_x & 0 & 0 & 0 \\ 0 & s_y & 0 & 0 \\ 0 & 0 & s_z & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\); Inverse rotation: \(\left|\begin{array}{cccc} r_{11} & r_{21} & r_{31} & 0 \\ r_{12} & r_{22} & r_{32} & 0 \\ r_{13} & r_{23} & r_{33} & 0 \\ 0 & 0 & 0 & 1 \end{array} \right|\) Inverse translation: \(\left|\begin{array}{cccc} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ -t_x & -t_y & -t_z & 1 \end{array} \right|\) Inverse scale: \(\left|\begin{array}{cccc} \frac{1}{s_x} & 0 & 0 & 0 \\ 0 & \frac{1}{s_y} & 0 & 0 \\ 0 & 0 & \frac{1}{s_z} & 0 \\ 0 & 0 & 0 & 1 \end{array} ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:962310,simpl,simple,962310,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"for extended likelihood calculation, which is the sum of all coefficients. ;  ; ExtendMode extendMode () const override;  Returns ability of PDF to provide extended likelihood terms. ;  ; bool forceAnalyticalInt (const RooAbsArg &arg) const override;  ; const RooArgList & funcList () const;  ; Int_t getAnalyticalIntegralWN (RooArgSet &allVars, RooArgSet &numVars, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Advertise that all integrals can be handled internally. ;  ; bool getFloor () const;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Check if all components that depend on obs are binned. ;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooRealSumPdf to more intuitively reflect the contents of the product operator construction. ;  ; bool selfNormalized () const override;  Shows if a PDF is self-normalized, which means that no attempt is made to add a normalization term. ;  ; void setCacheAndTrackHints (RooArgSet &) override;  Label OK'ed components of a RooRealSumPdf with cache-and-track. ;  ; void setFloor (bool flag);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, double minVal, double maxVal);  Constructor with name, title, and plot range. ;  ;  RooAbsPdf (const char *name, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooRealSumPdf.html:5150,intuit,intuitively,5150,doc/v632/classRooRealSumPdf.html,https://root.cern,https://root.cern/doc/v632/classRooRealSumPdf.html,2,['intuit'],['intuitively']
Usability,"for pattern classification based on Bayesian posterior probability. Introduction; Neural Networks are more and more used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are:. image analysis; financial movements predictions and analysis; sales forecast and product shipping optimisation; in particles physics: mainly for classification tasks (signal over background discrimination). More than 50% of neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package originally written by Jerome Schwindling. MLPfit remains one of the fastest tool for neural networks studies, and this ROOT add-on will not try to compete on that. A clear and flexible Object Oriented implementation has been chosen over a faster but more difficult to maintain code. Nevertheless, the time penalty does not exceed a factor 2. The MLP; The multilayer perceptron is a simple feed-forward network with the following structure:. It is made of neurons characterized by a bias and weighted links between them (let's call those links synapses). The input neurons receive the inputs, normalize them and forward them to the first hidden layer.; Each neuron in any subsequent layer first computes a linear combination of the outputs of the previous layer. The output of the neuron is then function of that combination with f being linear for output neurons or a sigmoid for hidden layers. This is useful because of two theorems:. A linear combination of sigmoids can approximate any continuous function.; Trained with output = 1 for the signal and 0 for the background, the approximated function of inputs X is the probability of signal, knowing X. Learning methods; The aim of all learning methods is to minimize the total error on a set of weighted examples. The error is defined as the sum in quadrature, divided by two, of the error on each individual output neuron. In all methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:2729,simpl,simple,2729,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;; ; // Create the table; TGTable *table = new TGTable(mainframe, 999, iface, 10, 6);; ; // Add the table to the main frame; mainframe->AddFrame(table, new TGLayoutHints(kLHintsExpandX | kLHintsExpandY));; ; // Set a selection; iface->SetSelection(""px > 0."");; // Add a column; iface->AddColumn(""(px+py)/(px-py)"", 0);; //update the table view; table->Update();; ; // Layout and map the main frame; mainframe->SetWindowName(""Tree Table Test"") ;; mainframe->MapSubwindows() ;; mainframe->Layout();; mainframe->Resize() ;; mainframe->MapWindow() ;; ; return mainframe;; }; TDirectoryFile::GetTObject * Get(const char *namecycle) overrideReturn pointer to object identified by namecycle.Definition TDirectoryFile.cxx:937; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TTreeTableInterfaceTTreeTableInterface is used to interface to data that is stored in a TTree.Definition TTreeTableInterface.h:25; TTreeTableInterface::SetSelectionvirtual void SetSelection(const char *selection)Set the selection expression.Definition TTreeTableInterface.cxx:140; TTreeTableInterface::AddColumnvirtual void AddColumn(const char *expression, UInt_t position)Add column according ot expression at position, TGTable->Update() is needed afterwards to apply the c...Definition TTreeTableInterface.cxx:378. Definition at line 34 of file TGTable.h. Public Member Functions;  TGTable (const TGWindow *p=nullptr, Int_t id=0, TVirtualTableInterface *interface=nullptr, UInt_t nrows=50, UInt_t ncolumns=20);  TGTable constuctor. ;  ;  ~TGTable () override;  TGTable destructor. ;  ; virtual TGTableCell * FindCell (TGString label);  Find the TGTableCell with label. ;  ; virtual const TGTableCell * FindCell (TGString label) const;  ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTable.html:5833,simpl,simple,5833,doc/master/classTGTable.html,https://root.cern,https://root.cern/doc/master/classTGTable.html,1,['simpl'],['simple']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id$ » Last generated: 2015-03-14 16:49; This page has been automatically generated. For comments ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSessionOutputFrame.html:18902,feedback,feedback,18902,root/html534/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html534/TSessionOutputFrame.html,1,['feedback'],['feedback']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:20; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSessionOutputFrame.html:18783,feedback,feedback,18783,root/html528/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html528/TSessionOutputFrame.html,1,['feedback'],['feedback']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:37; This pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSessionOutputFrame.html:18883,feedback,feedback,18883,root/html530/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html530/TSessionOutputFrame.html,1,['feedback'],['feedback']
Usability,"frame width; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. private:. TGLVEntry*fEntryTmpused to transfer to feedback; TGLVContainer*fLVContaineroutput list view; TSessionViewer*fViewerpointer on the main viewer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSessionOutputFrame(TGWindow* parent, Int_t w, Int_t h); Constructor. ~TSessionOutputFrame(); Destructor. void Build(TSessionViewer* gui); Build query output information frame. void OnElementClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle mouse clicks on list view items. void OnElementDblClicked(TGLVEntry* entry, Int_t btn, Int_t x, Int_t y); Handle double-clicks on list view items. void AddObject(TObject* obj); Add object to output list view. TGLVContainer * GetLVContainer(); { return fLVContainer; }. void RemoveAll(); { fLVContainer->RemoveAll(); }. » Author: Marek Biskup, Jakub Madejczyk, Bertrand Bellenot 10/08/2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/sessionviewer:$Id: TSessionViewer.h 40088 2011-06-30 15:10:06Z bellenot $ » Last generated: 2011-11-03 20:22; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TSessionOutputFrame.html:18883,feedback,feedback,18883,root/html532/TSessionOutputFrame.html,https://root.cern,https://root.cern/root/html532/TSessionOutputFrame.html,1,['feedback'],['feedback']
Usability,"freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Tue Jun 30 14:30:45 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddModel.html:53171,intuit,intuitively,53171,root/html602/RooAddModel.html,https://root.cern,https://root.cern/root/html602/RooAddModel.html,1,['intuit'],['intuitively']
Usability,"freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Tue Mar 10 17:14:23 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddModel.html:51514,intuit,intuitively,51514,root/html534/RooAddModel.html,https://root.cern,https://root.cern/root/html534/RooAddModel.html,1,['intuit'],['intuitively']
Usability,"from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; virtual void ResetCache ();  This will simply clear the cache. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; Int_t SetBufferSize (Int_t buffersize) override;  Change the underlying buffer size of the cache. ;  ; virtual void SetEntryRange (Long64_t emin, Long64_t emax);  Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ;  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; virtual void StopLearningPhase ();  This is the counterpart of StartLearningPhase() and can be used to stop the learning phase. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UpdateBranches (TTree *tree);  Update pointer to current Tree and recompute pointers to the branches in the cache. ;  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:15886,learn,learning,15886,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"fter a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Private Attributes; Architecture_t::ActivationDescriptor_t fActivationDesc;  ; Tensor_t fDerivatives;  activation function gradient ;  ; Scalar_t fDropoutProbability;  Probability that an input is active. ;  ; EActivationFunction fF;  Activation function of the layer. ;  ; Tensor_t fInputActivation;  output of GEMM and input to activation function ;  ; ERegularization fReg;  The regularization method. ;  ; Scalar_t fWeightDecay;  The weight decay. ;  . Additional Inherited Members;  Protected Attributes inherited from",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html:7093,learn,learningRate,7093,doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDenseLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ful application of the log view is interactive cherry-picking: just press 'C' to cherry-pick currently selected commit into your current branch.; Blame view; Blame view is extremely useful to see which lines were committed by whom. It is an improved version of the standard git blame command with a much clearer and interactive output.; Each line can be selected to display the associated full commit log and diff. Usage:; tig blame path/to/file.cxx. Interactive staging and current status; tig status opens an interactive display to quickly select files to be staged. Move over the file and press 'u' to (un)stage it. The .gitconfig file; This file contains global (~/.gitconfig) or repository-local configuration settings. You can (eg):. Set user and email information to label commits usefully:; git config --global user.name ""Chris Green"" ; git config --global user.email <email-address>. Set colors for various types of command output.; Set which local branches track which remote branches.; Set pull behavior for branches to be rebase rather than merge.; Define aliases as shortcuts for internal or external commands. See the attached .gitconfig example. Have fun!; Reproduced with permission from the following page: https://cdcvs.fnal.gov/redmine/projects/cet-is-public/wiki/GitTipsAndTri... by Chris Green. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:19044,guid,guidelines,19044,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['guid'],['guidelines']
Usability,"function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:7581,simpl,simple,7581,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 80 of file RooBifurGauss.cxx. ◆ IsA(). TClass * RooBifurGauss::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 49 of file RooBifurGauss.h. ◆ Streamer(). void RooBifurGauss::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooBifurGauss::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooBifurGauss.h. ◆ translate(). void RooBifurGauss::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 65 of file RooBifurGauss.cxx. Member Data Documentation. ◆ mean. RooRealProxy RooBifurGauss::mean. protected . Definition at line 40 of file RooBifurGauss.h. ◆ sigmaL. RooRealProxy RooBifurGauss::sigmaL. protected . Definition at line 41 of file RooBifurGauss.h. ◆ sigmaR. RooRealProxy RooBifurGauss::sigmaR. protected . Definition at line 42 of file RooBifurGauss.h. ◆ x. RooRealProxy RooBifurGauss::x. protected . Definition at ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBifurGauss.html:77941,simpl,simple,77941,doc/master/classRooBifurGauss.html,https://root.cern,https://root.cern/doc/master/classRooBifurGauss.html,1,['simpl'],['simple']
Usability,"function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 80 of file RooEfficiency.cxx. ◆ IsA(). TClass * RooEfficiency::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 48 of file RooEfficiency.h. ◆ Streamer(). void RooEfficiency::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooEfficiency::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 48 of file RooEfficiency.h. ◆ translate(). void RooEfficiency::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 90 of file RooEfficiency.cxx. Member Data Documentation. ◆ _cat. RooCategoryProxy RooEfficiency::_cat. protected . Accept/reject categort. ; Definition at line 44 of file RooEfficiency.h. ◆ _effFunc. RooRealProxy RooEfficiency::_effFunc. protected . Efficiency modeling function. ; Definition at line 45 of file RooEfficiency.h. ◆ _sigCatName. TString RooEfficiency::_sigCatName. protected . Name of accept state of accept/reject ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEfficiency.html:78465,simpl,simple,78465,doc/master/classRooEfficiency.html,https://root.cern,https://root.cern/doc/master/classRooEfficiency.html,1,['simpl'],['simple']
Usability,"g > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &otherColl) const;  Check if this and other collection have identically-named contents. ;  ; RooAbsArg * find (const char *n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:8743,clear,clear,8743,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['clear'],['clear']
Usability,"g > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debugging purposes. ;  ; bool empty () const;  ; const_iterator end () const;  ; bool equals (const RooAbsCollection &other",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgList.html:6159,clear,clear,6159,doc/master/classRooArgList.html,https://root.cern,https://root.cern/doc/master/classRooArgList.html,1,['clear'],['clear']
Usability,"g > var, bool silent=false);  Add an argument and transfer the ownership to the collection from a std::unique_ptr. ;  ; template<class Arg_t > ; bool addTyped (const RooAbsCollection &list, bool silent=false);  Adds elements of a given RooAbsCollection to the container if they match the specified type. ;  ; bool allInRange (const char *rangeSpec) const;  Return true if all contained object report to have their value inside the specified range. ;  ; void assign (const RooAbsCollection &other) const;  Sets the value, cache and constant attribute of any argument in our set that also appears in the other set. ;  ; void assignFast (const RooAbsCollection &other, bool setValDirty=true) const;  Functional equivalent of assign() but assumes this and other collection have same layout. ;  ; RooAbsCollection & assignValueOnly (const RooAbsCollection &other, bool forceIfSizeOne=false);  Sets the value of any argument in our set that also appears in the other set. ;  ; const_iterator begin () const;  ; void clear ();  Clear contents. If the collection is owning, it will also delete the contents. ;  ; virtual TObject * clone (const char *newname) const =0;  ; TObject * Clone (const char *newname=nullptr) const override;  Make a clone of an object using the Streamer facility. ;  ; bool contains (const RooAbsArg &var) const;  Check if collection contains an argument with the same name as var. ;  ; virtual bool containsInstance (const RooAbsArg &var) const;  Check if this exact instance is in this collection. ;  ; std::string contentsString () const;  Return comma separated list of contained object names as STL string. ;  ; virtual TObject * create (const char *newname) const =0;  ; Int_t defaultPrintContents (Option_t *opt) const override;  Define default RooPrinable print options for given Print() flag string For inline printing only show value of objects, for default print show name,class name value and extras of each object. ;  ; void dump () const;  Base contents dumper for debu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCollection.html:5154,clear,clear,5154,doc/master/classRooAbsCollection.html,https://root.cern,https://root.cern/doc/master/classRooAbsCollection.html,1,['clear'],['clear']
Usability,g Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  SearchHR1.C Example to illustrate high resolution peak searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVAC,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:155139,simpl,simple,155139,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,g Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  SearchHR1.C Example to illustrate high resolution peak searching function (class TSpectrum) ;  SearchHR3.C Example to illustrate the influence of number of iterations in deconvolution in high resolution peak searching function (class TSpectrum) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example ex,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/files.html:154345,simpl,simple,154345,doc/v610/files.html,https://root.cern,https://root.cern/doc/v610/files.html,1,['simpl'],['simple']
Usability,"g Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Run the tests. Running the ROOT battery of tests; Running all ROOT tests on at least a platform before sending a PR or before pushing anything to the ROOT repository is mandatory.; The ROOT continuous integration infrastructure allows to automatically check the PR also on a battery of platform, for example including macos and linux boxes.; In order to be able to run all tests, the simple steps below need to be followed; Prepare your development area and build ROOT; mkdir RootDevelopment; cd RootDevelopment; git clone https://github.com/root-project/root; git clone https://github.com/root-project/roottest; mkdir build; cd build; echo Note the cmake options; cmake -DCMAKE_BUILD_TYPE=Debug -Dtesting=ON -Droottest=ON ../root. Inspect and run the tests; From within the build directory. List all tests: ctest -N; List all test matching a regex: ctest -N -R myregex; Run all tests on N cores: ctest -j N. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/run-tests.html:3007,guid,guidelines,3007,d/run-tests.html,https://root.cern,https://root.cern/d/run-tests.html,1,['guid'],['guidelines']
Usability,"g in; the list, or just added.; The boolean merged is set to kFALSE when the object is just added to 'outlist';; this happens if the Merge() method does not exist or if a object named as 'obj'; is not already in the list. If the obj is not 'merged' than it should not be; deleted, unless outlist is not owner of its objects.; Return 0 on success, -1 on error. TObject * HandleHistogram(TObject* obj); Low statistic histograms need a special treatment when using autobin. Bool_t HistoSameAxis(TH1* h0, TH1* h1); Return kTRUE is the histograms 'h0' and 'h1' have the same binning and ranges; on the axis (i.e. if they can be just Add-ed for merging). void StoreOutput(TList* out); Store received output list. TList * MergeFeedback(); Merge feedback lists. void StoreFeedback(TObject* slave, TList* out); Store feedback results from the specified slave. void SetupFeedback(); Setup reporting of feedback objects. void StopFeedback(); Stop reporting of feedback objects. Bool_t HandleTimer(TTimer* timer); Send feedback objects to client. TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet for specified slave. Bool_t IsClient() const; Is the player running on the client?. Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (support for TChain::Draw()).; Returns -1 in case of error or number of selected events in case of success. void SetInitTime(); Set init time. TVirtualPacketizer * GetPacketizer() const; { return 0; }. void Progress(Long64_t total, Long64_t processed). void Progress(TSlave* , Long64_t total, Long64_t processed); { Progress(total, processed); }. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti). TProof * GetProof() const; { return fProof; }. TProofPlayerRemote(TProof* proof = 0); { fProgressStatus = new TProofProgressStatus(); }. » Author: Maarten Ballintijn 07/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerRemote.html:19447,feedback,feedback,19447,root/html530/TProofPlayerRemote.html,https://root.cern,https://root.cern/root/html530/TProofPlayerRemote.html,1,['feedback'],['feedback']
Usability,"g multiple values of a RooAbsReal. ;  ; const std::vector< double > & high () const;  ; const std::vector< int > & interpolationCodes () const;  ; TClass * IsA () const override;  ; const std::vector< double > & low () const;  ; double nominal () const;  ; void printAllInterpCodes ();  ; virtual void printFlexibleInterpVars (std::ostream &os) const;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Interface for detailed printing of object. ;  ; void setAllInterpCodes (int code);  ; void setGlobalBoundary (double boundary);  ; void setHigh (RooAbsReal &param, double newHigh);  ; void setInterpCode (RooAbsReal &param, int code);  ; void setLow (RooAbsReal &param, double newLow);  ; void setNominal (double newNominal);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ; const RooListProxy & variables () const;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegral (Int_t code, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html:2384,simpl,simple,2384,doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HistFactory_1_1FlexibleInterpVar.html,1,['simpl'],['simple']
Usability,"g none. Their proper usage is for setting attributes, properties or values; also for data or choices that are discrete, small and fixed in number, not easily remembered. With check boxes all alternatives are visible: it is easy to access and compare choices because they can all be seen together. Each option acts as a switch and can be either “on” or “off”. It is never changed in contents. Checkboxes differ from radio buttons in that they permit selection of more than one alternative. Each box can be switched on or off independently. These buttons can be used alone or grouped in sets. It is good practice to provide default settings for check boxes whenever it is possible. This can be done by:; SetState(EButtonState state); The parameter state can be one of kButtonUp, kButtonDown, kButtonEngaged, kButtonDisabled.; Check boxes can be used to affect other controls. The contents of a list can, for example, be filtered by setting a check box. In any case, use a check box only when both states of a choice are clearly opposite and unambiguous. If opposite states are not clear, it is better to use two radio buttons.; Choice description, i.e. check box label, must be clear, meaningful, fully spelled out, and displayed in mixed-type text. Whenever the use of a given button is inappropriate, for whatever reason, that button should be disabled:; button->SetState(kButtonDisabled);; Never make a button appear and disappear.; In general, option buttons should not offer more than eight choices. If the number of choices exceeds this maximum, it is better to use a multiple selection list box.; The method IsToggleButton() gives the information whether a radio button or a check button is selected. An option button can be set or unset via its method PSetState(EButtonState state).; The method HandleKey(event) is called when the defined hotkey is hit for any button. It sets the selected option button or clicks the selected text button and invokes its defined action.; 25.8.2 Text Entries; A ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1184393,clear,clearly,1184393,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clearly']
Usability,"g on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator controls the memory allocation/deallocation of Minuit ;  CStackAllocatorHolder;  CStackError;  CStackOverflowDefine stack allocator symbol ;  Csym;  CVariableMetricBuilderBuild (find) function minimum using the Variable Metric method (MIGRAD) ;  CVariableMetricEDMEstimator;  CVariableMetricMinimizerInstantiates the SeedGenerator and MinimumBuilder for Variable Metric Minimization method ;  Cvec;  CVectorOuterProduct;  ►NQu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:70320,simpl,simplex,70320,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,1,['simpl'],['simplex']
Usability,"g on the type of FCN function passesd and on the objects used for the parameters ;  CMPIProcess;  CMPITerminate;  CNegativeG2LineSearchIn case that one of the components of the second derivative g2 calculated by the numerical Gradient calculator is negative, a 1dim line search in the direction of that component is done in order to find a better position where g2 is again positive ;  CNumerical2PGradientCalculatorClass performing the numerical gradient calculation ;  CParametricFunctionFunction which has parameters ;  CScanBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CScanMinimizerClass implementing the required methods for a minimization using SCAN API is provided in the upper ROOT::Minuit2::ModularFunctionMinimizer class ;  CSimplexBuilderPerforms a minimization using the simplex method of Nelder and Mead (ref ;  CSimplexMinimizerClass implementing the required methods for a minimization using Simplex ;  CSimplexParametersClass describing the simplex set of points (f(x), x ) which evolve during the minimization iteration process ;  CSimplexSeedGeneratorGenerate Simplex starting point (state) ;  CSinParameterTransformationClass for the transformation for double-limited parameter Using a sin function one goes from a double-limited parameter range to an unlimited one ;  CSqrtLowParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CSqrtUpParameterTransformationTransformation from external to internal Parameter based on sqrt(1 + x**2) ;  CStackAllocatorStackAllocator controls the memory allocation/deallocation of Minuit ;  CStackAllocatorHolder;  CStackError;  CStackOverflowDefine stack allocator symbol ;  Csym;  CVariableMetricBuilderBuild (find) function minimum using the Variable Metric method (MIGRAD) Two possible error updators can be choosen ;  CVariableMetricEDMEstimator;  ►CVariableMetricMinimizerInstantiates the SeedGenerator and MinimumBuilder for Variable Metric Minimization",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/annotated.html:71570,simpl,simplex,71570,doc/v614/annotated.html,https://root.cern,https://root.cern/doc/v614/annotated.html,3,['simpl'],['simplex']
Usability,"g routines.; 14 ; 15This file defines a number of global error handling routines:; 16Warning(), Error(), SysError() and Fatal(). They all take a; 17location string (where the error happened) and a printf style format; 18string plus vararg's. In the end these functions call an; 19errorhandler function. Initially the MinimalErrorHandler, which is supposed; 20to be replaced by the proper DefaultErrorHandler(); 21*/; 22 ; 23#include ""TError.h""; 24 ; 25#include <cstdarg>; 26#include <cstdio>; 27#include <cstdlib>; 28#include <cerrno>; 29#include <string>; 30 ; 31Int_t gErrorIgnoreLevel = kUnset;; 32Int_t gErrorAbortLevel = kSysError+1;; 33Bool_t gPrintViaErrorHandler = kFALSE;; 34 ; 35const char *kAssertMsg = ""%s violated at line %d of `%s'"";; 36const char *kCheckMsg = ""%s not true at line %d of `%s'"";; 37 ; 38static ErrorHandlerFunc_t gErrorHandler = ROOT::Internal::MinimalErrorHandler;; 39 ; 40 ; 41static ROOT::Internal::ErrorSystemMsgHandlerFunc_t &GetErrorSystemMsgHandlerRef(); 42{; 43 static ROOT::Internal::ErrorSystemMsgHandlerFunc_t h;; 44 return h;; 45}; 46 ; 47 ; 48namespace ROOT {; 49namespace Internal {; 50 ; 51ErrorSystemMsgHandlerFunc_t GetErrorSystemMsgHandler(); 52{; 53 return GetErrorSystemMsgHandlerRef();; 54}; 55 ; 56ErrorSystemMsgHandlerFunc_t SetErrorSystemMsgHandler(ErrorSystemMsgHandlerFunc_t h); 57{; 58 auto oldHandler = GetErrorSystemMsgHandlerRef();; 59 GetErrorSystemMsgHandlerRef() = h;; 60 return oldHandler;; 61}; 62 ; 63/// A very simple error handler that is usually replaced by the TROOT default error handler.; 64/// The minimal error handler is not serialized across threads, so that output of multi-threaded programs; 65/// can get scrambled; 66/// @note `abort()` is only called if `abort_bool` is `true` and `level >= gErrorIgnoreLevel`; 67void MinimalErrorHandler(Int_t level, Bool_t abort_bool, const char *location, const char *msg); 68{; 69 if (level < gErrorIgnoreLevel); 70 return;; 71 ; 72 if (level >= kBreak); 73 fprintf(stderr, ""\n *** ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:2126,simpl,simple,2126,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['simpl'],['simple']
Usability,"g terms see $ROOTSYS/LICENSE. *; 9 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 10 *************************************************************************/; 11 ; 12/** \class TTreeViewer; 13A graphic user interface designed to handle ROOT trees and to take advantage of; 14TTree class features.; 15 ; 16It uses ROOT native GUI widgets adapted for ""drag and drop"" functionality.; 17in the same session.; 18 ; 19### The following capabilities are making the viewer a helpful tool for analysis:; 20 ; 21 - several trees may be opened in the same session;; 22 - branches and leaves can be easily browsed or scanned;; 23 - fast drawing of branch expressions by double-clicking;; 24 - new variables/selections easy to compose with the built-in editor;; 25 - histograms can be composed by dragging leaves or user-defined expressions; 26 to X, Y and Z axis items;; 27 - the tree entries to be processed can be selected with a double slider;; 28 - selections can be defined and activated by dragging them to the 'Cut' item;; 29 - all expressions can be aliased and aliases can be used in composing others;; 30 - input/output event lists easy to handle;; 31 - menu with histogram drawing options;; 32 - user commands may be executed within the viewer and the current command; 33 can be echoed;; 34 - current 'Draw' event loop is reflected by a progress bar and may be; 35 interrupted by the user;; 36 - all widgets have self-explaining tool tips and/or context menus;; 37 - expressions/leaves can be dragged to a 'scan box' and scanned by; 38 double-clicking this item. The result can be redirected to an ASCII file;; 39 ; 40### The layout has the following items:; 41 ; 42 - a menu bar with entries : File, Edit, Run, Options and Help;; 43 - a toolbar in the upper part where you can issue user commands, change; 44 the drawing option and the histogram name, three check buttons Hist, Rec; 45 and Scan.HIST toggles histogram drawing mode, REC enables recording of the; 46 last command issu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:1855,progress bar,progress bar,1855,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['progress bar'],['progress bar']
Usability,"g this class . ◆ Class_Name(). static const char * RooChangeTracker::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooChangeTracker::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 49 of file RooChangeTracker.h. ◆ clone(). TObject * RooChangeTracker::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 30 of file RooChangeTracker.h. ◆ DeclFileName(). static const char * RooChangeTracker::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 49 of file RooChangeTracker.h. ◆ evaluate(). double RooChangeTracker::evaluate ; (; ); const. inlineoverrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 47 of file RooChangeTracker.h. ◆ hasChanged(). bool RooChangeTracker::hasChanged ; (; bool ; clearState). Returns true if state has changed since last call with clearState=true. ; If clearState is true, changeState flag will be cleared. ; Definition at line 104 of file RooChangeTracker.cxx. ◆ IsA(). TClass * RooChangeTracker::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 49 of file RooChangeTracker.h. ◆ parameters(). RooArgSet RooChangeTracker::parameters ; (; ); const. Definition at line 188 of file RooChangeTracker.cxx. ◆ Streamer(). void RooChangeTracker::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooChangeTracker::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 49 of file RooChangeTracker.h. Member Data Documentation. ◆ _catRef. std::vector<Int_t> RooChangeTracker::_catRef. protected . Reference values for categories. ; Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChangeTracker.html:62728,clear,clearState,62728,doc/master/classRooChangeTracker.html,https://root.cern,https://root.cern/doc/master/classRooChangeTracker.html,1,['clear'],['clearState']
Usability,"g weight file: datasetcv/weights/TMVACrossValidation_Fisher_fold2.weights.xml; : Booked classifier ""Fisher"" of type: ""CrossValidation""; : Rebuilding Dataset Default; (int) 0; ; #include <cstdlib>; #include <iostream>; #include <map>; #include <string>; ; #include ""TChain.h""; #include ""TFile.h""; #include ""TTree.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TSystem.h""; #include ""TROOT.h""; ; #include ""TMVA/Factory.h""; #include ""TMVA/DataLoader.h""; #include ""TMVA/Tools.h""; #include ""TMVA/TMVAGui.h""; ; // Helper function to load data into TTrees.; TTree *fillTree(TTree * tree, Int_t nPoints, Double_t offset, Double_t scale, UInt_t seed = 100); {; TRandom3 rng(seed);; Float_t x = 0;; Float_t y = 0;; Int_t eventID = 0;; ; tree->SetBranchAddress(""x"", &x);; tree->SetBranchAddress(""y"", &y);; tree->SetBranchAddress(""eventID"", &eventID);; ; for (Int_t n = 0; n < nPoints; ++n) {; x = rng.Gaus(offset, scale);; y = rng.Gaus(offset, scale);; ; // For our simple example it is enough that the id's are uniformly; // distributed and independent of the data.; ++eventID;; ; tree->Fill();; }; ; // Important: Disconnects the tree from the memory locations of x and y.; tree->ResetBranchAddresses();; return tree;; }; ; int TMVACrossValidationApplication(); {; // This loads the library; TMVA::Tools::Instance();; ; // Set up the TMVA::Reader; TMVA::Reader *reader = new TMVA::Reader(""!Color:!Silent:!V"");; ; Float_t x;; Float_t y;; Int_t eventID;; ; reader->AddVariable(""x"", &x);; reader->AddVariable(""y"", &y);; reader->AddSpectator(""eventID"", &eventID);; ; // Book the serialised methods; TString jobname(""TMVACrossValidation"");; {; TString methodName = ""BDTG"";; TString weightfile = TString(""datasetcv/weights/"") + jobname + ""_"" + methodName + TString("".weights.xml"");; ; Bool_t weightfileExists = (gSystem->AccessPathName(weightfile) == kFALSE);; if (weightfileExists) {; reader->BookMVA(methodName, weightfile);; } else {; std::cout << ""Weightfile for method "" << methodName << "" not foun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html:2735,simpl,simple,2735,doc/master/TMVACrossValidationApplication_8C.html,https://root.cern,https://root.cern/doc/master/TMVACrossValidationApplication_8C.html,1,['simpl'],['simple']
Usability,"g& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNumConvolution.html:5646,clear,clearValueAndShapeDirty,5646,root/html532/RooNumConvolution.html,https://root.cern,https://root.cern/root/html532/RooNumConvolution.html,1,['clear'],['clearValueAndShapeDirty']
Usability,"g& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:5805,clear,clearValueAndShapeDirty,5805,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,3,['clear'],['clearValueAndShapeDirty']
Usability,"g(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringchannel; pair<double,double>dummyForRoot; vector<TH1F*>highHistsx pb per jet bin for + variations over list of systematics; vector<TH1F*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1F*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<NormFactor>normFactor; stringnormName; map<std::string,std::pair<double,double> >overallSyst""acceptance""->(0.8,1.2); vector<std::string>systSourceForHist. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EstimateSummary(). ~EstimateSummary(); {}. void Print(const char* opt = 0) const. void AddSyst(const string& sname, TH1F* low, TH1F* high). bool operator==(const RooStats::HistFactory::EstimateSummary& other) const; Comparator for two Estimate summary objects. Useful to make sure two analyses are the same. bool CompareHisto(const TH1* one, const TH1* two) const. EstimateSummary(); simple structure to hold necessary information about each channel. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2010-12-08 11:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__EstimateSummary.html:6334,simpl,simple,6334,root/html528/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__EstimateSummary.html,1,['simpl'],['simple']
Usability,"g(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. stringchannel; pair<double,double>dummyForRoot; vector<TH1F*>highHistsx pb per jet bin for + variations over list of systematics; vector<TH1F*>lowHistsx pb per jet bin for - variations over list of systematics; stringname; TH1F*nominalx pb per jet bin. all histograms need index of binning to be consistent; vector<NormFactor>normFactor; stringnormName; map<std::string,std::pair<double,double> >overallSyst""acceptance""->(0.8,1.2); vector<std::string>systSourceForHist. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; EstimateSummary(). ~EstimateSummary(); {}. void Print(const char* opt = 0) const. void AddSyst(const string& sname, TH1F* low, TH1F* high). bool operator==(const RooStats::HistFactory::EstimateSummary& other) const; Comparator for two Estimate summary objects. Useful to make sure two analyses are the same. bool CompareHisto(const TH1* one, const TH1* two) const. EstimateSummary(); simple structure to hold necessary information about each channel. » Author: Kyle Cranmer, Akira Shibata » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: cranmer $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__EstimateSummary.html:6403,simpl,simple,6403,root/html530/RooStats__HistFactory__EstimateSummary.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__EstimateSummary.html,1,['simpl'],['simple']
Usability,"g, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, const char* weight, TTree* data, TEventList* training, TEventList* test, TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a simple string:; The input/output layers are defined by giving; the branch names separated by comas.; Hidden layers are just described by the number of neurons.; The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be; normalized.; The output can be followed by '!' to use Softmax neurons for the; output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument.; training and test are the two TEventLists defining events; to be used during the neural net training.; Both the TTree and the TEventLists can be defined in the constructor,; or later with the suited setter method. TMultiLayerPerceptron(const char* layout, TTree* data = 0, const char* training = ""Entry$%2==0"", const char* test = """", TNeuron::ENeuronType type = TNeuron::kSigmoid, const char* extF = """", const char* extD = """"); The network is described by a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:19947,simpl,simple,19947,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['simpl'],['simple']
Usability,"g->SetTitle(""Simple Graph"");; 554 ; 555 g->SetPoint(0,-4,-3);; 556 g->SetPoint(1,1,1);; 557 g->SetPoint(2,2,1);; 558 g->SetPoint(3,3,4);; 559 g->SetPoint(4,5,5);; 560 ; 561 g->SetPointError(0,1.,2.);; 562 g->SetPointError(1,2,1);; 563 g->SetPointError(2,2,3);; 564 g->SetPointError(3,3,2);; 565 g->SetPointError(4,4,5);; 566 ; 567 g->GetXaxis()->SetNdivisions(520);; 568 ; 569 g->SetMarkerStyle(21);; 570 c->cd(1); gPad->SetGrid(1,1);; 571 g->Draw(""APL"");; 572 ; 573 c->cd(2); gPad->SetGrid(1,1);; 574 g->Draw(""A RX RY PL"");; 575}; 576End_Macro; 577 ; 578\anchor GrP7; 579### Graphs in logarithmic scale; 580 ; 581Like histograms, graphs can be drawn in logarithmic scale along X and Y. When; 582a pad is set to logarithmic scale with TPad::SetLogx() and/or with TPad::SetLogy(); 583the points building the graph are converted into logarithmic scale. But **only** the; 584points not the lines connecting them which stay linear. This can be clearly seen; 585on the following example:; 586 ; 587Begin_Macro(source); 588{; 589 // A graph with 3 points; 590 Double_t xmin = 750.;; 591 Double_t xmax = 1000;; 592 auto g = new TGraph(3);; 593 g->SetPoint(0,xmin,0.1);; 594 g->SetPoint(1,845,0.06504);; 595 g->SetPoint(2,xmax,0.008);; 596 ; 597 // The same graph with n points; 598 Int_t n = 10000;; 599 Double_t dx = (xmax-xmin)/n;; 600 Double_t x = xmin;; 601 auto g2 = new TGraph();; 602 for (Int_t i=0; i<n; i++) {; 603 g2->SetPoint(i, x, g->Eval(x));; 604 x = x + dx;; 605 }; 606 ; 607 auto cv = new TCanvas(""cv"",""cv"",800,600);; 608 cv->SetLogy();; 609 cv->SetGridx();; 610 cv->SetGridy();; 611 g->Draw(""AL*"");; 612 ; 613 g2->SetMarkerColor(kRed);; 614 g2->SetMarkerStyle(1);; 615 g2->Draw(""P"");; 616}; 617 ; 618End_Macro; 619 ; 620\anchor GrP8; 621#### Highlight mode for graph; 622 ; 623\since **ROOT version 6.15/01**; 624 ; 625\image html hlGraph1.gif ""Highlight mode""; 626 ; 627Highlight mode is implemented for `TGraph` (and for `TH1`) class. When; 628highlight mode is on, mouse movement over the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:22843,clear,clearly,22843,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clearly']
Usability,"g. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool canBeAdded (const RooAbsArg &arg, bool silent) const override;  Determine whether it's possible to add a given RooAbsArg to the collection or not. ;  ; bool checkForDup (const RooAbsArg &arg, bool silent) const;  Check if element with var's name is already in set. ;  ;  Protected Member Functions inherited from RooAbsCollection; void clearStructureTags ();  ; void deleteList ();  Delete contents of the list. ;  ; void makeStructureTag ();  ; void makeTypedStructureTag ();  ; TNamed * structureTag ();  ; TNamed * typedStructureTag ();  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; template<class Arg_t > ; void processArg (Arg_t &&arg);  ; void processArg (const char *name);  ; void processArg (const RooAbsArg &arg);  ; void processArg (const RooAbsArg *arg);  ; void processArg (const RooAbsCollection &coll);  ; void processArg (const RooArgList &list);  ; void processArg (double value);  ; void processArg (RooAbsArg *var);  ; void processArg (RooAbsCollection &&coll);  ; template<typename... Args_t> ; void processArgs (Args_t &&... args);  . Additional Inherited Members;  Public Types inherited from RooAbsCollection; using const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooArgSet.html:27370,clear,clearStructureTags,27370,doc/master/classRooArgSet.html,https://root.cern,https://root.cern/doc/master/classRooArgSet.html,1,['clear'],['clearStructureTags']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:3099,clear,clearEvalError,3099,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:2588,clear,clearEvalError,2588,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,1,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:2890,clear,clearEvalError,2890,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,4,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:2788,clear,clearEvalError,2788,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,1,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgusBG.html:2612,clear,clearEvalError,2612,root/html532/RooArgusBG.html,https://root.cern,https://root.cern/root/html532/RooArgusBG.html,49,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::crea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:4084,clear,clearEvalError,4084,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:3184,clear,clearEvalError,3184,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:3184,clear,clearEvalError,3184,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:2588,clear,clearEvalError,2588,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:2890,clear,clearEvalError,2890,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,8,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBDecay.html:2788,clear,clearEvalError,2788,root/html528/RooBDecay.html,https://root.cern,https://root.cern/root/html528/RooBDecay.html,2,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgusBG.html:2612,clear,clearEvalError,2612,root/html528/RooArgusBG.html,https://root.cern,https://root.cern/root/html528/RooArgusBG.html,46,['clear'],['clearEvalError']
Usability,"g::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:3137,clear,clearEvalError,3137,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,60,['clear'],['clearEvalError']
Usability,"g; 957should be preferred for performance-critical applications.; 958 ; 959Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame.; 960See [Efficient analysis in Python](#python) for possible ways to speed up hot paths in this case.; 961 ; 962Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations *for all RDataFrame computation graphs*; 963before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; 964 ; 965Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See [Activating RDataFrame execution logs](\ref rdf-logging).; 966 ; 967### Memory usage; 968 ; 969There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; 970 ; 971Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:56069,simpl,simplifies,56069,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simplifies']
Usability,"g; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; he is going to use.; For the moment it's just a call to FillBuffer() since that method; will creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:25233,learn,learning,25233,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['learn'],['learning']
Usability,"g>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFFTConvPdf.html:7247,clear,clearEvalError,7247,root/html532/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html532/RooFFTConvPdf.html,1,['clear'],['clearEvalError']
Usability,"g>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooFFTConvPdf.html:7247,clear,clearEvalError,7247,root/html528/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html528/RooFFTConvPdf.html,1,['clear'],['clearEvalError']
Usability,"g>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFFTConvPdf.html:7247,clear,clearEvalError,7247,root/html530/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html530/RooFFTConvPdf.html,1,['clear'],['clearEvalError']
Usability,"gDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGVProgressBar.html:20421,progress bar,progress bar,20421,root/html528/TGVProgressBar.html,https://root.cern,https://root.cern/root/html528/TGVProgressBar.html,3,['progress bar'],['progress bar']
Usability,"gDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGVProgressBar.html:20521,progress bar,progress bar,20521,root/html530/TGVProgressBar.html,https://root.cern,https://root.cern/root/html530/TGVProgressBar.html,3,['progress bar'],['progress bar']
Usability,"gDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGProgressBar.h 23115 2008-04-10 13:35:37Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGVProgressBar.html:20521,progress bar,progress bar,20521,root/html532/TGVProgressBar.html,https://root.cern,https://root.cern/root/html532/TGVProgressBar.html,3,['progress bar'],['progress bar']
Usability,"gLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-02 15:50; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGHProgressBar.html:22168,progress bar,progress bar,22168,root/html604/TGHProgressBar.html,https://root.cern,https://root.cern/root/html604/TGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"gLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame); Horizontal progress bar constructor. TGHProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t w); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void ShowPosition(Bool_t set = kTRUE, Bool_t percent = kTRUE, const char* format = ""%.2f""); Show postion text, either in percent or formatted according format. void DoRedraw(); Draw horizontal progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a horizontal progress bar as a C++ statement(s) on output stream out. TGHProgressBar(const TGWindow* p = 0, UInt_t w = 4, UInt_t h = kProgressBarTextWidth, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder | kSunkenFrame). virtual ~TGHProgressBar(); { }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-06-30 14:51; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGHProgressBar.html:22168,progress bar,progress bar,22168,root/html602/TGHProgressBar.html,https://root.cern,https://root.cern/root/html602/TGHProgressBar.html,2,['progress bar'],['progress bar']
Usability,"gLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance Chart:. TObject. ←; TFileCacheRead. ←; TTreeCache. ←. TTreeCacheUnzip. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:22668,learn,learning,22668,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,1,['learn'],['learning']
Usability,"gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1012 if (!y.empty()) theY[i] = gPad->PadtoY(gPad->AbsPixeltoY(y[i]+dpy));; 1013 }; 1014 } else {; 1015 pxold = px;; 1016 pxold = TMath::Max(pxold, px1);; 1017 pxold = TMath::Min(pxold, px2);; 1018 pyold = py;; 1019 pyold = TMath::Max(pyold, py2);; 1020 pyold = TMath::Min(pyold, py1);; 1021 theX[ipoint] = gPad->PadtoX(gPad->AbsPixeltoX(pxold));; 1022 theY[ipoint] = gPad->PadtoY(gPad->AbsPixeltoY(pyold));; 1023 if (theGraph->InheritsFrom(""TCutG"")) {; 1024 //make sure first and last point are the same; 1025 if (ipoint == 0) {; 1026 theX[theNpoints-1] = theX[0];; 1027 theY[theNpoints-1] = theY[0];; 1028 }; 1029 if (ipoint == theNpoints-1) {; 1030 theX[0] = theX[theNpoints-1];; 1031 theY[0] = theY[theNpoints-1];; 1032 }; 1033 }; 1034 }; 1035 badcase = kFALSE;; 1036 gPad->Modified(kTRUE);; 1037 //gPad->Update();; 1038 }; 1039 break;; 1040 ; 1041 case kButton1Up:; 1042 ; 1043 if (gROOT->IsEscaped()) {; 1044 gROOT->SetEscape(kFALSE);; 1045 x.clear();; 1046 y.clear();; 1047 break;; 1048 }; 1049 ; 1050 // Compute x,y range; 1051 xmin = gPad->GetUxmin();; 1052 xmax = gPad->GetUxmax();; 1053 ymin = gPad->GetUymin();; 1054 ymax = gPad->GetUymax();; 1055 dx = xmax-xmin;; 1056 dy = ymax-ymin;; 1057 dxr = dx/(1 - gPad->GetLeftMargin() - gPad->GetRightMargin());; 1058 dyr = dy/(1 - gPad->GetBottomMargin() - gPad->GetTopMargin());; 1059 ; 1060 if (theGraph->GetHistogram()) {; 1061 // Range() could change the size of the pad pixmap and therefore should; 1062 // be called before the other paint routines; 1063 gPad->Range(xmin - dxr*gPad->GetLeftMargin(),; 1064 ymin - dyr*gPad->GetBottomMargin(),; 1065 xmax + dxr*gPad->GetRightMargin(),; 1066 ymax + dyr*gPad->GetTopMargin());; 1067 gPad->RangeAxis(xmin, ymin, xmax, ymax);; 1068 }; 1069 if (middle) {; 1070 for(i=0;i<theNpoints;i++) {; 1071 if (badcase) continue; //do not update if big zoom and points moved; 1072 if (!x.empty()) theX[i] = gPad->PadtoX(gPad->AbsPixeltoX(x[i]+dpx));; 1073 if (!y.em",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:38508,clear,clear,38508,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"gPath;; 174 path.insert(path.end(), request.path.begin(), request.path.end());; 175 ; 176 if ((path != fLastPath) || !fLastElement) {; 177 ; 178 auto elem = GetSubElement(path);; 179 if (!elem) return false;; 180 ; 181 ResetLastRequestData(true);; 182 ; 183 fLastPath = path;; 184 fLastElement = std::move(elem);; 185 ; 186 fLastElement->cd(); // set element active; 187 } else if (request.reload) {; 188 // only reload items from element, not need to reset element itself; 189 ResetLastRequestData(false);; 190 }; 191 ; 192 // when request childs, always try to make elements; 193 if (fLastItems.empty()) {; 194 ; 195 auto iter = fLastElement->GetChildsIter();; 196 ; 197 if (!iter) return false;; 198 int id = 0;; 199 fLastAllChilds = true;; 200 ; 201 while (iter->Next() && fLastAllChilds) {; 202 fLastItems.emplace_back(iter->CreateItem());; 203 if (id++ > 10000); 204 fLastAllChilds = false;; 205 }; 206 ; 207 fLastSortedItems.clear();; 208 fLastSortMethod.clear();; 209 }; 210 ; 211 // create sorted array; 212 if ((fLastSortedItems.size() != fLastItems.size()) ||; 213 (fLastSortMethod != request.sort) ||; 214 (fLastSortReverse != request.reverse)) {; 215 fLastSortedItems.resize(fLastItems.size(), nullptr);; 216 int id = 0;; 217 if (request.sort.empty()) {; 218 // no sorting, just move all folders up; 219 for (auto &item : fLastItems); 220 if (item->IsFolder()); 221 fLastSortedItems[id++] = item.get();; 222 for (auto &item : fLastItems); 223 if (!item->IsFolder()); 224 fLastSortedItems[id++] = item.get();; 225 } else {; 226 // copy items; 227 for (auto &item : fLastItems); 228 fLastSortedItems[id++] = item.get();; 229 ; 230 if (request.sort != ""unsorted""); 231 std::sort(fLastSortedItems.begin(), fLastSortedItems.end(),; 232 [request](const Browsable::RItem *a, const Browsable::RItem *b) { return a ? a->Compare(b, request.sort) : !b; });; 233 }; 234 ; 235 if (request.reverse); 236 std::reverse(fLastSortedItems.begin(), fLastSortedItems.end());; 237 ; 238 fLastSortMethod = reque",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:6576,clear,clear,6576,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['clear'],['clear']
Usability,"gSet &numVars, const char *rangeName=nullptr) const override;  Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ;  ; TClass * IsA () const override;  ; bool isBinnedDistribution (const RooArgSet &obs) const override;  Tests if the distribution is binned. Unless overridden by derived classes, this always returns false. ;  ; const RooArgList & list () const;  ; const RooArgList & list1 () const;  ; std::list< double > * plotSamplingHint (RooAbsRealLValue &, double, double) const override;  Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ;  ; void printMetaArgs (std::ostream &os) const override;  ; bool setData (RooAbsData &data, bool cloneData=true) override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void translate (RooFit::Detail::CodeSquashContext &ctx) const override;  This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ;  ;  Public Member Functions inherited from RooAbsReal;  RooAbsReal ();  coverity[UNINIT_CTOR] Default constructor ;  ;  RooAbsReal (const char *name, const char *title, const char *unit="""");  Constructor with unit label. ;  ;  RooAbsReal (const char *name, const char *title, double minVal, double maxVal, const char *unit="""");  Constructor with plot range and unit label. ;  ;  RooAbsReal (const RooAbsReal &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooAbsReal () override;  Destructor. ;  ; virtual double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const;  Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ;  ; TF1 * asTF (const RooArgList &obs, const RooArgList &pars=RooArgList(), const RooArgSet &nset=RooArgSet()) const;  Return a ROOT TF1,2,3 object bound ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddition.html:2902,simpl,simple,2902,doc/master/classRooAddition.html,https://root.cern,https://root.cern/doc/master/classRooAddition.html,1,['simpl'],['simple']
Usability,"gSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:4679,clear,clearEvalError,4679,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['clear'],['clearEvalError']
Usability,"gTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchRef(); Default constructor. TBranchRef(TTree* tree); Main constructor called by TTree::BranchRef. ~TBranchRef(); Typical destructor. void Clear(Option_t* option = """"); Clear entries in the TRefTable. Int_t Fill(); Fill the branch basket with the referenced objects parent numbers. void FillLeaves(TBuffer& b); This function called by TBranch::Fill overloads TBranch::FillLeaves. Bool_t Notify(); This function is called by TRefTable::Notify, itself called by; TRef::GetObject.; The function reads the branch containing the object referenced; by the TRef. void Print(Option_t* option = """") const; Print the TRefTable branch. void ReadLeavesImpl(TBuffer& b); This function called by TBranch::GetEntry overloads TBranch::ReadLeaves. void Reset(Option_t* option = """"); Existing buffers are deleted; Entries, max and min are reset; TRefTable is cleared. Int_t SetParent(const TObject* obj, Int_t branchID); -- Set the current parent branch. This function is called by TBranchElement::GetEntry(); and TBranchElement::Fill() when reading or writing; branches that may contain referenced objects. TRefTable * GetRefTable() const; {return fRefTable;}. void SetReadEntry(Long64_t entry); {fReadEntry = entry;}. » Author: Rene Brun 19/08/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TBranchRef.h 37275 2010-12-04 21:32:11Z pcanal $ » Last generated: 2010-12-04 22:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TBranchRef.html:13918,clear,cleared,13918,root/html528/TBranchRef.html,https://root.cern,https://root.cern/root/html528/TBranchRef.html,1,['clear'],['cleared']
Usability,"gWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetRange(Float_t min, Float_t max); Set min and max of progress bar. void SetPosition(Float_t pos); Set progress position between [min,max]. void Increment(Float_t inc); Increment progress position. void Reset(); Reset progress bar (i.e. set pos to 0). void SetFillType(TGProgressBar::EFillType type); Set fill type. void SetBarType(TGProgressBar::EBarType type); Set bar type. void SetBarColor(ULong_t color); Set progress bar color. void SetBarColor(const char* color = ""blue""); Set progress bar color. void Format(const char* format = ""%.2f""); Set format for displaying a value. FontStruct_t GetDefaultFontStruct(); Return default font structure in use. const TGGC & GetDefaultGC(); Return default graphics context in use. void SetForegroundColor(Pixel_t pixel); Change text color drawing. void SavePrimitive(ostream& out, Option_t* option = """"); Save progress bar parameters as a C++ statement(s) on output stream out. Bool_t fDrawBar; // if true draw only bar in DoRedraw(). virtual ~TGProgressBar(); { }. Float_t GetMin() const; { return fMin; }. Float_t GetMax() const; { return fMax; }. Float_t GetPosition() const; { return fPos; }. EFillType GetFillType() const; { return fFillType; }. EBarType GetBarType() const; { return fBarType; }. Bool_t GetShowPos() const; { return fShowPos; }. TString GetFormat() const; { return fFormat; }. const char* GetValueFormat() const; { return fFormat.Data(); }. Bool_t UsePercent() const; { return fPercent; }. Pixel_t GetBarColor() const; { return fBarColorGC.GetForeground(); }. GContext_t GetNormGC() const; { return fNormGC; }. FontStruct_t GetFontStruct() const; { return fFontStruct; }. void Percent(Bool_t on); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t on); { fShowPos = on; fClient->NeedRedraw(this); }. void SetMin(Float_t min); { fMin = min; }. void SetMax(Float_t max); { fMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGProgressBar.html:19918,progress bar,progress bar,19918,root/html528/TGProgressBar.html,https://root.cern,https://root.cern/root/html528/TGProgressBar.html,4,['progress bar'],['progress bar']
Usability,"ge of (see TBuffer3D.h and TBuffer3DTypes.h). TBuffer3DSphere - solid, hollow and cut spheres*; TBuffer3DTubeSeg - angle tube segment; TBuffer3DCutTube - angle tube segment with plane cut ends. *OpenGL only supports solid spheres at present - cut/hollow ones will be; requested tessellated.; Anyone is free to add new TBuffer3D classes, but it should be clear that the; viewers require updating to be able to take advantage of them. The number of; native shapes in OpenGL will be expanded over time.; BoundingBox: You are not obliged to complete this, as any viewer; requiring one internally (OpenGL) will build one for you if you do not provide.; However; to do this the viewer will force you to provide the raw tessellation, and the; resulting box will be axis aligned with the overall scene, which is non-ideal; for rotated shapes.; As we need to support orientated (rotated) bounding boxes, TBuffer3D requires; the 6 vertices of the box. We also provide a convenience function, SetAABoundingBox(),; for simpler case of setting an axis aligned bounding box. Master/Local Reference Frames; The Core section of TBuffer3D contains two members relating to reference; frames:; fLocalFrame & fLocalMaster. fLocalFrame indicates; if any positions in the buffer (bounding box and tessellation vertexes) are; in local or master (world; frame). fLocalMaster is a standard 4x4 translation matrix (OpenGL; colum major ordering) for placing the object into the 3D master frame.; If fLocalFrame is kFALSE, fLocalMaster should contain an; identity matrix. This is set by default, and can be reset using SetLocalMasterIdentity() function.; Logical & Physical Objects; There are two cases of object addition:. Add this object as a single independent entity in the world reference; frame.; Add; a physical placement (copy) of this logical object (described in local; reference frame). The second case is very typical in geometry packages, GEANT4, where we have; very large number repeated placements of relatively fe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBuffer3D.html:4075,simpl,simpler,4075,root/html526/TBuffer3D.html,https://root.cern,https://root.cern/root/html526/TBuffer3D.html,13,['simpl'],['simpler']
Usability,"ge of the histogram is used. ; Use option ""R"" for restricting the chisquare calculation to the given range of the function Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare) Use option ""P"" for using the Pearson chisquare based on the expected bin errors ; Definition at line 2496 of file TH1.cxx. ◆ Class(). static TClass * TH1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TH1::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TH1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 444 of file TH1.h. ◆ ClearUnderflowAndOverflow(). void TH1::ClearUnderflowAndOverflow ; (; ). virtual . Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow and overflow bins will have content 0.0 The Sumw2 is also cleared, since there is no more content in the bins. ; Definition at line 2517 of file TH1.cxx. ◆ Clone(). TObject * TH1::Clone ; (; const char * ; newname = """"); const. overridevirtual . Make a complete copy of the underlying object. ; If 'newname' is set, the copy's name will be set to that name. ; Reimplemented from TObject.; Reimplemented in TH2Poly.; Definition at line 2752 of file TH1.cxx. ◆ ComputeIntegral(). Double_t TH1::ComputeIntegral ; (; Bool_t ; onlyPositive = false). virtual . Compute integral (normalized cumulative sum of bins) w/o under/overflows The result is stored in fIntegral and used by the GetRandom functions. ; This function is automatically called by GetRandom when the fIntegral array does not exist or when the number of entries in the histogram has changed since the previous call to GetRandom. The resulting integral is normalized to 1. If the routine is called with the onlyPositive flag set an error will be produced in case of negative bin content and a NaN value returned Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:102039,clear,cleared,102039,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['clear'],['cleared']
Usability,"ge the size of the cache with the TTree::SetCacheSize method (by default the size is 30 Megabytes). This feature can be controlled with the environment variable ROOT_TTREECACHE_SIZE or the TTreeCache.Size option. The entry range for which the cache is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a tri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:3961,learn,learning,3961,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"ge() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 141 of file RooCategory.h. ◆ clear(). void RooCategory::clear ; (; ). inline . Clear all defined category states. ; Definition at line 69 of file RooCategory.h. ◆ clearRange(). void RooCategory::clearRange ; (; const char * ; name, . bool ; silent . ). Clear the named range. ; NoteThis affects all copies of this category, because they are sharing range definitions. This ensures that categories inside a dataset and their counterparts on the outside will both see a modification of the range. ; Definition at line 321 of file RooCategory.cxx. ◆ clone(). TObject * RooCategory::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooCategory.h. ◆ DeclFileName(). static const char * RooCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 141 of file RooCategory.h. ◆ defineType() [1/2]. bool RooCategory::defineType ; (; const std::string & ; label). Define a state with given name. ; The lowest available positive integer is assigned as index. Category state labels may not contain semicolons. ReturnsTrue in case of an error. ; Definition at line 209 of file Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:55191,clear,clearRange,55191,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clearRange']
Usability,"ge(Long64_t first, Long64_t last); 8833{; 8834 if (!GetTree()) {; 8835 if (LoadTree(0)<0) {; 8836 Error(""SetCacheEntryRange"",""Could not load a tree"");; 8837 return -1;; 8838 }; 8839 }; 8840 if (GetTree()) {; 8841 if (GetTree() != this) {; 8842 return GetTree()->SetCacheEntryRange(first, last);; 8843 }; 8844 } else {; 8845 Error(""SetCacheEntryRange"", ""No tree is available. Could not set cache entry range"");; 8846 return -1;; 8847 }; 8848 ; 8849 TFile *f = GetCurrentFile();; 8850 if (!f) {; 8851 Error(""SetCacheEntryRange"", ""No file is available. Could not set cache entry range"");; 8852 return -1;; 8853 }; 8854 TTreeCache *tc = GetReadCache(f,true);; 8855 if (!tc) {; 8856 Error(""SetCacheEntryRange"", ""No cache is available. Could not set entry range"");; 8857 return -1;; 8858 }; 8859 tc->SetEntryRange(first,last);; 8860 return 0;; 8861}; 8862 ; 8863////////////////////////////////////////////////////////////////////////////////; 8864/// Interface to TTreeCache to set the number of entries for the learning phase; 8865 ; 8866void TTree::SetCacheLearnEntries(Int_t n); 8867{; 8868 TTreeCache::SetLearnEntries(n);; 8869}; 8870 ; 8871////////////////////////////////////////////////////////////////////////////////; 8872/// Enable/Disable circularity for this tree.; 8873///; 8874/// if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; 8875/// per branch in memory.; 8876/// Note that when this function is called (maxEntries>0) the Tree; 8877/// must be empty or having only one basket per branch.; 8878/// if maxEntries <= 0 the tree circularity is disabled.; 8879///; 8880/// #### NOTE 1:; 8881/// Circular Trees are interesting in online real time environments; 8882/// to store the results of the last maxEntries events.; 8883/// #### NOTE 2:; 8884/// Calling SetCircular with maxEntries <= 0 is necessary before; 8885/// merging circular Trees that have been saved on files.; 8886/// #### NOTE 3:; 8887/// SetCircular with maxEntries <= 0 is automatically called; 8888",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:343901,learn,learning,343901,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['learn'],['learning']
Usability,"ge; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. TGeoVolumeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolumeEditor.html:1020,simpl,simply,1020,root/html534/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html534/TGeoVolumeEditor.html,2,['simpl'],['simply']
Usability,"ge; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOMBUILDER; » TGeoVolumeEditor. class TGeoVolumeEditor: public TGeoGedFrame. TGeoVolumeEditor. Editor for geometry volumes and assemblies of volumes. Besides the volume; name and line attributes, a TGeoVolume has the following editable categories; split vertically by a shutter:; - Properties: one can edit the shape and medium components from here. It is; also possible to change the existing ones.; - Daughters: the main category allowing defining, editing, removing or; positioning daughter volumes inside the current edited volume. To add a; daughter, one needs to select first a volume and a matrix. Currently no check; is performed if the daughter volume creates an extrusion (illegal for tracking).; To remove or change the position of an existing daughter, one should simply; select the desired daughter from the combo box with the existing ones, then; simply click the appropriate button.; - Visualization: One can set the visibility of the volume and of its daughters,; set the visibility depth and the view type. Selecting ""All"" will draw the; volume and all visible daughters down to the selected level starting from the; edited volume. Selecting ""Leaves"" will draw just the deepest daughters within; the selected visibility level, without displaying the containers, while ""Only""; will just draw the edited volume.; - Division: The category becomes active only if there are no daughters of the; edited volume added by normal positioning (e.g. from <Daughters> category). The; minimum allowed starting value for the selected division axis is automatically; selected, while the dslicing step is set to 0 - meaning that only the number; of slices matter. Function Members (Methods); public:. virtual~TGeoVolumeEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolumeEditor.html:1020,simpl,simply,1020,root/html602/TGeoVolumeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoVolumeEditor.html,4,['simpl'],['simply']
Usability,"genreflex Use genreflex rather than rootcint to generate the dictionary. . par Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). . If, in addition to one of the 3 above options, the option ""+"" is specified, the function will generate:; a script called MAKEP to build the shared lib; a dirnameLinkDef.h file; rootcint will be run to generate a dirnameProjectDict.cxx file; dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; a shared lib dirname.so will be created. If the option ""++"" is specified, the generated shared lib is dynamically linked with the current executable module. If the option ""+"" and ""nocompile"" are specified, the utility files are generated as in the option ""+"" but they are not executed. Example: file.MakeProject(""demo"",""*"",""recreate++"");; creates a new directory demo unless it already exist; clear the previous directory content; generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.; creates the build script MAKEP; creates a LinkDef.h file; runs rootcint generating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented from TFile.; Definition at line 232 of file TSQLFile.h. ◆ MakeSelectQuery(). TString TSQLFile::MakeSelectQuery ; (; TClass * ; cl). Produce SELECT statement which can be used t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:77624,clear,clear,77624,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['clear'],['clear']
Usability,"genreflex Use genreflex rather than rootcint to generate the dictionary. . par Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). . If, in addition to one of the 3 above options, the option ""+"" is specified, the function will generate:; a script called MAKEP to build the shared lib; a dirnameLinkDef.h file; rootcint will be run to generate a dirnameProjectDict.cxx file; dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; a shared lib dirname.so will be created. If the option ""++"" is specified, the generated shared lib is dynamically linked with the current executable module. If the option ""+"" and ""nocompile"" are specified, the utility files are generated as in the option ""+"" but they are not executed. Example: file.MakeProject(""demo"",""*"",""recreate++"");; creates a new directory demo unless it already exist; clear the previous directory content; generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.; creates the build script MAKEP; creates a LinkDef.h file; runs rootcint generating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented from TFile.; Definition at line 78 of file TXMLFile.h. ◆ Map() [1/2]. void TXMLFile::Map ; (; ). inlinefinalvirtual . Reimplemented from TFile.; Definition at line 80 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLFile.html:60098,clear,clear,60098,doc/master/classTXMLFile.html,https://root.cern,https://root.cern/doc/master/classTXMLFile.html,1,['clear'],['clear']
Usability,"genreflex Use genreflex rather than rootcint to generate the dictionary. . par Create a PAR file with the minimal set of code needed to read the content of the ROOT file. The name of the PAR file is basename(dirname), with extension '.par' enforced; the PAR file will be created at dirname(dirname). . If, in addition to one of the 3 above options, the option ""+"" is specified, the function will generate:; a script called MAKEP to build the shared lib; a dirnameLinkDef.h file; rootcint will be run to generate a dirnameProjectDict.cxx file; dirnameProjectDict.cxx will be compiled with the current options in compiledata.h; a shared lib dirname.so will be created. If the option ""++"" is specified, the generated shared lib is dynamically linked with the current executable module. If the option ""+"" and ""nocompile"" are specified, the utility files are generated as in the option ""+"" but they are not executed. Example: file.MakeProject(""demo"",""*"",""recreate++"");; creates a new directory demo unless it already exist; clear the previous directory content; generate the xxx.h files for all classes xxx found in this file and not yet known to the CINT dictionary.; creates the build script MAKEP; creates a LinkDef.h file; runs rootcint generating demoProjectDict.cxx; compiles demoProjectDict.cxx into demoProjectDict.o; generates a shared lib demo.so; dynamically links the shared lib demo.so to the executable If only the option ""+"" had been specified, one can still link the shared lib to the current executable module with: gSystem->load(""demo/demo.so"");; The following feature is not yet enabled: One can restrict the list of classes to be generated by using expressions like: classes = ""Ali*"" generate code only for classes starting with Ali; classes = ""myClass"" generate code for class MyClass only.; . Reimplemented in TSQLFile, and TXMLFile.; Definition at line 2726 of file TFile.cxx. ◆ MakeProjectParMake(). Int_t TFile::MakeProjectParMake ; (; const char * ; pack, . const char * ; filema",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:76979,clear,clear,76979,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['clear'],['clear']
Usability,"geometry of ALICE TPC ;  geom_atlas.CShows ATLAS geometry ;  geom_atlas_playback.CPlays back event-recording of a root session running geom_atlas.C tutorial ;  geom_cms.CShows CMS geometry ;  geom_cms_playback.CPlays back event-recording of a root session running geom_cms.C tutorial ;  geom_cms_stereo.CShows CMS geometry in stereo mode ;  geom_default.CDemonstrates usage of ""Default"" geometry alias ;  geom_lhcb.CShows LHCB geometry ;  glplot.CPreliminary demo for showing Timur's GL plots in EVE ;  glplot_geom.CDemonstrates how to combine Timur's GL plots with other scene elements ;  hierarchical_scene.C;  histobrowser.CDemonstates how to use EVE as a histogram browser ;  jetcone.CDemonstrates usage of TEveJetCone class ;  lineset.CDemonstrates usage of class TEveStraightLineSet ;  lineset.py;  MultiView.CMulti-view (3d, rphi, rhoz) service class using EVE Window Manager ;  overlay_palette.C;  pack.CDemonstrates usage of class TGPack ;  paramlist.CDemonstrates usage of simple configuration via TEveParamList class ;  pointset.CDemonstrates usage of class TEvePointSet ;  projection.CDemonstrates usage of automatic 2D projections - class TEveProjectionManager ;  projection_prescale.CDemonstrates usage pre-scaling for automatic 2D projections ;  pythia_display.CDemo showing H -> ZZ -> 4 mu generated by Pythia ;  quadset.CDemonstates usage of 2D digit class TEveQuadSet ;  selection_sigs.CTest signals from TEveSelection class ;  show_extract.CHelper script for showing of extracted / simplified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► eve7;  collection.CThis example display collection of ??? in web browser ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:104969,simpl,simple,104969,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ger::MakeTube() method, we would have been able to create our wire with a single line :; TGeoVolume *wire_co = gGeoManager->MakeTube(""WIRE_CO"", ptrCOPPER, 0, 0.01, 1);; gGeoManagerR__EXTERN TGeoManager * gGeoManagerDefinition TGeoManager.h:608; TGeoManager::MakeTubeTGeoVolume * MakeTube(const char *name, TGeoMedium *medium, Double_t rmin, Double_t rmax, Double_t dz)Make in one step a volume pointing to a tube shape with given medium.Definition TGeoManager.cxx:3204; The same applies for all primitive shapes, for which there can be found corresponding MakeSHAPE() methods. Their usage is much more convenient unless a shape has to be shared between more volumes. Let's make now an aluminium wire having the same shape, supposing that we have created the copper wire with the line above :; TGeoVolume *wire_al = new TGeoVolume(""WIRE_AL"", wire_co->GetShape(), ptrAL);; TGeoVolume::GetShapeTGeoShape * GetShape() constDefinition TGeoVolume.h:190; Now that we have learned how to create elementary volumes, let's see how we can create a geometrical hierarchy. Positioning volumes; When creating a volume one does not specify if this will contain or not other volumes. Adding daughters to a volume implies creating those and adding them one by one to the list of daughters. Since the volume has to know the position of all its daughters, we will have to supply at the same time a geometrical transformation with respect to its local reference frame for each of them. The objects referencing a volume and a transformation are called NODES and their creation is fully handled by the modeler. They represent the link elements in the hierarchy of volumes. Nodes are unique and distinct geometrical objects ONLY from their container point of view. Since volumes can be replicated in the geometry, the same node may be found on different branches. An important observation is that volume objects are owned by the TGeoManager class. This stores a list of all volumes in the geometry, that is cleaned upon des",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:4960,learn,learned,4960,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,1,['learn'],['learned']
Usability,"ges to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in firs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:1578,undo,undo,1578,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,12,['undo'],['undo']
Usability,"gested work-flow, with an explanation of its motivation and details.; Some pertinent Git details; It is assumed at this point that you have a passing familiarity with CVS and/or Subversion; and that you have at least obtained a local copy (cloned) of a remote repository. Unlike CVS and SVN, every local working area is also a repository.; Unlike CVS and SVN, repositories are not sub-divisible: in the former systems, one can easily check out only a subsection of a package; with git, it's all-or-nothing.; A repository may have zero or more remote repositories to which items may be pushed (or from which they may be retrieved): Git is a truly distributed system.; Branches are easy to create, merge and destroy.; The, ""unit of change"" is a commit, labeled by its SHA1 hash. A tree's, ""state"" is a collection of commits. Merging branches multiple times is therefore trivial because it consists of comparing commit lists.; Git commit trees do not record history: they record changes. A simple change has one parent. Creating a branch creates another child of the parent commit; and a non-trivial merge joins two branches -- the resulting commit has two parents. Git (very) basics; Getting help. man git; git help <command>; man git-<command>; The git community book; Pragmatic Guide to Git; Google. Glossary. Add: put a file (or particular changes thereto) into the index ready for a commit operation. Optional for modifications to tracked files; mandatory for hitherto un-tracked files.; Alias shorthand for a git (or external) command, stored in a .gitconfig file.; Branch: a divergent change tree (eg a patch branch) which can me merged either wholesale or piecemeal with the master tree.; Commit: save the current state of the index and/or other specified files to the local repository.; Commit object: an object which contains the information about a particular revision, such as parents, committer, author, date and the tree object which corresponds to the top directory of the stored revision",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/git-tips-and-tricks.html:2975,simpl,simple,2975,d/git-tips-and-tricks.html,https://root.cern,https://root.cern/d/git-tips-and-tricks.html,1,['simpl'],['simple']
Usability,"getPlotLabel() const; Double_tRooAbsReal::getPropagatedError(const RooFitResult& fr); const Text_t*RooAbsArg::getStringAttribute(const Text_t* key) const; virtual const char*TNamed::GetTitle() const; TStringRooAbsReal::getTitle(Bool_t appendUnit = kFALSE) const; Bool_tRooAbsArg::getTransientAttribute(const Text_t* name) const; virtual UInt_tTObject::GetUniqueID() const; const Text_t*RooAbsReal::getUnit() const; Double_tRooAbsReal::getVal(const RooArgSet* set = 0) const; Double_tRooAbsReal::getVal(const RooArgSet& set) const; virtual Double_tRooAbsReal::getValV(const RooArgSet* set = 0) const; RooArgSet*RooAbsArg::getVariables(Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::graphVizTree(const char* fileName, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); voidRooAbsArg::graphVizTree(ostream& os, const char* delimiter = ""\n"", bool useTitle = false, bool useLatex = false); virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_thasChanged(Bool_t clearState); Bool_tRooAbsArg::hasClients() const; virtual ULong_tTNamed::Hash() const; virtual Bool_tRooAbsArg::hasRange(const char*) const; static Bool_tRooAbsReal::hideOffset(); RooGenFunction*RooAbsReal::iGenFunction(RooRealVar& x, const RooArgSet& nset = RooArgSet()); RooMultiGenFunction*RooAbsReal::iGenFunction(const RooArgSet& observables, const RooArgSet& nset = RooArgSet()); virtual Bool_tRooAbsArg::importWorkspaceHook(RooWorkspace&); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; virtual Bool_tRooAbsArg::inRange(const char*) const; virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual voidRooAbsArg::ioStreamerPass2(); static voidRooAbsArg::ioStreamerPass2Finalize(); virtual TClass*IsA() const; virtual Bool_tRooAbsReal::isBinnedDistribution(const RooArgSet&) const; Bool_tRooAbsArg::isCloneOf(const RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:15811,clear,clearState,15811,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,3,['clear'],['clearState']
Usability,"getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:38011,intuit,intuitively,38011,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,4,['intuit'],['intuitively']
Usability,"gger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode, e.g. if it contains objects of; any types deriving from TTrack this function will sort the objects; based on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:7458,simpl,simple,7458,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,1,['simpl'],['simple']
Usability,"gger than 100 (TTree::kSplitCollectionOfPointers); then the collection will be written in split mode. Ie. if it contains objects of; any types deriving from TTrack this function will sort the objects; basing on their type and store them in separate branches in split; mode. ==> branch->SetAddress(Void *address); In case of dynamic structures changing with each entry for example, one must; redefine the branch address before filling the branch again.; This is done via the TBranch::SetAddress member function. ==> tree->Fill(); loops on all defined branches and for each branch invokes the Fill function. See also the class TNtuple (a simple Tree with branches of floats). Adding a Branch to an Existing Tree. You may want to add a branch to an existing tree. For example,; if one variable in the tree was computed with a certain algorithm,; you may want to try another algorithm and compare the results.; One solution is to add a new branch, fill it, and save the tree.; The code below adds a simple branch to an existing tree.; Note the kOverwrite option in the Write method, it overwrites the; existing tree. If it is not specified, two copies of the tree headers; are saved. void tree3AddBranch(){; TFile f(""tree3.root"", ""update"");. Float_t new_v;; TTree *t3 = (TTree*)f->Get(""t3"");; TBranch *newBranch = t3->Branch(""new_v"", &new_v, ""new_v/F"");. //read the number of entries in the t3; Long64_t nentries = t3->GetEntries();. for (Long64_t i = 0; i < nentries; i++){; new_v= gRandom->Gaus(0, 1);; newBranch->Fill();; }; // save only the new version of the tree; t3->Write("""", TObject::kOverwrite);; }; Adding a branch is often not possible because the tree is in a read-only; file and you do not have permission to save the modified tree with the; new branch. Even if you do have the permission, you risk losing the; original tree with an unsuccessful attempt to save the modification.; Since trees are usually large, adding a branch could extend it over the; 2GB limit. In this case, the attempt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:7069,simpl,simple,7069,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['simpl'],['simple']
Usability,"gh); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&, unsigned int) ###; Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:49557,simpl,simplex,49557,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,2,['simpl'],['simplex']
Usability,"gh); Scans the value of the user function by varying parameter number \(\mbox{par}\), leaving all other parameters fixed at the current value. If \(\mbox{par}\) is not specified, all variable parameters are scanned in sequence. The number of points \(\mbox{npoints}\) in the scan is 40 by default, and cannot exceed 100. The range of the scan is by default 2 standard deviations on each side of the current best value, but can be specified as from \(\mbox{low}\) to \(\mbox{high}\). After each scan, if a new minimum is found, the best parameter values are retained as start values for future scans or minimizations. The curve resulting from each scan can be plotted on the output terminal using MnPlot [api:plot] in order to show the approximate behaviour of the function.; 5.10.2 ScanMinimizer; Although the \(\mbox{SCAN}\) method is not intended for minimization it can be used as a minimizer in its most primitive form.; 5.11 MnSimplex and SimplexMinimizer; [api:simplex]; \(\mbox{SIMPLEX}\) is a function minimization method using the simplex method of Nelder and Mead. MnSimplex provides minimization of the function by the method of \(\mbox{SIMPLEX}\) and the functionality for parameters interaction. It also retains the result from the last minimization in case the user may want to do subsequent minimization steps with parameter interactions in between the minimization requests. The minimization is done by the SimplexMinimizer. Minimization of the function can be done by directly using the SimplexMinimizer if no parameters interaction is required. As \(\mbox{SIMPLEX}\) is a stepping method it does not produce a covariance matrix.; 5.11.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); Constructor for the minimal required interface: \(\mbox{FCN}\) and starting values for parameters and uncertainties. Optional the strategy level in MnStrategy can be specified.; 5.11.2 MnSimplex(const FCNBase&, const MnUserParameter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:53562,simpl,simplex,53562,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['simpl'],['simplex']
Usability,"ghts () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t &matrix);  ; void WriteTensorToXML (void *node, const char *name, const std::vector< Matrix_t > &tensor);  helper functions for XML ;  . Static Protected Member Functions; static size_t CalculateNormDim (int axis, size_t c, size_t h, size_t w);  . Private Attributes; Tensor_t fDerivatives;  First fDerivatives of the activations of this layer. ;  ; TDescriptors * fDescriptors = nullptr;  ; Scalar_t fEpsilon;  ; Matrix_t fIVar;  ; Scalar_t fMomentum;  The weight dec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html:7626,learn,learningRate,7626,doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TBatchNormLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ging (Bool_t on=kTRUE) override;  Switch on/off merge timer. ;  ; void StopProcess (Bool_t abort, Int_t timeout=-1) override;  Stop process after this event. ;  ; void StoreFeedback (TObject *slave, TList *out) override;  Store feedback results from the specified slave. ;  ; void StoreOutput (TList *out) override;  Store received output list. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProofPlayer;  TProofPlayer (TProof *proof=0);  Default ctor. ;  ;  ~TProofPlayer () override;  Destructor. ;  ; void AddEventsProcessed (Long64_t ev) override;  ; void AddInput (TObject *inp) override;  Add object to input list. ;  ; void AddQueryResult (TQueryResult *q) override;  Add query result to the list, making sure that there are no duplicates. ;  ; void ClearInput () override;  Clear input list. ;  ; TDrawFeedback * CreateDrawFeedback (TProof *p) override;  Draw feedback creation proxy. ;  ; void DeleteDrawFeedback (TDrawFeedback *f) override;  Delete draw feedback object. ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:4635,feedback,feedback,4635,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static EvalErrorIter evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (std::ostream &os=std::cout, Int_t maxPerNode=10000000);  Print all outstanding logged evaluation error on the given ostream. ;  ; static void setEvalErrorLoggingMode (ErrorLoggingMode m);  Set evaluation error logging mode. ;  ; static void setHideOffset (bool flag);  ;  Static Public Member Functions inherited from RooAbsArg; static void setDirtyInhibit (bool flag);  Control global dirty inhibit mode. ;  ; static void verboseDirty (bool flag);  Activate verbose messaging related to dirty flag propagation. ;  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:49248,clear,clearing,49248,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['clear'],['clearing']
Usability,"given. For example, if the formula; TFormula old(sin(x*(x<0.5 || x>1))) one can assign a name to the formula. By default the name of the object = title = formula itself. old.SetName(""old""). then, old can be reused in a new expression. TFormula new(""x*old"") is equivalent to: TFormula new(""x*sin(x*(x<0.5 || x>1))""); Up to 4 dimensions are supported (indicated by x, y, z, t) An expression may have 0 parameters or a list of parameters indicated by the sequence [par_number]; A graph showing the logic to compile and analyze a formula is shown in TFormula::Compile and TFormula::Analyze. Once a formula has been compiled, it can be evaluated for a given set of parameters. see graph in TFormula::EvalPar.; This class is the base class for the function classes TF1,TF2 and TF3. It is also used by the ntuple selection mechanism TNtupleFormula.; In version 7 of TFormula, the usage of fOper has been changed to improve the performance of TFormula::EvalPar. Conceptually, fOper was changed from a simple array of Int_t to an array of composite values. For example a 'ylandau(5)' operation used to be encoded as 4105; it is now encoded as (klandau >> kTFOperShift) + 5 Any class inheriting from TFormula and using directly fOper (which is now a private data member), needs to be updated to take this in consideration. The member functions recommended to set and access fOper are: SetAction, GetAction, GetActionParam For more performant access to the information, see the implementation TFormula::EvalPar. CHANGING DEFAULT SETTINGS; When creating complex formula , it may be necessary to increase some default parameters. see static function TFormula::SetMaxima. WHY TFormula CANNOT ACCEPT A CLASS MEMBER FUNCTION ?; This is a frequently asked question. C++ is a strongly typed language. There is no way for TFormula (without recompiling this class) to know about all possible user defined data types. This also apply to the case of a static class function. Because TMath is a special and frequent case, T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html:2322,simpl,simple,2322,doc/master/classROOT_1_1v5_1_1TFormula.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1v5_1_1TFormula.html,1,['simpl'],['simple']
Usability,gradientsBegin () { assert (m_hasGradients); return m_itGradientBegin; } ///< returns iterator to the begin of the gradients; 604 const_iterator_type gradientsBegin () const { assert (m_hasGradients); return m_itGradientBegin; } ///< returns const iterator to the begin of the gradients; 605 const_iterator_type weightsBegin () const { assert (m_hasWeights); return m_itConstWeightBegin; } ///< returns const iterator to the begin of the weights for this layer; 606 ; 607 std::shared_ptr<std::function<double(double)>> activationFunction () const { return m_activationFunction; }; 608 std::shared_ptr<std::function<double(double)>> inverseActivationFunction () const { return m_inverseActivationFunction; }; 609 ; 610 /*! \brief set the drop-out info for this layer; 611 *; 612 */; 613 template <typename Iterator>; 614 void setDropOut (Iterator itDrop) { m_itDropOut = itDrop; m_hasDropOut = true; }; 615 ; 616 /*! \brief clear the drop-out-data for this layer; 617 *; 618 *; 619 */; 620 void clearDropOut () { m_hasDropOut = false; }; 621 ; 622 bool hasDropOut () const { return m_hasDropOut; } ///< has this layer drop-out turned on?; 623 const_dropout_iterator dropOut () const { assert (m_hasDropOut); return m_itDropOut; } ///< return the begin of the drop-out information; 624 ; 625 size_t size () const { return m_size; } ///< return the size of the layer; 626 ; 627 private:; 628 ; 629 /*! \brief compute the probabilities from the node values; 630 *; 631 *; 632 */; 633 container_type computeProbabilities () const;; 634 ; 635 private:; 636 ; 637 size_t m_size; ////< layer size; 638 ; 639 const_iterator_type m_itInputBegin; ///< iterator to the first of the nodes in the input node vector; 640 const_iterator_type m_itInputEnd; ///< iterator to the end of the nodes in the input node vector; 641 ; 642 std::vector<double> m_deltas; ///< stores the deltas for the DNN training; 643 std::vector<double> m_valueGradients; ///< stores the gradients of the values (nodes); 644 std::vector<doubl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:21205,clear,clearDropOut,21205,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['clear'],['clearDropOut']
Usability,"grams; When you call the Draw method of a histogram ( TH1::Draw ) for the first time, it creates a THistPainter object and saves a pointer to painter as a data member of the histogram. The THistPainter class specializes in the drawing of histograms. It allows logarithmic axes (x, y, z) when the CONT drawing option is using. The THistPainter class is separated from the histogram so that one can have histograms without the graphics overhead, for example in a batch program. The choice to give each histogram has its own painter rather than a central singleton painter, allows two histograms to be drawn in two threads without overwriting the painter’s values. When a displayed histogram is filled again, you do not have to call the Draw method again. The image is refreshed the next time the pad is updated. A pad is updated after one of these three actions:. A carriage control on the ROOT command line; A click inside the pad; A call to TPad::Update(). By default, the TH1::Draw clears the pad before drawing the new image of the histogram. You can use the ""SAME"" option to leave the previous display intact and superimpose the new histogram. The same histogram can be drawn with different graphics options in different pads. When a displayed histogram is deleted, its image is automatically removed from the pad. To create a copy of the histogram when drawing it, you can use TH1::DrawClone(). This will clone the histogram and allow you to change and delete the original one without affecting the clone. You can use TH1::DrawNormalized() to draw a normalized copy of a histogram.; TH1 *TH1::DrawNormalized(Option_t *option,Double_t norm) const; A clone of this histogram is normalized to norm and drawn with option. A pointer to the normalized histogram is returned. The contents of the histogram copy are scaled such that the new sum of weights (excluding under and overflow) is equal to norm .; Note that the returned normalized histogram is not added to the list of histograms in the current",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:82469,clear,clears,82469,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clears']
Usability,"gregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearRange(const char* name, Bool_t silent); voidRooAbsArg::clearShapeDirty() const; voidclearTypes(); voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsArg*RooAbsCategory::createFundamental(const char* newname = 0) const; Roo1DTable*RooAbsCategory::createTable(const char* label) const; virtual Int_tRooAbsArg::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; Bool_tdefineType(const char* label); Bool_tdefineType(const char* label, Int_t index); virtual voidTObject::Delete(Option_t* option = """")MENU ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCategory.html:2174,clear,clearValueDirty,2174,root/html532/RooCategory.html,https://root.cern,https://root.cern/root/html532/RooCategory.html,1,['clear'],['clearValueDirty']
Usability,"gressBar::fFillType. protected . OPTION={GetMethod=""GetFillType"";SetMethod=""SetFillType"";Items=(kSolidFill=Solid"",kBlockFill=""Block"")} ; Definition at line 33 of file TGProgressBar.h. ◆ fFontStruct. FontStruct_t TGProgressBar::fFontStruct. protected . font used to draw position text ; Definition at line 41 of file TGProgressBar.h. ◆ fFormat. TString TGProgressBar::fFormat. protected . format used to show position not in percent ; Definition at line 35 of file TGProgressBar.h. ◆ fgDefaultFont. const TGFont * TGProgressBar::fgDefaultFont = nullptr. staticprotected . Definition at line 45 of file TGProgressBar.h. ◆ fgDefaultGC. TGGC * TGProgressBar::fgDefaultGC = nullptr. staticprotected . Definition at line 46 of file TGProgressBar.h. ◆ fMax. Float_t TGProgressBar::fMax. protected . logical maximum value (default 100) ; Definition at line 29 of file TGProgressBar.h. ◆ fMin. Float_t TGProgressBar::fMin. protected . logical minimum value (default 0) ; Definition at line 28 of file TGProgressBar.h. ◆ fNormGC. GContext_t TGProgressBar::fNormGC. protected . text drawing graphics context ; Definition at line 40 of file TGProgressBar.h. ◆ fPercent. Bool_t TGProgressBar::fPercent. protected . show position in percent (default true) ; Definition at line 37 of file TGProgressBar.h. ◆ fPos. Float_t TGProgressBar::fPos. protected . logical position [fMin,fMax] ; Definition at line 30 of file TGProgressBar.h. ◆ fPosPix. Int_t TGProgressBar::fPosPix. protected . position of progress bar in pixel coordinates ; Definition at line 31 of file TGProgressBar.h. ◆ fShowPos. Bool_t TGProgressBar::fShowPos. protected . show position value (default false) ; Definition at line 36 of file TGProgressBar.h. Libraries for TGProgressBar:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGProgressBar.h; gui/gui/src/TGProgressBar.cxx. TGProgressBar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:39111,progress bar,progress bar,39111,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"ground events from the training sample. Boosting:; The idea behind adaptive boosting (AdaBoost) is, that signal events from the training sample, that end up in a background node (and vice versa) are given a larger weight than events that are in the correct leave node. This results in a re-weighed training event sample, with which then a new decision tree can be developed. The boosting can be applied several times (typically 100-500 times) and one ends up with a set of decision trees (a forest). Gradient boosting works more like a function expansion approach, where each tree corresponds to a summand. The parameters for each summand (tree) are determined by the minimization of a error function (binomial log- likelihood for classification and Huber loss for regression). A greedy algorithm is used, which means, that only one tree is modified at a time, while the other trees stay fixed. Bagging:; In this particular variant of the Boosted Decision Trees the boosting is not done on the basis of previous training results, but by a simple stochastic re-sampling of the initial training event sample. Random Trees:; Similar to the ""Random Forests"" from Leo Breiman and Adele Cutler, it uses the bagging algorithm together and bases the determination of the best node-split during the training on a random subset of variables only which is individually chosen for each split. Analysis:; Applying an individual decision tree to a test event results in a classification of the event as either signal or background. For the boosted decision tree selection, an event is successively subjected to the whole set of decision trees and depending on how often it is classified as signal, a ""likelihood"" estimator is constructed for the event being signal or background. The value of this estimator is the one which is then used to select the events from an event sample, and the cut value on this estimator defines the efficiency and purity of the selection. ; Definition at line 63 of file MethodBDT.h. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:3150,simpl,simple,3150,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['simpl'],['simple']
Usability,"gs and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr);  Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium. ;  ; void ReplayCreation (const TGeoVolume *other);  Recreate the content of the other volume without pointer copying. ;  ; void ResetTransparency (Char_t transparency=-1);  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Save geometry having this as top volume as a C++ macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SelectVolume (Bool_t clear=kFALSE);  Select this volume as matching an arbitrary criteria. ;  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAdded ();  ; void SetAsTopVolume ();  Set this volume as the TOP one (the whole geometry starts from here) ;  ; void SetAttVisibility (Bool_t vis);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  Set the current tracking point. ;  ; void SetCylVoxels (Bool_t flag=kTRUE);  ; void SetField (TObject *field);  ; void SetFinder (TGeoPatternFinder *finder);  ; void SetFWExtension (TGeoExtension *ext);  Connect framework defined extension to the volume. ;  ; void SetInvisible ();  ; void SetLineColor (Color_t lcolor) override;  Set the line color. ;  ; void SetLineStyle (Style_t lstyle) override;  Set the line style. ;  ; void SetLineWidth (Width_t lwidth) override;  Set the line width. ;  ; virtual void SetMedium (TGeoMedium *medium);  ; void SetNodes (TObjArray *nodes);  ; void SetNtotal (Int_t ntotal);  ; void SetNumber (Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolume.html:22110,clear,clear,22110,doc/master/classTGeoVolume.html,https://root.cern,https://root.cern/doc/master/classTGeoVolume.html,2,['clear'],['clear']
Usability,"gs and perform raytracing in the pad. ;  ; void RegisterYourself (Option_t *option="""");  Register the volume and all materials/media/matrices/shapes to the manager. ;  ; void Release ();  ; void RemoveNode (TGeoNode *node);  Remove an existing daughter. ;  ; TGeoNode * ReplaceNode (TGeoNode *nodeorig, TGeoShape *newshape=nullptr, TGeoMatrix *newpos=nullptr, TGeoMedium *newmed=nullptr);  Replace an existing daughter with a new volume having the same name but possibly a new shape, position or medium. ;  ; void ReplayCreation (const TGeoVolume *other);  Recreate the content of the other volume without pointer copying. ;  ; void ResetTransparency (Char_t transparency=-1);  ; void SaveAs (const char *filename="""", Option_t *option="""") const override;  Save geometry having this as top volume as a C++ macro. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a primitive as a C++ statement(s) on output stream ""out"". ;  ; void SelectVolume (Bool_t clear=kFALSE);  Select this volume as matching an arbitrary criteria. ;  ; void SetActiveDaughters (Bool_t flag=kTRUE);  ; void SetActivity (Bool_t flag=kTRUE);  ; void SetAdded ();  ; void SetAsTopVolume ();  Set this volume as the TOP one (the whole geometry starts from here) ;  ; void SetAttVisibility (Bool_t vis);  ; void SetCurrentPoint (Double_t x, Double_t y, Double_t z);  Set the current tracking point. ;  ; void SetCylVoxels (Bool_t flag=kTRUE);  ; void SetField (TObject *field);  ; void SetFinder (TGeoPatternFinder *finder);  ; void SetFWExtension (TGeoExtension *ext);  Connect framework defined extension to the volume. ;  ; void SetInvisible ();  ; void SetNodes (TObjArray *nodes);  ; void SetNtotal (Int_t ntotal);  ; void SetNumber (Int_t number);  ; void SetOption (const char *option);  Set the current options (none implemented) ;  ; void SetOverlappingCandidate (Bool_t flag);  ; void SetReplicated ();  ; void SetShape (const TGeoShape *shape);  set the shape associated with this volume ;  ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoVolumeMulti.html:18583,clear,clear,18583,doc/master/classTGeoVolumeMulti.html,https://root.cern,https://root.cern/doc/master/classTGeoVolumeMulti.html,1,['clear'],['clear']
Usability,"gs)""; TStringTCollection::fNamename of the collection; Bool_tfNewDeletekTRUE if Redo/Undo methods are new/delete; void*fObjectobject to which undo/redo actions applied; TQConnection*fRedodo/redo action; Long_t*fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tfState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tfStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringfTitlecommand description; TQConnection*fUndoundo action; Long_t*fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(const char* cl, void* object, const char* redo, const char* undo); common protected method used in several constructors. TQCommand(const char* cl = 0, void* object = 0, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. clname - class name.; 2. obj - an object; 3. redo - method or function to do/redo operation; 4. undo - method or function to undo operation. Comments:; - if either clname or obj is NULL that means that redo/undo is function; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");. - undo method can be same as redo one. In that case undo parameter; can be omitted. Example:; TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. TQCommand(TObject* obj, const char* redo = 0, const char* undo = 0); Constructor. Input parameters:; 1. obj - an object; 2. redo - method or function to do/redo operation; 3. undo - method or function to undo operation. Comments:; - to specify default arguments for redo/undo method/function; '=' must precede to argument value. Example:; TQCommand(gPad, ""SetEditable(=kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:17929,undo,undo,17929,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,4,['undo'],['undo']
Usability,"gs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption, TDirectory* theTargetDir = 0); standard constructor. MethodMLP(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = 0); constructor from a weight file. ~MethodMLP(); destructor; nothing to be done. Bool_t HasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); MLP can handle classification with 2 classes and regression with one regression-target. void Init(); default initializations. void DeclareOptions(); define the options (their key words) that can be set in the option string; know options:; TrainingMethod <string> Training method; available values are: BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs. BPMode <string> Back-propagation learning mode; available values are: sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events. void ProcessOptions(); process user options. void InitializeLearningRates(); initialize learning rates of synapses, used only by backpropagation. Double_t CalculateEstimator(TMVA::Types::ETreeType treeType = Types::kTraining, Int_t iEpoch = -1); calculate the estimator that training is attempting to minimize. void Train(Int_t nEpochs). void BFGSMinimize(Int_t nEpochs); train network with BFGS algorithm. void SetGammaDelta(TMatrixD& Gamma, TMatrixD& Delta, vector<Double_t>& Buffer). void ComputeDEDw(). void SimulateEvent(const TMVA::Event* ev). void SteepestDir(TMatrixD& Dir). Bool_t GetHessian(TMatrixD& Hessian, TMatrixD& Gamma, TMatrixD& Delta). void SetDir(TMatrixD& Hessian, TMatrixD& Dir).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodMLP.html:22589,learn,learning,22589,root/html528/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodMLP.html,12,['learn'],['learning']
Usability,"gs; }; 87 ; 88 /**; 89 get the vector of parameter settings (non-const method); 90 */; 91 std::vector<ROOT::Fit::ParameterSettings> & ParamsSettings() { return fSettings; }; 92 ; 93 /**; 94 number of parameters settings; 95 */; 96 unsigned int NPar() const { return fSettings.size(); }; 97 ; 98 /**; 99 return a vector of stored parameter values (i.e initial fit parameters); 100 */; 101 std::vector<double> ParamsValues() const;; 102 ; 103 ; 104 /**; 105 set the parameter settings from a model function.; 106 Create always new parameter setting list from a given model function; 107 */; 108 template <class T>; 109 void CreateParamsSettings(const ROOT::Math::IParamMultiFunctionTempl<T> &func) {; 110 // initialize from model function; 111 // set the parameters values from the function; 112 unsigned int npar = func.NPar();; 113 const double *begin = func.Parameters();; 114 if (!begin) {; 115 fSettings = std::vector<ParameterSettings>(npar);; 116 return;; 117 }; 118 ; 119 fSettings.clear();; 120 fSettings.reserve(npar);; 121 const double *end = begin + npar;; 122 unsigned int i = 0;; 123 for (const double *ipar = begin; ipar != end; ++ipar) {; 124 double val = *ipar;; 125 double step = 0.3 * fabs(val); // step size is 30% of par value; 126 // double step = 2.0*fabs(val); // step size is 30% of par value; 127 if (val == 0) step = 0.3;; 128 ; 129 fSettings.push_back(ParameterSettings(func.ParameterName(i), val, step));; 130#ifdef DEBUG; 131 std::cout << ""FitConfig: add parameter "" << func.ParameterName(i) << "" val = "" << val << std::endl;; 132#endif; 133 i++;; 134 }; 135 }; 136 ; 137 /**; 138 set the parameter settings from number of parameters and a vector of values and optionally step values. If there are not existing or number of parameters does not match existing one, create a new parameter setting list.; 139 */; 140 void SetParamsSettings(unsigned int npar, const double * params, const double * vstep = nullptr);; 141 ; 142 /*; 143 Set the parameter settings from a vector ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8h_source.html:3104,clear,clear,3104,doc/master/FitConfig_8h_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html,1,['clear'],['clear']
Usability,"gth()-2) = '*';; 1036 type.erase(type.length()-1);; 1037 }; 1038 prototype += type;; 1039 }; 1040 ; 1041 prototype = ""("" + prototype + "")"";; 1042 return true;; 1043 }; 1044 else {; 1045 ShowWarning(""can't convert Decl to FunctionDecl"","""");; 1046 return false;; 1047 }; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051 ; 1052void RScanner::Scan(const clang::ASTContext &C); 1053{; 1054 fSourceManager = &C.getSourceManager();; 1055 ; 1056// if (fVerboseLevel >= 3) fSelectionRules.PrintSelectionRules();; 1057 ; 1058 if (fVerboseLevel > 0 && fSelectionRules.GetHasFileNameRule()) {; 1059 std::cout<<""File name detected""<<std::endl;; 1060 }; 1061 ; 1062 if (fScanType == EScanType::kTwoPasses); 1063 TraverseDecl(C.getTranslationUnitDecl());; 1064 ; 1065 fFirstPass=false;; 1066 fselectedRecordDecls.clear();; 1067 fSelectedEnums.clear();; 1068 fSelectedTypedefs.clear();; 1069 fSelectedVariables.clear();; 1070 fSelectedFunctions.clear();; 1071 TraverseDecl(C.getTranslationUnitDecl());; 1072 ; 1073 // The RecursiveASTVisitor uses range-based for; we must not modify the AST; 1074 // during iteration / visitation. Instead, buffer the lookups that could; 1075 // potentially create new template specializations, and handle them here:; 1076 AddDelayedAnnotatedRecordDecls();; 1077}; 1078 ; 1079 ; 1080////////////////////////////////////////////////////////////////////////////////; 1081/// Set the callback to the RecordDecl and return the previous one.; 1082 ; 1083RScanner::DeclCallback RScanner::SetRecordDeclCallback(RScanner::DeclCallback callback); 1084{; 1085 DeclCallback old = fRecordDeclCallback;; 1086 fRecordDeclCallback = callback;; 1087 return old;; 1088}; IntToStrstd::string IntToStr(int num)Definition Scanner.cxx:161; APIntToLonglong APIntToLong(const llvm::APInt &num)Definition Scanner.cxx:147; gInterpcling::Interpreter * gInterp; AddSpacestd::string AddSpace(const std::string &txt)Definition Scanner.cxx:266; APIntToSizes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Scanner_8cxx_source.html:36883,clear,clear,36883,doc/master/Scanner_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Scanner_8cxx_source.html,1,['clear'],['clear']
Usability,"gxwork[1] = xhigh;; 1638 gywork[1] = yhigh;; 1639 ComputeLogs(2, optionZ);; 1640 if (gyworkl[0] < gPad->GetUymin()) gyworkl[0] = gPad->GetUymin();; 1641 if (gyworkl[1] < gPad->GetUymin()) continue;; 1642 if (gyworkl[1] > gPad->GetUymax()) gyworkl[1] = gPad->GetUymax();; 1643 if (gyworkl[0] > gPad->GetUymax()) continue;; 1644 ; 1645 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1646 }; 1647 } else {; 1648 for (i=1;i<=npoints;i++) {; 1649 xhigh = x[i-1];; 1650 ylow = y[i-1] - dbar;; 1651 yhigh = y[i-1] + dbar;; 1652 xlow = TMath::Max((Double_t)0, gPad->GetUxmin());; 1653 gxwork[0] = xlow;; 1654 gywork[0] = ylow;; 1655 gxwork[1] = xhigh;; 1656 gywork[1] = yhigh;; 1657 ComputeLogs(2, optionZ);; 1658 gPad->PaintBox(gxworkl[0],gyworkl[0],gxworkl[1],gyworkl[1]);; 1659 }; 1660 }; 1661 theGraph->SetFillColor(FillSave);; 1662 theGraph->TAttFill::Modify();; 1663 }; 1664 gPad->ResetBit(TGraph::kClipFrame);; 1665 ; 1666 gxwork.clear();; 1667 gywork.clear();; 1668 gxworkl.clear();; 1669 gyworkl.clear();; 1670}; 1671 ; 1672 ; 1673////////////////////////////////////////////////////////////////////////////////; 1674/// This is a service method used by `THistPainter`; 1675/// to paint 1D histograms. It is not used to paint TGraph.; 1676///; 1677/// Input parameters:; 1678///; 1679/// - npoints : Number of points in X or in Y.; 1680/// - x[npoints] or x[0] : x coordinates or (xmin,xmax).; 1681/// - y[npoints] or y[0] : y coordinates or (ymin,ymax).; 1682/// - chopt : Option.; 1683///; 1684/// The aspect of the histogram is done according to the value of the chopt.; 1685///; 1686/// | Option | Description |; 1687/// |--------|-----------------------------------------------------------------|; 1688/// |""R"" | Graph is drawn horizontally, parallel to X axis. (default is vertically, parallel to Y axis).If option R is selected the user must give 2 values for Y (y[0]=YMIN and y[1]=YMAX) or N values for X, one for each channel. Otherwise the user must give, N values for Y, one",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:60424,clear,clear,60424,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['clear'],['clear']
Usability,"h as the coordinates of a point, it is most efficient to create one branch with both coordinates on it. A variable on a TBranch is called a leaf (yes - TLeaf). Another point to keep in mind when designing trees is that branches of the same TTree can be written to separate files. To add a TBranch to a TTree we call the method TTree::Branch(). Note that we DO NOT use the TBranch constructor.; The TTree::Branch method has several signatures. The branch type differs by what is stored in it. A branch can hold an entire object, a list of simple variables, contents of a folder, contents of a TList, or an array of objects. Let’s see some examples. To follow along you will need the shared library libEvent.so. First, check if it is in $ROOTSYS/test. If it is, copy it to your own area. If it is not there, you have to build it by typing make in $ROOTSYS/test.; 12.9 Adding a Branch to Hold a List of Variables; As in the very first example (cernstaff.root.root) the data we want to save is a list of simple variables, such as integers or floats. In this case, we use the following TTree::Branch signature:; tree->Branch(""Ev_Branch"",&event,; ""temp/F:ntrack/I:nseg:nvtex:flag/i"");; The first parameter is the branch name.; The second parameter is the address from which the first variable is to be read. In the code above, “event” is a structure with one float and three integers and one unsigned integer. You should not assume that the compiler aligns the elements of a structure without gaps. To avoid alignment problems, you need to use structures with same length members. If your structure does not qualify, you need to create one branch for each element of the structure.; The leaf name is NOT used to pick the variable out of the structure, but is only used as the name for the leaf. This means that the list of variables needs to be in a structure in the order described in the third parameter.; This third parameter is a string describing the leaf list. Each leaf has a name and a type separate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:537702,simpl,simple,537702,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"h boost.python (with pyste; standalone it is a non-starter) and SWIG is that you need to run a separate tool to create and compile bindings. On top, these bindings are compiled against a specific version of Python, making for a distribution headache (just see the non-pickup of Python3 because of this problem). Compare: dictionaries are already available for all the most important classes in experiments, the EDM, because they are generated for I/O needs. They also do not depend on Python, and thus not on any specific version (only PyROOT does). Besides the obvious ease of use, there is also the benefit of lower memory footprints by not replicating structures. (For that matter, PyROOT creates bindings lazily, the others do not.); Other problems we've had, are that boost.python is very, very slow and only in ""keeping alive"" mode since 2004 or so. Pyste is based on gccxml, so no C++11 there, and has seen no major updates since 2005. SWIG is much, much better in both regards, but not up to snuff: it plain and simply can not parse our header files. The way around that, is to write .i files, but as you can imagine, that duplication is not nice for maintenance. Worse, the developers of individual packages need to do this work, and not every C++ developer has Python, let alone SWIG, experience.; Then there's PyPy. All existing binding generator tools (including PyROOT) rely on CPython internals, or at least on the Python C-API. That does not jive with PyPy as it has for example a garbage collector instead of reference counting. Through some heroics, it does expose a Python C-API, but it's slow as it interferes (blocks, really) the just-in-time compiler. Therefore, within PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also already a PyROOT version for the latter (see: http://root.cern.ch/drupal/content/pypyroot).; Cheers,; Wim. Submitted by Anonymous (not verified) on Thu, 07/23/2015 - 21:49 Permalink . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:7738,simpl,simply,7738,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['simpl'],['simply']
Usability,"h command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute redo method; com->Undo(); // execute undo method. 4. Merged commands. It possible to group several commands together so an end user; can undo and redo them with one command. TQCommand *update = new TQCommand(gPad, ""Modified()"");; com->Add(update);. 5. Macro commands. ""Merging"" allows to create macro commands, e.g. TQCommand *macro = new TQCommand(""my macro"");; macro->Add(com1);; macro->Add(com2);. During Redo operation commands composing macro command are executed; sequentially in direct order (first in first out). During Undo,; they are executed in reverse order (last in first out). 6. Undo manager. TQUndoManager is recorder of undo and redo operations. This is; command history list which can be traversed backwards and upwards; performing undo and redo operations.; To register command TQUndoManager::Add(TObject*) method is used. TQUndoManager *history = new TQUndoManager();; history->Add(com);. TQUndoManager::Add automatically invokes execution of command's; Redo method. Use TQUndoManager::Undo t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:2039,undo,undo,2039,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,12,['undo'],['undo']
Usability,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 36592 2010-11-11 10:43:17Z ganis $ » Last generated: 2010-12-08 16:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayerSlave.html:15039,feedback,feedback,15039,root/html528/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html528/TProofPlayerSlave.html,2,['feedback'],['feedback']
Usability,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 39442 2011-05-27 09:13:25Z ganis $ » Last generated: 2011-07-04 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofPlayerSlave.html:15166,feedback,feedback,15166,root/html530/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html530/TProofPlayerSlave.html,2,['feedback'],['feedback']
Usability,"h input objects; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Int_tTProofPlayer::fMaxDrawQueriesMax number of Draw queries kept; TList*TProofPlayer::fOutputlist with output objects; TQueryResult*TProofPlayer::fPreviousQueryPrevious instance of TQueryResult processed; TProofProgressStatus*TProofPlayer::fProgressStatusthe progress status object;; TQueryResult*TProofPlayer::fQueryInstance of TQueryResult currently processed; TList*TProofPlayer::fQueryResultsList of TQueryResult; TStatus*TProofPlayer::fSelStatus! status of query in progress; TSelector*TProofPlayer::fSelector! the latest selector; TClass*TProofPlayer::fSelectorClass! class of the latest selector; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; TTimer*TProofPlayer::fStopTimerTimer associated with a stop request; TMutex*TProofPlayer::fStopTimerMtxTo protect the stop timer; Long64_tTProofPlayer::fTotalEventsnumber of events requested; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static THashList*TProofPlayer::fgDrawInputParsList of input parameters to be kept on drawing actions. private:. TList*fFeedbackList of objects to send updates of; TSocket*fSocket. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupFeedback(); Setup feedback. void StopFeedback(); Stop feedback. Bool_t HandleTimer(TTimer* timer); Handle timer event. void HandleGetTreeHeader(TMessage* mess); Handle tree header request. TProofPlayerSlave(TSocket* socket = 0); { }. » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id: TProofPlayer.h 40186 2011-07-11 12:00:50Z ganis $ » Last generated: 2011-11-03 20:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofPlayerSlave.html:15166,feedback,feedback,15166,root/html532/TProofPlayerSlave.html,https://root.cern,https://root.cern/root/html532/TProofPlayerSlave.html,2,['feedback'],['feedback']
Usability,"h mode. ; Reimplemented from RooAbsReal.; Definition at line 121 of file RooRatio.cxx. ◆ evaluate(). double RooRatio::evaluate ; (; ); const. overrideprotectedvirtual . Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ; Implements RooAbsReal.; Definition at line 114 of file RooRatio.cxx. ◆ IsA(). TClass * RooRatio::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 44 of file RooRatio.h. ◆ Streamer(). void RooRatio::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsReal. ◆ StreamerNVirtual(). void RooRatio::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 44 of file RooRatio.h. ◆ translate(). void RooRatio::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 127 of file RooRatio.cxx. Member Data Documentation. ◆ _denominator. RooRealProxy RooRatio::_denominator. protected . Definition at line 42 of file RooRatio.h. ◆ _numerator. RooRealProxy RooRatio::_numerator. protected . Definition at line 41 of file RooRatio.h. Libraries for RooRatio:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooRatio.h; roofit/roofitcore/src/Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRatio.html:63534,simpl,simple,63534,doc/master/classRooRatio.html,https://root.cern,https://root.cern/doc/master/classRooRatio.html,1,['simpl'],['simple']
Usability,"h neuron calculate its delta by back propagation ; Definition at line 1328 of file MethodMLP.cxx. ◆ Class(). static TClass * TMVA::MethodMLP::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::MethodMLP::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::MethodMLP::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 219 of file MethodMLP.h. ◆ ComputeDEDw(). void TMVA::MethodMLP::ComputeDEDw ; (; ). private . Definition at line 697 of file MethodMLP.cxx. ◆ ComputeEstimator(). Double_t TMVA::MethodMLP::ComputeEstimator ; (; std::vector< Double_t > & ; parameters). this function is called by GeneticANN for GA optimization ; Definition at line 1393 of file MethodMLP.cxx. ◆ DecaySynapseWeights(). void TMVA::MethodMLP::DecaySynapseWeights ; (; Bool_t ; lateEpoch). private . decay synapse weights in last 10 epochs, lower learning rate even more to find a good minimum ; Definition at line 1208 of file MethodMLP.cxx. ◆ DeclareOptions(). void TMVA::MethodMLP::DeclareOptions ; (; ). privatevirtual . define the options (their key words) that can be set in the option string ; know options:. TrainingMethod <string> Training method available values are:; BP Back-Propagation <default>; GA Genetic Algorithm (takes a LONG time). LearningRate <float> NN learning rate parameter; DecayRate <float> Decay rate for learning parameter; TestRate <int> Test for overtraining performed at each #th epochs; BPMode <string> Back-propagation learning mode available values are:; sequential <default>; batch. BatchSize <int> Batch size: number of events/batch, only set if in Batch Mode,; -1 for BatchSize=number_of_events . Reimplemented from TMVA::MethodANNBase.; Definition at line 195 of file MethodMLP.cxx. ◆ DeclFileName(). static const char * TMVA::MethodMLP::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:41348,learn,learning,41348,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,"h object; is found return a null pointer. TObject* FindObject(const TObject* obj) const; Find object in list. If list contains object return; (same) pointer to object, otherwise return null pointer. void Clear(Option_t* o = 0); Remove all elements from collection. void Delete(Option_t* o = 0); Remove all elements in collection and delete all elements; NB: Collection does not own elements, this function should; be used judiciously by caller. TObject* find(const char* name) const; Return pointer to object with given name in collection.; If no such object is found, return null pointer. Int_t IndexOf(const TObject* arg) const; Return position of given object in list. If object; is not contained in list, return -1. Int_t IndexOf(const char* name) const; Return position of given object in list. If object; is not contained in list, return -1. void Print(const char* opt) const; Print contents of list, defers to Print() function; of contained objects. TIterator* MakeIterator(Bool_t dir = kTRUE) const; Return an iterator over this list. RooLinkedListIter iterator(Bool_t dir = kTRUE) const; Return an iterator over this list. void Sort(Bool_t ascend = kTRUE); Sort elements of this list according to their; TObject::Compare() ranking via a simple; bubble sort algorithm. void swapWithNext(RooLinkedListElem* elem); Swap given to elements in the linked list. Auxiliary function for Sort(). void Streamer(TBuffer& b); Custom streaming handling schema evolution w.r.t past implementations. Int_t getHashTableSize() const; Return size of hash table. Int_t GetSize() const; { return _size ; }. void Add(TObject* arg); { Add(arg,1) ; }. TObject* First() const. const char* GetName() const; { return _name.Data() ; }. void SetName(const char* name); { _name = name ; }. » Last changed: Sat Oct 9 06:58:32 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLinkedList.html:8806,simpl,simple,8806,root/html528/RooLinkedList.html,https://root.cern,https://root.cern/root/html528/RooLinkedList.html,1,['simpl'],['simple']
Usability,"h of; the mark is w, height is h and the type of the mark is determined by the; parameter type. void Slice(Double_t xr, Double_t yr, Double_t xs, Double_t ys, TLine* line); Calculates screen coordinates of the line given by two; nodes for contours display mode. The line is given by two points; xr, yr, xs, ys. Finally it draws the line. void CopyEnvelope(Double_t xr, Double_t xs, Double_t yr, Double_t ys); Copies envelope vector, which ensures hidden surface removal for the; contours display mode. void Paint(Option_t* option); Paints histogram according to preset parameters. ; Visualization; Goal: to present 2-dimensional spectra in suitable visual form; This package has several display mode groups and display modes, which can be; employed for the presentation of 2-dimensional histograms; Display modes groups:. kModeGroupSimple - it covers simple display modes using one; color only; kModeGroupLight - in this group the shading is carried out; according to the position of the fictive; light source; kModeGroupHeight - in this group the shading is carried out; according to the channel contents; kModeGroupLightHeight - combination of two previous shading; algorithms. One can control the weight; between both algorithms. Display modes:. kDisplayModePoints, ; kDisplayModeGrid, ; kDisplayModeContours,; kDisplayModeBars,; kDisplayModeLinesX,; kDisplayModeLinesY,; kDisplayModeBarsX,; kDisplayModeBarsY,; kDisplayModeNeedles,; kDisplayModeSurface,; kDisplayModeTriangles. one can combine the above given modes groups and display modes. The meaningful; combinations (denoted by x) are given in the next table. SimpleLightHeightLight-Height. Points XXXX; Grid XXXX; Contours X-X-; Bars X-X-; LinesX XXXX; LinesY XXXX; BarsX X-X-; BarsY X-X-; Needles X---; Surface -XXX; TrianglesXXXX. Function:; void TSpectrum2Painter::SetDisplayMode (Int_t modeGroup, Int_t displayMode). This function controls the display mode group and display mode of the; histogram drawing. To illustrate the possible ef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum2Painter.html:16454,simpl,simple,16454,root/html528/TSpectrum2Painter.html,https://root.cern,https://root.cern/root/html528/TSpectrum2Painter.html,6,['simpl'],['simple']
Usability,"h performance, but sometimes it gets in the way of writing simple code that manages RDF objects. Luckily, every RDF object can be converted to the generic RNode type. This tutorial shows how to take advantage of RNode to easily manipulate RDataFrames.; ; /// A generic function that takes an RDF object and applies a string filter; ROOT::RDF::RNode AddFilter(ROOT::RDF::RNode node, string_view filterStr); {; return node.Filter(filterStr);; }; ; void df025_RNode(); {; ROOT::RDataFrame df(8);; ; // Using the generic AddFilter helper function defined above: RNode in, RNode out; auto f1 = AddFilter(df, ""rdfentry_ > 0"");; auto f2 = f1.Filter([](ULong64_t e) { return e > 1; }, {""rdfentry_""});; ; // Conditionally applying a filter is simple with ROOT::RDF::RNode; bool someCondition = true;; auto maybe_filtered = ROOT::RDF::RNode(f2);; if (someCondition); maybe_filtered = maybe_filtered.Filter(""rdfentry_ > 3"");; ; // Adding new columns with Define in a loop is simple thanks to ROOT::RDF::RNode; auto with_columns = ROOT::RDF::RNode(maybe_filtered);; for (auto i = 0; i < 3; ++i); with_columns = with_columns.Define(""x"" + std::to_string(i), ""42"");; ; // RNodes can be used exactly like any other RDF object; std::cout << ""Entries passing the selection: "" << with_columns.Count().GetValue() << std::endl;; }; e#define e(i)Definition RSha256.hxx:103; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; ROOT::RDF::RInterfaceThe public interface to the RDataFrame federation of classes.Definition RInterface.hxx:113; ROOT::RDF::RInterface::FilterRInterface< RDFDetail::RFilter< F, Proxied >, DS_t > Filter(F f, const ColumnNames_t &columns={}, std::string_view name="""")Append a filter to the call graph.Definition RInterface.hxx:219; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; f1TF1 * f1Definition legend1.C:11; ROOT::RDF::RNodeRInterface<::ROOT::Detail::RDF::RNodeBase, void > RNodeDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df025__RNode_8C.html:1310,simpl,simple,1310,doc/master/df025__RNode_8C.html,https://root.cern,https://root.cern/doc/master/df025__RNode_8C.html,1,['simpl'],['simple']
Usability,"h reference ref. ;  ; Long64_t Finalize (Int_t query=-1, Bool_t force=kFALSE);  Finalize the qry-th query in fQueries. ;  ; TList * FindDataSets (const char *searchString, const char *optStr="""");  Find datasets, returns in a TList all found datasets. ;  ; Long64_t GetBytesRead () const;  ; Int_t GetClientProtocol () const;  ; const char * GetConfDir () const;  ; const char * GetConfFile () const;  ; Float_t GetCpuTime () const;  ; const char * GetDataPoolUrl () const;  ; virtual TFileCollection * GetDataSet (const char *dataset, const char *optStr="""");  Get a list of TFileInfo objects describing the files of the specified dataset. ;  ; TMap * GetDataSetQuota (const char *optStr="""");  returns a map of the quotas of all groups ;  ; virtual TMap * GetDataSets (const char *uri="""", const char *optStr="""");  Lists all datasets that match given uri. ;  ; TString Getenv (const char *env, const char *ord=""0"");  Get value of environment variable 'env' on node 'ord'. ;  ; TList * GetFeedbackList () const;  Return feedback list. ;  ; const char * GetGroup () const;  ; const char * GetImage () const;  ; TList * GetInputList ();  Get input list. ;  ; TMacro * GetLastLog ();  Fill a TMacro with the log lines since the last reading (fLogFileR) Return (TMacro *)0 if no line was logged. ;  ; TList * GetListOfEnabledPackages ();  Get from the master the list of names of the packages enabled. ;  ; TList * GetListOfPackages ();  Get from the master the list of names of the packages available. ;  ; virtual TList * GetListOfQueries (Option_t *opt="""");  Ask the master for the list of queries. ;  ; TList * GetListOfSlaveInfos ();  Returns list of TSlaveInfo's. In case of error return 0. ;  ; TList * GetLoadedMacros () const;  ; void GetLog (Int_t start=-1, Int_t end=-1);  Ask for remote logs in the range [start, end]. ;  ; Int_t GetLogLevel () const;  ; TMacro * GetMacroLog ();  ; TProofMgr * GetManager ();  ; const char * GetMaster () const;  ; void GetMaxQueries ();  Get max number of quer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:8714,feedback,feedback,8714,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,3,['feedback'],['feedback']
Usability,"h that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 372 of file RooCategory.cxx. ◆ addToRange() [2/2]. void RooCategory::addToRange ; (; const char * ; name, . RooAbsCategory::value_type ; stateIndex . ). Add the given state to the given range. ; NoteThis creates or accesses a shared map with allowed ranges. All copies of this category will share this range such that a category inside a dataset and its counterpart on the outside will both see a modification of the range. ; Definition at line 348 of file RooCategory.cxx. ◆ Class(). static TClass * RooCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooCategory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 141 of file RooCategory.h. ◆ clear(). void RooCategory::clear ; (; ). inline . Clear all defined category states. ; Definition at line 69 of file RooCategory.h. ◆ clearRange(). void RooCategory::clearRange ; (; const char * ; name, . bool ; silent . ). Clear the named range. ; NoteThis affects all copies of this category, because they are sharing range definitions. This ensures that categories inside a dataset and their counterparts on the outside will both see a modification of the range. ; Definition at line 321 of file RooCategory.cxx. ◆ clone(). TObject * RooCategory::clone ; (; const char * ; newname); const. inlineoverridevirtual . Implements RooAbsArg.; Definition at line 37 of file RooCategory.h. ◆ DeclFileName(). static const char * RooCategory::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 141 of file RooCategory.h. ◆ defineType() [1/2]. bool RooCategory::defineType ; (; const std::string & ; label). Define a state with given name. ; The lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:55025,clear,clear,55025,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clear']
Usability,"h the prior to obtain the posterior function ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio of profiled likelihoods ;  CSamplingDistPlotThis class provides",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:7992,simpl,simple,7992,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['simpl'],['simple']
Usability,"h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Horizontal progress bar constructor. ;  ;  ~TGHProgressBar () override;  ; TGDimension GetDefaultSize () const override;  std::cout << fWidth << ""x"" << fHeight << std::endl; ;  ; TClass * IsA () const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a horizontal progress bar as a C++ statement(s) on output stream out. ;  ; void ShowPosition (Bool_t set=kTRUE, Bool_t percent=kTRUE, const char *format=""%.2f"");  Show postion text, either in percent or formatted according format. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGProgressBar;  TGProgressBar (const TGWindow *p, UInt_t w, UInt_t h, Pixel_t back=GetWhitePixel(), Pixel_t barcolor=GetDefaultSelectedBackground(), GContext_t norm=GetDefaultGC()(), FontStruct_t font=GetDefaultFontStruct(), UInt_t options=kDoubleBorder|kSunkenFrame);  Create progress bar. ;  ;  ~TGProgressBar () override;  ; virtual void Format (const char *format=""%.2f"");  Set format for displaying a value. ;  ; Pixel_t GetBarColor () const;  ; EBarType GetBarType () const;  ; EFillType GetFillType () const;  ; FontStruct_t GetFontStruct () const;  ; TString GetFormat () const;  ; Float_t GetMax () const;  ; Float_t GetMin () const;  ; GContext_t GetNormGC () const;  ; Float_t GetPosition () const;  ; Bool_t GetShowPos () const;  ; const char * GetValueFormat () const;  ; void Increment (Float_t inc);  Increment progress position. ;  ; TClass * IsA () const override;  ; virtual void Percent (Bool_t on);  ; virtual void Reset ();  Reset progress bar (i.e. set pos to 0). ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save progress bar parameters",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGHProgressBar.html:1916,progress bar,progress bar,1916,doc/master/classTGHProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGHProgressBar.html,1,['progress bar'],['progress bar']
Usability,"h. ◆ stringAttributes(). const std::map< std::string, std::string > & RooAbsArg::stringAttributes ; (; ); const. inline . Definition at line 321 of file RooAbsArg.h. ◆ substituteServer(). void RooAbsArg::substituteServer ; (; RooAbsArg * ; oldServer, . RooAbsArg * ; newServer . ). private . Set by the RooFitDriver for this arg to retrieve its result in the run context. ; Private helper function for RooAbsArg::redirectServers().; *‍/ ; Definition at line 1116 of file RooAbsArg.cxx. ◆ syncCache(). virtual void RooAbsArg::syncCache ; (; const RooArgSet * ; nset = nullptr). protectedpure virtual . Implemented in RooStringVar, RooAbsCategory, RooAbsReal, and RooErrorVar. ◆ transientAttributes(). const std::set< std::string > & RooAbsArg::transientAttributes ; (; ); const. inline . Definition at line 329 of file RooAbsArg.h. ◆ translate(). void RooAbsArg::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. virtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented in RooStats::HistFactory::FlexibleInterpVar, ParamHistFunc, PiecewiseInterpolation, RooBernstein, RooBifurGauss, RooCBShape, RooChebychev, RooExponential, RooGamma, RooGaussian, RooLandau, RooLognormal, RooParamHistFunc, RooPoisson, RooPolynomial, RooUniform, RooAddition, RooAddPdf, RooConstraintSum, RooConstVar, RooEfficiency, RooEffProd, RooExtendPdf, RooFormulaVar, RooGenericPdf, RooHistFunc, RooHistPdf, RooPolyVar, RooProduct, RooRatio, RooRealIntegral, RooR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:102126,simpl,simple,102126,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['simpl'],['simple']
Usability,"h.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathematical operations involving arrays and scalars ;  vo003_LogicalOperations.C In this tutorial we learn how the RVec class can be used to express logical operations ;  vo004_SortAndSelect.C In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo004_SortAndSelect.py In this tutorial we learn how elements of an RVec can be easily sorted and selected ;  vo005_Combinations.C In this tutorial we learn how combinations of RVecs can be build ;  vo005_Combinations.py In this tutorial we learn how combinations of RVecs can be build ;  vo006_IndexManipulation.C In this tutorial we demonstrate RVec helpers for index manipulation ;  ► xml;  DOMParsePerson.C ROOT implementation of a XML DOM Parser ;  DOMRecursive.C ROOT implementation of a XML DOM Parser ;  SAXHandler.C ROOT implementation of a simple SAX Handler ;  xmlmodifyfile.C Example to read, modify and store xml file, using TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  xmlnewfile.C Example to create a new xml file with the TXMLEngine class ;  xmlreadfile.C Example to read and parse any xml file, supported by TXMLEngine class The input file, produced by xmlnewfile.C macro is used If you need full xml syntax support, use TXMLParser instead ;  benchmarks.CThis macro run several tests and produces an benchmark report ;  demos.CThis macro shows a control bar to run some of the ROOT tutorials ;  demoshelp.CThis macro shows help on running the Demos ;  geant3t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:172919,learn,learn,172919,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['learn'],['learn']
Usability,"h1*-*-; *-* =============================. this = this*h1. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this profile by multiplication of h1 by h2; *-* ================================================================. this = (c1*h1)*(c2*h2). TH1D * ProjectionX(const char* name = ""_px"", Option_t* option = ""e"") const; Project this profile into a 1-D histogram along X*-*-; *-* =================================================. The projection is always of the type TH1D. if option ""E"" is specified the errors of the projected histogram are computed and set; to be equal to the errors of the profile.; Option ""E"" is defined as the default one in the header file.; if option """" is specified the histogram errors are simply the sqrt of its content; if option ""B"" is specified, the content of bin of the returned histogram; will be equal to the GetBinEntries(bin) of the profile,; otherwise (default) it will be equal to GetBinContent(bin); if option ""C=E"" the bin contents of the projection are set to the; bin errors of the profile; if option ""W"" is specified the bin content of the projected histogram is set to the; product of the bin content of the profile and the entries.; With this option the returned histogram will be equivalent to the one obtained by; filling directly a TH1D using the 2-nd value as a weight.; This makes sense only for profile filled with weights =1. If not, the error of the; projected histogram obtained with this option will not be correct. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xbins = 0); Rebin this profile grouping ngroup bins together*-*-*-*-; *-* ================================================; -case 1 xbins=0; if newname is not blank a new temporary profile hnew is created.; else the current profile is modified (default); The parameter ngroup indicates ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile.html:38819,simpl,simply,38819,root/html528/TProfile.html,https://root.cern,https://root.cern/root/html528/TProfile.html,3,['simpl'],['simply']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:4086,clear,clearValueDirty,4086,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:3186,clear,clearValueDirty,3186,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,2,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:2590,clear,clearValueDirty,2590,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,1,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBCPEffDecay.html:2892,clear,clearValueDirty,2892,root/html526/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html526/RooBCPEffDecay.html,4,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:2790,clear,clearValueDirty,2790,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,1,['clear'],['clearValueDirty']
Usability,"hDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg::none(), const RooCmdArg arg7 = RooCmdArg::none(), const RooCmdArg arg8 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooArgusBG.html:2614,clear,clearValueDirty,2614,root/html526/RooArgusBG.html,https://root.cern,https://root.cern/root/html526/RooArgusBG.html,49,['clear'],['clearValueDirty']
Usability,"hNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual Bool_tchangeModel(const RooResolutionModel& newModel); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); const RooRealVar*convVar() const; virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); static UInt_tRooAbsArg::crc32(const char* data, ULong_t sz, UInt_t crc = 0); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsAnaConvPdf.html:4804,clear,clearValueDirty,4804,root/html534/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsAnaConvPdf.html,2,['clear'],['clearValueDirty']
Usability,"hPolargram::Initvoid Init()Initialize some of the fields of TGraphPolargram.Definition TGraphPolargram.cxx:327; TGraphPolargram::fRadialTextSizeDouble_t fRadialTextSizeDefinition TGraphPolargram.h:34; TGraphPolargram::GetTickpolarSizeDouble_t GetTickpolarSize()Definition TGraphPolargram.h:79; TGraphPolargram::SetPolarOffsetvoid SetPolarOffset(Double_t PolarOffset=0.04)Set the labels offset.Definition TGraphPolargram.cxx:832; TGraphPolargram::fGradBool_t fGradDefinition TGraphPolargram.h:25; TGraphPolargram::SetTwoPivoid SetTwoPi()Set range from 0 to 2*pi.Definition TGraphPolargram.cxx:947; TGraphPolargram::FindTextAngleDouble_t FindTextAngle(Double_t theta)Determine the orientation of the polar labels according to their angle.Definition TGraphPolargram.cxx:307; TGraphPolargram::SetRadialLabelColorvoid SetRadialLabelColor(Color_t tcolorradial=1)Set radial labels color.Definition TGraphPolargram.cxx:841; TGraphPolargram::PaintCirclevoid PaintCircle(Double_t x, Double_t y, Double_t r, Double_t phimin, Double_t phimax, Double_t theta)This is simplified from TEllipse::PaintEllipse.Definition TGraphPolargram.cxx:373; TGraphPolargram::SetRangeRadialvoid SetRangeRadial(Double_t rmin, Double_t rmax)Set the radial range.Definition TGraphPolargram.cxx:894; TGraphPolargram::fRadianBool_t fRadianDefinition TGraphPolargram.h:23; TGraphPolargram::SetTickpolarSizevoid SetTickpolarSize(Double_t tickpolarsize=0.02)Set polar ticks size.Definition TGraphPolargram.cxx:906; TGraphPolargram::SetAxisAnglevoid SetAxisAngle(Double_t angle=0)Set axis angle.Definition TGraphPolargram.cxx:765; TGraphPolargram::SetToDegreevoid SetToDegree()The Polar circle is labelled using degree.Definition TGraphPolargram.cxx:914; TGraphPolargram::SetNdivPolarvoid SetNdivPolar(Int_t Ndiv=508)Set the number of Polar divisions: enter a number ij with 0<i<99 and 0<j<99.Definition TGraphPolargram.cxx:775; TGraphPolargram::fNdivRadInt_t fNdivRadNumber of radial divisions.Definition TGraphPolargram.h:46; TGraphPolar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:37248,simpl,simplified,37248,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,1,['simpl'],['simplified']
Usability,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighboring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighboring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // displa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html:73014,simpl,simple,73014,root/htmldoc/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/htmldoc/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"hading according to channels counts-; // PICTURE2_MODE_GROUP_HEIGHT, modes of combination of; // shading according to light and to channels counts-; // PICTURE2_MODE_GROUP_LIGHT_HEIGHT); int display_mode; // spectrum display mode (points, grid, contours, bars, x_lines,; // y_lines, bars_x, bars_y, needles, surface, triangles); int z_scale; // z scale (linear, log, sqrt); int nodesx; // number of nodes in x dimension of grid; int nodesy; // number of nodes in y dimension of grid; int count_reg; // width between contours, applies only for contours display mode; int alfa; // angles of display,alfa+beta must be less or equal to 90, alpha- angle; // between base line of Canvas and left lower edge of picture picture; // base plane; int beta; // angle between base line of Canvas and right lower edge of picture base plane; int view_angle; // rotation angle of the view, it can be 0, 90, 180, 270 degrees; int levels; // # of color levels for rainbowed display modes, it does not apply for; // simple display modes algorithm group; float rainbow1_step; // determines the first component step for neighbouring color; // levels, applies only for rainbowed display modes, it does not apply; // for simple display modes algorithm group; float rainbow2_step; // determines the second component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; float rainbow3_step; // determines the third component step for neighbouring; // color levels, applies only for rainbowed display modes, it does not; // apply for simple display modes algorithm group; int color_alg; // applies only for rainbowed display modes (rgb smooth algorithm,; // rgb modulo color component, cmy smooth algorithm, cmy modulo; // color component, cie smooth algorithm, cie modulo color component,; // yiq smooth algorithm, yiq modulo color component, hsv smooth; // algorithm, hsv modulo color component, it does not apply for simple; // dis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:72022,simpl,simple,72022,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,1,['simpl'],['simple']
Usability,"hange both values simultaneously press the mouse button near to the slider center. To change pointer value press the mouse on the pointer and drag it to the desired position.; fSlider = new TGTripleHSlider(parent,100,kDoubleScaleBoth,kSLD_ID,; kHorizontalFrame);; parent->AddFrame(fSlider,new TGLayoutHints(kLHintsExpandX,5,5,5,5));; fSlider->SetConstrained(kTRUE);; fSlider->SetRange(rmin, rmax);; fSlider->SetPosition(pmin, pmax);; fSlider ->SetPointerPosition(pvalue);; 25.8.10 Progress Bars; A progress bar is a widget that shows that an operation is in progress and how much time is left. It is a long rectangular bar, initially empty, that fills with a color as a process is being performed. The filled-in area indicates the percentage of the process that has been completed. You should use this widget for waits exceeding one minute. For a very time consuming operation it is better to break the operation into subtasks and provide a progress bar for each of them. A progress bar may be oriented horizontally or vertically. The horizontally oriented progress bar fills with a color from left to right; the vertically oriented - from bottom to top. A percent complete message provides an indication of the completed part of the process. It is a good practice to include some descriptive text of the process to keep users informed and entertained while they are waiting for process completion.; The picture below shows the progress bars you can create using the classes TGProgressBar, TGHProgressBar, and TGHProgressBar.; // vertical frame with three horizontal progressive bars; TGVerticalFrame *vframe = new TGVerticalFrame(fMain, 10, 10);; fHProg1 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHProg1->ShowPosition();; fHProg1->SetBarColor(""yellow"");; fHProg2 = new TGHProgressBar(vframe,TGProgressBar::kFancy,300);; fHProg2->SetBarColor(""lightblue"");; fHProg2->ShowPosition(kTRUE,kFALSE,""%.0f events"");; fHProg3 = new TGHProgressBar(vframe,TGProgressBar::kStandard,300);; fHPro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1208165,progress bar,progress bar,1208165,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['progress bar'],['progress bar']
Usability,"hanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Print(). void TSelEventGen::Print ; (; Option_t * ; option = """"); const. overridevirtual . This method must be overridden when a class wants to print itself. ; Reimplemented from TObject.; Definition at line 486 of file TSelEventGen.cxx. ◆ Process(). Bool_t TSelEventGen::Process ; (; Long64_t ; entry). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 326 of file TSelEventGen.cxx. ◆ SetInputList(). void TSelEventGen::SetInputList ; (; TList * ; input). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 68 of file TSelEventGen.h. ◆ SetObject(). void TSelEventGen::SetObject ; (; TObject * ; obj). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file TSelEventGen.h. ◆ SetOption(). void TSelEventGen::SetOption ; (; const char * ; option). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 66 of file TSelEventGen.h. ◆ SlaveBegin(). void TSelEventGen::SlaveBegin ; (; TTree * ; tree). overridevirtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server. The tree argument is deprecated (on PROOF 0 is passed). ; Reimplemented from TSelector.; Definition at line 89 of fil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEventGen.html:17599,simpl,simple,17599,doc/master/classTSelEventGen.html,https://root.cern,https://root.cern/doc/master/classTSelEventGen.html,1,['simpl'],['simple']
Usability,"hanism. `TCanvas::Highlighted()` is similar; 3094`TCanvas::Picked()`; 3095 ; 3096- when selected object (histogram as a whole) is different from previous; 3097then emit `Picked()` signal; 3098- when selected (highlighted) bin from histogram is different from previous; 3099then emit `Highlighted()` signal; 3100 ; 3101Any user function (or functions) has to be defined; 3102`UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y)`.; 3103In example (see below) has name `PrintInfo()`. All parameters of user; 3104function are taken from; 3105 ; 3106 void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3107 ; 3108- `pad` is pointer to pad with highlighted histogram; 3109- `obj` is pointer to highlighted histogram; 3110- `x` is highlighted x bin for 1D histogram; 3111- `y` is highlighted y bin for 2D histogram (for 1D histogram not in use); 3112 ; 3113Example how to create a connection from any `TCanvas` object to a user; 3114`UserFunction()` slot (see also `TQObject::Connect()` for additional info); 3115 ; 3116 TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 3117 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3118 ; 3119or use non-static ""simplified"" function; 3120`TCanvas::HighlightConnect(const char *slot)`; 3121 ; 3122 c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; 3123 ; 3124NOTE the signal and slot string must have a form; 3125""(TVirtualPad*,TObject*,Int_t,Int_t)""; 3126 ; 3127 root [0] .x $ROOTSYS/tutorials/hsimple.C; 3128 root [1] hpx->SetHighlight(kTRUE); 3129 root [2] .x hlprint.C; 3130 ; 3131file `hlprint.C`; 3132~~~ {.cpp}; 3133void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); 3134{; 3135 auto h = (TH1F *)obj;; 3136 if (!h->IsHighlight()) // after highlight disabled; 3137 h->SetTitle(""highlight disable"");; 3138 else; 3139 h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; 3140 h->GetBinCenter(x), h->GetBinContent(x)));; 3141 pad->Updat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:123630,simpl,simplified,123630,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['simpl'],['simplified']
Usability,"hanisms of ROOT are activated by a single call: ROOT::EnableThreadSafety() which is the successor of the existing TThread::Initialize. This call must take place if ROOT needs to be used in a thread safe manner.; The implementation of TSemaphore was redone based on C++11 thread primitive in order to prevent cases where some of request post were lost.; TDirectory::TContext; We added a default constructor to TDirectory::TContext which record the current directory and will restore it at destruction time and does not change the current directory.; The constructor for TDirectory::TContext that takes a single TDirectory pointer as an argument was changed to set gDirectory to zero when being passed a null pointer; previously it was interpreting a null pointer as a request to not change the current directory - this behavior is now implement by the default constructor.; Collections; In THashList and THashTable, GetListForObject now returns a pointer to const as modifying the returned list (in particular adding to it) can break invariant of THashTable so we need to clearly mark the list as not being allowed to be modified.; In TSeqCollection::Merge, we no longer delete the object in the case where the original collection is marked as a owner.; Global resources.; Several tweaks to if and when, resources held by the global ROOT object (TROOT, TApplication) are deleted. When the default TApplication is replaced by a user provide TApplication, do not call EndOfProcessCleanups and co. and thus do not delete TFiles, TSockets or TColors that have already been created. In EndOfProcessCleanups, we now delete the objects held in TROOT’s TDirectory part. If the libCling library is unloaded, this now induces an immediate tear down of the ROOT resources; consequently objects might be deleted sooner in the process tear down process on some platforms.; TObject instances allocated as part of an array and made part of a collection, as for example the TCanvas instances into the global list of i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v606/release-notes.html:4941,clear,clearly,4941,doc/v606/release-notes.html,https://root.cern,https://root.cern/doc/v606/release-notes.html,1,['clear'],['clearly']
Usability,"har *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Returns the name of redo command. ;  ; Int_t GetStatus () const;  Returns a number of sequential undo or redo operations. ;  ; const char * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:3003,undo,undo,3003,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"har *distribution=nullptr, const char *projectionMode=nullptr, TGraph **lCurvePlot=nullptr, TSpline **logTauXPlot=nullptr, TSpline **logTauYPlot=nullptr);  scan a function wrt tau and determine the minimum ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TUnfoldSys;  TUnfoldSys (const TH2 *hist_A, EHistMap histmap, ERegMode regmode=kRegModeSize, EConstraint constraint=kEConstraintArea);  set up response matrix A, uncorrelated uncertainties of A and regularisation scheme ;  ;  TUnfoldSys (void);  only for use by root streamer or derived classes ;  ;  ~TUnfoldSys (void) override;  ; void AddSysError (const TH2 *sysError, const char *name, EHistMap histmap, ESysErrMode mode);  Specify a correlated systematic uncertainty. ;  ; void GetBackground (TH1 *bgr, const char *bgrSource=nullptr, const Int_t *binMap=nullptr, Int_t includeError=3, Bool_t clearHist=kTRUE) const;  get background into a histogram ;  ; TSortedList * GetBgrSources (void) const;  Get a new list of all background sources. ;  ; Double_t GetChi2Sys (void);  calculate total chi**2 including all systematic errors ;  ; Bool_t GetDeltaSysBackgroundScale (TH1 *delta, const char *source, const Int_t *binMap=nullptr);  correlated one-sigma shifts from background normalisation uncertainty ;  ; Bool_t GetDeltaSysSource (TH1 *hist_delta, const char *source, const Int_t *binMap=nullptr);  correlated one-sigma shifts correspinding to a given systematic uncertainty ;  ; Bool_t GetDeltaSysTau (TH1 *delta, const Int_t *binMap=nullptr);  correlated one-sigma shifts from shifting tau ;  ; void GetEmatrixInput (TH2 *ematrix, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance matrix contribution from input measurement uncertainties ;  ; void GetEmatrixSysBackgroundScale (TH2 *ematrix, const char *source, const Int_t *binMap=nullptr, Bool_t clearEmat=kTRUE);  covariance contri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfoldDensity.html:14732,clear,clearHist,14732,doc/master/classTUnfoldDensity.html,https://root.cern,https://root.cern/doc/master/classTUnfoldDensity.html,1,['clear'],['clearHist']
Usability,"har * GetTitle () const override;  Returns command description. ;  ; TQConnection * GetUndo () const;  ; Long_t * GetUndoArgs () const;  Returns a pointer to array of undo arguments. ;  ; const char * GetUndoName () const;  Returns the name of undo command. ;  ; Bool_t IsEqual (const TObject *obj) const override;  Equal comparison. ;  ; Bool_t IsExecuting () const;  Returns kTRUE if command execution is in progress. ;  ; Bool_t IsMacro () const;  Returns kTRUE if neither redo nor undo action specified. ;  ; Bool_t IsRedoing () const;  Redo action is in progress. ;  ; virtual Bool_t IsSetter () const;  Returns kTRUE is command if Redo is the same as Undo function and is the setter action. ;  ; Bool_t IsUndoing () const;  Undo action is in progress. ;  ; virtual Long64_t Merge (TCollection *, TFileMergeInfo *);  Merge a collection of TQCommand. ;  ; virtual void Merge (TQCommand *c);  Add command to the list of merged commands. ;  ; virtual void SetArgs (Int_t nargs,...);  Set do/redo and undo parameters. ;  ; virtual void SetName (const char *name);  Sets name of the command. ;  ; virtual void SetRedoArgs (Int_t nargs,...);  Set redo parameters. ;  ; virtual void SetTitle (const char *title);  Sets description of the command. ;  ; virtual void SetUndoArgs (Int_t nargs,...);  Set undo parameters. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TList;  TList ();  ; The argument is ignored Use the default constructor TList ()."") ;  ;  TList (TObject *) R__DEPRECATED(6;  ; virtual ~TList ();  Delete the list. ;  ; void AddAfter (const TObject *after, TObject *obj) override;  Insert object after object after in the list. ;  ; virtual void AddAfter (TObjLink *after, TObject *obj);  Insert object after the specified ObjLink object. ;  ; void AddAt (TObject *obj, Int_t idx) override;  Insert object at position idx in the list. ;  ; void AddBefore (const TObject *before, TObject *obj) override;  Insert object befor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:4330,undo,undo,4330,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"hat it has one daughter. Of course, the gas has some container also, but let us keeps it like that for the sake of simplicity. Since we did not supply the third argument, the wire will be positioned with an identity transformation inside the chamber.; Overlapping Volumes; Positioning volumes that does not overlap their neighbors nor extrude their container is sometimes quite strong constraint. Having a limited set of geometric shapes might force sometimes overlaps. Since overlapping is contradictory to containment, a point belonging to an overlapping region will naturally belong to all overlapping partners. The answer provided by the modeller to ""Where am I?"" is no longer deterministic if there is no priority assigned.; There are two ways out provided by the modeller in such cases and we will illustrate them by examples. Suppose we have 2 crossing tubes that we have to describe. Such a structure cannot be decomposed in a containment schema. This is a typical example of simple structure that can be handled by using composite shapes. What we have to do is to define as shapes the inner and outer parts of the tubes (tubes having Rmin=0,Rmax=inner/outer radius), then to make a composite:; C = (Tub1out+Tub2out)-(Tub1in+Tub2in); On the other hand, if we have an EM calorimeter having a honeycomb structure, Boolean combinations do not help anymore. Here the problem is that we usually have a very large number of cells that are naturally belonging to the same container. This result in a very flat and slow structure for that particular container, which we would very much want to avoid by introducing additional levels in depth. We can describe the basic cell as a hexahedron that we can represent by using a polygon primitive shape. Instead of putting one by one all cells in the same container, we can define rows of such elements, fitting in box-shaped containers. Then we can put row-beside-row inside the container, making life much easier for its navigation algorithms. The problem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:37632,simpl,simple,37632,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"hat the; expression eprim2 is very close to 0 (rounding problems) or 0.; - The algorithm is modified/protected for the case; when a TProfile2D is projected (ProjectionX). The previous algorithm; generated a N^2 problem when projecting a TProfile2D with a large number of; bins (eg 100000).; - in version 3.10/02, a new static function TProfile::Approximate; is introduced to enable or disable (default) the approximation.; (see also comments in TProfile::GetBinError). Option_t * GetErrorOption() const; -*-*Return option to compute profile2D errors; *-* =========================================. void GetStats(Double_t* stats) const; fill the array stats from the contents of this profile; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2; stats[4] = sumwy; stats[5] = sumwy2; stats[6] = sumwxy; stats[7] = sumwz; stats[8] = sumwz2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. void LabelsDeflate(Option_t* axis = ""X""); Reduce the number of bins for this axis to the number of bins having a label. void LabelsInflate(Option_t* axis = ""X""); Double the number of bins for axis.; Refill histogram; This function is called by TAxis::FindBin(const char *label). void LabelsOption(Option_t* option = ""h"", Option_t* axis = ""X""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). Long64_t Merge(TCollection* list); Merge all histograms in the collection in this histogram.; This function computes the min/max for the axes,; compute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProfile2D.html:37682,simpl,simply,37682,root/html528/TProfile2D.html,https://root.cern,https://root.cern/root/html528/TProfile2D.html,6,['simpl'],['simply']
Usability,"he 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6098; TTree::fTotBytesLong64_t fTotBytesTotal number of bytes in all branches before compression.Definition TTree.h:86; TTree::FlushBasketsvirtual Int_t FlushBaskets(bool create_cluster=true) constWrite to disk all the basket that have not yet been individually written and create an event cluster ...Definition TTree.cxx:5129; TTree::GetDefaultEntryOffsetLenInt_t GetDefaultEntryOffsetLen() constDefinition TTree.h:459; TTree::fMaxClusterRangeInt_t fMaxClusterRange! Memory allocated for the cluster range.Definition TTree.h:96; TTree::Showvirtual void Show(Long64_t entry=-1, Int_t lenmax=20)Print values of all active leaves for entry.Definition TTree.cxx:9385; TTree::fEventListTEventList * fEventList! Pointer to event selection list (if one)Definition TTree.h:125; TTree::GetAutoSavevirtual Long64_t GetAutoSave() constDefinition TTree.h:448; TTree::StopCacheLearningPhasevirtual Int_t StopCacheLearningPhase()Stop the cache learning phase.Definition TTree.cxx:9474; TTree::GetEntryvirtual Int_t GetEntry(Long64_t entry, Int_t getall=0)Read all branches of entry and return total number of bytes read.Definition TTree.cxx:5638; TTree::fSortedBranchesstd::vector< std::pair< Long64_t, TBranch * > > fSortedBranches! Branches to be processed in parallel when IMT is on, sorted by average task timeDefinition TTree.h:144; TTree::SetCircularvirtual void SetCircular(Long64_t maxEntries)Enable/Disable circularity for this tree.Definition TTree.cxx:8892; TTree::GetEstimatevirtual Long64_t GetEstimate() constDefinition TTree.h:507; TTree::GetDebugMaxLong64_t GetDebugMax() constDefinition TTree.h:460; TTree::fSavedBytesLong64_t fSavedBytesNumber of autosaved bytes.Definition TTree.h:88; TTree::AddBranchToCachevirtual Int_t AddBranchToCache(const char *bname, bool subbranches=false)Add branch with name bname to the Tree cache.Definition TTree.cxx:1059; TTree::GetMedianClusterSizeLong64_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:56085,learn,learning,56085,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['learn'],['learning']
Usability,"he Brent method to minimize one-dimensional function. An interval containing the function minimum must be provided. Here is an example where we define the function to minimize as a lambda function (requires C++11). The function to minimize must be given to the class implementing the algorithm as a ROOT::Math::IBaseFunctionOneDim object.; ROOT::Math::Functor1D func( [](double x){ return 1 + -4*x + 1*x*x; } );. ROOT::Math::BrentMinimizer1D bm;; bm.SetFunction(func, -10,10);; bm.Minimize(10,0,0);; cout << ""Minimum: f("" << bm.XMinimum() << "") = "" <<bm.FValMinimum() << endl;; Note that when setting the function to minimize, one needs to provide the interval range to find the minimum. In the Minimize call, the maximum number of function calls, the relative and absolute tolerance must be provided.; 13.10.1.2 ROOT::Math::GSLMInimizer1D; This class wraps two different methods from the GSL. The algorithms which can be chosen at construction time are GOLDENSECTION, which is the simplest method but the slowest and BRENT (the default one) which combines the golden section with a parabolic interpolation. The algorithm can be chosen as a different enumeration in the constructor: * ROOT::Math::Minim1D::kBRENT for the Brent algorithm (default) * ROOT::Math::Minim1D::kGOLDENSECTION for the golden section algorithm; // this makes class with the default Brent algorithm; ROOT::Math::GSLMinimizer1D minBrent;; // this make the class with the Golden Section algorithm; ROOT::Math::GSLMinimizer1D minGold(ROOT::Math::Minim1D::kGOLDENSECTION);; The interface to set the function and to minimize is the same as in the case of the BrentMinimizer1D.; 13.10.1.3 Using the TF1 class; It is possible to perform the one-dimensional minimization/maximization of a function by using directly the function class in ROOT, TF1 of the Hist library. The minmization is implemented in TF1 using the BrentMInimizer1D and available with the class member functions * TF1::GetMinimum/TF1::GetMaximum to find the function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:715971,simpl,simplest,715971,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simplest']
Usability,"he Double_t argument det is supplied, the matrix determinant is calculated. A.InvertFast(&det); TMatrixX; like Invert but for matrices i =(6x6)a faster but less accurate Cramer algorithm is used. A.Rank1Update(v,alpha); TMatrixX; Perform with vector v a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu^T\). A.RandomizePD(alpha,beta,seed)`; TMatrixX; \(A_{ij} = (\beta-\alpha)\bigcup(0,1)+\alpha\) a random symmetric positive-definite matrix is generated with elements uniformly distributed between \(\alpha\) and \(\beta\). Output TMatrixX indicates that the returned matrix is of the same type as A, being TMatrixD, TMatrixDSym or TMatrixDSparse. Next table shows miscellaneous operations for TMatrixD. Format; Output; Description. A.Rank1Update(v1,v2,alpha); TMatrixD; Perform with vector v1 and v2, a rank 1 operation on the matrix: \(A = A + \alpha.\nu.\nu2^T\). 14.5 Matrix Views; Another way to access matrix elements is through the matrix-view classes, TMatrixDRow, TMatrixDColumn, TMatrixDDiag and TMatrixDSub (each has also a const version which is obtained by simply appending const to the class name). These classes create a reference to the underlying matrix, so no memory management is involved. The next table shows how the classes access different parts of the matrix:. class; view. TMatrixDRow const(X,i) TMatrixDRow(X,i); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & & & & \\; x_{i0} & ... & x_{ij} & ... & x_{in} \\; & & & & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDColumn const(X,j) TMatrixDColumn(X,j); \[ \left(\begin{array}{ccccc}; x_{00} & & x_{0j} & & x_{0n} \\; & & ... & & \\; & & x_{ij} & & \\; & & ... & & \\; x_{n0} & & x_{nj} & & x_{nn}; \end{array}\right)\]. TMatrixDDiag const(X) TMatrixDDiag(X); \[ \left(\begin{array}{ccccc}; x_{00} & & & & x_{0n} \\; & ... & & & \\; & & ... & & \\; & & & ... & \\; x_{n0} & & & & x_{nn}; \end{array}\right)\]. TMatrixDSub const(X,i,l,j,k) TMatrixDSub(X,i,l,j,k); \[ \left(\begin{array}{ccccc}",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:783968,simpl,simply,783968,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"he RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7869,simpl,simple,7869,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"he STOP button; 114from the bottom-left; 115You can toggle recording of the current command in the history file by; 116checking the Rec button from the top-right; 117 ; 118### Context menus; 119 ; 120 You can activate context menus by right-clicking on items or inside the; 121right panel.; 122 ; 123Context menus for mapped items from the left tree-type list :; 124 The items from the left that are provided with context menus are tree and; 125branch items. You can directly activate the *MENU* marked methods of TTree; 126from this menu.; 127 ; 128Context menu for the right panel:; 129 ; 130 A general context menu is activated if the user right-clicks the right panel.; 131 ; 132 Commands are :; 133 - EmptyAll : clears the content of all expressions;; 134 - ExecuteCommand : execute a ROOT command;; 135 - MakeSelector : equivalent of TTree::MakeSelector();; 136 - NewExpression : add an expression item in the right panel;; 137 - Process : equivalent of TTree::Process();; 138 - SaveSource : save the current session as a C++ macro;; 139 - SetScanFileName : define a name for the file where TTree::Scan command; 140 is redirected when the `<Scan>` button is checked;; 141 - SetTreeName : open a new tree with this name in the viewer;; 142 ; 143 A specific context menu is activated if expressions/leaves are right-clicked.; 144 ; 145 Commands are :; 146 - Draw : draw a histogram for this item;; 147 - EditExpression : pops-up the expression editor;; 148 - Empty : empty the name and alias of this item;; 149 - RemoveItem : removes clicked item from the list;; 150 - Scan : scan this expression;; 151 - SetExpression : edit name and alias for this item by hand;; 152 ; 153Starting the viewer; 154 ; 155 1. From the TBrowser: Select a tree in the TBrowser, then call the; 156 StartViewer() method from its context menu (right-click on the tree).; 157 2. From the command line: Start a ROOT session in the directory where you have; 158 your tree. You will need first to load the library for TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeViewer_8cxx_source.html:6927,clear,clears,6927,doc/master/TTreeViewer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeViewer_8cxx_source.html,1,['clear'],['clears']
Usability,"he axis, to set the min/max in z.; 3.8.2.14 The SPEC Option; The “SPEC” option offers a large set of options/attributes to visualize 2D histograms thanks to “operators” following the “SPEC” keyword. For example, to draw the 2-D histogram h2 using all default attributes except the viewing angles, one can do:; h2->Draw(""SPEC a(30,30,0)"");; The operators’ names are case insensitive (i.e. one can use “a” or “A”) and their parameters are separated by coma “,”. Operators can be put in any order in the option and must be separated by a space "" "". No space characters should be put in an operator. All the available operators are described below.; The way how a 2D histogram will be painted is controlled by two parameters: the “Display modes groups” and the “Display Modes”. “Display modes groups” can take the following values:. 0 = Simple - simple display modes using one color only; 1 = Light - the shading is carried out according to the position of the fictive light source; 2 = Height - the shading is carried out according to the channel contents; 3 = LightHeight - combination of two previous shading algorithms (one can control the weight between both algorithms). “Display modes” can take the following values:. 1 = Points; 2 = Grid; 3 = Contours; 4 = Bars; 5 = LinesX; 6 = LinesY; 7 = BarsX; 8 = BarsY; 9 = Needles; 10 = Surface; 11 = Triangles. These parameters can be set by using the “dm” operator in the option.; h2->Draw(""SPEC dm(1,2)"");; The above example draws the histogram using the “Light Display mode group” and the “Grid Display mode”. The following tables summarize all the possible combinations of both groups:. Points; Grid; Contours; Bars; LinesX; LinesY. Simple; x; x; x; x; x; x. Light; x; x. x; x. Height; x; x; x; x; x; x. LightHeight; x; x. x; x. BarsX; BarsY; Needles; Surface; Triangles. Simple; x; x; x. x. Light. x; x. Height; x; x. x; x. LightHeight. x; x. The “Pen Attributes” can be changed using pa(color,style,width). Next example sets line color to 2, line ty",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:101666,simpl,simple,101666,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"he constructor for the complete description of learning methods and parameters) ;  ; void SetEpsilon (Double_t eps);  Sets Epsilon - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEta (Double_t eta);  Sets Eta - used in stochastic minimisation (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEtaDecay (Double_t ed);  Sets EtaDecay - Eta *= EtaDecay at each epoch (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetEventWeight (const char *);  Set the event weight. ;  ; void SetLearningMethod (TMultiLayerPerceptron::ELearningMethod method);  Sets the learning method. ;  ; void SetReset (Int_t reset);  Sets number of epochs between two resets of the search direction to the steepest descent. ;  ; void SetTau (Double_t tau);  Sets Tau - used in line search (look at the constructor for the complete description of learning methods and parameters) ;  ; void SetTestDataSet (const char *test);  Sets the Test dataset. ;  ; void SetTestDataSet (TEventList *test);  Sets the Test dataset. ;  ; void SetTrainingDataSet (const char *train);  Sets the Training dataset. ;  ; void SetTrainingDataSet (TEventList *train);  Sets the Training dataset. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (Int_t nEpoch, Option_t *option=""text"", Double_t minE=0);  Train the network. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:14384,learn,learning,14384,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['learn'],['learning']
Usability,"he current Tree; static Int_tfgLearnEntriesnumber of entries used for learning mode. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22051,learn,learning,22051,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,1,['learn'],['learning']
Usability,"he deletion ot update the list itself.; 1107 ; 1108 static TObject harmless;; 1109 TObjLink *cursor = files->FirstLink();; 1110 while (cursor) {; 1111 Content *dir = static_cast<Content*>( cursor->GetObject() );; 1112 if (dir) {; 1113 // In order for the iterator to stay valid, we must; 1114 // prevent the removal of the object (dir) from the list; 1115 // (which is done in TFile::Close). We can also can not; 1116 // just move to the next iterator since the Close might; 1117 // also (indirectly) remove that file.; 1118 // So we SetObject to a harmless value, so that 'dir'; 1119 // is not seen as part of the list.; 1120 // We will later, remove all the object (see files->Clear(); 1121 cursor->SetObject(&harmless); // this must not be zero otherwise things go wrong.; 1122 // See related comment at the files->Clear(""nodelete"");; 1123 dir->Close(""nodelete"");; 1124 // Put it back; 1125 cursor->SetObject(dir);; 1126 }; 1127 cursor = cursor->Next();; 1128 };; 1129 // Now were done, clear the list but do not delete the objects as; 1130 // they have been moved to the list of closed objects and must be; 1131 // deleted from there in order to avoid a double delete from a; 1132 // use objects (on the interpreter stack).; 1133 files->Clear(""nodelete"");; 1134 }; 1135 ; 1136 static void R__ListSlowDeleteContent(TList *files); 1137 {; 1138 // Routine to delete the content of list of files using the 'slow' techniques; 1139 ; 1140 static TObject harmless;; 1141 TObjLink *cursor = files->FirstLink();; 1142 while (cursor) {; 1143 TDirectory *dir = dynamic_cast<TDirectory*>( cursor->GetObject() );; 1144 if (dir) {; 1145 // In order for the iterator to stay valid, we must; 1146 // prevent the removal of the object (dir) from the list; 1147 // (which is done in TFile::Close). We can also can not; 1148 // just move to the next iterator since the Close might; 1149 // also (indirectly) remove that file.; 1150 // So we SetObject to a harmless value, so that 'dir'; 1151 // is not seen as part o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:44026,clear,clear,44026,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['clear'],['clear']
Usability,"he entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void DirectDraw(TGLRnrCtx& rnrCtx) const. Bool_t Kee",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:8176,simpl,simply,8176,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,1,['simpl'],['simply']
Usability,"he entry.; If not cached just call DirectDraw() for normal non DL cached drawing. void DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; Draw the logical shape in highlight mode.; If lvl argument is less than 0 (-1 by default), the index into color-set; is taken from the physical shape itself. void ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); Virtual method called-back after a secondary selection hit; is recorded (see TGLViewer::HandleButton(), Ctrl-Button1).; The ptr argument holds the GL pick-record of the closest hit. This base-class implementation simply prints out the result. void InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; Invoke popup menu or our bound external TObject (if any), using passed; 'menu' object, at location 'x' 'y'. Bool_t IgnoreSizeForOfInterest() const; Return true if size of this shape should be ignored when determining if; the object should be drawn. In this base-class we simply return state of; static flag fgIgnoreSizeForCameraInterest. Several sub-classes override this virtual function. Bool_t GetIgnoreSizeForCameraInterest(); Get state of static fgIgnoreSizeForCameraInterest flag.; When this is true all objects, also very small, will be drawn by GL. void SetIgnoreSizeForCameraInterest(Bool_t isfci); Set state of static fgIgnoreSizeForCameraInterest flag. TGLLogicalShape(const TGLLogicalShape& ). TGLLogicalShape& operator=(const TGLLogicalShape& ). UInt_t Ref() const; Physical shape reference-counting, replica management. { return fRef; }. void StrongRef(Bool_t strong) const; { fRefStrong = strong; }. const TGLPhysicalShape* GetFirstPhysical() const; { return fFirstPhysical; }. TObject* ID() const; { return fExternalObj; }. TObject* GetExternal() const; { return fExternalObj; }. TGLScene* GetScene() const; { return fScene; }. void UpdateBoundingBox(); {}. UInt_t DLOffset(Short_t ) const; { return 0; }. ELODAxes SupportedLODAxes() const; { return kLODAxesNone; }. void Direc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:8627,simpl,simply,8627,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,2,['simpl'],['simply']
Usability,he filters applied ;  tdf004_cutFlowReport.pyThis tutorial shows how to get information about the efficiency of the filters applied ;  tdf005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  tdf006_ranges.C This tutorial shows how to express the concept of ranges when working with the TDataFrame ;  tdf006_ranges.py This tutorial shows how to express the concept of ranges when working with the TDataFrame ;  tdf007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ;  tdf007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the TDataFrame ;  tdf008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with TDataFrame ;  tdf008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with TDataFrame ;  tdf009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a TDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  tdf010_trivialDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf010_trivialDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf011_ROOTDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf011_ROOTDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf012_DefinesAndFiltersAsStrings.C ;  tdf012_DefinesAndFiltersAsStrings.py ;  tdf013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  tdf014_CSVDataSource.C This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf014_CSVDataSource.py This tutorial illustrates how use the TDataFrame in combination with a TDataSource ;  tdf101_h1Analysis,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:97912,simpl,simpler,97912,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simpler']
Usability,"he first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table; Note: This is a base class. If one fears it is not safe; ----- to allow ""void *"" one may potect the end-user code; providing a derived class with the appropriated type; of the parameters. void BuildSorter(TString& colName, Int_t firstRow, Int_t numberRows). BuildSorter backs TTableSorter ctor. - colName - may be followed by the square brackets with integer number inside,; if that columm is an array (for example ""phys[3]"").; NO expression inside of [], only a single integer number allowed !; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Float_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Double_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the size of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows from the ""firstRow"" by the end of table. TTableSorter(const Long_t* simpleArray, Int_t arraySize, Int_t firstRow = 0, Int_t numberRows = 0). TTableSorter ctor sort the input ""simpleArray"". - arraySize - the sie of the full array; - firstRow - the first table row to sort from (=0 by default); - numberRows - the number of the table rows to sort (=0 by default); = 0 means sort all rows fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableSorter.html:16398,simpl,simpleArray,16398,root/html528/TTableSorter.html,https://root.cern,https://root.cern/root/html528/TTableSorter.html,6,['simpl'],['simpleArray']
Usability,"he fit data Set the constant and slope a...Definition HFitInterface.cxx:267; ROOT::Fit::InitGausvoid InitGaus(const ROOT::Fit::BinData &data, TF1 *f1)compute initial parameter for gaussian function given the fit data Set the sigma limits for zero top ...Definition HFitInterface.cxx:306; ROOT::Fit::DoFillDatavoid DoFillData(BinData &dv, const TGraph *gr, BinData::ErrorType type, TF1 *func)Definition HFitInterface.cxx:576; ROOT::Fit::GetDataTypeBinData::ErrorType GetDataType(const TGraph *gr, DataOptions &fitOpt)Definition HFitInterface.cxx:476; ROOT::Fit::GetConfidenceIntervalsbool GetConfidenceIntervals(const TH1 *h1, const ROOT::Fit::FitResult &r, TGraphErrors *gr, double cl=0.95)compute confidence intervals at level cl for a fitted histogram h1 in a TGraphErrors grDefinition HFitInterface.cxx:965; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ROOT::Fit::DataOptions::fErrors1bool fErrors1use all errors equal to 1, i.e. fit without errors (default is false)Definition DataOptions.h:52; ROOT::Fit::DataOptions::fAsymErrorsbool fAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residua...Definition DataOptions.h:55; ROOT::Fit::DataOptions::fNormBinVolumebool fNormBinVolumenormalize data by a normalized the bin volume (bin volume divided by a reference value)Definition DataOptions.h:49; ROOT::Fit::DataOptions::fIntegralbool fIntegraluse integral of bin content instead of bin center (default is false)Definition DataOptions.h:47; ROOT::Fit::DataOptions::fBinVolumebool fBinVolumenormalize data by the bin volume (it is used in the Poisson likelihood fits)Definition DataOptions.h:48; ROOT::Fit::DataOptions::fCoordErrorsbool fCoordErrorsuse errors on the x coordinates when available (default is true)Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:45469,simpl,simple,45469,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['simpl'],['simple']
Usability,"he histogram along x, y or z axis.; For axis = 11, 12 or 13 returns the approximate standard error of skewness; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, skewness and its standard error are computed bin by bin. Double_t GetKurtosis(Int_t axis = 1) const; For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; Kurtosis(gaussian(0, 1)) = 0.; For axis =11, 12 or 13 returns the approximate standard error of kurtosis; of the histogram along x, y or z axis; Note, that since third and fourth moment are not calculated; at the fill time, kurtosis and its standard error are computed bin by bin. void GetStats(Double_t* stats) const; fill the array stats from the contents of this histogram; The array stats must be correctly dimensionned in the calling program.; stats[0] = sumw; stats[1] = sumw2; stats[2] = sumwx; stats[3] = sumwx2. If no axis-subrange is specified (via TAxis::SetRange), the array stats; is simply a copy of the statistics quantities computed at filling time.; If a sub-range is specified, the function recomputes these quantities; from the bin contents in the current axis range. Note that the mean value/RMS is computed using the bins in the currently; defined range (see TAxis::SetRange). By default the range includes; all bins from 1 to nbins included, excluding underflows and overflows.; To force the underflows and overflows in the computation, one must; call the static function TH1::StatOverflows(kTRUE) before filling; the histogram. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void ResetStats(); Reset the statistics including the number of entries; and replace with values calculates from bin content; The number of entries is set to the total bin content or (in case of weighted histogram); to number of effective entries. Double_t GetSumOfWeights() const; -*-*-*-*-*-*Return the sum of weights excluding under/overflows*-*-*-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:104796,simpl,simply,104796,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['simpl'],['simply']
Usability,"he hot key is an underlined character in a button label that shows the assigned keyboard mnemonic for its choice. A button that prompts more information for users has the label generally followed by ellipsis (…). As we saw the hot strings “&Draw” and “&Exit” define the text labels “Draw” and “Exit” and keyboard mnemonics Alt+D, Alt+E for their selection. The letter D and E appear underlined on the screen. All text buttons should have a unique shortcut key with the exception of OK and Cancel.; These buttons are usually placed within a window to provide fast access to frequently used or critical commands. They help in situations where a command is not available through the menu bar. You already know that a command string can be passed in the text button via the constructor:; TGTextButton(const TGWindow *p, const char *s, const char *cmd,; Int_t id, GContext_t norm, FontStruct_t font,; UInt_t options);; A button label can be changed by SetText(new_label). There are important guidelines to be followed about a button label. The text has to provide a meaningful description of the performed action. The single-word label should be used whenever possible, only two-three words for clarity, if necessary. Do not number labels. Always follow all platform presentation and usage guidelines for standard button functions. Let’s remember a few standard names and definitions of well known buttons:; OK - any changed information in a window is accepted and the window is closed;; Cancel - closes window without implementing submitted changes;; Reset- resets defaults and cancels any changed information that has not be submitted;; Apply - any changed information is accepted and again displayed in the window that remains open;; Close - closes the window;; Help - opens online Help.; Below are examples of text buttons. Note the two placement methods. The first example should be used when there are one to three command buttons; the second one when there are more than three buttons. Picture butt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1178102,guid,guidelines,1178102,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['guid'],['guidelines']
Usability,"he misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:6097,learn,learning,6097,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['learn'],['learning']
Usability,"he next are some rules to remember:. name = * means all, but don’t remove the subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465569,simpl,simple,465569,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"he nominal_hx; 1013ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1014 ; 1015// the event loop runs here, upon first access to any of the results or varied results:; 1016hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1017hx[""pt:down""].Draw(""SAME"");; 1018hx[""pt:up""].Draw(""SAME"");; 1019~~~; 1020 ; 1021A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1022as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1023this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1024to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1025""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1026 ; 1027Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1028the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; 1029calls for each variation and fill the histogram with values and cuts that depend on the variation.; 1030 ; 1031There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; 1032not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; 1033complex functors. The callable can be applied to zero or more existing columns and it will always receive their; 1034_nominal_ value in input.; 1035 ; 1036#### Varying multiple columns in lockstep; 1037 ; 1038In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; 1039""in lockstep"":; 1040 ; 1041~~~{.python}; 1042df.Vary([""pt"", ""eta""],; 1043 ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; 1044 variat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:60509,simpl,simply,60509,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"he nominal_hx; 1053ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1054 ; 1055// the event loop runs here, upon first access to any of the results or varied results:; 1056hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1057hx[""pt:down""].Draw(""SAME"");; 1058hx[""pt:up""].Draw(""SAME"");; 1059~~~; 1060 ; 1061A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1062as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1063this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1064to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1065""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1066 ; 1067Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1068the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; 1069calls for each variation and fill the histogram with values and cuts that depend on the variation.; 1070 ; 1071There is no limitation to the complexity of a Vary() expression. Just like for the Define() and Filter() calls, users are; 1072not limited to string expressions but they can also pass any valid C++ callable, including lambda functions and; 1073complex functors. The callable can be applied to zero or more existing columns and it will always receive their; 1074_nominal_ value in input.; 1075 ; 1076#### Varying multiple columns in lockstep; 1077 ; 1078In the following Python snippet we use the Vary() signature that allows varying multiple columns simultaneously or; 1079""in lockstep"":; 1080 ; 1081~~~{.python}; 1082df.Vary([""pt"", ""eta""],; 1083 ""RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}"",; 1084 variat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:62189,simpl,simply,62189,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simply']
Usability,"he number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 524 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [4/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . TTree * ; data, . TEventList * ; training, . TEventList * ; test, . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are the two TEventLists defining events to be used during the neural net training. Both the TTree and the TEventLists can be defined in the constructor, or later with the suited setter method. ; Definition at line 318 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [5/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . const char * ; weight, . TTree * ; data, . TEventList * ; training, . TEventList * ; test, . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:31610,simpl,simple,31610,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"he number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html:7347,clear,clear,7347,root/html530/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"he number of sunctions set in the class.; The number must be equal to the dimension of the functions. { return fFunctions.size(); }. void Clear(); clear list of functions. const double * X() const; return the root X values solving the system. const double * FVal() const; return the function values f(X) solving the system; i.e. they must be close to zero at the solution. const double * Dx() const; return the last step size. bool Solve(const double* x, int maxIter = 0, double absTol = 0, double relTol = 0). Find the root starting from the point X;; Use the number of iteration and tolerance if given otherwise use; default parameter values which can be defined by; the static method SetDefault... int Iterations() const; Return number of iterations. int Status() const; Return the status of last root finding. { return fStatus; }. const char * Name() const; Return the algorithm name. void SetPrintLevel(int level). set print level; level = 0 quiet (no messages print); = 1 print only the result; = 3 max debug. Print result at each iteration. { fPrintLevel = level; }. int PrintLevel() const; return the print level. { return fPrintLevel; }. void SetDefaultTolerance(double abstol, double reltol = 0); -- static methods to set configurations; set tolerance (absolute and relative); relative tolerance is only use to verify the convergence; do it is a minor parameter. void SetDefaultMaxIterations(int maxiter); set maximum number of iterations. void PrintState(ostream& os = std::cout); print iteration state. std::pair<bool,int> GetType(const char* name); return type given a name. void ClearFunctions(); clear list of functions. » Author: L. Moneta 03/2011 » Copyright (c) 2004 ROOT Foundation, CERN/PH-SFT *; » Last changed: root/mathmore:$Id: GSLMultiRootFinder.h 38726 2011-04-04 14:05:51Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__GSLMultiRootFinder.html:7347,clear,clear,7347,root/html532/ROOT__Math__GSLMultiRootFinder.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__GSLMultiRootFinder.html,1,['clear'],['clear']
Usability,"he number of times deny-destroy has been requested on the element. ;  ; Bool_t GetDestroyOnZeroRefCnt () const;  Returns state of flag determining if the element will be destroyed when reference count reaches zero. ;  ; virtual TObject * GetEditorObject (const TEveException &eh) const;  ; virtual TString GetHighlightTooltip ();  ; virtual const TGPicture * GetListTreeCheckBoxIcon ();  Returns list-tree-item check-box picture appropriate for given rendering state. ;  ; virtual Color_t GetMainColor () const;  ; Color_t * GetMainColorPtr () const;  ; virtual Char_t GetMainTransparency () const;  ; TEveElement * GetMaster ();  Returns the master element - that is: ;  ; virtual Int_t GetNItems () const;  ; Int_t GetParentIgnoreCnt () const;  Get number of parents that should be ignored in doing reference-counting. ;  ; virtual TObject * GetRenderObject (const TEveException &eh) const;  ; virtual Bool_t GetRnrAnything () const;  ; virtual Bool_t GetRnrChildren () const;  ; virtual Bool_t GetRnrSelf () const;  ; virtual Bool_t GetRnrState () const;  ; virtual UChar_t GetSelectedLevel () const;  Get selection level, needed for rendering selection and highlight feedback. ;  ; TRef & GetSource ();  ; TObject * GetSourceObject () const;  ; void * GetUserData () const;  ; TEveElement * GetVizModel () const;  ; const TString & GetVizTag () const;  ; virtual Bool_t HandleElementPaste (TEveElement *el);  React to element being pasted or dnd-ed. ;  ; Bool_t HasChild (TEveElement *el);  Check if element el is a child of this element. ;  ; Bool_t HasChildren () const;  ; virtual Bool_t HasMainColor () const;  ; virtual Bool_t HasMainTrans () const;  ; Bool_t HasParents () const;  ; virtual void HighlightElement (Bool_t state);  Set element's highlight state. Stamp appropriately. ;  ; void IncDenyDestroy ();  Increases the deny-destroy count of the element. ;  ; virtual void IncImpliedHighlighted ();  Increase element's implied-highlight count. Stamp appropriately. ;  ; virtual void I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveLine.html:13273,feedback,feedback,13273,doc/master/classTEveLine.html,https://root.cern,https://root.cern/doc/master/classTEveLine.html,7,['feedback'],['feedback']
Usability,"he remote player. Returns kFALSE. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(Bool_t savememvalues = kFALSE); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for given object ""name"". TDSetElement * GetNextPacket(TSlave* slave, TMessage* r); Get next packet (may not be used in this class). void SetupFeedback(); Set up feedback (may not be used in this class). void StopFeedback(); Stop feedback (may not be used in this class). Long64_t DrawSelect(TDSet* set, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Draw (may not be used in this class). void HandleGetTreeHeader(TMessage* mess); Handle tree header request. void HandleRecvHisto(TMessage* mess); Receive histo from slave. Int_t DrawCanvas(TObject* obj); Draw the object if it is a canvas.; Return 0 in case of success, 1 if it is not a canvas or libProofDraw; is not available. Int_t GetDrawArgs(const char* var, const char* sel, Option_t* opt, TString& selector, TString& objname); Parse the arguments from var, sel and opt and fill the selector and; object name accordingly.; Return 0 in case of success, 1 if libProofDraw is not available. void FeedBackCanvas(const char* name, Bool_t create); Create/destroy a named canvas for feedback. Long64_t GetCacheSize(); Return the size in bytes of the cache. Int_t GetLearnEntries(); Return the number of entries in the l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:20973,feedback,feedback,20973,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,2,['feedback'],['feedback']
Usability,"he screen. The global visible level put a limitation on the maximum applied depth. Combined with visibility settings per volume, these can tune quite well what should appear on the screen. However, there are situations when users want to see a volume branch displayed down to the maximum depth, keeping at the same time a limitation or even suppressing others. In order to accomplish that, one should use the volume attribute: ""Visible daughters"". By default, all daughters of all volumes are displayed if there is no limitation related with their level depth with respect to the top drawn volume. Ray Tracing; Ray tracing is a quite known drawing technique based on tracking rays from the eye position through all pixels of a view port device. The pixel color is derived from the properties of the first crossed surface, according some illumination model and material optical properties. While there are currently existing quite sophisticated ray tracing models, TGeo is currently using a very simple approach where the light source is matching the eye position (no shadows or back-tracing of the reflected ray). In future we are considering providing a base class in order to be able to derive more complex models.; Due to the fact that the number of rays that have to be tracked matches the size in pixels of the pad, the time required by this algorithm is proportional to the pad size. On the other hand, the speed is quite acceptable for the default ROOT pad size and the images produced by using this technique have high quality. Since the algorithm is practically using all navigation features, producing ray-traced pictures is also a geometry validation check. Ray tracing can be activated at volume level as the normal Draw(). Ray-traced view in a pad; myVolume->Raytrace(); Once ray-tracing a view, this can be zoomed or rotated as a usual one. Objects on the screen are no longer highlighted when picking the vertices but the corresponding volumes is still accessible.; Clipping Ray-traced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:112599,simpl,simple,112599,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['simpl'],['simple']
Usability,"he sink in a RPageSinkBuf.; 83 static std::unique_ptr<RNTupleWriter> Create(std::unique_ptr<RNTupleModel> model,; 84 std::unique_ptr<Internal::RPageSink> sink,; 85 const RNTupleWriteOptions &options);; 86 ; 87public:; 88 /// Throws an exception if the model is null.; 89 static std::unique_ptr<RNTupleWriter> Recreate(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 90 std::string_view storage,; 91 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 92 static std::unique_ptr<RNTupleWriter>; 93 Recreate(std::initializer_list<std::pair<std::string_view, std::string_view>> fields, std::string_view ntupleName,; 94 std::string_view storage, const RNTupleWriteOptions &options = RNTupleWriteOptions());; 95 /// Throws an exception if the model is null.; 96 static std::unique_ptr<RNTupleWriter> Append(std::unique_ptr<RNTupleModel> model, std::string_view ntupleName,; 97 TFile &file,; 98 const RNTupleWriteOptions &options = RNTupleWriteOptions());; 99 RNTupleWriter(const RNTupleWriter &) = delete;; 100 RNTupleWriter &operator=(const RNTupleWriter &) = delete;; 101 ~RNTupleWriter();; 102 ; 103 /// The simplest user interface if the default entry that comes with the ntuple model is used.; 104 /// \return The number of uncompressed bytes written.; 105 std::size_t Fill() { return fFillContext.Fill(fFillContext.fModel->GetDefaultEntry()); }; 106 /// Multiple entries can have been instantiated from the ntuple model. This method will perform; 107 /// a light check whether the entry comes from the ntuple's own model.; 108 /// \return The number of uncompressed bytes written.; 109 std::size_t Fill(REntry &entry) { return fFillContext.Fill(entry); }; 110 /// Fill an entry into this ntuple, but don't commit the cluster. The calling code must pass an RNTupleFillStatus; 111 /// and check RNTupleFillStatus::ShouldFlushCluster.; 112 void FillNoFlush(REntry &entry, RNTupleFillStatus &status) { fFillContext.FillNoFlush(entry, status); }; 113 /// Flush column data, pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html:4603,simpl,simplest,4603,doc/master/RNTupleWriter_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RNTupleWriter_8hxx_source.html,1,['simpl'],['simplest']
Usability,"he subdirectories; cycle =* means all cycles (memory and file); cycle ="""" means apply to a memory object; cycle = 9999 also means apply to a memory object; namecycle = """" means the same as namecycle =“T*”; namecycle = T* delete subdirectories. For example to delete a directory from a file, you must specify the directory cycle:; root[] f->Delete(""Wed011003;1""); Some other examples of namecycle format are:. foo:delete the object named foo from memory; foo;1: delete the cycle 1 of the object named foo from the file; foo;*: delete all cycles of foo from the file and also from memory; *;2: delete all objects with cycle number 2 from the file; *;*: delete all objects from memory and from the file; T*;*: delete all objects from memory and from the file including all subdirectories. 11.3 Streamers; To follow the discussion on Streamers, you need to know what a simple data type is. A variable is of a simple data type if it cannot be decomposed into other types. Examples of simple data types are longs, shorts, floats, and chars. In contrast, a variable is of a composite data type if it can be decomposed. For example, classes, structures, and arrays are composite types. Simple types are also called primitive types, basic types, and Cling sometimes calls them fundamental types.; When we say, “writing an object to a file”, we actually mean writing the current values of the data members. The most common way to do this is to decompose (also called the serialization of) the object into its data members and write them to disk. The decomposition is the job of the Streamer. Every class with ambitions to be stored in a file has a Streamerthat decomposes it and “streams” its members into a buffer.; The methods of the class are not written to the file, it contains only the persistent data members. To decompose the parent classes, the Streamercalls the Streamerof the parent classes. It moves up the inheritance tree until it reaches an ancestor without a parent. To serialize the object dat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:465643,simpl,simple,465643,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"he time offset is the one that will be used by all graphs.; // If one changes it, it will be changed even on the graphs already defined; gStyle->SetTimeOffset(script_time);; ; auto ct = new TCanvas(""ct"",""Time on axis"",10,10,700,900);; ct->Divide(1,3);; ; int i;; ; //### Build a signal: noisy damped sine; // Time interval: 30 minutes; ; gStyle->SetTitleH(0.08);; float noise;; auto ht = new TH1F(""ht"",""Love at first sight"",3000,0.,2000.);; for (i=1;i<3000;i++) {; noise = gRandom->Gaus(0,120);; if (i>700) {; noise += 1000*sin((i-700)*6.28/30)*exp((double)(700-i)/300);; }; ht->SetBinContent(i,noise);; }; ct->cd(1);; ht->SetLineColor(2);; ht->GetXaxis()->SetLabelSize(0.05);; ht->Draw();; // Sets time on the X axis; // The time used is the one set as time offset added to the value; // of the axis. This is converted into day/month/year hour:min:sec and; // a reasonable tick interval value is chosen.; ht->GetXaxis()->SetTimeDisplay(1);; ; //### Build a simple graph beginning at a different time; // Time interval: 5 seconds; ; float x[100], t[100];; for (i=0;i<100;i++) {; x[i] = sin(i*4*3.1415926/50)*exp(-(double)i/20);; t[i] = 6000+(double)i/20;; }; auto gt = new TGraph(100,t,x);; gt->SetTitle(""Politics"");; ct->cd(2);; gt->SetLineColor(5);; gt->SetLineWidth(2);; gt->Draw(""AL"");; gt->GetXaxis()->SetLabelSize(0.05);; // Sets time on the X axis; gt->GetXaxis()->SetTimeDisplay(1);; gPad->Modified();; ; //### Build a second simple graph for a very long time interval; // Time interval: a few years; ; auto gt2 = new TGraph();; TDatime dateBegin(2000,1,1,0,0,0);; for (i=0;i<10;i++) {; TDatime datePnt(2000 + i,1,1,0,0,0);; gt2->AddPoint(datePnt.Convert() - dateBegin.Convert(), 100 + gRandom->Gaus(500,100)*i);; }; gt2->SetTitle(""Number of monkeys on the moon"");; ct->cd(3);; gt2->SetMarkerColor(4);; gt2->SetMarkerStyle(29);; gt2->SetMarkerSize(1.3);; gt2->Draw(""AP"");; gt2->GetXaxis()->SetLabelSize(0.04);; gt2->GetXaxis()->SetNdivisions(10);; // Sets time on the X axis; gt2->GetXaxis()-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/timeonaxis_8C.html:2014,simpl,simple,2014,doc/master/timeonaxis_8C.html,https://root.cern,https://root.cern/doc/master/timeonaxis_8C.html,2,['simpl'],['simple']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetUseWeightedEvents(). void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff). {*this += rEff;}. Double_t GetBetaAlpha(Int_t bin = -1) const; use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEfficiency.html:65601,clear,cleared,65601,root/html532/TEfficiency.html,https://root.cern,https://root.cern/root/html532/TEfficiency.html,1,['clear'],['cleared']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetUseWeightedEvents(). void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff); {*this += rEff;}. Double_t GetBetaAlpha(Int_t bin = -1) const; use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEfficiency.html:69482,clear,cleared,69482,root/html534/TEfficiency.html,https://root.cern,https://root.cern/root/html534/TEfficiency.html,2,['clear'],['cleared']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetUseWeightedEvents(). void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff); {*this += rEff;}. void Browse(TBrowser* ); {Draw();}. Double_t Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEfficiency.html:70472,clear,cleared,70472,root/html604/TEfficiency.html,https://root.cern,https://root.cern/root/html604/TEfficiency.html,1,['clear'],['cleared']
Usability,"he titles of the internal histograms are set to ""title + (total)""; or ""title + (passed)"" respectively.; - It is possible to label the axis of the histograms as usual (see; TH1::SetTitle). Example: Setting the title to ""My Efficiency"" and label the axis. pEff->SetTitle(""My Efficiency;x label;eff"");. Bool_t SetTotalEvents(Int_t bin, Int_t events); sets the number of total events in the given global bin. returns ""true"" if the number of total events has been updated; otherwise ""false"" ist returned. Note: - requires: fPassedHistogram->GetBinContent(bin) <= events. Bool_t SetTotalHistogram(const TH1& rTotal, Option_t* opt); sets the histogram containing all events. The given histogram is cloned and stored internally as histogram containing; all events. The given histogram has to be consistent with the current; fPassedHistogram (see CheckConsistency(const TH1&,const TH1&)).; The method returns whether the fTotalHistogram has been replaced (true) or; not (false). Note: The list of associated functions fFunctions is cleared. Option: - ""f"": force the replacement without checking the consistency; This can lead to inconsistent histograms and useless results; or unexpected behaviour. But sometimes it might be the only; way to change the histograms. If you use this option, you; should ensure that the fPassedHistogram is replaced by a; consistent one (with respect to rTotal) as well. void SetWeight(Double_t weight); sets the global weight for this TEfficiency object. Note: - weight has to be positive ( > 0). Double_t Wilson(Int_t total, Int_t passed, Double_t level, Bool_t bUpper); calculates the boundaries for the frequentist Wilson interval. Input: - total : number of total events; - passed: 0 <= number of passed events <= total; - level : confidence level; - bUpper: true - upper boundary is returned; false - lower boundary is returned. calculation:. void Add(const TEfficiency& rEff). {*this += rEff;}. Double_t GetBetaAlpha(Int_t bin = -1) const; use trick of -1 to return global",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEfficiency.html:63189,clear,cleared,63189,root/html528/TEfficiency.html,https://root.cern,https://root.cern/root/html528/TEfficiency.html,2,['clear'],['cleared']
Usability,"he tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(); }. BinaryTree* Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__BinarySearchTree.html:6515,clear,clear,6515,root/html528/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html528/TMVA__BinarySearchTree.html,2,['clear'],['clear']
Usability,"he tree to find the node matching ""event"". TMVA::BinarySearchTreeNode* Search(TMVA::Event* , TMVA::Node* ) const; Private, recursive, function for searching. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t GetSumOfWeights(Int_t theType) const; return the sum of event (node) weights. Double_t Fill(const vector<TMVA::Event*>& events, const vector<Int_t>& theVars, Int_t theType = -1); create the search tree from the event collection; using ONLY the variables specified in ""theVars"". Double_t Fill(const vector<TMVA::Event*>& events, Int_t theType = -1); create the search tree from the events in a TTree; using ALL the variables specified included in the Event. void NormalizeTree(vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , vector<pair<double,const TMVA::Event*>,allocator<pair<double,const TMVA::Event*> > >::iterator , UInt_t ). void NormalizeTree(); Normalisation of tree. void Clear(TMVA::Node* n = 0); clear nodes. Double_t SearchVolume(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0); search the whole tree and add up all weigths of events that; lie within the given voluem. Double_t SearchVolume(TMVA::Node* , TMVA::Volume* , Int_t , vector<const TMVA::BinarySearchTreeNode*>* events); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume. Bool_t InVolume(const vector<Float_t>& , TMVA::Volume* ) const; test if the data points are in the given volume. void CalcStatistics(TMVA::Node* n = 0, Int_t signalClass = 0); calculate basic statistics (mean, rms for each variable). Int_t SearchVolumeWithMaxLimit(TMVA::Volume* , vector<const TMVA::BinarySearchTreeNode*>* events = 0, Int_t = -1); recursively walk through the daughter nodes and add up all weigths of events that; lie within the given volume a maximum number of events can be given. Node * CreateNode(UInt_t ) const; { return new BinarySearchTreeNode(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__BinarySearchTree.html:6538,clear,clear,6538,root/html530/TMVA__BinarySearchTree.html,https://root.cern,https://root.cern/root/html530/TMVA__BinarySearchTree.html,2,['clear'],['clear']
Usability,"he type of the rule. ; Definition at line 764 of file TSchemaRule.cxx. ◆ GetSource(). const TObjArray * TSchemaRule::GetSource ; (; ); const. Get the list of source members as a TObjArray of TNamed object, with the name being the member name and the title being its type. ; Definition at line 560 of file TSchemaRule.cxx. ◆ GetSourceClass(). const char * TSchemaRule::GetSourceClass ; (; ); const. Get the source class of this rule (i.e. the onfile class). ; Definition at line 466 of file TSchemaRule.cxx. ◆ GetTarget(). const TObjArray * TSchemaRule::GetTarget ; (; ); const. Get the target data members of this rule (i.e. the in memory data member). ; Definition at line 520 of file TSchemaRule.cxx. ◆ GetTargetClass(). const char * TSchemaRule::GetTargetClass ; (; ); const. Get the targte class of this rule (i.e. the in memory class). ; Definition at line 484 of file TSchemaRule.cxx. ◆ GetTargetString(). const char * TSchemaRule::GetTargetString ; (; ); const. Get the target data members of this rule as a simple string (i.e. the in memory data member). ; Definition at line 512 of file TSchemaRule.cxx. ◆ GetVersion(). const char * TSchemaRule::GetVersion ; (; ); const. Get the version string. ; Definition at line 393 of file TSchemaRule.cxx. ◆ HasSource(). Bool_t TSchemaRule::HasSource ; (; const TString & ; source); const. Return true if one of the rule's data member source is 'source'. ; Definition at line 690 of file TSchemaRule.cxx. ◆ HasTarget(). Bool_t TSchemaRule::HasTarget ; (; const TString & ; target); const. Return true if one of the rule's data member target is 'target'. ; Definition at line 672 of file TSchemaRule.cxx. ◆ IsA(). TClass * ROOT::TSchemaRule::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 120 of file TSchemaRule.h. ◆ IsAliasRule(). Bool_t TSchemaRule::IsAliasRule ; (; ); const. Return kTRUE if the rule is a strict renaming of one of the data member of the class. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html:20667,simpl,simple,20667,doc/v632/classROOT_1_1TSchemaRule.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TSchemaRule.html,2,['simpl'],['simple']
Usability,"heManager<RooAbsCacheElement>::wireCache(). Data Members; protected:. Bool_t_allowOptimize; static Bool_t_clearObsListClear obslist on sterilize?; Bool_t_clearOnRedirect; Int_tRooCacheManager<RooAbsCacheElement>::_lastIndex! Last slot accessed; Int_tRooCacheManager<RooAbsCacheElement>::_maxSize! Maximum size; vector<RooNormSetCache>RooCacheManager<RooAbsCacheElement>::_nsetCache! Normalization/Integration set manager; vector<RooAbsCacheElement*>RooCacheManager<RooAbsCacheElement>::_object! Payload; Bool_t_optCacheModeSeen!; RooArgSet*_optCacheObservables! current optCacheObservables; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_size! Actual use; Bool_tRooCacheManager<RooAbsCacheElement>::_wired! In wired mode, there is a single payload which is returned always. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooObjCacheManager.html:4115,clear,clearCacheOnServerRedirect,4115,root/html602/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html602/RooObjCacheManager.html,2,['clear'],['clearCacheOnServerRedirect']
Usability,"heck if name is in the list of Tree/Branch leaves. ; This member function redefines the function in ROOT::v5::TFormula If a leaf has a name corresponding to the argument name, then returns a new code.; A TTreeFormula may contain more than one variable. For each variable referenced, the pointers to the corresponding branch and leaf is stored in the object arrays fBranches and fLeaves.; name can be :; Leaf_Name (simple variable or data member of a ClonesArray); Branch_Name.Leaf_Name; Branch_Name.Method_Name; Leaf_Name[index]; Branch_Name.Leaf_Name[index]; Branch_Name.Leaf_Name[index1]; Branch_Name.Leaf_Name[][index2]; Branch_Name.Leaf_Name[index1][index2]. New additions:; Branch_Name.Leaf_Name[OtherLeaf_Name]; Branch_Name.Datamember_Name; '.' can be replaced by '->'; and. Branch_Name[index1].Leaf_Name[index2]; Leaf_name[index].Action().OtherAction(param); Leaf_name[index].Action()[val].OtherAction(param). The expected returned values are; -2 : the name has been recognized but won't be usable; -1 : the name has not been recognized, or is too long, or tree does not exist.; >=0 : the name has been recognized, return the internal code for this name. . Reimplemented from ROOT::v5::TFormula.; Definition at line 2698 of file TTreeFormula.cxx. ◆ EvalClass() [1/2]. TClass * TTreeFormula::EvalClass ; (; ); const. virtual . Evaluate the class of this treeformula. ; If the 'value' of this formula is a simple pointer to an object, this function returns the TClass corresponding to its type. ; Definition at line 3597 of file TTreeFormula.cxx. ◆ EvalClass() [2/2]. TClass * TTreeFormula::EvalClass ; (; Int_t ; oper); const. protectedvirtual . Evaluate the class of the operation oper. ; If the 'value' in the requested operation is a simple pointer to an object, this function returns the TClass corresponding to its type. ; Definition at line 3610 of file TTreeFormula.cxx. ◆ EvalInstance() [1/2]. template<typename T > . T TTreeFormula::EvalInstance ; (; Int_t ; instance = 0, . const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:36343,usab,usable,36343,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,1,['usab'],['usable']
Usability,"heckMemUsage ; (; Long64_t & ; mfreq, . Bool_t & ; w80r, . Bool_t & ; w80v, . TString & ; wmsg . ). protected . Check the memory usage, if requested. ; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or resident limits are depassed. ; Definition at line 1512 of file TProofPlayer.cxx. ◆ Class(). static TClass * TProofPlayer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TProofPlayer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TProofPlayer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 228 of file TProofPlayer.h. ◆ ClearInput(). void TProofPlayer::ClearInput ; (; ). overridevirtual . Clear input list. ; Implements TVirtualProofPlayer.; Definition at line 468 of file TProofPlayer.cxx. ◆ CreateDrawFeedback(). TDrawFeedback * TProofPlayer::CreateDrawFeedback ; (; TProof * ; p). overridevirtual . Draw feedback creation proxy. ; When accessed via TProof avoids link dependency on libProofPlayer. ; Implements TVirtualProofPlayer.; Definition at line 733 of file TProofPlayer.cxx. ◆ DeclFileName(). static const char * TProofPlayer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 228 of file TProofPlayer.h. ◆ DeleteDrawFeedback(). void TProofPlayer::DeleteDrawFeedback ; (; TDrawFeedback * ; f). overridevirtual . Delete draw feedback object. ; Implements TVirtualProofPlayer.; Definition at line 750 of file TProofPlayer.cxx. ◆ DrawCanvas(). Int_t TProofPlayer::DrawCanvas ; (; TObject * ; obj). protectedvirtual . Draw the object if it is a canvas. ; Return 0 in case of success, 1 if it is not a canvas or libProofDraw is not available. ; Definition at line 1696 of file TProofPlayer.cxx. ◆ DrawSelect(). Long64_t TProofPlayer::DrawSelect ; (; TDSet * ; set, . const char * ; varexp, . const char * ; selection, . Option_t * ; option = """", .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:27087,feedback,feedback,27087,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['feedback'],['feedback']
Usability,"heckObject(UInt_t offset, const TClass* cl, Bool_t readClass = kFALSE); voidCheckVersionBuf(); voidCreateElemNode(const TStreamerElement* elem); XMLNodePointer_tCreateItemNode(const char* name); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Bool_tExtractPointer(XMLNodePointer_t node, void*& ptr, TClass*& cl); voidExtractReference(XMLNodePointer_t node, const void* ptr, const TClass* cl); Int_tGetCompressionAlgorithm() const; Int_tGetCompressionLevel() const; Int_tGetCompressionSettings() const; const char*TXMLSetup::GetElItemName(TStreamerElement* el); Bool_tTXMLSetup::IsValidXmlSetup(const char* setupstr); voidTObject::MakeZombie(); voidTBufferFile::operator=(const TBufferFile&); voidPerformPostProcessing(); voidPerformPreProcessing(const TStreamerElement* elem, XMLNodePointer_t elemnode); TXMLStackObj*PopStack(); Bool_tProcessPointer(const void* ptr, XMLNodePointer_t node); TXMLStackObj*PushStack(XMLNodePointer_t current, Bool_t simple = kFALSE); virtual Int_tTBuffer::Read(const char* name); Bool_tTXMLSetup::ReadSetupFromStr(const char* setupstr); voidRegisterPointer(const void* ptr, XMLNodePointer_t node); voidSetCompressionAlgorithm(Int_t algorithm = 0); voidSetCompressionLevel(Int_t level = 1); voidSetCompressionSettings(Int_t settings = 1); voidSetXML(TXMLEngine* xml); voidShiftStack(const char* info = 0); TXMLStackObj*Stack(Int_t depth = 0); XMLNodePointer_tStackNode(); Bool_tVerifyAttr(XMLNodePointer_t node, const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyElemNode(const TStreamerElement* elem); Bool_tVerifyItemNode(const char* name, const char* errinfo = 0); Bool_tVerifyNode(XMLNodePointer_t node, const char* name, const char* errinfo = 0); Bool_tVerifyStackAttr(const char* name, const char* value, const char* errinfo = 0); Bool_tVerifyStackNode(const char* name, const char* errinfo = 0); voidWorkWithClass(TStreamerInfo* info, const TClass* cl = 0); voidWorkWithElement(TStreamerEle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TBufferXML.html:19134,simpl,simple,19134,root/html530/TBufferXML.html,https://root.cern,https://root.cern/root/html530/TBufferXML.html,3,['simpl'],['simple']
Usability,"hed covariance matrix (NxN); shared_ptr<ROOT::Fit::FitData>fFitData! data of the fit; shared_ptr<ROOT::Fit::Fitter>fFitter! pointer to fitter object; ROOT::Math::Minimizer*fMinimizer; ROOT::Math::IParamMultiFunction*fModelFunc; ROOT::Math::IMultiGenFunction*fObjFunc. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBackCompFitter(); Constructur needed by TVirtualFitter interface. Same behavior as default constructor.; initialize setting name and the global pointer. TBackCompFitter(const shared_ptr<ROOT::Fit::Fitter>& fitter, const shared_ptr<ROOT::Fit::FitData>& data); constructor used after having fit using directly ROOT::Fit::Fitter; will create a dummy fitter copying configuration and parameter settings. ~TBackCompFitter(); destructor - delete the managed objects. Double_t Chisquare(Int_t npar, Double_t* params) const; do chisquare calculations in case of likelihood fits; do evaluation a the minimum only. void Clear(Option_t* option = """"); clear resources for consecutive fits. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); execute the command (Fortran Minuit compatible interface). bool ValidParameterIndex(int ipar) const; check if ipar is a valid parameter index. void FixParameter(Int_t ipar); fix the paramter; std::cout<<""FixParameter""<<std::endl;. void GetConfidenceIntervals(Int_t n, Int_t ndim, const Double_t* x, Double_t* ci, Double_t cl = 0.94999999999999996); Computes point-by-point confidence intervals for the fitted function; Parameters:; n - number of points; ndim - dimensions of points; x - points, at which to compute the intervals, for ndim > 1; should be in order: (x0,y0, x1, y1, ... xn, yn); ci - computed intervals are returned in this array; cl - confidence level, default=0.95; NOTE, that the intervals are approximate for nonlinear(in parameters) models. void GetConfidenceIntervals(TObject* obj, Double_t cl = 0.94999999999999996); Computes confidence intervals at level cl. Default is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBackCompFitter.html:13381,clear,clear,13381,root/html604/TBackCompFitter.html,https://root.cern,https://root.cern/root/html604/TBackCompFitter.html,1,['clear'],['clear']
Usability,"hen used to display the final difference between background and signal events. The figure “The neural net output” shows this plot. The neural net output. As it can be seen, this is a quite efficient technique. As mentioned earlier, neural networks are also used for fitting function. For some application with a cylindrical symmetry, a magnetic field simulation gives as output the angular component of the potential vector A, as well as the radial and z components of the B field.; One wants to fit those distributions with a function in order to plug them into the Geant simulation code. Polynomial fits could be tried, but it seems difficult to reach the desired precision over the full range. One could also use a spline interpolation between known points. In all cases, the resulting field would not be C-infinite.; An example of output (for Br) is shown. First the initial function can be seen as the target. Then, the resulting (normalized) neural net output. In order to ease the learning, the “normalize output” was used here. The initial amplitude can be recovered by multiplying by the original RMS and then shifting by the original mean. The original and the neural net for Br. 6 A Little C++. This chapter introduces you to some useful insights into C++, to allow you to use some of the most advanced features in ROOT. It is in no case a full course in C++.; 6.1 Classes, Methods and Constructors; C++ extends C with the notion of a class. If you’re used to structures in C, a class is a struct that is a group of related variables, which is extended with functions and routines specific to this structure (class). What is the interest? Consider a struct that is defined this way:; struct Line {; float x1;; float y1;; float x2;; float y2;; }; This structure represents a line to be drawn in a graphical window. (x1,y1) are the coordinates of the first point, (x2,y2) the coordinates of the second point. In the standard C, if you want to draw effectively such a line, you first have to d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:241395,learn,learning,241395,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['learn'],['learning']
Usability,"her with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0). Long64_t GetEntries() const; { return fEntries; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetReadCalls() const; { return fReadCalls; }. Double_t GetLearnTime() const; { return fLearnTime; }. Double_t GetProcTime() const; { return fProcTime; }. Double_t GetCPUTime() const; { return fCPUTime; }. Double_t GetLastUpdate() const; { return fLastUpdate; }. Double_t GetRate() const; { return ((fProcTime > 0) ? fEntries/fProcTime : 0); }. void SetLastEntries(Long64_t entries); { fLastEntries = entries; }. void SetEntries(Long64_t entries); { fEntries = entries; }. void IncEntries(Long64_t entries = 1); { fLastEntries = entries; fEntries += entries; }. void IncBytesRead(Long64_t bytesRead); { fBytesRead += bytesRead; }. void SetBytesRead(Long64_t bytesRead); { fBytesRead = bytesRead; }. void IncReadCalls(Long64_t readCalls); { fReadCalls += readCalls; }. void SetReadCalls(Long64_t readCalls); { fReadCalls = readCalls; }. void SetLearnTime(Double_t learnTime); { fLearnTime = learnTime; }. void SetLastProcTime(Double_t procTime); { fLastProcTime = procTime; }. void SetProcTime(Double_t procTime); { fProcTime = procTime; }. void IncProcTime(Double_t procTime); { fLastProcTime = procTime; fProcTime += procTime; }. void SetCPUTime(Double_t procTime); { fCPUTime = procTime; }. void IncCPUTime(Double_t procTime); { fCPUTime += procTime; }. » Author: Jan Iwaszkiewicz 08/08/08 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofProgressStatus.html:8595,learn,learnTime,8595,root/html534/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html534/TProofProgressStatus.html,2,['learn'],['learnTime']
Usability,"her with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0). Long64_t GetEntries() const; { return fEntries; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetReadCalls() const; { return fReadCalls; }. Double_t GetLearnTime() const; { return fLearnTime; }. Double_t GetProcTime() const; { return fProcTime; }. Double_t GetCPUTime() const; { return fCPUTime; }. Double_t GetLastUpdate() const; { return fLastUpdate; }. Double_t GetRate() const; { return ((fProcTime > 0) ? fEntries/fProcTime : 0); }. void SetLastEntries(Long64_t entries); { fLastEntries = entries; }. void SetEntries(Long64_t entries); { fEntries = entries; }. void IncEntries(Long64_t entries = 1); { fLastEntries = entries; fEntries += entries; }. void IncBytesRead(Long64_t bytesRead); { fBytesRead += bytesRead; }. void SetBytesRead(Long64_t bytesRead); { fBytesRead = bytesRead; }. void IncReadCalls(Long64_t readCalls); { fReadCalls += readCalls; }. void SetReadCalls(Long64_t readCalls); { fReadCalls = readCalls; }. void SetLearnTime(Double_t learnTime); { fLearnTime = learnTime; }. void SetLastProcTime(Double_t procTime); { fLastProcTime = procTime; }. void SetProcTime(Double_t procTime); { fProcTime = procTime; }. void IncProcTime(Double_t procTime); { fLastProcTime = procTime; fProcTime += procTime; }. void SetCPUTime(Double_t procTime); { fCPUTime = procTime; }. void IncCPUTime(Double_t procTime); { fCPUTime += procTime; }. » Author: Jan Iwaszkiewicz 08/08/08 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-02 16:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofProgressStatus.html:9222,learn,learnTime,9222,root/html604/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html604/TProofProgressStatus.html,2,['learn'],['learnTime']
Usability,"her with the passed value (if > 0) or with; the current time. Double_t GetCurrentRate() const; Get current rate. Rteunr the average rate if the current is not defined. TProofProgressStatus(Long64_t fEntries = 0, Long64_t fBytesRead = 0, Long64_t fReadCalls = 0, Double_t fProcTime = 0, Double_t fCPUTime = 0). Long64_t GetEntries() const; { return fEntries; }. Long64_t GetBytesRead() const; { return fBytesRead; }. Long64_t GetReadCalls() const; { return fReadCalls; }. Double_t GetLearnTime() const; { return fLearnTime; }. Double_t GetProcTime() const; { return fProcTime; }. Double_t GetCPUTime() const; { return fCPUTime; }. Double_t GetLastUpdate() const; { return fLastUpdate; }. Double_t GetRate() const; { return ((fProcTime > 0) ? fEntries/fProcTime : 0); }. void SetLastEntries(Long64_t entries); { fLastEntries = entries; }. void SetEntries(Long64_t entries); { fEntries = entries; }. void IncEntries(Long64_t entries = 1); { fLastEntries = entries; fEntries += entries; }. void IncBytesRead(Long64_t bytesRead); { fBytesRead += bytesRead; }. void SetBytesRead(Long64_t bytesRead); { fBytesRead = bytesRead; }. void IncReadCalls(Long64_t readCalls); { fReadCalls += readCalls; }. void SetReadCalls(Long64_t readCalls); { fReadCalls = readCalls; }. void SetLearnTime(Double_t learnTime); { fLearnTime = learnTime; }. void SetLastProcTime(Double_t procTime); { fLastProcTime = procTime; }. void SetProcTime(Double_t procTime); { fProcTime = procTime; }. void IncProcTime(Double_t procTime); { fLastProcTime = procTime; fProcTime += procTime; }. void SetCPUTime(Double_t procTime); { fCPUTime = procTime; }. void IncCPUTime(Double_t procTime); { fCPUTime += procTime; }. » Author: Jan Iwaszkiewicz 08/08/08 » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-06-30 15:28; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofProgressStatus.html:9222,learn,learnTime,9222,root/html602/TProofProgressStatus.html,https://root.cern,https://root.cern/root/html602/TProofProgressStatus.html,2,['learn'],['learnTime']
Usability,"her. They interact and allow method calls of other object’s methods. The idea is simple: any object can send out (emit) a signal in certain situations saying that something happened. This is all it does to communicate and it does not know whether anything is interested in this information. On the other side there might be an object waiting for that signal and ready to react to it. This object disposes of special instruments to listen to the sent out signals. To have a communication we need a message transmission between the objects. In this simple example we use signals and slots. The code of the method TGButton::Clicked() is:; virtual void Clicked() { Emit(""Clicked()""); } // *SIGNAL*; I.e. any button emits the signal Clicked() any time someone clicks on it. As you can see this method is virtual and could be overridden if you need to. In our simple example we call the Connect() method to connect the Clicked() signal of Draw button with MyMainFrame::DoDraw():; draw->Connect(""Clicked()"",""MyMainFrame"",this,""DoDraw()"");; In the same way we can connect to the signal Clicked() of the Exit button with the system call gApplication->Terminate(0). We declare a new slot DoExit(), implement it to invoke the termination call and associate this slot with the signal Clicked() of the Exit button.; The code of example.C can be changed as follows:; public:; ...; void DoExit(); // a new slot is added; }; void MyMainFrame::DoExit() {; gApplication->Terminate(0);; }; MyMainFrame::MyMainFrame(const TGWindow *p,UInt_t w,UInt_t h) {; ...; TGTextButton *exit = new TGTextButton(hframe,""&Exit "");; // connects signal Clicked() with slot DoExit(); exit->Connect(""Clicked()"",""MyMainFrame"",this,""DoExit()"");; ...; }; Here is an abstract view of the signal/slots connections in example.C:. To benefit from this mechanism your classes must inherit from TQObject or otherwise the class definition must start with RQ_OBJECT(""ClassName"")macro. This macro allows the signals/slots communication mechanism to be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164378,simpl,simple,1164378,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"hether the event has passed the selection (true) or not (false). It should perform ""read-only"" operations on the columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column names are used as variable names (e.g. Filter(""x[0] + x[1] > 0"")). This is a convenience feature that comes with a certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event loop. See the paragraph about ""Just-in-time compilation"" below for more information.; RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed in order and the first one returning false causes the event to be discarded and triggers the processing of the next entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for each entry: after the first access it simply serves a cached result.; Named filters and cutflow reports; An optional string parameter name can be passed to the Filter() method to create a named filter. Named filters work as usual, but also keep track of how many entries they accept and reject.; Statistics are retrieved through a call to the Report() method:. when Report() is called on the main RDataFrame object, it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative to all named filters declared up to that point; when called on a specific node (e.g. the result of a Define() or Filter()), it returns a ROOT::RDF::RResultPtr<RCutFlowReport> relative all named filters in the section of the chain between the main RDataFrame and that node (included). Stats are stored in the same order as named filters have been added to the graph, and refer to the latest event-loop that has been run using the relevant RDataFrame. Ranges; When RDataFrame is not being used in a mult",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:28370,simpl,simply,28370,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simply']
Usability,"hi2Sys(); Bool_tGetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); Bool_tGetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); voidTUnfold::GetEmatrix(TH2* ematrix, const Int_t* binMap = 0) const; voidGetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysBackgroundUncorr(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixSysUncorr(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); voidGetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); Double_tTUnfold::GetEpsMatrix() const; voidTUnfold::GetFoldedOutput(TH1* folded, const Int_t* binMap = 0) const; virtual const char*TObject::GetIconName() const; voidTUnfold::GetInput(TH1* inputData, const Int_t* binMap = 0) const; voidTUnfold::GetInputInverseEmatrix(TH2* ematrix); voidTUnfold::GetL(TH2* l) const; virtual Double_tTUnfold::GetLcurveX() const; virtual Double_tTUnfold::GetLcurveY() const; voidTUnfold::GetLsquared(TH2* lsquared) const; virtual const char*TObject::GetName() const; Int_tTUnfold::GetNdf() const; voidTUnfold::GetNormalisationVector(TH1* s, const Int_t* binMap = 0) const; Int_tTUnfold::GetNpar() const; Int_tTUnfold::GetNr() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; voidTUnfold::GetOutput(TH1* output, const Int_t* binMap = 0) const; voidTUnfold::GetProbabilityMatrix(TH2* A, TUnf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:6454,clear,clearEmat,6454,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,3,['clear'],['clearEmat']
Usability,"hich has to be used for starting dialog. ;  . Private Attributes; std::thread::id fCallbacksThrdId;  ! thread id where callbacks should be invoked ;  ; bool fCallbacksThrdIdSet {false};  ! flag indicating that thread id is assigned ;  ; std::shared_ptr< void > fClearOnClose;  ! entry which is cleared when last connection is closed ;  ; std::string fClientVersion;  ! configured client version, used as prefix in scripts URL ;  ; ConnectionsList_t fConn;  ! list of all accepted connections ;  ; WebWindowConnectCallback_t fConnCallback;  ! callback for connect event ;  ; unsigned fConnCnt {0};  ! counter of new connections to assign ids ;  ; unsigned fConnLimit {1};  ! number of allowed active connections ;  ; std::mutex fConnMutex;  ! mutex used to protect connection list ;  ; std::string fConnToken;  ! value of ""token"" URL parameter which should be provided for connecting window ;  ; WebWindowDataCallback_t fDataCallback;  ! main callback when data over channel 1 is arrived ;  ; std::string fDefaultPage;  ! HTML page (or file name) returned when window URL is opened ;  ; WebWindowConnectCallback_t fDisconnCallback;  ! callback for disconnect event ;  ; bool fHasWindowThrd {false};  ! indicate if special window thread was started ;  ; unsigned fHeight {0};  ! initial window width and height when displayed, zeros are ignored ;  ; unsigned fId {0};  ! unique identifier ;  ; std::queue< QueueEntry > fInputQueue;  ! input queue for all callbacks ;  ; std::mutex fInputQueueMutex;  ! mutex to protect input queue ;  ; std::shared_ptr< RWebWindow > fMaster;  ! master window where this window is embedded ;  ; std::vector< MasterConn > fMasterConns;  ! master connections ;  ; unsigned fMaxQueueLength {10};  ! maximal number of queue entries ;  ; std::shared_ptr< RWebWindowsManager > fMgr;  ! display manager ;  ; bool fNativeOnlyConn {false};  ! only native connection are allowed, created by Show() method ;  ; float fOperationTmout {50.};  ! timeout in seconds to perform synchrono",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:18160,clear,cleared,18160,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['clear'],['cleared']
Usability,"hifts of each source). unfold.GetDeltaSysBackgroundScale(bgr1shifts,""bgr1"");; unfold.GetDeltaSysBackgroundScale(bgr2shifts,""bgr2"");; unfold.GetDeltaSysSource(sys1shifts,""syserror1"");; unfold.GetDeltaSysSource(sys2shifts,""syserror2"");. retreive errors from uncorrelated sources; In the example, there are four sources of uncorrelated error; * the input vector (statistical errors of the data); * the input matrix histA (Monte Carlo statistical errors); * the errors on bgr1 (Monte Carlo statistical errors); * the errors on bgr2 (Monte Carlo statistical errors); These errors are returned as error matrices. unfold.GetEmatrixInput(stat_error);; unfold.GetEmatrixSysUncorr(uncorr_sys);; unfold.GetEmatrixSysBackgroundUncorr(bgr1uncorr,""bgr1"");; unfold.GetEmatrixSysBackgroundUncorr(bgr2uncorr,""bgr2"");. Error matrices can be added to existing histograms.; This is useful to retreive the sum of several error matrices.; If the last argument of the .GetEmatrixXXX methods is set to kFALSE, the; histogram is not cleared, but the error matrix is simply added.; Example: add all errors from background subtraction. unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr1"",0,kTRUE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr1"",0,kFALSE);; unfold.GetEmatrixSysBackgroundUncorr(bgrerror,""bgr2"",0,kFALSE);; unfold.GetEmatrixSysBackgroundCorr(bgrerror,""bgr2"",0,kFALSE);. There is a special function to get the total error:; unfold.GetEmatrixTotal(err_total);. Function Members (Methods); public:. TUnfoldSys(const TUnfoldSys&); TUnfoldSys(const TH2* hist_A, TUnfold::EHistMap histmap, TUnfold::ERegMode regmode = kRegModeSize, TUnfold::EConstraint constraint = kEConstraintNone); virtual~TUnfoldSys(); voidTObject::AbstractMethod(const char* method) const; voidAddSysError(const TH2* sysError, const char* name, TUnfold::EHistMap histmap, TUnfoldSys::ESysErrMode mode); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:5065,clear,cleared,5065,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,6,"['clear', 'simpl']","['cleared', 'simply']"
Usability,"hing...; No Matches. List of all members |; Public Types |; Public Member Functions |; Private Member Functions |; Private Attributes |; List of all members ; ROOT::TMetaUtils::TClingLookupHelper Class Reference. . Definition at line 160 of file TClingUtils.h. Public Types; typedef bool(* AutoParse_t) (const char *name);  ; typedef bool(* ExistingTypeCheck_t) (const std::string &tname, std::string &result);  . Public Member Functions;  TClingLookupHelper (cling::Interpreter &interpreter, TNormalizedCtxt &normCtxt, ExistingTypeCheck_t existingTypeCheck, AutoParse_t autoParse, bool *shuttingDownPtr, const int *pgDebug=nullptr);  ; virtual ~TClingLookupHelper ();  ; bool ExistingTypeCheck (const std::string &tname, std::string &result) override;  Helper routine to ry hard to avoid looking up in the Cling database as this could enduce an unwanted autoparsing. ;  ; void GetPartiallyDesugaredName (std::string &nameLong) override;  ; bool GetPartiallyDesugaredNameWithScopeHandling (const std::string &tname, std::string &result, bool dropstd=true) override;  We assume that we have a simple type: [const] typename[*&][const]. ;  ; bool IsAlreadyPartiallyDesugaredName (const std::string &nondef, const std::string &nameLong) override;  ; bool IsDeclaredScope (const std::string &base, bool &isInlined) override;  ; void ShuttingDownSignal () override;  ;  Public Member Functions inherited from TClassEdit::TInterpreterLookupHelper;  TInterpreterLookupHelper ();  ; virtual ~TInterpreterLookupHelper ();  . Private Member Functions; bool WantDiags () const;  . Private Attributes; AutoParse_t fAutoParse;  ; ExistingTypeCheck_t fExistingTypeCheck;  ; cling::Interpreter * fInterpreter;  ; bool * fInterpreterIsShuttingDownPtr;  ; TNormalizedCtxt * fNormalizedCtxt;  ; const int * fPDebug;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/core/clingutils/res/TClingUtils.h>. Inheritance diagram for ROOT::TMetaUtils::TClingLookupHelper:. This browser is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html:1214,simpl,simple,1214,doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TMetaUtils_1_1TClingLookupHelper.html,1,['simpl'],['simple']
Usability,"his class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Int_t SavePartialResults(Bool_t queryend = kFALSE, Bool_t force = kFALSE); Save the partial results of this query to a dedicated file under the user; data directory. The file name has the form; <session_tag>.q<query_seq_num>.root; The file pat and the file are created if not existing already.; Only objects in the outputlist not being TProofOutputFile are saved.; The packets list 'packets' is saved if given.; Trees not attached to any file are attached to the open file.; If 'queryend' is kTRUE evrything is written out (TTrees included).; The actual saving action is controlled by 'force' and by fSavePartialResults; fSaveResultsPerPacket:. fSavePartialResults = kFALSE/kTRUE no-saving/saving; fSaveResultsPerPacket = kFALSE/kTRUE save-per-query/save-per-packet. The function CheckMemUsage sets fSavePartialResults = 1 if fSaveMemThreshold > 0 and; ProcInfo_t::fMemResident >= fSaveMemThreshold: from that point on partial results; are always saved and expens",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofPlayer.html:17841,feedback,feedback,17841,root/html534/TProofPlayer.html,https://root.cern,https://root.cern/root/html534/TProofPlayer.html,3,['feedback'],['feedback']
Usability,"his class). void AddOutput(TList* out); Incorporate output list (may not be used in this class). void StoreOutput(TList* out); Store output list (may not be used in this class). void StoreFeedback(TObject* slave, TList* out); Store feedback list (may not be used in this class). void Progress(Long64_t total, Long64_t processed); Report progress (may not be used in this class). void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Report progress (may not be used in this class). void Progress(TProofProgressInfo* pi); Report progress (may not be used in this class). void Feedback(TList* objs); Set feedback list (may not be used in this class). TDrawFeedback * CreateDrawFeedback(TProof* p); Draw feedback creation proxy. When accessed via TProof avoids; link dependency on libProofPlayer. void SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); Set draw feedback option. void DeleteDrawFeedback(TDrawFeedback* f); Delete draw feedback object. Long64_t Process(TDSet* set, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process specified TDSet on PROOF worker.; The return value is -1 in case of error and TSelector::GetStatus(); in case of success. Bool_t CheckMemUsage(Long64_t& mfreq, Bool_t& w80r, Bool_t& w80v, TString& wmsg); Check the memory usage, if requested.; Return kTRUE if OK, kFALSE if above 95% of at least one between virtual or; resident limits are depassed. Long64_t Finalize(Bool_t force = kFALSE, Bool_t sync = kFALSE); Finalize query (may not be used in this class). Long64_t Finalize(TQueryResult* qr); Finalize query (may not be used in this class). void MergeOutput(); Merge output (may not be used in this class). void MapOutputListToDataMembers() const. void UpdateAutoBin(const char* name, Double_t& xmin, Double_t& xmax, Double_t& ymin, Double_t& ymax, Double_t& zmin, Double_t& zmax); Update automatic binning parameters for give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofPlayer.html:16482,feedback,feedback,16482,root/html528/TProofPlayer.html,https://root.cern,https://root.cern/root/html528/TProofPlayer.html,3,['feedback'],['feedback']
Usability,"his complication is to use template functions and/or C++14 auto return types: template <typename RDF>; auto ApplySomeFilters(RDF df); {; return df.Filter(""x > 0"").Filter([](int y) { return y < 0; }, {""y""});; }; A possibly simpler, C++11-compatible alternative is to take advantage of the fact that any dataframe node can be converted (implicitly or via an explicit cast) to the common type ROOT::RDF::RNode: // a function that conditionally adds a Range to an RDataFrame node.; RNode MaybeAddRange(RNode df, bool mustAddRange); {; return mustAddRange ? df.Range(1) : df;; }; // use as :; ROOT::RDataFrame df(10);; auto maybeRangedDF = MaybeAddRange(df, true);; The conversion to ROOT::RDF::RNode is cheap, but it will introduce an extra virtual call during the RDataFrame event loop (in most cases, the resulting performance impact should be negligible). Python users can perform the conversion with the helper function ROOT.RDF.AsRNode. Storing RDataFrame objects in collections; ROOT::RDF::RNode also makes it simple to store RDataFrame nodes in collections, e.g. a std::vector<RNode> or a std::map<std::string, RNode>:; std::vector<ROOT::RDF::RNode> dfs;; dfs.emplace_back(ROOT::RDataFrame(10));; dfs.emplace_back(dfs[0].Define(""x"", ""42.f""));. Executing callbacks every N events; It's possible to schedule execution of arbitrary functions (callbacks) during the event loop. Callbacks can be used e.g. to inspect partial results of the analysis while the event loop is running, drawing a partially-filled histogram every time a certain number of new entries is processed, or displaying a progress bar while the event loop runs.; For example one can draw an up-to-date version of a result histogram every 100 entries like this: auto h = df.Histo1D(""x"");; TCanvas c(""c"",""x hist"");; h.OnPartialResult(100, [&c](TH1D &h_) { c.cd(); h_.Draw(); c.Update(); });; // event loop runs here, this final `Draw` is executed after the event loop is finished; h->Draw();; TCanvasThe Canvas class.Definition TCanva",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:59534,simpl,simple,59534,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simple']
Usability,"his object to the current directory. ;  ;  Public Member Functions inherited from RooPrintable;  RooPrintable ();  ; virtual ~RooPrintable ();  ; virtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsMoment; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFirstMoment.html:45581,clear,clearEvalErrorLog,45581,doc/master/classRooFirstMoment.html,https://root.cern,https://root.cern/doc/master/classRooFirstMoment.html,3,['clear'],['clearEvalErrorLog']
Usability,"his point you can use the mouse to click on the contour of; the histogram hpx. When the mouse is clicked, the bin number and its; contents are printed.; Example2 of use of exec1.C. Root > TFile f(""hsimple.root""); Root > hpxpy.Draw(); Root > c1.AddExec(""ex2"","".x exec2.C""); When moving the mouse in the canvas, a second canvas shows the; projection along X of the bin corresponding to the Y position; of the mouse. The resulting histogram is fitted with a gaussian.; A ""dynamic"" line shows the current bin position in Y.; This more elaborated example can be used as a starting point; to develop more powerful interactive applications exploiting CINT; as a development engine. void AutoExec(); Execute the list of Execs when a pad event occurs. void Browse(TBrowser* b); Browse pad. TLegend * BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); Build a legend from the graphical objects in the pad. A simple method to build automatically a TLegend from the; primitives in a TPad. Only those deriving from TAttLine,; TAttMarker and TAttFill are added, excluding TPave and TFrame; derived classes. x1, y1, x2, y2 are the TLegend coordinates.; title is the legend title. By default it is "" "". The caller; program owns the returned TLegend. If the pad contains some TMultiGraph or THStack the individual; graphs or histograms in them are added to the TLegend. TVirtualPad * cd(Int_t subpadnumber = 0); Set Current pad.; When a canvas/pad is divided via TPad::Divide, one can directly; set the current path to one of the subdivisions.; See TPad::Divide for the convention to number subpads.; Returns the new current pad, or 0 in case of failure.; For example:; c1.Divide(2,3); // create 6 pads (2 divisions along x, 3 along y).; To set the current pad to the bottom right pad, do; c1.cd(6);; Note1: c1.cd() is equivalent to c1.cd(0) and sets the current pad; to c1 itself.; Note2: after a statement like c1.cd(6), the global variable gPad; poin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPad.html:32283,simpl,simple,32283,root/html534/TPad.html,https://root.cern,https://root.cern/root/html534/TPad.html,1,['simpl'],['simple']
Usability,"hitecture_t >::SetInputDepth ; (; size_t ; inputDepth). inline . Definition at line 218 of file GeneralLayer.h. ◆ SetInputHeight(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetInputHeight ; (; size_t ; inputHeight). inline . Definition at line 219 of file GeneralLayer.h. ◆ SetInputWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetInputWidth ; (; size_t ; inputWidth). inline . Definition at line 220 of file GeneralLayer.h. ◆ SetIsTraining(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetIsTraining ; (; bool ; isTraining). inline . Definition at line 224 of file GeneralLayer.h. ◆ SetWidth(). template<typename Architecture_t > . void TMVA::DNN::VGeneralLayer< Architecture_t >::SetWidth ; (; size_t ; width). inline . Definition at line 223 of file GeneralLayer.h. ◆ Update(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::Update ; (; const Scalar_t ; learningRate). Updates the weights and biases, given the learning rate. ; Definition at line 410 of file GeneralLayer.h. ◆ UpdateBiases(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiases ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the biases, given the gradients and the learning rate. ; Definition at line 428 of file GeneralLayer.h. ◆ UpdateBiasGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateBiasGradients ; (; const std::vector< Matrix_t > & ; biasGradients, . const Scalar_t ; learningRate . ). Updates the bias gradients, given some other weight gradients and learning rate. ; Definition at line 448 of file GeneralLayer.h. ◆ UpdateWeightGradients(). template<typename Architecture_t > . auto TMVA::DNN::VGeneralLayer< Architecture_t >::UpdateWeightGradients ; (; const std::vector< Matrix_t > & ; w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html:25278,learn,learningRate,25278,doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1VGeneralLayer.html,1,['learn'],['learningRate']
Usability,"hm . Definition at line 7347 of file TSpectrum2Painter.cxx. ◆ GetColorIncrements(). void TSpectrum2Painter::GetColorIncrements ; (; Double_t & ; r, . Double_t & ; g, . Double_t & ; b . ). Gets color increments between two color levels for r, g, b components: . r, g, b - color increments between two color levels . Definition at line 7357 of file TSpectrum2Painter.cxx. ◆ GetContourWidth(). void TSpectrum2Painter::GetContourWidth ; (; Int_t & ; width). Gets width between horizontal slices: . width - width between contours, applies only for contours display mode . Definition at line 7403 of file TSpectrum2Painter.cxx. ◆ GetDisplayMode(). void TSpectrum2Painter::GetDisplayMode ; (; Int_t & ; modeGroup, . Int_t & ; displayMode . ). Gets display group mode and display mode: -modeGroup - the following group modes might have been set: simple modes-kPicture2ModeGroupSimple, modes with shading according to light-kPicture2ModeGroupLight, modes with shading according to channels counts-kPicture2ModeGroupHeight, modes of combination of shading according to light and to channels counts-kPicture2ModeGroupLightHeight -displayMode - display modes that might have been set: points, grid, contours, bars, x_lines, y_lines, bars_x, bars_y, needles, surface, triangles. ; Definition at line 7287 of file TSpectrum2Painter.cxx. ◆ GetLightHeightWeight(). void TSpectrum2Painter::GetLightHeightWeight ; (; Double_t & ; weight). Gets weight between shading according to fictive light source and according to channels counts: . weight - weight between shading according to fictive light source and according to channels counts, applies only for kPicture2ModeGroupLightHeight modes group . Definition at line 7413 of file TSpectrum2Painter.cxx. ◆ GetLightPosition(). void TSpectrum2Painter::GetLightPosition ; (; Int_t & ; x, . Int_t & ; y, . Int_t & ; z . ). Gets position of fictive light source in 3D space: . x, y, z . Definition at line 7369 of file TSpectrum2Painter.cxx. ◆ GetNodes(). void TSpectrum2Pai",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Painter.html:28532,simpl,simple,28532,doc/master/classTSpectrum2Painter.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Painter.html,1,['simpl'],['simple']
Usability,"hod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); voidvector<long>::assign(initializer_list<vector<long>::value_type> __l); voidvector<long>::assign(vector<unsigned int>::size_type __n, const vector<long>::value_type& __val); vector<long>::referencevector<long>::at(vector<unsigned int>::size_type __n); vector<long>::const_referencevector<long>::at(vector<unsigned int>::size_type __n) const; vector<long>::referencevector<long>::back(); vector<long>::const_referencevector<long>::back() const; TTable::iteratorBegin(); TTable::iteratorBegin() const; vector<long>::iteratorvector<long>::begin(); vector<long>::const_iteratorvector<long>::begin() const; virtual voidTObject::Browse(TBrowser* b); vector<unsigned int>::size_typevector<long>::capacity() const; vector<long>::const_iteratorvector<long>::cbegin() const; vector<long>::const_iteratorvector<long>::cend() const; static TClass*Class(); virtual const char*TObject::ClassName() const; voidvector<long>::clear(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; vector<long>::const_reverse_iteratorvector<long>::crbegin() const; vector<long>::const_reverse_iteratorvector<long>::crend() const; long*vector<long>::data(); const long*vector<long>::data() const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; boolvector<long>::empty() const; TTable::iteratorEnd(); TTable::iteratorEnd() const; vector<long>::iteratorvector<long>::end(); vector<long>::const_iteratorvector<long>::end() const; vector<long>::iteratorvector<long>::erase(vector<long>::iterator __positi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTableMap.html:2474,clear,clear,2474,root/html604/TTableMap.html,https://root.cern,https://root.cern/root/html604/TTableMap.html,1,['clear'],['clear']
Usability,"hoodInterval object ;  CMarkovChainStores the steps in a Markov Chain of points ;  CMaxLikelihoodEstimateTestStatMaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter ;  CMCMCCalculatorBayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:7157,simpl,simple,7157,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['simpl'],['simple']
Usability,"hoodInterval object ;  CMarkovChainStores the steps in a Markov Chain of points ;  CMaxLikelihoodEstimateTestStatMaxLikelihoodEstimateTestStat: TestStatistic that returns maximum likelihood estimate of a specified parameter ;  CMCMCCalculatorBayesian Calculator estimating an interval or a credible region using the Markov-Chain Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalMCMCInterval is a concrete implementation of the RooStats::ConfInterval interface ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactoryA factory for building PDFs and data for a number counting combination ;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspectorUtility class to plot conditional MLE of nuisance parameters vs ;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:7374,simpl,simple,7374,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,5,['simpl'],['simple']
Usability,"hr_calc = ROOT.RooFormulaVar(""lhr_calc"", ""x[0] / x[1]"", [ws[""gauss""], ws[""uniform""]]); ; # Define the 'analytical' negative logarithmic likelihood ratio; nll_gauss = ws[""gauss""].createNLL(ws[""obs_data""]); ; # Create the learned pdf and NLL sum based on the learned likelihood ratio; pdf_learned = ROOT.RooWrapperPdf(""learned_pdf"", ""learned_pdf"", lhr_learned, True); ; nllr_learned = pdf_learned.createNLL(ws[""obs_data""]); ; # Plot the learned and analytical summed negativelogarithmic likelihood; frame1 = mu_vars[0].frame(; Title=""NLL of SBI vs. Morphing;#mu_{1};NLL"",; Range=(mu_observed[0] - 1, mu_observed[0] + 1),; ); nll_gauss.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+1"", Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, ShiftToZero=True, LineColor=""kP6Blue+2"", Name=""morph""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); nllr_learned.plotOn(frame1, LineColor=""kP6Blue"", ShiftToZero=True, Name=""learned""); ; ; # Declare a helper function in ROOT to dereference unique_ptr; ROOT.gInterpreter.Declare(; """"""; RooAbsArg &my_deref(std::unique_ptr<RooAbsArg> const& ptr) { return *ptr; }; """"""; ); ; # Choose normalization set for lhr_calc to plot over; norm_set = ROOT.RooArgSet(x_vars); lhr_calc_final_ptr = ROOT.RooFit.Detail.compileForNormSet(lhr_calc, norm_set); lhr_calc_final = ROOT.my_deref(lhr_calc_final_ptr); lhr_calc_final.recursiveRedirectServers(norm_set); ; # Plot the likelihood ratio functions; frame2 = x_vars[0].frame(Title=""Likelihood ratio r(x_{1}|#mu_{1}=2.5);x_{1};p_{gauss}/p_{uniform}""); lhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); lhr_calc_final.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html:9681,learn,learned,9681,doc/master/rf617__simulation__based__inference__multidimensional_8py.html,https://root.cern,https://root.cern/doc/master/rf617__simulation__based__inference__multidimensional_8py.html,1,['learn'],['learned']
Usability,"hrough an entire window. This is nothing else than the notion of inheritance. The TPad class is the parent of the TCanvas class. In ROOT, most objects derive from a base class TObject. This class has a virtual method Draw() such as all objects are supposed to be able to be “drawn”. If several canvases are defined, there is only one active at a time. One draws an object in the active canvas by using the statement:; object.Draw(); This instructs the object “object” to draw itself. If no canvas is opened, a default one (named “c1”) is created. In the next example, the first statement defines a function and the second one draws it. A default canvas is created since there was no opened one. You should see the picture as shown in the next figure.; root[] TF1 f1(""func1"",""sin(x)/x"",0,10); root[] f1.Draw(); <TCanvas::MakeDefCanvas>: created default TCanvas with name c1. A canvas with drawing. The following components comprise the canvas window:. Menu bar - contains main menus for global operations with files, print, clear canvas, inspect, etc.; Tool bar - has buttons for global and drawing operations; such as arrow, ellipse, latex, pad, etc.; Canvas - an area to draw objects.; Status bar - displays descriptive messages about the selected object.; Editor frame - responds dynamically and presents the user interface according to the selected object in the canvas. 2.3.1 Main Menus and Toolbar; At the top of the canvas window are File, Edit, View, Options, Inspect, Classes and Help menus.; 2.3.1.1 File Menu. New Canvas: creates a new canvas window in the current ROOT session.; Open…: popup a dialog to open a file.; Close Canvas: close the canvas window.; Save: save the drawing of the current canvas in a format selectable from the submenu. The current canvas name is used as a file name for various formats such as PostScript, GIF, JPEG, C macro file, root file.; Save As…: popup a dialog for saving the current canvas drawing in a new filename.; Print: popup a dialog to print the cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:36764,clear,clear,36764,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['clear'],['clear']
Usability,"hs.%s[i];\n"",element->GetArrayLength(),ename,ename);; 3489 } else if (element->GetArrayDim() >= 2) {; 3490 fprintf(file,"" for (Int_t i=0;i<%d;i++) reinterpret_cast<%s *>(%s"", element->GetArrayLength(), element->GetTypeName(), ename);; 3491 fprintf(file,"")[i] = reinterpret_cast<%s const *>(rhs.%s)[i];\n"", element->GetTypeName(), ename);; 3492 }; 3493 } else if (element->GetType() == TVirtualStreamerInfo::kSTLp) {; 3494 if (!defMod) { fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE; };; 3495 fprintf(file,"" modrhs.%s = 0;\n"",ename);; 3496 } else if (element->GetType() == TVirtualStreamerInfo::kSTL) {; 3497 if (!defMod) {; 3498 fprintf(file,"" %s &modrhs = const_cast<%s &>( rhs );\n"",protoname.Data(),protoname.Data()); defMod = kTRUE;; 3499 }; 3500 TClass *cle = element->GetClassPointer();; 3501 TVirtualCollectionProxy *proxy = cle ? element->GetClassPointer()->GetCollectionProxy() : 0;; 3502 std::string method_name = ""clear"";; 3503 if (!element->TestBit(TStreamerElement::kDoNotDelete) && proxy && (((TStreamerSTL*)element)->GetSTLtype() == ROOT::kSTLbitset)) {; 3504 method_name = ""reset"";; 3505 }; 3506 if (element->IsBase()) {; 3507 fprintf(file,"" modrhs.%s();\n"", method_name.c_str());; 3508 } else {; 3509 fprintf(file,"" modrhs.%s.%s();\n"",ename, method_name.c_str());; 3510 }; 3511 }; 3512 }; 3513 }; 3514}; 3515 ; 3516////////////////////////////////////////////////////////////////////////////////; 3517/// Write down the body of the 'move' constructor.; 3518 ; 3519static void R__WriteMoveConstructorBody(FILE *file, const TString &protoname, TIter &next); 3520{; 3521 TStreamerElement *element = 0;; 3522 next.Reset();; 3523 Bool_t atstart = kTRUE;; 3524 while ((element = (TStreamerElement*)next())) {; 3525 if (element->IsBase()) {; 3526 if (atstart) { fprintf(file,"" : ""); atstart = kFALSE; }; 3527 else fprintf(file,"" , "");; 3528 fprintf(file, ""%s(const_cast<%s &>( rhs ))\n"", element->GetName(),protoname.Data());; 35",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:141953,clear,clear,141953,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['clear'],['clear']
Usability,"i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8529 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8660 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8821 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8855 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8676 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:207483,learn,learning,207483,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['learn'],['learning']
Usability,"i);; TBranch::GetEntryvirtual Int_t GetEntry(Long64_t entry=0, Int_t getall=0)Read all leaves of entry and return total number of bytes read.Definition TBranch.cxx:1706; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented in TChain.; Definition at line 8534 of file TTree.cxx. ◆ SetBranchStyle(). void TTree::SetBranchStyle ; (; Int_t ; style = 1). static . Set the current branch style. ; (static function). style = 0 old Branch; style = 1 new Bronch . Definition at line 8665 of file TTree.cxx. ◆ SetCacheEntryRange(). Int_t TTree::SetCacheEntryRange ; (; Long64_t ; first, . Long64_t ; last . ). virtual . interface to TTreeCache to set the cache entry range ; Returns:; 0 entry range set; -1 on error . Definition at line 8831 of file TTree.cxx. ◆ SetCacheLearnEntries(). void TTree::SetCacheLearnEntries ; (; Int_t ; n = 10). virtual . Interface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:209974,learn,learning,209974,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['learn'],['learning']
Usability,"i, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EDataSet. enum TMultiLayerPerceptron::EDataSet. EnumeratorkTraining ; kTest . Definition at line 32 of file TMultiLayerPerceptron.h. ◆ ELearningMethod. enum TMultiLayerPerceptron::ELearningMethod. EnumeratorkStochastic ; kBatch ; kSteepestDescent ; kRibierePolak ; kFletcherReeves ; kBFGS . Definition at line 30 of file TMultiLayerPerceptron.h. Constructor & Destructor Documentation. ◆ TMultiLayerPerceptron() [1/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; ). Default constructor. ; Definition at line 264 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [2/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . TTree * ; data = nullptr, . const char * ; training = ""Entry$%2==0"", . const char * ; test = """", . TNeuron::ENeuronType ; type = TNeuron::kSigmoid, . const char * ; extF = """", . const char * ; extD = """" . ). The network is described by a simple string: The input/output layers are defined by giving the branch names separated by comas. ; Hidden layers are just described by the number of neurons. The layers are separated by colons.; Ex: ""x,y:10:5:f""; The output can be prepended by '@' if the variable has to be normalized. The output can be followed by '!' to use Softmax neurons for the output layer only.; Ex: ""x,y:10:5:c1,c2,c3!""; Input and outputs are taken from the TTree given as second argument. training and test are two cuts (see TTreeFormula) defining events to be used during the neural net training and testing.; Example: ""Entry$%2"", ""(Entry$+1)%2"".; Both the TTree and the cut can be defined in the constructor, or later with the suited setter method. ; Definition at line 446 of file TMultiLayerPerceptron.cxx. ◆ TMultiLayerPerceptron() [3/6]. TMultiLayerPerceptron::TMultiLayerPerceptron ; (; const char * ; layout, . const char * ; weight, . TTree * ; data = nullptr, . const char * ; training = ""Entry$%2==0"", . const char * ; test = """", . TNeuron::ENe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiLayerPerceptron.html:29346,simpl,simple,29346,doc/master/classTMultiLayerPerceptron.html,https://root.cern,https://root.cern/doc/master/classTMultiLayerPerceptron.html,1,['simpl'],['simple']
Usability,"i1) .... cos(fPhil+fDphi1); Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& ); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTUBE.html:9085,simpl,simplified,9085,root/html534/TTUBE.html,https://root.cern,https://root.cern/root/html534/TTUBE.html,1,['simpl'],['simplified']
Usability,"i1) .... cos(fPhil+fDphi1); Float_tfDzhalf length in z; Color_tTAttFill::fFillColorfill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& b); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTUBE.html:8851,simpl,simplified,8851,root/html528/TTUBE.html,https://root.cern,https://root.cern/root/html528/TTUBE.html,3,['simpl'],['simplified']
Usability,"i; Float_tfRmaxmaximum radius; Float_tfRminminimum radius; Float_tfThemaxmaximum theta; Float_tfTheminminimum theta; TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag; Float_tfaXCoeff along Ox; Float_tfaYCoeff along Oy; Float_tfaZCoeff along Oz. private:. Float_tfAspectRatioRelation between asumth and grid size (by default 1.0); Double_t*fCoTab! Table of cos(fPhimin) .... cos(Phi); Double_t*fCoThetaTab! Table of sin(gThemin) .... cos(Theta); Int_tfNdivnumber of divisions; Int_tfNz! number of sections; Double_t*fSiTab! Table of sin(fPhimin) .... sin(Phi). Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TSPHE. Function documentation; TSPHE(); SPHE shape default constructor. TSPHE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t themin, Float_t themax, Float_t phimin, Float_t phimax); SPHE shape normal constructor. TSPHE(const char* name, const char* title, const char* material, Float_t rmax); SPHE shape ""simplified"" constructor. ~TSPHE(); SPHE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a PSPHE. Compute the closest distance of approach from point px,py to each; computed outline point of the PSPHE (stolen from PCON). void SetEllipse(const Float_t* factors); Set ellipse. void SetNumberOfDivisions(Int_t p); Set number of divisions. void SetPoints(Double_t* points) const; Create SPHE points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void MakeTableOfCoSin() const; Make table of sine and cosine. void Streamer(TBuffer& ); Stream a class object. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TSPHE(). Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetThemin() const; {return fThemin;}. Float_t GetThemax() const; {return fThemax;}. Float_t GetPhimin() const; {return fPhimin;}. Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPHE.html:9967,simpl,simplified,9967,root/html602/TSPHE.html,https://root.cern,https://root.cern/root/html602/TSPHE.html,2,['simpl'],['simplified']
Usability,"iableInfo(i).GetExpression());; 333 firstArrayVar = kFALSE;; 334 firstArrayVarIndex = i;; 335 ; 336 Log() << kINFO << ""Using variable "" << dsi.GetVariableInfo(i).GetInternalName() <<; 337 "" from array expression "" << dsi.GetVariableInfo(i).GetExpression() << "" of size "" << arraySize << Endl;; 338 }; 339 fInputTableFormulas.push_back(std::make_pair(ttf, (Int_t) i-firstArrayVarIndex));; 340 if (int(i)-firstArrayVarIndex == arraySize-1 ) {; 341 // I am the last element of the array; 342 firstArrayVar = kTRUE;; 343 firstArrayVarIndex = -1;; 344 Log() << kDEBUG << ""Using Last variable from array : "" << dsi.GetVariableInfo(i).GetInternalName() << Endl;; 345 }; 346 }; 347 ; 348 }; 349 ; 350 //; 351 // targets; 352 //; 353 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform regression targets"" << Endl;; 354 for (formIt = fTargetFormulas.begin(), formItEnd = fTargetFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 355 fTargetFormulas.clear();; 356 for (UInt_t i=0; i<dsi.GetNTargets(); i++) {; 357 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetTargetInfo(i).GetInternalName().Data() ),; 358 dsi.GetTargetInfo(i).GetExpression().Data(), tr );; 359 CheckTTreeFormula( ttf, dsi.GetTargetInfo(i).GetExpression(), hasDollar );; 360 fTargetFormulas.push_back( ttf );; 361 }; 362 ; 363 //; 364 // spectators; 365 //; 366 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName()) << ""transform spectator variables"" << Endl;; 367 for (formIt = fSpectatorFormulas.begin(), formItEnd = fSpectatorFormulas.end(); formIt!=formItEnd; ++formIt) if (*formIt) delete *formIt;; 368 fSpectatorFormulas.clear();; 369 for (UInt_t i=0; i<dsi.GetNSpectators(); i++) {; 370 ttf = new TTreeFormula( TString::Format( ""Formula%s"", dsi.GetSpectatorInfo(i).GetInternalName().Data() ),; 371 dsi.GetSpectatorInfo(i).GetExpression().Data(), tr );; 372 CheckTTreeFormula( ttf, dsi.GetSpectatorInfo(i).GetExpression(), hasDollar );; 373 fSpectatorFormulas.push_back( ttf );;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:14248,clear,clear,14248,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['clear'],['clear']
Usability,"iagrams. More...;  ; class  TCurlyLine;  Implements curly or wavy polylines used to draw Feynman diagrams. More...;  ; class  TCutG;  Graphical cut class. More...;  ; class  TDiamond;  Draw a Diamond. More...;  ; class  TEllipse;  Draw Ellipses. More...;  ; class  TFrame;  Define a Frame. More...;  ; class  TGaxis;  The axis painter class. More...;  ; class  TGraphPolar;  To draw a polar graph. More...;  ; class  TGraphPolargram;  To draw polar axis. More...;  ; class  TGraphQQ;  This class allows to draw quantile-quantile plots. More...;  ; class  TImage;  An abstract interface to image processing library. More...;  ; class  TImagePalette;  A class to define a conversion from pixel values to pixel color. More...;  ; class  TLatex;  To draw Mathematical Formula. More...;  ; class  TLegend;  This class displays a legend box (TPaveText) containing several legend entries. More...;  ; class  TLegendEntry;  Storage class for one entry of a TLegend. More...;  ; class  TLine;  Use the TLine constructor to create a simple line. More...;  ; class  TLink;  Special TText object used to show hyperlinks. More...;  ; class  TMarker;  Manages Markers. More...;  ; class  TMathText;  To draw TeX Mathematical Formula. More...;  ; class  TPaletteEditor;  Edit the palette via a GUI. More...;  ; class  TPave;  A TBox with a bordersize and a shadow option. More...;  ; class  TPaveLabel;  A Pave (see TPave) with a text centered in the Pave. More...;  ; class  TPaveStats;  The histogram statistics painter class. More...;  ; class  TPavesText;  A PaveText (see TPaveText) with several stacked paves. More...;  ; class  TPaveText;  A Pave (see TPave) with text, lines or/and boxes inside. More...;  ; class  TPie;  Draw a Pie Chart,. More...;  ; class  TPieSlice;  A slice of a piechart, see the TPie class. More...;  ; class  TPoints;  2-D graphics point (world coordinates). More...;  ; class  TPolyLine;  Defined by an array on N points in a 2-D space. More...;  ; class  TText;  Base class for se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__BasicGraphics.html:1669,simpl,simple,1669,doc/master/group__BasicGraphics.html,https://root.cern,https://root.cern/doc/master/group__BasicGraphics.html,1,['simpl'],['simple']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dependent eventloop via gSystem. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual void Show ();  ; virtual void StartIdleing ();  Called when system ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationRemote.html:5270,guid,guide,5270,doc/master/classTApplicationRemote.html,https://root.cern,https://root.cern/doc/master/classTApplicationRemote.html,1,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual void Show ();  ; virtual void StartIdleing ();  Called when system starts idleing. ;  ; virtual void StopIdleing ();  Called when system stops idleing. ;  ; void StreamerNVirtual (TBuffer",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplicationServer.html:4627,guid,guide,4627,doc/master/classTApplicationServer.html,https://root.cern,https://root.cern/doc/master/classTApplicationServer.html,1,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void Run (Bool_t retrn=kFALSE);  Main application eventloop. Calls system dependent eventloop via gSystem. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGApplication.html:3264,guid,guide,3264,doc/master/classTGApplication.html,https://root.cern,https://root.cern/doc/master/classTGApplication.html,1,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetEchoMode (Bool_t mode);  Set console echo mode: ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:7897,guid,guide,7897,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,2,['guid'],['guide']
Usability,"ialize the graphics environment. ;  ; TObjArray * InputFiles () const;  ; virtual Bool_t IsCmdThread ();  ; Bool_t IsRunning () const;  ; virtual void KeyPressed (Int_t key);  Emit signal when console keyboard key was pressed. ;  ; virtual void LineProcessed (const char *line);  Emit signal when a line has been processed. ;  ; virtual void Lower ();  ; void ls (Option_t *option="""") const override;  Show available sessions. ;  ; Bool_t NoLogoOpt () const;  ; Bool_t NoLogOpt () const;  ; virtual void Open ();  ; void OpenForumTopic (const TString &type);  It opens a Forum topic in a web browser with prefilled ROOT version. ;  ; void OpenGitHubIssue (const TString &type);  It opens a GitHub issue in a web browser with prefilled ROOT version. ;  ; void OpenInBrowser (const TString &url);  The function generates and executes a command that loads the Doxygen URL in a browser. ;  ; void OpenReferenceGuideFor (const TString &strippedClass);  It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/struct) or member (method/function/ data member/enumeration/enumerator. ;  ; virtual Longptr_t ProcessFile (const char *file, Int_t *error=nullptr, Bool_t keep=kFALSE);  Process a file containing a C++ macro. ;  ; virtual Longptr_t ProcessLine (const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr);  Process a single command line, either a C++ statement or an interpreter command starting with a ""."". ;  ; Bool_t QuitOpt () const;  ; virtual void Raise ();  ; virtual void RemoveIdleTimer ();  Remove idle timer. Normally called via TROOT::Idle(0). ;  ; Bool_t ReturnFromRun () const;  ; virtual void ReturnPressed (char *text);  Emit signal when return key was pressed. ;  ; virtual void SetIdleTimer (UInt_t idleTimeInSec, const char *command);  Set the command to be executed after the system has been idle for idleTimeInSec seconds. ;  ; void SetReturnFromRun (Bool_t ret);  ; virtual void Show ();  ; virtual void StartIdleing ();  Called wh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRint.html:3856,guid,guide,3856,doc/master/classTRint.html,https://root.cern,https://root.cern/doc/master/classTRint.html,1,['guid'],['guide']
Usability,"iance method"" and the implementation is provided in the function FitUtil::EvaluateChi2Effective. Linear fitting:; When the fitting function is linear (contains the ++ sign) or the fitting function is a polynomial, a linear fitter is initialised. To create a linear function, use the following syntax: linear parts separated by ++ sign. Example: to fit the parameters of the function p0*x + p1*sin(x), you can create a TF1 object as TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; For such a TF1 you don't have to set the initial conditions and the linear fitter is used. Going via the linear fitter for functions, linear in parameters, gives a considerable advantage in speed. When using the linear fitting it is also possible to perform a robust fitting with the Least Trimmed Square (LTS) regression algorithm, by using the fit option ROB. See the tutorial fitLinearRobust.C. Notes on TGraph/TGraphErrors Fitting:. By using the ""effective variance"" method a simple linear regression becomes a non-linear case, which takes several iterations instead of 0 as in the linear case.; The effective variance technique assumes that there is no correlation between the x and y coordinate.; The standard chi2 (least square) method without error in the coordinates (x) can be forced by using option ""EX0""; The linear fitter doesn't take into account the errors in x. When fitting a TGraphErrors with a linear functions the errors in x will not be considered. If errors in x are important, use option ""F"" for linear function fitting.; When fitting a TGraph (i.e. no errors associated with each point), a correction is applied to the errors on the parameters with the following formula: parameter_error *= sqrt(chisquare/(ndf-1)). General Fitting documentation; See in TH1::Fit for the documentation of; Fit Result; Fit Status; Fit Statistics Box; Fitting in a Range; Setting Initial Conditions . Definition at line 1231 of file TGraph.cxx. ◆ FitPanel(). void TGraph::FitPanel ; (; ). virtual . Display a GUI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph.html:51827,simpl,simple,51827,doc/master/classTGraph.html,https://root.cern,https://root.cern/doc/master/classTGraph.html,1,['simpl'],['simple']
Usability,"iated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Thu Sep 23 19:59:34 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExpensiveObjectCache.html:8054,clear,clearObj,8054,root/html528/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html528/RooExpensiveObjectCache.html,2,['clear'],"['clearAll', 'clearObj']"
Usability,"iated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Tue Jun 30 14:32:46 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExpensiveObjectCache.html:8628,clear,clearObj,8628,root/html602/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html602/RooExpensiveObjectCache.html,2,['clear'],"['clearAll', 'clearObj']"
Usability,"iated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* paramIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Tue Mar 10 17:16:31 2015 » Last generated: 2015-03-10 17:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooExpensiveObjectCache.html:8142,clear,clearObj,8142,root/html534/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html534/RooExpensiveObjectCache.html,2,['clear'],"['clearAll', 'clearObj']"
Usability,"ibly with different arguments every time. More...;  ; class  TGenericClassInfo;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TModuleGenerator;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWriteGuard;  ; class  TSchemaRule;  ; class  TSeq;  A pseudo container class which is a generator of indices. More...;  ; class  TSequentialExecutor;  ; class  TSpinMutex;  A spin mutex class which respects the STL interface for mutexes. More...;  ; class  TThreadedObject;  A wrapper to make object instances thread private, lazily. More...;  ; class  TThreadExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TTreeProcessorMP;  This class provides an interface to process a TTree dataset in parallel with multi-process technology. More...;  ; class  TTreeProcessorMT;  A class to process the entries of a TTree in parallel. More...;  ; class  TVirtualRWMutex;  ; class  TWriteLockGuard;  . Typedefs; using ColumnNames_t = ROOT::Detail::RDF::ColumnNames_t;  ; using ColumnNamesPtr_t = std::shared_ptr< const ColumnNames_t >;  ; typedef void(* DelArrFunc_t) (void *);  ; typedef void(* DelFunc_t) (void *);  ; typedef void(* DesFunc_t) (void *);  ; typedef void(* DirAutoAdd_t) (void *, TDirectory *);  ; using Double_v = Double_t;  ; using Float_v = Float_t;  ; using Int32_v = Int_t;  ; using Int_v = Int_t;  ; typedef std::map< std::string, ROOT::Internal::TSchemaType > MembersTypeMap_t;  ; typedef Long64_t(* MergeFunc_t) (void *, TCollection *, TFileMergeInfo *);  ; typedef void *(* NewArrFunc_t) (Lon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v618/namespaceROOT.html:2561,simpl,simple,2561,doc/v618/namespaceROOT.html,https://root.cern,https://root.cern/doc/v618/namespaceROOT.html,2,['simpl'],['simple']
Usability,"ibraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the actual values and are here only to; 2828/// shorten this comment).; 2829///; 2830/// Note that the default behavior is to remove libraries when closing ROOT,; 2831/// ie TSystem::CleanCompiledMacros() is called in the TROOT destructor.; 2832/// The default behavior of .L script.C+ is the opposite one, leaving things; 2833/// after closing, without removing. In other words, .L always passes the 'k'; 2834/// option behind the scenes.; 2835 ; 2836int TSystem::CompileMacro(const char *filename, Option_t *opt,; 2837 const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:93069,simpl,simplify,93069,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['simpl'],['simplify']
Usability,"ic Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:44124,clear,clearCacheObject,44124,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,2,['clear'],['clearCacheObject']
Usability,"ic Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-02 16:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGeoNodeEditor.html:22708,undo,undoing,22708,root/html604/TGeoNodeEditor.html,https://root.cern,https://root.cern/root/html604/TGeoNodeEditor.html,1,['undo'],['undoing']
Usability,"ic Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel; static TGFrame::(anonymous)TGFrame::kDeleteWindowCalled. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for node editor. ~TGeoNodeEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to a editable object. void DoSelectMother(); Select the mother volume. void DoSelectVolume(); Select the volume. void DoSelectMatrix(); Select the matrix. void DoEditMother(); Edit the mother volume. void DoEditVolume(); Edit selected volume. void DoEditMatrix(); Edit selected material. void DoNodeName(); Change node name. void DoNodeNumber(); Change node copy number. void DoApply(); Slot for applying modifications. void DoUndo(); Slot for undoing last operation. TGeoNodeEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-06-30 15:02; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeEditor.html:22708,undo,undoing,22708,root/html602/TGeoNodeEditor.html,https://root.cern,https://root.cern/root/html602/TGeoNodeEditor.html,1,['undo'],['undoing']
Usability,"ic Member Functions |; Protected Member Functions |; Private Attributes |; List of all members ; TMVA::VariableImportance Class ReferenceTMVA. . Definition at line 44 of file VariableImportance.h. Public Member Functions;  VariableImportance (DataLoader *loader);  ;  ~VariableImportance ();  ; virtual void Evaluate ();  Virtual method to be implemented with your algorithm. ;  ; const VariableImportanceResult & GetResults () const;  ; VIType GetType ();  ; virtual TClass * IsA () const;  ; void SetType (VIType type);  ; virtual void Streamer (TBuffer &);  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TMVA::Envelope;  ~Envelope ();  Default destructor. ;  ; virtual void BookMethod (TString methodname, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; virtual void BookMethod (Types::EMVA method, TString methodtitle, TString options="""");  Method to book the machine learning method to perform the algorithm. ;  ; DataLoader * GetDataLoader ();  Method to get the pointer to TMVA::DataLoader object. ;  ; TFile * GetFile ();  Method to get the pointer to TFile object. ;  ; std::vector< OptionMap > & GetMethods ();  Method get the Booked methods in a option map object. ;  ; Bool_t HasMethod (TString methodname, TString methodtitle);  function to check methods booked ;  ; Bool_t IsModelPersistence ();  Method to see if the algorithm model is saved in xml or serialized files. ;  ; Bool_t IsSilentFile ();  Method to see if a file is available to save results. ;  ; Bool_t IsVerbose ();  Method to see if the algorithm should print extra information. ;  ; virtual void ParseOptions ();  Method to parse the internal option string. ;  ; void SetDataLoader (DataLoader *dalaloader);  Method to set the pointer to TMVA::DataLoader object. ;  ; void SetFile (TFile *file);  Method to set the pointer to TFile object, with a writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html:1232,learn,learning,1232,doc/master/classTMVA_1_1VariableImportance.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1VariableImportance.html,1,['learn'],['learning']
Usability,"ic Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static std::unique_ptr< RooAbsPdf > create (RooAbsPdf &pdf, RooAbsData const &data, double precision);  Creates a wrapping RooBinSamplingPdf if appropriate. ;  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinSamplingPdf.html:59875,clear,clearEvalErrorLog,59875,doc/master/classRooBinSamplingPdf.html,https://root.cern,https://root.cern/doc/master/classRooBinSamplingPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"ic Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoCombiTransEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); Constructor for combi matrix editor. ~TGeoCombiTransEditor(); Destructor. void ConnectSignals2Slots(); Connect signals to slots. void SetModel(TObject* obj); Connect to the selected combi matrix. void DoName(); Slot for name. void DoRotPhi(); Slot for phi (Euler X convention). void DoRotTheta(); Slot for theta (Euler X convention). void DoRotPsi(); Slot for psi (Euler X convention). void DoRotAngle(); Slot for additional rotation about one axis. Bool_t DoParameters(); Slot for checking parameters. void DoApply(); Slot for applying modifications. void DoCancel(); Slot for cancelling last un-applied operations. void DoModified(); Slot for notifying changes. void DoUndo(); Slot for undoing last changes. void DoDx(); Slot for X. void DoDy(); Slot for Y. void DoDz(); Slot for Z. » Author: M.Gheata » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: :$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoCombiTransEditor.html:22298,undo,undoing,22298,root/html534/TGeoCombiTransEditor.html,https://root.cern,https://root.cern/root/html534/TGeoCombiTransEditor.html,1,['undo'],['undoing']
Usability,"ic TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; MsgLogger & Log () const;  ; TString SecToText (Double_t, Bool_t) const;  pretty string output ;  . Private Attributes; Bool_t fColourfulOutput;  flag for use of colors ;  ; MsgLogger * fLogger;  ! the output logger ;  ; Int_t fNcounts;  reference number of ""counts"" ;  ; Bool_t fOutputToFile;  ; TString fPrefix;  prefix for outputs ;  ; Int_t fPreviousProgress;  ; TString fPreviousTimeEstimate;  ; Int_t fProgressBarStringLength;  . Static Private Attributes; static const TString fgClassName = ""Timer"";  used for output ;  ; static const Int_t fgNbins = 16;  number of bins in progress bar ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to Error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Timer.html:12506,progress bar,progress bar,12506,doc/master/classTMVA_1_1Timer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Timer.html,1,['progress bar'],['progress bar']
Usability,"ic Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static const TGFont*TGProgressBar::fgDefaultFont; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGGC*TGProgressBar::fgDefaultGC; static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGVProgressBar(const TGWindow* p = 0, UInt_t w = kProgressBarTextWidth, UInt_t h = 4, Pixel_t back = GetWhitePixel(), Pixel_t barcolor = GetDefaultSelectedBackground(), GContext_t norm = GetDefaultGC()(), FontStruct_t font = GetDefaultFontStruct(), UInt_t options = kDoubleBorder|kSunkenFrame); cconstructor. TGVProgressBar(const TGWindow* p, TGProgressBar::EBarType type, UInt_t h); Simple constructor allow you to create either a standard progress; bar, or a more fancy progress bar (fancy means: double sized border,; white background and a bit wider to allow for text to be printed; in the bar. void DoRedraw(); Draw vertical progress bar. void SavePrimitive(ostream& out, Option_t* option = """"); Save a vertical progress bar as a C++ statement(s) on output stream out. void Percent(Bool_t ); { fPercent = on; fClient->NeedRedraw(this); }. void ShowPos(Bool_t ); { fShowPos = on; fClient->NeedRedraw(this); }. TGDimension GetDefaultSize() const; { return TGDimension(fWidth, fBarWidth); }. virtual ~TGVProgressBar(); { }. » Author: Fons Rademakers 10/10/2000 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id$ » Last generated: 2015-03-14 16:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGVProgressBar.html:20540,progress bar,progress bar,20540,root/html534/TGVProgressBar.html,https://root.cern,https://root.cern/root/html534/TGVProgressBar.html,3,['progress bar'],['progress bar']
Usability,"ic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several methods giving control of the cache have changed return type from void to Int_t, to be able to return a code to indicate if there was an error.; Usually TTree::SetCacheSize will no longer reset the list of branches to be cached (either set or previously learnt) nor restart the learning phase. The learning phase is restarted when a new cache is created, e.g. after having removed a cache with SetCacheSize(0).; TSelectorDraw; The axis titles in case of a x:y:z plot with the option COLZ were not correct.; TParallelCoordVar; Change the format used to print the variables limit for ||-Coord to %g. It was %6.4f before.; Histogram Libraries; TFormula. New version of the TFormula class based on Cling. Formula expressions are now used to create functions which are passed to Cling to be Just In Time compiled. The expression is therefore compiled using Clang/LLVVM which will give execution time as compiled code and in addition correctness of the result obtained.; This class is not 100% backward compatible with the old TFormula class, which is still available in ROOT as =ROOT::v5::TFormula=. Some of the TFormula member funtions available in version 5, such as =Analyze= and =AnalyzeFunction= are not available in t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:14010,learn,learnt,14010,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,2,['learn'],"['learning', 'learnt']"
Usability,"ic player, using ROOT geometry class ;  na49.CThis file has been generated automatically via the root utility toroot from an interactive version of GEANT (see ROOT class TGeometry header for an example of use) This shows an example of the old geometry package (now obsolete) ;  na49geomfile.CBefore executing this macro, the file makegeometry.C must have been executed ;  na49view.CThis macro generates with 2 views of the NA49 detector using the old obsolete geometry package ;  parallel_world.CMisaligning geometry generate in many cases overlaps, due to the idealization of the design and the fact that in real life movements of the geometry volumes have constraints and are correlated ;  RadioNuclides.CMacro that demonstrates usage of radioactive elements/materials/mixtures with TGeo package ;  robot.CDrawing a famous Korean robot, TaekwonV, using ROOT geometry class ;  rootgeom.CDefinition of a simple geometry (the 4 ROOT characters) ;  runplugin.CCreates and runs a simple iterator plugin connected to TGeoPainter iterator ;  shapes.CThe old geometry shapes (see script geodemo.C) ;  shapesAnim.CMacro illustrating how to animate a geometry picture using a Timer ;  south_gate.CDrawing a famous Korean gate, the South gate, called Namdeamoon in Korean, using ROOT geometry class ;  station1.CDrawing a space station, using ROOT geometry class ;  station2.CDrawing a space station (version 2), using ROOT geometry class ;  tank.CDrawing a fine tank, using ROOT geometry class ;  xtruDraw.CDraw a ""representative"" TXTRU shape ;  xtruSamples.CDraw a sample of TXTRU shapes some convex, concave (and possibly malformed) ;  ► gl;  customcolorgl.h;  glbox.CDisplay a 3D histogram using GL (box option) ;  gldemos.CMenu for running GL demos ;  glh3c.CDisplay a 3D histogram using GL (box option) ;  glparametric.CShow rendering of parametric surfaces ;  glparametrics2.CShow rendering of parametric surfaces ;  glrose.CRender a TF2 looking like a rose ;  glsurfaces.CVarious surfaces rendered with",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:110263,simpl,simple,110263,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"ical User Interface; 10 Folders and Tasks; 11 Input/Output; 12 Trees; 13 Math Libraries in ROOT; 14 Linear Algebra in ROOT; 15 Adding a Class; 16 Collection Classes; 17 Physics Vectors; 18 The Geometry Package; 19 Python Interface; 20 The Tutorials and Tests; 21 Example Analysis; 22 Networking; 23 Threads; 24 PROOF: Parallel Processing; 25 Writing a Graphical User Interface; 26 The Signal/Slot Communication Mechanism; 27 Automatic HTML Documentation; 28 Appendix A: Install and Build ROOT. WARNING: This documentation is not maintained anymore. Some part might be obsolete or wrong, some part might be missing but still some valuable information can be found there. Instead please refer to the ROOT Reference Guide and the ROOT Manual. If you think some information should be imported in the ROOT Reference Guide or in the ROOT Manual, please post your request to the ROOT Forum or via a Github Issue. Preface; In late 1994, we decided to learn and investigate Object Oriented programming and C++ to better judge the suitability of these relatively new techniques for scientific programming. We knew that there is no better way to learn a new programming environment than to use it to write a program that can solve a real problem. After a few weeks, we had our first histogramming package in C++. A few weeks later we had a rewrite of the same package using the, at that time, very new template features of C++. Again, a few weeks later we had another rewrite of the package without templates since we could only compile the version with templates on one single platform using a specific compiler. Finally, after about four months we had a histogramming package that was faster and more efficient than the well-known FORTRAN based HBOOK histogramming package. This gave us enough confidence in the new technologies to decide to continue the development. Thus was born ROOT. Since its first public release at the end of 1995, ROOT has enjoyed an ever-increasing popularity. Currently it is being ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1164,learn,learn,1164,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['learn'],['learn']
Usability,"ically sets 'mvf=1'; it is still possible to set 'mvf=11'; to save results after each packet. The separator from the next option is either a ' ' or a ';'. All recognized settings are removed from the input string opt.; If action == 0, set up the output file accordingly, if action == 1 clean related; output file settings.; If the final target file is local then 'target' is set to the final local path; when action == 0 and used to retrieve the file with TFile::Cp when action == 1. Output file settings are in the form. <previous_option>of=name <next_option>; <previous_option>outfile=name,...;<next_option>. The separator from the next option is either a ' ' or a ';'; Called interanally by TProof::Process. Returns 0 on success, -1 on error. void SetFeedback(TString& opt, TString& optfb, Int_t action); Extract from opt in optfb information about wanted feedback settings.; Feedback are removed from the input string opt.; If action == 0, set up feedback accordingly, if action == 1 clean related; feedback settings (using info in optfb, if available, or reparsing opt). Feedback requirements are in the form. <previous_option>fb=name1,name2,name3,... <next_option>; <previous_option>feedback=name1,name2,name3,...;<next_option>. The special name 'stats' triggers feedback about events and packets.; The separator from the next option is either a ' ' or a ';'.; Called interanally by TProof::Process. Long64_t Process(TDSet* dset, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TDSet) using the specified selector (.C) file or; Tselector object; Entry- or event-lists should be set in the data set object using; TDSet::SetEntryList.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. Long64_t Process(TFileCollection* fc, const char* selector, Option_t* option = """", Long64_t nentries = -1, Long64_t firstentry = 0); Process a data set (TFileCollection) using the specified selector (.C)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:51063,feedback,feedback,51063,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,6,['feedback'],['feedback']
Usability,"ically the; baskets from the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:1365,learn,learning,1365,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,3,['learn'],['learning']
Usability,ication of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► envelope;  classification.C;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:155769,simpl,simple,155769,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,1,['simpl'],['simple']
Usability,"ics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Direct generation is safe if all components say so. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Return pseud-code that indicates if all components can do internal generation (1) or not (0). void generateEvent(Int_t code); This function should never be called as RooAddModel implements a custom generator context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddModel to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddModel(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; Model is self normalized when used as p.d.f. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Mon Dec 7 13:45:55 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:47558,intuit,intuitively,47558,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,1,['intuit'],['intuitively']
Usability,"ictionary-like syntax, you can also get objects with names that don’t qualify as a Python variable. Here is a short demo:; import ROOT. with ROOT.TFile.Open(""my_file.root"", ""RECREATE"") as my_file:. # Populate the TFile with simple objects.; my_file.WriteObject(ROOT.std.string(""hello world""), ""my_string""); my_file.WriteObject(ROOT.vector[""int""]([1, 2, 3]), ""my vector""). print(my_file[""my_string""]) # new syntax; print(my_file.my_string) # old deprecated syntax. # With the dictionary syntax, you can also use names that don't qualify as; # a Python variable:; print(my_file[""my vector""]); # print(my_file.my vector) # the old syntax would not work here!; The old pythonization with the __getattr__ syntax still works, but emits a deprecation warning and will be removed from ROOT 6.34.; Removal of Python 2 support; ROOT does no longer support Python 2. The minimum Python version necessary to use ROOT in a Python application is 3.8. As a consequence, any reference to Python 2 in ROOT code was removed and certain configuration options are no longer usable, e.g. root-config --python2-version; cmake -Dpyroot-python2. The cmake build system now looks for the standard Python3 package and previously custom Python-related cmake variables are now just the ones automatically produced by cmake (see https://cmake.org/cmake/help/latest/module/FindPython.html).; More usage of the public cppyy API; Many implementation details of the ROOT pythonizations were moved from C++ functions to pure Python bindings using the public cppyy API. This helps in the integration with the tool but also improves code efficiency and memory usage.; Class Reference Guide. Define missing doxygen groups.; Fix a few typos in the THStack documentation.; Small fixes in the THistPainter documentation.; Improve the TColor documentation: use modern C++ in the examples.; Make sure the python examples do not generate wrong namespaces in the documentation.; The dataframe tutorials json spec files were not displayed proper",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:22703,usab,usable,22703,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['usab'],['usable']
Usability,"icular case where volume families are used is when we want; that a volume positioned inside a container to match one ore more container; limits. Suppose we want to position the same box inside 2 different volumes; and we want the Z size to match the one of each container:. TGeoVolume *container1 = gGeoManager->MakeBox(""C1"", imed, 10,10,30);; TGeoVolume *container2 = gGeoManager->MakeBox(""C2"", imed, 10,10,20);; TGeoVolume *pvol = gGeoManager->MakeBox(""PVOL"", jmed, 3,3,-1);; container1->AddNode(pvol, 1);; container2->AddNode(pvol, 1);. Note that the third parameter of PVOL is negative, which does not make sense; as half-length on Z. This is interpreted as: when positioned, create a box; replacing all invalid parameters with the corresponding dimensions of the; container. This is also internally handled by the TGeoVolumeMulti class, which; does not need to be instantiated by users. Dividing volumes. Volumes can be divided according a pattern. The most simple division can; be done along one axis, that can be: X, Y, Z, Phi, Rxy or Rxyz. Let's take; the most simple case: we would like to divide a box in N equal slices along X; coordinate, representing a new volume family. Supposing we already have created; the initial box, this can be done like:. TGeoVolume *slicex = box->Divide(""SLICEX"", 1, N);. where SLICE is the name of the new family representing all slices and 1 is the; slicing axis. The meaning of the axis index is the following: for all volumes; having shapes like box, trd1, trd2, trap, gtra or para - 1,2,3 means X,Y,Z; for; tube, tubs, cone, cons - 1 means Rxy, 2 means phi and 3 means Z; for pcon and; pgon - 2 means phi and 3 means Z; for spheres 1 means R and 2 means phi.; In fact, the division operation has the same effect as positioning volumes; in a given order inside the divided container - the advantage being that the; navigation in such a structure is much faster. When a volume is divided, a; volume family corresponding to the slices is created. In case all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoVolume.html:13029,simpl,simple,13029,root/html534/TGeoVolume.html,https://root.cern,https://root.cern/root/html534/TGeoVolume.html,9,['simpl'],['simple']
Usability,"icular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be writ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:1672,learn,learning,1672,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['learn'],['learning']
Usability,"id *parent)=0Read the information and the weights about the layer from XML node.; TMVA::DNN::VGeneralLayer::UpdateBiasGradientsvoid UpdateBiasGradients(const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate)Updates the bias gradients, given some other weight gradients and learning rate.Definition GeneralLayer.h:448; TMVA::DNN::VGeneralLayer::SetBatchSizevoid SetBatchSize(size_t batchSize)Setters.Definition GeneralLayer.h:217; TMVA::DNN::VGeneralLayer::CopyWeightsvoid CopyWeights(const std::vector< Matrix_t > &otherWeights)Copies the weights provided as an input.Definition GeneralLayer.h:458; TMVA::DNN::VGeneralLayer::fBatchSizesize_t fBatchSizeBatch size used for training and evaluation.Definition GeneralLayer.h:59; TMVA::DNN::VGeneralLayer::AddWeightsXMLTovirtual void AddWeightsXMLTo(void *parent)=0Writes the information and the weights about the layer in an XML node.; TMVA::DNN::VGeneralLayer::UpdateWeightsvoid UpdateWeights(const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate)Updates the weights, given the gradients and the learning rate,.Definition GeneralLayer.h:418; TMVA::DNN::VGeneralLayer::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition GeneralLayer.h:54; TMVA::DNN::VGeneralLayer::GetBiasGradientsconst std::vector< Matrix_t > & GetBiasGradients() constDefinition GeneralLayer.h:190; TMVA::DNN::VGeneralLayer::SetInputDepthvoid SetInputDepth(size_t inputDepth)Definition GeneralLayer.h:218; TMVA::DNN::VGeneralLayer::GetWeightsconst std::vector< Matrix_t > & GetWeights() constDefinition GeneralLayer.h:172; TMVA::DNN::VGeneralLayer::GetDepthsize_t GetDepth() constDefinition GeneralLayer.h:167; TMVA::DNN::VGeneralLayer::GetWeightsstd::vector< Matrix_t > & GetWeights()Definition GeneralLayer.h:173; TMVA::DNN::VGeneralLayer::fWidthsize_t fWidthThe width of this layer.Definition GeneralLayer.h:67; TMVA::DNN::VGeneralLayer::fInitEInitialization fInitThe initialization method.Definition GeneralLayer.h:80; TMVA::DNN:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GeneralLayer_8h_source.html:30194,learn,learningRate,30194,doc/master/GeneralLayer_8h_source.html,https://root.cern,https://root.cern/doc/master/GeneralLayer_8h_source.html,2,['learn'],"['learning', 'learningRate']"
Usability,"id *receiver, const char *slot);  Create connection between sender and receiver. ;  ;  Static Protected Attributes inherited from TQObject; static Bool_t fgAllSignalsBlocked = kFALSE;  flag used for suppression of signals ;  . #include <TQCommand.h>. Inheritance diagram for TQCommand:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TQCommand() [1/3]. TQCommand::TQCommand ; (; const char * ; clname = nullptr, . void * ; obj = nullptr, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; clname - class name.; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments:; if either clname or obj is NULL that means that redo/undo is function; to specify default arguments for redo/undo method/function '=' must precede to argument value. Example: TQCommand(""TPad"", gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case undo parameter can be omitted.; Example: TQCommand(""TPad"", gPad, ""SetFillStyle(Style_t)"");. Definition at line 168 of file TQCommand.cxx. ◆ TQCommand() [2/3]. TQCommand::TQCommand ; (; TObject * ; obj, . const char * ; redo = nullptr, . const char * ; undo = nullptr . ). Constructor. ; Input parameters:; obj - an object; redo - method or function to do/redo operation; undo - method or function to undo operation. Comments: to specify default arguments for redo/undo method/function '=' must precede to argument value.; Example: TQCommand(gPad, ""SetEditable(=kTRUE)"", ""SetEditable(=kFALSE)"");; undo method can be same as redo one. In that case ""undo"" can parameter be omitted.; Example: TQCommand(gPad, ""SetFillStyle(Style_t)"");. Definition at line 199 of file TQCommand.cxx. ◆ TQCommand() [3/3]. TQCommand::TQCommand ; (; const TQCommand & ; com). Copy constructor. ; Definition at line 209 of file TQCommand.cxx. ◆ ~TQComma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:32405,undo,undo,32405,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"id * ; wghtnode). virtual . Implements TMVA::MethodBase.; Definition at line 551 of file MethodKNN.cxx. ◆ Streamer(). virtual void TMVA::MethodKNN::Streamer ; (; TBuffer & ; ). virtual . Reimplemented from TMVA::MethodBase. ◆ StreamerNVirtual(). void TMVA::MethodKNN::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 143 of file MethodKNN.h. ◆ Train(). void TMVA::MethodKNN::Train ; (; void ; ). virtual . kNN training ; Implements TMVA::MethodBase.; Definition at line 234 of file MethodKNN.cxx. ◆ WriteWeightsToStream(). void TMVA::MethodKNN::WriteWeightsToStream ; (; TFile & ; rf); const. save weights to ROOT file ; Definition at line 678 of file MethodKNN.cxx. Member Data Documentation. ◆ fBalanceDepth. Int_t TMVA::MethodKNN::fBalanceDepth. private . number of binary tree levels used for balancing tree ; Definition at line 124 of file MethodKNN.h. ◆ fEvent. kNN::EventVec TMVA::MethodKNN::fEvent. private . ! (untouched) events used for learning ; Definition at line 136 of file MethodKNN.h. ◆ fKernel. TString TMVA::MethodKNN::fKernel. private . =""Gaus"",""Poln"" - kernel type for smoothing ; Definition at line 129 of file MethodKNN.h. ◆ fLDA. LDA TMVA::MethodKNN::fLDA. private . ! Experimental feature for local knn analysis ; Definition at line 138 of file MethodKNN.h. ◆ fModule. kNN::ModulekNN* TMVA::MethodKNN::fModule. private . ! module where all work is done ; Definition at line 121 of file MethodKNN.h. ◆ fnkNN. Int_t TMVA::MethodKNN::fnkNN. private . number of k-nearest neighbors ; Definition at line 123 of file MethodKNN.h. ◆ fScaleFrac. Float_t TMVA::MethodKNN::fScaleFrac. private . fraction of events used to compute variable width ; Definition at line 126 of file MethodKNN.h. ◆ fSigmaFact. Float_t TMVA::MethodKNN::fSigmaFact. private . scale factor for Gaussian sigma in Gaus. kernel ; Definition at line 127 of file MethodKNN.h. ◆ fSumOfWeightsB. Double_t TMVA::MethodKNN::fSumOfWeightsB. private . sum-of-weights for backgrou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodKNN.html:36982,learn,learning,36982,doc/master/classTMVA_1_1MethodKNN.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodKNN.html,1,['learn'],['learning']
Usability,"id DrawEventStatus(Int_t event, Int_t x, Int_t y, TObject* selected); Report name and title of primitive below the cursor. This function is called when the option ""Event Status""; in the canvas menu ""Options"" is selected. void EditorBar(); Get editor bar. void EmbedInto(Int_t winid, Int_t ww, Int_t wh); Embedded a canvas into a TRootEmbeddedCanvas. This method is only called; via TRootEmbeddedCanvas::AdoptCanvas. void EnterLeave(TPad* prevSelPad, TObject* prevSelObj); Generate kMouseEnter and kMouseLeave events depending on the previously; selected object and the currently selected object. Does nothing if the; selected object does not change. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to one event. This member function must be implemented to realize the action; corresponding to the mouse click on the object in the canvas. Only handle mouse motion events in TCanvas, all other events are; ignored for the time being. void FeedbackMode(Bool_t set); Turn rubberband feedback mode on or off. void Flush(); Flush canvas buffers. void UseCurrentStyle(); Force a copy of current style for all objects in canvas. Int_t GetWindowTopX(); Returns current top x position of window on screen. Int_t GetWindowTopY(); Returns current top y position of window on screen. void HandleInput(EEventType button, Int_t x, Int_t y); Handle Input Events. Handle input events, like button up/down in current canvas. Bool_t IsFolder() const; Is folder ?. void ls(Option_t* option = """") const; List all pads. TCanvas * MakeDefCanvas(); Static function to build a default canvas. void MoveOpaque(Int_t set = 1); Set option to move objects/pads in a canvas. if set = 1 (default) graphics objects are moved in opaque mode; = 0 only the outline of objects is drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCanvas.html:39591,feedback,feedback,39591,root/html526/TCanvas.html,https://root.cern,https://root.cern/root/html526/TCanvas.html,7,['feedback'],['feedback']
Usability,"id RGeomDescription::ProduceDrawData(); 1359{; 1360 auto json = ProduceJson();; 1361 ; 1362 TLockGuard lock(fMutex);; 1363 ; 1364 fDrawJson = ""GDRAW:""s + json;; 1365}; 1366 ; 1367/////////////////////////////////////////////////////////////////////; 1368/// Clear raw data. Will be rebuild when next connection will be established; 1369 ; 1370void RGeomDescription::ClearDrawData(); 1371{; 1372 TLockGuard lock(fMutex);; 1373 ; 1374 fDrawJson.clear();; 1375 fSearchJson.clear();; 1376}; 1377 ; 1378/////////////////////////////////////////////////////////////////////; 1379/// Clear cached data, need to be clear when connection broken; 1380 ; 1381void RGeomDescription::ClearCache(); 1382{; 1383 ClearDrawData();; 1384 ; 1385 TLockGuard lock(fMutex);; 1386 fShapes.clear();; 1387 fSearch.clear();; 1388}; 1389 ; 1390/////////////////////////////////////////////////////////////////////; 1391/// return true when node used in main geometry drawing and does not have childs; 1392/// for such nodes one could provide optimize toggling of visibility flags; 1393 ; 1394bool RGeomDescription::IsPrincipalEndNode(int nodeid); 1395{; 1396 TLockGuard lock(fMutex);; 1397 ; 1398 if ((nodeid < 0) || (nodeid >= (int)fDesc.size())); 1399 return false;; 1400 ; 1401 auto &desc = fDesc[nodeid];; 1402 ; 1403 return (desc.sortid < fDrawIdCut) && desc.IsVisible() && desc.CanDisplay() && (desc.chlds.empty());; 1404}; 1405 ; 1406/////////////////////////////////////////////////////////////////////; 1407/// Search visible nodes for provided name; 1408/// If number of found elements less than 100, create description and shapes for them; 1409/// Returns number of match elements; 1410 ; 1411int RGeomDescription::SearchVisibles(const std::string &find, std::string &hjson, std::string &json); 1412{; 1413 TLockGuard lock(fMutex);; 1414 ; 1415 hjson.clear();; 1416 json.clear();; 1417 ; 1418 if (find.empty()) {; 1419 hjson = ""FOUND:RESET"";; 1420 return 0;; 1421 }; 1422 ; 1423 std::vector<int> nodescnt(fDesc.size()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RGeomData_8cxx_source.html:41969,clear,clear,41969,doc/master/RGeomData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RGeomData_8cxx_source.html,2,['clear'],['clear']
Usability,"id RooMinimizer::setRecoverFromNaNStrength ; (; double ; strength). Try to recover from invalid function values. ; When invalid function values are encountered, a penalty term is returned to the minimiser to make it back off. This sets the strength of this penalty. NoteA strength of zero is equivalent to a constant penalty (= the gradient vanishes, ROOT < 6.24). Positive values lead to a gradient pointing away from the undefined regions. Use ~10 to force the minimiser away from invalid function values. ; Definition at line 802 of file RooMinimizer.cxx. ◆ setStrategy(). void RooMinimizer::setStrategy ; (; int ; istrat). Change MINUIT strategy to istrat. ; Accepted codes are 0,1,2 and represent MINUIT strategies for dealing most efficiently with fast FCNs (0), expensive FCNs (2) and 'intermediate' FCNs (1) ; Definition at line 189 of file RooMinimizer.cxx. ◆ setVerbose(). void RooMinimizer::setVerbose ; (; bool ; flag = true). inline . Definition at line 153 of file RooMinimizer.h. ◆ simplex(). int RooMinimizer::simplex ; (; ). Execute SIMPLEX. ; Changes in parameter values and calculated errors are automatically propagated back the RooRealVars representing the floating parameters in the MINUIT operation. ; Definition at line 453 of file RooMinimizer.cxx. ◆ Streamer(). void RooMinimizer::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void RooMinimizer::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 247 of file RooMinimizer.h. ◆ update(). bool RooMinimizer::update ; (; bool ; isValid). private . Definition at line 1100 of file RooMinimizer.cxx. ◆ updateErrors(). void RooMinimizer::updateErrors ; (; ). private . Definition at line 1129 of file RooMinimizer.cxx. ◆ updateFitConfig(). void RooMinimizer::updateFitConfig ; (; ). private . Definition at line 1013 of file RooMinimizer.cxx. ◆ updateMinimizerOptions(). bool RooMinimizer::updateMi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMinimizer.html:29552,simpl,simplex,29552,doc/master/classRooMinimizer.html,https://root.cern,https://root.cern/doc/master/classRooMinimizer.html,1,['simpl'],['simplex']
Usability,id TMVA::TSynapse::SetLearningRate ; (; Double_t ; rate). inline . Definition at line 56 of file TSynapse.h. ◆ SetPostNeuron(). void TMVA::TSynapse::SetPostNeuron ; (; TNeuron * ; post). inline . Definition at line 68 of file TSynapse.h. ◆ SetPreNeuron(). void TMVA::TSynapse::SetPreNeuron ; (; TNeuron * ; pre). inline . Definition at line 65 of file TSynapse.h. ◆ SetWeight(). void TMVA::TSynapse::SetWeight ; (; Double_t ; weight). set synapse weight ; Definition at line 68 of file TSynapse.cxx. ◆ Streamer(). virtual void TMVA::TSynapse::Streamer ; (; TBuffer & ; R__b). virtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TMVA::TSynapse::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 101 of file TSynapse.h. Member Data Documentation. ◆ fCount. Int_t TMVA::TSynapse::fCount. private . number of updates contributing to error field ; Definition at line 95 of file TSynapse.h. ◆ fDEDw. Double_t TMVA::TSynapse::fDEDw. private . sum of deltas ; Definition at line 94 of file TSynapse.h. ◆ fDelta. Double_t TMVA::TSynapse::fDelta. private . local error field ; Definition at line 93 of file TSynapse.h. ◆ fLearnRate. Double_t TMVA::TSynapse::fLearnRate. private . learning rate parameter ; Definition at line 92 of file TSynapse.h. ◆ fPostNeuron. TNeuron* TMVA::TSynapse::fPostNeuron. private . pointer to post-neuron ; Definition at line 97 of file TSynapse.h. ◆ fPreNeuron. TNeuron* TMVA::TSynapse::fPreNeuron. private . pointer to pre-neuron ; Definition at line 96 of file TSynapse.h. ◆ fWeight. Double_t TMVA::TSynapse::fWeight. private . weight of the synapse ; Definition at line 91 of file TSynapse.h. Libraries for TMVA::TSynapse:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/TSynapse.h; tmva/tmva/src/TSynapse.cxx. TMVATSynapse. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:44 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSynapse.html:15216,learn,learning,15216,doc/master/classTMVA_1_1TSynapse.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSynapse.html,1,['learn'],['learning']
Usability,"id TQCommand::SetArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set do/redo and undo parameters. ; The format is SetArgs(number_of_params, redo_params, undo_params); Example: move_command->SetArgs(2, 100, 100, 200, 200);; 2 params, (100,100) - do/redo position, (200,200) - undo position ; Definition at line 465 of file TQCommand.cxx. ◆ SetName(). void TQCommand::SetName ; (; const char * ; name). virtual . Sets name of the command. ; Definition at line 832 of file TQCommand.cxx. ◆ SetRedoArgs(). void TQCommand::SetRedoArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set redo parameters. ; The format is SetRedoArgs(number_of_params, params); Example: move_command->SetRedoArgs(2, 100, 100);. Definition at line 508 of file TQCommand.cxx. ◆ SetTitle(). void TQCommand::SetTitle ; (; const char * ; title). virtual . Sets description of the command. ; Definition at line 840 of file TQCommand.cxx. ◆ SetUndoArgs(). void TQCommand::SetUndoArgs ; (; Int_t ; narg, .  ; ... . ). virtual . Set undo parameters. ; The format is SetUndoArgs(number_of_params, params); Example: move_command->SetUndoArgs(2, 200, 200);. Definition at line 542 of file TQCommand.cxx. ◆ Streamer(). void TQCommand::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from TList.; Reimplemented in TQUndoManager. ◆ StreamerNVirtual(). void TQCommand::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 98 of file TQCommand.h. ◆ Undo(). void TQCommand::Undo ; (; Option_t * ; option = """"). virtual . Un-execute all merged commands and the command. ; Merged commands are executed in reverse order. ; Reimplemented in TQUndoManager.; Definition at line 626 of file TQCommand.cxx. Friends And Related Symbol Documentation. ◆ TQUndoManager. friend class TQUndoManager. friend . Definition at line 29 of file TQCommand.h. Member Data Documentation. ◆ fName. TString TQCommand::fName. protected . Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:43522,undo,undo,43522,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"id);; 2004 Int_t ind = pidslist->IndexOf(pid);; 2005 pid->SetUniqueID((UInt_t)ind);; 2006 }; 2007 ; 2008 return pid;; 2009}; 2010 ; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72383,usab,usable,72383,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['usab'],['usable']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:3140,clear,clearEvalErrorLog,3140,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooDecay.html:2629,clear,clearEvalErrorLog,2629,root/html532/RooDecay.html,https://root.cern,https://root.cern/root/html532/RooDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBCPEffDecay.html:2931,clear,clearEvalErrorLog,2931,root/html532/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html532/RooBCPEffDecay.html,4,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:2829,clear,clearEvalErrorLog,2829,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgusBG.html:2653,clear,clearEvalErrorLog,2653,root/html532/RooArgusBG.html,https://root.cern,https://root.cern/root/html532/RooArgusBG.html,49,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:4125,clear,clearEvalErrorLog,4125,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:3225,clear,clearEvalErrorLog,3225,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedPdf.html:3225,clear,clearEvalErrorLog,3225,root/html530/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedPdf.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tRooAbsAnaConvPdf::coefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDecay.html:2629,clear,clearEvalErrorLog,2629,root/html528/RooDecay.html,https://root.cern,https://root.cern/root/html528/RooDecay.html,2,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*RooAbsAnaConvPdf::coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBCPEffDecay.html:2931,clear,clearEvalErrorLog,2931,root/html528/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html528/RooBCPEffDecay.html,8,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooBDecay.html:2829,clear,clearEvalErrorLog,2829,root/html528/RooBDecay.html,https://root.cern,https://root.cern/root/html528/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual Double_tcoefficient(Int_t basisIndex) const; virtual RooArgSet*coefVars(Int_t coefIdx) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooBDecay.html:2829,clear,clearEvalErrorLog,2829,root/html530/RooBDecay.html,https://root.cern,https://root.cern/root/html530/RooBDecay.html,1,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg arg1, const RooCmdArg arg2 = RooCmdArg::none(), const RooCmdArg arg3 = RooCmdArg::none(), const RooCmdArg arg4 = RooCmdArg::none(), const RooCmdArg arg5 = RooCmdArg::none(), const RooCmdArg arg6 = RooCmdArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooArgusBG.html:2653,clear,clearEvalErrorLog,2653,root/html528/RooArgusBG.html,https://root.cern,https://root.cern/root/html528/RooArgusBG.html,46,['clear'],['clearEvalErrorLog']
Usability,"idRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); RooAbsReal*RooAbsPdf::createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooExtendPdf.html:3178,clear,clearEvalErrorLog,3178,root/html528/RooExtendPdf.html,https://root.cern,https://root.cern/root/html528/RooExtendPdf.html,60,['clear'],['clearEvalErrorLog']
Usability,"idateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse succesfull; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fValidateError; }. const char * GetVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLParser.html:10894,clear,clear,10894,root/html528/TXMLParser.html,https://root.cern,https://root.cern/root/html528/TXMLParser.html,3,['clear'],['clear']
Usability,"idateto validate the parse context; TStringfValidateErrorparse error; TStringfValidateWarningparse warning; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TXMLParser(); Cleanup. void SetValidate(Bool_t val = kTRUE); The parser will validate the xml file if val = true. void SetReplaceEntities(Bool_t val = kTRUE); The parser will replace/expand entities. void ReleaseUnderlying(); To release any existing document. void OnValidateError(const TString& message); This function is called when an error from the parser has occured.; Message is the parse error. void OnValidateWarning(const TString& message); This function is called when a warning from the parser has occured.; Message is the parse error. const char * GetParseCodeMessage(Int_t parseCode) const; Returns the parse code message. void InitializeContext(); Initialize parser parameters, such as, disactivate non-standards libxml1; features, on/off validation, clear error and warning messages. void StopParser(); Stops parsing. void SetParseCode(Int_t code); Set the parse code:; 0: Parse successful; -1: Attempt to parse a second file while a parse is in progress; -2: Parse context is not created; -3: An error occured while parsing file; -4: A fatal error occured while parsing file; -5: Document is not well-formed. void SetStopOnError(Bool_t stop = kTRUE); Set parser stops in case of error:; stop = true, stops on error; stop = false, continue parsing on error... TXMLParser& operator=(const TXMLParser& ). Bool_t GetValidate() const; { return fValidate; }. Bool_t GetReplaceEntities() const; { return fReplaceEntities; }. Int_t ParseFile(const char* filename). Int_t ParseBuffer(const char* contents, Int_t len). Int_t GetParseCode() const; { return fParseCode; }. Bool_t GetStopOnError() const; { return fStopError; }. const char * GetValidateError() const; { return fValidateError; }. const char * GetVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXMLParser.html:10982,clear,clear,10982,root/html534/TXMLParser.html,https://root.cern,https://root.cern/root/html534/TXMLParser.html,1,['clear'],['clear']
Usability,"ide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofProgressMemoryPlot Class ReferenceGUI » Session Viewer. ; This class implements a dialog, used to display the memory footprint on the proof workers and master. ; For the workers, memory is plotted as a function of number of events processed. For the master, it is plotted as a function of number of objects merged ; Definition at line 28 of file TProofProgressMemoryPlot.h. Public Member Functions;  TProofProgressMemoryPlot (TProofProgressDialog *d, Int_t w=700, Int_t h=300);  Main constructor. ;  ;  ~TProofProgressMemoryPlot () override;  Destructor. ;  ; void Clear (Option_t *=nullptr) override;  Clear the canvases. ;  ; void DoPlot ();  Draw the plot from the logs. ;  ; void Select (Int_t id);  actions of select all/clear all button ;  ;  Public Member Functions inherited from TGTransientFrame;  TGTransientFrame (const TGWindow *p=nullptr, const TGWindow *main=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a transient window. ;  ; virtual void CenterOnParent (Bool_t croot=kTRUE, EPlacement pos=kCenter);  Position transient frame centered relative to the parent frame. ;  ; const TGWindow * GetMain () const;  ; TClass * IsA () const override;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save a transient frame widget as a C++ statement(s) on output stream out. ;  ; void SaveSource (const char *filename=""Rootdlog.C"", Option_t *option="""") override;  Save the GUI transient frame widget in a C++ macro file. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGMainFrame;  TGMainFrame (const TGWindow *p=nullptr, UInt_t w=1, UInt_t h=1, UInt_t options=kVerticalFrame);  Create a top level main frame. ;  ;  ~TGMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofProgressMemoryPlot.html:989,clear,clear,989,doc/master/classTProofProgressMemoryPlot.html,https://root.cern,https://root.cern/doc/master/classTProofProgressMemoryPlot.html,1,['clear'],['clear']
Usability,"ide ; .  . Loading...; Searching...; No Matches. hsimpleReader.C File ReferenceTutorials » Tree tutorials. Detailed Description; TTreeReader simplest example. ; Read data from hsimple.root (written by hsimple.C); ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h""; ; void hsimpleReader() {; // Create a histogram for the values we read.; auto myHist = new TH1F(""h1"",""ntuple"",100,-4,4);; ; // Open the file containing the tree.; auto myFile = TFile::Open(""hsimple.root"");; if (!myFile || myFile->IsZombie()) {; return;; }; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);; ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");; ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; }; ; myHist->Draw();; }; TFile.h; TH1F.h; TTreeReaderValue.h; TTreeReader.h; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TTreeReaderValueAn interface for reading values stored in ROOT columnar datasets.Definition TTreeReaderValue.h:174; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; AuthorAnders Eie, 2013 ; Definition in file hsimpleReader.C. tutorialstreehsimpleReader.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:31 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimpleReader_8C.html:1769,simpl,simple,1769,doc/master/hsimpleReader_8C.html,https://root.cern,https://root.cern/doc/master/hsimpleReader_8C.html,1,['simpl'],['simple']
Usability,"ideEmit signals.Definition TGButton.cxx:1262; TGCheckButton::SetStatevoid SetState(EButtonState state, Bool_t emit=kFALSE) overrideSet check button state.Definition TGButton.cxx:1250; TGCheckButton::fPrevStateEButtonState fPrevStateprevious check button stateDefinition TGButton.h:272; TGCheckButton::DoRedrawvoid DoRedraw() overrideDraw the check button widget.Definition TGButton.cxx:1437; TGCheckButton::fDisOffconst TGPicture * fDisOffbutton disabled and was OFF pictureDefinition TGButton.h:276; TGCheckButton::fDisOnconst TGPicture * fDisOnbutton disabled and was ON pictureDefinition TGButton.h:275; TGCheckButton::GetDefaultSizeTGDimension GetDefaultSize() const overridedefault sizeDefinition TGButton.cxx:1236; TGCheckButton::PSetStatevoid PSetState(EButtonState state, Bool_t emit)Set check button state.Definition TGButton.cxx:1273; TGDimensionDefinition TGDimension.h:18; TGFontEncapsulate fonts used in the GUI system.Definition TGFont.h:140; TGFrameA subclasses of TGWindow, and is used as base class for some simple widgets (buttons,...Definition TGFrame.h:80; TGGCEncapsulate a graphics context used in the low level graphics.Definition TGGC.h:22; TGHotStringTGHotString is a string with a ""hot"" character underlined.Definition TGString.h:42; TGPictureButtonYield an action as soon as it is clicked.Definition TGButton.h:228; TGPictureButton::SetPicturevirtual void SetPicture(const TGPicture *new_pic)Change a picture in a picture button.Definition TGButton.cxx:1040; TGPictureButton::CreateDisabledPicturevirtual void CreateDisabledPicture()Creates disabled picture.Definition TGButton.cxx:1108; TGPictureButton::GetDisabledPictureconst TGPicture * GetDisabledPicture() constDefinition TGButton.h:257; TGPictureButton::SetDisabledPicturevirtual void SetDisabledPicture(const TGPicture *pic)Changes disabled picture.Definition TGButton.cxx:1135; TGPictureButton::GetPictureconst TGPicture * GetPicture() constDefinition TGButton.h:256; TGPictureButton::SavePrimitivevoid SavePrimiti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGButton_8h_source.html:28090,simpl,simple,28090,doc/master/TGButton_8h_source.html,https://root.cern,https://root.cern/doc/master/TGButton_8h_source.html,1,['simpl'],['simple']
Usability,"idth increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2010-09-23 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGUndockedFrame.html:22162,undo,undocked,22162,root/html528/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html528/TGUndockedFrame.html,4,['undo'],['undocked']
Usability,"idth increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-07-04 15:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGUndockedFrame.html:22315,undo,undocked,22315,root/html530/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html530/TGUndockedFrame.html,4,['undo'],['undocked']
Usability,"idth increments; Int_tTGMainFrame::fWMXWM x position; Int_tTGMainFrame::fWMYWM y position; UInt_tTGFrame::fWidthframe width; TStringTGMainFrame::fWindowNamewindow name; Int_tTGFrame::fXframe x position; Int_tTGFrame::fYframe y position; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static const TGGC*TGFrame::fgBckgndGC; static const TGGC*TGFrame::fgBlackGC; static Pixel_tTGFrame::fgBlackPixel; static Int_tTGWindow::fgCountercounter of created windows in SavePrimitive; static Window_tTGFrame::fgDbw; static Int_tTGFrame::fgDbx; static Int_tTGFrame::fgDby; static Pixel_tTGFrame::fgDefaultFrameBackground; static TGLayoutHints*TGCompositeFrame::fgDefaultHintsdefault hints used by AddFrame(); static Pixel_tTGFrame::fgDefaultSelectedBackground; static const TGGC*TGFrame::fgHilightGC; static Bool_tTGFrame::fgInit; static UInt_tTGFrame::fgLastButton; static Time_tTGFrame::fgLastClick; static const TGGC*TGFrame::fgShadowGC; static UInt_tTGFrame::fgUserColor; static const TGGC*TGFrame::fgWhiteGC; static Pixel_tTGFrame::fgWhitePixel. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGUndockedFrame(const TGWindow* p = 0, TGDockableFrame* dockable = 0); Create the undocked (transient) frame. ~TGUndockedFrame(); Delete undocked frame. Puts back dockable frame in its original container. void FixSize(); Fix the size of the undocked frame so it cannot be changed via the WM. void CloseWindow(); Close undocked frame (called via WM close button). TGUndockedFrame(const TGUndockedFrame& ). TGUndockedFrame& operator=(const TGUndockedFrame& ). » Author: Abdelhalim Ssadik 07/07/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/gui:$Id: TGDockableFrame.h 23256 2008-04-16 14:13:50Z antcheva $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGUndockedFrame.html:22315,undo,undocked,22315,root/html532/TGUndockedFrame.html,https://root.cern,https://root.cern/root/html532/TGUndockedFrame.html,4,['undo'],['undocked']
Usability,"iduals"" of at least ""improvement"" ; this gives a simple measure of if the estimator of the MLP is converging and no major improvement is to be expected. ; Definition at line 66 of file ConvergenceTest.cxx. ◆ Progress(). Float_t TMVA::ConvergenceTest::Progress ; (; ). returns a float from 0 (just started) to 1 (finished) ; Definition at line 91 of file ConvergenceTest.cxx. ◆ ResetConvergenceCounter(). void TMVA::ConvergenceTest::ResetConvergenceCounter ; (; ). inline . Definition at line 58 of file ConvergenceTest.h. ◆ SetConvergenceParameters(). void TMVA::ConvergenceTest::SetConvergenceParameters ; (; Int_t ; steps, . Double_t ; improvement . ). inline . Definition at line 54 of file ConvergenceTest.h. ◆ SetCurrentValue(). void TMVA::ConvergenceTest::SetCurrentValue ; (; Float_t ; value). inline . Definition at line 56 of file ConvergenceTest.h. ◆ SpeedControl(). Float_t TMVA::ConvergenceTest::SpeedControl ; (; UInt_t ; ofSteps). this function provides the ability to change the learning rate according to the success of the last generations. ; Parameters:. int ofSteps : = if OF the number of STEPS given in this variable (ofSteps) the rate of improvement has to be calculated. using this function one can increase the stepSize of the mutation when we have good success (to pass fast through the easy phase-space) and reduce the learning rate if we are in a difficult ""territory"" of the phase-space. ; Definition at line 112 of file ConvergenceTest.cxx. Member Data Documentation. ◆ fBestResult. Float_t TMVA::ConvergenceTest::fBestResult. private . Definition at line 81 of file ConvergenceTest.h. ◆ fConvValue. Float_t TMVA::ConvergenceTest::fConvValue. private . ! the best ""fitness"" value ; Definition at line 76 of file ConvergenceTest.h. ◆ fCounter. Int_t TMVA::ConvergenceTest::fCounter. private . ! counts the number of steps without improvement ; Definition at line 75 of file ConvergenceTest.h. ◆ fCurrentValue. Float_t TMVA::ConvergenceTest::fCurrentValue. protected . ! cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html:3498,learn,learning,3498,doc/master/classTMVA_1_1ConvergenceTest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html,1,['learn'],['learning']
Usability,"id SetNotify (TObject *obj);  Sets the address of the object to be notified when the tree is loaded. ;  ; virtual void SetObject (const char *name, const char *title);  Change the name and title of this tree. ;  ; virtual void SetParallelUnzip (bool opt=true, Float_t RelSize=-1);  Enable or disable parallel unzipping of Tree buffers. ;  ; virtual void SetPerfStats (TVirtualPerfStats *perf);  Set perf stats. ;  ; virtual void SetScanField (Int_t n=50);  ; void SetTargetMemoryRatio (Float_t ratio);  ; virtual void SetTimerInterval (Int_t msec=333);  ; virtual void SetTreeIndex (TVirtualIndex *index);  The current TreeIndex is replaced by the new index. ;  ; virtual void SetUpdate (Int_t freq=0);  ; virtual void SetWeight (Double_t w=1, Option_t *option="""");  Set tree weight. ;  ; virtual void Show (Long64_t entry=-1, Int_t lenmax=20);  Print values of all active leaves for entry. ;  ; virtual void StartViewer ();  Start the TTreeViewer on this tree. ;  ; virtual Int_t StopCacheLearningPhase ();  Stop the cache learning phase. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual Int_t UnbinnedFit (const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0);  Unbinned fit of one or more variable(s) from a tree. ;  ; void UseCurrentStyle () override;  Replace current attributes by current style. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const override;  Write this object to the current directory. ;  ; Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) override;  Write this object to the current directory. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:41636,learn,learning,41636,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['learn'],['learning']
Usability,"ied entries; *-* ===========================================. This function accepts TCut objects as arguments.; Useful to use the string operator +; example:; table.Draw(""x"",cut1+cut2+cut3);. TCutG object with ""CUTG"" name can be created via the graphics editor. TH1 * Draw(const char* varexp, const char* selection, Option_t* option = """", Int_t nentries = 1000000000, Int_t firstentry = 0); *-*-*-*-*-*Draw expression varexp for specified entries; *-* ===========================================. varexp is an expression of the general form e1:e2:e3; where e1,etc is a C++ expression referencing a combination of the TTable columns; One can use two extra meta variable ""i$"" and ""n$"" along with the table; column names.; i$ is to involve the current row number; n$ refers the total num,ber of rows of this table provided by TTable::GetNRows(). Example:; varexp = x simplest case: draw a 1-Dim distribution of column named x; = sqrt(x) : draw distribution of sqrt(x); = x*y/z; = y:sqrt(x) 2-Dim dsitribution of y versus sqrt(x); = i$:sqrt(x) 2-Dim dsitribution of i versus sqrt(x[i]); = phep[0]:sqrt(phep[3]) 2-Dim dsitribution of phep[0] versus sqrt(phep[3]). Note that the variables e1, e2 or e3 may contain a boolean expression as well.; example, if e1= x*(y<0), the value histogrammed will be x if y<0; and will be 0 otherwise. selection is a C++ expression with a combination of the columns.; The value corresponding to the selection expression is used as a weight; to fill the histogram.; If the expression includes only boolean operations, the result; is 0 or 1. If the result is 0, the histogram is not filled.; In general, the expression may be of the form:. value*(boolean expression). if boolean expression is true, the histogram is filled with; a weight = value.; Examples:; selection1 = ""x<y && sqrt(z)>3.2 && 6 < i$ && i$ < n$""; selection2 = ""(x+y)*(sqrt(z)>3.2""; selection3 = ""signal*(log(signal)>1.2)""; selection1 returns a weigth = 0 or 1; selection2 returns a weight = x+y if sqrt(z)>",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTable.html:20233,simpl,simplest,20233,root/html528/TTable.html,https://root.cern,https://root.cern/root/html528/TTable.html,6,['simpl'],['simplest']
Usability,"ied with the fraction that; is in the current range w.r.t the reference range. void selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of observables; for interpretation of fraction coefficients. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of fraction coefficients. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return specialized context to efficiently generate toy events from RooAddPdfs; return RooAbsPdf::genContext(vars,prototype,auxProto,verbose) ; // WVE DEBUG. std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Loop over components for plot sampling hints and merge them if there are multiple. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooAddPdf to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooAddPdf(*this,newname) ; }. Bool_t forceAnalyticalInt(const RooAbsArg& ) const; Force RooRealIntegral to offer all observables for internal integration. Bool_t selfNormalized() const; P.d.f is self normalized. ExtendMode extendMode() const; Return extended mode capabilities. Double_t expectedEvents(const RooArgSet* nset). const RooArgList& pdfList() const; Return list of component p.d.fs. const RooArgList& coefList() const; Return list of coefficients of component p.d.f.s. CacheElem* getProjCache(const RooArgSet* nset, const RooArgSet* iset = 0, const char* rangeName = 0) const. » Last changed: Mon Dec 7 13:45:56 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:47043,intuit,intuitively,47043,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['intuit'],['intuitively']
Usability,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The ""Undo"" button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the ""Undo"" does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable. Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object. Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button ""Position"" allows editing the positioning matrix of a given node. Setting volume properties and modifying volume hierarchy. Visualization. This category allow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:141881,undo,undoable,141881,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['undo'],['undoable']
Usability,"ied. Once the apply button is pressed, the changes are applied to the edited shape and drawn. The “Undo” button becomes active after the first modification has been applied. It allows restoring the initial parameters of the shape.; NOTE: In this version the “Undo” does not allow restoring an intermediate state of the parameters that was applied - it will always restore the parameters at the moment the shape was edited.; All material properties changes are undoable. The mixture editor currently allows adding elements one by one in the mixture composition. This can be done either by element weight fraction or by number of atoms. Once an element was added using one method the other method is not selectable anymore. Summing component fractions up to 1 in the final mixture is the user responsibility. Adding materials as components of a mixture is not supported in this version.; The elements that were added to the mixture appear in the bottom of the mixture editor. The operations performed on mixture are not undoable.; 18.11.4 Creation of New Objects; As described above, all geometry object creators are accessible within the geometry manager editor frame. Generally, if the new object that needs to be created does not depend on other objects, it will be built with a set of default parameters. This is the case for all shapes (except composite shapes) and matrices. For all the other objects the interface forces the selection of components before creating the object.; 18.11.5 Editing Volumes; Volumes are hierarchical components in the geometry, therefore their editor is more complex. It provides the following functionalities:. General. This category allows changing the name of the volume and selecting other shape or medium among existing ones.; Daughters. The category allows removing existing daughter nodes or adding new ones. The button “Position” allows editing the positioning matrix of a given node. . Visualization. This category allows changing the visibility of the edite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1037458,undo,undoable,1037458,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['undo'],['undoable']
Usability,iency of the filters applied ;  df004_cutFlowReport.pyThis tutorial shows how to get information about the efficiency of the filters applied ;  df005_fillAnyObject.C This tutorial shows how to fill any object the class of which exposes a Fill method ;  df006_ranges.C This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df006_ranges.py This tutorial shows how to express the concept of ranges when working with the RDataFrame ;  df007_snapshot.C This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df007_snapshot.py This tutorial shows how to write out datasets in ROOT formatusing the RDataFrame ;  df008_createDataSetFromScratch.C This tutorial shows how to create a dataset from scratch with RDataFrame ;  df008_createDataSetFromScratch.py This tutorial shows how to create a dataset from scratch with RDataFrame ;  df009_FromScratchVSTTree.C This tutorial illustrates how simpler it can be to use a RDataFrame to create a dataset with respect to the usage of the TTree interfaces ;  df010_trivialDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df010_trivialDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df011_ROOTDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df012_DefinesAndFiltersAsStrings.C ;  df012_DefinesAndFiltersAsStrings.py ;  df013_InspectAnalysis.C Showcase registration of callback functions that act on partial results while the event-loop is running using OnPartialResult and OnPartialResultSlot ;  df014_CSVDataSource.C This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df014_CSVDataSource.py This tutorial illustrates how use the RDataFrame in combination with a RDataSource ;  df015_LazyDataSource.C Thi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v614/files.html:99030,simpl,simpler,99030,doc/v614/files.html,https://root.cern,https://root.cern/doc/v614/files.html,1,['simpl'],['simpler']
Usability,"ientAttributes() const; Return set of transient boolean attributes. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Sat Oct 9 22:38:27 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsArg.html:40771,clear,clearValueDirty,40771,root/html528/RooAbsArg.html,https://root.cern,https://root.cern/root/html528/RooAbsArg.html,2,['clear'],"['clearShapeDirty', 'clearValueDirty']"
Usability,"ier(float* working_space, Int_t num, Int_t hartley, Int_t direction, Int_t zt_clear). AUXILIARY FUNCION. This function calculates Fourier based transform of a part of data; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -hartley-1 if it is Hartley transform, 0 othewise; -direction-forward or inverse transform. void BitReverseHaar(float* working_space, Int_t shift, Int_t num, Int_t start). AUXILIARY FUNCION. This function carries out bir-reverse reordering for Haar transform; Function parameters:; -working_space-pointer to vector of processed data; -shift-shift of position of processing; -start-initial position of processed data; -num-length of processed data. int GeneralExe(float* working_space, Int_t zt_clear, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates generalized (mixed) transforms of different degrees; Function parameters:; -working_space-pointer to vector of transformed data; -zt_clear-flag to clear imaginary data before staring; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). int GeneralInv(float* working_space, Int_t num, Int_t degree, Int_t type). AUXILIARY FUNCION. This function calculates inverse generalized (mixed) transforms; Function parameters:; -working_space-pointer to vector of transformed data; -num-length of processed data; -degree-degree of transform (see manual); -type-type of mixed transform (see manual). void Transform(const float* source, float* destVector). ONE-DIMENSIONAL TRANSFORM FUNCTION; This function transforms the source spectrum. The calling program; should fill in input parameters.; Transformed data are written into dest spectrum. Function parameters:; source-pointer to the vector of source spectrum, its length should; be size except for inverse FOURIER, FOUR-WALSH, FOUR-HAAR; transform. These need 2*size length to supply real and; imaginary coefficients.; destVector-p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrumTransform.html:10461,clear,clear,10461,root/html528/TSpectrumTransform.html,https://root.cern,https://root.cern/root/html528/TSpectrumTransform.html,4,['clear'],['clear']
Usability,"ies column lower-bound index. SetColIndexArray (Int_t *data); for sparse matrices, set the column index. The array data should contains at least fNelems entries. SetSparseIndex (Int_t nelems new); allocate memory for a sparse map of nelems_new elements and copy (if exists) at most nelems_new matrix elements over to the new structure. SetSparseIndex (const TMatrixDBase &a); copy the sparse map from matrix a Note that this can be a dense matrix!. SetSparseIndexAB (const TMatrixDSparse &a, const TMatrixDSparse &b); set the sparse map to the same of the map of matrix a and b. The second half of the table is only relevant for sparse matrices. These methods define the sparse structure. It should be clear that a call to any of these methods has to be followed by a SetMatrixArray (…) which will supply the matrix data, see the next chapter “Creating and Filling a Matrix”.; 14.3 Creating and Filling a Matrix; The matrix constructors are listed in the next table. In the simplest ones, only the number of rows and columns is given. In a slightly more elaborate version, one can define the row and column index range. Finally, one can also define the matrix data in the constructor. In Matrix Operators and Methods we will encounter more fancy constructors that will allow arithmetic operations. TMatrixD(Int_t nrows,Int_t ncols); TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb); TMatrixD(Int_t nrows,Int_t ncols,const Double_t *data, Option_t option= """"); TMatrixD(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,; const Double_t *data,Option_t *option=""""). TMatrixDSym(Int_t nrows); TMatrixDSym(Int_t row_lwb,Int_t row_upb); TMatrixDSym(Int_t nrows,const Double_t *data,Option_t *option=""""); TMatrixDSym(Int_t row_lwb,Int_t row_upb,const Double_t *data, Option_t *opt=""""). TMatrixDSparse(Int_t nrows,Int_t ncols); TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb, Int_t col_upb ); TMatrixDSparse(Int_t row_lwb,Int_t row_upb,Int_t col_lwb,Int_t col_upb,; Int_t nr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:775040,simpl,simplest,775040,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simplest']
Usability,"ies the mask and the values to be set. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 3012 of file TGCocoa.mm. ◆ ChangeProperties(). void TGCocoa::ChangeProperties ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . Int_t ; format, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Reimplemented from TVirtualX.; Definition at line 3859 of file TGCocoa.mm. ◆ ChangeProperty(). void TGCocoa::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property name ; [in]typethe type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties ; [in]datathe property data ; [in]lenthe length of the specified data format . Reimplemented from TVirtualX.; Definition at line 3816 of file TGCocoa.mm. ◆ ChangeWindowAttributes(). void TGCocoa::ChangeWindowAttributes ; (; Window_t ; id, . SetWindowAttributes_t * ; attr . ). overridevirtual . Changes the attributes of the specified window ""id"" according the values provided in ""attr"". ; The mask data member of ""attr"" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored. ; Reimplemented from TVirtualX.; Definition at line 1006 of file TGCocoa.mm. ◆ CheckEvent(). Bool_t TGCocoa::CheckEvent ; (; Window_t ; id, . EGEventType ; type, . Event_t & ; ev . ). overridevirtual . Check if there is for window ""id"" an event of type ""type"". ; If there is it fills in the event str",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:55711,simpl,simply,55711,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['simpl'],['simply']
Usability,"ies. Function documentation; RooMappedCategory(const char* name, const char* title, RooAbsCategory& inputCat, const char* defCatName = ""NotMapped"", Int_t defCatIdx = NoCatIdx); Constructor with input category and name of default output state, which is assigned; to all input category states that do not follow any mapping rule. RooMappedCategory(const RooMappedCategory& other, const char* name = 0). ~RooMappedCategory(); Destructor. Bool_t map(const char* inKeyRegExp, const char* outKeyName, Int_t outKeyNum = NoCatIdx); Add mapping rule: any input category state label matching the 'inKeyRegExp'; wildcard expression will be mapped to an output state with name 'outKey'. Rules are evaluated in the order they were added. In case an input state; matches more than one rule, the first rules output state will be assigned. RooCatType evaluate() const; Calculate the current value of the object. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this mapped category to the specified stream. In addition to the info; from RooAbsCategory::printStream() we add:. Standard : input category; Shape : default value; Verbose : list of mapping rules. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from given stream. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooMappedCategory to more intuitively reflect the contents of the; product operator construction. void writeToStream(ostream& os, Bool_t compact) const; Write object contents to given stream. inline RooMappedCategory(); { }. TObject* clone(const char* newname) const; { return new RooMappedCategory(*this,newname); }. Entry& operator=(const RooMappedCategory& ). » Last changed: Tue Jun 2 15:32:03 2015 » Last generated: 2015-06-02 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooMappedCategory.html:25576,intuit,intuitively,25576,root/html604/RooMappedCategory.html,https://root.cern,https://root.cern/root/html604/RooMappedCategory.html,1,['intuit'],['intuitively']
Usability,"ies; When building your own executable you will have to link against the libraries that contain the classes you use. The ROOT reference guide states the library a class is reference guide defined in. Almost all relevant classes can be found in libraries returned by root-config -glibs; the graphics libraries are retuned by root-config --libs. These commands are commonly used in Makefiles. Using root-config instead of enumerating the libraries by hand allows you to link them in a platform independent way. Also, if ROOT library names change you will not need to change your Makefile.; A batch program that does not have a graphic display, which creates, fills, and saves histograms and trees, only needs to link the core libraries (libCore, libRIO), libHist and libTree. If ROOT needs access to other libraries, it loads them dynamically. For example, if the TreeViewer is used, libTreePlayer and all libraries libTreePlayer depends on are loaded also. The dependent libraries are shown in the ROOT reference guide’s library dependency graph. The difference between reference guide libHist and libHistPainter is that the former needs to be explicitly linked and the latter will be loaded automatically at runtime when ROOT needs it, by means of the Plugin Manager. plugin manager; In the Figure 1-2, the libraries represented by green boxes outside of the core are loaded via the plugin manager plugin manager or equivalent techniques, while the white ones are not. Of course, if one wants to access a plugin library directly, it has to be explicitly linked. An example of a plugin library is libMinuit. To create and fill histograms you need to link libHist.so. If the code has a call to fit the histogram, the “fitter” will dynamically load libMinuit if it is not yet loaded.; 1.6.2.3 Plugins: Runtime Library Dependencies for Linking; plugin manager The Plugin Manager TPluginManager allows postponing library dependencies to runtime: a plugin library will only be loaded when it is needed. Non",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:22531,guid,guide,22531,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['guid'],['guide']
Usability,"iewer.cxx. ◆ Progress() [1/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2615 of file TSessionViewer.cxx. ◆ Progress() [2/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti . ). inline . Definition at line 428 of file TSessionViewer.h. ◆ Progress() [3/3]. void TSessionQueryFrame::Progress ; (; Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti, . Int_t ; actw, . Int_t ; tses, . Float_t ; eses . ). New version of Progress (just forward to the old version for the time being). ; Definition at line 2733 of file TSessionViewer.cxx. ◆ ProgressLocal(). void TSessionQueryFrame::ProgressLocal ; (; Long64_t ; total, . Long64_t ; processed . ). Update progress bar and status labels. ; Definition at line 2745 of file TSessionViewer.cxx. ◆ ResetProgressDialog(). void TSessionQueryFrame::ResetProgressDialog ; (; const char * ; selec, . Int_t ; files, . Long64_t ; first, . Long64_t ; entries . ). Reset progress frame information fields. ; Definition at line 2905 of file TSessionViewer.cxx. ◆ Streamer(). void TSessionQueryFrame::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGCompositeFrame. ◆ StreamerNVirtual(). void TSessionQueryFrame::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 448 of file TSessionViewer.h. ◆ UpdateButtons(). void TSessionQueryFrame::UpdateButtons ; (; TQueryDescription * ; desc). Update buttons state for the current query status. ; Definition at line 3229 of file TSessionViewer.cxx. ◆ UpdateHistos(). void TSessionQueryFrame::UpdateHistos ; (; TList * ; objs). Update feedback histograms. ; Definition at line 2572 of file T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSessionQueryFrame.html:37302,progress bar,progress bar,37302,doc/master/classTSessionQueryFrame.html,https://root.cern,https://root.cern/doc/master/classTSessionQueryFrame.html,1,['progress bar'],['progress bar']
Usability,"iewer3D Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; List of all members ; TVirtualViewer3D Class ReferenceabstractCore ROOT classes » Base ROOT classes. ; Abstract 3D shapes viewer. ; The concrete implementations are:. TViewerX3D : X3d viewer; TGLViewer : OpenGL viewer. 3D Viewer Infrastructure Overview; The 3D Viewer infrastructure consists of:. TVirtualViewer3D interface: An abstract handle to the viewer, allowing client to test preferences, add objects, control the viewer via scripting (to be added) etc. -TBuffer3D class hierarchy: Used to describe 3D objects (""shapes""); filled /added by negotiation with viewer via TVirtualViewer3D. Together these allow clients to publish objects to any one of the 3D viewers (currently OpenGL/x3d,TPad), free of viewer specific drawing code. They allow our simple x3d viewer, and considerably more sophisticated OpenGL one to both work with both geometry libraries (g3d and geom) efficiently.; Publishing to a viewer consists of the following steps:. Create / obtain viewer handle; Begin scene on viewer; Fill mandatory parts of TBuffer3D describing object; Add to viewer; Fill optional parts of TBuffer3D if requested by viewer, and add again ... repeat 3/4/5 as required; End scene on viewer. Creating / Obtaining Viewer; Create/obtain the viewer handle via local/global pad - the viewer is always bound to a TPad object at present [This may be removed as a restriction in the future] . You should perform the publishing to the viewer described below in the Paint() method of the object you attach to the pad (via Draw()) TVirtualViewer3D * v = gPad->GetViewer3D(""xxxx"");; gPad#define gPadDefinition TVirtualPad.h:308; TVirtualViewer3DAbstract 3D shapes viewer.Definition TVirtualViewer3D.h:34; v@ vDefinition rootcling_impl.cxx:3699; "" xxxx"" is viewer type: OpenGL ""ogl"", X3D ""x3d"" or Pad ""pad"" (default). The view",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualViewer3D.html:958,simpl,simple,958,doc/master/classTVirtualViewer3D.html,https://root.cern,https://root.cern/doc/master/classTVirtualViewer3D.html,1,['simpl'],['simple']
Usability,"ifferent package as long as it implements the required signatures. One such vector type is CLHEP's Hep3Vector:; XYZVector v1(1,2,3);; RhoEtaPhiVector r2(v1);; CLHEP::Hep3Vector q(1,2,3);; XYZVector v3(q); qfloat * qDefinition THbookFile.cxx:89; v3@ v3Definition rootcling_impl.cxx:3703. Arithmetic Operations; The following operations are possible between vector classes, even of different coordinate system types:; v1 += v2;; v1 -= v2;; v1 = - v2;; v1 *= a;; v1 /= a;; v2 = a * v1;; v2 = v1 / a;; v2 = v1 * a;; v3 = v1 + v2;; v3 = v1 - v2;; a#define a(i)Definition RSha256.hxx:99; v2@ v2Definition rootcling_impl.cxx:3702; Note that the multiplication between two vectors using the operator * is not supported because it is ambiguous. Other Methods; The vector classes support methods for:. computation of the dot product via Dot(),; computation of the cross product via Cross(),; construction of a unit vector via Unit(). Transformations; The transformations are modeled using simple (non-template) classes, using double as the scalar type to avoid too large numerical errors. The transformations are grouped in Rotations (in 3 dimensions), Lorentz transformations. Each group has several members which may model physically equivalent transformations but with different internal representations. Transformation classes can operate on all type of vectors using the operator() or the operator * and the transformations can also be combined via the operator *. In more detail the transformations available are:. 3D Rotations. ROOT::Math::Rotation3D, rotation described by a 3x3 matrix of doubles; ROOT::Math::EulerAngles rotation described by the three Euler angles (phi, theta and psi) following the GoldStein definition.; ROOT::Math::RotationZYX rotation described by three angles defining a rotation first along the Z axis, then along the rotated Y' axis and then along the rotated X'' axis.; ROOT::Math::AxisAngle, rotation described by a vector (axis) and an angle; ROOT::Math::Quaternion, rotatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__GenVector.html:7371,simpl,simple,7371,doc/master/group__GenVector.html,https://root.cern,https://root.cern/doc/master/group__GenVector.html,1,['simpl'],['simple']
Usability,"ifies the type of tick marks on the axis.; If tx = gPad->GetTickx() and ty = gPad->GetTicky() then:. tx = 1; tick marks on top side are drawn (inside); tx = 2; tick marks and labels on top side are drawn; ty = 1; tick marks on right side are drawn (inside); ty = 2; tick marks and labels on right side are drawn. By default only the left Y axis and X bottom axis are drawn; (tx = ty = 0); TPad::SetTicks(tx,ty) allows to set these options.; See also The TAxis functions to set specific axis attributes.; In case multiple color filled histograms are drawn on the same pad, the fill; area may hide the axis tick marks. One can force a redraw of the axis over all; the histograms by calling:. gPad->RedrawAxis();. Giving titles to the X, Y and Z axis. h->GetXaxis()->SetTitle(""X axis title"");; h->GetYaxis()->SetTitle(""Y axis title"");. The histogram title and the axis titles can be any TLatex string.; The titles are part of the persistent histogram.; The option ""SAME""; By default, when an histogram is drawn, the current pad is cleared before; drawing. In order to keep the previous drawing and draw on top of it the; option ""SAME"" should be use. The histogram drawn with the option; ""SAME"" uses the coordinates system available in the current pad. This option can be used alone or combined with any valid drawing option but; some combinations must be use with care.; Limitations. It does not work when; combined with the ""LEGO"" and ""SURF"" options unless the; histogram plotted with the option ""SAME"" has exactly the same; ranges on the X, Y and Z axis as the currently drawn histogram. To superimpose; lego plots histograms' stacks should be used. Superimposing two histograms with different scales in the same pad; The following example creates two histograms, the second histogram is the bins; integral of the first one. It shows a procedure to draw the two histograms in; the same pad and it draws the scale of the second histogram using a new vertical; axis on the right side. See also the tutor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:12541,clear,cleared,12541,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,6,['clear'],['cleared']
Usability,"ig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->GetName() : 0 ; }. const RooAbsReal& integrand() const; { return _function.arg() ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooRealIntegral.html:37016,intuit,intuitively,37016,root/html528/RooRealIntegral.html,https://root.cern,https://root.cern/root/html528/RooRealIntegral.html,1,['intuit'],['intuitively']
Usability,"ig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. void setCacheNumeric(Bool_t flag); If true, value of this interal is cached if it is (partially numeric). Bool_t getCacheNumeric(); If true, value of this interal is cached if it is (partially numeric). void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:36306,intuit,intuitively,36306,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['intuit'],['intuitively']
Usability,"ig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject* clone(const char* newname) const; { return new RooRealIntegral(*this,newname); }. Bool_t isValid() const; { return _valid; }. const RooArgSet& numIntCatVars() const; { return _sumList ; }. const RooArgSet& numIntRealVars() const; { return _intList ; }. const RooArgSet& anaIntVars() const; { return _anaList ; }. RooArgSet intVars() const; { RooArgSet tmp(_sumList) ; tmp.add(_intList) ; tmp.add(_anaList) ; tmp.add(_facList) ; return tmp ; }. const char* intRange(); { return _rangeName ? _rangeName->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealIntegral.html:37141,intuit,intuitively,37141,root/html530/RooRealIntegral.html,https://root.cern,https://root.cern/root/html530/RooRealIntegral.html,1,['intuit'],['intuitively']
Usability,"ighlighted() is similar TCanvas::Picked(). when selected object (histogram as a whole) is different from previous then emit Picked() signal; when selected (highlighted) bin from histogram is different from previous then emit Highlighted() signal. Any user function (or functions) has to be defined UserFunction(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). In example (see below) has name PrintInfo(). All parameters of user function are taken from void TCanvas::Highlighted(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y). pad is pointer to pad with highlighted histogram; obj is pointer to highlighted histogram; x is highlighted x bin for 1D histogram; y is highlighted y bin for 2D histogram (for 1D histogram not in use). Example how to create a connection from any TCanvas object to a user UserFunction() slot (see also TQObject::Connect() for additional info) TQObject::Connect(""TCanvas"", ""Highlighted(TVirtualPad*,TObject*,Int_t,Int_t)"",; 0, 0, ""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; or use non-static ""simplified"" function TCanvas::HighlightConnect(const char *slot) c1->HighlightConnect(""UserFunction(TVirtualPad*,TObject*,Int_t,Int_t)"");; NOTE the signal and slot string must have a form ""(TVirtualPad*,TObject*,Int_t,Int_t)"" root [0] .x $ROOTSYS/tutorials/hsimple.C; root [1] hpx->SetHighlight(kTRUE); root [2] .x hlprint.C; file hlprint.C void PrintInfo(TVirtualPad *pad, TObject *obj, Int_t x, Int_t y); {; auto h = (TH1F *)obj;; if (!h->IsHighlight()) // after highlight disabled; h->SetTitle(""highlight disable"");; else; h->SetTitle(TString::Format(""bin[%03d] (%5.2f) content %g"", x,; h->GetBinCenter(x), h->GetBinContent(x)));; pad->Update();; }; ; void hlprint(); {; if (!gPad) return;; gPad->GetCanvas()->HighlightConnect(""PrintInfo(TVirtualPad*,TObject*,Int_t,Int_t)"");; }; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TVi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:130728,simpl,simplified,130728,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['simpl'],['simplified']
Usability,"ightGradientsAt (size_t i);  ; const Matrix_t & GetWeightGradientsAt (size_t i) const;  ; std::vector< Matrix_t > & GetWeights ();  ; const std::vector< Matrix_t > & GetWeights () const;  ; Matrix_t & GetWeightsAt (size_t i);  ; const Matrix_t & GetWeightsAt (size_t i) const;  ; size_t GetWidth () const;  ; virtual void Initialize ();  Initialize the weights and biases according to the given initialization method. ;  ; bool IsTraining () const;  ; void ReadMatrixXML (void *node, const char *name, Matrix_t &matrix);  ; virtual void ResetTraining ();  Reset some training flags after a loop on all batches Some layer (e.g. ;  ; void SetBatchSize (size_t batchSize);  Setters. ;  ; void SetDepth (size_t depth);  ; virtual void SetDropoutProbability (Scalar_t);  Set Dropout probability. ;  ; virtual void SetExtraLayerParameters (const std::vector< Matrix_t > &);  ; void SetHeight (size_t height);  ; void SetInputDepth (size_t inputDepth);  ; void SetInputHeight (size_t inputHeight);  ; void SetInputWidth (size_t inputWidth);  ; void SetIsTraining (bool isTraining);  ; void SetWidth (size_t width);  ; void Update (const Scalar_t learningRate);  Updates the weights and biases, given the learning rate. ;  ; void UpdateBiases (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the biases, given the gradients and the learning rate. ;  ; void UpdateBiasGradients (const std::vector< Matrix_t > &biasGradients, const Scalar_t learningRate);  Updates the bias gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeightGradients (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weight gradients, given some other weight gradients and learning rate. ;  ; void UpdateWeights (const std::vector< Matrix_t > &weightGradients, const Scalar_t learningRate);  Updates the weights, given the gradients and the learning rate,. ;  ; void WriteMatrixToXML (void *node, const char *name, const Matrix_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html:5893,learn,learningRate,5893,doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TReshapeLayer.html,2,['learn'],"['learning', 'learningRate']"
Usability,"ights ;  CTBinStatNo-op; this class does not provide per-bin statistics ;  ►CTHistStatUncertaintyHistogram statistics to keep track of the Poisson uncertainty per bin ;  CTBinStatModifying view on a THistStatUncertainty for a given bin ;  CTConstBinStatConst view on a THistStatUncertainty for a given bin ;  CTHistViewA view on a histogram, selecting a range on a subset of dimensions ;  CTHistViewOutOfRange;  CTLogEntry;  CTLogHandlerAbstract TLogHandler base class ;  CTLogManager;  ►NFitNamespace for the fitting classes ;  CBasicFCNBasicFCN class: base class for the objective functions used in the fits It has a reference to the data and th emodel function used in the fit ;  CBinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y values and error on coordinates The dimension of the coordinate is free There are 4 different options: ;  CChi2FCNChi2FCN class for binnned fits using the least square methods ;  CDataOptionsDataOptions : simple structure holding the options on how the data are filled ;  CDataRangeClass describing the range in the coordinates it supports multiple range in a coordinate ;  CDummyDeleter;  CFcnAdapter;  CFitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::ParameterSettings class ;  CFitDataBase class for all the fit data types: Stores the coordinates and the DataOptions ;  CFitResultClass containg the result of the fit and all the related information (fitted parameter values, error, covariance matrix and minimizer result information) Contains a pointer also to the fitted (model) function, modified with the fit parameter values ;  CFitterFitter class, entry point for performing all type of fits ;  CLogLikelihoodFCNLogLikelihoodFCN class for likelihood fits ;  CParameterSettingsClass, describing value, limits and step size of the parameters Provides functionality also to set/retrieve values, step sizes, limits and fix the parameters ;  CPoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v610/annotated.html:18001,simpl,simple,18001,doc/v610/annotated.html,https://root.cern,https://root.cern/doc/v610/annotated.html,1,['simpl'],['simple']
Usability,"ights.; Exploiting the well-known properties of the derivative, especialy the; derivative of compound functions, one can write:. for a neuton: product of the local derivative with the; weighted sum on the outputs of the derivatives.; for a synapse: product of the input with the local derivative; of the output neuron. This computation is called back-propagation of the errors. A; loop over all examples is called an epoch.; Six learning methods are implemented.; Stochastic minimization: This; is the most trivial learning method. This is the Robbins-Monro; stochastic approximation applied to multilayer perceptrons. The; weights are updated after each example according to the formula:; $w_{ij}(t+1) = w_{ij}(t) + \Delta w_{ij}(t)$. with. $\Delta w_{ij}(t) = - \eta(\d e_p / \d w_{ij} +; \delta) + \epsilon \Deltaw_{ij}(t-1)$; The parameters for this method are Eta, EtaDecay, Delta and; Epsilon.; Steepest descent with fixed step size; (batch learning): It is the same as the stochastic; minimization, but the weights are updated after considering all the; examples, with the total derivative dEdw. The parameters for this; method are Eta, EtaDecay, Delta and Epsilon.; Steepest descent algorithm: Weights; are set to the minimum along the line defined by the gradient. The; only parameter for this method is Tau. Lower tau = higher precision =; slower search. A value Tau = 3 seems reasonable.; Conjugate gradients with the; Polak-Ribiere updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Conjugate gradients with the; Fletcher-Reeves updating formula: Weights are set to the; minimum along the line defined by the conjugate gradient. Parameters; are Tau and Reset, which defines the epochs where the direction is; reset to the steepes descent.; Broyden, Fletcher, Goldfarb, Shanno; (BFGS) method: Implies the computation of a NxN matr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMultiLayerPerceptron.html:4793,learn,learning,4793,root/html528/TMultiLayerPerceptron.html,https://root.cern,https://root.cern/root/html528/TMultiLayerPerceptron.html,6,['learn'],['learning']
Usability,"ignal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions;  TApplication ();  Default ctor. Can be used by classes deriving from TApplication. ;  ; virtual void Forum (const char *line);  The function ("".forum <type>"") submits a new post on the ROOT forum via web browser. ;  ; virtual void GitHub (const char *line);  The function ("".gh <type>"") submits a new issue on GitHub via web browser. ;  ; virtual void Help (const char *line);  The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxygen ("".help scope"" or "".help scope::member""). ;  ; virtual void LoadGraphicsLibs ();  Load shared libs necessary for graphics. ;  ; virtual void MakeBatch ();  Switch to batch mode. ;  ; virtual Longptr_t ProcessRemote (const char *line, Int_t *error=nullptr);  Process the content of a line starting with "".R"" (already stripped-off) The format is. ;  ; void SetSignalHandler (TSignalHandler *sh);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Static Protected Member Functions; static void Close (TApplication *app);  Static function used to close a remote application. ;  ; static TApplication * Open (const char *url, Int_t debug, const char *script);  Static fun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTApplication.html:18046,guid,guide,18046,doc/master/classTApplication.html,https://root.cern,https://root.cern/doc/master/classTApplication.html,1,['guid'],['guide']
Usability,"ignal. ;  ; virtual void HighPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void LowPriority (const char *signal_name, const char *slot_name=nullptr);  ; virtual void Message (const char *msg);  ; virtual Int_t NumberOfConnections () const;  Return number of connections for this object. ;  ; virtual Int_t NumberOfSignals () const;  Return number of signals for this object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TGLColorSet & GetDefaultColorSet ();  Returns reference to the default color-set. ;  ; static Bool_t IsUsingDefaultColorSetForNewViewers ();  Returns the value of the static flag that determines if new viewers should use the default color-set. ;  ; static void SetAxisLabelScale (Float_t als);  Sets static scaling facor that allows simple guide axies to have label values scaled relative to actual scene dimensions. ;  ; static void UseDefaultColorSetForNewViewers (Bool_t x);  Sets static flag that determines if new viewers should use the default color-set. ;  ;  Static Public Member Functions inherited from TVirtualViewer3D; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static TVirtualViewer3D * Viewer3D (TVirtualPad *pad=nullptr, Option_t *type="""");  Create a Viewer 3D of specified type. ;  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:27759,simpl,simple,27759,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"ignments. Creating functions and p.d.f.s. MyPdf::g(x,m,s) - Create p.d.f or function of type MyPdf with name g with argument x,m,s; Interpretation and number of arguments are mapped to the constructor arguments of the class; (after the name and title). MyPdf(x,m,s) - As above, but with an implicitly defined (unique) object name. Creating sets and lists (to be used as inputs above). {a,b,c} - Create RooArgSet or RooArgList (as determined by context) from given contents. Objects that are not created, are assumed to exist in the workspace; Object creation expressions as shown above can be nested, e.g. one can do. RooGaussian::g(x[-10,10],m[0],3). to create a p.d.f and its variables in one go. This nesting can be applied recursively e.g. SUM::model( f[0.5,0,1] * RooGaussian::g( x[-10,10], m[0], 3] ),; RooChebychev::c( x, {a0[0.1],a1[0.2],a2[-0.3]} )). creates the sum of a Gaussian and a Chebychev and all its variables. A seperate series of operator meta-type exists to simplify the construction of composite expressions; meta-types in all capitals (SUM) create p.d.f.s, meta types in lower case (sum) create; functions. SUM::name(f1*pdf1,f2*pdf2,pdf3] -- Create sum p.d.f name with value f1*pdf1+f2*pdf2+(1-f1-f2)*pdf3; RSUM::name(f1*pdf1,f2*pdf2,pdf3] -- Create recursive sum p.d.f. name with value f1*pdf1 + (1-f1)(f2*pdf2 + (1-f2)pdf3); ASUM::name(f1*amp1,f2*amp2,amp3] -- Create sum p.d.f. name with value f1*amp1+f2*amp2+(1-f1-f2)*amp3 where amplX are amplitudes of type RooAbsReal; sum::name(a1,a2,a3] -- Create sum function with value a1+a2+a3; sum::name(a1*b1,a2*b2,a3*b 3] -- Create sum function with value a1*b1+a2*b2+a3*b3. PROD::name(pdf1,pdf2] -- Create product of p.d.f with 'name' with given input p.d.fs; PROD::name(pdf1|x,pdf2] -- Create product of conditional p.d.f. pdf1 given x and pdf2; prod::name(a,b,c] -- Create production function with value a*b*c. SIMUL::name(cat,a=pdf1,b=pdf2] -- Create simultaneous p.d.f index category cat. Make pdf1 to state a, pdf2 to state b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFactoryWSTool.html:13530,simpl,simplify,13530,root/html526/RooFactoryWSTool.html,https://root.cern,https://root.cern/root/html526/RooFactoryWSTool.html,7,['simpl'],['simplify']
Usability,"igurable; void EnableLooseOptions (Bool_t b=kTRUE);  ; const TString & GetReferenceFile () const;  ; Bool_t LooseOptionCheckingEnabled () const;  ; void ResetSetFlag ();  resets the IsSet flag for all declare options to be called before options are read from stream ;  ; void WriteOptionsReferenceToFile ();  write complete options to output stream ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Private Member Functions; void CalculateMulticlassValues (const TMVA::Event *&evt, std::vector< Double_t > &parameters, std::vector< Float_t > &values);  calculate the values for multiclass ;  ; void ClearAll ();  delete and clear all class members ;  ; void CreateFormula ();  translate formula string into TFormula, and parameter string into par ranges ;  ; void DeclareOptions ();  define the options (their key words) that can be set in the option string ;  ; Double_t InterpretFormula (const Event *, std::vector< Double_t >::iterator begin, std::vector< Double_t >::iterator end);  formula interpretation ;  ; void PrintResults (const TString &, std::vector< Double_t > &, const Double_t) const;  display fit parameters check maximum length of variable name ;  ; void ProcessOptions ();  the option string is decoded, for available options see ""DeclareOptions"" ;  . Private Attributes; std::vector< Double_t > fBestPars;  the pars that optimise (minimise) the estimator ;  ; TString fConverger;  fit method uses fConverger as intermediate step to converge into local minimas ;  ; IFitterTarget * fConvergerFitter;  intermediate fitter ;  ; TString fFitMethod;  estimator optimisation method ;  ; FitterBase * fFitter;  the fitter used in the training ;  ; TFormula * fFormula;  the discrimination function ;  ; TString fFormulaStringP;  string with function ;  ; TString fFormulaStringT;  string with function ;  ; UInt_t fNPars;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodFDA.html:26872,clear,clear,26872,doc/master/classTMVA_1_1MethodFDA.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodFDA.html,1,['clear'],['clear']
Usability,"ikelihood using internal constrains in p.d.f; GlobalObservables(const RooArgSet&) -- Define the set of normalization observables to be used for the constraint terms.; If none are specified the constrained parameters are used; ExternalConstraints(const RooArgSet& ) -- Include given external constraints to likelihood; Offset(Bool_t) -- Offset likelihood by initial value (so that starting value of FCN in minuit is zero). This; can improve numeric stability in simultaneously fits with components with large likelihood values. Options to control flow of fit procedure. Minimizer(type,algo) -- Choose minimization package and algorithm to use. Default is MINUIT/MIGRAD through the RooMinimizer; interface, but others can be specified (through RooMinimizer interface). Select OldMinuit to use; MINUIT through the old RooMinuit interface. Type Algorithm; ------ ---------; OldMinuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit migrad, simplex, minimize (=migrad+simplex), migradimproved (=migrad+improve); Minuit2 migrad, simplex, minimize, scan; GSLMultiMin conjugatefr, conjugatepr, bfgs, bfgs2, steepestdescent; GSLSimAn -. InitialHesse(Bool_t flag) -- Flag controls if HESSE before MIGRAD as well, off by default; Optimize(Bool_t flag) -- Activate constant term optimization of test statistic during minimization (on by default); Hesse(Bool_t flag) -- Flag controls if HESSE is run after MIGRAD, on by default; Minos(Bool_t flag) -- Flag controls if MINOS is run after HESSE, off by default; Minos(const RooArgSet& set) -- Only run MINOS on given subset of arguments; Save(Bool_t flag) -- Flac controls if RooFitResult object is produced and returned, off by default; Strategy(Int_t flag) -- Set Minuit strategy (0 through 2, default is 1); FitOptions(const char* optStr) -- Steer fit with classic options string (for backward compatibility). Use of this option; excludes use of any of the new style steering options. SumW2Error(Bool_t flag) -- Apply correa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:56969,simpl,simplex,56969,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,15,['simpl'],['simplex']
Usability,"ikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for tools which can produce both a RooStats HypoTestResult and ConfInterval). More...;  ; class  ProfileLikelihoodTestStat;  ProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset. More...;  ; class  ProofConfig;  Holds configuration options for proof and proof-lite. More...;  ; class  ProposalFunction;  ProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm. More...;  ; class  ProposalHelper;  ; class  RatioOfProfiledLikelihoodsTestStat;  TestStatistic that returns the ratio of profiled likelihoods. More...;  ; struct  RooStatsConfig;  ; class  SamplingDistPlot;  This class provides simple and straightforward utilities to plot SamplingDistribution objects. More...;  ; class  SamplingDistribution;  This class simply holds a sampling distribution of some test statistic. More...;  ; class  SamplingSummary;  ; class  SamplingSummaryLookup;  ; class  SequentialProposal;  Class implementing a proposal function that samples the parameter space by moving only in one coordinate (chosen randomly) at each step. More...;  ; class  SimpleInterval;  SimpleInterval is a concrete implementation of the ConfInterval interface. More...;  ; class  SimpleLikelihoodRatioTestStat;  TestStatistic class that returns -log(L[null] / L[alt]) where L is the likelihood. More...;  ; class  SPlot;  A class to calculate ""sWeights"" used to create an ""sPlot"". More...;  ; class  TestStatistic;  TestStatistic is an interface class to provide a facility for construction test statistics distributions to the NeymanConstruction class. More...;  ; class  TestStatSampler;  TestStatSampler is an interface class for a tools which produce RooStats SamplingDistributions. More...;  ; class  ToyMCImportanceSampler;  ToyMCImportanceSampler is an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceRooStats.html:7179,simpl,simply,7179,doc/master/namespaceRooStats.html,https://root.cern,https://root.cern/doc/master/namespaceRooStats.html,1,['simpl'],['simply']
Usability,"ile *GetCurrentFile() const;; 459 Int_t GetDefaultEntryOffsetLen() const {return fDefaultEntryOffsetLen;}; 460 Long64_t GetDebugMax() const { return fDebugMax; }; 461 Long64_t GetDebugMin() const { return fDebugMin; }; 462 TDirectory *GetDirectory() const { return fDirectory; }; 463 virtual Long64_t GetEntries() const { return fEntries; }; 464 virtual Long64_t GetEntries(const char *selection);; 465 /// Return a number greater or equal to the total number of entries in the; 466 /// dataset.; 467 ///; 468 /// \note If you are interested in the total number of entries in a TChain,; 469 /// this function will give that number once the last file of the chain; 470 /// is opened. In general, using this instead of GetEntries will avoid; 471 /// opening all files in the chain which could be very costly for very; 472 /// large number of files stored at a remote location.; 473 ///; 474 /// The logic depends on whether the dataset is a TTree or a TChain. In the; 475 /// first case, it simply returns the total number of entries in the tree. In; 476 /// the latter case, it depends on which point of the processing of the chain; 477 /// this function is called. During most of the chain processing, this; 478 /// function will return TTree::kMaxEntries. When the chain arrives at the; 479 /// last file, then the function will return the accumulated total number of; 480 /// entries in the whole chain. A notable use case where this function; 481 /// becomes quite useful is when writing the following for loop to traverse; 482 /// the entries in the dataset:; 483 ///; 484 /// \code{.cpp}; 485 /// for(Long64_t ievent = 0; ievent < dataset.GetEntriesFast(); ievent++) {; 486 /// // Do something with the event in the dataset; 487 /// }; 488 /// \endcode; 489 ///; 490 /// In the example above, independently on whether the dataset is a TTree or; 491 /// a TChain, the GetEntriesFast call will provide the correct stopping; 492 /// condition for the loop (i.e. the total number of entries). In the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:25301,simpl,simply,25301,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['simpl'],['simply']
Usability,"ile Histo1D<float>(""x"") does not; the latter spelling should be preferred for performance-critical applications.; Python applications cannot easily specify template parameters or pass C++ callables to RDataFrame. See Efficient analysis in Python for possible ways to speed up hot paths in this case.; Just-in-time compilation happens once, right before starting an event loop. To reduce the runtime cost of this step, make sure to book all operations for all RDataFrame computation graphs before the first event loop is triggered: just-in-time compilation will happen once for all code required to be generated up to that point, also across different computation graphs.; Also make sure not to count the just-in-time compilation time (which happens once before the event loop and does not depend on the size of the dataset) as part of the event loop runtime (which scales with the size of the dataset). RDataFrame has an experimental logging feature that simplifies measuring the time spent in just-in-time compilation and in the event loop (as well as providing some more interesting information). See Activating RDataFrame execution logs. Memory usage; There are two reasons why RDataFrame may consume more memory than expected. Firstly, each result is duplicated for each worker thread, which e.g. in case of many (possibly multi-dimensional) histograms with fine binning can result in visible memory consumption during the event loop. The thread-local copies of the results are destroyed when the final result is produced. Reducing the number of threads or using coarser binning will reduce the memory usage.; Secondly, just-in-time compilation of string expressions or non-templated actions (see the previous paragraph) causes Cling, ROOT's C++ interpreter, to allocate some memory for the generated code that is only released at the end of the application. This commonly results in memory usage creep in long-running applications that create many RDataFrames one after the other. Possible mitig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:50683,simpl,simplifies,50683,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['simpl'],['simplifies']
Usability,"ile RooLognormal.h. ◆ getShapeK(). RooAbsReal const & RooLognormal::getShapeK ; (; ); const. inline . Get the shape parameter. ; Definition at line 42 of file RooLognormal.h. ◆ getX(). RooAbsReal const & RooLognormal::getX ; (; ); const. inline . Get the x variable. ; Definition at line 36 of file RooLognormal.h. ◆ IsA(). TClass * RooLognormal::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 57 of file RooLognormal.h. ◆ Streamer(). void RooLognormal::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooLognormal::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file RooLognormal.h. ◆ translate(). void RooLognormal::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 85 of file RooLognormal.cxx. ◆ useStandardParametrization(). bool RooLognormal::useStandardParametrization ; (; ); const. inline . Definition at line 44 of file RooLognormal.h. Member Data Documentation. ◆ _useStandardParametrization. bool RooLognormal::_useStandardParametrization = false. protected . Definition at line 50 of file RooLognormal.h. ◆ k. RooRealProxy RooLognormal::k. protected . the shape parameter, exp(sigma) ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLognormal.html:80536,simpl,simple,80536,doc/master/classRooLognormal.html,https://root.cern,https://root.cern/doc/master/classRooLognormal.html,1,['simpl'],['simple']
Usability,"ile TProofPlayer.h. ◆ Progress() [4/6]. void TProofPlayerSuperMaster::Progress ; (; TSlave * ; sl, . Long64_t ; total, . Long64_t ; processed . ). overridevirtual . Report progress. ; Reimplemented from TProofPlayerRemote.; Definition at line 4680 of file TProofPlayer.cxx. ◆ Progress() [5/6]. void TProofPlayerSuperMaster::Progress ; (; TSlave * ; sl, . Long64_t ; total, . Long64_t ; processed, . Long64_t ; bytesread, . Float_t ; initTime, . Float_t ; procTime, . Float_t ; evtrti, . Float_t ; mbrti . ). overridevirtual . Report progress. ; Reimplemented from TProofPlayerRemote.; Definition at line 4700 of file TProofPlayer.cxx. ◆ Progress() [6/6]. void TProofPlayerSuperMaster::Progress ; (; TSlave * ; sl, . TProofProgressInfo * ; pi . ). overridevirtual . Progress signal. ; Reimplemented from TProofPlayerRemote.; Definition at line 4761 of file TProofPlayer.cxx. ◆ SetupFeedback(). void TProofPlayerSuperMaster::SetupFeedback ; (; ). overrideprotectedvirtual . Setup reporting of feedback objects and progress messages. ; Reimplemented from TProofPlayerRemote.; Definition at line 4892 of file TProofPlayer.cxx. ◆ Streamer(). void TProofPlayerSuperMaster::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TProofPlayerRemote. ◆ StreamerNVirtual(). void TProofPlayerSuperMaster::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 442 of file TProofPlayer.h. Member Data Documentation. ◆ fReturnFeedback. Bool_t TProofPlayerSuperMaster::fReturnFeedback. private . Definition at line 409 of file TProofPlayer.h. ◆ fSlaveActW. TArrayI TProofPlayerSuperMaster::fSlaveActW. private . Definition at line 405 of file TProofPlayer.h. ◆ fSlaveBytesRead. TArrayL64 TProofPlayerSuperMaster::fSlaveBytesRead. private . Definition at line 400 of file TProofPlayer.h. ◆ fSlaveEffS. TArrayF TProofPlayerSuperMaster::fSlaveEffS. private . Definition at line 407 of file TProofPlayer.h. ◆ fSlaveEvtRti. TArrayF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSuperMaster.html:30741,feedback,feedback,30741,doc/master/classTProofPlayerSuperMaster.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSuperMaster.html,1,['feedback'],['feedback']
Usability,"ile TQCommand.cxx. ◆ CanCompress(). Bool_t TQCommand::CanCompress ; (; TQCommand * ; c); const. virtual . By default, commands can be compressed if they are: . equal; setter commands. More complicated commands might want to override this function. ; Definition at line 387 of file TQCommand.cxx. ◆ CanMerge(). Bool_t TQCommand::CanMerge ; (; TQCommand * ; c); const. virtual . Two commands can be merged if they can be composed into a single command (Macro command). ; To allow merging commands user might override this function. ; Definition at line 314 of file TQCommand.cxx. ◆ CanRedo(). Bool_t TQCommand::CanRedo ; (; ); const. virtual . Returns kTRUE if Redo action is possible, kFALSE if it's not. ; By default, only single sequential redo action is possible. ; Reimplemented in TQUndoManager.; Definition at line 571 of file TQCommand.cxx. ◆ CanUndo(). Bool_t TQCommand::CanUndo ; (; ); const. virtual . Returns kTRUE if Undo action is possible, kFALSE if it's not. ; By default, only single trial undo action is possible. ; Reimplemented in TQUndoManager.; Definition at line 580 of file TQCommand.cxx. ◆ Class(). static TClass * TQCommand::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TQCommand::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TQCommand::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 98 of file TQCommand.h. ◆ Compress(). void TQCommand::Compress ; (; TQCommand * ; c). virtual . Compress command. ; Compression is analogous to arithmetic ""addition operation"".; Note:; The compressed command will be deleted.; Execution Compress method invokes Redo action with new redo arguments inherited from compressed command. More complicated commands might want to override this function. ; Definition at line 402 of file TQCommand.cxx. ◆ DeclFileName(). static const char * TQCommand::DeclFileName ; (; ). inlinestatic . Returns",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:35113,undo,undo,35113,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"ile-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::WriteInt_t Write(const char *name=nullptr, Int_t opt=0, Int_t bufsiz=0) overrideWrite memory objects to this file.Definition TFile.cxx:2436; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TH1F1-D histogram with a float per channel (see TH1 documentation)Definition TH1.h:622; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TNtupleA simple TTree restricted to a list of float variables only.Definition TNtuple.h:28; TNtuple::FillInt_t Fill() overrideFill a Ntuple with current values in fArgs.Definition TNtuple.cxx:169; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::FillInt_t Fill(const Double_t *v)Definition TProfile.h:55; TRandom3Random number generator class based on M.Definition TRandom3.h:27; TRandom3::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom3.cxx:99; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed following a gaussian with mean=0 and sigma=1.Definition TRandom.cxx:507; TStringBasic string class.Definition TString.h:139; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::Pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/hsimple_8C.html:6266,simpl,simple,6266,doc/master/hsimple_8C.html,https://root.cern,https://root.cern/doc/master/hsimple_8C.html,1,['simpl'],['simple']
Usability,"ile.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded. The corresponding binary file and shared library will be deleted at the end of the function. If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded.; The static function returns a pointer to a TSelector object ; Definition at line 142 of file TSelector.cxx. ◆ GetStatus(). virtual Long64_t TSelector::GetStatus ; (; ); const. inlinevirtual . Definition at line 58 of file TSelector.h. ◆ ImportOutput(). void TSelector::ImportOutput ; (; TList * ; output). virtual . Imports the content of 'output' in the internal output list. ; Existing content in the output list is discarded (unless found also in 'output'). In particular, if 'output' is nullptr or empty, reset the internal list. On return, the content of 'output' is cleared to avoid double deletion issues. (The caller is responsible of 'output' as container: its content is transferred under the selector ownership). ; Definition at line 270 of file TSelector.cxx. ◆ Init(). virtual void TSelector::Init ; (; TTree * ; ). inlinevirtual . Reimplemented in TSelVerifyDataSet, TSelHandleDataSet, TProofDraw, TProofDrawHist, TProofDrawEventList, TProofDrawEntryList, TProofDrawProfile, TProofDrawProfile2D, h1analysisTreeReader, TSelEvent, TSelEventGen, TProofDrawGraph, TProofDrawPolyMarker3D, RooProofDriverSelector, TSelectorEntries, and h1analysis.; Definition at line 53 of file TSelector.h. ◆ IsA(). TClass * TSelector::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TSelVerifyDataSet, TSelEvent, TSelEventGen, TSelHandleDataSet, TSelHist, TSelectorDraw, and TSelectorEntries.; Definition at line 79 of file TSelector.h. ◆ IsStandardDraw(). bool TSelector::IsStandardDraw ; (; con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelector.html:19056,clear,cleared,19056,doc/master/classTSelector.html,https://root.cern,https://root.cern/doc/master/classTSelector.html,1,['clear'],['cleared']
Usability,"ile1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the dataset specification. Adding a progress bar; A progress bar showing the processed event statistics can be added to any RDataFrame program. The event statistics include elapsed time, currently processed file, currently processed events, the rate of event processing and an estimated remaining time (per file being processed). It is recorded and printed in the terminal every m events and every n seconds (by default m = 1000 and n = 1). The ProgressBar can be also added when the multithread (MT) mode is enabled.; ProgressBar is added after creating the dataframe object (df): ROOT::RDataFrame df(""tree"", ""file.root"");; ROOT::RDF::Experimental::AddProgressBar(df);; ROOT::RDF::Experimental::AddProgressBarvoid AddProgressBar(ROOT::RDF::RNode df)Add ProgressBar to a ROOT::RDF::RNode.Definition RDFHelpers.cxx:373; Alternatively, RDataFrame can be cast to an RNode first, giving the user more flexibility For example, it can be called at any computational node, such as Filter or Define, not only the head node, with no change to the ProgressBar function itself (please see the Eff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:78186,progress bar,progress bar,78186,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,4,['progress bar'],['progress bar']
Usability,"ileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; void FadeView (Float_t alpha);  Draw a rectangle (background color and given alpha) across the whole viewport. ;  ; void InitGL ();  Initialise GL state. ;  ; void MakeCurrent () const;  Make GL context current. ;  ; void PostDraw ();  Perform GL work which must be done after each draw. ;  ; void PreDraw ();  Perform GL work which must be done before each draw. ;  ; void SetupCameras (Bool_t reset);  Setup cameras for current bounding box. ;  ; void SetupClipObject () override;  allow simple guide axes labels to be scaled relative to scene units ;  ; void SetViewport (const TGLRect &vp);  ; void SetViewport (Int_t x, Int_t y, Int_t width, Int_t height);  Set viewer viewport (window area) with bottom/left at (x,y), with dimensions 'width'/'height'. ;  ; void SwapBuffers () const;  Swap GL buffers. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TGLViewerBase; SceneInfoList_i FindScene (TGLSceneBase *scene);  Find scene-info corresponding to scene. ;  ; void SubRenderScenes (SubRender_foo render_foo);  Call sub-rendering function render_foo on all currently visible scenes. ;  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TGLAutoRotator * fAutoRotator;  ; Bool_t fAxesDepthTest;  axes type ;  ; Int_t fAxesType;  smooth line edge rendering ;  ; TGLCameraOver",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLViewer.html:31160,simpl,simple,31160,doc/master/classTGLViewer.html,https://root.cern,https://root.cern/doc/master/classTGLViewer.html,2,"['guid', 'simpl']","['guide', 'simple']"
Usability,"ill area color; Style_tTAttFill::fFillStylefill area style; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tfNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfRmaxellipse semi-axis in X outside; Float_tfRminellipse semi-axis in X inside; Double_t*fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←. TCONE. TELTU. THYPE. TTUBS; ←. TCONS. TCTUB. Function documentation; TTUBE(); TUBE shape default constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t aspect = 1); TUBE shape normal constructor. TTUBE(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz); TUBE shape ""simplified"" constructor. TTUBE(const TTUBE& ); copy constructor. TTUBE& operator=(const TTUBE& ); assignement operator. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBE(); TUBE shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetNumberOfDivisions(Int_t ndiv); Set number of divisions used to draw this tube. void SetPoints(Double_t* points) const; Create TUBE points. void SetSegsAndPols(TBuffer3D& buffer) const; Set segments and polygons. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). void Streamer(TBuffer& ); Stream an object of class TTUBE. const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. Float_t GetRmin() const; {return fRmin;}. Float_t GetRmax() const; {return fRmax;}. Float_t GetDz() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTUBE.html:9654,simpl,simplified,9654,root/html602/TTUBE.html,https://root.cern,https://root.cern/root/html602/TTUBE.html,2,['simpl'],['simplified']
Usability,"ill be created for each element of this collection. In case a collection element is a TClonesArray, the special Tree constructor; for TClonesArray is called.; The collection itself cannot be a TClonesArray. The function returns the total number of branches created. If name is given, all branch names will be prefixed with name_. IMPORTANT NOTE1: This function should not be called with splitlevel < 1. IMPORTANT NOTE2: The branches created by this function will have names; corresponding to the collection or object names. It is important; to give names to collections to avoid misleading branch names or; identical branch names. By default collections have a name equal to; the corresponding class name, e.g. the default name for a TList is ""TList"". And in general in any cases two or more master branches contain subbranches; with identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. Example--------------------------------------------------------------:. {; TTree T(""T"",""test list"");; TList *list = new TList();. TObjArray *a1 = new TObjArray();; a1->SetName(""a1"");; list->Add(a1);; TH1F *ha1a = new TH1F(""ha1a"",""ha1"",100,0,1);; TH1F *ha1b = new TH1F(""ha1b"",""ha1"",100,0,1);; a1->Add(ha1a);; a1->Add(ha1b);; TObjArray *b1 = new TObjArray();; b1->SetName(""b1"");; list->Add(b1);; TH1F *hb1a = new TH1F(""hb1a"",""hb1"",100,0,1);; TH1F *hb1b = new TH1F(""hb1b"",""hb1"",100,0,1);; b1->Add(hb1a);; b1->Add(hb1b);. TObjArray *a2 = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:46658,simpl,simply,46658,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['simpl'],['simply']
Usability,"ill be no result produced; 1057by applying multiple systematic variations at the same time.; 1058For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1059""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1060 ; 1061~~~{.cpp}; 1062auto df = _df.Vary(""pt"",; 1063 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1064 {""down"", ""up""}); 1065 .Vary(""eta"",; 1066 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1067 {""eta""},; 1068 2);; 1069 ; 1070auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1071auto all_hs = VariationsFor(nom_h);; 1072all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1073~~~; 1074 ; 1075Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1076shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1077 ; 1078\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1079 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1080 programming model will be streamlined in future versions.; 1081 ; 1082\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1083 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1084 ; 1085See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1086for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1087 ; 1088\anchor rnode; 1089### RDataFrame objects as function arguments and return values; 1090RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1091functions and to return them from functions. Howev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:63283,feedback,feedback,63283,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['feedback'],['feedback']
Usability,"ill be no result produced; 1097by applying multiple systematic variations at the same time.; 1098For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1099""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1100 ; 1101~~~{.cpp}; 1102auto df = _df.Vary(""pt"",; 1103 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1104 {""down"", ""up""}); 1105 .Vary(""eta"",; 1106 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1107 {""eta""},; 1108 2);; 1109 ; 1110auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1111auto all_hs = VariationsFor(nom_h);; 1112all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1113~~~; 1114 ; 1115Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1116shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1117 ; 1118\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1119 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1120 programming model will be streamlined in future versions.; 1121 ; 1122\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1123 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1124 ; 1125See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1126for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1127 ; 1128\anchor rnode; 1129### RDataFrame objects as function arguments and return values; 1130RDataFrame variables/nodes are relatively cheap to copy and it's possible to both pass them to (or move them into); 1131functions and to return them from functions. Howev",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:64963,feedback,feedback,64963,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['feedback'],['feedback']
Usability,"ill return the name of the last clicked button.; {; // run macro from tutorials directory of ROOT!; TControlBar bar(""vertical"");; bar.AddButton(""Help to run demos"","".x demoshelp.C"",; ""Explains how to run the demos"");; bar.AddButton(""framework"", "".x graphics/framework.C"",; ""An Example of Object Oriented User Interface"");; bar.AddButton(""hsimple"", "".x hsimple.C"",; ""An Example Creating Histograms/Ntuples on File"");; bar.AddButton(""hsum"", "".x hist/hsum.C"",; ""Filling histograms and some graphics options"");; bar.AddButton(""canvas"", "".x graphics/canvas.C"",; ""Canvas and Pad Management"");; bar.AddButton(""formula1"", "".x graphics/formula1.C"",; ""Simple Formula and Functions"");; bar.AddButton(""fillrandom"", "".x hist/fillrandom.C"",; ""Histograms with Random Numbers from a Function"");; bar.AddButton(""fit1"", "".x fit/fit1.C"",; ""A Simple Fitting Example"");; bar.AddButton(""draw2dopt"", "".x hist/draw2dopt.C"",; ""Drawing Options for 2D Histograms"");; bar.AddButton(""graph"", "".x graphs/graph.C"",; ""Examples of a simple graph"");; bar.AddButton(""tornado"", "".x graphics/tornado.C"",; ""Examples of 3-D PolyMarkers"");; bar.AddButton(""shapes"", "".x geom/shapes.C"",; ""The Geometry Shapes"");; bar.AddButton(""file_layout"", "".x io/file.C"",; ""The ROOT file format"");; bar.AddButton(""tree_layout"", "".x tree/tree.C"",; ""The Tree Data Structure"");; bar.AddButton(""ntuple1"", "".x tree/ntuple1.C"",; ""Ntuples and Selections"");; bar.AddButton(""run benchmarks"", "".x legacy/benchmarks.C"",; ""Runs all the ROOT benchmarks"");; bar.AddButton(""rootmarks"", "".x legacy/rootmarks.C"",; ""Prints an estimated ROOTMARKS for your machine"");; bar.AddButton(""edit_hsimple"", "".!vi hsimple.C &"",; ""Invokes the text editor on file hsimple.C"");; bar.AddButton(""Close Bar"", ""bar.Hide()"",; ""Close ControlBar"");; bar.Show();; }; TControlBarA Control Bar is a fully user configurable tool which provides fast access to frequently used operati...Definition TControlBar.h:26; . Definition at line 26 of file TControlBar.h. Public Types; enum  { kVertical = 1; , ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTControlBar.html:1904,simpl,simple,1904,doc/master/classTControlBar.html,https://root.cern,https://root.cern/doc/master/classTControlBar.html,1,['simpl'],['simple']
Usability,"illRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519; TH1::GetRandom can be used to return a random number distributed according to the contents of a histogram. Making a copy of a histogram; Like for any other ROOT object derived from TObject, one can use the Clone() function. This makes an identical copy of the original histogram including all associated errors and functions, e.g.: TH1F *hnew = (TH1F*)h->Clone(""hnew"");; TH1::CloneTObject * Clone(const char *newname="""") const overrideMake a complete copy of the underlying object.Definition TH1.cxx:2752. Normalizing histograms; One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1::Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram. Drawing histograms; Histograms are drawn via the THistPainter class. Each histogram has a pointer to its own painter (to be usable in a multithreaded program). Many drawing options are supported. See THistPainter::Paint() for more details.; The same histogram can be drawn with different options in different pads. When a histogram drawn in a pad is deleted, the histogram is automatically removed from the pad or pads where it was drawn. If a histogram is drawn in a pad, then filled again, the new status of the histogram will be automatically shown in the pad next time the pad is updated. One does not need to redraw the histogram. To draw the current version of a histogram in a pad, one can use h->DrawCopy();; This makes a clone (see Clone below) of the histogram. Once the clone is drawn, the original histogram may be modified or deleted without affecting the aspect of the clone.; One can use TH1::SetMaximum() and TH1::SetMinimum() to force a particular value for the maximum or the minimum scale on the plot. (For 1-D histograms this means the y-axis, while for 2-D histograms these functions affect th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:17050,usab,usable,17050,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['usab'],['usable']
Usability,"im; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tfAllowDirectiveswhether directives are to be interpreted; Bool_tfCheckForMethodwhether to check the current line for a method; TStringfClassDescrTagtag for finding the class description; enum(anonymous)fClassDocStatewhether we found the class description; TStringfCommentcurrent comment; Bool_tfCommentAtBOLat the beginning of the current line, fParseContext contained kComment; TClass*fCurrentClasscurrent class context of sources being parsed; TStringfCurrentFilecurrent source / header file name; TStringfCurrentMethodTagname_idx of the currently parsed method; TStringfCurrentModulecurrent module context of sources being parsed; TListfDataMembers[6]data members (by access, plus enums); Int_tfDirectiveCountindex of directive for current method; TListfDirectiveHandlershandler for doc directives (TDocDirective objects); TDocParser::EDocContextfDocContextcurrent context of parsed sources for documenting; TDocOutput*fDocOutputTDocOutput invoking us; set<UInt_t>fExtraLinesWithAnchorlines that need an additional anchor; TStringfFirstClassDocfirst class-doc found - per file, taken if fLastClassDoc is empty; THtml*fHtmlTHtml object using us; TStringfLastClassDoclast class-doc found - becomes class doc at ClassImp or first method; TStringfLineCommentcurrent line with links and directives for doc; UInt_tfLineNocurrent line number; Long_tfLineNumbersource line number; TStringfLineRawcurrent line; TStringfLineSourcecurrent line with links; TStringfLineStrippedcurrent line without surrounding spaces; map<string,Int_t>fMethodCountsnumber of undocumented overloads; THashListfMethods[3]methods as TMethodWrapper objects (by access); list<UInt_t>fParseContextcurrent context of parsed sources; TClass*fRecentClassrecently seen class context of sources being parsed, e.g. for Convert(); TStringfSourceInfo[5]author, last changed, ...; TStringfSourceInfoTags[5]tags for source inf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocParser.html:11158,undo,undocumented,11158,root/html602/TDocParser.html,https://root.cern,https://root.cern/root/html602/TDocParser.html,2,['undo'],['undocumented']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTBase_double_.html:6950,simpl,simple,6950,root/html602/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTBase_double_.html,2,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTBase_float_.html:6947,simpl,simple,6947,root/html602/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTBase_float_.html,2,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixDBase, TMatrixTBase<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:6950,simpl,simple,6950,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,3,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixFBase, TMatrixTBase<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_float_.html:6947,simpl,simple,6947,root/html528/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html,2,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Double_t>, TMatrixDBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<double>(); virtual TMatrixTBase<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<double>&Apply(const TElementActionT<double>& action); virtual TMatrixTBase<double>&Apply(const TElementPosActio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMatrixTBase_double_.html:6950,simpl,simple,6950,root/html532/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html532/TMatrixTBase_double_.html,1,['simpl'],['simple']
Usability,"imal, but not by a whole lot. And that's right,; class MakeHilbert is declared *within* a function and local to; that function. It means one can define another MakeHilbert class; (within another function or outside of any function, that is, in; the global scope), and it still will be OK. Note, this currently; is not yet supported by the interpreter CINT. Another example is applying of a simple function to each matrix; element:. void foo(TMatrixD &m,TMatrixD &m1); {; typedef double (*dfunc_t)(double);; class ApplyFunction : public TElementActionD {; dfunc_t fFunc;; void Operation(Double_t &element); { element=fFunc(element); }; public:; ApplyFunction(dfunc_t func):fFunc(func) {}; };; ApplyFunction x(TMath::Sin);; m.Apply(x);; }. Validation code $ROOTSYS/test/vmatrix.cxx and vvector.cxx contain; a few more examples of that kind. 6. Lazy matrices: instead of returning an object return a ""recipe""; how to make it. The full matrix would be rolled out only when; and where it's needed:; TMatrixD haar = THaarMatrixD(5);; THaarMatrixD() is a *class*, not a simple function. However; similar this looks to a returning of an object (see note #1; above), it's dramatically different. THaarMatrixD() constructs a; TMatrixDLazy, an object of just a few bytes long. A special; ""TMatrixD(const TMatrixDLazy &recipe)"" constructor follows the; recipe and makes the matrix haar() right in place. No matrix; element is moved whatsoever!. This class is also known as (typedefs to this class)TMatrixTBase<Float_t>, TMatrixFBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTBase<float>(); virtual TMatrixTBase<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual TMatrixTBase<float>&Apply(const TElementActionT<float>& action); virtual TMatrixTBase<float>&Apply(const TElementPosActionT<flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTBase_float_.html:6947,simpl,simple,6947,root/html530/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTBase_float_.html,2,['simpl'],['simple']
Usability,"imate(tree->GetEntries()+1); // same as tree->SetEstimate(-1);; You must call SetEstimate if the expected number of selected rows; you need to look at is greater than 1000000. You can use the option ""goff"" to turn off the graphics output; of TTree::Draw in the above example. Automatic interface to TTree::Draw via the TTreeViewer. A complete graphical interface to this function is implemented; in the class TTreeViewer.; To start the TTreeViewer, three possibilities:; - select TTree context menu item ""StartViewer""; - type the command ""TTreeViewer TV(treeName)""; - execute statement ""tree->StartViewer();"". void DropBaskets(); Remove some baskets from memory. void DropBuffers(Int_t nbytes); Drop branch buffers to accommodate nbytes below MaxVirtualsize. Int_t Fill(); Fill all branches. This function loops on all the branches of this tree. For; each branch, it copies to the branch buffer (basket) the current; values of the leaves data types. If a leaf is a simple data type,; a simple conversion to a machine independent format has to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called committing or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:89926,simpl,simple,89926,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,6,['simpl'],['simple']
Usability,"ime Date and time 950130 124559; TDecayChannel Class describing a particle decay channel; TDecompBK Matrix Decomposition Bunch-Kaufman; TDecompBase Matrix Decomposition Base; TDecompChol Matrix Decompositition Cholesky; TDecompLU Matrix Decompositition LU; TDecompQRH Matrix Decompositition QRH; TDecompSVD Matrix Decompositition SVD; TDecompSparse Matrix Decompositition LU; TDialogCanvas A specialized canvas to set attributes.; TDiamond Diamond class; TDictionary ABC defining interface to dictionary; TDirectory Describe directory structure in memory; TDirectoryFile Describe directory structure in a ROOT file; TDocDirective THtml directive handler; TDocHtmlDirective Handler for ""Begin_Html""/""End_Html"" for raw HTML in documentation comments; TDocLatexDirective Handler for ""Begin_Latex""/""End_Latex"" to generate an image from latex; TDocMacroDirective Handler for ""Begin_Macro""/""End_Macro"" for code that is executed and that can generate an image for documentation; TDocOutput generates documentation web pages; TDocParser parser for reference documentation; TDrawFeedback Present PROOF query feedback; TELTU ELTU shape; TEditQueryFrame Edit query frame; TEllipse An ellipse; TEmulatedCollectionProxy ; TEmulatedMapProxy ; TEntryList A list of entries in a TTree; TEntryListBlock Used internally in TEntryList to store the entry numbers; TEntryListFromFile Manager for entry lists from different files; TEnv Handle ROOT configuration resources; TEnvRec Individual TEnv records; TEve3DProjection 3D scaling ""projection""; TEveArrow Class for gl visualisation of arrow.; TEveArrowEditor GUI editor for TEveArrow.; TEveArrowGL GL renderer class for TEveArrow.; TEveBoxSet Collection of 3D primitives (fixed-size boxes, boxes of different sizes, or arbitrary sexto-epipeds); each primitive can be assigned a signal value and a TRef.; TEveBoxSetGL GL-renderer for TEveBoxSet class.; TEveBrowser Specialization of TRootBrowser for Eve.; TEveCalo2D Class for visualization of projected calorimeter event",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ClassIndex.html:54492,feedback,feedback,54492,root/html526/ClassIndex.html,https://root.cern,https://root.cern/root/html526/ClassIndex.html,1,['feedback'],['feedback']
Usability,"imental::RCanvas Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Private Attributes |; Friends |; List of all members ; ROOT::Experimental::RCanvas Class ReferenceGraphics » ROOT7 Graphics » ROOT7 Pad related classes. ; A window's topmost RPad. ; AuthorAxel Naumann axel@.nosp@m.cern.nosp@m..ch ; Date2015-07-08 ; WarningThis is part of the ROOT 7 prototype! It will change without notice. It might trigger earthquakes. Feedback is welcome! ; Definition at line 47 of file RCanvas.hxx. Public Member Functions;  RCanvas ();  Create a temporary RCanvas; for long-lived ones please use Create(). ;  ;  ~RCanvas () override=default;  ; template<class PANEL > ; bool AddPanel (std::shared_ptr< PANEL > &panel);  Insert panel into the canvas, canvas should be shown at this moment. ;  ; void ClearOnClose (const std::shared_ptr< void > &handle);  Set handle which will be cleared when connection is closed. ;  ; void ClearShown ();  clear IsShown() flag ;  ; void ClearUpdated ();  clear IsUpdated() flag ;  ; std::string CreateJSON ();  Provide JSON which can be used for offline display. ;  ; const RCanvas * GetCanvas () const override;  Access to the top-most canvas, if any (const version). ;  ; RCanvas * GetCanvas () override;  Access to the top-most canvas, if any (non-const version). ;  ; int GetHeight () const;  Get canvas height. ;  ; uint64_t GetModified () const;  Get modify counter. ;  ; const std::string & GetTitle () const;  Get the canvas's title. ;  ; std::string GetUID () const;  Return unique identifier for the canvas Used in iPython display. ;  ; int GetWidth () const;  Get canvas width. ;  ; std::string GetWindowAddr () const;  Returns window name used to display canvas. ;  ; std::string GetWindowUrl (bool remote);  Returns window URL which can be used for connection. ;  ; void Hide ();  Hide all canvas display",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:1048,clear,cleared,1048,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['clear'],['cleared']
Usability,"imize \(\chi^2 = g^2(\vec\theta)\) where g is arbitrary function.; Approximate value is:; \[; {\frac{\partial^2\chi^2}{\partial\theta_i\partial\theta_k}}\approx Z_{ik}=; \sum^n_{j=1}{\frac{1}{\sigma^2_j}}{\frac{\partial f_j}{\theta_i}}; {\frac{\partial f_j}{\theta_k}}; \]; Then the equations for parameter increments are:; \[; \left(\frac{\partial\chi^2}{\partial\theta_i}\right)_; {\vec\theta={\vec\theta}^0} +\sum_k Z_{ik}\cdot(\theta_k-\theta^0_k) =; 0, \qquad i=1\ldots m; \]; Remarkable feature of algorithm is the technique for step restriction. For an initial value of parameter \({\vec\theta}^0\) a parallelepiped \(P_0\) is built with the center at \({\vec\theta}^0\) and axes parallel to coordinate axes \(\theta_i\). The lengths of parallelepiped sides along i-th axis is \(2b_i\), where \(b_i\) is such a value that the functions \(f_j(\vec\theta)\) are quasi-linear all over the parallelepiped.; FUMILI takes into account simple linear inequalities in the form:; \[ \theta_i^{min}\le\theta_i\le\theta^{max}_i\]; They form parallelepiped \(P\) (\(P_0\) may be deformed by \(P\)). Very similar step formulae are used in FUMILI for negative logarithm of the likelihood function with the same idea - linearization of function argument.; 5.12 Neural Networks; 5.12.1 Introduction; Neural Networks are used in various fields for data analysis and classification, both for research and commercial institutions. Some randomly chosen examples are image analysis, financial movements’ predictions and analysis, or sales forecast and product shipping optimization. In particles physics neural networks are mainly used for classification tasks (signal over background discrimination). A vast majority of commonly used neural networks are multilayer perceptrons. This implementation of multilayer perceptrons is inspired from the MLPfit package, which remains one of the fastest tools for neural networks studies.; 5.12.2 The MLP; The multilayer perceptron is a simple feed-forward network with the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:229992,simpl,simple,229992,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"implemented from RooAbsReal.; Definition at line 108 of file RooCBShape.cxx. ◆ IsA(). TClass * RooCBShape::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 62 of file RooCBShape.h. ◆ maxVal(). double RooCBShape::maxVal ; (; Int_t ; code); const. overridevirtual . Return maximum value for set of observables identified by code assigned in getMaxVal. ; Reimplemented from RooAbsReal.; Definition at line 120 of file RooCBShape.cxx. ◆ Streamer(). void RooCBShape::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from RooAbsPdf. ◆ StreamerNVirtual(). void RooCBShape::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 62 of file RooCBShape.h. ◆ translate(). void RooCBShape::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overridevirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 67 of file RooCBShape.cxx. Member Data Documentation. ◆ alpha. RooRealProxy RooCBShape::alpha. protected . Definition at line 52 of file RooCBShape.h. ◆ m. RooRealProxy RooCBShape::m. protected . Definition at line 49 of file RooCBShape.h. ◆ m0. RooRealProxy RooCBShape::m0. protected . Definition at line 50 of file RooCBShape.h. ◆ n. RooRealProxy RooCBShape::n. protected . Definition at line 53 of file RooCBShape.h. ◆ sigma. R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCBShape.html:78418,simpl,simple,78418,doc/master/classRooCBShape.html,https://root.cern,https://root.cern/doc/master/classRooCBShape.html,1,['simpl'],['simple']
Usability,"imum value for the counter so far ;  ; std::deque< Short_t > fSuccessList;  to calculate the improvement-speed ;  . #include <TMVA/ConvergenceTest.h>. Inheritance diagram for TMVA::ConvergenceTest:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ConvergenceTest(). TMVA::ConvergenceTest::ConvergenceTest ; (; ). constructor ; Definition at line 40 of file ConvergenceTest.cxx. ◆ ~ConvergenceTest(). TMVA::ConvergenceTest::~ConvergenceTest ; (; ). destructor ; Definition at line 55 of file ConvergenceTest.cxx. Member Function Documentation. ◆ GetCurrentValue(). Float_t TMVA::ConvergenceTest::GetCurrentValue ; (; ). inline . Definition at line 57 of file ConvergenceTest.h. ◆ HasConverged(). Bool_t TMVA::ConvergenceTest::HasConverged ; (; Bool_t ; withinConvergenceBand = kFALSE). gives back true if the last ""steps"" steps have lead to an improvement of the ""fitness"" of the ""individuals"" of at least ""improvement"" ; this gives a simple measure of if the estimator of the MLP is converging and no major improvement is to be expected. ; Definition at line 66 of file ConvergenceTest.cxx. ◆ Progress(). Float_t TMVA::ConvergenceTest::Progress ; (; ). returns a float from 0 (just started) to 1 (finished) ; Definition at line 91 of file ConvergenceTest.cxx. ◆ ResetConvergenceCounter(). void TMVA::ConvergenceTest::ResetConvergenceCounter ; (; ). inline . Definition at line 58 of file ConvergenceTest.h. ◆ SetConvergenceParameters(). void TMVA::ConvergenceTest::SetConvergenceParameters ; (; Int_t ; steps, . Double_t ; improvement . ). inline . Definition at line 54 of file ConvergenceTest.h. ◆ SetCurrentValue(). void TMVA::ConvergenceTest::SetCurrentValue ; (; Float_t ; value). inline . Definition at line 56 of file ConvergenceTest.h. ◆ SpeedControl(). Float_t TMVA::ConvergenceTest::SpeedControl ; (; UInt_t ; ofSteps). this function provides the ability to change the learning rate according to the s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html:2553,simpl,simple,2553,doc/master/classTMVA_1_1ConvergenceTest.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1ConvergenceTest.html,1,['simpl'],['simple']
Usability,"in Monte Carlo method to integrate the likelihood function with the prior to obtain the posterior function ;  CMCMCIntervalPlotThis class provides simple and straightforward utilities to plot a MCMCInterval object ;  CMetropolisHastingsThis class uses the Metropolis-Hastings algorithm to construct a Markov Chain of data points using Monte Carlo ;  CMinNLLTestStatMinNLLTestStat is an implementation of the TestStatistic interface that calculates the minimum value of the negative log likelihood function and returns it as a test statistic ;  CModelConfigModelConfig is a simple class that holds configuration information specifying how a model should be used in the context of various RooStats tools ;  CNeymanConstructionNeymanConstruction is a concrete implementation of the NeymanConstruction interface that, as the name suggests, performs a NeymanConstruction ;  CNuisanceParametersSamplerHelper class for ToyMCSampler ;  CNumberCountingPdfFactory;  CNumEventsTestStatNumEventsTestStat is a simple implementation of the TestStatistic interface used for simple number counting ;  CPdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface ;  CPointSetIntervalPointSetInterval is a concrete implementation of the ConfInterval interface ;  CProfileInspector;  CProfileLikelihoodCalculatorProfileLikelihoodCalculator is a concrete implementation of CombinedCalculator (the interface class for a tools which can produce both RooStats HypoTestResults and ConfIntervals) ;  CProfileLikelihoodTestStatProfileLikelihoodTestStat is an implementation of the TestStatistic interface that calculates the profile likelihood ratio at a particular parameter point given a dataset ;  CProofConfigHolds configuration options for proof and proof-lite ;  CProposalFunctionProposalFunction is an interface for all proposal functions that would be used with a Markov Chain Monte Carlo algorithm ;  CProposalHelper;  CRatioOfProfiledLikelihoodsTestStatTestStatistic that returns the ratio o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:7930,simpl,simple,7930,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,1,['simpl'],['simple']
Usability,"in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send cleanup request for the session specified by tag. ;  ; void ClearData (UInt_t what=kUnregistered, const char *dsname=0);  Remove files for the data directory. ;  ; void ClearFeedback ();  Clear feedback list. ;  ; void ClearInput ();  Clear input object list. ;  ; void ClearInputData (const char *name);  Remove obj 'name' form the input data list;. ;  ; void ClearInputData (TObject *obj=0);  Remove obj form the input data list; if obj is null (default), clear the input data info. ;  ; Int_t ClearPackage (const char *package);  Remove a specific package. ;  ; Int_t ClearPackages ();  Remove all packages. ;  ; void Close (Option_t *option="""");  Close all open slave servers. ;  ; void CloseProgressDialog ();  Close progress dialog. ;  ; TDrawFeedback * CreateDrawFeedback ();  Draw feedback creation proxy. ;  ; void DataSetStatus (const char *msg, Bool_t status, Int_t done, Int_t total);  Send dataset preparation status. ;  ; Int_t DeactivateWorker (const char *ord, Bool_t save=kTRUE);  Remove the worker identified by the ordinal number 'ord' from the the active list. ;  ; void DeleteDrawFeedback (TDrawFeedback *f);  Delete draw feedback object. ;  ; void DeleteParameters (const char *wildcard);  Delete the input list parameters specified by a wildcard (e.g. ;  ; void Detach (Option_t *opt="""");  Detach this instance to its proofserv. ;  ; void DisableGoAsyn ();  Signal to disable related switches. ;  ; Int_t DownloadPackage (const char *par, const char *dstdir=0);  Download a PROOF archive (PAR file) from the master package repository. ;  ; Long64_t DrawSelect (const char *dsetname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0, TObject *enl=0);  Execute the specified drawing action on ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:7980,feedback,feedback,7980,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['feedback'],['feedback']
Usability,"in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQCommand::fStatusfStatus++ after Redo(), fStatus-- after Undo(); TStringTQCommand::fTitlecommand description; TQConnection*TQCommand::fUndoundo action; Long_t*TQCommand::fUndoArgsundo values; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQUndoManager(); Constructor. ~TQUndoManager(); Destructor. void ls(Option_t* option = """") const; Lists all commands in stack. void PrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; Print collection entry. void SetLogging(Bool_t on = kTRUE); Start logging. Delete all previous log records; Note: logging is not implemented yet. void Add(TObject* obj, Option_t* opt); Add command to the stack of commands.; Command's redo action will be executed. option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:17726,undo,undo,17726,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,8,['undo'],"['undo', 'undoing']"
Usability,"in the corresponding popup menu. It should also have a defined character as its unique access key. The second parameter is the popup menu we would like to add. The third one is an object of TGLayoutHints type that defines how the menu title will be laid out in the menu bar. In our example the File and Test menus will be laid out to the left of the menu bar with 4 pixels distance in between, the Help menu - will be laid out to the right.; The menu classes provide a very flexible menu system: you can enable, disable, add or remove menu items dynamically. The method HideEntry(menuID) hides the menu entry (the entry will not be shown in the popup menu). To enable a hidden entry you should call EnableEntry(menuID) method. By default all entries are enabled. The method DisableEntry(menuID) helps you to disable a menu entry - it will appear in sunken relieve. The DeleteEntry(menuID) method will delete the specified entry from the menu.; A few words about the menu design. A menu should be kept consistent and simple. All related items need to be in a popup menu. The cascade menus should be used judiciously. Try to limit them to one, maximum two levels.; There are some rules for naming the menu objects:. Define unique names within a menu; Use capitalized one-word names allowing the quick scan of the menu; Define unique access key for any menu item; Indicate by ellipsis (…) after the title with no space when a menu item will pop-up a dialog box. The proper kind of graphical menus is a critical point to every application success and depends of three main factors:. number of presented items in the menu; how often the menu is used; how often the menu contents may change. 25.8.5 Toolbar. A toolbar (TGToolBar) is a composite frame that contains TGPictureButtonobjects. It provides an easy and fast access to most frequently used commands or options across multiple application screens. Also, it invokes easily a sub application within an application. All its functions can be obtained by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1194105,simpl,simple,1194105,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"in the same Postscript file: case 1; The following macro is an example illustrating how to open a Postscript; file and draw several pictures. The generation of a new Postscript page; is automatic when TCanvas::Clear is called by; object->Draw(). {; TFile f(""hsimple.root"");; TCanvas c1(""c1"",""canvas"",800,600);; // select postscript output type; // type = 111 portrait ps; // type = 112 landscape ps; // type = 113 eps; Int_t type = 111;; // create a postscript file and set the paper size; TPostScript ps(""test.ps"",type);; ps.Range(16,24); //set x,y of printed page; // draw 3 histograms from file hsimple.root on separate pages; hpx->Draw();; c1.Update(); //force drawing in a macro; hprof->Draw();; c1.Update();; hpx->Draw(""lego1"");; c1.Update();; ps.Close();; }. Making several pictures in the same Postscript file: case 2; This example shows 2 pages. The canvas is divided.; TPostScript::NewPage must be called before starting a new; picture.object->Draw does not clear the canvas in this case; because we clear only the pads and not the main canvas.; Note that c1->Update must be called at the end of the first; picture. {; TFile *f1 = new TFile(""hsimple.root"");; TCanvas *c1 = new TCanvas(""c1"");; TPostScript *ps = new TPostScript(""file.ps"",112);; c1->Divide(2,1);; // picture 1; ps->NewPage();; c1->cd(1);; hpx->Draw();; c1->cd(2);; hprof->Draw();; c1->Update();; // picture 2; ps->NewPage();; c1->cd(1);; hpxpy->Draw();; c1->cd(2);; ntuple->Draw(""px"");; c1->Update();; ps->Close();; // invoke Postscript viewer; gSystem->Exec(""gs file.ps"");; }. Making several pictures in the same Postscript file: case 3; This is the recommended way. If the Postscript file name finishes with; ""("", the file remains opened (it is not closed). If the Postscript file name; finishes with "")"" and the file has been opened with ""("", the file is closed.; Example:. {; TCanvas c1(""c1"");; h1.Draw();; c1.Print(""c1.ps(""); // write canvas and keep the ps file open; h2.Draw();; c1.Print(""c1.ps""); // canvas is added t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPostScript.html:4483,clear,clear,4483,root/html528/TPostScript.html,https://root.cern,https://root.cern/root/html528/TPostScript.html,6,['clear'],['clear']
Usability,"in) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between 0 and `GetNSlots() - 1`.; 925In other words, within a slot, computation runs sequentially and events are processed sequentially.; 926Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:51846,simpl,simple,51846,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"in) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between 0 and `GetNSlots() - 1`.; 965In other words, within a slot, computation runs sequentially and events are processed sequentially.; 966Note that the same slot might be associated to differen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53486,simpl,simple,53486,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['simpl'],['simple']
Usability,"in,Xmax,""X"");; Create a new volume by dividing an existing one (GEANT3 like).; Divides MOTHER into NDIV divisions called NAME along axis IAXIS starting at coordinate value START and having size STEP. The created volumes will have tracking media ID=NUMED (if NUMED=0 -> same media as MOTHER).; The behavior of the division operation can be triggered using OPTION (case insensitive):. Ndivide all range in NDIV cells (same effect as STEP<=0) (GSDVN in G3); NXdivide range starting with START in NDIV cells (GSDVN2 in G3); Sdivide all range with given STEP; NDIV is computed and divisions will be centered in full range (same effect as NDIV<=0) (GSDVS, GSDVT in G3); SXsame as DVS, but from START position (GSDVS2, GSDVT2 in G3). 18.4.2.10 Volume Assemblies; In general, geometry contains structures of positioned volumes that have to be grouped and handled together, for different possible reasons. One of these is that the structure has to be replicated in several parts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as “overlapping” (see also "" Overlapping Volumes ""); Representing the container as a composite shape - the Boolean union of all components (see also "" Composite Shapes ""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:958226,simpl,simply,958226,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simply']
Usability,"inMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixFromVyy(const TMatrixDSparse* vyy, TH2* ematrix, const Int_t* binMap, Bool_t clearEmat); propagate error matrix vyy to the result; vyy: error matrix on input data fY; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixTotal(TH2* ematrix, const Int_t* binMap = 0); get total error including statistical error; ematrix: output; binMap: see method GetEmatrix(). Double_t GetChi2Sys(void); calculate total chi**2 including systematic errors. void VectorMapToHist(TH1* hist_delta, const TMatrixDSparse",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:25735,clear,clearEmat,25735,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,9,['clear'],"['clear', 'clearEmat']"
Usability,inVolume = 1.0;; 632 for ( unsigned int j = 0; j < fDim; j++ ); 633 {; 634 binVolume *= ( xup[j] - xlow[j] );; 635 }; 636 ; 637 // store the minimum bin volume found as reference for future normalizations; 638 if ( fNPoints == 1 ); 639 fRefVolume = binVolume;; 640 else if ( binVolume < fRefVolume ); 641 fRefVolume = binVolume;; 642 }; 643 ; 644 ; 645 void BinData::InitDataVector (); 646 {; 647 fData.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 648 fDataPtr = fData.empty() ? nullptr : &fData.front();; 649 }; 650 ; 651 void BinData::InitializeErrors(); 652 {; 653 assert( kValueError == fErrorType || kCoordError == fErrorType ||; 654 kAsymError == fErrorType || kNoError == fErrorType );; 655 ; 656 if ( fpTmpCoordErrorVector ); 657 {; 658 delete[] fpTmpCoordErrorVector;; 659 fpTmpCoordErrorVector = nullptr;; 660 }; 661 ; 662 if ( kNoError == fErrorType ); 663 {; 664 fCoordErrors.clear();; 665 fCoordErrorsPtr.clear();; 666 ; 667 fDataErrorHigh.clear();; 668 fDataErrorHighPtr = nullptr;; 669 ; 670 fDataErrorLow.clear();; 671 fDataErrorLowPtr = nullptr;; 672 ; 673 fDataError.clear();; 674 fDataErrorPtr = nullptr;; 675 ; 676 return;; 677 }; 678 ; 679 if ( kCoordError == fErrorType || kAsymError == fErrorType ); 680 {; 681 fCoordErrorsPtr.resize( fDim );; 682 fCoordErrors.resize( fDim );; 683 for( unsigned int i=0; i < fDim; i++ ); 684 {; 685 fCoordErrors[i].resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 686 ; 687 fCoordErrorsPtr[i] = fCoordErrors[i].empty() ? nullptr : &fCoordErrors[i].front();; 688 }; 689 ; 690 fpTmpCoordErrorVector = new double[fDim];; 691 }; 692 else; 693 {; 694 fCoordErrors.clear();; 695 fCoordErrorsPtr.clear();; 696 }; 697 ; 698 if ( kValueError == fErrorType || kCoordError == fErrorType ); 699 {; 700 fDataError.resize(fMaxPoints + FitData::VectorPadding(fMaxPoints));; 701 fDataErrorPtr = fDataError.empty() ? nullptr : &fDataError.front();; 702 ; 703 fDataErrorHigh.clear();; 704 fDataErrorHighPtr = nullptr;; 705 fDataErrorLow.cl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8cxx_source.html:20496,clear,clear,20496,doc/master/BinData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/BinData_8cxx_source.html,1,['clear'],['clear']
Usability,"include <TGProgressBar.h>. Inheritance diagram for TGProgressBar:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ anonymous enum. anonymous enum. EnumeratorkProgressBarStandardWidth ; kProgressBarTextWidth ; kBlockSize ; kBlockSpace . Definition at line 24 of file TGProgressBar.h. ◆ EBarType. enum TGProgressBar::EBarType. EnumeratorkStandard ; kFancy . Definition at line 22 of file TGProgressBar.h. ◆ EFillType. enum TGProgressBar::EFillType. EnumeratorkSolidFill ; kBlockFill . Definition at line 23 of file TGProgressBar.h. Constructor & Destructor Documentation. ◆ TGProgressBar(). TGProgressBar::TGProgressBar ; (; const TGWindow * ; p, . UInt_t ; w, . UInt_t ; h, . Pixel_t ; back = GetWhitePixel(), . Pixel_t ; barcolor = GetDefaultSelectedBackground(), . GContext_t ; norm = GetDefaultGC()(), . FontStruct_t ; font = GetDefaultFontStruct(), . UInt_t ; options = kDoubleBorder | kSunkenFrame . ). Create progress bar. ; Definition at line 42 of file TGProgressBar.cxx. ◆ ~TGProgressBar(). TGProgressBar::~TGProgressBar ; (; ). inlineoverride . Definition at line 58 of file TGProgressBar.h. Member Function Documentation. ◆ Class(). static TClass * TGProgressBar::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGProgressBar::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGProgressBar::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 90 of file TGProgressBar.h. ◆ DeclFileName(). static const char * TGProgressBar::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 90 of file TGProgressBar.h. ◆ DoRedraw(). void TGProgressBar::DoRedraw ; (; ). overrideprotectedpure virtual . Redraw the frame. ; Reimplemented from TGFrame.; Implemented in TGHProgressBar, and TGVProgressBar. ◆ Format(). ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGProgressBar.html:31084,progress bar,progress bar,31084,doc/master/classTGProgressBar.html,https://root.cern,https://root.cern/doc/master/classTGProgressBar.html,1,['progress bar'],['progress bar']
Usability,"index should be <= %d"", fNpoints);; 1758 return;; 1759 }; 1760 ; 1761 if (ipoint == fNpoints) {; 1762 SetPoint(ipoint, x, y);; 1763 return;; 1764 }; 1765 ; 1766 Double_t **ps = ExpandAndCopy(fNpoints + 1, ipoint);; 1767 CopyAndRelease(ps, ipoint, fNpoints++, ipoint + 1);; 1768 ; 1769 // To avoid redefinitions in descendant classes; 1770 FillZero(ipoint, ipoint + 1);; 1771 ; 1772 fX[ipoint] = x;; 1773 fY[ipoint] = y;; 1774}; 1775 ; 1776 ; 1777////////////////////////////////////////////////////////////////////////////////; 1778/// Integrate the TGraph data within a given (index) range.; 1779/// Note that this function computes the area of the polygon enclosed by the points of the TGraph.; 1780/// The polygon segments, which are defined by the points of the TGraph, do not need to form a closed polygon,; 1781/// since the last polygon segment, which closes the polygon, is taken as the line connecting the last TGraph point; 1782/// with the first one. It is clear that the order of the point is essential in defining the polygon.; 1783/// Also note that the segments should not intersect.; 1784///; 1785/// NB:; 1786/// - if last=-1 (default) last is set to the last point.; 1787/// - if (first <0) the first point (0) is taken.; 1788///; 1789/// ### Method:; 1790///; 1791/// There are many ways to calculate the surface of a polygon. It all depends on what kind of data; 1792/// you have to deal with. The most evident solution would be to divide the polygon in triangles and; 1793/// calculate the surface of them. But this can quickly become complicated as you will have to test; 1794/// every segments of every triangles and check if they are intersecting with a current polygon's; 1795/// segment or if it goes outside the polygon. Many calculations that would lead to many problems...; 1796///; 1797/// ### The solution (implemented by R.Brun); 1798/// Fortunately for us, there is a simple way to solve this problem, as long as the polygon's; 1799/// segments don't intersect.; 1800",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:63798,clear,clear,63798,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['clear'],['clear']
Usability,"ine 59 of file TXMLParser.h. ◆ GetParseCodeMessage(). const char * TXMLParser::GetParseCodeMessage ; (; Int_t ; parseCode); const. Returns the parse code message. ; Definition at line 122 of file TXMLParser.cxx. ◆ GetReplaceEntities(). Bool_t TXMLParser::GetReplaceEntities ; (; ); const. inline . Definition at line 53 of file TXMLParser.h. ◆ GetStopOnError(). Bool_t TXMLParser::GetStopOnError ; (; ); const. inline . Definition at line 64 of file TXMLParser.h. ◆ GetValidate(). Bool_t TXMLParser::GetValidate ; (; ); const. inline . Definition at line 50 of file TXMLParser.h. ◆ GetValidateError(). const char * TXMLParser::GetValidateError ; (; ); const. inline . Definition at line 66 of file TXMLParser.h. ◆ GetValidateWarning(). const char * TXMLParser::GetValidateWarning ; (; ); const. inline . Definition at line 67 of file TXMLParser.h. ◆ InitializeContext(). void TXMLParser::InitializeContext ; (; ). protectedvirtual . Initialize parser parameters, such as, disactivate non-standards libxml1 features, on/off validation, clear error and warning messages. ; Definition at line 152 of file TXMLParser.cxx. ◆ IsA(). TClass * TXMLParser::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 69 of file TXMLParser.h. ◆ OnValidateError(). void TXMLParser::OnValidateError ; (; const TString & ; message). protectedvirtual . This function is called when an error from the parser has occurred. ; Message is the parse error. ; Definition at line 105 of file TXMLParser.cxx. ◆ OnValidateWarning(). void TXMLParser::OnValidateWarning ; (; const TString & ; message). protectedvirtual . This function is called when a warning from the parser has occurred. ; Message is the parse error. ; Definition at line 114 of file TXMLParser.cxx. ◆ operator=(). TXMLParser & TXMLParser::operator= ; (; const TXMLParser & ; ). privatedelete . ◆ ParseBuffer(). virtual Int_t TXMLParser::ParseBuffer ; (; const char * ; contents, . I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLParser.html:18926,clear,clear,18926,doc/master/classTXMLParser.html,https://root.cern,https://root.cern/doc/master/classTXMLParser.html,1,['clear'],['clear']
Usability,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←; TTUBS. ←. TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-02 16:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTUBS.html:10129,simpl,simplified,10129,root/html604/TTUBS.html,https://root.cern,https://root.cern/root/html604/TTUBS.html,1,['simpl'],['simplified']
Usability,"ine color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; TMaterial*TShape::fMaterialPointer to material; TStringTNamed::fNameobject identifier; Int_tTTUBE::fNdivnumber of segments (precision); Int_tTShape::fNumberShape number; Float_tfPhi1first phi limit; Float_tfPhi2second phi limit; Float_tTTUBE::fRmaxellipse semi-axis in X outside; Float_tTTUBE::fRminellipse semi-axis in X inside; Double_t*TTUBE::fSiTab! Table of sin(fPhi1) .... sin(fPhil+fDphi1); TStringTNamed::fTitleobject title; Int_tTShape::fVisibilityVisibility flag. Class Charts. Inheritance Chart:. TObject. ←; TNamed. TAttLine. TAttFill. TAtt3D. ←; TShape. ←; TTUBE. ←; TTUBS. ←. TCONS. TCTUB. Function documentation; TTUBS(); TUBS shape default constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmin, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape normal constructor. TTUBS(const char* name, const char* title, const char* material, Float_t rmax, Float_t dz, Float_t phi1, Float_t phi2); TUBS shape ""simplified"" constructor. void MakeTableOfCoSin() const; Make table of sine and cosine. ~TTUBS(); TUBS shape default destructor. Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a TUBE. Compute the closest distance of approach from point px,py to each; computed outline point of the TUBE. void SetPoints(Double_t* points) const; Create TUBS points. void Sizeof3D() const; Return total X3D needed by TNode::ls (when called with option ""x""). const TBuffer3D & GetBuffer3D(Int_t reqSections) const; Get buffer 3d. TTUBS(). Float_t GetPhi1() const; {return fPhi1;}. Float_t GetPhi2() const; {return fPhi2;}. » Author: Nenad Buncic 18/09/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/g3d:$Id$ » Last generated: 2015-06-30 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT sup",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTUBS.html:10129,simpl,simplified,10129,root/html602/TTUBS.html,https://root.cern,https://root.cern/root/html602/TTUBS.html,1,['simpl'],['simplified']
Usability,"ine command. Now let us execute a multi-line command:; root [] {; root [] ? TLine l;; root [] ? for (int i = 0; i < 5; i++) {; root [] ? l.SetX1(i);; root [] ? l.SetY1(i+1);; root [] ? l.Print();; root [] ? }; root [] ? }; TLine X1=0.000000 Y1=1.000000 X2=0.000000 Y2=0.000000; TLine X1=1.000000 Y1=2.000000 X2=0.000000 Y2=0.000000; TLine X1=2.000000 Y1=3.000000 X2=0.000000 Y2=0.000000; TLine X1=3.000000 Y1=4.000000 X2=0.000000 Y2=0.000000; TLine X1=4.000000 Y1=5.000000 X2=0.000000 Y2=0.000000; root [] .q; Here we note:. A multi-line command starts with a { and ends with a }.; Inside continuation, every line has to be correctly terminated with a ; (like in ""real’’ C++).; All objects are created in global scope.; There is no way to back up; you are better off writing a script.; Use .q to exit root. 7.2 Feeding Sources Files To ROOT: C++ Scripts; ROOT script files (often called “Macros”) contain pure C++ code. They can contain a simple sequence of statements like in the multi command line example given above, but also arbitrarily complex class and function definitions.; The most frequent interaction with the ROOT prompt uses .x to “run” a file:; root [] .x myScript.C; This loads myScript.C into the interpreter and calls the function myScript(). You can pass arguments using .x myScript.C(12, ""A String"").; Alternatively you can load the script and then run a function explicitly:; root [] .L myScript.C; root [] myScript(); The above is equivalent to .x myScript.C.; In a named script, the objects created on the stack are deleted when the function exits. In a common scenario you create a histogram in a named script on the stack. You draw the histogram, but when the function exits the canvas is empty and the histogram has disappeared. To avoid the histogram from disappearing you can create it on the heap (by using new). This will leave the histogram object intact, but the pointer in the named script scope will be “gone”. Since histograms (and trees) are added to the list of o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:263194,simpl,simple,263194,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCurlyArcImplements curly or wavy arcs used to draw Feynman diagrams.Definition TCurlyArc.h:16; TCurlyLineImplements curly or wavy polylines used to draw Feynman diagrams.Definition TCurlyLine.h:19; TCurlyLine::TCurlyLineTCurlyLine()Default constructor.Definition TCurlyLine.cxx:46; TCurlyLine::SetWavyvirtual void SetWavy()Set wavy.Definition TCurlyLine.cxx:369; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPolyLine::Drawvoid Draw(Option_t *option="""") overrideDraw this polyline with its current attributes.Definition TPolyLine.cxx:215; int; c1return c1Definition legend1.C:41; ginitstatic int ginitDefinition rsalib.cxx:256; lTLine lDefinition textangle.C:4; . Definition at line 19 of file TCurlyLine.h. Public Member Functions;  TCurlyLine ();  Default constructor. ;  ;  TCurlyLine (Double_t x1, Double_t y1, Double_t x2, Double_t y2, Double_t wl=.02, Double_t amp=.01);  Create a new TCurlyLine with starting point (x1, y1), end point (x2,y2). ;  ;  ~TCurlyLine () override;  ; virtual void Build ();  Create a curly (Gluon) or wavy (Gamma) line. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to a line. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCurlyLine.html:3260,simpl,simple,3260,doc/master/classTCurlyLine.html,https://root.cern,https://root.cern/doc/master/classTCurlyLine.html,1,['simpl'],['simple']
Usability,"ineColor=""kP6Blue+1"", ShiftToZero=True, Name=""gauss""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""Ignore"") # Silence some warnings; nll_morph.plotOn(frame1, LineColor=""kP6Blue+2"", ShiftToZero=True, Name=""morphed""); ROOT.RooAbsReal.setEvalErrorLoggingMode(""PrintErrors""); ; # Plot the likelihood functions; frame2 = x_var.frame(Title=""Likelihood ratio r(x|#mu=2.5);x;p_{gauss}/p_{uniform}""); llhr_learned.plotOn(frame2, LineColor=""kP6Blue"", Name=""learned_ratio""); llhr_calc.plotOn(frame2, LineColor=""kP6Blue+1"", Name=""exact""); ; # Write the plots into one canvas to show, or into separate canvases for saving.; single_canvas = True; ; c = ROOT.TCanvas("""", """", 1200 if single_canvas else 600, 600); if single_canvas:; c.Divide(2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame1.GetYaxis().SetTitleOffset(1.8); frame1.Draw(); ; legend1 = ROOT.TLegend(0.43, 0.63, 0.8, 0.87); legend1.SetFillColor(ROOT.kWhite); legend1.SetLineColor(ROOT.kWhite); legend1.SetTextSize(0.04); legend1.AddEntry(""learned"", ""learned (SBI)"", ""L""); legend1.AddEntry(""gauss"", ""true NLL"", ""L""); legend1.AddEntry(""morphed"", ""moment morphing"", ""L""); legend1.Draw(); ; if single_canvas:; c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.8); else:; c.SaveAs(""rf615_plot_1.png""); c = ROOT.TCanvas("""", """", 600, 600); ; frame2.Draw(); ; legend2 = ROOT.TLegend(0.53, 0.73, 0.87, 0.87); legend2.SetFillColor(ROOT.kWhite); legend2.SetLineColor(ROOT.kWhite); legend2.SetTextSize(0.04); legend2.AddEntry(""learned_ratio"", ""learned (SBI)"", ""L""); legend2.AddEntry(""exact"", ""true ratio"", ""L""); legend2.Draw(); ; if not single_canvas:; c.SaveAs(""rf615_plot_2.png""); ; # Compute the minimum via minuit and display the results; for nll in [nll_gauss, nllr_learned, nll_morph]:; minimizer = ROOT.RooMinimizer(nll); minimizer.setErrorLevel(0.5) # Adjust the error level in the minimization to work with likelihoods; minimizer.setPrintLevel(-1); minimizer.minimize(""Minuit2""); result = minimizer.save(); ROOT.SetOwnership(result, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html:8590,learn,learned,8590,doc/master/rf615__simulation__based__inference_8py.html,https://root.cern,https://root.cern/doc/master/rf615__simulation__based__inference_8py.html,2,['learn'],['learned']
Usability,"ineoverridevirtual . Implements TVirtualPadPainter.; Definition at line 83 of file TWebPadPainter.h. ◆ DrawBox(). void TWebPadPainter::DrawBox ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2, . EBoxMode ; mode . ). overridevirtual . Paint a simple box. ; Implements TVirtualPadPainter.; Definition at line 102 of file TWebPadPainter.cxx. ◆ DrawFillArea() [1/2]. void TWebPadPainter::DrawFillArea ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 124 of file TWebPadPainter.cxx. ◆ DrawFillArea() [2/2]. void TWebPadPainter::DrawFillArea ; (; Int_t ; n, . const Float_t * ; x, . const Float_t * ; y . ). overridevirtual . Paint filled area. ; Implements TVirtualPadPainter.; Definition at line 140 of file TWebPadPainter.cxx. ◆ DrawLine(). void TWebPadPainter::DrawLine ; (; Double_t ; x1, . Double_t ; y1, . Double_t ; x2, . Double_t ; y2 . ). overridevirtual . Paint a simple line. ; Implements TVirtualPadPainter.; Definition at line 65 of file TWebPadPainter.cxx. ◆ DrawLineNDC(). void TWebPadPainter::DrawLineNDC ; (; Double_t ; u1, . Double_t ; v1, . Double_t ; u2, . Double_t ; v2 . ). overridevirtual . Paint a simple line in normalized coordinates. ; Implements TVirtualPadPainter.; Definition at line 83 of file TWebPadPainter.cxx. ◆ DrawPixels(). void TWebPadPainter::DrawPixels ; (; const unsigned char * ; pixelData, . UInt_t ; width, . UInt_t ; height, . Int_t ; dstX, . Int_t ; dstY, . Bool_t ; enableAlphaBlending . ). overridevirtual . Noop, for non-gl pad TASImage calls gVirtualX->CopyArea. ; Implements TVirtualPadPainter.; Definition at line 55 of file TWebPadPainter.cxx. ◆ DrawPolyLine() [1/2]. void TWebPadPainter::DrawPolyLine ; (; Int_t ; n, . const Double_t * ; x, . const Double_t * ; y . ). overridevirtual . Paint Polyline. ; Implements TVirtualPadPainter.; Definition at line 156 of file TWebPadPainter.cxx. ◆ DrawPolyLine() [2/2]. void TWebP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebPadPainter.html:15315,simpl,simple,15315,doc/master/classTWebPadPainter.html,https://root.cern,https://root.cern/doc/master/classTWebPadPainter.html,1,['simpl'],['simple']
Usability,"ing () const;  Returns kTRUE if logging is ON. ;  ; void ls (Option_t *option="""") const override;  Lists all commands in stack. ;  ; void Redo (Option_t *option="""") override;  Performs redo action. Move cursor position forward in history stack. ;  ; virtual void SetLimit (UInt_t limit);  Returns a maximum number of commands which could be located in stack. ;  ; virtual void SetLogging (Bool_t on=kTRUE);  Start logging. ;  ; void Streamer (TBuffer &) override;  Stream all objects in the collection to or from the I/O buffer. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Undo (Option_t *option="""") override;  Performs undo action. Move cursor position backward in history stack. ;  ;  Public Member Functions inherited from TQCommand;  TQCommand (const char *cl=nullptr, void *object=nullptr, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ;  TQCommand (const TQCommand &com);  Copy constructor. ;  ;  TQCommand (TObject *obj, const char *redo=nullptr, const char *undo=nullptr);  Constructor. ;  ; virtual ~TQCommand ();  dtor. ;  ; virtual Bool_t CanCompress (TQCommand *c) const;  By default, commands can be compressed if they are: ;  ; virtual Bool_t CanMerge (TQCommand *c) const;  Two commands can be merged if they can be composed into a single command (Macro command). ;  ; virtual void Compress (TQCommand *c);  Compress command. ;  ; void Delete (Option_t *option="""") override;  If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ;  ; const char * GetName () const override;  Returns the command name. ;  ; Int_t GetNRargs () const;  Returns a number of redo arguments. ;  ; Int_t GetNUargs () const;  Returns a number of undo arguments. ;  ; void * GetObject () const;  Returns an object for which undo redo actions are applied. ;  ; TQConnection * GetRedo () const;  ; Long_t * GetRedoArgs () const;  Returns a pointer to array of redo arguments. ;  ; const char * GetRedoName () const;  Return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:2221,undo,undo,2221,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['undo'],['undo']
Usability,"ing C++ user code to be used from Python with; 23# PyROOT, please see:; 24# https://root.cern.ch/manual/python/#loading-user-libraries-and-just-in-time-compilation-jitting; 25ROOT.gInterpreter.Declare('''; 26class MyClass {};; 27'''); 28 ; 29# Next, we define a pythonizor function: the function that will be responsible; 30# for injecting new behaviour in our C++ class `MyClass`.; 31#; 32# To convert a given Python function into a pythonizor, we need to decorate it; 33# with the @pythonization decorator. Such decorator allows us to define which; 34# which class we want to pythonize by providing its class name and its; 35# namespace (if the latter is not specified, it defaults to the global; 36# namespace, i.e. '::').; 37#; 38# The decorated function - the pythonizor - must accept either one or two; 39# parameters:; 40# 1. The class to be pythonized (proxy object where new behaviour can be; 41# injected); 42# 2. The fully-qualified name of that class (optional).; 43#; 44# Let's see all this with a simple example. Suppose I would like to define how; 45# `MyClass` objects are represented as a string in Python (i.e. what would be; 46# shown when I print that object). For that purpose, I can define the following; 47# pythonizor function. There are two important things to be noted here:; 48# - The @pythonization decorator has one argument that specifies our target; 49# class is `MyClass`.; 50# - The pythonizor function `pythonizor_of_myclass` provides and injects a new; 51# implementation for `__str__`, the mechanism that Python provides to define; 52# how to represent objects as strings. This new implementation; 53# always returns the string ""This is a MyClass object"".; 54@pythonization('MyClass'); 55def pythonizor_of_myclass(klass):; 56 klass.__str__ = lambda o : 'This is a MyClass object'; 57 ; 58# Once we have defined our pythonizor function, let's see it in action.; 59# We will now use the `MyClass` class for the first time from Python: we will; 60# create a new insta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html:2037,simpl,simple,2037,doc/master/pyroot002__pythonizationDecorator_8py_source.html,https://root.cern,https://root.cern/doc/master/pyroot002__pythonizationDecorator_8py_source.html,1,['simpl'],['simple']
Usability,"ing Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » Development Coding Conventions. Naming conventions; Class definition conventions. Inline; Declaration Order. Avoid raw C types; Exception handling; Namespaces; Using comments to document the code; Source file layout. Header file layout; Implementation file layout. Preferred Coding Style. Indentation; Placing Braces and Spaces. ClangFormat; Astyle; Where to go from here. Naming conventions; For naming conventions we follow the Taligent rules. They have written a very large body of C++ and their rules seem well thought out. No need to invent something new. The only addition/change we made is to append an _t to typedefs and simple structs, e.g.:; typedef int Int_t ; struct Simple_t { ..... } ; ; Addherence to the rules is mandatory. After a while one really gets used to the fact that all class fields start with an f followed by a capitalized word, fEnergy, or that TStreamerInfo is a class. If the convention is sporadically violated debugging becomes a nightmare. The usage of a standard begin letter or token for the different types also makes it easy to parse and search the code using simple tools.; Class definition conventions; Also here the Taligent guide is quite reasonable. Of course, no class data member should ever be public. Make the data fields always private. Or protected, if you want to grant an inherited class direct access.; Inline; Add trivial get or setters directly in the class definition. This improves reading time since one does not have to look for it somewhere else. Add more complex inlines (longer than one line) at the bottom of the .h file. Creating separate .i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/coding-conventions.html:2484,simpl,simple,2484,d/coding-conventions.html,https://root.cern,https://root.cern/d/coding-conventions.html,1,['simpl'],['simple']
Usability,"ing H -> ZZ -> 4 mu generated by Pythia ;  quadset.CDemonstates usage of 2D digit class TEveQuadSet ;  selection_sigs.CTest signals from TEveSelection class ;  show_extract.CHelper script for showing of extracted / simplified geometries ;  SplitGLView.CHelper classes for the alice_esd_split.C demo ;  text.CDemonstrates usage of class TEveText - 2D & 3D text in GL ;  track.CDemonstrates usage of TEveTrackPRopagator with different magnetic field configurations ;  triangleset.CDemonstrates usage of class TEveTriangleSet ;  view3ds.CLoading and display of basic 3DS models ;  window_manager.CDemonstrates usage of EVE window-manager ;  ► eve7;  collection.CThis example display collection of ??? in web browser ;  compound.C;  csgdemo.CCombinatorial Solid Geometry example ;  event_demo.CThis example display geometry, tracks and hits in web browser ;  geom_cms.C;  points.CThis example display only points in web browser ;  projection_prescale.C;  show_extract.CHelper script for showing of extracted / simplified geometries ;  table.CThis example display table in web browser ;  tracks.CThis example display only points in web browser ;  ► fft;  FFT.C This tutorial illustrates the Fast Fourier Transforms interface in ROOT ;  ► fit;  combinedFit.C Combined (simultaneous) fit of two histogram with separate functions and some common parameters ;  ConfidenceIntervals.C Illustrates TVirtualFitter::GetConfidenceIntervals This method computes confidence intervals for the fitted function ;  ErrorIntegral.C Estimate the error in the integral of a fitted function taking into account the errors in the parameters resulting from the fit ;  exampleFit3D.C example of fitting a 3D function Typical multidimensional parametric regression where the predictor depends on 3 variables ;  fit1.C Simple fitting example (1-d histogram with an interpreted function) ;  fit2.C Fitting a 2-D histogram This tutorial illustrates : ;  fit2a.C Fitting a 2-D histogram (a variant) This tutorial illustrates : ;  fit2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:106278,simpl,simplified,106278,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simplified']
Usability,"ing state""); mixState.defineType(""mixed"", -1); mixState.defineType(""unmixed"", 1); ; # With pythonization :; mixState = ROOT.RooCategory(""mixState"", ""B0/B0bar mixing state"", {""mixed"" : -1, ""unmixed"" : 1}). Definition at line 28 of file RooCategory.h. Public Member Functions;  RooCategory ();  ;  RooCategory (const char *name, const char *title);  Constructor. Types must be defined using defineType() before variable can be used. ;  ;  RooCategory (const char *name, const char *title, const std::map< std::string, int > &allowedStates);  Create a new category and define allowed states. ;  ;  RooCategory (const RooCategory &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooCategory () override;  Destructor. ;  ; void addToRange (const char *rangeName, const char *stateNameList);  Add the list of state names to the given range. ;  ; void addToRange (const char *rangeName, RooAbsCategory::value_type stateIndex);  Add the given state to the given range. ;  ; void clear ();  Clear all defined category states. ;  ; void clearRange (const char *name, bool silent);  Clear the named range. ;  ; TObject * clone (const char *newname) const override;  ; bool defineType (const std::string &label);  Define a state with given name. ;  ; bool defineType (const std::string &label, Int_t index);  Define a state with given name and index. ;  ; void defineTypes (const std::map< std::string, int > &allowedStates);  Define multiple states in a single call. ;  ; value_type getCurrentIndex () const final;  Return current index. ;  ; TClass * IsA () const override;  ; RooCategory & operator= (const RooCategory &)=delete;  ; value_type & operator[] (const std::string &stateName);  Access a named state. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from given stream. ;  ; bool setIndex (const std::pair< std::string, value_type > &nameIdxPair, bool printError=true);  Change category state to state specified by another cat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCategory.html:3137,clear,clear,3137,doc/master/classRooCategory.html,https://root.cern,https://root.cern/doc/master/classRooCategory.html,1,['clear'],['clear']
Usability,"ing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  hlGraph1.CThis tutorial demonstrates how to use the highlight mode on graph ;  hlGraph2.CThis tutorial demonstrates how to use the highlight mode on graph ;  labels1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:118369,simpl,simple,118369,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['simpl'],['simple']
Usability,"ing the ""compacting"" algorithm in TPadPainter ;  pstable.C Display all possible types of ROOT/Postscript characters ;  psview.C An example how to display PS, EPS, PDF files in canvas ;  quarks.C Example illustrating divided pads and Latex ;  tmathtext.CThis macro draws various formula in a canvas ;  tmathtext2.C This macro draw all possible symbols provided by TMathtext ;  tornado.C Show 3-d polymarker ;  transparency.C This macro demonstrates the use of color transparency ;  triangles.C Generate small triangles randomly in the canvas ;  ► graphs;  annotation3d.C This example show how to put some annotation on a 3D plot using 3D polylines ;  approx.C Macro to test interpolation function Approx ;  bent.C Bent error bars ;  bent.py Bent error bars ;  exclusiongraph.C Draw three graphs with an exclusion zone ;  exclusiongraph2.C Draw several graphs with an exclusion zones ;  gerrors.C Draw a graph with error bars ;  gerrors2.C Draw two graphs with error bars ;  graph.C Draw a simple graph ;  graph2derrorsfit.C Draw and fit a TGraph2DErrors ;  graphApply.C A macro to demonstrate the functionality of TGraph::Apply() method ;  graphpalettecolor.C Palette coloring for graphs is activated thanks to the options PFC (Palette Fill Color), PLC (Palette Line Color) and AMC (Palette Marker Color) ;  graphpolar.C Create and draw a polar graph ;  graphpolar2.C Create and draw a polar graph with PI axis ;  graphpolar3.C Create and draw a polar graph with PI axis using a TF1 ;  graphShade.C Show how to shade an area between two graphs ;  graphstruct.C Draw a simple graph structure ;  graphtext.C Draw a graph with text attached to each point ;  gtime.C Example of TGraphTime ;  gtime2.C Example of TGraphTime showing how the class could be used to visualize a set of particles with their time stamp in a MonteCarlo program ;  labels1.C Setting alphanumeric labels in a 1-d histogram ;  labels2.C Setting alphanumeric labels ;  motorcycle.C Macro to test scatterplot smoothers: ksmooth, lowes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/files.html:114572,simpl,simple,114572,doc/v612/files.html,https://root.cern,https://root.cern/doc/v612/files.html,2,['simpl'],['simple']
Usability,"ing the error, and a test dataset that will avoid bias. Those two datasets can be built aside and then given to the network, or can be built from a standard expression. By default, half of the events are put in both datasets.; // a more complex 4:8:1 network; // the ptsumf branch is used as weigh;; // default event lists are explicit; TMultiLayerPerceptron network(""m,pt,acol,acopl:8:type"",""pt"",tree,; ""Entry$%2"",""Entry$/2"");; The method TMultiLayerPerceptron::SetLearningMethod() defines the learning method. Learning methods are:; TMultiLayerPerceptron::kStochastic,; TMultiLayerPerceptron::kBatch,; TMultiLayerPerceptron::kSteepestDescent,; TMultiLayerPerceptron::kRibierePolak,; TMultiLayerPerceptron::kFletcherReeves,; TMultiLayerPerceptron::kBFGS // default; The training can start with TMultiLayerPerceptron::Train(Int_t nepoch,Option_t* options). The first argument is the number of epochs while option is a string that can contain “text” (simple text output), “graph” (evaluating graphical training curves), “update = X” (step for the text/graph output update) or “+” (will skip the randomization and start from the previous values). All combinations are available.; network.Train(1000,""text,graph,update=10""); // full output every; // 10 epochs; network.Train(100,""text,+""); // 100 more epochs; //starts with existing weights; The weights can be saved to a file (DumpWeights) and then reloaded (LoadWeights) to a new compatible network. The output can also be evaluated (Evaluate) for a given output neuron and an array of double input parameters or the network can be exported (Export) as a standalone code. Up to now, this is only as a C++ or PYTHON class, but other languages could be implemented.; 5.12.5 Examples; An example of how to use TMultiLayerPerceptron is the macro mlpHiggs.C in $ROOTSYS/tutorials. Using some standard simulated information that could have been obtained at LEP, a neural network is build, which can make the difference between WW events and events containin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:237036,simpl,simple,237036,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simple']
Usability,"ing using OpenGL](\ref HP29); 118 - [General information: plot types and supported options](\ref HP29a); 119 - [TH3 as color boxes](\ref HP290); 120 - [TH3 as boxes (spheres)](\ref HP29b); 121 - [TH3 as iso-surface(s)](\ref HP29c); 122 - [TF3 (implicit function)](\ref HP29d); 123 - [Parametric surfaces](\ref HP29e); 124 - [Interaction with the plots](\ref HP29f); 125 - [Selectable parts](\ref HP29g); 126 - [Rotation and zooming](\ref HP29h); 127 - [Panning](\ref HP29i); 128 - [Box cut](\ref HP29j); 129 - [Plot specific interactions (dynamic slicing etc.)](\ref HP29k); 130 - [Surface with option ""GLSURF""](\ref HP29l); 131 - [TF3](\ref HP29m); 132 - [Box](\ref HP29n); 133 - [Iso](\ref HP29o); 134 - [Parametric plot](\ref HP29p); 135- [Highlight mode for histogram](\ref HP30); 136 - [Highlight mode and user function](\ref HP30a); 137 ; 138 ; 139\anchor HP00; 140## Introduction; 141 ; 142 ; 143Histograms are drawn via the `THistPainter` class. Each histogram has a; 144pointer to its own painter (to be usable in a multithreaded program). When the; 145canvas has to be redrawn, the `Paint` function of each objects in the; 146pad is called. In case of histograms, `TH1::Paint` invokes directly; 147`THistPainter::Paint`.; 148 ; 149To draw a histogram `h` it is enough to do:; 150 ; 151 h->Draw();; 152 ; 153`h` can be of any kind: 1D, 2D or 3D. To choose how the histogram will; 154be drawn, the `Draw()` method can be invoked with an option. For instance; 155to draw a 2D histogram as a lego plot it is enough to do:; 156 ; 157 h->Draw(""lego"");; 158 ; 159`THistPainter` offers many options to paint 1D, 2D and 3D histograms.; 160 ; 161When the `Draw()` method of a histogram is called for the first time; 162(`TH1::Draw`), it creates a `THistPainter` object and saves a; 163pointer to this ""painter"" as a data member of the histogram. The; 164`THistPainter` class specializes in the drawing of histograms. It is; 165separated from the histogram so that one can have histograms without the; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:5413,usab,usable,5413,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['usab'],['usable']
Usability,"ing when produce pointer by buf.P() function ; Definition at line 333 of file TXMLPlayer.cxx. ◆ ElementSetter(). const char * TXMLPlayer::ElementSetter ; (; TClass * ; cl, . const char * ; membername, . char * ; endch . ). protected . Produce code to set value to given data member. ; endch should be output after value is specified. ; Definition at line 392 of file TXMLPlayer.cxx. ◆ GetBasicTypeName(). TString TXMLPlayer::GetBasicTypeName ; (; TStreamerElement * ; el). protected . return simple data types for given TStreamerElement object ; Definition at line 260 of file TXMLPlayer.cxx. ◆ GetBasicTypeReaderMethodName(). TString TXMLPlayer::GetBasicTypeReaderMethodName ; (; Int_t ; type, . const char * ; realname . ). protected . return functions name to read simple data type from xml file ; Definition at line 293 of file TXMLPlayer.cxx. ◆ GetMemberTypeName(). TString TXMLPlayer::GetMemberTypeName ; (; TDataMember * ; member). protected . returns name of simple data type for given data member ; Definition at line 222 of file TXMLPlayer.cxx. ◆ GetStreamerName(). TString TXMLPlayer::GetStreamerName ; (; TClass * ; cl). protected . returns streamer function name for given class ; Definition at line 150 of file TXMLPlayer.cxx. ◆ IsA(). TClass * TXMLPlayer::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 52 of file TXMLPlayer.h. ◆ ProduceCode(). Bool_t TXMLPlayer::ProduceCode ; (; TList * ; cllist, . const char * ; filename . ). Produce streamers for provide class list TList should include list of classes, for which code should be generated. ; filename specify name of file (without extension), where streamers should be created. Function produces two files: header file and source file. For instance, if filename is ""streamers"", files ""streamers.h"" and ""streamers.cxx"" will be created. ; Definition at line 167 of file TXMLPlayer.cxx. ◆ ProduceSTLstreamer(). Bool_t TXMLPlayer::ProduceSTLstreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLPlayer.html:14064,simpl,simple,14064,doc/master/classTXMLPlayer.html,https://root.cern,https://root.cern/doc/master/classTXMLPlayer.html,1,['simpl'],['simple']
Usability,ing! true if cache is in learning mode; Bool_tTTreeCache::fIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_tfLastReadPos; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; TMutex*fMutexListMutex to protect the various lists. Used by the condvars.; Int_tfNFound! number of blocks that were found in the cache; Int_tfNMissed! number of blocks that were not found in the cache and were unzipped; Int_tTTreeCache::fNReadMissNumber of blocks read and not found in the chache; Int_tTTreeCache::fNReadOkNumber of blocks read and found in the cache; Int_tTTreeCache::fNReadPrefNumber of blocks that were prefetched; Int_tfNStalls! number of hits which caused a stall; Int_tfNUnzip! number of blocks that were unzipped; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tTTreeCache::fNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tfNseekMax! fNseek can change so we need to know its max size; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tTTreeCache::fOneTime! used in the learning phase ; TTree*TTreeCache::fOwner! pointer to the owner Tree/chain; Bool_tfParallelIndicate if we want to activate the parallelism (for this instance); Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.; Bool_tTTreeCache::fReadDirectionSet! read direction established; Bool_tTTreeCache::fReverseRead! reading in reverse mode ; Long64_t*TFileCacheRead::fSeek[fNseek] Position on file of buffers to be prefetched; Int_t*TFileCacheRead::fSeekIndex[fNseek] sorted index table of fSeek; Int_t*TFileCacheRead::fSeekLen[fNseek] Length of buffers to be prefetched; Int_t*TFileCacheRead::fSeekPos[fNseek] Position of,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:11806,learn,learning,11806,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"ing...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Friends |; List of all members ; RooMCStudy Class ReferenceRooFit » RooFit Core. ; Helper class to facilitate Monte Carlo studies such as 'goodness-of-fit' studies, that involve fitting a PDF to multiple toy Monte Carlo sets. ; These may be generated from either same PDF or from a different PDF with similar parameters.; Given a fit and a generator PDF (they might be identical), RooMCStudy can produce toyMC samples and/or fit these. It accumulates the post-fit parameters of each iteration in a dataset. These can be retrieved using fitParams() or fitParDataSet(). This dataset additionally contains the variables; NLL: The value of the negative log-likelihood for each run.; ngen: The number of events generated for each run. Additional plotting routines simplify the task of plotting the distribution of the minimized likelihood, the fitted parameter values, fitted error and pull distribution.; RooMCStudy provides the option to insert add-in modules that modify the generate-and-fit cycle and allow to perform extra steps in the cycle. Output of these modules can be stored alongside the fit results in the aggregate results dataset. These study modules should derive from the class RooAbsMCStudyModule.; Check the RooFit tutorials; rf801_mcstudy.C; rf802_mcstudy_addons.C; rf803_mcstudy_addons2.C; rf804_mcstudy_constr.C for usage examples. PyROOT; Some member functions of RooMCStudy that take a RooCmdArg as argument also support keyword arguments. So far, this applies to constructor RooMCStudy(), RooMCStudy::plotParamOn, RooMCStudy::plotParam, RooMCStudy::plotNLL, RooMCStudy::plotError and RooMCStudy::plotPull. For example, the following code is equivalent in PyROOT: # Directly passing a RooCmdArg:; frame3 = mcstudy.plotPull(mean, ROOT.RooFit.Bins(40), ROOT.RooFit.FitGauss(True)); ; # With keywor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMCStudy.html:1042,simpl,simplify,1042,doc/master/classRooMCStudy.html,https://root.cern,https://root.cern/doc/master/classRooMCStudy.html,1,['simpl'],['simplify']
Usability,"ing::GetFunctionTemplate(ClassInfo_t *opaque_cl, const char* name); 5178{; 5179 R__LOCKGUARD(gInterpreterMutex);; 5180 DeclId_t f;; 5181 TClingClassInfo *cl = (TClingClassInfo*)opaque_cl;; 5182 if (cl) {; 5183 f = cl->GetFunctionTemplate(name);; 5184 }; 5185 else {; 5186 TClingClassInfo gcl(GetInterpreterImpl());; 5187 f = gcl.GetFunctionTemplate(name);; 5188 }; 5189 return f;; 5190 ; 5191}; 5192 ; 5193////////////////////////////////////////////////////////////////////////////////; 5194/// The 'name' is known to the interpreter, this function returns; 5195/// the internal version of this name (usually just resolving typedefs); 5196/// This is used in particular to synchronize between the name used; 5197/// by rootcling and by the run-time environment (TClass); 5198/// Return 0 if the name is not known.; 5199 ; 5200void TCling::GetInterpreterTypeName(const char* name, std::string &output, Bool_t full); 5201{; 5202 output.clear();; 5203 ; 5204 R__LOCKGUARD(gInterpreterMutex);; 5205 ; 5206 TClingClassInfo cl(GetInterpreterImpl(), name);; 5207 if (!cl.IsValid()) {; 5208 return ;; 5209 }; 5210 if (full) {; 5211 cl.FullName(output,*fNormalizedCtxt);; 5212 return;; 5213 }; 5214 // Well well well, for backward compatibility we need to act a bit too; 5215 // much like CINT.; 5216 TClassEdit::TSplitType splitname( cl.Name(), TClassEdit::kDropStd );; 5217 splitname.ShortType(output, TClassEdit::kDropStd );; 5218 ; 5219 return;; 5220}; 5221 ; 5222////////////////////////////////////////////////////////////////////////////////; 5223/// Execute a global function with arguments params.; 5224///; 5225/// FIXME: The cint-based version of this code does not check if the; 5226/// SetFunc() call works, and does not do any real checking; 5227/// for errors from the Exec() call. It did fetch the most; 5228/// recent cint security error and return that in error, but; 5229/// this does not really translate well to cling/clang. We; 5230/// should enhance these interfaces so that we can rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:202413,clear,clear,202413,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['clear'],['clear']
Usability,"ing; 1190/// function is a polynomial, a linear fitter is initialised.; 1191/// To create a linear function, use the following syntax: linear parts; 1192/// separated by `++` sign.; 1193/// Example: to fit the parameters of the function `p0*x + p1*sin(x)`, you can create a; 1194/// TF1 object as; 1195///; 1196/// TF1 *f1 = new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; 1197///; 1198/// For such a TF1 you don't have to set the initial conditions and the linear fitter is used.; 1199/// Going via the linear fitter for functions, linear in parameters, gives a; 1200/// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:43124,simpl,simple,43124,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['simpl'],['simple']
Usability,ings: SC_factor. ; Definition at line 201 of file MethodMLP.h. ◆ fGA_SC_rate. Int_t TMVA::MethodMLP::fGA_SC_rate. private . GA settings: SC_rate. ; Definition at line 200 of file MethodMLP.h. ◆ fGA_SC_steps. Int_t TMVA::MethodMLP::fGA_SC_steps. private . GA settings: SC_steps. ; Definition at line 199 of file MethodMLP.h. ◆ fgPRINT_BATCH. const Bool_t TMVA::MethodMLP::fgPRINT_BATCH = kFALSE. staticprivate . debug flags ; Definition at line 217 of file MethodMLP.h. ◆ fgPRINT_ESTIMATOR_INC. const Int_t TMVA::MethodMLP::fgPRINT_ESTIMATOR_INC = 10. staticprivate . debug flags ; Definition at line 215 of file MethodMLP.h. ◆ fgPRINT_SEQ. const Bool_t TMVA::MethodMLP::fgPRINT_SEQ = kFALSE. staticprivate . debug flags ; Definition at line 216 of file MethodMLP.h. ◆ fLastAlpha. Double_t TMVA::MethodMLP::fLastAlpha. private . line search variable ; Definition at line 183 of file MethodMLP.h. ◆ fLearnRate. Double_t TMVA::MethodMLP::fLearnRate. private . learning rate for synapse weight adjustments ; Definition at line 188 of file MethodMLP.h. ◆ fPrior. Double_t TMVA::MethodMLP::fPrior. private . zjh ; Definition at line 166 of file MethodMLP.h. ◆ fPriorDev. std::vector<Double_t> TMVA::MethodMLP::fPriorDev. private . zjh ; Definition at line 167 of file MethodMLP.h. ◆ fResetStep. Int_t TMVA::MethodMLP::fResetStep. private . reset time (how often we clear hessian matrix) ; Definition at line 185 of file MethodMLP.h. ◆ fSamplingEpoch. Float_t TMVA::MethodMLP::fSamplingEpoch. private . fraction of epochs where sampling is used ; Definition at line 177 of file MethodMLP.h. ◆ fSamplingFraction. Float_t TMVA::MethodMLP::fSamplingFraction. private . fraction of events which is sampled for training ; Definition at line 176 of file MethodMLP.h. ◆ fSamplingTesting. Bool_t TMVA::MethodMLP::fSamplingTesting. private . The testing sample is sampled. ; Definition at line 180 of file MethodMLP.h. ◆ fSamplingTraining. Bool_t TMVA::MethodMLP::fSamplingTraining. private . The training sample is s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html:52218,learn,learning,52218,doc/master/classTMVA_1_1MethodMLP.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodMLP.html,1,['learn'],['learning']
Usability,ings::m_batchSize. mini-batch size ; Definition at line 838 of file NeuralNet.h. ◆ m_convergenceCount. size_t TMVA::DNN::Settings::m_convergenceCount. Definition at line 857 of file NeuralNet.h. ◆ m_convergenceSteps. size_t TMVA::DNN::Settings::m_convergenceSteps. number of steps without improvement to consider the DNN to have converged ; Definition at line 837 of file NeuralNet.h. ◆ m_dropOut. std::vector<double> TMVA::DNN::Settings::m_dropOut. Definition at line 850 of file NeuralNet.h. ◆ m_dropRepetitions. double TMVA::DNN::Settings::m_dropRepetitions. Definition at line 849 of file NeuralNet.h. ◆ m_factorWeightDecay. double TMVA::DNN::Settings::m_factorWeightDecay. Definition at line 840 of file NeuralNet.h. ◆ m_maxConvergenceCount. size_t TMVA::DNN::Settings::m_maxConvergenceCount. Definition at line 858 of file NeuralNet.h. ◆ m_maxProgress. double TMVA::DNN::Settings::m_maxProgress. current limits for the progress bar ; Definition at line 834 of file NeuralNet.h. ◆ m_minError. double TMVA::DNN::Settings::m_minError. Definition at line 859 of file NeuralNet.h. ◆ m_minProgress. double TMVA::DNN::Settings::m_minProgress. current limits for the progress bar ; Definition at line 833 of file NeuralNet.h. ◆ m_regularization. EnumRegularization TMVA::DNN::Settings::m_regularization. Definition at line 847 of file NeuralNet.h. ◆ m_testRepetitions. size_t TMVA::DNN::Settings::m_testRepetitions. Definition at line 839 of file NeuralNet.h. ◆ m_timer. Timer TMVA::DNN::Settings::m_timer. timer for monitoring ; Definition at line 832 of file NeuralNet.h. ◆ m_useMultithreading. bool TMVA::DNN::Settings::m_useMultithreading. protected . Definition at line 863 of file NeuralNet.h. Libraries for TMVA::DNN::Settings:. [legend]; The documentation for this class was generated from the following files:; tmva/tmva/inc/TMVA/NeuralNet.h; tmva/tmva/src/NeuralNet.cxx. TMVADNNSettings. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:45 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:15225,progress bar,progress bar,15225,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['progress bar'],['progress bar']
Usability,"inition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2144; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:8373,learn,learning,8373,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,1,['learn'],['learning']
Usability,"inition RSha256.hxx:104; nentriesint nentriesDefinition THbookFile.cxx:91; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; Reading a subset of all branches; In the Process function we read a subset of the branches. Only the branches used in the first entry will be put in the cache TTree *T;; f->GetObject(T, ""mytree"");; // We want to process only the 200 first entries; auto nentries=200UL;; auto efirst = 0;; auto elast = efirst+nentries;; auto cachesize = 10000000U; // 10 MBytes; TTreeCache::SetLearnEntries(1); //<<< we can take the decision after 1 entry; T->SetCacheSize(cachesize); //<<<; T->SetCacheEntryRange(efirst,elast); //<<<; T->Process(""myselector.C+"","""",nentries,efirst);; // In the TSelector::Process we read only 2 branches; auto b1 = T->GetBranch(""branch1"");; b1->GetEntry(i);; if (somecondition) return;; auto b2 = T->GetBranch(""branch2"");; b2->GetEntry(i);; ... Here the entry is processed; TTreeCache::SetLearnEntriesstatic void SetLearnEntries(Int_t n=10)Static function to set the number of entries to be used in learning mode The default value for n is 1...Definition TTreeCache.cxx:2145; ; Custom event loop; Always using the same two branches; In this example, exactly two branches are always used: those need to be prefetched. TTree *T;; f->GetObject(T, ""mytree"");; auto b1 = T->GetBranch(""branch1"");; auto b2 = T->GetBranch(""branch2"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; //10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(b1, true); //<<< add branch1 and branch2 to the cache; T->AddBranchToCache(b2, true); //<<<; T->StopCacheLearningPhase(); //<<< we do not need the system to guess anything; for (auto i : TSeqL(nentries)) {; T->LoadTree(i); //<<< important call when calling TBranch::GetEntry after; b1->GetEntry(i);; if (some condition not met) continue;; b2->GetEntry(i);; if (some condition not met) continue;; // Here we read the full event only in some rare cases.; // There is no point in caching ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:8374,learn,learning,8374,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['learn'],['learning']
Usability,"inition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TCurlyArcImplements curly or wavy arcs used to draw Feynman diagrams.Definition TCurlyArc.h:16; TCurlyArc::TCurlyArcTCurlyArc()Default constructor.Definition TCurlyArc.cxx:45; TCurlyLineImplements curly or wavy polylines used to draw Feynman diagrams.Definition TCurlyLine.h:19; TCurlyLine::TCurlyLineTCurlyLine()Default constructor.Definition TCurlyLine.cxx:46; TCurlyLine::SetWavyvirtual void SetWavy()Set wavy.Definition TCurlyLine.cxx:369; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TPolyLine::Drawvoid Draw(Option_t *option="""") overrideDraw this polyline with its current attributes.Definition TPolyLine.cxx:215; int; c1return c1Definition legend1.C:41; ginitstatic int ginitDefinition rsalib.cxx:256; lTLine lDefinition textangle.C:4; . Definition at line 16 of file TCurlyArc.h. Public Member Functions;  TCurlyArc ();  Default constructor. ;  ;  TCurlyArc (Double_t x1, Double_t y1, Double_t rad, Double_t phimin, Double_t phimax, Double_t wl=.02, Double_t amp=.01);  Create a new TCurlyArc with center (x1, y1) and radius rad. ;  ;  ~TCurlyArc () override;  ; void Build () override;  Create a curly (Gluon) or wavy (Gamma) arc. ;  ; Int_t DistancetoPrimitive (Int_t px, Int_t py) override;  Compute distance from point px,py to an arc. ;  ; void ExecuteEvent (Int_t event, Int_t px, Int_t py) override;  Exe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCurlyArc.html:3330,simpl,simple,3330,doc/master/classTCurlyArc.html,https://root.cern,https://root.cern/doc/master/classTCurlyArc.html,1,['simpl'],['simple']
Usability,"inition TGWin32VirtualXProxy.cxx:104; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; namechar name[80]Definition TGX11.cxx:110; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TMatrixDSym.h; TMatrixD.h; TPaveText.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; RooAbsArgCommon abstract base class for objects that represent a value and a ""shape"" in RooFit.Definition RooAbsArg.h:79; RooAbsArg::clearValueAndShapeDirtyvoid clearValueAndShapeDirty() constDefinition RooAbsArg.h:571; RooAbsArg::Printvoid Print(Option_t *options=nullptr) const overridePrint the object to the defaultPrintStream().Definition RooAbsArg.h:294; RooAbsArg::dependsOnbool dependsOn(const RooAbsCollection &serverList, const RooAbsArg *ignoreArg=nullptr, bool valueOnly=false) constTest whether we depend on (ie, are served by) any object in the specified collection.Definition RooAbsArg.cxx:850; RooAbsArg::constR__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg constDefinition RooAbsArg.h:145; RooAbsArg::setOperModevoid setOperMode(OperMode mode, bool recurseADirty=true)Set the operation mode of this node.Definition RooAbsArg.cxx:1963; RooAbsArg::getParametersRooFit::OwningPtr< RooArgSet > getParameters(const RooAbsData *data, bool stripDisconnected=true) constCreate a list of leaf nodes in the arg tree starti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:135347,clear,clearValueAndShapeDirtyvoid,135347,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,2,['clear'],"['clearValueAndShapeDirty', 'clearValueAndShapeDirtyvoid']"
Usability,"inition at line 1181 of file TTree.cxx. ◆ DropBuffers(). void TTree::DropBuffers ; (; Int_t ; nbytes). virtual . Drop branch buffers to accommodate nbytes below MaxVirtualsize. ; Definition at line 4531 of file TTree.cxx. ◆ EnableCache(). bool TTree::EnableCache ; (; ). Enable the TTreeCache unless explicitly disabled for this TTree by a prior call to SetCacheSize(0). ; If the environment variable ROOT_TTREECACHE_SIZE or the rootrc config TTreeCache.Size has been set to zero, this call will over-ride them with a value of 1.0 (i.e. use a cache size to hold 1 cluster); Return true if there is a cache attached to the TTree (either pre-exisiting or created as part of this call) ; Definition at line 2685 of file TTree.cxx. ◆ Fill(). Int_t TTree::Fill ; (; ). virtual . Fill all branches. ; This function loops on all the branches of this tree. For each branch, it copies to the branch buffer (basket) the current values of the leaves data types. If a leaf is a simple data type, a simple conversion to a machine independent format has to be done.; This machine independent version of the data is copied into a basket (each branch has its own basket). When a basket is full (32k worth of data by default), it is then optionally compressed and written to disk (this operation is also called committing or 'flushing' the basket). The committed baskets are then immediately removed from memory.; The function returns the number of bytes committed to the individual branches.; If a write error occurs, the number of bytes returned is -1.; If no data are written, because, e.g., the branch is disabled, the number of bytes returned is 0.; The baskets are flushed and the Tree header saved at regular intervals; At regular intervals, when the amount of data written so far is greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk. This makes future reading faster as it guarantees that baskets belonging to nearby entries will be on the same disk region. When the first call to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:138827,simpl,simple,138827,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,4,['simpl'],['simple']
Usability,"inition at line 41 of file TEveScene.cxx. ◆ TEveScene() [3/3]. TEveScene::TEveScene ; (; TGLScenePad * ; gl_scene, . const char * ; n = ""TEveScene"", . const char * ; t = """" . ). Constructor. ; Definition at line 60 of file TEveScene.cxx. ◆ ~TEveScene(). TEveScene::~TEveScene ; (; ). override . Destructor. ; Definition at line 79 of file TEveScene.cxx. Member Function Documentation. ◆ Changed(). void TEveScene::Changed ; (; ). inline . Definition at line 51 of file TEveScene.h. ◆ Class(). static TClass * TEveScene::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TEveScene::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TEveScene::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 71 of file TEveScene.h. ◆ CollectSceneParents(). void TEveScene::CollectSceneParents ; (; List_t & ; scenes). overridevirtual . Virtual from TEveElement; here we simply append this scene to the list. ; Reimplemented from TEveElement.; Definition at line 93 of file TEveScene.cxx. ◆ DeclFileName(). static const char * TEveScene::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 71 of file TEveScene.h. ◆ DestroyElementRenderers() [1/2]. void TEveScene::DestroyElementRenderers ; (; TEveElement * ; element). Remove element from the scene. ; It is not an error if the element is not found in the scene. ; Definition at line 199 of file TEveScene.cxx. ◆ DestroyElementRenderers() [2/2]. void TEveScene::DestroyElementRenderers ; (; TObject * ; rnrObj). Remove element represented by object rnrObj from the scene. ; It is not an error if the element is not found in the scene. ; Definition at line 212 of file TEveScene.cxx. ◆ GetGLScene(). TGLScenePad * TEveScene::GetGLScene ; (; ); const. inline . Definition at line 60 of file TEveScene.h. ◆ GetHierarchical(). Bool_t TEveScene::GetHierarchical ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveScene.html:35651,simpl,simply,35651,doc/master/classTEveScene.html,https://root.cern,https://root.cern/doc/master/classTEveScene.html,1,['simpl'],['simply']
Usability,"inition at line 449 of file RooAbsCategory.cxx. ◆ attachToVStore(). void RooAbsCategory::attachToVStore ; (; RooVectorDataStore & ; vstore). overrideprotectedvirtual . Attach the category index and label to as branches to the given vector store. ; Implements RooAbsArg.; Definition at line 436 of file RooAbsCategory.cxx. ◆ begin(). std::map< std::string, value_type >::const_iterator RooAbsCategory::begin ; (; ); const. inline . Iterator for category state names. Points to pairs of index and name. ; Definition at line 91 of file RooAbsCategory.h. ◆ Class(). static TClass * RooAbsCategory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCategory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCategory::Class_Version ; (; ). inlinestaticconstexpr . A buffer for reading values from trees. ; ReturnsVersion of this class ; Definition at line 226 of file RooAbsCategory.h. ◆ clearTypes(). void RooAbsCategory::clearTypes ; (; ). protected . Delete all currently defined states. ; Definition at line 277 of file RooAbsCategory.cxx. ◆ copyCache(). void RooAbsCategory::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value from given source and raise dirty flag. ; It is the callers responsibility to ensure that the sources cache is clean(valid) before this function is called, e.g. by calling syncCache() on the source. ; Implements RooAbsArg.; Reimplemented in RooAbsCategoryLValue.; Definition at line 560 of file RooAbsCategory.cxx. ◆ createFundamental(). RooFit::OwningPtr< RooAbsArg > RooAbsCategory::createFundamental ; (; const char * ; newname = nullptr); const. overridevirtual . Create a RooCategory fundamental object with our properties. ; Implements RooAbsArg.; Definition at line 642 of file RooAbsCategory.cxx. ◆ createTable(). Roo1DTable * RooAbsCategory::createTab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:47963,clear,clearTypes,47963,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['clear'],['clearTypes']
Usability,"inition for most cases without need for a RooFormulaVar object: e.g. a Gaussian resolution PDF do setConvolutionWindow(gaussMean,gaussSigma,5) Note that for a 'wide' Gaussian the -inf to +inf integration may converge more quickly than that over a finite range! The default numeric precision is 1e-7, i.e. the global default for numeric integration but you should experiment with this value to see if it is sufficient for example by studying the number of function calls that MINUIT needs to fit your function as function of the convolution precision. ; Definition at line 26 of file RooNumConvPdf.h. Public Member Functions;  RooNumConvPdf ();  ;  RooNumConvPdf (const char *name, const char *title, RooRealVar &convVar, RooAbsPdf &pdf, RooAbsPdf &resmodel);  ;  RooNumConvPdf (const RooNumConvPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumConvPdf () override;  Destructor. ;  ; void clearConvolutionWindow ();  ; TObject * clone (const char *newname) const override;  ; RooNumIntConfig & convIntConfig ();  ; double evaluate () const override;  Calculate and return value of p.d.f. ;  ; TClass * IsA () const override;  ; RooAbsReal & model () const;  ; RooAbsReal & pdf () const;  ; void printMetaArgs (std::ostream &os) const override;  Customized printing of arguments of a RooNumConvPdf to more intuitively reflect the contents of the product operator construction. ;  ; const TH2 * profileData () const;  ; void setCallProfiling (bool flag, Int_t nbinX=40, Int_t nbinCall=40, Int_t nCallHigh=1000);  ; void setCallWarning (Int_t threshold=2000);  ; void setConvolutionWindow (RooAbsReal &centerParam, RooAbsReal &widthParam, double widthScaleFactor=1);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; RooRealVar & var () const;  ;  Public Member Functions inherited from RooAbsPdf;  RooAbsPdf ();  Default constructor. ;  ;  RooAbsPdf (const char *name, const char *title, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumConvPdf.html:2952,clear,clearConvolutionWindow,2952,doc/master/classRooNumConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooNumConvPdf.html,1,['clear'],['clearConvolutionWindow']
Usability,"ink(TObject* obj, Option_t* opt, TObjLink* prev = NULL); virtual voidPrintCollectionEntry(TObject* entry, Option_t* option, Int_t recurse) const; virtual voidTQCommand::PrintCollectionHeader(Option_t* option) const. Data Members; public:. enum TCollection::[unnamed] { kIsOwner; kInitCapacity; kInitHashTableCapacity; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TQCommand*fCurrentthe latest executed command; TObjLink*fCursorcurrent position in history stack; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; UInt_tfLimitmaximum number of commands can be located in stack; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; TList*fLogBooklisting of all actions during execution; Bool_tfLoggingkTRUE if logging is ON; Int_tTQCommand::fNRargsnumber of redo arguments; Int_tTQCommand::fNUargsnumber of undo arguments; TStringTQCommand::fNamecommand name. Default is ""ClassName::RedoName(args)""; TStringTCollection::fNamename of the collection; Bool_tTQCommand::fNewDeletekTRUE if Redo/Undo methods are new/delete; void*TQCommand::fObjectobject to which undo/redo actions applied; TQConnection*TQCommand::fRedodo/redo action; Long_t*TQCommand::fRedoArgsredo values; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; Int_tTQCommand::fState-1 undoing on, 1 redoing on, 0 nothing in progress; Int_tTQC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:17475,undo,undo,17475,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,4,['undo'],['undo']
Usability,"inkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidclearConvolutionWindow(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); RooNumIntConfig&convIntConfig(); const RooNumIntConfig&convIntConfig() const; virtual voidTNamed::Copy(TObject& named) const; static voidRooAbsArg::copyList(TList& dest, const TList& source); static UInt_tRooAbsArg::crc32(const char* data); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataSet& data, const RooLinkedList& cmdList); virtual RooAbsReal*RooAbsReal::createChi2(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvolution.html:5343,clear,clearEvalErrorLog,5343,root/html526/RooNumConvolution.html,https://root.cern,https://root.cern/root/html526/RooNumConvolution.html,2,['clear'],['clearEvalErrorLog']
Usability,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Jun 30 14:30:02 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCollection.html:22627,clear,clearStructureTags,22627,root/html602/RooAbsCollection.html,https://root.cern,https://root.cern/root/html602/RooAbsCollection.html,1,['clear'],['clearStructureTags']
Usability,"inkedList(), const RooCmdArg* formatCmd = 0) const; Internal implementation function of printLatex. Bool_t allInRange(const char* rangeSpec) const; Return true if all contained object report to have their; value inside the specified range. void makeStructureTag(). void makeTypedStructureTag(). TObject* clone(const char* newname) const. TObject* create(const char* newname) const. TObject* Clone(const char* newname = 0) const. void setHashTableSize(Int_t i); Hash table control. Int_t getHashTableSize() const; Return size of internal hash table. Bool_t contains(const RooAbsArg& var) const; Returns true if object with same name as var is contained in this collection. Bool_t containsInstance(const RooAbsArg& var) const; Returns true if var is contained in this collection. TIterator* createIterator(Bool_t dir = kIterForward) const; export subset of THashList interface. RooFIter fwdIterator() const; { return RooFIter(&_list); }. Int_t getSize() const; Return the number of elements in the collection. RooAbsArg * first() const; Return the first element in this collection. void Print(Option_t* options = 0) const; Printing interface (human readable). void setName(const char* name); Set name of collection. const char* GetName() const; Return namer of collection. Bool_t isOwning() const; Does collection own contents?. void releaseOwnership(); { _ownCont = kFALSE ; }. void takeOwnership(); { _ownCont = kTRUE ; }. void sort(Bool_t ascend = kTRUE); { _list.Sort(ascend) ; }. TNamed* structureTag(); { if (_structureTag==0) makeStructureTag() ; return _structureTag ; }. TNamed* typedStructureTag(); { if (_typedStructureTag==0) makeTypedStructureTag() ; return _typedStructureTag ; }. void clearStructureTags(); { _structureTag=0 ; _typedStructureTag = 0 ; }. » Last changed: Tue Mar 10 17:13:56 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCollection.html:21117,clear,clearStructureTags,21117,root/html534/RooAbsCollection.html,https://root.cern,https://root.cern/root/html534/RooAbsCollection.html,1,['clear'],['clearStructureTags']
Usability,"inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 98 of file TQCommand.h. ◆ Delete(). void TQCommand::Delete ; (; Option_t * ; opt = """"). overridevirtual . If ""opt"" is not zero delete every merged command which option string is equal to ""opt"". ; If ""opt"" is zero - delete all merged commands. ; Reimplemented from TList.; Definition at line 285 of file TQCommand.cxx. ◆ GetCommand(). TQCommand * TQCommand::GetCommand ; (; ). static . Return a command which is doing redo/undo action. ; This static method allows to set undo parameters dynamically, i.e. during execution of Redo function.; Example: For redo actions like TGTextEdit::DelChar() it is not possible to know ahead what character will be deleted. To set arguments for undo action ( e.g. TGTextEdit::InsChar(char)), one needs to call TQCommand::SetUndoArgs(1, character) from inside of TGTextEdit::DelChar() method, i.e. TQCommand::GetCommand()->SetUndoArgs(1, somechar);; TQCommand::GetCommandstatic TQCommand * GetCommand()Return a command which is doing redo/undo action.Definition TQCommand.cxx:276. Definition at line 276 of file TQCommand.cxx. ◆ GetName(). const char * TQCommand::GetName ; (; ); const. overridevirtual . Returns the command name. ; Default name is ""ClassName::RedoName(args)"" If list of merged commands is not empty the name is ""ClassName::RedoName(args):cname1:cname2 ..."" ; Reimplemented from TCollection.; Definition at line 670 of file TQCommand.cxx. ◆ GetNRargs(). Int_t TQCommand::GetNRargs ; (; ); const. Returns a number of redo arguments. ; Definition at line 768 of file TQCommand.cxx. ◆ GetNUargs(). Int_t TQCommand::GetNUargs ; (; ); const. Returns a number of undo arguments. ; Definition at line 776 of file TQCommand.cxx. ◆ GetObject(). void * TQCommand::GetObject ; (; ); const. Returns an object for which undo redo actions are applied. ; Definition at line 784 of file TQCommand.cxx. ◆ GetRedo(). TQConnection * TQCommand::GetRedo ; (; ); const. inline . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQCommand.html:37152,undo,undo,37152,doc/master/classTQCommand.html,https://root.cern,https://root.cern/doc/master/classTQCommand.html,1,['undo'],['undo']
Usability,"int const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; Note that RResult<void> can be used for a function without return value, like this; RResult<void> DoSomething(); {; if (failure); return R__FAIL(""user-facing error messge"");; return RResult<void>::Success();; }; RResult<T>::Unwrap() can be used as a short hand for ""give me the wrapped value or, in case of an error, throw"". For instance:; int value = FuncThatReturnsRResultOfInt().Unwrap(); // may throw; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; There is no implict operator that converts RResult<T> to T. This is intentional to make it clear in the calling code where an exception may be thrown. ; Definition at line 194 of file RError.hxx. Public Member Functions;  RResult (const RResult &other)=delete;  ;  RResult (const T &value);  ;  RResult (RError &&error);  ;  RResult (RResult &&other)=default;  ;  RResult (T &&value);  ;  ~RResult ()=default;  ; RResult & Forward (RError::RLocation &&sourceLocation);  Used by R__FORWARD_RESULT in order to keep track of the stack trace in case of errors. ;  ; const T & Inspect ();  If the operation was successful, returns a const reference to the inner type. ;  ;  operator bool ();  ; RResult & operator= (const RResult &other)=delete;  ; RResult & operator= (RResult &&other)=default;  ; T Unwrap ();  If the operation was successful, returns the inner type by value. ;  ;  Public Member Functions inherited from ROOT::Experimental::RResultBase;  RResultBase (const RResultBase &other)=delete;  ;  RResultBase (RResultBase &&other)=default;  ;  ~RResultBase () noexcept(false);  ; RError * GetError ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RResult.html:2770,clear,clear,2770,doc/master/classROOT_1_1Experimental_1_1RResult.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RResult.html,1,['clear'],['clear']
Usability,"int nElements, TBuffer& b); voidWriteMap(UInt_t nElements, TBuffer& b). private:. TEmulatedMapProxy&operator=(const TEmulatedMapProxy& rhs). Data Members; public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t); static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBIT_ISTSTRING; static TGenCollectionProxy::(anonymous)TGenCollectionProxy::kBOOL_t; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsAssociative; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kIsEmulated; static TVirtualCollectionProxy::EPropertyTVirtualCollectionProxy::kNeedDelete. protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; TGenCollectionProxy::Collectfunc_tTGenCollectionProxy::fCollectMethod to collect objects from container; TGenCollectionProxy::ArrIterfunc_tTGenCollectionProxy::fConstructContainer accessors: block construct; map<string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; TGenCollectionProxy::Sizing_tTGenCollectionProxy::fDestructContainer accessors: block destruct; TGenCollectionProxy::EnvironBase_t*TGenCollectionProxy::fEnvAddress of the currently proxied object; TGenCollectionProxy::Feedfunc_tTGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; TVirtualCollectionProxy::CopyIterator_tTGenCollectionProxy::fFunctionCopyIterator; TVirtualCollectionProxy::CreateIterators_tTGenCollectionProxy::fFunctionCreateIterators; TVirtualCollectionProxy::DeleteIterator_tTGenCollectionProxy::fFunctionDeleteI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEmulatedMapProxy.html:5390,clear,clear,5390,root/html602/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html602/TEmulatedMapProxy.html,2,['clear'],['clear']
Usability,"inted using ELogLevel.kDebug and even more (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using ELogLevel.kDebug+10. Creating an RDataFrame from a dataset specification file; RDataFrame can be created using a dataset specification JSON file:; import ROOT; ; df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1729; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON file is the following:; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:77070,simpl,simple,77070,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"inted using ELogLevel.kDebug and even more (e.g. a full dump of the generated code that RDataFrame just-in-time-compiles) using ELogLevel.kDebug+10. Creating an RDataFrame from a dataset specification file; RDataFrame can be created using a dataset specification JSON file:; import ROOT; ; df = ROOT.RDF.Experimental.FromSpec(""spec.json""); ROOT::RDF::Experimental::FromSpecROOT::RDataFrame FromSpec(const std::string &jsonFile)Factory method to create an RDataFrame from a JSON specification file.Definition RDataFrame.cxx:1906; The input dataset specification JSON file needs to be provided by the user and it describes all necessary samples and their associated metadata information. The main required key is the ""samples"" (at least one sample is needed) and the required sub-keys for each sample are ""trees"" and ""files"". Additionally, one can specify a metadata dictionary for each sample in the ""metadata"" key.; A simple example for the formatting of the specification in the JSON file is the following:; {; ""samples"": {; ""sampleA"": {; ""trees"": [""tree1"", ""tree2""],; ""files"": [""file1.root"", ""file2.root""],; ""metadata"": {; ""lumi"": 10000.0, ; ""xsec"": 1.0,; ""sample_category"" = ""data""; }; },; ""sampleB"": {; ""trees"": [""tree3"", ""tree4""],; ""files"": [""file3.root"", ""file4.root""],; ""metadata"": {; ""lumi"": 0.5, ; ""xsec"": 1.5,; ""sample_category"" = ""MC_background""; }; }; }; }; The metadata information from the specification file can be then accessed using the DefinePerSample function. For example, to access luminosity information (stored as a double):; df.DefinePerSample(""lumi"", 'rdfsampleinfo_.GetD(""lumi"")'); or sample_category information (stored as a string):; df.DefinePerSample(""sample_category"", 'rdfsampleinfo_.GetS(""sample_category"")'); or directly the filename:; df.DefinePerSample(""name"", ""rdfsampleinfo_.GetSampleName()""); An example implementation of the ""FromSpec"" method is available in tutorial: df106_HiggstoFourLeptons.py, which also provides a corresponding exemplary JSON file for the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:78492,simpl,simple,78492,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['simpl'],['simple']
Usability,"inter to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. » Last change",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooObjCacheManager.html:4364,clear,clearOnRedirect,4364,root/html526/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html526/RooObjCacheManager.html,2,['clear'],['clearOnRedirect']
Usability,"inter to owning RooAbsArg; Int_tRooCacheManager<RooAbsCacheElement>::_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 10, Bool_t clearCacheOnServerRedirect = kTRUE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooObjCacheManager.html:4447,clear,clearOnRedirect,4447,root/html530/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html530/RooObjCacheManager.html,1,['clear'],['clearOnRedirect']
Usability,"interfaces is to spot memory leaks in RooFit-based frameworks. If you make sure that your framework compiles both with and without ROOFIT_MEMORY_SAFE_INTERFACES, you can get rid of all memory leaks related to RooFit user error! After making the necessary changes, you can remove the marco definition again to keep backwards compatibility.; Note that the memory-safe interfaces might become the default at some point, so doing this backwards-compatible migration early is strongly encouraged and appreciated.; Removal of some memory-unsafe interfaces. The final bool takeOwnership parameter of the RooAddition and RooStats::HistFactory::PiecewiseInterpolation constructors was removed. This is to avoid situations where ownership is not clear to the compiler. Now, ownership of the input RooAbsArgs is never passed in the constructor. If you want the pass input ownership to the created object, please use addOwnedComponents. If you want to be extra safe, make sure the inputs are in an owning collection and then std::move the collection, so that the ownership is always clear.; Example:; RooArgList sumSet;; sumSet.add(*(new RooRealVar(""var1"", ""var1"", 1.0)));; sumSet.add(*(new RooRealVar(""var2"", ""var2"", 3.0)));; RooAddition addition{""addition"", ""addition"", sumSet, /*takeOwnership=*/true};; should become:; RooArgList sumSet;; sumSet.addOwned(std::make_unique<RooRealVar>(""var1"", ""var1"", 1.0));; sumSet.addOwned(std::make_unique<RooRealVar>(""var2"", ""var2"", 3.0));; RooAddition addition{""addition"", ""addition"", sumSet};; addition.addOwnedComponents(std::move(sumSet));. Deprecation of legacy iterators; The following methods related to the RooFit legacy iterators are deprecated and will be removed in ROOT 6.34. They should be replaced with the suitable STL-compatible interfaces, or you can just use range-based loops:. RooAbsArg::clientIterator(): use clients() and begin(), end() or range-based loops instead; RooAbsArg::valueClientIterator(): use valueClients(); RooAbsArg::shapeClientIterator(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:11783,clear,clear,11783,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['clear'],['clear']
Usability,"interpolated histogram. ; Reimplemented from RooAbsReal.; Definition at line 686 of file ParamHistFunc.cxx. ◆ setConstant(). void ParamHistFunc::setConstant ; (; bool ; constant). Definition at line 233 of file ParamHistFunc.cxx. ◆ setParamConst(). void ParamHistFunc::setParamConst ; (; Int_t ; index, . bool ; varConst = true . ). Definition at line 227 of file ParamHistFunc.cxx. ◆ setShape(). void ParamHistFunc::setShape ; (; TH1 * ; shape). Definition at line 242 of file ParamHistFunc.cxx. ◆ Streamer(). void ParamHistFunc::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void ParamHistFunc::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 111 of file ParamHistFunc.h. ◆ translate(). void ParamHistFunc::translate ; (; RooFit::Detail::CodeSquashContext & ; ctx); const. overrideprotectedvirtual . This function defines a translation for each RooAbsReal based object that can be used to express the class as simple C++ code. ; The function adds the code represented by each class as an std::string (that is later concatenated with code strings from translate calls) to form the C++ code that AD tools can understand. Any class that wants to support AD, has to implement this function.; Parameters. [in]ctxAn object to manage auxiliary information for code-squashing. Also takes the code string that this class outputs into the squashed code through the 'addToCodeBody' function. . Reimplemented from RooAbsArg.; Definition at line 563 of file ParamHistFunc.cxx. Member Data Documentation. ◆ _dataSet. RooDataHist ParamHistFunc::_dataSet. mutableprotected . Definition at line 98 of file ParamHistFunc.h. ◆ _dataVars. RooListProxy ParamHistFunc::_dataVars. protected . The RooRealVars. ; Definition at line 82 of file ParamHistFunc.h. ◆ _normIntMgr. RooObjCacheManager ParamHistFunc::_normIntMgr. mutableprotected . ! The integration cache manager ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classParamHistFunc.html:73449,simpl,simple,73449,doc/master/classParamHistFunc.html,https://root.cern,https://root.cern/doc/master/classParamHistFunc.html,1,['simpl'],['simple']
Usability,"ion RCanvas.cxx:211; ROOT::Experimental::RCanvas::SetHeightvoid SetHeight(int height)Set canvas height.Definition RCanvas.hxx:108; ROOT::Experimental::RCanvas::IsShownbool IsShown() constreturns true if Show() method was calledDefinition RCanvas.hxx:120; ROOT::Experimental::RCanvas::fPainterstd::unique_ptr< Internal::RVirtualCanvasPainter > fPainterThe painter of this canvas, bootstrapping the graphics connection.Definition RCanvas.hxx:67; ROOT::Experimental::RCanvas::fWidthint fWidthWidth of the canvas in pixels.Definition RCanvas.hxx:56; ROOT::Experimental::RCanvas::fUpdatedbool fUpdatedindicate if Update() method was called beforeDefinition RCanvas.hxx:73; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RCanvas::ClearShownvoid ClearShown()clear IsShown() flagDefinition RCanvas.hxx:123; ROOT::Experimental::RCanvas::ClearOnClosevoid ClearOnClose(const std::shared_ptr< void > &handle)Set handle which will be cleared when connection is closed.Definition RCanvas.cxx:239; ROOT::Experimental::RCanvas::SetWidthvoid SetWidth(int width)Set canvas width.Definition RCanvas.hxx:105; ROOT::Experimental::RCanvas::GetCanvasconst RCanvas * GetCanvas() const overrideAccess to the top-most canvas, if any (const version).Definition RCanvas.hxx:92; ROOT::Experimental::RCanvas::RCanvasRCanvas()Create a temporary RCanvas; for long-lived ones please use Create().Definition RCanvas.hxx:88; ROOT::Experimental::RCanvas::Modifiedvoid Modified(std::shared_ptr< RDrawable > drawable)Set newest version to specified drawable.Definition RCanvas.hxx:152; ROOT::Experimental::RCanvas::Modifiedvoid Modified()Definition RCanvas.hxx:149; ROOT::Experimental::RCanvas::GetWidthint GetWidth() constGet canvas width.Definition RCanvas.hxx:111; ROOT::Experimental::RCanvas::AddPanelbool AddPanel(std::shared_ptr< PANEL > &panel)Insert panel into the canvas, canvas should be shown at this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8hxx_source.html:12474,clear,cleared,12474,doc/master/RCanvas_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8hxx_source.html,1,['clear'],['cleared']
Usability,"ion TStyle.h:436; gPad#define gPadDefinition TVirtualPad.h:308; TStyle::SetPaperSizevoid SetPaperSize(EPaperSize size)Set paper size for PostScript output.Definition TStyle.cxx:1704; Then, the generated file (hpx.tex) can be included in a LaTeX document (simple.tex) in the following way: \documentclass{article}; \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; \title{A simple LaTeX example}; \date{July 2013}; \begin{document}; \maketitle; The following image as been generated using the TTeXDump class:; \par; \input{hpx.tex}; \end{document}; TTeXDumpInterface to TeX.Definition TTeXDump.h:20; Rcpp::asTString as(SEXP s)Definition RExports.h:86; TMVA_SOFIE_GNN.endendDefinition TMVA_SOFIE_GNN.py:207; Note the three directives needed at the top of the LaTeX file: \usepackage{tikz}; \usetikzlibrary{patterns}; \usetikzlibrary{plotmarks}; Then including the picture in the document is done with the \input directive.; The command pdflatex simple.tex will generate the corresponding pdf file simple.pdf. ; Definition at line 20 of file TTeXDump.h. Public Member Functions;  TTeXDump ();  Default TeX constructor. ;  ;  TTeXDump (const char *filename, Int_t type=-113);  Initialize the TeX interface. ;  ;  ~TTeXDump () override;  Default TeX destructor. ;  ; void CellArrayBegin (Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2) override;  Begin the Cell Array painting. ;  ; void CellArrayEnd () override;  End the Cell Array painting. ;  ; void CellArrayFill (Int_t r, Int_t g, Int_t b) override;  Paint the Cell Array. ;  ; void Close (Option_t *opt="""") override;  Close a TeX file. ;  ; Int_t CMtoTeX (Double_t u);  ; void DefineMarkers ();  add additional pgfplotmarks ;  ; void DrawBox (Double_t x1, Double_t y1, Double_t x2, Double_t y2) override;  Draw a Box. ;  ; void DrawFrame (Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light) override;  Draw a Frame around a box. ;  ; void DrawPolyLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTeXDump.html:1861,simpl,simple,1861,doc/master/classTTeXDump.html,https://root.cern,https://root.cern/doc/master/classTTeXDump.html,1,['simpl'],['simple']
Usability,"ion about the; function. void CreateGeneralTab(); Create 'General' tab. void CreateMinimizationTab(); Create 'Minimization' tab. void ConnectSlots(); Connect GUI signals to fit panel slots. void DisconnectSlots(); Disconnect GUI signals from fit panel slots. void SetCanvas(TCanvas* c); Connect to another canvas. void Hide(); Hide the fit panel and set it to non-active state. void Show(TVirtualPad* pad, TObject* obj); Show the fit panel (possible only via context menu). void CloseWindow(); Close fit panel window. void Terminate(); Called to delete the fit panel. void UpdateGUI(); Set the fit panel GUI according to the selected object. void SetFitObject(TVirtualPad* pad, TObject* obj, Int_t event); Slot called when the user clicks on an object inside a canvas.; Updates pointers to the parent pad and the selected object; for fitting (if suitable). void DoNoSelection(); Slot called when users close a TCanvas or when the user select; no object. void RecursiveRemove(TObject* obj); When obj is deleted, clear fFitObject if fFitObject = obj. void FillFunctionList(Int_t selected = -1); Fills the list of functions depending on the type of fit; selected. void FillMinMethodList(Int_t selected = -1); Fills the list of methods depending on the minimization library; selected. void FillDataSetList(); Create a combo box with all the possible objects to be fitted. TGComboBox* BuildMethodList(TGFrame* parent, Int_t id); Create method list in a combo box. void DoAdvancedOptions(); Slot connected to advanced option button (opens a dialog). void DoEmptyBinsAllWeights1(); Slot connected to 'include emtry bins and forse all weights to 1' setting. void DoUseFuncRange(). void DoAllWeights1(); Slot connected to 'set all weights to 1' setting. void DoClose(); Close the fit panel. void DoUpdate(); Easy here!. void DoFit(); Perform a fit with current parameters' settings. Int_t CheckFunctionString(const char* str); Check entered function string. void DoAddition(Bool_t on); Slot connected to additi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFitEditor.html:32744,clear,clear,32744,root/html528/TFitEditor.html,https://root.cern,https://root.cern/root/html528/TFitEditor.html,6,['clear'],['clear']
Usability,"ion depends on the entry number. For details about entry numbers in multi-threaded runs, see here. . Filter() Filter rows based on user-defined conditions. . FilterAvailable() Specialized Filter. If the value of the input column is available, keep the entry, otherwise discard it. . FilterMissing() Specialized Filter. If the value of the input column is missing, keep the entry, otherwise discard it. . Range() Filter rows based on entry number (single-thread only). . Redefine() Overwrite the value and/or type of an existing column. See Define() for more information. . RedefineSlot() Overwrite the value and/or type of an existing column. See DefineSlot() for more information. . RedefineSlotEntry() Overwrite the value and/or type of an existing column. See DefineSlotEntry() for more information. . Vary() Register systematic variations for an existing column. Varied results are then extracted via VariationsFor(). . Actions; Actions aggregate data into a result. Each one is described in more detail in the reference guide.; In the following, whenever we say an action ""returns"" something, we always mean it returns a smart pointer to it. Actions only act on events that pass all preceding filters.; Lazy actions only trigger the event loop when one of the results is accessed for the first time, making it easy to produce many different results in one event loop. Instant actions trigger the event loop instantly. Lazy action Description . Aggregate() Execute a user-defined accumulation operation on the processed column values. . Book() Book execution of a custom action using a user-defined helper object. . Cache() Cache column values in memory. Custom columns can be cached as well, filtered entries are not cached. Users can specify which columns to save (default is all). . Count() Return the number of events processed. Useful e.g. to get a quick count of the number of events passing a Filter. . Display() Provides a printable representation of the dataset contents. The method retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:4960,guid,guide,4960,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['guid'],['guide']
Usability,"ion nodes. void Streamer(TBuffer& b); Stream an object of class TGeoVolume. void SetOption(const char* option); Set the current options (none implemented). void SetLineColor(Color_t lcolor); Set the line color. void SetLineStyle(Style_t lstyle); Set the line style. void SetLineWidth(Width_t lwidth); Set the line width. TGeoNode * GetNode(const char* name) const; get the pointer to a daughter node. Int_t GetByteCount() const; get the total size in bytes for this volume. void FindOverlaps() const; loop all nodes marked as overlaps and find overlaping brothers. void RemoveNode(TGeoNode* node); Remove an existing daughter. TGeoNode * ReplaceNode(TGeoNode* nodeorig, TGeoShape* newshape = 0, TGeoMatrix* newpos = 0, TGeoMedium* newmed = 0); Replace an existing daughter with a new volume having the same name but; possibly a new shape, position or medium. Not allowed for positioned assemblies.; For division cells, the new shape/matrix are ignored. void SelectVolume(Bool_t clear = kFALSE); Select this volume as matching an arbitrary criteria. The volume is added to; a static list and the flag TGeoVolume::kVolumeSelected is set. All flags need; to be reset at the end by calling the method with CLEAR=true. This will also clear; the list. void SetVisibility(Bool_t vis = kTRUE); set visibility of this volume. void SetVisContainers(Bool_t flag = kTRUE); Set visibility for containers. void SetVisLeaves(Bool_t flag = kTRUE); Set visibility for leaves. void SetVisOnly(Bool_t flag = kTRUE); Set visibility for leaves. Bool_t Valid() const; Check if the shape of this volume is valid. Bool_t FindMatrixOfDaughterVolume(TGeoVolume* vol) const; Find a daughter node having VOL as volume and fill TGeoManager::fHMatrix; with its global matrix. void VisibleDaughters(Bool_t vis = kTRUE); set visibility for daughters. void Voxelize(Option_t* option); build the voxels for this volume. Double_t Weight(Double_t precision = 0.01, Option_t* option = ""va""); Estimate the weight of a volume (in kg) with ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoVolume.html:30655,clear,clear,30655,root/html528/TGeoVolume.html,https://root.cern,https://root.cern/root/html528/TGeoVolume.html,3,['clear'],['clear']
Usability,"ion transforms the source spectrum.Definition TSpectrumTransform.cxx:1269. Definition at line 1269 of file TSpectrumTransform.cxx. ◆ Fourier(). void TSpectrumTransform::Fourier ; (; Double_t * ; working_space, . Int_t ; num, . Int_t ; hartley, . Int_t ; direction, . Int_t ; zt_clear . ). protected . This function calculates Fourier based transform of a part of data Function parameters: . working_space-pointer to vector of transformed data; num-length of processed data; hartley-1 if it is Hartley transform, 0 otherwise; direction-forward or inverse transform . Definition at line 265 of file TSpectrumTransform.cxx. ◆ GeneralExe(). int TSpectrumTransform::GeneralExe ; (; Double_t * ; working_space, . Int_t ; zt_clear, . Int_t ; num, . Int_t ; degree, . Int_t ; type . ). protected . This function calculates generalized (mixed) transforms of different degrees Function parameters: . working_space-pointer to vector of transformed data; zt_clear-flag to clear imaginary data before staring; num-length of processed data; degree-degree of transform (see manual); type-type of mixed transform (see manual) . Definition at line 431 of file TSpectrumTransform.cxx. ◆ GeneralInv(). int TSpectrumTransform::GeneralInv ; (; Double_t * ; working_space, . Int_t ; num, . Int_t ; degree, . Int_t ; type . ). protected . This function calculates inverse generalized (mixed) transforms Function parameters: . working_space-pointer to vector of transformed data; num-length of processed data; degree-degree of transform (see manual); type-type of mixed transform (see manual) . Definition at line 547 of file TSpectrumTransform.cxx. ◆ Haar(). void TSpectrumTransform::Haar ; (; Double_t * ; working_space, . Int_t ; num, . Int_t ; direction . ). protected . This function calculates Haar transform of a part of data Function parameters: . working_space-pointer to vector of transformed data; num-length of processed data; direction-forward or inverse transform . Definition at line 96 of file TSpectrumTrans",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumTransform.html:26037,clear,clear,26037,doc/master/classTSpectrumTransform.html,https://root.cern,https://root.cern/doc/master/classTSpectrumTransform.html,1,['clear'],['clear']
Usability,"ion with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TSelector. ◆ Process(). Bool_t TSelEvent::Process ; (; Long64_t ; entry). virtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either TTree::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms. ; Reimplemented from TSelector.; Definition at line 201 of file TSelEvent.cxx. ◆ SetInputList(). virtual void TSelEvent::SetInputList ; (; TList * ; input). inlinevirtual . Reimplemented from TSelector.; Definition at line 113 of file TSelEvent.h. ◆ SetObject(). virtual void TSelEvent::SetObject ; (; TObject * ; obj). inlinevirtual . Reimplemented from TSelector.; Definition at line 112 of file TSelEvent.h. ◆ SetOption(). virtual void TSelEvent::SetOption ; (; const char * ; option). inlinevirtual . Reimplemented from TSelector.; Definition at line 111 of file TSelEvent.h. ◆ SlaveBegin(). void TSelEvent::SlaveBegin ; (; TTree * ; tree). virtual . The SlaveBegin() function is called after the Begin() function. ; When running with PROOF SlaveBegin() is called on each slave server. The tree argument is deprecated (on PROOF 0 is passed). ; Reimplemented from TSelector.; Definition at line 129 of file TSelEvent.cxx. ◆ SlaveTerm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSelEvent.html:18043,simpl,simple,18043,doc/master/classTSelEvent.html,https://root.cern,https://root.cern/doc/master/classTSelEvent.html,1,['simpl'],['simple']
Usability,"ion “N”- do not store the function and do not draw it.; 5.6.4 Advances Options; The advance option button is enabled only after having performed the fit and provides additional drawing options that can be used after having done the fit. These new drawing tools, which can be selected by the “Advanced Drawing Tool” panel that pops up when clicking the “Advanced” button, are:. Contour: to plot the confidence contour of two chosen parameters. One can select the number of points to draw the contour (more points might require more time to compute it), the parameters and the desired confidence level .; Scan : to plot a scan of the minimization function (likelihood or chi-squared) around the minimum as function of the chosen parameter.; Conf Interval : to plot the confidence interval of the fitted function as a filled coloured band around its central value. One can select the desired confidence level for the band to be plotted. 5.6.5 Print Options; This set of options specifies the amount of feedback printed on the root command line after performed fits.; ‘Verbose’ - prints fit results after each iteration.; ‘Quiet’ - no fit information is printed.; ‘Default’ - between Verbose and Quiet.; 5.6.6 Command Buttons; Fit button - performs a fit taking different option settings via the Fit Panel interface.; Reset - sets the GUI elements and related fit settings to the default ones.; Close - closes the Fit panel window.; 5.6.7 Minimization Options; With this tab one can select specific options for minimization. These include. The minimizer library ( Minuit, Minuit2, Fumili, GSL, Genetics ); The method (algorithm) for minimization. For example for Minuit one can choose between (Migrad, Simplex or Scan); Error definition; Minimization tolerance; Number of iterations/function calls; Print Level: (Default, Verbose or Quiet). 5.7 New ROOT::Fit classes; The fitting of the data objects in ROOT, histograms, graphs and tree is performed via some common classes, which are defined in the ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:187380,feedback,feedback,187380,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['feedback'],['feedback']
Usability,"ion'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooFormulaVar * identity ();  Return identity formula pointer. ;  ;  Static Public Member Functions inherited from RooAbsPdf; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static RooNumGenConfig * defaultGeneratorConfig ();  Returns the default numeric MC generator configuration for all RooAbsReals. ;  ; static int verboseEval ();  Return global level of verbosity for p.d.f. evaluations. ;  ; static void verboseEval (Int_t stat);  Change global level of verbosity for p.d.f. evaluations. ;  ;  Static Public Member Functions inherited from RooAbsReal; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static void clearEvalErrorLog ();  Clear the stack of evaluation error messages. ;  ; static const char * DeclFileName ();  ; static RooNumIntConfig * defaultIntegratorConfig ();  Returns the default numeric integration configuration for all RooAbsReals. ;  ; static std::map< constRooAbsArg *, std::pair< std::string, std::list< RooAbsReal::EvalError > > >::iterator evalErrorIter ();  ; static ErrorLoggingMode evalErrorLoggingMode ();  Return current evaluation error logging mode. ;  ; static bool hideOffset ();  ; static void logEvalError (const RooAbsReal *originator, const char *origName, const char *message, const char *serverValueString=nullptr);  Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream. ;  ; static Int_t numEvalErrorItems ();  ; static Int_t numEvalErrors ();  Return the number of logged evaluation errors since the last clearing. ;  ; static void printEvalErrors (s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooResolutionModel.html:59175,clear,clearEvalErrorLog,59175,doc/master/classRooResolutionModel.html,https://root.cern,https://root.cern/doc/master/classRooResolutionModel.html,1,['clear'],['clearEvalErrorLog']
Usability,"ion. ;  . Protected Member Functions; void UpdateBiases (size_t layerIndex, std::vector< Matrix_t > &biases, const std::vector< Matrix_t > &biasGradients);  Update the biases, given the current bias gradients. ;  ; void UpdateWeights (size_t layerIndex, std::vector< Matrix_t > &weights, const std::vector< Matrix_t > &weightGradients);  Update the weights, given the current weight gradients. ;  . Protected Attributes; Scalar_t fMomentum;  The momentum used for training. ;  ; std::vector< std::vector< Matrix_t > > fPastBiasGradients;  The sum of the past bias gradients associated with the deep net. ;  ; std::vector< std::vector< Matrix_t > > fPastWeightGradients;  The sum of the past weight gradients associated with the deep net. ;  ;  Protected Attributes inherited from TMVA::DNN::VOptimizer< Architecture_t, Layer_t, DeepNet_t >; DeepNet_t & fDeepNet;  The reference to the deep net. ;  ; size_t fGlobalStep;  The current global step count during training. ;  ; Scalar_t fLearningRate;  The learning rate used for training. ;  . #include <TMVA/DNN/SGD.h>. Inheritance diagram for TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ Matrix_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >::Matrix_t = typename Architecture_t::Matrix_t. Definition at line 48 of file SGD.h. ◆ Scalar_t. template<typename Architecture_t , typename Layer_t = VGeneralLayer<Architecture_t>, typename DeepNet_t = TDeepNet<Architecture_t, Layer_t>> . using TMVA::DNN::TSGD< Architecture_t, Layer_t, DeepNet_t >::Scalar_t = typename Architecture_t::Scalar_t. Definition at line 49 of file SGD.h. Constructor & Destructor Documentation. ◆ TSGD(). template<typename Architecture_t , typename Layer_t , typename DeepNet_t > . TMV",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html:3172,learn,learning,3172,doc/master/classTMVA_1_1DNN_1_1TSGD.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TSGD.html,1,['learn'],['learning']
Usability,"ion. ◆ TKDTree() [1/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree. Default constructor. Nothing is built. ; Definition at line 270 of file TKDTree.cxx. ◆ TKDTree() [2/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree ; (; Index ; npoints, . Index ; ndim, . UInt_t ; bsize . ). Definition at line 292 of file TKDTree.cxx. ◆ TKDTree() [3/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree ; (; Index ; npoints, . Index ; ndim, . UInt_t ; bsize, . Value ** ; data . ). Create a kd-tree from the provided data array. ; This function only sets the data, call Build() to build the tree!!! Parameters:; npoints - total number of points. Adding points after the tree is built is not supported; ndim - number of dimensions; bsize - maximal number of points in the terminal nodes; data - the data array. The data should be placed columnwise (like in a TTree). The columnwise orientation is chosen to simplify the usage together with TTree::GetV1() like functions. An example of filling such an array for a 2d case: Double_t **data = new Double_t*[2]; data[0] = new Double_t[npoints]; data[1] = new Double_t[npoints]; for (Int_t i=0; i<npoints; i++){ data[0][i]=gRandom->Uniform(-1, 1); //fill the x-coordinate data[1][i]=gRandom->Uniform(-1, 1); //fill the y-coordinate }; By default, the kd-tree doesn't own the data. If you want the kd-tree to delete the data array, call kdtree->SetOwner(kTRUE). ; Definition at line 344 of file TKDTree.cxx. ◆ ~TKDTree(). template<typename Index , typename Value > . TKDTree< Index, Value >::~TKDTree. override . Destructor By default, the original data is not owned by kd-tree and is not deleted with it. ; If you want to delete the data along with the kd-tree, call SetOwner(kTRUE). ; Definition at line 373 of file TKDTree.cxx. ◆ TKDTree() [4/4]. template<typename Index , typename Value > . TKDTree< Index, Value >::TKDTree ; (; const TKDTree< Index, Value > & ; ). priv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTKDTree.html:29402,simpl,simplify,29402,doc/master/classTKDTree.html,https://root.cern,https://root.cern/doc/master/classTKDTree.html,1,['simpl'],['simplify']
Usability,"ionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TMVAGAexample.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAGAexample2.C This exectutable gives an example of a very simple use of the genetic algorithm of TMVA ;  TMVAMulticlass.C This macro provides a simple example for the training and testing of the TMVA multiclass classification ;  TMVAMulticlassApplication.C This macro provides a simple example on how to use the trained multiclass classifiers within an analysis module ;  TMVAMultipleBackgroundExample.C This example shows the training of signal with three different backgrounds Then in the application a tree is created with all signal and background events where the true class ID and the three classifier outputs are added finally with the application tree, the significance is maximized with the help of the TMVA genetic algrorithm ;  TMVARegression.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVARegressionApplication.C This macro provides a simple example on how to use the trained regression MVAs within an analysis module ;  ► tree;  basic.C Read data from an ascii file and create a root file with an histogram an",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:153734,simpl,simple,153734,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,3,['simpl'],['simple']
Usability,ionRL_wide.C Example to illustrate deconvolution function (class TSpectrum) ;  DeconvolutionRL_wide_boost.C Example to illustrate deconvolution function (class TSpectrum) ;  peaks.C Getting Contours From TH2D ;  peaks2.C Example to illustrate the 2-d peak finder (class TSpectrum2) ;  Smoothing.C Example to illustrate smoothing using Markov algorithm (class TSpectrum) ;  spectrumpainter.C Examples showing how to use TSpectrum2Painter (the SPEC option) ;  ► splot;  TestSPlot.CThis tutorial illustrates the use of class TSPlot and of the sPlots method ;  ► sql;  sqlcanvas.CThis is slight modification of ntuple1.C example ;  sqlcreatedb.CCreate a runcatalog table in a MySQL test database ;  sqlfilldb.CFill run catalog with nfiles entries ;  sqlselect.C;  sqltables.CThis is an example illustrating how the TSQLFile class can be used ;  ► thread;  stressThreadPool.CUsage: ;  threadPool.CUsage: ;  threads.CExample of a simple script creating 3 threads ;  threadsh1.CExample of a simple script creating 3 threads ;  threadsh2.CExample of a simple script creating 2 threads each with one canvas ;  ► tmva;  ► keras;  ApplicationClassificationKeras.py;  ApplicationRegressionKeras.py;  ClassificationKeras.py;  GenerateModel.py;  LaunchClasGUI.C;  LaunchMultiGUI.C;  LaunchRegGUI.C;  MulticlassKeras.py;  RegressionKeras.py;  createData.CPlot the variables ;  TMVAClassification.C This macro provides examples for the training and testing of the TMVA classifiers ;  TMVAClassificationApplication.C This macro provides a simple example on how to use the trained classifiers within an analysis module ;  TMVAClassificationCategory.C This macro provides examples for the training and testing of the TMVA classifiers in categorisation mode ;  TMVAClassificationCategoryApplication.C This macro provides a simple example on how to use the trained classifiers (with categories) within an analysis module ;  TMVACrossValidation.C This example explains how to use the cross-validation feature of TMVA ;  TM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:152552,simpl,simple,152552,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,1,['simpl'],['simple']
Usability,"ion_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented: meaningful only in the remote player. Returns kFALSE. ;  ; void Progres",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLocal.html:3464,learn,learning,3464,doc/master/classTProofPlayerLocal.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLocal.html,1,['learn'],['learning']
Usability,"ion_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleGetTreeHeader (TMessage *mess) override;  Handle tree header request. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; TClass * IsA () const override;  ; Bool_t IsClient () const override;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayer.html:4082,learn,learning,4082,doc/master/classTProofPlayer.html,https://root.cern,https://root.cern/doc/master/classTProofPlayer.html,1,['learn'],['learning']
Usability,"ion_t *option="""", Long64_t nentries=-1, Long64_t firstentry=0) override;  Draw (may not be used in this class). ;  ; void Feedback (TList *objs) override;  Set feedback list (may not be used in this class). ;  ; void FeedBackCanvas (const char *name, Bool_t create);  Create/destroy a named canvas for feedback. ;  ; Long64_t Finalize (Bool_t force=kFALSE, Bool_t sync=kFALSE) override;  Finalize query (may not be used in this class). ;  ; Long64_t Finalize (TQueryResult *qr) override;  Finalize query (may not be used in this class). ;  ; Long64_t GetCacheSize () override;  Return the size in bytes of the cache. ;  ; TQueryResult * GetCurrentQuery () const override;  ; Int_t GetDrawArgs (const char *var, const char *sel, Option_t *opt, TString &selector, TString &objname) override;  Parse the arguments from var, sel and opt and fill the selector and object name accordingly. ;  ; Long64_t GetEventsProcessed () const override;  ; EExitStatus GetExitStatus () const override;  ; TList * GetInputList () const override;  ; Int_t GetLearnEntries () override;  Return the number of entries in the learning phase. ;  ; TList * GetListOfResults () const override;  ; TDSetElement * GetNextPacket (TSlave *slave, TMessage *r) override;  Get next packet (may not be used in this class). ;  ; TObject * GetOutput (const char *name) const override;  Get output object by name. ;  ; TList * GetOutputList () const override;  Get output list. ;  ; TVirtualPacketizer * GetPacketizer () const override;  ; TProofProgressStatus * GetProgressStatus () const override;  ; TQueryResult * GetQueryResult (const char *ref) override;  Get query result instances referenced 'ref' from the list of results. ;  ; void HandleRecvHisto (TMessage *mess) override;  Receive histo from slave. ;  ; Bool_t IsClient () const override;  ; Bool_t JoinProcess (TList *workers) override;  Not implemented: meaningful only in the remote player. Returns kFALSE. ;  ; Long64_t Process (TDSet *set, const char *selector, Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerSlave.html:2754,learn,learning,2754,doc/master/classTProofPlayerSlave.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerSlave.html,1,['learn'],['learning']
Usability,"ion_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TPaveText.h; TVirtualPaveStats.h; TBoxCreate a Box.Definition TBox.h:22; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObjectMother of all ROOT objects.Definition TObject.h:41; TPaveStatsThe histogram statistics painter class.Definition TPaveStats.h:18; TPaveStats::TPaveStatsTPaveStats()TPaveStats default constructor.Definition TPaveStats.cxx:231; TPaveStats::GetOptStatInt_t GetOptStat() constReturn the stat option.Definition TPaveStats.cxx:271; TPaveStats::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TPaveStats.cxx:504; TPaveStats::EditTextvoid EditText() overrideEdit text at the mouse position.Definition TPaveStats.h:34; TPaveStats::UseCurrentStylevoid UseCurrentStyle() overrideReplace current attributes by current style.Definition TPaveStats.cxx:570; TPaveStats::InsertTextvoid InsertText(const char *) overrideAdd a new Text line at the mouse position.Definition TPaveStats.h:41; TPaveStats::InsertLinevoid InsertLine() overrideAdd a new line at t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPaveStats_8h_source.html:4239,simpl,simple,4239,doc/master/TPaveStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TPaveStats_8h_source.html,1,['simpl'],['simple']
Usability,"ions . ; FAQ . ; News . ; Blog . ; Workshops . ; Support . ; Forum . ; Bug submission guidelines . ; Submit a Bug . ; RootTalk Digest . ; Discourse Mailing List Mode . ; About . ; Licence . ; Contact Us . ; Project Founders . ; Team . ; Previous Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » About Contact Us. You can contact the ROOT developers in the following ways, in order of preference:. Via the RootTalk web forum. Use this forum to post your questions. ROOT team members are actively reading this forum and answering the questions. And if the developers don't happen to be online your question might be answered by a fellow user. Remember, before posting a question, do a search to see if the issue has already been discussed.; Via the roottalk mailing list. Check the digest to see if your question has already been discussed.; Direct mail to the ROOT Developers. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/contact-us.html:2664,guid,guidelines,2664,d/contact-us.html,https://root.cern,https://root.cern/d/contact-us.html,1,['guid'],['guidelines']
Usability,"ions not valid for graphs; 993 HFit::CheckGraphFitOptions(foption);; 994 // TMultiGraph fitting; 995 return HFit::Fit(gr,f1,foption,moption,goption,range);; 996}; 997 ; 998TFitResultPtr ROOT::Fit::FitObject(TGraph2D * gr, TF1 *f1 , Foption_t & foption , const ROOT::Math::MinimizerOptions & moption, const char *goption, ROOT::Fit::DataRange & range) {; 999 // exclude options not valid for graphs; 1000 HFit::CheckGraphFitOptions(foption);; 1001 // TGraph2D fitting; 1002 return HFit::Fit(gr,f1,foption,moption,goption,range);; 1003}; 1004 ; 1005TFitResultPtr ROOT::Fit::FitObject(THnBase * s1, TF1 *f1 , Foption_t & foption , const ROOT::Math::MinimizerOptions & moption, const char *goption, ROOT::Fit::DataRange & range) {; 1006 // sparse histogram fitting; 1007 return HFit::Fit(s1,f1,foption,moption,goption,range);; 1008}; 1009 ; 1010 ; 1011 ; 1012// Int_t TGraph2D::DoFit(TF2 *f2 ,Option_t *option ,Option_t *goption) {; 1013// // internal graph2D fitting methods; 1014// Foption_t fitOption;; 1015// ROOT::Fit::FitOptionsMake(option,fitOption);; 1016 ; 1017// // create range and minimizer options with default values; 1018// ROOT::Fit::DataRange range(2);; 1019// ROOT::Math::MinimizerOptions minOption;; 1020// return ROOT::Fit::FitObject(this, f2 , fitOption , minOption, goption, range);; 1021// }; 1022 ; 1023 ; 1024// function to compute the simple chi2 for graphs and histograms; 1025 ; 1026 ; 1027double ROOT::Fit::Chisquare(const TH1 & h1, TF1 & f1, bool useRange, ROOT::Fit::EChisquareType type) {; 1028 return HFit::ComputeChi2(h1,f1,useRange, type);; 1029}; 1030 ; 1031double ROOT::Fit::Chisquare(const TGraph & g, TF1 & f1, bool useRange) {; 1032 return HFit::ComputeChi2(g,f1, useRange, ROOT::Fit::EChisquareType::kNeyman);; 1033}; 1034 ; 1035template<class FitObject>; 1036double HFit::ComputeChi2(const FitObject & obj, TF1 & f1, bool useRange, ROOT::Fit::EChisquareType type ) {; 1037 ; 1038 // implement using the fitting classes; 1039 ROOT::Fit::DataOptions opt;; 1040 opt.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:38802,simpl,simple,38802,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['simpl'],['simple']
Usability,"ions; 14914 *; 14915 * If we just look for 's' anywhere in the string, ""localhost:80""; 14916 * will be detected as SSL (false positive).; 14917 * Looking for 's' after a digit may cause false positives in; 14918 * ""my24service:8080"".; 14919 * Looking from 's' backward if there are only ':' and numbers; 14920 * before will not work for ""24service:8080"" (non SSL, port 8080); 14921 * or ""24s"" (SSL, port 24).; 14922 *; 14923 * Remark: Initially hostnames were not allowed to start with a; 14924 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14925 * Section 2.1).; 14926 *; 14927 * To get this correct, the entire string must be parsed as a whole,; 14928 * reading it as a list element for element and parsing with an; 14929 * algorithm equivalent to parse_port_string.; 14930 *; 14931 * In fact, we use local interface names here, not arbitrary; 14932 * hostnames, so in most cases the only name will be ""localhost"".; 14933 *; 14934 * So, for now, we use this simple algorithm, that may still return; 14935 * a false positive in bizarre cases.; 14936 */; 14937 int i;; 14938 int portslen = (int)strlen(ports);; 14939 char prevIsNumber = 0;; 14940 ; 14941 for (i = 0; i < portslen; i++) {; 14942 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14943 return 1;; 14944 }; 14945 if (ports[i] >= '0' && ports[i] <= '9') {; 14946 prevIsNumber = 1;; 14947 } else {; 14948 prevIsNumber = 0;; 14949 }; 14950 }; 14951 }; 14952 return 0;; 14953}; 14954 ; 14955 ; 14956static int; 14957set_ports_option(struct mg_context *phys_ctx); 14958{; 14959 const char *list;; 14960 int on = 1;; 14961#if defined(USE_IPV6); 14962 int off = 0;; 14963#endif; 14964 struct vec vec;; 14965 struct socket so, *ptr;; 14966 ; 14967 struct mg_pollfd *pfd;; 14968 union usa usa;; 14969 socklen_t len;; 14970 int ip_version;; 14971 ; 14972 int portsTotal = 0;; 14973 int portsOk = 0;; 14974 ; 14975 const char *opt_txt;; 14976 long opt_listen_backlog;; 14977 ; 14978 if (!phys_ctx) {; 14979 return 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:442335,simpl,simple,442335,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['simpl'],['simple']
Usability,"ions; 14915 *; 14916 * If we just look for 's' anywhere in the string, ""localhost:80""; 14917 * will be detected as SSL (false positive).; 14918 * Looking for 's' after a digit may cause false positives in; 14919 * ""my24service:8080"".; 14920 * Looking from 's' backward if there are only ':' and numbers; 14921 * before will not work for ""24service:8080"" (non SSL, port 8080); 14922 * or ""24s"" (SSL, port 24).; 14923 *; 14924 * Remark: Initially hostnames were not allowed to start with a; 14925 * digit (according to RFC 952), this was allowed later (RFC 1123,; 14926 * Section 2.1).; 14927 *; 14928 * To get this correct, the entire string must be parsed as a whole,; 14929 * reading it as a list element for element and parsing with an; 14930 * algorithm equivalent to parse_port_string.; 14931 *; 14932 * In fact, we use local interface names here, not arbitrary; 14933 * hostnames, so in most cases the only name will be ""localhost"".; 14934 *; 14935 * So, for now, we use this simple algorithm, that may still return; 14936 * a false positive in bizarre cases.; 14937 */; 14938 int i;; 14939 int portslen = (int)strlen(ports);; 14940 char prevIsNumber = 0;; 14941 ; 14942 for (i = 0; i < portslen; i++) {; 14943 if (prevIsNumber && (ports[i] == 's' || ports[i] == 'r')) {; 14944 return 1;; 14945 }; 14946 if (ports[i] >= '0' && ports[i] <= '9') {; 14947 prevIsNumber = 1;; 14948 } else {; 14949 prevIsNumber = 0;; 14950 }; 14951 }; 14952 }; 14953 return 0;; 14954}; 14955 ; 14956 ; 14957static int; 14958set_ports_option(struct mg_context *phys_ctx); 14959{; 14960 const char *list;; 14961 int on = 1;; 14962#if defined(USE_IPV6); 14963 int off = 0;; 14964#endif; 14965 struct vec vec;; 14966 struct socket so, *ptr;; 14967 ; 14968 struct mg_pollfd *pfd;; 14969 union usa usa;; 14970 socklen_t len;; 14971 int ip_version;; 14972 ; 14973 int portsTotal = 0;; 14974 int portsOk = 0;; 14975 ; 14976 const char *opt_txt;; 14977 long opt_listen_backlog;; 14978 ; 14979 if (!phys_ctx) {; 14980 return 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:442368,simpl,simple,442368,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['simpl'],['simple']
Usability,"ions;  LayerData (const LayerData &other);  copy c'tor of LayerData ;  ;  LayerData (const_iterator_type itInputBegin, const_iterator_type itInputEnd, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (LayerData &&other);  move c'tor of LayerData ;  ;  LayerData (size_t inputSize);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, iterator_type itGradientBegin, std::shared_ptr< std::function< double(double)> > activationFunction, std::shared_ptr< std::function< double(double)> > inverseActivationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  LayerData (size_t size, const_iterator_type itWeightBegin, std::shared_ptr< std::function< double(double)> > activationFunction, ModeOutputValues eModeOutput=ModeOutputValues::DIRECT);  c'tor of LayerData ;  ;  ~LayerData ();  ; std::shared_ptr< std::function< double(double)> > activationFunction () const;  ; void clear ();  clear the values and the deltas ;  ; void clearDropOut ();  clear the drop-out-data for this layer ;  ; iterator_type deltasBegin ();  returns iterator to the begin of the deltas (back-propagation) ;  ; const_iterator_type deltasBegin () const;  returns const iterator to the begin of the deltas (back-propagation) ;  ; iterator_type deltasEnd ();  returns iterator to the end of the deltas (back-propagation) ;  ; const_iterator_type deltasEnd () const;  returns const iterator to the end of the deltas (back-propagation) ;  ; const_dropout_iterator dropOut () const;  return the begin of the drop-out information ;  ; iterator_type gradientsBegin ();  returns iterator to the begin of the gradients ;  ; const_iterator_type gradientsBegin () const;  returns const iterator to the begin of the gradients ;  ; bool hasDropOut () const;  has this layer drop-out turned on? ;  ; std::shared_ptr< std::function< double(double)> > inverseActivationFunction () const;  ; ModeOutputValues outputMode () const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html:1940,clear,clear,1940,doc/master/classTMVA_1_1DNN_1_1LayerData.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1LayerData.html,1,['clear'],['clear']
Usability,"ionship between the pieces is not defined by neighbors, but by containment. In other words, volumes are put one inside another making an in-depth hierarchy. From outside, the whole thing looks like a big pack that you can open finding out other smaller packs nicely arranged waiting to be opened at their turn. The biggest one containing all others defines the “world” of the model. We will often call this master reference system (MARS). Going on and opening our packs, we will obviously find out some empty ones, otherwise, something is very wrong… We will call these leaves (by analogy with a tree structure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:; 18.1.1 Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does make map in root folder.; root[] gSystem->Load(""libGeom"");; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:876657,simpl,simplest,876657,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['simpl'],['simplest']
Usability,"ionsminimizer options; intROOT::Math::Minimizer::fStatusstatus of minimizer; boolROOT::Math::Minimizer::fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit). private:. unsigned intfDimdimension of the function to be minimized; vector<double>fErrors; ROOT::Minuit2::ModularFunctionMinimizer*fMinimizer; ROOT::Minuit2::FunctionMinimum*fMinimum; ROOT::Minuit2::FCNBase*fMinuitFCN; ROOT::Minuit2::MnUserParameterStatefState; boolfUseFumili; vector<double>fValues. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Minuit2Minimizer(ROOT::Minuit2::EMinimizerType type = ROOT::Minuit2::kMigrad). Default constructor. Minuit2Minimizer(const char* type). Constructor with a char (used by PM). virtual ~Minuit2Minimizer(). Destructor (no operations). Minuit2Minimizer(const ROOT::Minuit2::Minuit2Minimizer& ); usually copying is non trivial, so we make this unaccessible. Copy constructor. void Clear(); clear resources (parameters) for consecutives minimizations. void SetFunction(const ROOT::Math::IMultiGenFunction& func); set the function to minimize. void SetFunction(const ROOT::Math::IMultiGradFunction& func); set gradient the function to minimize. bool SetVariable(unsigned int ivar, const string& name, double val, double step); set free variable. bool SetLowerLimitedVariable(unsigned int ivar, const string& name, double val, double step, double lower); set lower limit variable (override if minimizer supports them ). bool SetUpperLimitedVariable(unsigned int ivar, const string& name, double val, double step, double upper); set upper limit variable (override if minimizer supports them ). bool SetLimitedVariable(unsigned int ivar, const string& name, double val, double step, double , double ); set upper/lower limited variable (override if minimizer supports them ). bool SetFixedVariable(unsigned int , const string& , double ); set fixed variable (override if minimizer supports them ). bool SetVariableValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__Minuit2Minimizer.html:6348,clear,clear,6348,root/html602/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__Minuit2Minimizer.html,2,['clear'],['clear']
Usability,"iour in split or non-split mode. classname does; not have to derive from TObject. The function is based on; the new TStreamerInfo. Build a TBranchElement for an object of class classname. addr is the address of a pointer to an object of class; classname. The class dictionary must be available (ClassDef; in class header). Note: See the comments in TBranchElement::SetAddress() for a more; detailed discussion of the meaning of the addr parameter. This option requires access to the library where the; corresponding class is defined. Accessing one single data; member in the object implies reading the full object. By default the branch buffers are stored in the same file as the Tree.; use TBranch::SetFile to specify a different file. IMPORTANT NOTE about branch names; In case two or more master branches contain subbranches with; identical names, one must add a ""."" (dot) character at the end; of the master branch name. This will force the name of the subbranch; to be master.subbranch instead of simply subbranch.; This situation happens when the top level object (say event); has two or more members referencing the same class.; For example, if a Tree has two branches B1 and B2 corresponding; to objects of the same class MyClass, one can do:; tree.Branch(""B1."",""MyClass"",&b1,8000,1);; tree.Branch(""B2."",""MyClass"",&b2,8000,1);; if MyClass has 3 members a,b,c, the two instructions above will generate; subbranches called B1.a, B1.b ,B1.c, B2.a, B2.b, B2.c. bufsize is the buffer size in bytes for this branch; The default value is 32000 bytes and should be ok for most cases.; You can specify a larger value (e.g. 256000) if your Tree is not split; and each entry is large (Megabytes); A small value for bufsize is optimum if you intend to access; the entries in the Tree randomly and your Tree is in split mode. Use splitlevel < 0 instead of splitlevel=0 when the class; has a custom Streamer. Note: if the split level is set to the default (99), TTree::Branch will; not issue a warning if t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:55846,simpl,simply,55846,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,3,['simpl'],['simply']
Usability,"ious Developers . ; Development . ; Program of Work . ; Code Owners . ; Release Checklist . ; Coding Conventions . ; Shifter's Instructions . ; Git Primer . ; Creating a Pull Request . ; Github ssh key . ; Git Tips and Tricks . ; Git How Tos . ; A suggested work flow for distributed projects: NoSY . ; Browse Sources . ; Meetings . ; ROOT 7 . ; Run the tests . ; Setup externals from AFS/CVMFS . ; Jenkins . ; Doxygen . ; Benchmarks . ; Contribute . ; Collaborate with Us . You are hereHome » First Steps With ROOT Processing data with ROOT. The ROOT framework consists of many classes, grouped into several categories. Finally, the latter are grouped into few top-level categories. Each top-level category comes with a basic description of the framework design and of the purpose of its categories, which also have more detailed documentation about their use. The most complete documentation is the Reference Guide, that contains the automatically generated documentation of each class.; This document is about the top-level categories related to data processing. . ‹ First Steps With ROOT; up; CINT and RootCint ›. Navigate through this book; Processing data with ROOTCINT and RootCint; About PROOF; Bindings; Analyzing data with ROOT; Math; RooFit; TMVA. Showing results with ROOT; Simulation in ROOT; ROOT I/O. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate with Us. © Copyright CERN 2014-18. All rights reserved. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/processing-data-root.html:2920,guid,guidelines,2920,d/processing-data-root.html,https://root.cern,https://root.cern/d/processing-data-root.html,1,['guid'],['guidelines']
Usability,"ipped;; however, this may cause problems if You try to unfold something; which depends on these input bins. code fragment (with histograms A and y filled):. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);; Double_t tau=1.E-4;; Double_t biasScale=0.0;; unfold.DoUnfold(tau,y,biasScale);; TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. will create histograms ""x"" and ""correlation"" from A and y.; if tau is very large, the output is biased to the generated distribution scaled by biasScale; if tau is very small, the output will show oscillations; and large entries in the correlation matrix. Proper choice of tau. One of the difficult questions is about the choice of tau. The most; common method is the L-curve method: a two-dimensional curve is plotted; x-axis: log10(chisquare); y-axis: log10(regularisation condition); In many cases this curve has an L-shape. The best choice of tau is in the; kink of the L. Within TUnfold a simple version of the L-curve analysis is included.; It tests a given number of points in a predefined tau-range and searches; for the maximum of the curvature in the L-curve (kink position).; if no tau range is given, the range of teh scan is determied automatically. Example: scan tau and produce the L-curve plot. Code fragment: assume A and y are filled. TUnfold unfold(A,TUnfold::kHistMapOutputHoriz);. unfold.SetInput(y);. Int_t nScan=30;; Int_t iBest;; TSpline *logTauX,*logTauY;; TGraph *lCurve;. iBest=unfold.ScanLcurve(nScan,0.0,0.0,&lCurve);. std::cout<<""tau=""<<unfold.GetTau()<<""\n"";. TH1D *x=unfold.GetOutput(""x"",""myVariable"");; TH2D *rhoij=unfold.GetRhoIJ(""correlation"",""myVariable"");. This creates; logTauX: the L-curve's x-coordinate as a function of log(tau); logTauY: the L-curve's y-coordinate as a function of log(tau); lCurve: a graph of the L-curve; x,rhoij: unfolding result for best choice of tau; iBest: the coordinate/spline knot number with the best choice of tau. Note: always check the L ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:5282,simpl,simple,5282,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,3,['simpl'],['simple']
Usability,"ipt showing how to divide a canvas into adjacent subpads + axis labels on the top and right side of the pads ;  ► gui;  buttonChangelabel.CThis macro gives an example for changing text button labels anytime the Start or Pause buttons are clicked ;  buttongroupState.CA simple example that shows the enabled and disabled state of a button group with radio and check buttons ;  buttonsLayout.CThis macro gives an example of different buttons' layout ;  buttonTest.CThis macro gives an example of how to set/change text button attributes ;  calendar.CThis macro gives an example of how to use html widget to display tabular data ;  CPUMeter.CSimple macro showing capabilities of the TGSpeedo widget ;  customContextMenu.CExample showing how to add a function to the class context menu ;  customTH1Fmenu.CExample showing how to customize a context menu for a class ;  drag_and_drop.CThis tutorial illustrates how to use drag and drop within ROOT ;  exec3.CExample of using signal/slot in TCanvas/TPad to get feedback about processed events ;  exec_macro.CThis utility macro executes the macro ""macro"" given as first argument and save a capture in a png file ;  games.CThis macro runs three ""games"" that each nicely illustrate the graphics capabilities of ROOT ;  gtreeTableTest.CThis TableTest class is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simpl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:118418,feedback,feedback,118418,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['feedback'],['feedback']
Usability,"iption; function members; data members; class charts. ROOT; » ROOFIT; » ROOFITCORE; » RooSimWSTool. class RooSimWSTool: public TNamed, public RooPrintable. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to bu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool.html:1090,simpl,simple,1090,root/html526/RooSimWSTool.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool.html,4,['simpl'],['simple']
Usability,"ironment. ;  ; TClass * IsA () const override;  ; virtual void SetActive ();  ; virtual void SetActive (Bool_t active);  Suspend or resume PROOF via Condor. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TProof;  TProof (const char *masterurl, const char *conffile=kPROOF_ConfFile, const char *confdir=kPROOF_ConfDir, Int_t loglevel=0, const char *alias=0, TProofMgr *mgr=0);  Create a PROOF environment. ;  ;  ~TProof () override;  Clean up PROOF environment. ;  ; Int_t ActivateWorker (const char *ord, Bool_t save=kTRUE);  Make sure that the worker identified by the ordinal number 'ord' is in the active list. ;  ; void AddChain (TChain *chain);  Add chain to data set. ;  ; Int_t AddDynamicPath (const char *libpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'libpath' to the lib path search. ;  ; void AddFeedback (const char *name);  Add object to feedback list. ;  ; Int_t AddIncludePath (const char *incpath, Bool_t onClient=kFALSE, TList *wrks=0, Bool_t doCollect=kTRUE);  Add 'incpath' to the inc path search. ;  ; void AddInput (TObject *obj);  Add objects that might be needed during the processing of the selector (see Process()). ;  ; void AddInputData (TObject *obj, Bool_t push=kFALSE);  Add data objects that might be needed during the processing of the selector (see Process()). ;  ; Int_t Archive (const char *queryref, const char *url=0);  Send archive request for the query specified by ref. ;  ; Int_t Archive (Int_t query, const char *url);  Send archive request for the qry-th query in fQueries. ;  ; void Browse (TBrowser *b) override;  Build the PROOF's structure in the browser. ;  ; virtual Bool_t CancelStagingDataSet (const char *dataset);  Cancels a dataset staging request. ;  ; void cd (Int_t id=-1);  Set session with 'id' the default one. ;  ; Int_t CleanupSession (const char *sessiontag);  Send ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofCondor.html:1669,feedback,feedback,1669,doc/master/classTProofCondor.html,https://root.cern,https://root.cern/doc/master/classTProofCondor.html,1,['feedback'],['feedback']
Usability,"ironment.Definition TApplication.cxx:244; TApplication::Openvirtual void Open()Definition TApplication.h:132; TApplication::LoadGraphicsLibsvirtual void LoadGraphicsLibs()Load shared libs necessary for graphics.Definition TApplication.cxx:1333; TApplication::StopIdleingvirtual void StopIdleing()Called when system stops idleing.Definition TApplication.cxx:1907; TApplication::kProcessRemotely@ kProcessRemotelyDefinition TApplication.h:44; TApplication::kDefaultApplication@ kDefaultApplicationDefinition TApplication.h:45; TApplication::StartIdleingvirtual void StartIdleing()Called when system starts idleing.Definition TApplication.cxx:1896; TApplication::Runvirtual void Run(Bool_t retrn=kFALSE)Main application eventloop. Calls system dependent eventloop via gSystem.Definition TApplication.cxx:1860; TApplication::~TApplicationvirtual ~TApplication()TApplication dtor.Definition TApplication.cxx:210; TApplication::OpenReferenceGuideForvoid OpenReferenceGuideFor(const TString &strippedClass)It opens the online reference guide, generated with Doxygen, for the chosen scope (class/namespace/st...Definition TApplication.cxx:1065; TApplication::HandleExceptionvirtual void HandleException(Int_t sig)Handle exceptions (kSigBus, kSigSegmentationViolation, kSigIllegalInstruction and kSigFloatingExcepti...Definition TApplication.cxx:590; TApplication::MakeBatchvirtual void MakeBatch()Switch to batch mode.Definition TApplication.cxx:1395; TApplication::OpenGitHubIssuevoid OpenGitHubIssue(const TString &type)It opens a GitHub issue in a web browser with prefilled ROOT version.Definition TApplication.cxx:1034; TApplication::fReturnFromRunBool_t fReturnFromRunDefinition TApplication.h:62; TApplication::Initvirtual void Init()Definition TApplication.h:117; TApplication::fIdleCommandTString fIdleCommandDefinition TApplication.h:68; TApplication::Argvchar ** Argv() constDefinition TApplication.h:141; TApplication::fgGraphNeededstatic Bool_t fgGraphNeededDefinition TApplication.h:73; TApplic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:89086,guid,guide,89086,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['guid'],['guide']
Usability,"irtual . Implements RooAbsDataStore.; Definition at line 1041 of file RooVectorDataStore.cxx. ◆ attachCache(). void RooVectorDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). overridevirtual . Initialize cache of dataset: attach variables of cache ArgSet to the corresponding TTree branches. ; Implements RooAbsDataStore.; Definition at line 982 of file RooVectorDataStore.cxx. ◆ cache(). const RooVectorDataStore * RooVectorDataStore::cache ; (; ); const. inline . Definition at line 171 of file RooVectorDataStore.h. ◆ cacheArgs(). void RooVectorDataStore::cacheArgs ; (; const RooAbsArg * ; owner, . RooArgSet & ; newVarSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = true . ). overridevirtual . Cache given RooAbsArgs: The tree is given direct write access of the args internal cache the args values is pre-calculated for all data points in this data collection. ; Upon a get() call, the internal cache of 'newVar' will be loaded with the precalculated value and it's dirty flag will be cleared. ; Implements RooAbsDataStore.; Definition at line 764 of file RooVectorDataStore.cxx. ◆ cacheOwner(). const RooAbsArg * RooVectorDataStore::cacheOwner ; (; ). inlineoverridevirtual . Implements RooAbsDataStore.; Definition at line 163 of file RooVectorDataStore.h. ◆ catStoreList(). std::vector< CatVector * > & RooVectorDataStore::catStoreList ; (; ). inline . Definition at line 542 of file RooVectorDataStore.h. ◆ changeObservableName(). bool RooVectorDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 595 of file RooVectorDataStore.cxx. ◆ Class(). static TClass * RooVectorDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooVectorDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooVectorDataStore::Class_V",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooVectorDataStore.html:27552,clear,cleared,27552,doc/master/classRooVectorDataStore.html,https://root.cern,https://root.cern/doc/master/classRooVectorDataStore.html,1,['clear'],['cleared']
Usability,"irtual void TMVA::DNN::Settings::endTestCycle ; (; ). inlinevirtual . callback for monitoring and loggging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 805 of file NeuralNet.h. ◆ endTrainCycle(). virtual void TMVA::DNN::Settings::endTrainCycle ; (; double ; ). inlinevirtual . callback for monitoring and logging ; Reimplemented in TMVA::DNN::ClassificationSettings.; Definition at line 788 of file NeuralNet.h. ◆ exists(). bool TMVA::DNN::Settings::exists ; (; std::string ; histoName). inline . for monitoring ; Definition at line 825 of file NeuralNet.h. ◆ factorWeightDecay(). double TMVA::DNN::Settings::factorWeightDecay ; (; ); const. inline . get the weight-decay factor ; Definition at line 769 of file NeuralNet.h. ◆ hasConverged(). bool TMVA::DNN::Settings::hasConverged ; (; double ; testError). virtual . has this training converged already? ; check for convergence; Definition at line 485 of file NeuralNet.cxx. ◆ learningRate(). double TMVA::DNN::Settings::learningRate ; (; ); const. inline . get the learning rate ; Definition at line 771 of file NeuralNet.h. ◆ maxConvergenceCount(). size_t TMVA::DNN::Settings::maxConvergenceCount ; (; ); const. inline . returns the max convergence count so far ; Definition at line 828 of file NeuralNet.h. ◆ minError(). size_t TMVA::DNN::Settings::minError ; (; ); const. inline . returns the smallest error so far ; Definition at line 829 of file NeuralNet.h. ◆ minimizerType(). MinimizerType TMVA::DNN::Settings::minimizerType ; (; ); const. inline . which minimizer shall be used (e.g. SGD) ; Definition at line 774 of file NeuralNet.h. ◆ momentum(). double TMVA::DNN::Settings::momentum ; (; ); const. inline . get the momentum (e.g. for SGD) ; Definition at line 772 of file NeuralNet.h. ◆ pads(). void TMVA::DNN::Settings::pads ; (; int ; numPads). inline . preparation for monitoring ; Definition at line 818 of file NeuralNet.h. ◆ plot(). void TMVA::DNN::Settings::plot ; (; std::string ; histoName, . std::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html:9044,learn,learningRate,9044,doc/master/classTMVA_1_1DNN_1_1Settings.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1Settings.html,1,['learn'],['learningRate']
Usability,"irtualCollectionProxy::EProperty. { return fProperties; }. void * New() const; Return a new container object. void * New(void* arena) const; Execute the container constructor. void * NewArray(Int_t nElements) const; Return a new container object. void * NewArray(Int_t nElements, void* arena) const; Execute the container constructor. void Destructor(void* p, Bool_t dtorOnly = kFALSE); Execute the container destructor. void DeleteArray(void* p, Bool_t dtorOnly = kFALSE); Execute the container array destructor. UInt_t Sizeof() const; Return the sizeof the collection object. void PushProxy(void* objectstart); Set the address of the container being proxied and keep track of the previous one. void PopProxy(); Reset the address of the container being proxied to the previous container. Bool_t HasPointers() const; Return true if the content is of type 'pointer to'. TClass * GetValueClass(); Return a pointer to the TClass representing the content. EDataType GetType(); If the content is a simple numerical value, return its type (see TDataType). void * At(UInt_t idx); Return the address of the value at index 'idx'. void Clear(const char* opt = """"); Clear the container. UInt_t Size() const; Return the current size of the container. void* Allocate(UInt_t n, Bool_t forceDelete). void Commit(void* ). char * operator[](UInt_t idx) const; { return (char*)(const_cast<TVirtualCollectionProxy*>(this))->At(idx); }. TStreamerInfoActions::TActionSequence * GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); MemberWise actions. TStreamerInfoActions::TActionSequence * GetReadMemberWiseActions(Int_t version). TStreamerInfoActions::TActionSequence * GetWriteMemberWiseActions(). CreateIterators_t GetFunctionCreateIterators(Bool_t read = kTRUE); begin_arena and end_arena should contain the location of a memory arena of size fgIteratorSize.; If the collection iterator are of that size or less, the iterators will be constructed in place in those location (new with placement); Othe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualCollectionProxy.html:4380,simpl,simple,4380,root/html528/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualCollectionProxy.html,3,['simpl'],['simple']
Usability,"irtualXProxy.cxx:70; y1Option_t Option_t TPoint TPoint const char y1Definition TGWin32VirtualXProxy.cxx:70; TArrowDraw all kinds of Arrows.Definition TArrow.h:29; TArrow::Drawvoid Draw(Option_t *option="""") overrideDraw this arrow with its current attributes.Definition TArrow.cxx:120; TArrow::SetAnglevirtual void SetAngle(Float_t angle=60)Definition TArrow.h:60; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineStylevirtual void SetLineStyle(Style_t lstyle)Set the line style.Definition TAttLine.h:42; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttText::SetTextAlignvirtual void SetTextAlign(Short_t align=11)Set the text alignment.Definition TAttText.h:42; TAttText::SetTextFontvirtual void SetTextFont(Font_t tfont=62)Set the text font.Definition TAttText.h:46; TAttText::SetTextSizevirtual void SetTextSize(Float_t tsize=1)Set the text size.Definition TAttText.h:47; TCanvasThe Canvas class.Definition TCanvas.h:23; TLatexTo draw Mathematical Formula.Definition TLatex.h:18; TLatex::DrawLatexTLatex * DrawLatex(Double_t x, Double_t y, const char *text)Make a copy of this object with the new parameters And copy object attributes.Definition TLatex.cxx:1943; TLineUse the TLine constructor to create a simple line.Definition TLine.h:22; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; TMath::Cconstexpr Double_t C()Velocity of light in .Definition TMath.h:114; lTLine lDefinition textangle.C:4; AuthorOlivier Couet ; Definition in file mass_spectrum.C. tutorialsgraphicsmass_spectrum.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mass__spectrum_8C.html:5858,simpl,simple,5858,doc/master/mass__spectrum_8C.html,https://root.cern,https://root.cern/doc/master/mass__spectrum_8C.html,1,['simpl'],['simple']
Usability,"is a simple example of how to use a TGTreeTable ;  guilabels.CThis macro gives an example of how to create different kind of labels and the possibility to enable/disable them ;  guitest.CTest program for ROOT native GUI classes Exactly like $ROOTSYS/test/guitest.cxx but using the new signal and slots communication mechanism ;  guitest_playback.CThis macro plays a recorded ROOT session showing how to perform various interactive GUI operations with the guitest.C macro While replaying the session, several temporary macros (guitest0xx.C) macros will be saved ;  guiWithCINT.CA simple example of entering CINT commands and having the CINT output in a ROOT GUI application window ;  iconAsXPMData.CA simple example of creating icon image from XPM data, included into the code ;  listBox.CThis macro gives an example of how to create a list box and how to set and use its multiple selection feature ;  mditest.CGUI MDI features ;  ntupleTableTest.CThis TableTest class is a simple example of how to use a TGTable with a TTreeTableInterface ;  numberEntry.CThis macro gives an example of how to create a number entry and how to update a label according to the changed value of this number entry ;  QtFileDialog.CThis is a small ROOT macro to use Qt 3.3 class: QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileName ;  QtMultiFileDialog.CThis is a small ROOT macro to use Qt 3.3 class :QFileDialog See: https://doc.qt.io/archives/3.3/qfiledialog.html#getOpenFileNames ;  QtPrintDialog.CThis is a small ROOT macro to use Qt 3.3 class: QPrinter to setup the printer via Qt ""setup printer dialog"" See: Printer setup dialog box and print out the ROOT TCanvas object either via the ""can"" pointer provided or the current one ;  simpleTableTest.CThis TableTest class is a simple example of how to use a TGSimpleTable that creates and owns it's own TGSimpleTableInterface ;  Slider3Demo.CSimple macro showing capabilities of triple slider ;  splitbuttonTest.CA simple example that show",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/files.html:119683,simpl,simple,119683,doc/v608/files.html,https://root.cern,https://root.cern/doc/v608/files.html,5,['simpl'],['simple']
Usability,"is active can also be set with the SetEntryRange method. Changes of behavior when using TChain and TEventList; The usage of TChain or TEventList have influence on the behaviour of the cache:. Special case of a TChain Once the training is done on the first Tree, the list of branches in the cache is kept for the following files.; Special case of a TEventlist if the Tree or TChain has a TEventlist, only the buffers referenced by the list are put in the cache. The learning phase is started or restarted when:; TTree automatically creates a cache.; TTree::SetCacheSize is called with a non-zero size and a cache did not previously exist; TTreeCache::StartLearningPhase is called.; TTreeCache::SetEntryRange is called and the learning is not yet finished and has not been set to manual and the new minimun entry is different. The learning period is stopped (and prefetching is started) when:; TTreeCache::StopLearningPhase is called.; An entry outside the 'learning' range is requested The 'learning range is from fEntryMin (default to 0) to fEntryMin + fgLearnEntries.; A 'cached' TChain switches over to a new file. Self-optimization in presence of cache misses; The TTreeCache can optimize its behavior on a cache miss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:4192,learn,learning,4192,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['learn'],['learning']
Usability,"is called by TBranch::GetBasket If we are not longer in the training phase this is an error. ;  ; virtual void LearnPrefill ();  Perform an initial prefetch, attempting to read as much of the learning phase baskets for all branches at once. ;  ; Int_t ReadBuffer (char *buf, Long64_t pos, Int_t len) override;  Read buffer at position pos if the request is in the list of prefetched blocks read from fBuffer. ;  ; virtual Int_t ReadBufferNormal (char *buf, Long64_t pos, Int_t len);  Old method ReadBuffer before the addition of the prefetch mechanism. ;  ; virtual Int_t ReadBufferPrefetch (char *buf, Long64_t pos, Int_t len);  Used to read a chunk from a block previously fetched. ;  ; void ResetMissCache ();  Reset all the miss cache training. ;  ; void SetAutoCreated (bool val);  ; void SetFile (TFile *file, TFile::ECacheAction action=TFile::kDisconnect) override;  Change the file that is being cached. ;  ; virtual void SetLearnPrefill (EPrefillType type=kNoPrefill);  Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ;  ; void SetOptimizeMisses (bool opt);  Start of methods for the miss cache. ;  ; void StartLearningPhase ();  The name should be enough to explain the method. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TFileCacheRead;  TFileCacheRead ();  Default Constructor. ;  ;  TFileCacheRead (TFile *file, Int_t buffersize, TObject *tree=nullptr);  Creates a TFileCacheRead data structure. ;  ;  ~TFileCacheRead () override;  Destructor. ;  ; virtual void AddNoCacheBytesRead (Long64_t len);  ; virtual void AddNoCacheReadCalls (Int_t reads);  ; virtual void Close (Option_t *option="""");  Close out any threads or asynchronous fetches used by the underlying implementation. ;  ; virtual Int_t GetBufferSize () const;  ; virtual Long64_t GetBytesRead () const;  ; virtual Long64_t GetBytesReadExtra () const;  ; TFile * GetFile () const;  ; virtual Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:7287,learn,learning,7287,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['learn'],['learning']
Usability,"is case, we will name it histogram-race-condition-fix, but you may name it differently according to what your contribution will be.; git checkout -b histogram-race-condition-fix; After implementing your changes, add and commit your changes (More about how to use git here):; git add hist/hist/somefile.cxx; git commit -m ""Avoid race condition on Ubuntu 16.04""; git push --set-upstream origin histogram-race-condition-fix; Your changes are now in your forked repository on GitHub. We will now make the pull request.; Making the pull request on GitHub; If you go to https://github.com/<your GitHub username>/root, you will see a notification saying ""Your recently pushed branches: histogram-race-condition-fix (some minutes ago)"":. You can now hit the green ""Compare & pull request"" button which lets you create the pull request.; Fill in a reasonable description of what your new feature is, and hit ""Create pull request"". A project member will later initiate a build of your pull request and then review your pull request before giving feedback and in the end hopefully merge it. More about how what happens after submitting the pull request can be found in the contributing readme.; Pulling the last changes from upstream/master; Often, there might have been changes in the upstream/master repository that you want to have together with your new changes. This section will describe how to pull the new changes.; Add the ROOT repository upstream as a remote:; git remote add upstream https://github.com/root-project/root; Make sure you are on the master branch locally and pull the latest changes from upstream:; git checkout master; git pull upstream master; Go back to your local branch and rebase the last changes from master:; git checkout histogram-race-condition-fix; git rebase master; Push your new updated local branch to your GitHub repository (origin):; git push --force; Summary. The entire workflow is summarized in the image above. First, we cloned root-project/root, and cloned it to o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:3515,feedback,feedback,3515,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,1,['feedback'],['feedback']
Usability,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. Double_t EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall cor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:22690,simpl,simple,22690,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,3,['simpl'],['simple']
Usability,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char** stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:23008,simpl,simple,23008,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,1,['simpl'],['simple']
Usability,"is name. TLeaf* GetLeafWithDatamember(const char* topchoice, const char* nextchice, Long64_t readentry) const. Bool_t BranchHasMethod(TLeaf* leaf, TBranch* branch, const char* method, const char* params, Long64_t readentry) const; Return the leaf (if any) of the tree with contains an object of a class; having a method which has the name provided in the argument. Int_t GetRealInstance(Int_t instance, Int_t codeindex); Now let calculate what physical instance we really need.; Some redundant code is used to speed up the cases where; they are no dimensions.; We know that instance is less that fCumulUsedSize[0] so; we can skip the modulo when virt_dim is 0. TClass* EvalClass() const; Evaluate the class of this treeformula. If the 'value' of this formula is a simple pointer to an object,; this function returns the TClass corresponding to its type. TClass* EvalClass(Int_t oper) const; Evaluate the class of the operation oper. If the 'value' in the requested operation is a simple pointer to an object,; this function returns the TClass corresponding to its type. void* EvalObject(Int_t i = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. Return the address of the object pointed to by the formula.; Return 0 if the formula is not a single object; The object type can be retrieved using by call EvalClass();. const char* EvalStringInstance(Int_t i = 0); Eval the instance as a string. T EvalInstance(Int_t i = 0, const char*[] stringStack = 0); Evaluate this treeformula*-*-*-*-; *-* =========================. TFormLeafInfo * GetLeafInfo(Int_t code) const; -*-*Return DataMember corresponding to code; *-* =======================================. function called by TLeafObject::GetValue; with the value of fLookupType computed in TTreeFormula::DefinedVariable. TLeaf * GetLeaf(Int_t n) const; -*-*Return leaf corresponding to serial number n; *-* ============================================. TMethodCall * GetMethodCall(Int_t code) const; -*-*Return methodcall correspon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:28258,simpl,simple,28258,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['simpl'],['simple']
Usability,"is of the W boson mass taken from the ATLAS Open Data release in 2020 (http://opendata.atlas.cern/release/2020/documentation/). The data was recorded with the ATLAS detector during 2016 at a center-of-mass energy of 13 TeV. W bosons are produced frequently at the LHC and are an important background to studies of Standard Model processes, for example the Higgs boson analyses.; The analysis is translated to a RDataFrame workflow processing up to 60 GB of simulated events and data. By default the analysis runs on a preskimmed dataset to reduce the runtime. The full dataset can be used with the –full-dataset argument and you can also run only on a fraction of the original dataset using the argument –lumi-scale.; See the corresponding spec json file. ; import ROOT; import sys; import json; import argparse; import os; ; # Argument parsing; parser = argparse.ArgumentParser(); parser.add_argument(""--lumi-scale"", type=float, default=0.001,; help=""Run only on a fraction of the total available 10 fb^-1 (only usable together with --full-dataset)""); parser.add_argument(""--full-dataset"", action=""store_true"", default=False,; help=""Use the full dataset (use --lumi-scale to run only on a fraction of it)""); parser.add_argument(""-b"", action=""store_true"", default=False, help=""Use ROOT batch mode""); parser.add_argument(""-t"", action=""store_true"", default=False, help=""Use implicit multi threading (for the full dataset only possible with --lumi-scale 1.0)""); if 'df105_WBosonAnalysis.py' in sys.argv[0]:; # Script; args = parser.parse_args(); else:; # Notebook; args = parser.parse_args(args=[]); ; if args.b: ROOT.gROOT.SetBatch(True); if args.t: ROOT.EnableImplicitMT(); ; if not args.full_dataset: lumi_scale = 0.001 # The preskimmed dataset contains only 0.01 fb^-1; else: lumi_scale = args.lumi_scale; lumi = 10064.0; print('Run on data corresponding to {:.2f} fb^-1 ...'.format(lumi * lumi_scale / 1000.0)); ; if args.full_dataset: dataset_path = ""root://eospublic.cern.ch//eos/opendata/atlas/O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html:1382,usab,usable,1382,doc/master/df105__WBosonAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df105__WBosonAnalysis_8py.html,1,['usab'],['usable']
