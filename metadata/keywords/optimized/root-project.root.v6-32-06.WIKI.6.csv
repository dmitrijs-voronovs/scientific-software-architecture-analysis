quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualMutex.h 25230 2008-08-25 15:22:04Z rdm $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TLockGuard.html:376,avail,available,376,root/html532/TLockGuard.html,https://root.cern,https://root.cern/root/html532/TLockGuard.html,2,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. TLockGuard(TVirtualMutex* mutex); virtual~TLockGuard(); static TClass*Class(); virtual TClass*IsA() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TLockGuard(const TLockGuard&); TLockGuard&operator=(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. virtual ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TLockGuard.html:376,avail,available,376,root/html534/TLockGuard.html,https://root.cern,https://root.cern/root/html534/TLockGuard.html,2,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 13:52; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TLockGuard.html:376,avail,available,376,root/html602/TLockGuard.html,https://root.cern,https://root.cern/root/html602/TLockGuard.html,2,['avail'],['available']
Availability,". TLockGuard. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TLockGuard. class TLockGuard. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods); public:. ~TLockGuard(); static TClass*Class(); TClass*IsA() const; voidShowMembers(TMemberInspector& insp) const; voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TLockGuard(TVirtualMutex* mutex); Int_tUnLock(). private:. TLockGuard&operator=(const TLockGuard&); TLockGuard(const TLockGuard&). Data Members; private:. TVirtualMutex*fMutex. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t UnLock(). TLockGuard(const TLockGuard& ). TLockGuard& operator=(const TLockGuard& ). TLockGuard(TVirtualMutex* mutex); { if (fMutex) fMutex->Lock(); }. ~TLockGuard(); { if (fMutex) fMutex->UnLock(); }. » Author: Fons Rademakers 14/07/2002 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TLockGuard.html:376,avail,available,376,root/html604/TLockGuard.html,https://root.cern,https://root.cern/root/html604/TLockGuard.html,2,['avail'],['available']
Availability,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer. Class Charts. Inheritance; In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMD5.html:508,avail,available,508,root/html528/TMD5.html,https://root.cern,https://root.cern/root/html528/TMD5.html,4,['avail'],['available']
Availability,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t* digest); voidFinal(); voidFinal(UChar_t* digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t* buf, const UChar_t* in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!temp buffer; Char_tfStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMD5.html:508,avail,available,508,root/html534/TMD5.html,https://root.cern,https://root.cern/root/html534/TMD5.html,2,['avail'],['available']
Availability,". TMD5. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMD5. class TMD5. TMD5. This code implements the MD5 message-digest algorithm.; The algorithm is due to Ron Rivest. This code was; written by Colin Plumb in 1993, no copyright is claimed.; This code is in the public domain; do with it what you wish. Equivalent code is available from RSA Data Security, Inc.; This code has been tested against that, and is equivalent,; except that you don't need to include two pages of legalese; with every copy. To compute the message digest of a chunk of bytes, create an; TMD5 object, call Update() as needed on buffers full of bytes, and; then call Final(), which will, optionally, fill a supplied 16-byte; array with the digest. Function Members (Methods); public:. virtual~TMD5(); const char*AsString() const; static TClass*Class(); static TMD5*FileChecksum(const char* file); static Int_tFileChecksum(const char* file, UChar_t[16] digest); voidFinal(); voidFinal(UChar_t[16] digest); virtual TClass*IsA() const; TMD5&operator=(const TMD5& rhs); voidPrint() const; static TMD5*ReadChecksum(const char* file); Int_tSetDigest(const char* md5ascii); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMD5(); TMD5(const UChar_t* digest); TMD5(const TMD5& md5); voidUpdate(const UChar_t* buf, UInt_t len); static Int_tWriteChecksum(const char* file, const TMD5* md5). private:. voidDecode(UInt_t* out, const UChar_t* in, UInt_t len); voidEncode(UChar_t* out, const UInt_t* in, UInt_t len); voidTransform(UInt_t[4] buf, const UChar_t[64] in). Data Members; private:. UInt_tfBits[2]!temp buffer; UInt_tfBuf[4]!temp buffer; UChar_tfDigest[16]message digest; Bool_tfFinalizedtrue if message digest has been finalized; UChar_tfIn[64]!t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMD5.html:508,avail,available,508,root/html602/TMD5.html,https://root.cern,https://root.cern/root/html602/TMD5.html,4,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; TMVA::BinaryTreeBinaryTree(); TMVA::BinaryTreeBinaryTree(const TMVA::BinaryTree&); static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = __null); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = 262656); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = 262656); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = __null); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinaryTree(const TMVA::BinaryTree& ); constructor for a yet ""empty"" tree. Needs to be filled afterwards. ~BinaryT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__BinaryTree.html:479,avail,available,479,root/html602/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html602/TMVA__BinaryTree.html,2,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = NULL); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree; static TMVA::MsgLogger*fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* ); protected, recurs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__BinaryTree.html:479,avail,available,479,root/html528/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html528/TMVA__BinaryTree.html,4,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = NULL); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = NULL); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree; static TMVA::MsgLogger*fgLoggermessage logger, static to save resources . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~BinaryTree( void ); destructor (deletes the nodes and ""events"" if owned by the tree. void DeleteNode(TMVA::Node* )",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__BinaryTree.html:479,avail,available,479,root/html534/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html534/TMVA__BinaryTree.html,2,['avail'],['available']
Availability,". TMVA::BinaryTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::BinaryTree. class TMVA::BinaryTree. BinaryTree. Base class for BinarySearch and Decision Trees. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~BinaryTree(); virtual void*AddXMLTo(void* parent) const; TMVA::BinaryTreeBinaryTree(); TMVA::BinaryTreeBinaryTree(const TMVA::BinaryTree&); static TClass*Class(); virtual const char*ClassName() const; UInt_tCountNodes(TMVA::Node* n = __null); virtual TMVA::Node*CreateNode(UInt_t size = 0) const; virtual TMVA::BinaryTree*CreateTree() const; TMVA::Node*GetLeftDaughter(TMVA::Node* n); UInt_tGetNNodes() const; TMVA::Node*GetRightDaughter(TMVA::Node* n); virtual TMVA::Node*GetRoot() const; UInt_tGetTotalTreeDepth() const; virtual TClass*IsA() const; TMVA::BinaryTree&operator=(const TMVA::BinaryTree&); virtual voidPrint(ostream& os) const; virtual voidRead(istream& istr, UInt_t tmva_Version_Code = 262657); virtual voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetRoot(TMVA::Node* r); voidSetTotalTreeDepth(Int_t depth); voidSetTotalTreeDepth(TMVA::Node* n = __null); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidDeleteNode(TMVA::Node*); TMVA::MsgLogger&Log() const. Data Members; protected:. UInt_tfDepthmaximal depth in tree reached; UInt_tfNNodestotal number of nodes in the tree (counted); TMVA::Node*fRootthe root node of the tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; BinaryTree(const TMVA::BinaryTree& ); constructor for a yet ""empty"" tree. Needs to be filled afterwards. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__BinaryTree.html:487,avail,available,487,root/html604/TMVA__BinaryTree.html,https://root.cern,https://root.cern/root/html604/TMVA__BinaryTree.html,2,['avail'],['available']
Availability,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__FitterBase.html:530,avail,available,530,root/html602/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html602/TMVA__FitterBase.html,2,['avail'],['available']
Availability,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__FitterBase.html:530,avail,available,530,root/html528/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html528/TMVA__FitterBase.html,6,['avail'],['available']
Availability,". TMVA::FitterBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::FitterBase. class TMVA::FitterBase: public TMVA::Configurable. FitterBase. Baseclass for TMVA fitters. Also defines generalised fitting interface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~FitterBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& parameters); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__FitterBase.html:538,avail,available,538,root/html604/TMVA__FitterBase.html,https://root.cern,https://root.cern/root/html604/TMVA__FitterBase.html,2,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); TMVA::IFitterTargetIFitterTarget(); TMVA::IFitterTargetIFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IFitterTarget(); constructor. IFitterTarget(). virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__IFitterTarget.html:522,avail,available,522,root/html602/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html602/TMVA__IFitterTarget.html,2,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__IFitterTarget.html:522,avail,available,522,root/html528/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html528/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__IFitterTarget.html:522,avail,available,522,root/html530/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html530/TMVA__IFitterTarget.html,1,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id: IFitterTarget.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__IFitterTarget.html:522,avail,available,522,root/html532/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html532/TMVA__IFitterTarget.html,2,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:43; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__IFitterTarget.html:522,avail,available,522,root/html534/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html534/TMVA__IFitterTarget.html,2,['avail'],['available']
Availability,". TMVA::IFitterTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IFitterTarget. class TMVA::IFitterTarget. IFitterTarget. Interface for a fitter 'target'. Defines interface to the estimator; function. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IFitterTarget(); static TClass*Class(); virtual Double_tEstimatorFunction(vector<Double_t>& parameters); TMVA::IFitterTargetIFitterTarget(); TMVA::IFitterTargetIFitterTarget(const TMVA::IFitterTarget&); virtual TClass*IsA() const; TMVA::IFitterTarget&operator=(const TMVA::IFitterTarget&); virtual voidProgressNotifier(TString, TString); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IFitterTarget(); constructor. IFitterTarget(). virtual ~IFitterTarget(); {}. Double_t EstimatorFunction(vector<Double_t>& parameters). void ProgressNotifier(TString , TString ); function to notify the FitterTarget of the progress status of the fitter; sender : ""GA"", ""MC"", ...; progress : ""init"", ""iteration"", ""last"", ""stop"". {}. » Author: Andreas Hoecker, Peter Speckmayer » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__IFitterTarget.html:530,avail,available,530,root/html604/TMVA__IFitterTarget.html,https://root.cern,https://root.cern/root/html604/TMVA__IFitterTarget.html,2,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0); virtual const char*GetName() const; virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; virtual Bool_tMonitorBoost(TMVA::MethodBoost* boost); TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to target file. void MakeClass(const TString& classFileName = TString("""")) const; make ROOT-independent C++ class for classifier ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__IMethod.html:410,avail,available,410,root/html528/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html528/TMVA__IMethod.html,1,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMVA::IMethodIMethod(); TMVA::IMethodIMethod(const TMVA::IMethod&); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__IMethod.html:410,avail,available,410,root/html602/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html602/TMVA__IMethod.html,2,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method specific monitoring histograms to targe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__IMethod.html:410,avail,available,410,root/html534/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html534/TMVA__IMethod.html,2,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; virtual Bool_tMonitorBoost(TMVA::MethodBoost* boost); TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read weights from output stream. void WriteMonitoringHistosToFile( void ); write method spec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__IMethod.html:410,avail,available,410,root/html530/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html530/TMVA__IMethod.html,3,['avail'],['available']
Availability,". TMVA::IMethod. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::IMethod. class TMVA::IMethod. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~IMethod(); static TClass*Class(); virtual const TMVA::Ranking*CreateRanking(); virtual voidDeclareOptions(); virtual Double_tGetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); virtual const char*GetName() const; virtual Bool_tHasAnalysisType(TMVA::Types::EAnalysisType type, UInt_t numberClasses, UInt_t numberTargets); TMVA::IMethodIMethod(); TMVA::IMethodIMethod(const TMVA::IMethod&); virtual voidInit(); virtual TClass*IsA() const; virtual voidMakeClass(const TString& classFileName = TString("""")) const; TMVA::IMethod&operator=(const TMVA::IMethod&); virtual voidPrintHelpMessage() const; virtual voidProcessOptions(); virtual voidReadWeightsFromStream(istream&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTrain(); virtual voidWriteMonitoringHistosToFile() const. protected:. virtual voidGetHelpMessage() const; virtual voidMakeClassSpecific(ostream&, const TString&) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; IMethod(); default constructur. {}. virtual ~IMethod(); default destructur. {}. const char * GetName() const; ------- virtual member functions to be implemented by each MVA method; the name of the method. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the MVA value - some methods may return a per-event error estimate (unless: *err = -1). void Train( void ); training method. void ReadWeightsFromStream(istream& ); read",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__IMethod.html:418,avail,available,418,root/html604/TMVA__IMethod.html,https://root.cern,https://root.cern/root/html604/TMVA__IMethod.html,2,['avail'],['available']
Availability,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodANNBase.html:519,avail,available,519,root/html602/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodANNBase.html,2,['avail'],['available']
Availability,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticlass() const; Bool_tTMVA::MethodBase::DoRegression() const; virtual voidTObject::Dr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodANNBase.html:519,avail,available,519,root/html528/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodANNBase.html,6,['avail'],['available']
Availability,". TMVA::MethodANNBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodANNBase. class TMVA::MethodANNBase: public TMVA::MethodBase. Base class for all TMVA methods using artificial neural networks. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodANNBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; Bool_tDebug() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidDeclareOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodANNBase.html:527,avail,available,527,root/html604/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodANNBase.html,2,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double_t* tin2, Double_t*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html:736,avail,available,736,root/html528/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCFMlpANN_Utils.html,4,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidOut(Int_t* iii, Int_t* maxcycle); Double_tSen3a(); voidSetLogger(TMVA::MsgLogger* l); voidTestNN(); voidTrain_nn(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodCFMlpANN_Utils.html:736,avail,available,736,root/html534/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodCFMlpANN_Utils.html,2,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(); TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(const TMVA::MethodCFMlpANN_Utils&); TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Double_t* tou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCFMlpANN_Utils.html:736,avail,available,736,root/html602/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCFMlpANN_Utils.html,2,['avail'],['available']
Availability,". TMVA::MethodCFMlpANN_Utils. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCFMlpANN_Utils. class TMVA::MethodCFMlpANN_Utils. Implementation of Clermond-Ferrand artificial neural network. Reference for the original FORTRAN version ""mlpl3.F"":; Authors : J. Proriol and contributions from ALEPH-Clermont-Ferrand; Team members; Copyright: Laboratoire Physique Corpusculaire; Universite de Blaise Pascal, IN2P3/CNRS. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCFMlpANN_Utils(); static TClass*Class(); virtual TClass*IsA() const; TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(); TMVA::MethodCFMlpANN_UtilsMethodCFMlpANN_Utils(const TMVA::MethodCFMlpANN_Utils&); TMVA::MethodCFMlpANN_Utils&operator=(const TMVA::MethodCFMlpANN_Utils&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidArret(const char* mot); voidCollectVar(Int_t* nvar, Int_t* class__, Double_t* xpg); voidCout(Int_t*, Double_t* xxx); voidCout2(Int_t*, Double_t* yyy); virtual Int_tDataInterface(Double_t*, Double_t*, Int_t*, Int_t*, Int_t*, Int_t*, Double_t*, Int_t*, Int_t*); voidEn_arriere(Int_t* ievent); voidEn_avant(Int_t* ievent); voidEn_avant2(Int_t* ievent); voidEntree_new(Int_t*, char*, Int_t* ntrain, Int_t* ntest, Int_t* numlayer, Int_t* nodes, Int_t* numcycle, Int_t); Double_tFdecroi(Int_t* i__); voidFoncf(Int_t* i__, Double_t* u, Double_t* f); voidGraphNN(Int_t* ilearn, Double_t*, Double_t*, char*, Int_t); voidInl(); voidInnit(char* det, Double_t* tout2, Double_t* tin2, Int_t); voidLecev2(Int_t* ktest, Double_t* tout2, Double_t* tin2); voidLeclearn(Int_t* ktest, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html:744,avail,available,744,root/html604/TMVA__MethodCFMlpANN_Utils.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCFMlpANN_Utils.html,2,['avail'],['available']
Availability,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodCompositeBase.html:715,avail,available,715,root/html602/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodCompositeBase.html,2,['avail'],['available']
Availability,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::Dista",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodCompositeBase.html:715,avail,available,715,root/html528/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodCompositeBase.html,6,['avail'],['available']
Availability,". TMVA::MethodCompositeBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodCompositeBase. class TMVA::MethodCompositeBase: public TMVA::MethodBase. This class is virtual class meant to combine more than one classifier; together. The training of the classifiers is done by classes that are; derived from this one, while the saving and loading of weights file; and the evaluation is done here. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MethodCompositeBase(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodCompositeBase.html:723,avail,available,723,root/html604/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodCompositeBase.html,2,['avail'],['available']
Availability,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:465,Avail,Available,465,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,1,['Avail'],['Available']
Availability,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); Bool_tTMVA::MethodBase::DoMulticla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodTMlpANN.html:465,Avail,Available,465,root/html532/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodTMlpANN.html,2,['Avail'],['Available']
Availability,". TMVA::MethodTMlpANN. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::MethodTMlpANN. class TMVA::MethodTMlpANN: public TMVA::MethodBase. This is the TMVA TMultiLayerPerceptron interface class. It provides the; training and testing the ROOT internal MLP class in the TMVA framework.; Available learning methods:. Stochastic ; Batch ; SteepestDescent ; RibierePolak ; FletcherReeves ; BFGS . . See the TMultiLayerPerceptron class description; for details on this ANN. Function Members (Methods); public:. virtual~MethodTMlpANN(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; voidTMVA::MethodBase::AddOutput(TMVA::Types::ETreeType type, TMVA::Types::EAnalysisType analysisType); virtual voidAddWeightsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); TDirectory*TMVA::MethodBase::BaseDir() const; virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; virtual voidTMVA::MethodBase::CheckSetup(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); TMVA::ConfigurableTMVA::Configurable::Configurable(const TMVA::Configurable&); virtual voidTObject::Copy(TObject& object) const; virtual const TMVA::Ranking*CreateRanking(); TMVA::DataSet*TMVA::MethodBase::Data() const; TMVA::DataSetInfo&TMVA::MethodBase::DataInfo() const; virtual voidTMVA::MethodBase::DeclareCompatibilityOptions(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::MethodBase::DisableWriting(Bool_t setter); virtual In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__MethodTMlpANN.html:473,Avail,Available,473,root/html604/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html604/TMVA__MethodTMlpANN.html,1,['Avail'],['Available']
Availability,". TMVA::MinuitFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::MinuitFitter. class TMVA::MinuitFitter: public TMVA::FitterBase, public TMVA::IFitterTarget. Fitter using MINUIT. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~MinuitFitter(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::Configurable::AddOptionsXMLTo(void* parent) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::Configurable::CheckForUnusedOptions() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; TMVA::ConfigurableTMVA::Configurable::Configurable(const TString& theOption = """"); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; Double_tEstimatorFunction(vector<Double_t>& pars); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MinuitFitter.html:499,avail,available,499,root/html528/TMVA__MinuitFitter.html,https://root.cern,https://root.cern/root/html528/TMVA__MinuitFitter.html,6,['avail'],['available']
Availability,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidReadXML(void* node, UInt_t tmva_Version_Code = TMVA_VERSION_CODE); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); virtual voidSetRight(TMVA::Node* r); virtual voidShowMembers(TMemberInsp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__Node.html:723,avail,available,723,root/html528/TMVA__Node.html,https://root.cern,https://root.cern/root/html528/TMVA__Node.html,6,['avail'],['available']
Availability,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeNode(); TMVA::NodeNode(const TMVA::Node& n); TMVA::NodeNode(TMVA::Node* p, char pos); TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262656); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = 262656); voidReadXML(void* node, UInt_t tmva_Version_Code = 262656); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__Node.html:723,avail,available,723,root/html602/TMVA__Node.html,https://root.cern,https://root.cern/root/html602/TMVA__Node.html,2,['avail'],['available']
Availability,". TMVA::Node. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::Node. class TMVA::Node. Node for the BinarySearch or Decision Trees. For the binary search tree, it basically consists of the EVENT, and; pointers to the parent and daughters. In case of the Decision Tree, it specifies parent and daughters, as; well as ""which variable is used"" in the selection of this node,; including the respective cut value. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~Node(); virtual voidAddAttributesToNode(void* node) const; virtual voidAddContentToNode(stringstream& s) const; void*AddXMLTo(void* parent) const; static TClass*Class(); Int_tCountMeAndAllDaughters() const; virtual TMVA::Node*CreateNode() const; intGetCount(); UInt_tGetDepth() const; virtual TMVA::Node*GetLeft() const; virtual TMVA::Node*GetParent() const; virtual TMVA::BinaryTree*GetParentTree() const; charGetPos() const; virtual TMVA::Node*GetRight() const; virtual Bool_tGoesLeft(const TMVA::Event&) const; virtual Bool_tGoesRight(const TMVA::Event&) const; virtual TClass*IsA() const; TMVA::NodeNode(); TMVA::NodeNode(const TMVA::Node& n); TMVA::NodeNode(TMVA::Node* p, char pos); TMVA::Node&operator=(const TMVA::Node&); virtual voidPrint(ostream& os) const; virtual voidPrintRec(ostream& os) const; virtual voidReadAttributes(void* node, UInt_t tmva_Version_Code = 262657); virtual voidReadContent(stringstream& s); virtual Bool_tReadDataRecord(istream&, UInt_t tmva_Version_Code = 262657); voidReadXML(void* node, UInt_t tmva_Version_Code = 262657); voidSetDepth(UInt_t d); virtual voidSetLeft(TMVA::Node* l); virtual voidSetParent(TMVA::Node* p); virtual voidSetParentTree(TMVA::BinaryTree* t); voidSetPos(char s); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__Node.html:731,avail,available,731,root/html604/TMVA__Node.html,https://root.cern,https://root.cern/root/html604/TMVA__Node.html,2,['avail'],['available']
Availability,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = NULL); virtual voidTObject::DrawClass() constMENU ; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamDecisionTree.html:540,error,error,540,root/html530/TMVA__PDEFoamDecisionTree.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamDecisionTree.html,5,['error'],['error']
Availability,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamDecisionTree.html:540,error,error,540,root/html602/TMVA__PDEFoamDecisionTree.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamDecisionTree.html,2,['error'],['error']
Availability,". TMVA::PDEFoamDecisionTree. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDecisionTree. class TMVA::PDEFoamDecisionTree: public TMVA::PDEFoamDiscriminant. PDEFoamDecisionTree. This PDEFoam variant acts like a decision tree and stores in every; cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. The decision tree-like behaviour; is achieved by overriding PDEFoamDiscriminant::Explore() to use a; decision tree-like cell splitting algorithm (given a separation; type). This PDEFoam variant should be booked together with the; PDEFoamDecisionTreeDensity density estimator, which returns the; events in a cell without sampling. Function Members (Methods); public:. virtual~PDEFoamDecisionTree(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html:548,error,error,548,root/html604/TMVA__PDEFoamDecisionTree.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDecisionTree.html,2,['error'],['error']
Availability,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = NULL); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamDiscriminant.html:497,error,error,497,root/html530/TMVA__PDEFoamDiscriminant.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamDiscriminant.html,5,['error'],['error']
Availability,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamDiscriminant.html:497,error,error,497,root/html602/TMVA__PDEFoamDiscriminant.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamDiscriminant.html,2,['error'],['error']
Availability,". TMVA::PDEFoamDiscriminant. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamDiscriminant. class TMVA::PDEFoamDiscriminant: public TMVA::PDEFoam. PDEFoamDiscriminant. This PDEFoam variant stores in every cell the discriminant. D = #events with given class / total number of events. as well as the statistical error on the discriminant. It therefore; acts as a discriminant estimator. It should be booked together; with the PDEFoamDiscriminantDensity density estimator, which; returns the discriminant density at a given phase space point; during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamDiscriminant(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html:505,error,error,505,root/html604/TMVA__PDEFoamDiscriminant.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamDiscriminant.html,2,['error'],['error']
Availability,". TMVA::PDEFoamKernelBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamKernelBase. class TMVA::PDEFoamKernelBase: public TObject. PDEFoamKernelBase. This class is the abstract kernel interface for PDEFoam. The; kernel can be used for manipulating (smearing) the cell values of a; PDEFoam, by passing it as an argument to; PDEFoam::GetCellValue(...). Derived classes must implement the Estimate() function to provide a; specific kernel behaviour. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamKernelBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamKernelBase.html:772,avail,available,772,root/html530/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamKernelBase.html,7,['avail'],['available']
Availability,". TMVA::PDEFoamKernelBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamKernelBase. class TMVA::PDEFoamKernelBase: public TObject. PDEFoamKernelBase. This class is the abstract kernel interface for PDEFoam. The; kernel can be used for manipulating (smearing) the cell values of a; PDEFoam, by passing it as an argument to; PDEFoam::GetCellValue(...). Derived classes must implement the Estimate() function to provide a; specific kernel behaviour. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~PDEFoamKernelBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Float_tEstimate(TMVA::PDEFoam*, vector<Float_t>&, TMVA::ECellValue); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html:780,avail,available,780,root/html604/TMVA__PDEFoamKernelBase.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamKernelBase.html,2,['avail'],['available']
Availability,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = NULL); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__PDEFoamTarget.html:450,error,error,450,root/html530/TMVA__PDEFoamTarget.html,https://root.cern,https://root.cern/root/html530/TMVA__PDEFoamTarget.html,5,['error'],['error']
Availability,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__PDEFoamTarget.html:450,error,error,450,root/html602/TMVA__PDEFoamTarget.html,https://root.cern,https://root.cern/root/html602/TMVA__PDEFoamTarget.html,2,['error'],['error']
Availability,". TMVA::PDEFoamTarget. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::PDEFoamTarget. class TMVA::PDEFoamTarget: public TMVA::PDEFoam. PDEFoamTarget. This PDEFoam variant stores in every cell the average target; fTarget (see the Constructor) as well as the statistical error on; the target fTarget. It therefore acts as a target estimator. It; should be booked together with the PDEFoamTargetDensity density; estimator, which returns the target fTarget density at a given; phase space point during the foam build-up. Function Members (Methods); public:. virtual~PDEFoamTarget(); voidTObject::AbstractMethod(const char* method) const; voidTMVA::PDEFoam::AddVariableName(const char* s); voidTMVA::PDEFoam::AddVariableName(TObjString* s); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); voidTMVA::PDEFoam::CheckAll(Int_t); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; voidTMVA::PDEFoam::Create(); virtual voidTObject::Delete(Option_t* option = """")MENU ; voidTMVA::PDEFoam::DeleteBinarySearchTree(); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); TH1D*TMVA::PDEFoam::Draw1Dim(TMVA::ECellValue cell_value, Int_t nbin, TMVA::PDEFoamKernelBase* kernel = __null); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__PDEFoamTarget.html:458,error,error,458,root/html604/TMVA__PDEFoamTarget.html,https://root.cern,https://root.cern/root/html604/TMVA__PDEFoamTarget.html,2,['error'],['error']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__SeparationBase.html:431,avail,available,431,root/html528/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html528/TMVA__SeparationBase.html,4,['avail'],['available']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__SeparationBase.html:431,avail,available,431,root/html602/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html602/TMVA__SeparationBase.html,2,['avail'],['available']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return the separation index (a measure for ""purity"" of the sample""). const TString& GetName(); Return the name of the concrete Index implementation. { return fName; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Cop",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__SeparationBase.html:431,avail,available,431,root/html534/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html534/TMVA__SeparationBase.html,2,['avail'],['available']
Availability,". TMVA::SeparationBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::SeparationBase. class TMVA::SeparationBase. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~SeparationBase(); static TClass*Class(); const TString&GetName(); virtual Double_tGetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); virtual Double_tGetSeparationIndex(const Double_t& s, const Double_t& b); virtual TClass*IsA() const; TMVA::SeparationBase&operator=(const TMVA::SeparationBase&); TMVA::SeparationBaseSeparationBase(); TMVA::SeparationBaseSeparationBase(const TMVA::SeparationBase& s); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; protected:. TStringfNamename of the concrete Separation Index impementation; Double_tfPrecisionCut. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; SeparationBase(); default constructor. SeparationBase(const TMVA::SeparationBase& s); copy constructor. Double_t GetSeparationGain(const Double_t& nSelS, const Double_t& nSelB, const Double_t& nTotS, const Double_t& nTotB); Separation Gain:; the measure of how the quality of separation of the sample increases; by splitting the sample e.g. into a ""left-node"" and a ""right-node""; (N * Index_parent) - (N_left * Index_left) - (N_right * Index_right); this is then the quality crition which is optimized for when trying; to increase the information in the system (making the best selection. virtual ~SeparationBase(); destructor. {}. Double_t GetSeparationIndex(const Double_t& s, const Double_t& b); Return t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__SeparationBase.html:439,avail,available,439,root/html604/TMVA__SeparationBase.html,https://root.cern,https://root.cern/root/html604/TMVA__SeparationBase.html,2,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTActivation(); TMVA::TActivationTActivation(const TMVA::TActivation&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivation(); {}. virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 13:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__TActivation.html:422,avail,available,422,root/html602/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html602/TMVA__TActivation.html,2,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TActivation.html:422,avail,available,422,root/html528/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html528/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__TActivation.html:422,avail,available,422,root/html530/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html530/TMVA__TActivation.html,1,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TActivation.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TActivation.html:422,avail,available,422,root/html532/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html532/TMVA__TActivation.html,2,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TActivation.html:422,avail,available,422,root/html534/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html534/TMVA__TActivation.html,2,['avail'],['available']
Availability,". TMVA::TActivation. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TActivation. class TMVA::TActivation. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TActivation(); static TClass*Class(); virtual Double_tEval(Double_t arg); virtual Double_tEvalDerivative(Double_t arg); virtual TStringGetExpression(); virtual Double_tGetMax(); virtual Double_tGetMin(); virtual TClass*IsA() const; virtual voidMakeFunction(ostream& fout, const TString& fncName); TMVA::TActivation&operator=(const TMVA::TActivation&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TActivationTActivation(); TMVA::TActivationTActivation(const TMVA::TActivation&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TActivation(); {}. virtual ~TActivation(); {}. Double_t Eval(Double_t arg); evaluate the activation function. Double_t EvalDerivative(Double_t arg); evaulate the derivative of the activation function. Double_t GetMin(); minimum of the range of activation function. Double_t GetMax(); maximum of the range of the activation function. TString GetExpression(); expression for activation function. void MakeFunction(ostream& fout, const TString& fncName); writer of function code. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__TActivation.html:430,avail,available,430,root/html604/TMVA__TActivation.html,https://root.cern,https://root.cern/root/html604/TMVA__TActivation.html,2,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TNeuronInputTNeuronInput(); TMVA::TNeuronInputTNeuronInput(const TMVA::TNeuronInput&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuronInput(); {}. virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 13:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__TNeuronInput.html:425,avail,available,425,root/html602/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html602/TMVA__TNeuronInput.html,2,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 29122 2009-06-22 06:51:30Z brun $ » Last generated: 2010-09-23 20:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__TNeuronInput.html:425,avail,available,425,root/html528/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html528/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 39395 2011-05-26 10:05:54Z moneta $ » Last generated: 2011-07-04 15:34; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__TNeuronInput.html:425,avail,available,425,root/html530/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html530/TMVA__TNeuronInput.html,1,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id: TNeuronInput.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__TNeuronInput.html:425,avail,available,425,root/html532/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html532/TMVA__TNeuronInput.html,2,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__TNeuronInput.html:425,avail,available,425,root/html534/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html534/TMVA__TNeuronInput.html,2,['avail'],['available']
Availability,". TMVA::TNeuronInput. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::TNeuronInput. class TMVA::TNeuronInput. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNeuronInput(); static TClass*Class(); virtual Double_tGetInput(const TMVA::TNeuron* neuron) const; virtual TStringGetName(); virtual TClass*IsA() const; TMVA::TNeuronInput&operator=(const TMVA::TNeuronInput&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TMVA::TNeuronInputTNeuronInput(); TMVA::TNeuronInputTNeuronInput(const TMVA::TNeuronInput&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TNeuronInput(); {}. virtual ~TNeuronInput(); {}. Double_t GetInput(const TMVA::TNeuron* neuron) const; calculate input value for neuron. TString GetName(); name of class. » Author: Matt Jachowski » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__TNeuronInput.html:433,avail,available,433,root/html604/TMVA__TNeuronInput.html,https://root.cern,https://root.cern/root/html604/TMVA__TNeuronInput.html,2,['avail'],['available']
Availability,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__VariableTransformBase.html:468,avail,available,468,root/html530/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html530/TMVA__VariableTransformBase.html,7,['avail'],['available']
Availability,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__VariableTransformBase.html:468,avail,available,468,root/html528/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html528/TMVA__VariableTransformBase.html,1,['avail'],['available']
Availability,". TMVA::VariableTransformBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TMVA; » TMVA; » TMVA::VariableTransformBase. class TMVA::VariableTransformBase: public TObject. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~VariableTransformBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAttachXMLTo(void* parent); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCountVariableTypes(UInt_t& nvars, UInt_t& ntgts, UInt_t& nspcts) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__VariableTransformBase.html:476,avail,available,476,root/html604/TMVA__VariableTransformBase.html,https://root.cern,https://root.cern/root/html604/TMVA__VariableTransformBase.html,2,['avail'],['available']
Availability,". TMatrixTBase<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<double>. class TMatrixTBase<double>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Si",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_double_.html:822,avail,available,822,root/html528/TMatrixTBase_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_double_.html,10,['avail'],['available']
Availability,". TMatrixTBase<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTBase<float>. class TMatrixTBase<float>: public TObject. Linear Algebra Package. The present package implements all the basic algorithms dealing; with vectors, matrices, matrix columns, rows, diagonals, etc.; In addition eigen-Vector analysis and several matrix decomposition; have been added (LU,QRH,Cholesky,Bunch-Kaufman and SVD) .; The decompositions are used in matrix inversion, equation solving. For a dense matrix, elements are arranged in memory in a ROW-wise; fashion . For (n x m) matrices where n*m <=kSizeMax (=25 currently); storage space is available on the stack, thus avoiding expensive; allocation/deallocation of heap space . However, this introduces of; course kSizeMax overhead for each matrix object . If this is an; issue recompile with a new appropriate value (>=0) for kSizeMax. Sparse matrices are also stored in row-wise fashion but additional; row/column information is stored, see TMatrixTSparse source for; additional details . Another way to assign and store matrix data is through Use; see for instance stressLinear.cxx file . Unless otherwise specified, matrix and vector indices always start; with 0, spanning up to the specified limit-1. However, there are; constructors to which one can specify aribtrary lower and upper; bounds, e.g. TMatrixD m(1,10,1,5) defines a matrix that ranges; from 1..10, 1..5 (a(1,1)..a(10,5)). The present package provides all facilities to completely AVOID; returning matrices. Use ""TMatrixD A(TMatrixD::kTransposed,B);""; and other fancy constructors as much as possible. If one really needs; to return a matrix, return a TMatrixTLazy object instead. The; conversion is completely transparent to the end user, e.g.; ""TMatrixT m = THaarMatrixT(5);"" and _is_ efficient. Since",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTBase_float_.html:819,avail,available,819,root/html528/TMatrixTBase_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTBase_float_.html,10,['avail'],['available']
Availability,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTLazy_double_.html:573,avail,available,573,root/html602/TMatrixTLazy_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTLazy_double_.html,4,['avail'],['available']
Availability,". TMatrixTLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<double>. class TMatrixTLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Double_t>, TMatrixDLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTLazy_double_.html:663,avail,available,663,root/html528/TMatrixTLazy_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTLazy_double_.html,6,['avail'],['available']
Availability,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int_tGetColLwb() const; Int_tGetColUpb() const; virtual Option_t*TObject::GetDrawOption() co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTLazy_float_.html:570,avail,available,570,root/html602/TMatrixTLazy_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTLazy_float_.html,4,['avail'],['available']
Availability,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFLazy, TMatrixTLazy<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTLazy_float_.html:659,avail,available,659,root/html534/TMatrixTLazy_float_.html,https://root.cern,https://root.cern/root/html534/TMatrixTLazy_float_.html,2,['avail'],['available']
Availability,". TMatrixTLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTLazy<float>. class TMatrixTLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTLazy<Float_t>, TMatrixFLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTLazy_float_.html:659,avail,available,659,root/html528/TMatrixTLazy_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTLazy_float_.html,4,['avail'],['available']
Availability,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSymLazy_double_.html:582,avail,available,582,root/html602/TMatrixTSymLazy_double_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSymLazy_double_.html,4,['avail'],['available']
Availability,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixDSymLazy, TMatrixTSymLazy<Double_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixTSymLazy_double_.html:678,avail,available,678,root/html534/TMatrixTSymLazy_double_.html,https://root.cern,https://root.cern/root/html534/TMatrixTSymLazy_double_.html,2,['avail'],['available']
Availability,". TMatrixTSymLazy<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<double>. class TMatrixTSymLazy<double>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Double_t>, TMatrixDSymLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSymLazy_double_.html:678,avail,available,678,root/html528/TMatrixTSymLazy_double_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSymLazy_double_.html,4,['avail'],['available']
Availability,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSymLazy_float_.html:579,avail,available,579,root/html602/TMatrixTSymLazy_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSymLazy_float_.html,4,['avail'],['available']
Availability,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixFSymLazy, TMatrixTSymLazy<Float_t>. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMatrixTSymLazy_float_.html:674,avail,available,674,root/html528/TMatrixTSymLazy_float_.html,https://root.cern,https://root.cern/root/html528/TMatrixTSymLazy_float_.html,3,['avail'],['available']
Availability,". TMatrixTSymLazy<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TMatrixTSymLazy<float>. class TMatrixTSymLazy<float>: public TObject. Templates of Lazy Matrix classes. TMatrixTLazy; TMatrixTSymLazy; THaarMatrixT; THilbertMatrixT; THilbertMatrixTSym. This class is also known as (typedefs to this class)TMatrixTSymLazy<Float_t>, TMatrixFSymLazy. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMatrixTSymLazy<float>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMatrixTSymLazy_float_.html:674,avail,available,674,root/html530/TMatrixTSymLazy_float_.html,https://root.cern,https://root.cern/root/html530/TMatrixTSymLazy_float_.html,3,['avail'],['available']
Availability,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; TMemberInspector&operator=(const TMemberInspector&); voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters starting at ""startingAt"". void G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMemberInspector.html:684,avail,available,684,root/html528/TMemberInspector.html,https://root.cern,https://root.cern/root/html528/TMemberInspector.html,4,['avail'],['available']
Availability,". TMemberInspector. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMemberInspector. class TMemberInspector. TMemberInspector. Abstract base class for accessing the datamembers of a class.; Classes derived from this class can be given as argument to the; ShowMembers() methods of ROOT classes. This feature facilitates; the writing of class browsers and inspectors. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMemberInspector(); voidAddToParent(const char* name); static TClass*Class(); voidGenericShowMembers(const char* topClassName, void* obj, Bool_t transientMember); const char*GetParent() const; Ssiz_tGetParentLen() const; virtual voidInspect(TClass* cl, const char* parent, const char* name, const void* addr); voidInspectMember(TObject& obj, const char* name); voidInspectMember(TClass* cl, void* pobj, const char* name); voidInspectMember(const char* topclassname, void* pobj, const char* name, Bool_t transient); virtual TClass*IsA() const; voidRemoveFromParent(Ssiz_t startingAt); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TMemberInspector&operator=(const TMemberInspector&). Data Members; private:. TMemberInspector::TParentBuf*fParentcurrent inspection ""path"". Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TMemberInspector(); Destruct a member inspector. const char* GetParent() const; Get the parent string. Ssiz_t GetParentLen() const; Get the length of the parent string. void AddToParent(const char* name); Append ""name"" to the parent string. void RemoveFromParent(Ssiz_t startingAt); Remove trailing characters sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMemberInspector.html:684,avail,available,684,root/html534/TMemberInspector.html,https://root.cern,https://root.cern/root/html534/TMemberInspector.html,2,['avail'],['available']
Availability,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. TMessageHandler(const TClass* cl, Bool_t derived = kTRUE); TMessageHandler(const char* cl, Bool_t derived = kTRUE); virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMessageHandler.html:853,Error,Errors,853,root/html532/TMessageHandler.html,https://root.cern,https://root.cern/root/html532/TMessageHandler.html,2,['Error'],['Errors']
Availability,". TMessageHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TMessageHandler. class TMessageHandler: public TNamed, public TQObject. TMessageHandler. Handle messages that might be generated by the system.; By default a handler only keeps track of the different messages; generated for a specific class. By deriving from this class and; overriding Notify() one can implement custom message handling.; In Notify() one has access to the message id and the object; generating the message. One can install more than one message; handler per class. A message handler can be removed or again; added when needed.; All Root ""Warnings"" are logged as message 1001; All Root ""Errors"" are logged as message 1002; All Root ""SysErrors"" are logged as message 1003; All Root ""Fatals"" are logged as message 1004. Function Members (Methods); public:. virtual~TMessageHandler(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTNamed::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMessageHandler.html:853,Error,Errors,853,root/html602/TMessageHandler.html,https://root.cern,https://root.cern/root/html602/TMessageHandler.html,2,['Error'],['Errors']
Availability,". TMonaLisaText. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaText. class TMonaLisaText: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaText(const TMonaLisaText&); TMonaLisaText(const char* name, const char* text); virtual~TMonaLisaText(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* me",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaText.html:550,down,downloaded,550,root/html530/TMonaLisaText.html,https://root.cern,https://root.cern/root/html530/TMonaLisaText.html,6,['down'],"['download', 'downloaded']"
Availability,". TMonaLisaValue. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaValue. class TMonaLisaValue: public TNamed. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_cpp-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Function Members (Methods); public:. TMonaLisaValue(const char* name, Double_t value); virtual~TMonaLisaValue(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaValue.html:553,down,downloaded,553,root/html530/TMonaLisaValue.html,https://root.cern,https://root.cern/root/html530/TMonaLisaValue.html,6,['down'],"['download', 'downloaded']"
Availability,". TMonaLisaWriter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » MONALISA; » TMonaLisaWriter. class TMonaLisaWriter: public TVirtualMonitoringWriter. TMonaLisaWriter. Class defining interface to MonaLisa Monitoring Services in ROOT.; The TMonaLisaWriter object is used to send monitoring information to; a MonaLisa server using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:598,down,downloaded,598,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,6,['down'],"['download', 'downloaded']"
Availability,". TMutexImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TMutexImp. class TMutexImp: public TObject. TMutexImp. This class provides an abstract interface to the OS dependent mutex; classes (TPosixMutex and TWin32Mutex). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TMutexImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMutexImp.html:543,avail,available,543,root/html528/TMutexImp.html,https://root.cern,https://root.cern/root/html528/TMutexImp.html,10,['avail'],['available']
Availability,". TNDArray. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TNDArray. class TNDArray: public TObject. TNDArray. N-Dim array class. Storage layout:; Assume 3 dimensions, array sizes 2, 4 and 3 i.e. 24 bins:; Data is stored as [0,0,0], [0,0,1], [0,0,2], [0,1,0],... fSizes stores the combined size of each bin in a dimension, i.e. in; above example it would contain 24, 12, 3, 1. Storage is allocated lazily, only when data is written to the array. TNDArrayRef gives access to a sub-dimension, e.g. arr[0][1] in above; three-dimensional example, up to an element with conversion operator; to double: double value = arr[0][1][2];. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TNDArray(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddAt(ULong64_t linidx, Double_t value); virtual voidTObject::AppendPad(Option_t* option = """"); virtual Double_tAtAsDouble(ULong64_t linidx) const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNDArray.html:921,avail,available,921,root/html534/TNDArray.html,https://root.cern,https://root.cern/root/html534/TNDArray.html,6,['avail'],['available']
Availability,". TNewChainDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewChainDlg. class TNewChainDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TNewChainDlg(const TGWindow* p = 0, const TGWindow* main = 0); virtual~TNewChainDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNewChainDlg.html:425,avail,available,425,root/html528/TNewChainDlg.html,https://root.cern,https://root.cern/root/html528/TNewChainDlg.html,6,['avail'],['available']
Availability,". TNewChainDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewChainDlg. class TNewChainDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TNewChainDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNewChainDlg.html:425,avail,available,425,root/html602/TNewChainDlg.html,https://root.cern,https://root.cern/root/html602/TNewChainDlg.html,4,['avail'],['available']
Availability,". TNewQueryDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewQueryDlg. class TNewQueryDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TNewQueryDlg(TSessionViewer* gui, Int_t Width, Int_t Height, TQueryDescription* query = 0, Bool_t editmode = kFALSE); virtual~TNewQueryDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNewQueryDlg.html:425,avail,available,425,root/html528/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html528/TNewQueryDlg.html,6,['avail'],['available']
Availability,". TNewQueryDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TNewQueryDlg. class TNewQueryDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TNewQueryDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBuild(TSessionViewer* gui); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNewQueryDlg.html:425,avail,available,425,root/html602/TNewQueryDlg.html,https://root.cern,https://root.cern/root/html602/TNewQueryDlg.html,4,['avail'],['available']
Availability,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. TObject(); TObject(const TObject& object); virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:436,error,error,436,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,6,['error'],['error']
Availability,". TObject. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObject. class TObject. TObject. Mother of all ROOT objects. The TObject class provides default behaviour and protocol for all; objects in the ROOT system. It provides protocol for object I/O,; error handling, sorting, inspection, printing, drawing, etc.; Every object which inherits from TObject can be stored in the; ROOT collection classes.; TObject's bits can be used as flags, bits 0 - 13 and 24-31 are; reserved as global bits while bits 14 - 23 can be used in different; class hierarchies (watch out for overlaps). Function Members (Methods); public:. virtual~TObject(); voidAbstractMethod(const char* method) const; virtual voidAppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidCopy(TObject& object) const; virtual voidDelete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidDrawClass() constMENU ; virtual TObject*DrawClone(Option_t* option = """") constMENU ; virtual voidDump() constMENU ; virtual voidError(const char* method, const char* msgfmt) const; virtual voidExecute(const char* method, const char* params, Int_t* error = 0); virtual voidExecute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFatal(const char* method, const char* msgfmt) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual Option_t*GetDrawOption() const; static Long_tGetDtorOnly(); virtual const char*GetIconNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObject.html:436,error,error,436,root/html602/TObject.html,https://root.cern,https://root.cern/root/html602/TObject.html,4,['error'],['error']
Availability,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectRefSpy(TObject*& obj, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectRefSpy.html:621,error,error,621,root/html528/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html528/TObjectRefSpy.html,6,['error'],['error']
Availability,". TObjectRefSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectRefSpy. class TObjectRefSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectRefSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectRefSpy.html:621,error,error,621,root/html602/TObjectRefSpy.html,https://root.cern,https://root.cern/root/html602/TObjectRefSpy.html,4,['error'],['error']
Availability,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. TObjectSpy(TObject* obj = 0, Bool_t fixMustCleanupBit = kTRUE); virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObjectSpy.html:612,error,error,612,root/html528/TObjectSpy.html,https://root.cern,https://root.cern/root/html528/TObjectSpy.html,6,['error'],['error']
Availability,". TObjectSpy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TObjectSpy. class TObjectSpy: public TObject. TObjectSpy, TObjectRefSpy. Monitors objects for deletion and reflects the deletion by reverting; the internal pointer to zero. When this pointer is zero we know the; object has been deleted. This avoids the unsafe TestBit(kNotDeleted); hack. The spied object must have the kMustCleanup bit set otherwise; you will get an error. Function Members (Methods); public:. virtual~TObjectSpy(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TObjectSpy.html:612,error,error,612,root/html602/TObjectSpy.html,https://root.cern,https://root.cern/root/html602/TObjectSpy.html,4,['error'],['error']
Availability,". TOracleServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » SQL; » ORACLE; » TOracleServer. class TOracleServer: public TSQLServer. TOracleServer. This class implements an OCCI interface to Oracle data bases.; It uses the instantclient10 software available from Oracle.; To install this client software do:; 1) Download Instant Client Packages (4 files) from:; http://www.oracle.com/technology/software/tech/oci/instantclient/index.html; 2) Unzip the files into instantclient10_2 (Mac OS X example here):; unzip instantclient-basic-macosx-10.2.0.4.zip; unzip instantclient-sqlplus-macosx-10.2.0.4.zip; unzip instantclient-sdk-macosx-10.2.0.4.zip; unzip instantclient-jdbc-macosx-10.2.0.4.zip; 3) Create two symbolic links for the files that have the version; appended:; ln -s libclntsh.dylib.10.1 libclntsh.dylib; ln -s libocci.dylib.10.1 libocci.dylib; 4) Add instantclient10_1 directory to your (DY)LD_LIBRARY_PATH; in your .profile:; export (DY)LD_LIBRARY_PATH=""<pathto>/instantclient10_2""; Use DY only on Mac OS X.; 5) If you also want to use the sqlplus command line app add also; export SQLPATH=""<pathto>/instantclient10_2""; 6) If you want to connect to a remote db server you will also need; to create a tnsname.ora file which describes the local_name for; the remote db servers (at CERN most public machines have this; file in /etc). If it is not in /etc create TNS_ADMIN:; export TNS_ADMIN=""<path-to-dir-containing-tnsname.ora>""; 7) Test it our with the sqlplus command line app:; sqlplus [username][/password]@<local_name>; or; sqlplus [username][/password]@//[hostname][:port][/database]. Function Members (Methods); public:. TOracleServer(const TOracleServer&); TOracleServer(const char* db, const char* uid, const char* pw); virtual~TOracleServer(); voidTObject::AbstractMethod(const char* method) const; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TOracleServer.html:419,avail,available,419,root/html528/TOracleServer.html,https://root.cern,https://root.cern/root/html528/TOracleServer.html,1,['avail'],['available']
Availability,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. TParallelCoordVar(); TParallelCoordVar(const TParallelCoordVar&); TParallelCoordVar(Double_t* val, const char* title, Int_t id, TParallelCoord* gram); virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoordVar.html:866,avail,available,866,root/html530/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html530/TParallelCoordVar.html,10,['avail'],['available']
Availability,". TParallelCoordVar. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TParallelCoordVar. class TParallelCoordVar: public TNamed, public TAttLine, public TAttFill. Axes:. Class containing a variable for the TParallelCoord. Options can be defined each axis separatly using the right mouse click. These options can be applied to every axes using the editor. Axis width: If set to 0, the axis is simply a line. If higher, a color histogram is drawn on the axis.; Axis histogram height: If not 0, a usual bar histogram is drawn on the plot. The order in which the variables are drawn is essential to see the clusters. The axes can be dragged to change their position. A zoom is also available. The logarithm scale is also available by right clicking on the axis. Function Members (Methods); public:. virtual~TParallelCoordVar(); voidTObject::AbstractMethod(const char* method) const; voidAddRange()MENU ; voidAddRange(TParallelCoordRange* range); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; voidDeleteVariable()MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TParallelCoordVar.html:866,avail,available,866,root/html602/TParallelCoordVar.html,https://root.cern,https://root.cern/root/html602/TParallelCoordVar.html,8,['avail'],['available']
Availability,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters. Statistics Display; Fit Statistics; Statistics box editing. Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on (1 or 2), off (0). mode = ksiourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:771,error,error,771,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,24,['error'],['error']
Availability,". TPaveStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GRAF; » TPaveStats. class TPaveStats: public TPaveText. The histogram statistics painter class; A PaveStats is a PaveText to draw histogram statistics and fit parameters.; Statistics Display; The type of information shown in the histogram statistics box can be selected; with:. gStyle->SetOptStat(mode);. The ""mode"" has up to nine digits that can be set to on(1 or 2), off(0). mode = iourmen (default = 000001111); k = 1; kurtosis printed; k = 2; kurtosis and kurtosis error printed; s = 1; skewness printed; s = 2; skewness and skewness error printed; i = 1; integral of bins printed; o = 1; number of overflows printed; u = 1; number of underflows printed; r = 1; rms printed; r = 2; rms and rms error printed; m = 1; mean value printed; m = 2; mean and mean error values printed; e = 1; number of entries printed; n = 1; name of histogram is printed. For example:. gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewnes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPaveStats.html:708,error,error,708,root/html528/TPaveStats.html,https://root.cern,https://root.cern/root/html528/TPaveStats.html,16,['error'],['error']
Availability,". TPaveStatsEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TPaveStatsEditor. class TPaveStatsEditor: public TGedFrame. TPaveStatsEditor. Implements GUI for editing attributes of TPaveStats objects. //; all text attributes; The following statistics option settings can be set:; name, mean, RMS, overflow, underflow, integral of bins,; Fit parameters that can be set are: Values/Names, Probability,; Errors, Chisquare. /*. */. Function Members (Methods); public:. TPaveStatsEditor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()); virtual~TPaveStatsEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPaveStatsEditor.html:588,Error,Errors,588,root/html532/TPaveStatsEditor.html,https://root.cern,https://root.cern/root/html532/TPaveStatsEditor.html,2,['Error'],['Errors']
Availability,". TPaveStatsEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TPaveStatsEditor. class TPaveStatsEditor: public TGedFrame. TPaveStatsEditor. Implements GUI for editing attributes of TPaveStats objects. //; all text attributes; The following statistics option settings can be set:; name, mean, RMS, overflow, underflow, integral of bins,; Fit parameters that can be set are: Values/Names, Probability,; Errors, Chisquare. /*. */. Function Members (Methods); public:. virtual~TPaveStatsEditor(); voidTObject::AbstractMethod(const char* method) const; virtual Bool_tTGedFrame::AcceptModel(TObject*); virtual voidTGFrame::Activate(Bool_t); virtual voidTGedFrame::ActivateBaseClassEditors(TClass* cl); virtual voidTGedFrame::AddExtraTab(TGedFrame::TGedSubFrame* sf); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPaveStatsEditor.html:588,Error,Errors,588,root/html602/TPaveStatsEditor.html,https://root.cern,https://root.cern/root/html602/TPaveStatsEditor.html,2,['Error'],['Errors']
Availability,". TPoints3DABC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF3D; » G3D; » TPoints3DABC. class TPoints3DABC: public TObject. The TPoints3DABC class; Abstract class to define Arrays of 3D points.; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TPoints3DABC(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAdd(Float_t x, Float_t y, Float_t z); virtual Int_tAddLast(Float_t x, Float_t y, Float_t z); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; static Int_tDistancetoLine(Int_t px, Int_t py, Float_t x1, Float_t y1, Float_t x2, Float_t y2, Int_t lineWidth = 1); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObje",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPoints3DABC.html:505,avail,available,505,root/html528/TPoints3DABC.html,https://root.cern,https://root.cern/root/html528/TPoints3DABC.html,10,['avail'],['available']
Availability,". TProfile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TProfile. class TProfile: public TH1D. Profile histograms are used to display the mean; value of Y and its error for each bin in X. The displayed error is by default the; standard error on the mean (i.e. the standard deviation divided by the sqrt(n) ); Profile histograms are in many cases an; elegant replacement of two-dimensional histograms : the inter-relation of two; measured quantities X and Y can always be visualized by a two-dimensional; histogram or scatter-plot; its representation on the line-printer is not particularly; satisfactory, except for sparse data. If Y is an unknown (but single-valued); approximate function of X, this function is displayed by a profile histogram with; much better precision than by a scatter-plot. The following formulae show the cumulated contents (capital letters) and the values; displayed by the printing or plotting routines (small letters) of the elements for bin J. 2; H(J) = sum Y E(J) = sum Y; l(J) = sum l L(J) = sum l; h(J) = H(J)/L(J) mean of Y,; s(J) = sqrt(E(J)/L(J)- h(J)**2) standard deviation of Y (e.g. RMS); e(J) = s(J)/sqrt(L(J)) standard error on the mean. The displayed bin content for bin J of a TProfile is always h(J). The corresponding bin error is by default; e(J). In case the option ""s"" is used (in the constructor or by calling TProfile::BuildOptions); the displayed error is s(J). In the special case where s(J) is zero (eg, case of 1 entry only in one bin); the bin error e(J) is computed from the average of the s(J) for all bins if; the static function TProfile::Approximate has been called.; This simple/crude approximation was suggested in order to keep the bin; during a fit operation. But note that this approximation is not the default behaviour.; See also TProfile::BuildOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:350,error,error,350,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,18,['error'],['error']
Availability,". TProofBenchRun. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFBENCH; » TProofBenchRun. class TProofBenchRun: public TObject. TProofBenchRun. Abstract base class for PROOF benchmark run. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofBenchRun(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRun.html:505,avail,available,505,root/html530/TProofBenchRun.html,https://root.cern,https://root.cern/root/html530/TProofBenchRun.html,9,['avail'],['available']
Availability,". TProofDraw. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofDraw. class TProofDraw: public TSelector. TProofDraw. Implement Tree drawing using PROOF. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofDraw(); virtual voidTSelector::Abort(const char* why, TSelector::EAbort what = kAbortProcess); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBegin(TTree*); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TSelector::EAbortTSelector::GetAbort() const; virtual Option_t*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofDraw.html:483,avail,available,483,root/html528/TProofDraw.html,https://root.cern,https://root.cern/root/html528/TProofDraw.html,10,['avail'],['available']
Availability,". TProofMonSender. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofMonSender. class TProofMonSender: public TNamed. TProofMonSender. Provides the interface for PROOF monitoring to different writers.; Allows to decouple the information sent from the backend. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofMonSender(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofMonSender.html:565,avail,available,565,root/html532/TProofMonSender.html,https://root.cern,https://root.cern/root/html532/TProofMonSender.html,4,['avail'],['available']
Availability,". TProofMonSender. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TProofMonSender. class TProofMonSender: public TNamed. TProofMonSender. Provides the interface for PROOF monitoring to different writers.; Allows to decouple the information sent from the backend. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofMonSender(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofMonSender.html:589,avail,available,589,root/html602/TProofMonSender.html,https://root.cern,https://root.cern/root/html602/TProofMonSender.html,4,['avail'],['available']
Availability,". TProofResources. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResources. class TProofResources: public TObject. TProofResources. Abstract base class for PROOF resources.; The class contains common method declarations for derived classes; such as TProofResourcesStatic which reads and interprets static; config files, and returns master, submaster and worker information; using TProofNodeInfo objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofResources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofResources.html:705,avail,available,705,root/html528/TProofResources.html,https://root.cern,https://root.cern/root/html528/TProofResources.html,1,['avail'],['available']
Availability,". TProofResources. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TProofResources. class TProofResources: public TObject. TProofResources. Abstract base class for PROOF resources.; The class contains common method declarations for derived classes; such as TProofResourcesStatic which reads and interprets static; config files, and returns master, submaster and worker information; using TProofNodeInfo objects. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TProofResources(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofResources.html:707,avail,available,707,root/html530/TProofResources.html,https://root.cern,https://root.cern/root/html530/TProofResources.html,9,['avail'],['available']
Availability,". TPythia8. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » PYTHIA8; » TPythia8. class TPythia8: public TGenerator. TPythia8. TPythia is an interface class to C++ version of Pythia 8.1; event generators, written by T.Sjostrand. The user is assumed to be familiar with the Pythia package.; This class includes only a basic interface to Pythia8. Because Pythia8 is; also written in C++, its functions/classes can be called directly from a; compiled C++ script.; To call Pythia functions not available in this interface a dictionary must; be generated.; see $ROOTSYS/tutorials/pythia/pythia8.C for an example of use from CINT. | |; | *------------------------------------------------------------------------------* |; | | | |; | | | |; | | PPP Y Y TTTTT H H III A Welcome to the Lund Monte Carlo! | |; | | P P Y Y T H H I A A This is PYTHIA version 8.100 | |; | | PPP Y T HHHHH I AAAAA Last date of change: 20 Oct 2007 | |; | | P Y T H H I A A | |; | | P Y T H H III A A Now is 27 Oct 2007 at 18:26:53 | |; | | | |; | | Main author: Torbjorn Sjostrand; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Department of Theoretical Physics, Lund University, Lund, Sweden; | |; | | phone: + 41 - 22 - 767 82 27; e-mail: torbjorn@thep.lu.se | |; | | Author: Stephen Mrenna; Computing Division, Simulations Group, | |; | | Fermi National Accelerator Laboratory, MS 234, Batavia, IL 60510, USA; | |; | | phone: + 1 - 630 - 840 - 2556; e-mail: mrenna@fnal.gov | |; | | Author: Peter Skands; CERN/PH, CH-1211 Geneva, Switzerland, | |; | | and Theoretical Physics Department, | |; | | Fermi National Accelerator Laboratory, MS 106, Batavia, IL 60510, USA; | |; | | phone: + 41 - 22 - 767 24 59; e-mail: skands@fnal.gov | |; | | | |; | | The main program reference is the 'Brief Introduction to PYTHIA 8.1', | |; | | T. Sjostrand, S.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPythia8.html:670,avail,available,670,root/html528/TPythia8.html,https://root.cern,https://root.cern/root/html528/TPythia8.html,10,['avail'],['available']
Availability,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQCommand.html:843,down,downwards,843,root/html602/TQCommand.html,https://root.cern,https://root.cern/root/html602/TQCommand.html,4,['down'],['downwards']
Availability,". TQCommand. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQCommand. class TQCommand: public TList, public TQObject. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQCommand.html:819,down,downwards,819,root/html528/TQCommand.html,https://root.cern,https://root.cern/root/html528/TQCommand.html,6,['down'],['downwards']
Availability,". TQObject. ←; TXMLParser. ←; TSAXParser. Function documentation; TSAXParser(); Create SAX parser. ~TSAXParser(); TSAXParser desctructor. void OnStartDocument(); Emit a signal for OnStartDocument. void OnEndDocument(); Emit a signal for OnEndDocument. void OnStartElement(const char* name, const TList* attr); Emit a signal for OnStarElement, where name is the Element's name and; attribute is a TList of (TObjString*, TObjString *) TPair's.; The TPair's key is the attribute's name and value is the attribute's; value. void OnEndElement(const char* name); Emit a signal for OnEndElement, where name is the Element's name. void OnCharacters(const char* characters); Emit a signal for OnCharacters, where characters are the characters; outside of tags. void OnComment(const char* text); Emit a signal for OnComment, where text is the comment. void OnWarning(const char* text); Emit a signal for OnWarning, where text is the warning. Int_t OnError(const char* text); Emit a signal for OnError, where text is the error and it returns the; Parse Error Code, see TXMLParser. Int_t OnFatalError(const char* text); Emit a signal for OnFactalError, where text is the error and it; returns the Parse Error Code, see TXMLParser. void OnCdataBlock(const char* text, Int_t len); Emit a signal for OnCdataBlock. Int_t Parse(); This function parses the xml file, by initializing the parser and checks; whether the parse context is created or not, it will check as well; whether the document is well formated.; It returns the parse error code, see TXMLParser. Int_t ParseFile(const char* filename); It creates the parse context of the xml file, where the xml file name is; filename. If context is created sucessfully, it will call Parse(); It returns parse error code, see TXMLParser. Int_t ParseBuffer(const char* contents, Int_t len); It parse the contents, instead of a file.; It will return error if is attempted to parse a second file while; a parse is in progres.; It returns parse code error, see TXMLParser.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSAXParser.html:12602,error,error,12602,root/html602/TSAXParser.html,https://root.cern,https://root.cern/root/html602/TSAXParser.html,6,"['Error', 'error']","['Error', 'error']"
Availability,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootApplication.h 32344 2010-02-15 16:15:57Z bellenot $ » Last generated: 2010-09-23 20:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQRootApplication.html:1249,error,error,1249,root/html528/TQRootApplication.html,https://root.cern,https://root.cern/root/html528/TQRootApplication.html,1,['error'],['error']
Availability,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id: TQRootApplication.h 32344 2010-02-15 16:15:57Z bellenot $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQRootApplication.html:1249,error,error,1249,root/html532/TQRootApplication.html,https://root.cern,https://root.cern/root/html532/TQRootApplication.html,2,['error'],['error']
Availability,". TQRootApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » QTGSI; » TQRootApplication. class TQRootApplication: public QApplication. Function Members (Methods); public:. TQRootApplication(int& argc, char** argv, int poll = 0); ~TQRootApplication(); static TClass*Class(); voidExecute(); virtual TClass*IsA() const; voidQuit(); voidSetDebugOn(); voidSetWarningOn(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). private:. TQRootApplication(const TQRootApplication&); TQRootApplication&operator=(const TQRootApplication&). Data Members; public:. static Bool_tfgDebug; static Bool_tfgWarningdebug and warning flags. protected:. QTimer*fQTimerQt timer that poll the event loop of ROOT; TTimer*fRTimerRoot timer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQRootApplication(int& argc, char** argv, int poll = 0); Connect ROOT via Timer call back. ~TQRootApplication(); dtor. void Execute(); Call the inner loop of ROOT. void Quit(); Set a Qt-Specific error handler. TQRootApplication(const TQRootApplication& ). TQRootApplication& operator=(const TQRootApplication& ). void SetDebugOn(); { fgDebug=kTRUE; }. void SetWarningOn(); { fgWarning=kTRUE;}. » Author: Denis Bertini, M. AL-Turany 01/11/2000 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/qtgsi:$Id$ » Last generated: 2015-03-14 16:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TQRootApplication.html:1268,error,error,1268,root/html534/TQRootApplication.html,https://root.cern,https://root.cern/root/html534/TQRootApplication.html,2,['error'],['error']
Availability,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQUndoManager.html:842,down,downwards,842,root/html602/TQUndoManager.html,https://root.cern,https://root.cern/root/html602/TQUndoManager.html,4,['down'],['downwards']
Availability,". TQUndoManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TQUndoManager. class TQUndoManager: public TQCommand. The Command design pattern is based on the idea, that all editing; in an application is done by creating instances of command objects.; Command objects apply changes to the edited object and then are; stored on a command stack. Furthermore, each command knows how to; undo its changes to bring the edited object back to its previous; state. As long as the application only uses command objects to; change the state of the edited object, it is possible to undo; a sequence of commands by traversing the command stack downwards and; calling the ""undo"" method of each command in turn. It is also; possible to redo a sequence of commands by traversing the command; stack upwards and calling the ""redo"" method of each command. Examples:. 1. Create a new command. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)""; ""SetFillColor(Color_t)"");. 1st parameter - the name of class; 2nd parameter - object; 3rd parameter - the name of do/redo method; 4th parameter - the name of undo method. Since redo,undo methods are the same, undo name can be omitted, e.g. TQCommand *com = new TQCommand(""TH1"", hpx, ""SetFillColor(Color_t)"");. For objects derived from TObject class name can be omitted, e.g. TQCommand *com = new TQCommand(hpx, ""SetFillColor(Color_t)"");. 2. Setting undo, redo parameters. Color_t old_color = hpx->GetFillColor();; Color_t new_color = 4; // blue color. com->SetRedoArgs(1, new_color);; com->SetUndoArgs(1, old_color);. 1st argument - the number of undo, redo parameters; the other arguments - undo, redo values. Since the number of undo,redo parameters is the same one can use. com->SetArgs(1, new_color, old_color);. 3. Undo, redo method execution. com->Redo(); // execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQUndoManager.html:818,down,downwards,818,root/html528/TQUndoManager.html,https://root.cern,https://root.cern/root/html528/TQUndoManager.html,6,['down'],['downwards']
Availability,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpDataBase.html:939,avail,available,939,root/html602/TQpDataBase.html,https://root.cern,https://root.cern/root/html602/TQpDataBase.html,4,['avail'],['available']
Availability,". TQpDataBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpDataBase. class TQpDataBase: public TObject. TQpDataBase. Data for the general QP formulation. The Data class stores the data defining the problem and provides; methods for performing the operations with this data required by; the interior-point algorithms. These operations include assembling; the linear systems (5) or (7), performing matrix-vector operations; with the data, calculating norms of the data, reading input into the; data structure from various sources, generating random problem; instances, and printing the data. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpDataBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidAmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidATransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidCTransmult(Double_t beta, TVectorD& y, Double_t alpha, const TVectorD& x); virtual Double_tDataNorm(); virtual voidDataRandom(TVectorD& x, TVectorD& y, TVectorD& z, TVectorD& s); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpDataBase.html:915,avail,available,915,root/html528/TQpDataBase.html,https://root.cern,https://root.cern/root/html528/TQpDataBase.html,6,['avail'],['available']
Availability,". TQpLinSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpLinSolverBase. class TQpLinSolverBase: public TObject. TQpLinSolverBase. Implementation of main solver for linear systems. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpLinSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpLinSolverBase.html:536,avail,available,536,root/html602/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpLinSolverBase.html,4,['avail'],['available']
Availability,". TQpLinSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpLinSolverBase. class TQpLinSolverBase: public TObject. TQpLinSolverBase. Implementation of main solver for linear systems. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpLinSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidComputeDiagonals(TVectorD& dd, TVectorD& omega, TVectorD& t, TVectorD& lambda, TVectorD& u, TVectorD& pi, TVectorD& v, TVectorD& gamma, TVectorD& w, TVectorD& phi); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidFactor(TQpDataBase* prob, TQpVar* vars); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpLinSolverBase.html:512,avail,available,512,root/html528/TQpLinSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpLinSolverBase.html,6,['avail'],['available']
Availability,". TQpProbBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpProbBase. class TQpProbBase: public TObject. TQpProbBase. default general problem formulation:. minimize c' x + ( 1/2 ) x' * Q x ;; subject to A x = b ;; clo <= C x <= cup ;; xlo <= x <= xup ;. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpProbBase.html:602,avail,available,602,root/html602/TQpProbBase.html,https://root.cern,https://root.cern/root/html602/TQpProbBase.html,4,['avail'],['available']
Availability,". TQpProbBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpProbBase. class TQpProbBase: public TObject. TQpProbBase. default general problem formulation:. minimize c' x + ( 1/2 ) x' * Q x ;; subject to A x = b ;; clo <= C x <= cup ;; xlo <= x <= xup ;. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpProbBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpProbBase.html:578,avail,available,578,root/html528/TQpProbBase.html,https://root.cern,https://root.cern/root/html528/TQpProbBase.html,6,['avail'],['available']
Availability,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQpSolverBase.html:745,avail,available,745,root/html602/TQpSolverBase.html,https://root.cern,https://root.cern/root/html602/TQpSolverBase.html,4,['avail'],['available']
Availability,". TQpSolverBase. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » QUADP; » TQpSolverBase. class TQpSolverBase: public TObject. TSolverBase. The Solver class contains methods for monitoring and checking the; convergence status of the algorithm, methods to determine the step; length along a given direction, methods to define the starting point,; and the solve method that implements the interior-point algorithm. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TQpSolverBase(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; Double_tDataNorm(); virtual voidDefMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual voidDefStart(TQpProbBase* formulation, TQpVar* iterate, TQpDataBase* prob, TQpResidual* resid, TQpVar* step); virtual Int_tDefStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Double_t mu, Int_t level); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDoMonitor(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Double_t alpha, Double_t sigma, Int_t i, Double_t mu, Int_t stop_code, Int_t level); virtual Int_tDoStatus(TQpDataBase* data, TQpVar* vars, TQpResidual* resids, Int_t i, Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TQpSolverBase.html:721,avail,available,721,root/html528/TQpSolverBase.html,https://root.cern,https://root.cern/root/html528/TQpSolverBase.html,6,['avail'],['available']
Availability,". TRandom2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom2. class TRandom2: public TRandom. TRandom2. Random number generator class based on the maximally quidistributed combined; Tausworthe generator by L'Ecuyer. The period of the generator is 2**88 (about 10**26) and it uses only 3 words; for the state. For more information see:; P. L'Ecuyer, Mathematics of Computation, 65, 213 (1996); P. L'Ecuyer, Mathematics of Computation, 68, 225 (1999). The publication are available online at; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps. Function Members (Methods); public:. virtual~TRandom2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRandom2.html:689,avail,available,689,root/html602/TRandom2.html,https://root.cern,https://root.cern/root/html602/TRandom2.html,4,['avail'],['available']
Availability,". TRandom2. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TRandom2. class TRandom2: public TRandom. TRandom2. Random number generator class based on the maximally quidistributed combined; Tausworthe generator by L'Ecuyer. The period of the generator is 2**88 (about 10**26) and it uses only 3 words; for the state. For more information see:; P. L'Ecuyer, Mathematics of Computation, 65, 213 (1996); P. L'Ecuyer, Mathematics of Computation, 68, 225 (1999). The publication are available online at; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme.ps; http://www.iro.umontreal.ca/~lecuyer/myftp/papers/tausme2.ps. Function Members (Methods); public:. TRandom2(UInt_t seed = 1); TRandom2(const TRandom2&); virtual~TRandom2(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual Int_tTRandom::Binomial(Int_t ntot, Double_t prob); virtual Double_tTRandom::BreitWigner(Double_t mean = 0, Double_t gamma = 1); virtual voidTObject::Browse(TBrowser* b); virtual voidTRandom::Circle(Double_t& x, Double_t& y, Double_t r); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRandom2.html:665,avail,available,665,root/html528/TRandom2.html,https://root.cern,https://root.cern/root/html528/TRandom2.html,6,['avail'],['available']
Availability,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRobustEstimator.html:591,robust,robust,591,root/html602/TRobustEstimator.html,https://root.cern,https://root.cern/root/html602/TRobustEstimator.html,12,['robust'],"['robust', 'robustness']"
Availability,". TRobustEstimator. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » PHYSICS; » TRobustEstimator. class TRobustEstimator: public TObject. TRobustEstimator. Minimum Covariance Determinant Estimator - a Fast Algorithm; invented by Peter J.Rousseeuw and Katrien Van Dreissen; ""A Fast Algorithm for the Minimum covariance Determinant Estimator""; Technometrics, August 1999, Vol.41, NO.3. What are robust estimators?; ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recongize them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected.""; R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz; ""Data Analysis Techniques for High-Energy Physics"", 2nd edition. What does this algorithm do?; It computes a highly robust estimator of multivariate location and scatter.; Then, it takes those estimates to compute robust distances of all the; data vectors. Those with large robust distances are considered outliers.; Robust distances can then be plotted for better visualization of the data. How does this algorithm do it?; The MCD objective is to find h observations(out of n) whose classical; covariance matrix has the lowest determinant. The MCD estimator of location; is then the average of those h points and the MCD estimate of scatter; is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2; so the algorithm is ef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRobustEstimator.html:567,robust,robust,567,root/html528/TRobustEstimator.html,https://root.cern,https://root.cern/root/html528/TRobustEstimator.html,18,['robust'],"['robust', 'robustness']"
Availability,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. TRootAuth(); TRootAuth(const TRootAuth&); virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootAuth(); { }. virtual ~TRootAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"). void ErrorMsg(const char* where, Int_t ecode = -1). const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id: TRootAuth.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootAuth.html:1120,Error,ErrorMsg,1120,root/html532/TRootAuth.html,https://root.cern,https://root.cern/root/html532/TRootAuth.html,1,['Error'],['ErrorMsg']
Availability,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. TRootAuth(); TRootAuth(const TRootAuth&); virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TRootAuth(); { }. virtual ~TRootAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"). void ErrorMsg(const char* where, Int_t ecode = -1). const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootAuth.html:1139,Error,ErrorMsg,1139,root/html534/TRootAuth.html,https://root.cern,https://root.cern/root/html534/TRootAuth.html,1,['Error'],['ErrorMsg']
Availability,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootAuth(); TRootAuth(const TRootAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. ←; TRootAuth. Function documentation; TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"); Runs authentication on socket s.; Invoked when dynamic loading is needed.; Returns 1 on success, 0 on failure. Int_t ClientVersion(); Return client version;. void ErrorMsg(const char* where, Int_t ecode = -1); Print error string corresponding to ecode, prepending location. TRootAuth(); { }. virtual ~TRootAuth(); { }. const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootAuth.html:1245,failure,failure,1245,root/html602/TRootAuth.html,https://root.cern,https://root.cern/root/html602/TRootAuth.html,5,"['Error', 'error', 'failure']","['ErrorMsg', 'error', 'failure']"
Availability,". TRootAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » AUTH; » TRootAuth. class TRootAuth: public TVirtualAuth. TRootAuth. TVirtualAuth implementation based on the old client authentication; code. Function Members (Methods); public:. virtual~TRootAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options = """"); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode = -1); virtual TClass*IsA() const; virtual const char*Name(); TRootAuth&operator=(const TRootAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TRootAuth(); TRootAuth(const TRootAuth&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options = """"); Runs authentication on socket s.; Invoked when dynamic loading is needed.; Returns 1 on success, 0 on failure. Int_t ClientVersion(); Return client version;. void ErrorMsg(const char* where, Int_t ecode = -1); Print error string corresponding to ecode, prepending location. TRootAuth(); { }. virtual ~TRootAuth(); { }. const char * Name(); { return ""Root""; }. » Author: Gerardo Ganis 08/07/05 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/auth:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootAuth.html:1226,failure,failure,1226,root/html604/TRootAuth.html,https://root.cern,https://root.cern/root/html604/TRootAuth.html,5,"['Error', 'error', 'failure']","['ErrorMsg', 'error', 'failure']"
Availability,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootContextMenu.html:545,down,downs,545,root/html602/TRootContextMenu.html,https://root.cern,https://root.cern/root/html602/TRootContextMenu.html,2,['down'],['downs']
Availability,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. TRootContextMenu(TContextMenu* c = 0, const char* name = ""ROOT Context Menu""); virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootContextMenu.html:521,down,downs,521,root/html528/TRootContextMenu.html,https://root.cern,https://root.cern/root/html528/TRootContextMenu.html,6,['down'],['downs']
Availability,". TRootContextMenu. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TRootContextMenu. class TRootContextMenu: public TGPopupMenu, public TContextMenuImp. TRootContextMenu. This class provides an interface to context sensitive popup menus.; These menus pop up when the user hits the right mouse button, and; are destroyed when the menu pops downs.; The picture below shows a canvas with a pop-up menu. ; . The picture below shows a canvas with a pop-up menu and a dialog box. ; . Function Members (Methods); public:. virtual~TRootContextMenu(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGPopupMenu::Activate(Bool_t); virtual voidTGPopupMenu::Activate(TGMenuEntry* entry); virtual voidTGPopupMenu::Activated(Int_t id)SIGNAL ; virtual voidTGPopupMenu::AddEntry(TGHotString* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddEntry(const char* s, Int_t id, void* ud = 0, const TGPicture* p = 0, TGMenuEntry* before = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTGPopupMenu::AddLabel(TGHotString* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddLabel(const char* s, const TGPicture* p = 0, TGMenuEntry* before = 0); virtual voidTGPopupMenu::AddPopup(TGHotString* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddPopup(const char* s, TGPopupMenu* popup, TGMenuEntry* before = 0, const TGPicture* p = 0); virtual voidTGPopupMenu::AddSeparator(TGMenuEntry* before = 0); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGPopupMenu::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootContextMenu.html:521,down,downs,521,root/html604/TRootContextMenu.html,https://root.cern,https://root.cern/root/html604/TRootContextMenu.html,2,['down'],['downs']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-10-29 07:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TRootIOCtor.html:663,avail,available,663,root/html528/TRootIOCtor.html,https://root.cern,https://root.cern/root/html528/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&); TRootIOCtor&operator=(TRootIOCtor&&); TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); TRootIOCtor(TRootIOCtor&&). Class Charts. Inheritance Chart:. TRootIOCtor. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TRootIOCtor.html:689,avail,available,689,root/html602/TRootIOCtor.html,https://root.cern,https://root.cern/root/html602/TRootIOCtor.html,2,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TRootIOCtor.html:665,avail,available,665,root/html534/TRootIOCtor.html,https://root.cern,https://root.cern/root/html534/TRootIOCtor.html,2,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TRootIOCtor.html:665,avail,available,665,root/html530/TRootIOCtor.html,https://root.cern,https://root.cern/root/html530/TRootIOCtor.html,1,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TRootIOCtor.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TRootIOCtor.html:665,avail,available,665,root/html532/TRootIOCtor.html,https://root.cern,https://root.cern/root/html532/TRootIOCtor.html,2,['avail'],['available']
Availability,". TRootIOCtor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TRootIOCtor. class TRootIOCtor. TRootIOCtor. Helper class used to mark a constructor to be used by ROOT instead; of the default constructor.; If rootcint sees in a class declaration of the class MyClass:; MyClass(TRootIOCtor*);; This constructor will be used instead of the default constructor. Also the pragma:; #pragma link C++ ioctortype MyMarker;; can be used to tell rootcint that a constuctor taking a MyMarker*; should be used whenever available. Function Members (Methods); public:. ~TRootIOCtor(); TRootIOCtor&operator=(const TRootIOCtor&); TRootIOCtor&operator=(TRootIOCtor&&); TRootIOCtor(); TRootIOCtor(const TRootIOCtor&); TRootIOCtor(TRootIOCtor&&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Author: Philippe Canal 15/03/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TRootIOCtor.html:665,avail,available,665,root/html604/TRootIOCtor.html,https://root.cern,https://root.cern/root/html604/TRootIOCtor.html,2,['avail'],['available']
Availability,". TSPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SPLOT; » TSPlot. class TSPlot: public TObject. . Overview. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF).; To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any a priori knowledge on this; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sampl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSPlot.html:541,reliab,reliable,541,root/html602/TSPlot.html,https://root.cern,https://root.cern/root/html602/TSPlot.html,4,['reliab'],['reliable']
Availability,". TSPlot. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » SPLOT; » TSPlot. class TSPlot: public TObject. . Overview. A common method used in High Energy Physics to perform measurements is; the maximum Likelihood method, exploiting discriminating variables to; disentangle signal from background. The crucial point for such an; analysis to be reliable is to use an exhaustive list of sources of; events combined with an accurate description of all the Probability; Density Functions (PDF).; To assess the validity of the fit, a convincing quality check; is to explore further the data sample by examining the distributions of; control variables. A control variable can be obtained for instance by; removing one of the discriminating variables before performing again; the maximum Likelihood fit: this removed variable is a control; variable. The expected distribution of this control variable, for; signal, is to be compared to the one extracted, for signal, from the; data sample. In order to be able to do so, one must be able to unfold; from the distribution of the whole data sample.; The TSPlot method allows to reconstruct the distributions for; the control variable, independently for each of the various sources of; events, without making use of any a priori knowledge on this; variable. The aim is thus to use the knowledge available for the; discriminating variables to infer the behaviour of the individual; sources of events with respect to the control variable. TSPlot is optimal if the control variable is uncorrelated with the discriminating variables. A detail description of the formalism itself, called ; , is given in [1]. The method. The ; technique is developped in the above context of a maximum Likelihood method making use of discriminating variables.; One considers a data sample in which are merged se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSPlot.html:517,reliab,reliable,517,root/html528/TSPlot.html,https://root.cern,https://root.cern/root/html528/TSPlot.html,6,['reliab'],['reliable']
Availability,". TSQLResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLResult. class TSQLResult: public TObject. TSQLResult. Abstract base class defining interface to a SQL query result.; Objects of this class are created by TSQLServer methods. Related classes are TSQLServer and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLResult.html:623,avail,available,623,root/html602/TSQLResult.html,https://root.cern,https://root.cern/root/html602/TSQLResult.html,4,['avail'],['available']
Availability,". TSQLResult. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLResult. class TSQLResult: public TObject. TSQLResult. Abstract base class defining interface to a SQL query result.; Objects of this class are created by TSQLServer methods. Related classes are TSQLServer and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLResult(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLResult.html:599,avail,available,599,root/html528/TSQLResult.html,https://root.cern,https://root.cern/root/html528/TSQLResult.html,6,['avail'],['available']
Availability,". TSQLRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLRow. class TSQLRow: public TObject. TSQLRow. Abstract base class defining interface to a row of a SQL query; result. Objects of this class are created by TSQLResult methods. Related classes are TSQLServer and TSQLResult. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLRow.html:623,avail,available,623,root/html602/TSQLRow.html,https://root.cern,https://root.cern/root/html602/TSQLRow.html,4,['avail'],['available']
Availability,". TSQLRow. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLRow. class TSQLRow: public TObject. TSQLRow. Abstract base class defining interface to a row of a SQL query; result. Objects of this class are created by TSQLResult methods. Related classes are TSQLServer and TSQLResult. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLRow(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLRow.html:599,avail,available,599,root/html528/TSQLRow.html,https://root.cern,https://root.cern/root/html528/TSQLRow.html,6,['avail'],['available']
Availability,". TSQLServer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NET; » TSQLServer. class TSQLServer: public TObject. TSQLServer. Abstract base class defining interface to a SQL server. To open a connection to a server use the static method Connect().; The db argument of Connect() is of the form:; <dbms>://<host>[:<port>][/<database>], e.g.; mysql://pcroot.cern.ch:3456/test, oracle://srv1.cern.ch/main, ...; Depending on the <dbms> specified an appropriate plugin library; will be loaded which will provide the real interface. Related classes are TSQLResult and TSQLRow. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSQLServer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual Bool_tCommit(); virtual Int_tTObject::Compare(const TObject* obj) const; static TSQLServer*Connect(const char* db, const char* uid, const char* pw); virtual voidTObject::Copy(TObject& object) const; virtual Int_tCreateDataBase(const char* dbname); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Int_tDropDataBase(const char* dbname); virtual voidTObject::Dump() constMENU ; virtual voidEnableErrorOutput(Bool_t on = kTRUE); virtual voidTObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSQLServer.html:879,avail,available,879,root/html528/TSQLServer.html,https://root.cern,https://root.cern/root/html528/TSQLServer.html,4,['avail'],['available']
Availability,". TSVDUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSVDUnfold. class TSVDUnfold: public TObject. SVD Approach to Data Unfolding. Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307]. TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum.; ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition.; ; Monte Carlo inputs:; ; xini: true underlying spectrum (TH1D, n bins); bini: reconstructed spectrum (TH1D, n bins); Adet: response matrix (TH2D, nxn bins); ; Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis.; ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by; . TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; . where kreg determines the regularisation of the unfolding. In general, overregularisation (too small kreg) will bias the unfolded spectrum towards the Monte Carlo input, while underregularisation (too large kreg) will lead to large fluctuation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSVDUnfold.html:1126,error,errors,1126,root/html534/TSVDUnfold.html,https://root.cern,https://root.cern/root/html534/TSVDUnfold.html,2,['error'],['errors']
Availability,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; TIterTCollection::begin() const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSeqCollection.html:611,avail,available,611,root/html602/TSeqCollection.html,https://root.cern,https://root.cern/root/html602/TSeqCollection.html,4,['avail'],['available']
Availability,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TCollection::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSeqCollection.html:587,avail,available,587,root/html530/TSeqCollection.html,https://root.cern,https://root.cern/root/html530/TSeqCollection.html,5,['avail'],['available']
Availability,". TSeqCollection. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TSeqCollection. class TSeqCollection: public TCollection. TSeqCollection. Sequenceable collection abstract base class. TSeqCollection's have; an ordering relation, i.e. there is a first and last element. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSeqCollection(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TObject* obj); virtual voidAddAfter(const TObject* after, TObject* obj); virtual voidTCollection::AddAll(const TCollection* col); virtual voidAddAt(TObject* obj, Int_t idx); virtual voidAddBefore(const TObject* before, TObject* obj); virtual voidAddFirst(TObject* obj); virtual voidAddLast(TObject* obj); voidTCollection::AddVector(TObject* obj1); virtual TObject*After(const TObject* obj) const; virtual voidTObject::AppendPad(Option_t* option = """"); Bool_tTCollection::AssertClass(TClass* cl) const; virtual TObject*At(Int_t idx) const; virtual TObject*Before(const TObject* obj) const; virtual voidTCollection::Browse(TBrowser* b); Int_tTCollection::Capacity() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTCollection::Clear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTCollection::Compare(const TObject* obj) const; Bool_tTCollection::Contains(const char* name) const; Bool_tTCollection::Contains(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTCollection::Delete(Option_t* option = """"); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTCollection::Draw(Option_t* option = """"); virtual voidTObject::DrawClass(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSeqCollection.html:587,avail,available,587,root/html528/TSeqCollection.html,https://root.cern,https://root.cern/root/html528/TSeqCollection.html,1,['avail'],['available']
Availability,". TSpider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TSpider. class TSpider: public TObject, public TAttFill, public TAttLine. Spider class; A spider view is a handy way to visualize a set of data stored in a TTree. It draws as; many polar axes as selected data members. For each of them, it draws on the axis; the position of the present event between the min and max of the data member.; Two modes are availables:. The spider view: With each points on the axes is drawn a polyline.; The segment view: For each data member is drawn an arc segment with the radius corresponding to the event. The spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = (TNtuple*)f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString selectStr = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),selectStr.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }. Function Members (Methods); public:. virtual~TSpider(); voidTObject::AbstractMethod(const char* method) const; voidAddSuperposed(TSpider* sp); voidAddVariable(const char* varexp)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpider.html:623,avail,availables,623,root/html602/TSpider.html,https://root.cern,https://root.cern/root/html602/TSpider.html,8,['avail'],"['available', 'availables']"
Availability,". TSpider. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEVIEWER; » TSpider. class TSpider: public TObject, public TAttFill, public TAttLine. Spider class; A spider view is a handy way to visualize a set of data stored in a TTree. It draws as; many polar axes as selected data members. For each of them, it draws on the axis; the position of the present event between the min and max of the data member.; Two modes are availables:. The spider view: With each points on the axes is drawn a polyline.; The segment view: For each data member is drawn an arc segment with the radius corresponding to the event. The spider plot is available from the treeviewer called by ""atree->StartViewer()"", or simply by calling its constructor and defining the variables to display. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""TSpider example"",200,10,700,700);; TFile *f = new TFile(""$(ROOTSYS)/tutorials/hsimple.root"");; if (!f || f->IsZombie()) {; printf(""Please run <ROOT location>/tutorials/hsimple.C before."");; return;; }; TNtuple* ntuple = f->Get(""ntuple"");; TString varexp = ""px:py:pz:random:sin(px):log(px/py):log(pz)"";; TString select = ""px>0 && py>0 && pz>0"";; TString options = ""average"";; TSpider *spider = new TSpider(ntuple,varexp.Data(),select.Data(),options.Data());; spider->Draw();; c1->ToggleEditor();; c1->Selected(c1,spider,1);; return c1;; }. Function Members (Methods); public:. TSpider(); TSpider(const TSpider&); TSpider(TTree* tree, const char* varexp, const char* selection, Option_t* option = """", Long64_t nentries = 0, Long64_t firstentry = 0); virtual~TSpider(); voidTObject::AbstractMethod(const char* method) const; voidAddSuperposed(TSpider* sp); voidAddVariable(const char* varexp)MENU ; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSpider.html:599,avail,availables,599,root/html530/TSpider.html,https://root.cern,https://root.cern/root/html530/TSpider.html,10,['avail'],"['available', 'availables']"
Availability,". TSpline. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSpline. class TSpline: public TNamed, public TAttLine, public TAttFill, public TAttMarker. TSpline. Base class for spline implementation containing the Draw/Paint; methods. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSpline(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpline.html:574,avail,available,574,root/html602/TSpline.html,https://root.cern,https://root.cern/root/html602/TSpline.html,4,['avail'],['available']
Availability,". TSpline. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TSpline. class TSpline: public TNamed, public TAttLine, public TAttFill, public TAttMarker. TSpline. Base class for spline implementation containing the Draw/Paint; methods. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSpline(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Double_tEval(Double_t x) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpline.html:550,avail,available,550,root/html528/TSpline.html,https://root.cern,https://root.cern/root/html528/TSpline.html,6,['avail'],['available']
Availability,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGetMeanErr() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatistic.html:366,error,errors,366,root/html602/TStatistic.html,https://root.cern,https://root.cern/root/html602/TStatistic.html,2,['error'],['errors']
Availability,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. TStatistic(const char* name = """"); TStatistic(const TStatistic&); TStatistic(const char* name, Int_t n, const Double_t* val, const Double_t* w = 0); virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatistic.html:342,error,errors,342,root/html534/TStatistic.html,https://root.cern,https://root.cern/root/html534/TStatistic.html,2,['error'],['errors']
Availability,". TStatistic. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TStatistic. class TStatistic: public TObject. TStatistic. Statistical variable, defined by its mean, RMS and related errors.; Named, streamable, storable and mergeable. Function Members (Methods); public:. virtual~TStatistic(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t val, Double_t w = 1.); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; Double_tGetM2() const; Double_tGetMean() const; Double_tGetMeanErr() const; Long64_tGetN() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TStatistic.html:342,error,errors,342,root/html604/TStatistic.html,https://root.cern,https://root.cern/root/html604/TStatistic.html,2,['error'],['errors']
Availability,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStatus.html:388,error,error,388,root/html602/TStatus.html,https://root.cern,https://root.cern/root/html602/TStatus.html,4,['error'],['error']
Availability,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); TStatus(const TStatus&); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStatus.html:364,error,error,364,root/html528/TStatus.html,https://root.cern,https://root.cern/root/html528/TStatus.html,4,['error'],['error']
Availability,". TStatus. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFPLAYER; » TStatus. class TStatus: public TNamed. TStatus. This class holds the status of an ongoing operation and collects; error messages. It provides a Merge() operation allowing it to; be used in PROOF to monitor status in the slaves.; No messages indicates success. Function Members (Methods); public:. TStatus(); virtual~TStatus(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const char* mesg); voidAddInfo(const char* mesg); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TStatus.html:364,error,error,364,root/html534/TStatus.html,https://root.cern,https://root.cern/root/html534/TStatus.html,2,['error'],['error']
Availability,". TStdExceptionHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStdExceptionHandler. class TStdExceptionHandler: public TSysEvtHandler. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TStdExceptionHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStdExceptionHandler.html:550,avail,available,550,root/html602/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html602/TStdExceptionHandler.html,4,['avail'],['available']
Availability,". TStdExceptionHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TStdExceptionHandler. class TStdExceptionHandler: public TSysEvtHandler. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TStdExceptionHandler(); voidTObject::AbstractMethod(const char* method) const; voidTSysEvtHandler::Activate(); virtual voidTSysEvtHandler::Activated()SIGNAL ; virtual voidAdd(); virtual voidTSysEvtHandler::Added()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidTSysEvtHandler::DeActivate(); virtual voidTSysEvtHandler::DeActivated()SIGNAL ; virtual voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStdExceptionHandler.html:526,avail,available,526,root/html528/TStdExceptionHandler.html,https://root.cern,https://root.cern/root/html528/TStdExceptionHandler.html,6,['avail'],['available']
Availability,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStyleManager.html:880,avail,available,880,root/html602/TStyleManager.html,https://root.cern,https://root.cern/root/html602/TStyleManager.html,6,"['Avail', 'avail']","['Available', 'available']"
Availability,". TStyleManager. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GED; » TStyleManager. class TStyleManager: public TGMainFrame. TStyleManager. This class provides a Graphical User Interface to manage styles; in ROOT. It allows the user to edit styles, import / export; them to macros, apply a style on the selected object or on; all canvases, change gStyle. Activate the style manager by selecting Edit menu / Style...; in the canvas window. The Style Manager interface is composed of two parts:; - the top level interface that manages a list of styles;; - the style editor, which deals with the current style settings. /*. */. The combo box 'Available Styles' contains the list of available; styles for the current ROOT session and shows the currently; selected one. The field on the right shows the setting of the gStyle.; You can set the global variable gStyle to the selected style by; clicking on the button in the middle.; The group frame 'Apply on' displays information for the currently; selected canvas and object in the ROOT session. This selection might; be changed by clicking on another object with the middle mouse; button. You have a choice to apply a style on the selected object or; on all available canvases.; WARNING: You cannot undo the changes after applying the style! If; you are not sure of that action, it may be better to see a preview; of what you are going to apply.; If the check button 'Preview' is selected, a preview of the selected; canvas according to the selected style will be shown. The selection; of the next check button 'Run Time Preview' will apply updates of; the preview any time a value of the selected style is changed. For; drawings that take a time it is better to disable this option. Create a new style:; A new style can be created via the Style menu/New... or the toolbar.; A c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:856,avail,available,856,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,8,"['Avail', 'avail']","['Available', 'available']"
Availability,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSysEvtHandler.html:542,avail,available,542,root/html602/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html602/TSysEvtHandler.html,4,['avail'],['available']
Availability,". TSysEvtHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TSysEvtHandler. class TSysEvtHandler: public TObject, public TQObject. TSysEvtHandler. Abstract base class for handling system events. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TSysEvtHandler(); voidTObject::AbstractMethod(const char* method) const; voidActivate(); virtual voidActivated()SIGNAL ; virtual voidAdd(); virtual voidAdded()SIGNAL ; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTObject::Copy(TObject& object) const; voidDeActivate(); virtual voidDeActivated()SIGNAL ; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidTQObject::Destroyed()SIGNAL ; Bool_tTQOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSysEvtHandler.html:518,avail,available,518,root/html528/TSysEvtHandler.html,https://root.cern,https://root.cern/root/html528/TSysEvtHandler.html,6,['avail'],['available']
Availability,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable. TGTable implements a table widget to display data in rows and; columns. The data is supplied by a TVirtualTableInterface. The table is a TGCanvas to make use of already available viewport; functionality and drawing optimizations. The top left cell in a table has coordinates (0,0). A TObjArray is used internally to ensure little overhead and fast; acces to cells. If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate; TVirtualTableInterface from the data that needs visualization and; then creating the TGTable using this interface. A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTableRange.html:478,avail,available,478,root/html602/TTableRange.html,https://root.cern,https://root.cern/root/html602/TTableRange.html,4,['avail'],['available']
Availability,". TTableRange. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » GUI; » TTableRange. class TTableRange. TGTable; ; TGTable implements a table widget to display data in rows and ; columns. The data is supplied by a TVirtualTableInterface. . The table is a TGCanvas to make use of already available viewport ; functionality and drawing optimizations. . The top left cell in a table has coordinates (0,0) . A TObjArray is used internally to ensure little overhead and fast ; acces to cells. . If the data source has more rows than the default 50 rows of cells in; memory, buttons at the bottom of the table can be used to load the; next or previous chunk of data. At the top of the table, a frame is visible that shows the coordinates; of the top left cell currently in memmory in row,column. The amount of; rows and columns is also shown in rows x columns. These values can be; edited to move to a different area of the data source or to resize the; table. Tab will switch between the enties, return will move to the; currently entered range and resize the table if needed. Clicking the; goto button has the same effect. A TGTable is created by first creating an appropriate ; TVirtualTableInterface from the data that needs visualization and ; then creating the TGTable using this interface. . A simple macro to use a TGTable with a TGSimpleTableInterface:. Picture; Source. {; // Create an array to hold a bunch of numbers; Int_t i = 0, j = 0;; UInt_t nrows = 6, ncolumns = 5;; Double_t** data = new Double_t*[nrows];; for (i = 0; i < nrows; i++) {; data[i] = new Double_t[ncolumns];; for (j = 0; j < ncolumns; j++) {; data[i][j] = 10 * i + j;; }; }. // Create a main frame to contain the table; TGMainFrame* mainframe = new TGMainFrame(0, 400, 200);; mainframe->SetCleanup(kDeepCleanup) ;. // Create an interface; TGSimpleTableI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTableRange.html:459,avail,available,459,root/html528/TTableRange.html,https://root.cern,https://root.cern/root/html528/TTableRange.html,4,['avail'],['available']
Availability,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buff",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThreadFactory.html:601,avail,available,601,root/html602/TThreadFactory.html,https://root.cern,https://root.cern/root/html602/TThreadFactory.html,4,['avail'],['available']
Availability,". TThreadFactory. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadFactory. class TThreadFactory: public TNamed. TThreadFactory. This ABC is a factory for thread components. Depending on which; factory is active one gets either Posix or Win32 threads. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadFactory(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual TConditionImp*CreateConditionImp(TMutexImp* m); virtual TMutexImp*CreateMutexImp(Bool_t recursive); virtual TThreadImp*CreateThreadImp(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThreadFactory.html:577,avail,available,577,root/html528/TThreadFactory.html,https://root.cern,https://root.cern/root/html528/TThreadFactory.html,6,['avail'],['available']
Availability,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TThreadImp.html:695,avail,available,695,root/html602/TThreadImp.html,https://root.cern,https://root.cern/root/html602/TThreadImp.html,4,['avail'],['available']
Availability,". TThreadImp. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » THREAD; » TThreadImp. class TThreadImp: public TObject. TThreadImp. This class implements threads. A thread is an execution environment; much lighter than a process. A single process can have multiple; threads. The actual work is done via the TThreadImp class (either; TPosixThread or TWin32Thread). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TThreadImp(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Int_tCancelPoint(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(void** main); virtual Int_tCleanUpPop(void** main, Int_t exe); virtual Int_tCleanUpPush(void** main, void* free, void* arg); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Int_tExit(void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TThreadImp.html:671,avail,available,671,root/html528/TThreadImp.html,https://root.cern,https://root.cern/root/html528/TThreadImp.html,6,['avail'],['available']
Availability,". TTree * TProof::GetTreeHeader ; (; TDSet * ; tdset). virtual . Creates a tree header (a tree with nonexisting files) object for the DataSet. ; Reimplemented in TProofLite.; Definition at line 10042 of file TProof.cxx. ◆ GetUrl(). const char * TProof::GetUrl ; (; ). inline . Definition at line 911 of file TProof.h. ◆ GetUser(). const char * TProof::GetUser ; (; ); const. inline . Definition at line 906 of file TProof.h. ◆ GetWorkDir(). const char * TProof::GetWorkDir ; (; ); const. inline . Definition at line 908 of file TProof.h. ◆ GoAsynchronous(). void TProof::GoAsynchronous ; (; ). Send GOASYNC message to the master. ; Definition at line 6267 of file TProof.cxx. ◆ GoMoreParallel(). Int_t TProof::GoMoreParallel ; (; Int_t ; nWorkersToAdd). private . Add nWorkersToAdd workers to current list of workers. ; This function is works on the master only, and only when an analysis is ongoing. A message is sent back to the client when we go ""more"" parallel. Returns -1 on error, number of total (not added!) workers on success. ; Definition at line 7170 of file TProof.cxx. ◆ GoParallel(). Int_t TProof::GoParallel ; (; Int_t ; nodes, . Bool_t ; attach = kFALSE, . Bool_t ; random = kFALSE . ). private . Go in parallel mode with at most ""nodes"" slaves. ; Since the fSlaves list is sorted by slave performace the active list will contain first the most performant nodes. Returns the number of active slaves. If random is TRUE, and nodes is less than the number of available workers, a random selection is done. Returns -1 in case of error. ; Definition at line 7273 of file TProof.cxx. ◆ HandleInputMessage(). Int_t TProof::HandleInputMessage ; (; TSlave * ; sl, . TMessage * ; mess, . Bool_t ; deactonfail = kFALSE . ). private . Analyze the received message. ; Returns 0 on success (1 if this the last message from this socket), -1 if any failure occurs. ; Definition at line 3105 of file TProof.cxx. ◆ HandleLibIncPath(). void TProof::HandleLibIncPath ; (; const char * ; what, . Bool_t ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:107965,error,error,107965,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:731,avail,available,731,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,2,['avail'],['available']
Availability,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:721,avail,available,721,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['avail'],['available']
Availability,". TTreeFormula. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeFormula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:697,avail,available,697,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,6,['avail'],['available']
Availability,". TTreeReader. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREEPLAYER; » TTreeReader. class TTreeReader: public TObject. TTreeReader is a simple, robust and fast interface to read values from a TTree,; TChain or TNtuple. It uses TTreeReaderValue<T> and; TTreeReaderArray<T> to access the data. Example code can be found in; tutorials/tree/hsimpleReader.C and tutorials/trees/h1analysisTreeReader.h and; tutorials/trees/h1analysisTreeReader.C for a TSelector.; Roottest contains an; example; showing the full power.; A simpler analysis example - the one from the tutorials - can be found below:; it histograms a function of the px and py branches.;  ; // A simple TTreeReader use: read data from hsimple.root (written by hsimple.C);  ; #include ""TFile.h""; #include ""TH1F.h""; #include ""TTreeReader.h""; #include ""TTreeReaderValue.h"";  ; void hsimpleReader() {; // Create a histogram for the values we read.; TH1F *myHist = new TH1F(""h1"", ""ntuple"", 100, -4, 4);;  ; // Open the file containing the tree.; TFile *myFile = TFile::Open(""$ROOTSYS/tutorials/hsimple.root"");;  ; // Create a TTreeReader for the tree, for instance by passing the; // TTree's name and the TDirectory / TFile it is in.; TTreeReader myReader(""ntuple"", myFile);;  ; // The branch ""px"" contains floats; access them as myPx.; TTreeReaderValue<Float_t> myPx(myReader, ""px"");; // The branch ""py"" contains floats, too; access those as myPy.; TTreeReaderValue<Float_t> myPy(myReader, ""py"");;  ; // Loop over all entries of the TTree or TChain.; while (myReader.Next()) {; // Just access the data as if myPx and myPy were iterators (note the '*'; // in front of them):; myHist->Fill(*myPx + *myPy);; };  ; myHist->Draw();; }. A more complete example including error handling and a few combinations of; TTreeReaderValue and TTreeReaderArr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeReader.html:349,robust,robust,349,root/html602/TTreeReader.html,https://root.cern,https://root.cern/root/html602/TTreeReader.html,4,['robust'],['robust']
Availability,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfold.html:701,avail,available,701,root/html602/TUnfold.html,https://root.cern,https://root.cern/root/html602/TUnfold.html,8,"['avail', 'error']","['available', 'errors']"
Availability,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. A short summary of the algorithm is given in the following:. the ""best"" x matching the measurement y within errors; is determined by minimizing the function; L1+L2+L3. where; L1 = (y-Ax)# Vyy^-1 (y-Ax); L2 = tau^2 (L(x-x0))# L(x-x0); L3 = lambda sum_i(y_i -(Ax)_i). [the notation # means that the matrix is transposed ]. The term L1 is familiar from a least-square minimisation; The term L2 defines the regularisation (smootheness condition on x),; where the parameter tau^2 gives the strength of teh regularisation; The term L3 is an optional area constraint with Lagrangian parameter; lambda, ensuring that that the normalisation of x is consistent with the; normalisation of y. The method can be applied to a very large number of problems,; where the measured distribution y is a linear superposition; of several Monte Carlo shapes. Input from measurement:. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y. From simulation:. A: migration matrix (dimension ny x nx). Result. x: unknown underlying distribution (dimension nx); The error matrix of x, V_xx, is also determined. Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfold.html:677,avail,available,677,root/html534/TUnfold.html,https://root.cern,https://root.cern/root/html534/TUnfold.html,4,"['avail', 'error']","['available', 'errors']"
Availability,". TUnfold. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfold. class TUnfold: public TObject. TUnfold solves the inverse problem. chi**2 = (y-Ax)# Vyy^-1 (y-Ax) + tau^2 (L(x-x0))# L(x-x0) + lambda sum_i(y_i -(Ax)_i). where # means that the matrix is transposed. Monte Carlo input. y: vector of measured quantities (dimension ny); Vyy: covariance matrix for y (dimension ny x ny); in many cases V is diagonal and calculated from the errors of y; A: migration matrix (dimension ny x nx); x: unknown underlying distribution (dimension nx). Regularisation. tau: parameter, defining the regularisation strength; L: matrix of regularisation conditions (dimension nl x nx); x0: bias distribution. Preservation of the area. lambda: lagrangian multiplier; y_i: one component of the vector y; (Ax)_i: one component of the vector Ax. and chi**2 is minimized; (a) not constrained: minimisation is performed a function of x for fixed lambda=0; or; (b) constrained: minimisation is performed a function of x and lambda. This applies to a very large number of problems, where the measured; distribution y is a linear superposition of several Monte Carlo shapes; and the sum of these shapes gives the output distribution x. The constraint can be useful to reduce biases on the result x; in cases where the vector y follows non-Gaussian probability densities; (example: Poisson statistics at counting experiments in particle physics). Some random examples:. (1) measure a cross-section as a function of, say, E_T(detector); and unfold it to obtain the underlying distribution E_T(generator); (2) measure a lifetime distribution and unfold the contributions from; different flavours; (3) measure the transverse mass and decay angle; and unfold for the true mass distribution plus background. Documentation. Some technical documenta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfold.html:620,error,errors,620,root/html528/TUnfold.html,https://root.cern,https://root.cern/root/html528/TUnfold.html,4,['error'],['errors']
Availability,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name, Int_t nBins, Double_t xMin, Double_t xMax, Bool_t hasUnderflow, Bool_t hasOverflow); TUnfoldBinning*AddBinning(TUnfoldBinning* binning); TUnfoldBinning*AddBinning(const char* n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldBinning.html:813,avail,available,813,root/html602/TUnfoldBinning.html,https://root.cern,https://root.cern/root/html602/TUnfoldBinning.html,4,['avail'],['available']
Availability,". TUnfoldBinning. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldBinning. class TUnfoldBinning: public TNamed. TUnfoldBinning. This class serves as a container of analysis bins; analysis bins are specified by defining the axes of a distribution.; It is also possible to have unconnected analysis bins without axis.; Multiple TUnfoldBinning objects may be arranged in a tree,; such that a full tree structure of histograms and bins is supported. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. Functionality. The class gives access to all analysis bins numbered in sequence.; Such a sequence of bins may be stored in a 1-dimension histogram.; Correlations between two TUnfoldBinning objects may be stored in; a 2-dimensional histogram. This type of ordering is required for; the TUnfold class. In addition, it is possible to have root histograms, using the; axes as defined with the distributions. Underflow/overflow bins; can be included or excluded when mapping bins on root histograms.; In addition, it is possible to collapse one of more axes when going; from a N-dimensional distribution to a root histogram. Function Members (Methods); public:. TUnfoldBinning(const TUnfoldBinning&); TUnfoldBinning(const char* name = 0, Int_t nBins = 0, const char* binNames = 0); TUnfoldBinning(const TAxis& axis, Int_t includeUnderflow, Int_t includeOverflow); virtual~TUnfoldBinning(); voidTObject::AbstractMethod(const char* method) const; Bool_tAddAxis(const TAxis& axis, Bool_t includeUnderflow, Bool_t includeOverflow); Bool_tAddAxis(const char* name, Int_t nBins, const Double_t* binBorders, Bool_t hasUnderflow, Bool_t hasOverflow); Bool_tAddAxis(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldBinning.html:789,avail,available,789,root/html534/TUnfoldBinning.html,https://root.cern,https://root.cern/root/html534/TUnfoldBinning.html,2,['avail'],['available']
Availability,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other backgrou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldDensity.html:830,avail,available,830,root/html602/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html602/TUnfoldDensity.html,4,['avail'],['available']
Availability,". TUnfoldDensity. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldDensity. class TUnfoldDensity: public TUnfoldSys. TUnfoldDensity : public TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. More details are described with the documentation of TUnfold. For most applications, it is best to use TUnfoldDensity; instead of using TUnfoldSys or TUnfold. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. As compared to TUnfold, TUndolfDensity adds the following functionality; * background subtraction (see documentation of TUnfoldSys); * error propagation (see documentation of TUnfoldSys); * regularisation schemes respecting the bin widths; * support for complex, multidimensional input distributions. Complex binning schemes are imposed on the measurements y and; on the result vector x with the help of the class TUnfoldBinning; The components of x or y are part of multi-dimensional distributions.; The bin widths along the relevant directions in these distributions; are used to calculate bin densities (number of events divided by bin width); or to calculate derivatives taking into account the proper distance of; adjacent bin centers. Complex binning schemes. in literature on unfolding, the ""standard"" test case is a; one-dimensional distribution without underflow or overflow bins.; The migration matrix is almost diagonal. This ""standard"" case is rarely realized for real problems. Often one has to deal with multi-dimensional input distributions.; In addition, there are underflow and overflow bins; or other background bins, possibly determ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldDensity.html:806,avail,available,806,root/html534/TUnfoldDensity.html,https://root.cern,https://root.cern/root/html534/TUnfoldDensity.html,4,"['avail', 'error']","['available', 'error']"
Availability,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnfoldSys.html:495,error,error,495,root/html602/TUnfoldSys.html,https://root.cern,https://root.cern/root/html602/TUnfoldSys.html,20,"['avail', 'error']","['available', 'error', 'errors']"
Availability,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys : public TUnfold. TUnfold is used to decompose a measurement y into several sources x; given the measurement uncertainties and a matrix of migrations A. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. * For most applications, it is better to use TUnfoldDensity *; * instead of using TUnfoldSys or TUnfold *. If you use this software, please consider the following citation; S.Schmitt, JINST 7 (2012) T10003 [arXiv:1205.6201]. More documentation and updates are available on; http://www.desy.de/~sschmitt. The following sources of systematic error are considered in TUnfoldSys. (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. In addition there is the (statistical) uncertainty of the input vector (i). Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnfoldSys.html:471,error,error,471,root/html534/TUnfoldSys.html,https://root.cern,https://root.cern/root/html534/TUnfoldSys.html,10,"['avail', 'error']","['available', 'error', 'errors']"
Availability,". TUnfoldSys. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TUnfoldSys. class TUnfoldSys: public TUnfold. TUnfoldSys adds error propagation of systematic errors to TUnfold; Also, background sources (with errors) can be subtracted. The following sources of systematic error are considered:; (a) uncorrelated errors on the input matrix histA, taken as the; errors provided with the histogram.; These are typically statistical errors from finite Monte Carlo samples. (b) correlated shifts of the input matrix histA. These shifts are taken; as one-sigma effects when switchig on a given error soure.; several such error sources may be defined. (c) a systematic error on the regularisation parameter tau. (d) uncorrelated errors on background sources, taken as the errors; provided with the background histograms. (e) scale errors on background sources. Source (a) is providede with the original histogram histA; TUnfoldSys(histA,...). Sources (b) are added by calls to; AddSysError(). The systematic uncertainty on tau (c) is set by; SetTauError(). Backgound sources causing errors of type (d) and (e) are added by; SubtractBackground(). NOTE:. Systematic errors (a), (b), (c) are propagated to the result; AFTER unfolding. Background errors (d) and (e) are added to the data errors; BEFORE unfolding. For this reason:; errors of type (d) and (e) are INCLUDED in the standard error matrix; and other methods provided by the base class TUnfold:; GetOutput(); GetEmatrix(). whereas errors of type (a), (b), (c) are NOT INCLUDED in the methods; provided by the base class TUnfold. Accessing error matrices:. The error sources (b),(c) and (e) propagate to shifts of the result.; These shifts may be accessed as histograms using the methods; GetDeltaSysSource() corresponds to (b); GetDeltaSysTau() corresponds to (c); GetDel",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:307,error,error,307,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,48,['error'],"['error', 'errors']"
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnuranBaseDist.html:549,avail,available,549,root/html528/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html528/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance Chart:. TUnuranBaseDist. ←. TUnuranContDist. TUnuranDiscrDist. TUnuranEmpDist. TUnuranMultiContDist. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUnuranBaseDist.html:575,avail,available,575,root/html602/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html602/TUnuranBaseDist.html,2,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TUnuranBaseDist(); TUnuranBaseDist(const TUnuranBaseDist&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUnuranBaseDist.html:551,avail,available,551,root/html604/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html604/TUnuranBaseDist.html,2,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUnuranBaseDist.html:551,avail,available,551,root/html530/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html530/TUnuranBaseDist.html,1,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id: TUnuranBaseDist.h 21526 2007-12-20 10:42:41Z moneta $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnuranBaseDist.html:551,avail,available,551,root/html532/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html532/TUnuranBaseDist.html,2,['avail'],['available']
Availability,". TUnuranBaseDist. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » MATH; » UNURAN; » TUnuranBaseDist. class TUnuranBaseDist. TUnuranBaseDist, base class for Unuran distribution classees such as; TUnuranContDist (for one-dimension) or TUnuranMultiContDist (multi-dimension). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TUnuranBaseDist(); static TClass*Class(); virtual TUnuranBaseDist*Clone() const; virtual TClass*IsA() const; TUnuranBaseDist&operator=(const TUnuranBaseDist&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TUnuranBaseDist(). Destructor (no operations). {}. TUnuranBaseDist * Clone() const. Abstract clone method for a deep copy of the derived classes. » Last changed: root/unuran:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TUnuranBaseDist.html:551,avail,available,551,root/html534/TUnuranBaseDist.html,https://root.cern,https://root.cern/root/html534/TUnuranBaseDist.html,2,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUploadDataSetDlg.html:414,avail,available,414,root/html528/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html528/TUploadDataSetDlg.html,1,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. TUploadDataSetDlg(TSessionViewer* gui, Int_t w, Int_t h); virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TUploadDataSetDlg.html:416,avail,available,416,root/html530/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html530/TUploadDataSetDlg.html,5,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TUploadDataSetDlg.html:464,avail,available,464,root/html602/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html602/TUploadDataSetDlg.html,2,['avail'],['available']
Availability,". TUploadDataSetDlg. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GUI; » SESSIONVIEWER; » TUploadDataSetDlg. class TUploadDataSetDlg: public TGTransientFrame. TSessionDialogs. This file defines several dialogs that are used by TSessionViewer.; The following dialogs are available: TNewChainDlg and TNewQueryDlg. Function Members (Methods); public:. virtual~TUploadDataSetDlg(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidAddFiles(const char* fileName); voidAddFiles(TList* fileList); virtual voidTGCompositeFrame::AddFrame(TGFrame* f, TGLayoutHints* l = 0); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual Bool_tTGMainFrame::BindKey(const TGWindow* w, Int_t keycode, Int_t modifier) const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); voidBrowseFiles(); virtual voidTGTransientFrame::CenterOnParent(Bool_t croot = kTRUE, TGTransientFrame::EPlacement pos = kCenter); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGCompositeFrame::ChangeOptions(UInt_t options); virtual voidTGCompositeFrame::ChangeSubframesBackground(Pixel_t back); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTGCompositeFrame::Cleanup(); virtual voidTObject::Clear(Option_t* = """"); voidClearFiles(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidCloseWindow(); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TUploadDataSetDlg.html:440,avail,available,440,root/html604/TUploadDataSetDlg.html,https://root.cern,https://root.cern/root/html604/TUploadDataSetDlg.html,2,['avail'],['available']
Availability,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>& action); TVectorT<double>&Apply(const TElementPosActionT<double>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_double_.html:573,avail,available,573,root/html602/TVectorT_double_.html,https://root.cern,https://root.cern/root/html602/TVectorT_double_.html,4,['avail'],['available']
Availability,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorD, TVectorT<Double_t>. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVectorT_double_.html:549,avail,available,549,root/html530/TVectorT_double_.html,https://root.cern,https://root.cern/root/html530/TVectorT_double_.html,3,['avail'],['available']
Availability,". TVectorT<double>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<double>. class TVectorT<double>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Double_t>, TVectorD. Function Members (Methods); public:. TVectorT<double>(); TVectorT<double>(Int_t n); TVectorT<double>(const TVectorT<double>& another); TVectorT<double>(const TMatrixTRow_const<double>& mr); TVectorT<double>(const TMatrixTColumn_const<double>& mc); TVectorT<double>(const TMatrixTDiag_const<double>& md); TVectorT<double>(const TVectorT<float>& another); TVectorT<double>(Int_t lwb, Int_t upb); TVectorT<double>(Int_t n, const double* elements); TVectorT<double>(Int_t lwb, Int_t upb, const double* elements); virtual~TVectorT<double>(); TVectorT<double>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<double>& v); voidAdd(const TVectorT<double>& v1, const TVectorT<double>& v2); voidAddSomeConstant(double val, const TVectorT<double>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<double>&Apply(const TElementActionT<double>&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVectorT_double_.html:549,avail,available,549,root/html528/TVectorT_double_.html,https://root.cern,https://root.cern/root/html528/TVectorT_double_.html,3,['avail'],['available']
Availability,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. Function Members (Methods); public:. virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<float>&Apply(const TElementPosActionT<float>& action); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVectorT_float_.html:570,avail,available,570,root/html602/TVectorT_float_.html,https://root.cern,https://root.cern/root/html602/TVectorT_float_.html,4,['avail'],['available']
Availability,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVector, TVectorF. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVectorT_float_.html:546,avail,available,546,root/html534/TVectorT_float_.html,https://root.cern,https://root.cern/root/html534/TVectorT_float_.html,2,['avail'],['available']
Availability,". TVectorT<float>. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATRIX; » TVectorT<float>. class TVectorT<float>: public TObject. TVectorT. Template class of Vectors in the linear algebra package. Unless otherwise specified, vector indices always start with 0,; spanning up to the specified limit-1. For (n) vectors where n <= kSizeMax (5 currently) storage space is; available on the stack, thus avoiding expensive allocation/; deallocation of heap space . However, this introduces of course; kSizeMax overhead for each vector object . If this is an issue; recompile with a new appropriate value (>=0) for kSizeMax. Another way to assign and store vector data is through Use; see for instance stressLinear.cxx file . Note that Constructors/assignments exists for all different matrix; views. For usage examples see $ROOTSYS/test/stressLinear.cxx. This class is also known as (typedefs to this class)TVectorT<Float_t>, TVectorF, TVector. Function Members (Methods); public:. TVectorT<float>(); TVectorT<float>(Int_t n); TVectorT<float>(const TVectorT<float>& another); TVectorT<float>(const TMatrixTRow_const<float>& mr); TVectorT<float>(const TMatrixTColumn_const<float>& mc); TVectorT<float>(const TMatrixTDiag_const<float>& md); TVectorT<float>(const TVectorT<double>& another); TVectorT<float>(Int_t lwb, Int_t upb); TVectorT<float>(Int_t n, const float* elements); TVectorT<float>(Int_t lwb, Int_t upb, const float* elements); virtual~TVectorT<float>(); TVectorT<float>&Abs(); voidTObject::AbstractMethod(const char* method) const; voidAdd(const TVectorT<float>& v); voidAdd(const TVectorT<float>& v1, const TVectorT<float>& v2); voidAddSomeConstant(float val, const TVectorT<float>& select); virtual voidTObject::AppendPad(Option_t* option = """"); TVectorT<float>&Apply(const TElementActionT<float>& action); TVectorT<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVectorT_float_.html:546,avail,available,546,root/html528/TVectorT_float_.html,https://root.cern,https://root.cern/root/html528/TVectorT_float_.html,4,['avail'],['available']
Availability,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TView.html:468,avail,available,468,root/html602/TView.html,https://root.cern,https://root.cern/root/html602/TView.html,4,['avail'],['available']
Availability,". TView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GRAF2D; » GPAD; » TView. class TView: public TObject, public TAttLine. See TView3D; . Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdjustScales(TVirtualPad* pad = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidAxisVertex(Double_t ang, Double_t* av, Int_t& ix1, Int_t& ix2, Int_t& iy1, Int_t& iy2, Int_t& iz1, Int_t& iz2); virtual voidTObject::Browse(TBrowser* b); virtual voidCentered(); virtual voidCentered3DImages(TVirtualPad* pad = 0); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TView*CreateView(Int_t system = 1, const Double_t* rmin = 0, const Double_t* rmax = 0); virtual voidDefinePerspectiveView(); virtual voidDefineViewDirection(const Double_t* s, const Double_t* c, Double_t cosphi, Double_t sinphi, Double_t costhe, Double_t sinthe, Double_t cospsi, Double_t sinpsi, Double_t* tnorm, Double_t* tback); virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawOutlineCube(TList* outline, Double_t* rmin, Double_t* rmax); virtual voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TView.html:444,avail,available,444,root/html528/TView.html,https://root.cern,https://root.cern/root/html528/TView.html,6,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Sep 23 20:22:18 2010 » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualAuth.html:454,avail,available,454,root/html528/TVirtualAuth.html,https://root.cern,https://root.cern/root/html528/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance Chart:. TVirtualAuth. ←. TRootAuth. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:32:34 2015 » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualAuth.html:480,avail,available,480,root/html602/TVirtualAuth.html,https://root.cern,https://root.cern/root/html602/TVirtualAuth.html,3,"['Error', 'avail']","['ErrorMsg', 'available']"
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualAuth(); TVirtualAuth(const TVirtualAuth&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualAuth(); { }. virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:49:45 2015 » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualAuth.html:456,avail,available,456,root/html604/TVirtualAuth.html,https://root.cern,https://root.cern/root/html604/TVirtualAuth.html,3,"['Error', 'avail']","['ErrorMsg', 'available']"
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:38:47 2011 » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualAuth.html:456,avail,available,456,root/html530/TVirtualAuth.html,https://root.cern,https://root.cern/root/html530/TVirtualAuth.html,1,['avail'],['available']
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:07 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualAuth.html:456,avail,available,456,root/html532/TVirtualAuth.html,https://root.cern,https://root.cern/root/html532/TVirtualAuth.html,3,"['Error', 'avail']","['ErrorMsg', 'available']"
Availability,". TVirtualAuth. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualAuth. class TVirtualAuth. TVirtualAuth. Abstract interface for client authentication code. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualAuth(); virtual TSecContext*Authenticate(TSocket*, const char* host, const char* user, Option_t* options); static TClass*Class(); virtual Int_tClientVersion(); virtual voidErrorMsg(const char* where, Int_t ecode); virtual TClass*IsA() const; virtual const char*Name(); TVirtualAuth&operator=(const TVirtualAuth&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualAuth(); { }. TSecContext * Authenticate(TSocket* , const char* host, const char* user, Option_t* options). void ErrorMsg(const char* where, Int_t ecode). const char * Name(). » Author: G. Ganis 08/07/05 » Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:05:51 2015 » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualAuth.html:456,avail,available,456,root/html534/TVirtualAuth.html,https://root.cern,https://root.cern/root/html534/TVirtualAuth.html,3,"['Error', 'avail']","['ErrorMsg', 'available']"
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualCollectionProxy.html:699,avail,available,699,root/html528/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualCollectionProxy.html,1,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualCollectionProxy.html:639,avail,available,639,root/html602/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualCollectionProxy.html,2,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const; virtual TStreamerInfoActions::TActionSequence*GetWriteMemberWiseActions(); virtual Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualCollectionProxy.html:615,avail,available,615,root/html604/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html604/TVirtualCollectionProxy.html,2,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE) const; virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE) const; virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass() const; virtual Int_tGetCollectionType() const; virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement() const; virtual Int_tGetProperties() const; virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType() const; virtual TClass*GetValueClass() const;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualCollectionProxy.html:701,avail,available,701,root/html534/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualCollectionProxy.html,2,['avail'],['available']
Availability,". TVirtualCollectionProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » CONT; » TVirtualCollectionProxy. class TVirtualCollectionProxy. TVirtualCollectionProxy. Virtual interface of a proxy object for a collection class; In particular this is used to implement splitting, emulation,; and TTreeFormula access to STL containers. This class is also known as (typedefs to this class)TCollectionProxyFactory::Proxy_t. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualCollectionProxy(); virtual void*Allocate(UInt_t n, Bool_t forceDelete); virtual void*At(UInt_t idx); virtual voidClear(const char* opt = """"); virtual voidCommit(void*); virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual TVirtualCollectionProxy*Generate() const; virtual TClass*GetCollectionClass(); virtual Int_tGetCollectionType(); virtual TStreamerInfoActions::TActionSequence*GetConversionReadMemberWiseActions(TClass* oldClass, Int_t version); virtual TVirtualCollectionProxy::CopyIterator_tGetFunctionCopyIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::CreateIterators_tGetFunctionCreateIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteIterator_tGetFunctionDeleteIterator(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::DeleteTwoIterators_tGetFunctionDeleteTwoIterators(Bool_t read = kTRUE); virtual TVirtualCollectionProxy::Next_tGetFunctionNext(Bool_t read = kTRUE); virtual ULong_tGetIncrement(); virtual Int_tGetProperties(); virtual TStreamerInfoActions::TActionSequence*GetReadMemberWiseActions(Int_t version); virtual EDataTypeGetType(); virtual TClass*GetValueClass(); virtual TStreamerInfoActions::TActionSequence*G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualCollectionProxy.html:701,avail,available,701,root/html530/TVirtualCollectionProxy.html,https://root.cern,https://root.cern/root/html530/TVirtualCollectionProxy.html,3,['avail'],['available']
Availability,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFFT.html:1145,redundant,redundant,1145,root/html602/TVirtualFFT.html,https://root.cern,https://root.cern/root/html602/TVirtualFFT.html,6,"['Avail', 'redundant']","['Available', 'redundant']"
Availability,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT01 in FFTW3 notation)- kind=1; DCT-III(REDFT10 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT01 in FFTW3 notation)- kind=5; DST-III(RODFT10 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualFFT.html:1121,redundant,redundant,1121,root/html530/TVirtualFFT.html,https://root.cern,https://root.cern/root/html530/TVirtualFFT.html,7,"['Avail', 'redundant']","['Available', 'redundant']"
Availability,". TVirtualFFT. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualFFT. class TVirtualFFT: public TObject. TVirtualFFT. TVirtualFFT is an interface class for Fast Fourier Transforms. The default FFT library is FFTW. To use it, FFTW3 library should already; be installed, and ROOT should be have fftw3 module enabled, with the directories; of fftw3 include file and library specified (see installation instructions).; Function SetDefaultFFT() allows to change the default library. Available transform types:; FFT:; - ""C2CFORWARD"" - a complex input/output discrete Fourier transform (DFT); in one or more dimensions, -1 in the exponent; - ""C2CBACKWARD""- a complex input/output discrete Fourier transform (DFT); in one or more dimensions, +1 in the exponent; - ""R2C"" - a real-input/complex-output discrete Fourier transform (DFT); in one or more dimensions,; - ""C2R"" - inverse transforms to ""R2C"", taking complex input; (storing the non-redundant half of a logically Hermitian array); to real output; - ""R2HC"" - a real-input DFT with output in ¡Èhalfcomplex¡É format,; i.e. real and imaginary parts for a transform of size n stored as; r0, r1, r2, ..., rn/2, i(n+1)/2-1, ..., i2, i1; - ""HC2R"" - computes the reverse of FFTW_R2HC, above; - ""DHT"" - computes a discrete Hartley transform. Sine/cosine transforms:; Different types of transforms are specified by parameter kind of the SineCosine() static; function. 4 different kinds of sine and cosine transforms are available; DCT-I (REDFT00 in FFTW3 notation)- kind=0; DCT-II (REDFT10 in FFTW3 notation)- kind=1; DCT-III(REDFT01 in FFTW3 notation)- kind=2; DCT-IV (REDFT11 in FFTW3 notation)- kind=3; DST-I (RODFT00 in FFTW3 notation)- kind=4; DST-II (RODFT10 in FFTW3 notation)- kind=5; DST-III(RODFT01 in FFTW3 notation)- kind=6; DST-IV (RODFT11 in FFTW3 notation)- k",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFFT.html:1121,redundant,redundant,1121,root/html528/TVirtualFFT.html,https://root.cern,https://root.cern/root/html528/TVirtualFFT.html,1,['redundant'],['redundant']
Availability,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualFitter.html:493,avail,available,493,root/html604/TVirtualFitter.html,https://root.cern,https://root.cern/root/html604/TVirtualFitter.html,2,['avail'],['available']
Availability,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualFitter.html:497,avail,available,497,root/html602/TVirtualFitter.html,https://root.cern,https://root.cern/root/html602/TVirtualFitter.html,2,['avail'],['available']
Availability,". TVirtualFitter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MATH; » MATHCORE; » TVirtualFitter. class TVirtualFitter: public TNamed. Abstract Base Class for Fitting. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualFitter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual Double_tChisquare(Int_t npar, Double_t* params) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual Int_tExecuteCommand(const char* command, Double_t* args, Int_t nargs); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static TVir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualFitter.html:473,avail,available,473,root/html528/TVirtualFitter.html,https://root.cern,https://root.cern/root/html528/TVirtualFitter.html,6,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. ←. TGLManip; ←. TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualGLManip.html:520,avail,available,520,root/html604/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html604/TVirtualGLManip.html,4,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLManip(); TVirtualGLManip(const TVirtualGLManip&). Class Charts. Inheritance Chart:. TVirtualGLManip. ←. TGLManip; ←. TGLRotateManip. TGLScaleManip. TGLTransManip. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGLManip.html:520,avail,available,520,root/html602/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html602/TVirtualGLManip.html,4,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGLManip.html:496,avail,available,496,root/html528/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html528/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualGLManip.html:496,avail,available,496,root/html530/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html530/TVirtualGLManip.html,2,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualGLManip.html:496,avail,available,496,root/html532/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html532/TVirtualGLManip.html,4,['avail'],['available']
Availability,". TVirtualGLManip. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLManip. class TVirtualGLManip. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLManip(); static TClass*Class(); virtual TClass*IsA() const; TVirtualGLManip&operator=(const TVirtualGLManip&); virtual Bool_tSelect(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLManip(); {}. Bool_t Select(const TGLCamera& camera, const TGLRect& rect, const TGLBoundingBox& sceneBox). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualGLManip.html:496,avail,available,496,root/html534/TVirtualGLManip.html,https://root.cern,https://root.cern/root/html534/TVirtualGLManip.html,4,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualGLPainter(); TVirtualGLPainter(const TVirtualGLPainter&). Class Charts. Inheritance Chart:. TVirtualGLPainter. ←. TGLPlotPainter; ←. TGLBoxPainter. TGLH2PolyPainter. TGLIsoPainter. TGLLegoPainter. TGLParametricPlot. TGLSurfacePainter. TGLTF3Painter. TGLTH3CompositionPainter. TGLVoxelPainter.  [more...]. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGLPainter.html:526,avail,available,526,root/html602/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGLPainter.html,8,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGLPainter.html:502,avail,available,502,root/html528/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualGLPainter.html,2,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualGLPainter.html:502,avail,available,502,root/html530/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html530/TVirtualGLPainter.html,2,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id: TVirtualGL.h 20877 2007-11-19 11:17:07Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualGLPainter.html:502,avail,available,502,root/html532/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html532/TVirtualGLPainter.html,4,['avail'],['available']
Availability,". TVirtualGLPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualGLPainter. class TVirtualGLPainter. TVirtualGL. The TVirtualGL class is an abstract base class defining the; OpenGL interface protocol. All interactions with OpenGL should be; done via the global pointer gVirtualGL. If the OpenGL library is; available this pointer is pointing to an instance of the TGLKernel; class which provides the actual interface to OpenGL. Using this; scheme of ABC we can use OpenGL in other parts of the framework; without having to link with the OpenGL library in case we don't; use the classes using OpenGL. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGLPainter(); static TClass*Class(); virtual char*GetPlotInfo(Int_t px, Int_t py); virtual TClass*IsA() const; TVirtualGLPainter&operator=(const TVirtualGLPainter&); virtual voidPaint(); virtual voidPan(Int_t px, Int_t py); virtual Bool_tPlotSelected(Int_t px, Int_t py); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualGLPainter(); {}. void Paint(). void Pan(Int_t px, Int_t py). Bool_t PlotSelected(Int_t px, Int_t py); Used by status bar in a canvas. char * GetPlotInfo(Int_t px, Int_t py). » Author: Valery Fine(fine@vxcern.cern.ch) 05/03/97 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualGLPainter.html:502,avail,available,502,root/html534/TVirtualGLPainter.html,https://root.cern,https://root.cern/root/html534/TVirtualGLPainter.html,4,['avail'],['available']
Availability,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = __null); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.10000000000000001, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGeoPainter.html:520,avail,available,520,root/html602/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGeoPainter.html,4,['avail'],['available']
Availability,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual voidDefaultAngles(); virtual voidDefaultColors(); virtual voidTObject::Delete(Option_t* opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGeoPainter.html:496,avail,available,496,root/html528/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualGeoPainter.html,1,['avail'],['available']
Availability,". TVirtualGeoPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoPainter. class TVirtualGeoPainter: public TObject. TVirtualGeoPainter. ABC for geometry painters. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddSize3D(Int_t numpoints, Int_t numsegs, Int_t numpolys); virtual TVirtualGeoTrack*AddTrack(Int_t id, Int_t pdgcode, TObject* particle); virtual voidAddTrackPoint(Double_t* point, Double_t* box, Bool_t reset = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBombTranslation(const Double_t* tr, Double_t* bombtr); virtual voidTObject::Browse(TBrowser* b); virtual voidCheckBoundaryErrors(Int_t ntracks = 1000000, Double_t radius = -1.); virtual voidCheckBoundaryReference(Int_t icheck = -1); virtual voidCheckGeometry(Int_t nrays, Double_t startx, Double_t starty, Double_t startz) const; virtual voidCheckGeometryFull(Bool_t checkoverlaps = kTRUE, Bool_t checkcrossings = kTRUE, Int_t nrays = 10000, const Double_t* vertex = NULL); virtual voidCheckOverlaps(const TGeoVolume* vol, Double_t ovlp = 0.1, Option_t* option = """") const; virtual voidCheckPoint(Double_t x = 0, Double_t y = 0, Double_t z = 0, Option_t* option = """"); virtual voidCheckShape(TGeoShape* shape, Int_t testNo, Int_t nsamples, Option_t* option); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual Int_tCountVisibleNodes(); virtual v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualGeoPainter.html:496,avail,available,496,root/html530/TVirtualGeoPainter.html,https://root.cern,https://root.cern/root/html530/TVirtualGeoPainter.html,5,['avail'],['available']
Availability,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGeoTrack.html:779,avail,available,779,root/html602/TVirtualGeoTrack.html,https://root.cern,https://root.cern/root/html602/TVirtualGeoTrack.html,4,['avail'],['available']
Availability,". TVirtualGeoTrack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » GEOM; » GEOM; » TVirtualGeoTrack. class TVirtualGeoTrack: public TObject, public TGeoAtt, public TAttLine, public TAttMarker. TVirtualGeoTrack - Base class for user-defined tracks attached to a geometry.; Tracks are 3D objects made of points and they store a; pointer to a TParticle. The geometry manager holds a list; of all tracks that will be deleted on destruction of; gGeoManager. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGeoTrack(); voidTObject::AbstractMethod(const char* method) const; virtual Int_tAddDaughter(TVirtualGeoTrack* other); virtual TVirtualGeoTrack*AddDaughter(Int_t id, Int_t pdgcode, TObject* particle = 0); virtual voidAddPoint(Double_t x, Double_t y, Double_t z, Double_t t); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGeoTrack.html:755,avail,available,755,root/html528/TVirtualGeoTrack.html,https://root.cern,https://root.cern/root/html528/TVirtualGeoTrack.html,6,['avail'],['available']
Availability,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::Fin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualGraphPainter.html:549,avail,available,549,root/html602/TVirtualGraphPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualGraphPainter.html,4,['avail'],['available']
Availability,". TVirtualGraphPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualGraphPainter. class TVirtualGraphPainter: public TObject. TVirtualGraphPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualGraphPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual Int_tDistancetoPrimitiveHelper(TGraph* theGraph, Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanelHelper(TGraph* theGraph); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidExecuteEventHelper(TGraph* theGraph, Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualGraphPainter.html:525,avail,available,525,root/html528/TVirtualGraphPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualGraphPainter.html,6,['avail'],['available']
Availability,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualHistPainter.html:545,avail,available,545,root/html602/TVirtualHistPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualHistPainter.html,4,['avail'],['available']
Availability,". TVirtualHistPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » HIST; » HIST; » TVirtualHistPainter. class TVirtualHistPainter: public TObject. TVirtualHistPainter is an abstract interface to a histogram painter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualHistPainter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawPanel(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TList*GetContourList(Double_t contour) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualHistPainter.html:521,avail,available,521,root/html528/TVirtualHistPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualHistPainter.html,6,['avail'],['available']
Availability,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualIndex.html:492,avail,available,492,root/html602/TVirtualIndex.html,https://root.cern,https://root.cern/root/html602/TVirtualIndex.html,4,['avail'],['available']
Availability,". TVirtualIndex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualIndex. class TVirtualIndex: public TNamed. Abstract interface for Tree Index. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIndex(); voidTObject::AbstractMethod(const char* method) const; virtual voidAppend(const TVirtualIndex*, Bool_t delaySort = kFALSE); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualIndex.html:468,avail,available,468,root/html528/TVirtualIndex.html,https://root.cern,https://root.cern/root/html528/TVirtualIndex.html,6,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualIsAProxy.html:438,avail,available,438,root/html528/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html528/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl); TVirtualIsAProxy(); TVirtualIsAProxy(const TVirtualIsAProxy&). Class Charts. Inheritance Chart:. TVirtualIsAProxy. ←. TIsAProxy. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualIsAProxy.html:464,avail,available,464,root/html602/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html602/TVirtualIsAProxy.html,2,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualIsAProxy.html:440,avail,available,440,root/html534/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html534/TVirtualIsAProxy.html,2,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualIsAProxy.html:440,avail,available,440,root/html530/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html530/TVirtualIsAProxy.html,1,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id: TVirtualIsAProxy.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualIsAProxy.html:440,avail,available,440,root/html532/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html532/TVirtualIsAProxy.html,2,['avail'],['available']
Availability,". TVirtualIsAProxy. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualIsAProxy. class TVirtualIsAProxy. TClass. Virtual IsAProxy base class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualIsAProxy(); virtual TClass*operator()(const void* obj); TVirtualIsAProxy&operator=(const TVirtualIsAProxy&); virtual voidSetClass(TClass* cl); TVirtualIsAProxy(); TVirtualIsAProxy(const TVirtualIsAProxy&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualIsAProxy(); { }. void SetClass(TClass* cl). TClass* operator()(const void* obj). » Author: Markus Frank 20/05/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualIsAProxy.html:440,avail,available,440,root/html604/TVirtualIsAProxy.html,https://root.cern,https://root.cern/root/html604/TVirtualIsAProxy.html,2,['avail'],['available']
Availability,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMC.html:973,avail,available,973,root/html602/TVirtualMC.html,https://root.cern,https://root.cern/root/html602/TVirtualMC.html,4,['avail'],['available']
Availability,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual Bool_tDefineIon(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualMC.html:949,avail,available,949,root/html530/TVirtualMC.html,https://root.cern,https://root.cern/root/html530/TVirtualMC.html,5,['avail'],['available']
Availability,". TVirtualMC. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMC. class TVirtualMC: public TNamed. Virtual MC provides a virtual interface to Monte Carlo.; It enables the user to build a virtual Monte Carlo application; independent of any actual underlying Monte Carlo implementation itself. A user will have to implement a class derived from the abstract; Monte Carlo application class, and provide functions like; ConstructGeometry(), BeginEvent(), FinishEvent(), ... .; The concrete Monte Carlo (Geant3, Geant4) is selected at run time -; when processing a ROOT macro where the concrete Monte Carlo is instantiated. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMC(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuildPhysics(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Bool_tCurrentBoundaryNormal(Double_t& x, Double_t& y, Double_t& z) const; virtual Int_tCurrentEvent() const; virtual Int_tCurrentMaterial(Float_t& a, Float_t& z, Float_t& dens, Float_t& radl, Float_t& absl) const; virtual Int_tCurrentMedium() const; virtual Int_tCurrentVolID(Int_t& copyNo) const; virtual const char*CurrentVolName() const; virtual Int_tCurrentVolOffID(Int_t off, Int_t& copyNo) const; virtual const char*CurrentVolOffName(Int_t off) const; virtual const char*CurrentVolPath(); virtual voidDefaultRange()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMC.html:949,avail,available,949,root/html528/TVirtualMC.html,https://root.cern,https://root.cern/root/html528/TVirtualMC.html,1,['avail'],['available']
Availability,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidBeginWorkerRun() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TVirtualMCApplication*CloneForWorker() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCApplication.html:531,avail,available,531,root/html602/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html602/TVirtualMCApplication.html,4,['avail'],['available']
Availability,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidBeginWorkerRun() const; virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual TVirtualMCApplication*CloneForWorker() const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualMCApplication.html:507,avail,available,507,root/html534/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html534/TVirtualMCApplication.html,2,['avail'],['available']
Availability,". TVirtualMCApplication. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCApplication. class TVirtualMCApplication: public TNamed. Interface to a user Monte Carlo application. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCApplication(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddIons(); virtual voidAddParticles(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBeginEvent(); virtual voidBeginPrimary(); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidConstructGeometry(); virtual voidConstructOpGeometry(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidField(const Double_t* x, Double_t* b) const; virtual voidTNamed::FillBuffer(char*& buffer)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCApplication.html:507,avail,available,507,root/html528/TVirtualMCApplication.html,https://root.cern,https://root.cern/root/html528/TVirtualMCApplication.html,4,['avail'],['available']
Availability,". TVirtualMCDecayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TVirtualMCDecayer. class TVirtualMCDecayer: public TObject. Abstract base class for particle decays.; Clients are the transport code and the primary particle generators; This is an abstract base class !. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCDecayer.html:618,avail,available,618,root/html602/TVirtualMCDecayer.html,https://root.cern,https://root.cern/root/html602/TVirtualMCDecayer.html,4,['avail'],['available']
Availability,". TVirtualMCDecayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » EG; » TVirtualMCDecayer. class TVirtualMCDecayer: public TObject. Abstract base class for particle decays.; Clients are the transport code and the primary particle generators; This is an abstract base class !. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCDecayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidDecay(Int_t idpart, TLorentzVector* p); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual voidForceD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCDecayer.html:594,avail,available,594,root/html528/TVirtualMCDecayer.html,https://root.cern,https://root.cern/root/html528/TVirtualMCDecayer.html,6,['avail'],['available']
Availability,". TVirtualMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCGeometry. class TVirtualMCGeometry: public TNamed. Virtual MCGeometry provides a virtual interface to Monte Carlo; geometry construction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCGeometry.html:564,avail,available,564,root/html602/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html602/TVirtualMCGeometry.html,4,['avail'],['available']
Availability,". TVirtualMCGeometry. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCGeometry. class TVirtualMCGeometry: public TNamed. Virtual MCGeometry provides a virtual interface to Monte Carlo; geometry construction. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCGeometry(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCGeometry.html:540,avail,available,540,root/html528/TVirtualMCGeometry.html,https://root.cern,https://root.cern/root/html528/TVirtualMCGeometry.html,6,['avail'],['available']
Availability,". TVirtualMCStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCStack. class TVirtualMCStack: public TObject. Interface to a user defined particles stack. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMCStack.html:514,avail,available,514,root/html602/TVirtualMCStack.html,https://root.cern,https://root.cern/root/html602/TVirtualMCStack.html,4,['avail'],['available']
Availability,". TVirtualMCStack. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MONTECARLO; » VMC; » TVirtualMCStack. class TVirtualMCStack: public TObject. Interface to a user defined particles stack. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMCStack(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetCurrentParentTrackNumber() const; virtual TParticle*GetCurrentTrack() const; virtual Int_tGetCurrentTrackNumber() const; virtual Option_t*TObject::GetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMCStack.html:490,avail,available,490,root/html528/TVirtualMCStack.html,https://root.cern,https://root.cern/root/html528/TVirtualMCStack.html,6,['avail'],['available']
Availability,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualMutex.html:425,avail,available,425,root/html602/TVirtualMutex.html,https://root.cern,https://root.cern/root/html602/TVirtualMutex.html,8,['avail'],['available']
Availability,". TVirtualMutex. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualMutex. class TVirtualMutex: public TObject. TVirtualMutex. This class implements a mutex interface. The actual work is done via; TMutex which is available as soon as the thread library is loaded. and. TLockGuard. This class provides mutex resource management in a guaranteed and; exception safe way. Use like this:; {; TLockGuard guard(mutex);; ... // do something; }; when guard goes out of scope the mutex is unlocked in the TLockGuard; destructor. The exception mechanism takes care of calling the dtors; of local objects so it is exception safe. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualMutex(); voidTObject::AbstractMethod(const char* method) const; Int_tAcquire(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual Int_tCleanUp(); virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualMutex.html:401,avail,available,401,root/html528/TVirtualMutex.html,https://root.cern,https://root.cern/root/html528/TVirtualMutex.html,12,['avail'],['available']
Availability,". TVirtualPS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPS. class TVirtualPS: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TVirtualPS is an abstract interface to a Postscript, PDF and SVG drivers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPS.html:592,avail,available,592,root/html602/TVirtualPS.html,https://root.cern,https://root.cern/root/html602/TVirtualPS.html,4,['avail'],['available']
Availability,". TVirtualPS. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPS. class TVirtualPS: public TNamed, public TAttLine, public TAttFill, public TAttMarker, public TAttText. TVirtualPS is an abstract interface to a Postscript, PDF and SVG drivers. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPS(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidCellArrayBegin(Int_t W, Int_t H, Double_t x1, Double_t x2, Double_t y1, Double_t y2); virtual voidCellArrayEnd(); virtual voidCellArrayFill(Int_t r, Int_t g, Int_t b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual voidClose(Option_t* opt = """"); virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidDrawFrame(Double_t xl, Double_t yl, Double_t xt, Double_t yt, Int_t mode, Int_t border, Int_t dark, Int_t light); virtual voidDrawPolyMarker(Int_t n, Float_t* x, Float_t* y); virtual voidDrawPolyMarker(Int_t n, Double_t* x, Double_t* y); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPS.html:568,avail,available,568,root/html528/TVirtualPS.html,https://root.cern,https://root.cern/root/html528/TVirtualPS.html,6,['avail'],['available']
Availability,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TLegend*BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67000000000000004, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPad.html:589,avail,available,589,root/html602/TVirtualPad.html,https://root.cern,https://root.cern/root/html602/TVirtualPad.html,4,['avail'],['available']
Availability,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TLegend*BuildLegend(Double_t x1 = 0.5, Double_t y1 = 0.67, Double_t x2 = 0.88, Double_t y2 = 0.88, const char* title = """"); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPad.html:565,avail,available,565,root/html534/TVirtualPad.html,https://root.cern,https://root.cern/root/html534/TVirtualPad.html,2,['avail'],['available']
Availability,". TVirtualPad. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPad. class TVirtualPad: public TObject, public TAttLine, public TAttFill, public TAttPad, public TQObject. TVirtualPad is an abstract base class for the Pad and Canvas classes. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPad(); virtual voidAbsCoordinates(Bool_t set); virtual Double_tAbsPixeltoX(Int_t px); virtual Double_tAbsPixeltoY(Int_t py); voidTObject::AbstractMethod(const char* method) const; virtual voidAddExec(const char* name, const char* command); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualPad*cd(Int_t subpadnumber = 0); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* option = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual voidClose(Option_t* option = """"); virtual voidCloseToolTip(TObject* tip); voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPad.html:565,avail,available,565,root/html528/TVirtualPad.html,https://root.cern,https://root.cern/root/html528/TVirtualPad.html,4,['avail'],['available']
Availability,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); TVirtualPadEditor(); TVirtualPadEditor(const TVirtualPadEditor&); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPadEditor.html:523,avail,available,523,root/html602/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html602/TVirtualPadEditor.html,4,['avail'],['available']
Availability,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPadEditor.html:499,avail,available,499,root/html528/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html528/TVirtualPadEditor.html,4,['avail'],['available']
Availability,". TVirtualPadEditor. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadEditor. class TVirtualPadEditor. TVirtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Membe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPadEditor.html:499,avail,available,499,root/html534/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html534/TVirtualPadEditor.html,2,['avail'],['available']
Availability,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t enableAlphaBlending); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPadPainter.html:457,avail,available,457,root/html602/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html602/TVirtualPadPainter.html,4,['avail'],['available']
Availability,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPixels(const unsigned char* pixelData, UInt_t width, UInt_t height, Int_t dstX, Int_t dstY, Bool_t alphaBlending); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawText(Double_t x, Double_t y, const wchar_t* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const wchar_t* text, TVirtualPadPainter::ETextMode mode)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPadPainter.html:433,avail,available,433,root/html534/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html534/TVirtualPadPainter.html,2,['avail'],['available']
Availability,". TVirtualPadPainter. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPadPainter. class TVirtualPadPainter. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadPainter(); static TClass*Class(); virtual voidClearDrawable(); virtual voidCopyDrawable(Int_t device, Int_t px, Int_t py); virtual Int_tCreateDrawable(UInt_t w, UInt_t h); virtual voidDestroyDrawable(); virtual voidDrawBox(Double_t x1, Double_t y1, Double_t x2, Double_t y2, TVirtualPadPainter::EBoxMode mode); virtual voidDrawFillArea(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawFillArea(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawLine(Double_t x1, Double_t y1, Double_t x2, Double_t y2); virtual voidDrawLineNDC(Double_t u1, Double_t v1, Double_t u2, Double_t v2); virtual voidDrawPolyLine(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyLine(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawPolyLineNDC(Int_t n, const Double_t* u, const Double_t* v); virtual voidDrawPolyMarker(Int_t n, const Double_t* x, const Double_t* y); virtual voidDrawPolyMarker(Int_t n, const Float_t* x, const Float_t* y); virtual voidDrawText(Double_t x, Double_t y, const char* text, TVirtualPadPainter::ETextMode mode); virtual voidDrawTextNDC(Double_t u, Double_t v, const char* text, TVirtualPadPainter::ETextMode mode); virtual Color_tGetFillColor() const; virtual Style_tGetFillStyle() const; virtual Color_tGetLineColor() const; virtual Style_tGetLineStyle() const; virtual Width_tGetLineWidth() const; virtual Short_tGetTextAlign() const; virtual Float_tGetTextAngle() const; virtual Color_tGetTextColor() const; virtual Font_tGetTextFont() const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPadPainter.html:433,avail,available,433,root/html528/TVirtualPadPainter.html,https://root.cern,https://root.cern/root/html528/TVirtualPadPainter.html,4,['avail'],['available']
Availability,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPerfStats.html:578,avail,available,578,root/html602/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html602/TVirtualPerfStats.html,4,['avail'],['available']
Availability,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; static TVirtualPerfStats*&CurrentPerfStats(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:554,avail,available,554,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,2,['avail'],['available']
Availability,". TVirtualPerfStats. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualPerfStats. class TVirtualPerfStats: public TObject. TVirtualPerfStats. Provides the interface for the PROOF internal performance measurment; and event tracing. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPerfStats(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; static const char*EventType(TVirtualPerfStats::EEventType type); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidFileEvent(const char* slave, const char* slavename, const char* nodename, const char* filename, Bool_t isStart); virtual voidFileOpenEvent(TFile* file, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualPerfStats.html:554,avail,available,554,root/html528/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html528/TVirtualPerfStats.html,4,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual voidTO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualProofPlayer.html:574,avail,available,574,root/html528/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualProofPlayer.html,1,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const char*); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualProofPlayer.html:576,avail,available,576,root/html530/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html530/TVirtualProofPlayer.html,5,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualProofPlayer.html:624,avail,available,624,root/html602/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualProofPlayer.html,2,['avail'],['available']
Availability,". TVirtualProofPlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOF; » TVirtualProofPlayer. class TVirtualProofPlayer: public TObject, public TQObject. TVirtualProofPlayer. Abstract interface for the PROOF player.; See the concrete implementations under 'proofplayer' for details. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualProofPlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddEventsProcessed(Long64_t ev); virtual voidAddInput(TObject* inp); virtual voidAddOutput(TList* out); virtual Int_tAddOutputObject(TObject* obj); virtual voidAddQueryResult(TQueryResult* q); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual voidClearInput(); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualProofPlayer.html:600,avail,available,600,root/html604/TVirtualProofPlayer.html,https://root.cern,https://root.cern/root/html604/TVirtualProofPlayer.html,2,['avail'],['available']
Availability,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(TFile* file = 0); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualStreamerInfo.html:591,avail,available,591,root/html602/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TVirtualStreamerInfo.html,4,['avail'],['available']
Availability,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualStreamerInfo.html:567,avail,available,567,root/html528/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html528/TVirtualStreamerInfo.html,4,['avail'],['available']
Availability,". TVirtualStreamerInfo. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » CORE; » META; » TVirtualStreamerInfo. class TVirtualStreamerInfo: public TNamed. TVirtualStreamerInfo Abstract Interface class. Abstract Interface describing Streamer information for one class. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualStreamerInfo(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual voidBuild(); virtual voidBuildCheck(TFile* file = 0); virtual voidBuildEmulated(TFile* file); virtual Bool_tBuildFor(const TClass* cl); virtual voidBuildOld(); virtual voidCallShowMembers(void* obj, TMemberInspector& insp) const; static Bool_tCanDelete(); static Bool_tCanOptimize(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t*); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Bool_tCompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); virtual voidCompile(); virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDeleteArray(void* p, Bool_t dtorOnly = kFALSE); virtual voidDestructor(void* p, Bool_t dtorOnly = kFALSE); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; vir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualStreamerInfo.html:567,avail,available,567,root/html534/TVirtualStreamerInfo.html,https://root.cern,https://root.cern/root/html534/TVirtualStreamerInfo.html,2,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Thu Sep 23 20:22:29 2010 » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualTableInterface.html:419,avail,available,419,root/html528/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html528/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; inheritance tree (.pdf) viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualTableInterface(); TVirtualTableInterface(const TVirtualTableInterface&). Class Charts. Inheritance Chart:. TVirtualTableInterface. ←. TGSimpleTableInterface. TTreeTableInterface. Function documentation; TVirtualTableInterface(); {;}. virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Jun 30 15:32:41 2015 » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualTableInterface.html:445,avail,available,445,root/html602/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html602/TVirtualTableInterface.html,2,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TVirtualTableInterface(); TVirtualTableInterface(const TVirtualTableInterface&). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualTableInterface(); {;}. virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:49:49 2015 » Last generated: 2015-09-08 17:49; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TVirtualTableInterface.html:421,avail,available,421,root/html604/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html604/TVirtualTableInterface.html,2,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Mon Jul 4 15:38:58 2011 » Last generated: 2011-07-04 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TVirtualTableInterface.html:421,avail,available,421,root/html530/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html530/TVirtualTableInterface.html,1,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Thu Nov 3 20:24:17 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TVirtualTableInterface.html:421,avail,available,421,root/html532/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html532/TVirtualTableInterface.html,2,['avail'],['available']
Availability,". TVirtualTableInterface. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » TVirtualTableInterface. class TVirtualTableInterface. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTableInterface(); static TClass*Class(); virtual const char*GetColumnHeader(UInt_t column); virtual UInt_tGetNColumns(); virtual UInt_tGetNRows(); virtual const char*GetRowHeader(UInt_t row); virtual Double_tGetValue(UInt_t row, UInt_t column); virtual const char*GetValueAsString(UInt_t row, UInt_t column); virtual TClass*IsA() const; TVirtualTableInterface&operator=(const TVirtualTableInterface&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~TVirtualTableInterface(); {;}. Double_t GetValue(UInt_t row, UInt_t column). const char * GetValueAsString(UInt_t row, UInt_t column). const char * GetRowHeader(UInt_t row). const char * GetColumnHeader(UInt_t column). UInt_t GetNRows(). UInt_t GetNColumns(). » Author: Roel Aaij 21/07/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: Tue Sep 8 17:05:53 2015 » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualTableInterface.html:421,avail,available,421,root/html534/TVirtualTableInterface.html,https://root.cern,https://root.cern/root/html534/TVirtualTableInterface.html,2,['avail'],['available']
Availability,". TVirtualTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualTreePlayer. class TVirtualTreePlayer: public TObject. TVirtualTreePlayer. Abstract base class defining the interface for the plugins that; implement Draw, Scan, Process, MakeProxy, etc. for a TTree object.; See the individual documentations in TTree. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualTreePlayer.html:670,avail,available,670,root/html602/TVirtualTreePlayer.html,https://root.cern,https://root.cern/root/html602/TVirtualTreePlayer.html,4,['avail'],['available']
Availability,". TVirtualTreePlayer. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » TREE; » TREE; » TVirtualTreePlayer. class TVirtualTreePlayer: public TObject. TVirtualTreePlayer. Abstract base class defining the interface for the plugins that; implement Draw, Scan, Process, MakeProxy, etc. for a TTree object.; See the individual documentations in TTree. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualTreePlayer(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); virtual TVirtualIndex*BuildIndex(const TTree* T, const char* majorname, const char* minorname); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual TTree*CopyTree(const char* selection, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual Long64_tDrawScript(const char* wrapperPrefix, const char* macrofilename, const char* cutfilename, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual Long64_tDrawSelect(const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); virtual voidTObject::Dump() constMENU ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualTreePlayer.html:646,avail,available,646,root/html528/TVirtualTreePlayer.html,https://root.cern,https://root.cern/root/html528/TVirtualTreePlayer.html,6,['avail'],['available']
Availability,". TVolumeView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TVolumeView. class TVolumeView: public TObjectSet, public TAtt3D. TVolumeView. TVolumeView class is a special kind of TDataSet with one extra; pointer to wrap any TObject onto TDataSet object. BE CAREFUL !!!; One has to use it carefully no control over that extra object; is performed. This means: the object m_Obj data-member points to can; be destroyed with no this kbject notifying.; There is no tool /protection to check whether m_Obj is till alive.; It is one's code responsilitiy. Function Members (Methods); public:. virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObject(TObject* obj, Bool_t makeOwner = kTRUE); virtual voidTObject::AppendPad(Option_t* option = """"); TDataSet*TDataSet::At(Int_t idx) const; virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TDataSet::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObjectSet::Delete(Option_t* opt = """"); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual Bool_tTObjectSet::DoOwner(Bool_t done = kTRUE); virtual voidDraw(Option_t* depth = ""3"")MENU ; virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVolumeView.html:718,alive,alive,718,root/html602/TVolumeView.html,https://root.cern,https://root.cern/root/html602/TVolumeView.html,4,['alive'],['alive']
Availability,". TVolumeView. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » MISC; » TABLE; » TVolumeView. class TVolumeView: public TObjectSet, public TAtt3D. TVolumeView. TVolumeView class is a special kind of TDataSet with one extra; pointer to wrap any TObject onto TDataSet object. BE CAREFUL !!!; One has to use it carefully no control over that extra object; is performed. This means: the object m_Obj data-member points to can; be destroyed with no this kbject notifying.; There is no tool /protection to check whether m_Obj is till alive.; It is one's code responsilitiy. Function Members (Methods); public:. TVolumeView(); TVolumeView(TVolumeView* viewNode, TVolumePosition* nodePosition = 0); TVolumeView(TVolumeView* viewNode, TVolumeView* topNode); TVolumeView(TVolume* thisNode, TVolumePosition* nodePosition); TVolumeView(TVolumeView* viewNode, const Char_t* NodeName1, const Char_t* NodeName2 = 0); TVolumeView(TVolumeView* viewNode, const TVolumeView* node1, const TVolumeView* node2); TVolumeView(TVolume& pattern, Int_t maxDepLevel = 0, const TVolumePosition* nodePosition = 0, TDataSet::EDataSetPass iopt = kMarked, TVolumeView* root = 0); TVolumeView(Double_t* translate, Double_t* rotate, UInt_t positionId, TVolume* thisNode, const Char_t* thisNodePath, const Char_t* matrixName = 0, Int_t matrixType = 0); virtual~TVolumeView(); voidTObject::AbstractMethod(const char* method) const; virtual voidAdd(TDataSet* dataset); virtual voidAdd(TVolumeView* node); virtual voidAdd(TShape* shape, Bool_t IsMaster = kFALSE); virtual voidTDataSet::AddAt(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddAtAndExpand(TDataSet* dataset, Int_t idx = 0); virtual voidTDataSet::AddFirst(TDataSet* dataset); virtual voidTDataSet::AddLast(TDataSet* dataset); virtual TVolume*AddNode(TVolume* node); virtual TObject*TObjectSet::AddObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVolumeView.html:694,alive,alive,694,root/html528/TVolumeView.html,https://root.cern,https://root.cern/root/html528/TVolumeView.html,6,['alive'],['alive']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TXHandler(); TXHandler(const TXHandler&). Class Charts. Inheritance Chart:. TXHandler. ←. TXProofMgr. TXProofServ. TXSlave. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-02 16:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXHandler.html:1124,error,error,1124,root/html604/TXHandler.html,https://root.cern,https://root.cern/root/html604/TXHandler.html,2,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TXHandler(); TXHandler(const TXHandler&). Class Charts. Inheritance Chart:. TXHandler. ←. TXProofMgr. TXProofServ. TXSlave. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-06-30 15:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXHandler.html:1124,error,error,1124,root/html602/TXHandler.html,https://root.cern,https://root.cern/root/html602/TXHandler.html,2,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXHandler.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXHandler.html:1055,error,error,1055,root/html528/TXHandler.html,https://root.cern,https://root.cern/root/html528/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXHandler.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXHandler.html:1055,error,error,1055,root/html530/TXHandler.html,https://root.cern,https://root.cern/root/html530/TXHandler.html,1,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector& insp); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id: TXHandler.h 30815 2009-10-20 13:49:22Z rdm $ » Last generated: 2011-12-02 14:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXHandler.html:1055,error,error,1055,root/html532/TXHandler.html,https://root.cern,https://root.cern/root/html532/TXHandler.html,2,['error'],['error']
Availability,". TXHandler. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » PROOF; » PROOFX; » TXHandler. class TXHandler. TXHandler. Handler of asynchronous events for xproofd sockets.; Classes needing this should inherit from this and overload the; relevant methods. Function Members (Methods); public:. TXHandler(); TXHandler(const TXHandler&); virtual~TXHandler(); static TClass*Class(); virtual Bool_tHandleError(const void* in = 0); virtual Bool_tHandleInput(const void* in = 0); virtual TClass*IsA() const; TXHandler&operator=(const TXHandler&); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t HandleInput(const void* in = 0); Handler of asynchronous input events. Bool_t HandleError(const void* in = 0); Handler of asynchronous error events. TXHandler(); { }. virtual ~TXHandler(); { }. » Author: G. Ganis Mar 2006 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXHandler.html:1074,error,error,1074,root/html534/TXHandler.html,https://root.cern,https://root.cern/root/html534/TXHandler.html,2,['error'],['error']
Availability,". TXMLParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TXMLParser. class TXMLParser: public TObject, public TQObject. TXMLParser. TXMLParser is an abstract class which interfaces with Libxml2.; Libxml2 is the XML C parser and toolkit developed for the Gnome; project. The libxml library provides two interfaces to the parser, a DOM; style tree interface and a SAX style event based interface. TXMLParser is parent class of TSAXParser and TDOMParser, which are; a SAX interface and DOM interface of libxml. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TXMLParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXMLParser.html:857,avail,available,857,root/html602/TXMLParser.html,https://root.cern,https://root.cern/root/html602/TXMLParser.html,4,['avail'],['available']
Availability,". TXMLParser. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » IO; » XMLPARSER; » TXMLParser. class TXMLParser: public TObject, public TQObject. TXMLParser. TXMLParser is an abstract class which interfaces with Libxml2.; Libxml2 is the XML C parser and toolkit developed for the Gnome; project. The libxml library provides two interfaces to the parser, a DOM; style tree interface and a SAX style event based interface. TXMLParser is parent class of TSAXParser and TDOMParser, which are; a SAX interface and DOM interface of libxml. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TXMLParser(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Compare(const TObject* obj) const; Bool_tTQObject::Connect(const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(TQObject* sender, const char* signal, const char* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::Connect(const char* sender_class, const char* signal, const char* receiver_class, void* receiver, const char* slot); virtual voidTQObject::Connected(const cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXMLParser.html:833,avail,available,833,root/html528/TXMLParser.html,https://root.cern,https://root.cern/root/html528/TXMLParser.html,6,['avail'],['available']
Availability,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; inheritance tree (.pdf) viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:722,toler,tolerance,722,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,3,"['Fault', 'toler']","['Fault', 'tolerance']"
Availability,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. TXNetFile(); TXNetFile(const char* url, Option_t* option = """", const char* fTitle = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE, const char* logicalurl = 0); virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:698,toler,tolerance,698,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,8,"['Fault', 'toler']","['Fault', 'tolerance']"
Availability,". TXNetFile. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; source file; viewVC header viewVC source. Sections:; class description; function members; data members; class charts. ROOT; » NET; » NETX; » TXNetFile. class TXNetFile: public TNetFile. TXNetFile. Authors: Alvise Dorigo, Fabrizio Furano; INFN Padova, 2003; Interfaced to the standalone client (XrdClient): G. Ganis, CERN. TXNetFile is an extension of TNetFile able to deal with new xrootd; server. Its new features are:; - Automatic server kind recognition (xrootd load balancer, xrootd; data server, old rootd); - Backward compatibility with old rootd server (acts as an old; TNetFile); - Fault tolerance for read/write operations (read/write timeouts; and retry); - Internal connection timeout (tunable indipendently from the OS; one) handled by threads; - handling of redirections from server; - Single TCP physical channel for multiple TXNetFile's instances; inside the same application; So, each TXNetFile object client must send messages containing; its ID (streamid). The server, of course, will respond with; messages containing the client's ID, in order to make the client; able to recognize its message by matching its streamid with that; one contained in the server's response.; - Tunable log verbosity level (0 = nothing, 3 = dump read/write; buffers too!); - Many parameters configurable via TEnv facility (see SetParm(); methods). Function Members (Methods); public:. virtual~TXNetFile(); voidTObject::AbstractMethod(const char* method) const; virtual voidTDirectoryFile::Add(TObject* obj, Bool_t replace = kFALSE); static voidTDirectory::AddDirectory(Bool_t add = kTRUE); static Bool_tTDirectory::AddDirectoryStatus(); virtual voidTDirectoryFile::Append(TObject* obj, Bool_t replace = kFALSE); virtual Int_tTDirectoryFile::AppendKey(TKey* key); virtual voidTObject::AppendPad(Option_t* option = """"); static TFileOpenHandle*TFile::AsyncOpen(const char* name, Option_t* option = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXNetFile.html:698,toler,tolerance,698,root/html604/TXNetFile.html,https://root.cern,https://root.cern/root/html604/TXNetFile.html,3,"['Fault', 'toler']","['Fault', 'tolerance']"
Availability,". The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effects, by changing global; ROOT state via, e.g. gSystem calls, etc. However, in specific cases; this might be useful, e.g. adding a library search path, adding a specific; dependency, check on some OS or ROOT capability or downloading; of the plugin. void AddHandler(const char* base, const char* regexp, const char* className, const char* pluginName, const char* ctor = 0, const char* origin = 0); Add plugin handler to the list of handlers. If there is already a; handler defined for the same base and regexp it will be replaced. void RemoveHandler(const char* base, const char* regexp = 0); Remove handler for the specified base class and the specified; regexp. If regexp=0 remove all handlers for the specified base. TPluginHandler * FindHandler(const char* base, const char* uri = 0); Returns the handler if there exists a handler for the specified URI.; The uri can be 0 in which case the first matching plugin handler; will be returned. Returns 0 in case handler is not found. void Print(Option_t* opt = """") const; Print list of registered plugin handlers. If option is ""a"" print; also the ctor's that will be used. Int_t WritePluginMacros(const char* dir, const char* plugin = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TPluginManager.html:10687,down,downloading,10687,root/html528/TPluginManager.html,https://root.cern,https://root.cern/root/html528/TPluginManager.html,10,['down'],['downloading']
Availability,". The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this function is not called if the static member fgReadInfo is false. (see TFile::SetReadStreamerInfo) ; Definition at line 3605 of file TFile.cxx. ◆ Recover(). Int_t TFile::Recover ; (; ). virtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is important to save the Tree header at regular intervals (see TTree::AutoSave). If a file containing a Tree is recovered, the last Tree header written to the file will be used. In this case all the entries in all the branches written before writing the header are valid entries. One can disable the automatic recovery procedure by setting TFile.Recover 0; in the sys",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:89148,recover,recover,89148,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['recover'],['recover']
Availability,". The most common change, namely where to find; 2791/// header files, will be available through the function; 2792/// TSystem::SetIncludePath().; 2793/// A good default will be provided so that a typical user session should be at; 2794/// most:; 2795/// ~~~ {.cpp}; 2796/// root[1] gSystem->SetIncludePath(""-I$ROOTSYS/include; 2797/// -I$HOME/mypackage/include"");; 2798/// root[2] .x myfunc.C++(10,20);; 2799/// ~~~; 2800/// The user may sometimes try to compile a script before it has loaded all the; 2801/// needed shared libraries. In this case we want to be helpful and output a; 2802/// list of the unresolved symbols. So if the loading of the created shared; 2803/// library fails, we will try to build a executable that contains the; 2804/// script. The linker should then output a list of missing symbols.; 2805///; 2806/// To support this we provide a TSystem::SetMakeExe() function, that sets the; 2807/// directive telling how to create an executable. The loader will need; 2808/// to be informed of all the libraries available. The information about; 2809/// the libraries that has been loaded by .L and TSystem::Load() is accessible; 2810/// to the script compiler. However, the information about; 2811/// the libraries that have been selected at link time by the application; 2812/// builder (like the root libraries for root.exe) are not available and need; 2813/// to be explicitly listed in fLinkedLibs (either by default or by a call to; 2814/// TSystem::SetLinkedLibs()).; 2815///; 2816/// To simplify customization we could also add to the .rootrc support for the; 2817/// variables; 2818/// ~~~ {.cpp}; 2819/// Unix.*.Root.IncludePath: -I$ROOTSYS/include; 2820/// WinNT.*.Root.IncludePath: -I%ROOTSYS%/include; 2821///; 2822/// Unix.*.Root.LinkedLibs: -L$ROOTSYS/lib -lBase ....; 2823/// WinNT.*.Root.LinkedLibs: %ROOTSYS%/lib/*.lib msvcrt.lib ....; 2824/// ~~~; 2825/// And also support for MakeSharedLibs() and MakeExe().; 2826///; 2827/// (the ... have to be replaced by the ac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:92586,avail,available,92586,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['avail'],['available']
Availability,". This function calls the RLoopManager::Run method on the fLoopManager data member of the input argument. It is intended for internal use only. ; Definition at line 38 of file RInterface.cxx. ◆ TTreeAsFlatMatrix(). template<typename BufType , typename... ColTypes, std::size_t... Idx> . void ROOT::Internal::RDF::TTreeAsFlatMatrix ; (; std::index_sequence< Idx... > ; , . TTree & ; tree, . std::vector< BufType > & ; matrix, . std::vector< std::string > & ; columns . ). Definition at line 40 of file PyROOTHelpers.hxx. ◆ TTreeAsFlatMatrixHelper(). template<typename BufType , typename... ColTypes> . void ROOT::Internal::RDF::TTreeAsFlatMatrixHelper ; (; TTree & ; tree, . std::vector< BufType > & ; matrix, . std::vector< std::string > & ; columns . ). Definition at line 58 of file PyROOTHelpers.hxx. ◆ TypeID2TypeName(). std::string ROOT::Internal::RDF::TypeID2TypeName ; (; const std::type_info & ; id). Returns the name of a type starting from its type_info An empty string is returned in case of failure References and pointers are not supported since those cannot be stored in columns. ; Note that this function will take a lock and may be a potential source of contention in multithreaded execution. ; Definition at line 119 of file RDFUtils.cxx. ◆ TypeName2ROOTTypeName(). char ROOT::Internal::RDF::TypeName2ROOTTypeName ; (; const std::string & ; b). Convert type name (e.g. ; ""Float_t"") to ROOT type code (e.g. 'F') – see TBranch documentation. Return a space ' ' in case no match was found. ; Definition at line 259 of file RDFUtils.cxx. ◆ TypeName2TypeID(). const std::type_info & ROOT::Internal::RDF::TypeName2TypeID ; (; const std::string & ; name). Return the type_info associated to a name. ; If the association fails, an exception is thrown. References and pointers are not supported since those cannot be stored in columns. ; Definition at line 62 of file RDFUtils.cxx. ◆ Union(). template<typename T > . std::vector< T > ROOT::Internal::RDF::Union ; (; const std::vector< T > & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html:42056,failure,failure,42056,doc/master/namespaceROOT_1_1Internal_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Internal_1_1RDF.html,1,['failure'],['failure']
Availability,". To change the file name use File menu / Save As... or corresponding SaveAs button on the toolbar.; Text Selection; You can move the cursor by simply clicking on the desired location with the left mouse button. To highlight some text, press the mouse and drag the mouse while holding the left button pressed. To select a word, double-click on it; to select the text line - triple-click on it; to select all do quadruple-click.; Cut, Copy, Paste; After selecting some text, you can cut or copy it to the clipboard. A subsequent paste operation will insert the contents of the clipboard at the current cursor location.; Text Search; The editor uses a standard Search dialog. You can specify a forward or backward search direction starting from the current cursor location according to the selection made of a case sensitive mode or not. The last search can be repeated by pressing F3.; Text Font; You can change the text font by selecting Edit menu / Set Font. The Font Dialog pops up and shows the Name, Style, and Size of any available font. The selected font sample is shown in the preview area.; Executing Macros; You can execute the currently loaded macro in the editor by selecting Tools menu / Execute Macro; by clicking on the corresponding toolbar button, or by using Ctrl+F5 accelerator keys. This is identical to the command "".x macro.C"" in the root prompt command line.; Compiling Macros; The currently loaded macro can be compiled with ACLiC if you select Tools menu / Compile Macro; by clicking on the corresponding toolbar button, or by using Ctrl+F7 accelerator keys. This is identical to the command "".L macro.C++"" in the root prompt command line.; Interrupting a Running Macro; You can interrupt a running macro by selecting the Tools menu / Interrupt; by clicking on the corresponding toolbar button, or by using Shift+F5 accelerator keys.; Interface to CINT Interpreter; Any command entered in the Command combo box will be passed to the CINT interpreter. This combo box will keep t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGTextEditor.html:2340,avail,available,2340,doc/master/classTGTextEditor.html,https://root.cern,https://root.cern/doc/master/classTGTextEditor.html,1,['avail'],['available']
Availability,". UInt_t TSocket::GetBytesRecv ; (; ); const. inline . Definition at line 120 of file TSocket.h. ◆ GetBytesSent(). UInt_t TSocket::GetBytesSent ; (; ); const. inline . Definition at line 119 of file TSocket.h. ◆ GetClientProtocol(). Int_t TSocket::GetClientProtocol ; (; ). static . Static method returning supported client protocol. ; Definition at line 1469 of file TSocket.cxx. ◆ GetCompressionAlgorithm(). Int_t TSocket::GetCompressionAlgorithm ; (; ); const. inline . Definition at line 175 of file TSocket.h. ◆ GetCompressionLevel(). Int_t TSocket::GetCompressionLevel ; (; ); const. inline . Definition at line 181 of file TSocket.h. ◆ GetCompressionSettings(). Int_t TSocket::GetCompressionSettings ; (; ); const. inline . Definition at line 187 of file TSocket.h. ◆ GetDescriptor(). virtual Int_t TSocket::GetDescriptor ; (; ); const. inlinevirtual . Reimplemented in TPSocket.; Definition at line 112 of file TSocket.h. ◆ GetErrorCode(). Int_t TSocket::GetErrorCode ; (; ); const. Returns error code. ; Meaning depends on context where it is called. If no error condition returns 0 else a value < 0. For example see TServerSocket ctor. ; Definition at line 1035 of file TSocket.cxx. ◆ GetInetAddress(). TInetAddress TSocket::GetInetAddress ; (; ); const. inline . Definition at line 113 of file TSocket.h. ◆ GetLastUsage(). TTimeStamp TSocket::GetLastUsage ; (; ). inline . Definition at line 129 of file TSocket.h. ◆ GetLocalInetAddress(). TInetAddress TSocket::GetLocalInetAddress ; (; ). virtual . Return internet address of local host to which the socket is bound. ; In case of error TInetAddress::IsValid() returns kFALSE. ; Reimplemented in TPSocket, and TServerSocket.; Definition at line 409 of file TSocket.cxx. ◆ GetLocalPort(). Int_t TSocket::GetLocalPort ; (; ). virtual . Return the local port # to which the socket is bound. ; In case of error return -1. ; Reimplemented in TServerSocket.; Definition at line 423 of file TSocket.cxx. ◆ GetOption() [1/2]. Option_t * TSocket::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSocket.html:27484,error,error,27484,doc/master/classTSocket.html,https://root.cern,https://root.cern/doc/master/classTSocket.html,1,['error'],['error']
Availability,". UInt_t ; h . ). virtual . Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ; GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1913 of file TVirtualX.cxx. ◆ DrawSegments(). void TVirtualX::DrawSegments ; (; Drawable_t ; id, . GContext_t ; gc, . Segment_t * ; seg, . Int_t ; nseg . ). virtual . Draws multiple line segments. ; Each line is specified by a pair of points.; Parameters. [in]idDrawable identifier ; [in]gcgraphics context ; [in]*segspecifies an array of segments ; [in]nsegspecifies the number of segments in the array. GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, and dash-list. (see also the GCValues_t structure) ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1935 of file TVirtualX.cxx. ◆ DrawString(). void TVirtualX::DrawString ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . const char * ; s, . Int_t ; len . ). virtual . Each character image, as defined by the font in the GC, is treated as an additional mask for a fill operation on the drawable. ; Parameters. [in]idthe drawable ; [in]gcthe GC ; [in]x,ycoordinates, which are relative to the origin of the specified drawable and define the origin of the first character ; [in]sthe character string ; [in]lenthe number of characters in the string argument. GC components in use: function, plane-mask, fill-style, font, subwindow-mod",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:74696,mask,mask,74696,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,2,['mask'],['mask']
Availability,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionAlgorithm(Int_t algorithm = 0); See comments for function SetCompressionSettings. void SetCompressionLevel(Int_t level = 1); See comments for function SetCompressionSettings. void SetCompressionSettings(Int_t settings = 1); Used to specify the compression level and algorithm:; settings = 100 * algorithm + level. level = 0, objects written to this file will not be compressed.; level = 1, minimal compression level but fast. level = 9, maximal compression level but slower and might use more memory.; (For the currently supported algorithms, the maximum level is 9); If compress is negative it indicates the compression level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSocket.html:19251,error,error,19251,root/html530/TSocket.html,https://root.cern,https://root.cern/root/html530/TSocket.html,17,['error'],['error']
Availability,". Using option kPeek; one can peek at incoming data. Returns number of received bytes.; Returns -1 in case of error. In case of opt == kOob: -2 means; EWOULDBLOCK and -3 EINVAL. In case of non-blocking mode (kNoBlock); -4 means EWOULDBLOCK. Returns -5 if pipe broken or reset by; peer (EPIPE || ECONNRESET). Bool_t RecvStreamerInfos(TMessage* mess); Receive a message containing streamer infos. In case the message contains; streamer infos they are imported, the message will be deleted and the; method returns kTRUE. Bool_t RecvProcessIDs(TMessage* mess); Receive a message containing process ids. In case the message contains; process ids they are imported, the message will be deleted and the; method returns kTRUE. Int_t SetOption(ESockOptions opt, Int_t val); Set socket options. Int_t GetOption(ESockOptions opt, Int_t& val); Get socket options. Returns -1 in case of error. Int_t GetErrorCode() const; Returns error code. Meaning depends on context where it is called.; If no error condition returns 0 else a value < 0.; For example see TServerSocket ctor. void SetCompressionLevel(Int_t level = 1); Set the message compression level. Can be between 0 and 9 with 0; being no compression and 9 maximum compression. In general the default; level of 1 is the best compromise between achieved compression and; cpu time. Compression will only happen when the message is > 256 bytes. Bool_t Authenticate(const char* user); Authenticated the socket with specified user. TSocket * CreateAuthSocket(const char* url, Int_t size = 0, Int_t tcpwindowsize = -1, TSocket* s = 0); Creates a socket or a parallel socket and authenticates to the; remote server. url: [[proto][p][auth]://][user@]host[:port][/service][?options]. where proto = ""sockd"", ""rootd"", ""proofd""; indicates the type of remote server;; if missing ""sockd"" is assumed (""sockd"" indicates; any remote server session using TServerSocket); [p] = for parallel sockets (forced internally for; rootd; ignored for proofd); [auth] = ""up"", ""s"", ""k"", """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSocket.html:18974,error,error,18974,root/html528/TSocket.html,https://root.cern,https://root.cern/root/html528/TSocket.html,1,['error'],['error']
Availability,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4236 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:75871,error,errors,75871,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['errors']
Availability,". Warnings(bool flag) Enable or disable MINUIT warnings (enabled by default) . PrintEvalErrors(Int_t numErr) Control number of p.d.f evaluation errors printed per likelihood evaluation. A negative value suppress output completely, a zero value will only print the error count per p.d.f component, a positive value is will print details of each error up to numErr messages per p.d.f component. . PyROOT; The RooAbsReal::chi2FitTo() function is pythonized with the command argument pythonization. The keywords must correspond to the CmdArgs of the function. . Definition at line 4312 of file RooAbsReal.cxx. ◆ chi2FitTo() [4/4]. RooFit::OwningPtr< RooFitResult > RooAbsReal::chi2FitTo ; (; RooDataSet & ; xydata, . const RooLinkedList & ; cmdList . ). virtual . Perform a 2-D \( \chi^2 \) fit using a series of x and y values stored in the dataset xydata. ; The y values can either be the event weights, or can be another column designated by the YVar() argument. The y value must have errors defined for the \( \chi^2 \) to be well defined. Options to control construction of the chi-square . YVar(RooRealVar& yvar) Designate given column in dataset as Y value . Integrate(bool flag) Integrate function over range specified by X errors rather than take value at bin center. Options to control flow of fit procedure . InitialHesse(bool flag) Flag controls if HESSE before MIGRAD as well, off by default . Hesse(bool flag) Flag controls if HESSE is run after MIGRAD, on by default . Minos(bool flag) Flag controls if MINOS is run after HESSE, on by default . Minos(const RooArgSet& set) Only run MINOS on given subset of arguments . Save(bool flag) Flag controls if RooFitResult object is produced and returned, off by default . Strategy(Int_t flag) Set Minuit strategy (0 through 2, default is 1). Options to control informational output . Verbose(bool flag) Flag controls if verbose output is printed (NLL, parameter changes during fit . Timer(bool flag) Time CPU and wall clock consumption of fit ste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:77139,error,errors,77139,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['errors']
Availability,". We use NULL to mean not set, so we don't want to fill; with empty RooArgSets. void Print(Option_t* option = """") const; print contents of Model on the default print stream; It can be changed using RooPrintable. void SetWS(RooWorkspace& ws); set a workspace that owns all the necessary components for the analysis. RooWorkspace * GetWS() const; get from TRef. void SetSnapshot(const RooArgSet& set); save snaphot in the workspace; and use values passed with the set. const RooArgSet * GetSnapshot() const; Load the snapshot from ws and return the corresponding set with the snapshot values.; User must delete returned RooArgSet. void LoadSnapshot() const; load the snapshot from ws if it exists. void DefineSetInWS(const char* name, const RooArgSet& set); helper functions to avoid code duplication. void ImportPdfInWS(const RooAbsPdf& pdf); internal function to import Pdf in WS. void ImportDataInWS(RooAbsData& data); internal function to import data in WS. Bool_t SetHasOnlyParameters(const RooArgSet& set, const char* errorMsgPrefix = 0). ModelConfig(RooWorkspace* ws = 0). ModelConfig(const char* name, RooWorkspace* ws = 0). ModelConfig(const char* name, const char* title, RooWorkspace* ws = 0). ModelConfig * Clone(const char* name = """") const; clone. void SetWorkspace(RooWorkspace& ws); alias for SetWS(...). { SetWS(ws); }. void SetProtoData(RooAbsData& data); Set the proto DataSet, add to the the workspace if not already there. SetProtoData(const char* name). void SetPdf(const RooAbsPdf& pdf); Set the Pdf, add to the the workspace if not already there. SetPdf(const char* name). void SetPriorPdf(const RooAbsPdf& pdf); Set the Prior Pdf, add to the the workspace if not already there. SetPriorPdf(const char* name). void SetParameters(const RooArgSet& set); specify the parameters of interest in the interval. void SetParametersOfInterest(const RooArgSet& set). SetParameters(const char* argList). void SetParametersOfInterest(const char* argList). void SetNuisanceParameters(const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__ModelConfig.html:9931,error,errorMsgPrefix,9931,root/html534/RooStats__ModelConfig.html,https://root.cern,https://root.cern/root/html534/RooStats__ModelConfig.html,6,['error'],['errorMsgPrefix']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file. viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Thu Sep 23 20:22:46 2010 » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/WindowAttributes_t.html:1564,mask,mask,1564,root/html528/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html528/WindowAttributes_t.html,1,['mask'],['mask']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Mon Jul 4 15:39:15 2011 » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/WindowAttributes_t.html:1566,mask,mask,1566,root/html530/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html530/WindowAttributes_t.html,1,['mask'],['mask']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Thu Nov 3 20:24:28 2011 » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/WindowAttributes_t.html:1566,mask,mask,1566,root/html532/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html532/WindowAttributes_t.html,2,['mask'],['mask']
Availability,". WindowAttributes_t. Quick Links:; ROOT Homepage; Class Index; Class Hierarchy. Search. Source:; header file; ; viewVC header . Sections:; class description; function members; data members; class charts. ROOT; » CORE; » BASE; » WindowAttributes_t. class WindowAttributes_t. GuiTypes. Types used by the GUI classes. Function Members (Methods); public:. WindowAttributes_t(); WindowAttributes_t(const WindowAttributes_t&); ~WindowAttributes_t(); WindowAttributes_t&operator=(const WindowAttributes_t&). Data Members; public:. Long_tfAllEventMasksset of events all people have interest in; ULong_tfBackingPixelvalue to be used when restoring planes; ULong_tfBackingPlanesplanes to be preserved if possible; Int_tfBackingStorekNotUseful, kWhenMapped, kAlways; Int_tfBitGravityone of bit gravity values; Int_tfBorderWidthborder width of window; Int_tfClasskInputOutput, kInputOnly; Colormap_tfColormapcolor map to be associated with window; Int_tfDepthdepth of window; Long_tfDoNotPropagateMaskset of events that should not propagate; Int_tfHeightwidth and height of window; Bool_tfMapInstalledboolean, is color map currently installed; Int_tfMapStatekIsUnmapped, kIsUnviewable, kIsViewable; Bool_tfOverrideRedirectboolean value for override-redirect; Window_tfRootroot of screen containing window; Bool_tfSaveUnderboolean, should bits under be saved?; void*fScreenback pointer to correct screen; void*fVisualthe associated visual structure; Int_tfWidth; Int_tfWinGravityone of the window gravity values; Int_tfX; Int_tfYlocation of window; Long_tfYourEventMaskmy event mask. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation. » Last changed: Tue Sep 8 17:05:59 2015 » Last generated: 2015-09-08 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/WindowAttributes_t.html:1566,mask,mask,1566,root/html534/WindowAttributes_t.html,https://root.cern,https://root.cern/root/html534/WindowAttributes_t.html,2,['mask'],['mask']
Availability,". XMLNodePointer_t AllocateNode(int namelen, XMLNodePointer_t parent); Allocates new xml node with specified namelength. XMLAttrPointer_t AllocateAttr(int namelen, int valuelen, XMLNodePointer_t xmlnode); Allocate new attribute with specified name length and value length. XMLNsPointer_t FindNs(XMLNodePointer_t xmlnode, const char* nsname); define if namespace of that name exists for xmlnode. void TruncateNsExtension(XMLNodePointer_t xmlnode); removes namespace extension of nodename. void UnpackSpecialCharacters(char* target, const char* source, int srclen); unpack special symbols, used in xml syntax to code characters; these symbols: '<' - &lt, '>' - &gt, '&' - &amp, '""' - &quot. void OutputValue(char* value, TXMLOutputStream* out); output value to output stream; if symbols '<' '&' '>' '""' appears in the string, they; will be encoded to appropriate xml symbols: &lt, &amp, &gt, &quot. void SaveNode(XMLNodePointer_t xmlnode, TXMLOutputStream* out, Int_t layout, Int_t level); stream data of xmlnode to output. XMLNodePointer_t ReadNode(XMLNodePointer_t xmlparent, TXMLInputStream* inp, Int_t& resvalue); Tries to construct xml node from input stream. Node should be; child of xmlparent node or it can be closing tag of xmlparent.; resvalue <= 0 if error; resvalue == 1 if this is endnode of parent; resvalue == 2 if this is child. void DisplayError(Int_t error, Int_t linenumber); Displays xml parsing error. TXMLEngine(). void SetSkipComments(bool on = kTRUE); { fSkipComments = on; }. Bool_t GetSkipComments() const; { return fSkipComments; }. Bool_t ValidateDocument(XMLDocPointer_t , Bool_t = kFALSE); { return kFALSE; }. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLEngine.h 38266 2011-03-01 18:46:08Z rdm $ » Last generated: 2011-07-04 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TXMLEngine.html:17612,error,error,17612,root/html530/TXMLEngine.html,https://root.cern,https://root.cern/root/html530/TXMLEngine.html,3,['error'],['error']
Availability,". XMLNodePointer_t AllocateNode(int namelen, XMLNodePointer_t parent); Allocates new xml node with specified namelength. XMLAttrPointer_t AllocateAttr(int namelen, int valuelen, XMLNodePointer_t xmlnode); Allocate new attribute with specified name length and value length. XMLNsPointer_t FindNs(XMLNodePointer_t xmlnode, const char* nsname); define if namespace of that name exists for xmlnode. void TruncateNsExtension(XMLNodePointer_t xmlnode); removes namespace extension of nodename. void UnpackSpecialCharacters(char* target, const char* source, int srclen); unpack special symbols, used in xml syntax to code characters; these symbols: '<' - &lt, '>' - &gt, '&' - &amp, '""' - &quot. void OutputValue(char* value, TXMLOutputStream* out); output value to output stream; if symbols '<' '&' '>' '""' appears in the string, they; will be encoded to appropriate xml symbols: &lt, &amp, &gt, &quot. void SaveNode(XMLNodePointer_t xmlnode, TXMLOutputStream* out, Int_t layout, Int_t level); stream data of xmlnode to output. XMLNodePointer_t ReadNode(XMLNodePointer_t xmlparent, TXMLInputStream* inp, Int_t& resvalue); Tries to construct xml node from input stream. Node should be; child of xmlparent node or it can be closing tag of xmlparent.; resvalue <= 0 if error; resvalue == 1 if this is endnode of parent; resvalue == 2 if this is child. void DisplayError(Int_t error, Int_t linenumber); Displays xml parsing error. TXMLEngine(). void SetSkipComments(bool on = kTRUE); { fSkipComments = on; }. Bool_t GetSkipComments() const; { return fSkipComments; }. Bool_t ValidateDocument(XMLDocPointer_t , Bool_t = kFALSE); { return kFALSE; }. » Author: Sergey Linev 10.05.2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/xml:$Id: TXMLEngine.h 38266 2011-03-01 18:46:08Z rdm $ » Last generated: 2011-11-03 20:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXMLEngine.html:17612,error,error,17612,root/html532/TXMLEngine.html,https://root.cern,https://root.cern/root/html532/TXMLEngine.html,6,['error'],['error']
Availability,". bool ; verbose = false, . bool ; autoBinned = true, . const char * ; binnedTag = """", . bool ; expectedData = false, . bool ; extended = false . ); const. Generate a new dataset containing the specified variables with events sampled from our distribution. ; Parameters. [in]whatVarsGenerate a dataset with the variables (and categories) in this set. Any variables of this PDF that are not in whatVars will use their current values and be treated as fixed parameters. ; [in]nEventsGenerate the specified number of events or else try to use expectedEvents() if nEvents <= 0 (default). ; [in]verboseShow which generator strategies are being used. ; [in]autoBinnedIf original distribution is binned, return bin centers and randomise weights instead of generating single events. ; [in]binnedTag; [in]expectedDataCall setExpectedData on the genContext. ; [in]extendedRandomise number of events generated according to Poisson(nEvents). Only useful if PDF is extended. . ReturnsNew dataset. Returns zero in case of an error. The caller takes ownership of the returned dataset. ; Definition at line 1385 of file RooAbsPdf.cxx. ◆ generate() [4/6]. RooFit::OwningPtr< RooDataSet > RooAbsPdf::generate ; (; const RooArgSet & ; whatVars, . Int_t ; nEvents, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg & ; arg4 = {}, . const RooCmdArg & ; arg5 = {} . ). inline . See RooAbsPdf::generate(const RooArgSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&) ; Parameters. [in]whatVarsSet of observables to generate for each event according to this model. ; [in]nEventsHow many events to generate ; arg1,arg2,arg3,arg4,arg5Optional command arguments. . Definition at line 57 of file RooAbsPdf.h. ◆ generate() [5/6]. RooFit::OwningPtr< RooDataSet > RooAbsPdf::generate ; (; RooAbsPdf::GenSpec & ; spec); const. Generate according to GenSpec obtained from prepareMultiGen(). ; If many identical gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf.html:119183,error,error,119183,doc/master/classRooAbsPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf.html,1,['error'],['error']
Availability,". char * TSystem::GetServiceByPort ; (; int ; port). virtual . Get name of internet service. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2327 of file TSystem.cxx. ◆ GetSockName(). TInetAddress TSystem::GetSockName ; (; int ; sock). virtual . Get Internet Protocol (IP) address of host and port #. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2309 of file TSystem.cxx. ◆ GetSockOpt(). int TSystem::GetSockOpt ; (; int ; sock, . int ; kind, . int * ; val . ). virtual . Get socket option. ; Reimplemented in TWinNTSystem, and TUnixSystem.; Definition at line 2445 of file TSystem.cxx. ◆ GetSoExt(). const char * TSystem::GetSoExt ; (; ); const. virtual . Get the shared library extension. ; Definition at line 4013 of file TSystem.cxx. ◆ GetSysInfo(). int TSystem::GetSysInfo ; (; SysInfo_t * ; info); const. virtual . Returns static system info, like OS type, CPU type, number of CPUs RAM size, etc into the SysInfo_t structure. ; Returns -1 in case of error, 0 otherwise. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 2458 of file TSystem.cxx. ◆ GetUid(). Int_t TSystem::GetUid ; (; const char * ; user = nullptr). virtual . Returns the user's id. If user = 0, returns current user's id. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1562 of file TSystem.cxx. ◆ GetUserInfo() [1/2]. UserGroup_t * TSystem::GetUserInfo ; (; const char * ; user = nullptr). virtual . Returns all user info in the UserGroup_t structure. ; If user = 0, returns current user's id info. The returned structure must be deleted by the user. In case of error 0 is returned. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1612 of file TSystem.cxx. ◆ GetUserInfo() [2/2]. UserGroup_t * TSystem::GetUserInfo ; (; Int_t ; uid). virtual . Returns all user info in the UserGroup_t structure. ; The returned structure must be deleted by the user. In case of error 0 is returned. ; Reimplemented in TUnixSystem, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:67760,error,error,67760,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['error'],['error']
Availability,". class TGSlider: public TGFrame, public TGWidget. TGSlider, TGVSlider and TGHSlider. Slider widgets allow easy selection of a range.; Sliders can be either horizontal or vertical oriented and there is; a choice of two different slider types and three different types; of tick marks. TGSlider is an abstract base class. Use the concrete TGVSlider and; TGHSlider. Dragging the slider will generate the event:; kC_VSLIDER, kSL_POS, slider id, position (for vertical slider); kC_HSLIDER, kSL_POS, slider id, position (for horizontal slider). Pressing the mouse will generate the event:; kC_VSLIDER, kSL_PRESS, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_PRESS, slider id, 0 (for horizontal slider). Releasing the mouse will generate the event:; kC_VSLIDER, kSL_RELEASE, slider id, 0 (for vertical slider); kC_HSLIDER, kSL_RELEASE, slider id, 0 (for horizontal slider). Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGSlider(); voidTObject::AbstractMethod(const char* method) const; virtual voidTGFrame::Activate(Bool_t); voidTGFrame::AddInput(UInt_t emask); virtual voidTObject::AppendPad(Option_t* option = """"); static Bool_tTQObject::AreAllSignalsBlocked(); Bool_tTQObject::AreSignalsBlocked() const; virtual voidTGWidget::Associate(const TGWindow* w); static Bool_tTQObject::BlockAllSignals(Bool_t b); Bool_tTQObject::BlockSignals(Bool_t b); virtual voidTObject::Browse(TBrowser* b); virtual voidTGFrame::ChangeBackground(Pixel_t back); virtual voidTQObject::ChangedBy(const char* method)SIGNAL ; virtual voidTGFrame::ChangeOptions(UInt_t options); virtual voidChangeSliderPic(const char* name); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; voidTQObject::CollectClassSignalLists(TList& list, TClass* cls); virtual Int_tTObject::Co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGSlider.html:1257,avail,available,1257,root/html528/TGSlider.html,https://root.cern,https://root.cern/root/html528/TGSlider.html,10,['avail'],['available']
Availability,". class TParallelCoord: public TNamed. Parallel Coordinates class. The multidimensional system of Parallel coordinates is a common way of studying high-dimensional geometry and visualizing multivariate problems. It has first been proposed by A. Inselberg in 1981. To show a set of points in an n-dimensional space, a backdrop is drawn consisting of n parallel lines. A point in n-dimensional space is represented as a polyline with vertices on the parallel axes; the position of the vertex on the i-th axis corresponds to the i-th coordinate of the point. This tool comes with a rather large gui in the editor. It is necessary to use this editor in order to explore a data set, as explained below.; Reduce cluttering:. The main issue for parallel coordinates is the very high cluttering of the output when dealing with large data set. Two techniques have been implemented to bypass that so far:. Draw doted lines instead of plain lines with an adjustable dots spacing. A slider to adjust the dots spacing is available in the editor.; Sort the entries to display with a ""weight cut"". On each axis is drawn a histogram describing the distribution of the data on the corresponding variable. The ""weight"" of an entry is the sum of the bin content of each bin the entry is going through. An entry going through the histograms peaks will have a big weight wether an entry going randomly through the histograms will have a rather small weight. Setting a cut on this weight allows to draw only the most representative entries. A slider set the cut is also available in the gui. Selections:. Selections of specific entries can be defined over the data se using parallel coordinates. With that representation, a selection is an ensemble of ranges defined on the axes. Ranges defined on the same axis are conjugated with OR (an entry must be in one or the other ranges to be selected). Ranges on different axes are are conjugated with AND (an entry must be in all the ranges to be selected). Several selections ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TParallelCoord.html:1277,avail,available,1277,root/html530/TParallelCoord.html,https://root.cern,https://root.cern/root/html530/TParallelCoord.html,9,['avail'],['available']
Availability,". const char * ; title, . Int_t ; nbins, . const Double_t * ; xbins . ). protected . Constructor for variable bin size histograms using an input array of type double. ; Parameters. [in]namename of histogram (avoid blanks) ; [in]titlehistogram title. If title is of the form stringt;stringx;stringy;stringz the histogram title is set to stringt, the x axis title to stringx, the y axis title to stringy, etc. ; [in]nbinsnumber of bins ; [in]xbinsarray of low-edges for each bin. This is an array of type double and size nbins+1 . Definition at line 741 of file TH1.cxx. ◆ ~TH1(). TH1::~TH1 ; (; ). override . Histogram default destructor. ; Definition at line 643 of file TH1.cxx. Member Function Documentation. ◆ Add() [1/3]. Bool_t TH1::Add ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1 . ). virtual . Replace contents of this histogram by the addition of h1 and h2. ; this = c1*h1 + c2*h2 if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; Note also that adding histogram with labels is not supported, histogram will be added merging them by bin number independently of the labels. For adding histogram ith labels one should use TH1::Merge; SPECIAL CASE (Average/Efficiency histograms) For histograms representing averages or efficiencies, one should compute the average of the two histograms and not the sum. One can mark a histogram to be an average histogram by setting its bit kIsAverage with myhist.SetBit(TH1::kIsAverage); Note that the two histograms must have their kIsAverage bit set; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Add; IMPORTANT NOTE2: You should be careful about the statistics of the returned histogram, whose statistics may be binned or unbinned, depending on whether c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:74356,error,errors,74356,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,. const std::string & ROOT::Math::MinimizerOptions::DefaultMinimizerAlgo ; (; ). static . Definition at line 85 of file MinimizerOptions.cxx. ◆ DefaultMinimizerType(). const std::string & ROOT::Math::MinimizerOptions::DefaultMinimizerType ; (; ). static . Definition at line 100 of file MinimizerOptions.cxx. ◆ DefaultPrecision(). double ROOT::Math::MinimizerOptions::DefaultPrecision ; (; ). static . Definition at line 93 of file MinimizerOptions.cxx. ◆ DefaultPrintLevel(). int ROOT::Math::MinimizerOptions::DefaultPrintLevel ; (; ). static . Definition at line 97 of file MinimizerOptions.cxx. ◆ DefaultStrategy(). int ROOT::Math::MinimizerOptions::DefaultStrategy ; (; ). static . Definition at line 96 of file MinimizerOptions.cxx. ◆ DefaultTolerance(). double ROOT::Math::MinimizerOptions::DefaultTolerance ; (; ). static . Definition at line 92 of file MinimizerOptions.cxx. ◆ ErrorDef(). double ROOT::Math::MinimizerOptions::ErrorDef ; (; ); const. inline . error definition ; Definition at line 192 of file MinimizerOptions.h. ◆ ExtraOptions(). const IOptions * ROOT::Math::MinimizerOptions::ExtraOptions ; (; ); const. inline . return extra options (NULL pointer if they are not present) ; Definition at line 195 of file MinimizerOptions.h. ◆ FindDefault(). IOptions * ROOT::Math::MinimizerOptions::FindDefault ; (; const char * ; name). static . Find an extra options and return a nullptr if it is not existing. ; Same as above but it will not create a new one ; Definition at line 239 of file MinimizerOptions.cxx. ◆ MaxFunctionCalls(). unsigned int ROOT::Math::MinimizerOptions::MaxFunctionCalls ; (; ); const. inline . max number of function calls ; Definition at line 177 of file MinimizerOptions.h. ◆ MaxIterations(). unsigned int ROOT::Math::MinimizerOptions::MaxIterations ; (; ); const. inline . max iterations ; Definition at line 180 of file MinimizerOptions.h. ◆ MinimizerAlgorithm(). const std::string & ROOT::Math::MinimizerOptions::MinimizerAlgorithm ; (; ); const. inline .,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:7534,error,error,7534,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['error'],['error']
Availability,". const std::string & ; variationName . ). private . Return the RVariationsWithReaders object that handles the specified variation of the specified column, or null. ; Definition at line 166 of file RDFColumnRegister.cxx. ◆ GenerateColumnNames(). std::vector< std::string_view > ROOT::Internal::RDF::RColumnRegister::GenerateColumnNames ; (; ); const. Return the list of the names of the defined columns (Defines + Aliases). ; Definition at line 310 of file RDFColumnRegister.cxx. ◆ GetDefine(). RDFDetail::RDefineBase * ROOT::Internal::RDF::RColumnRegister::GetDefine ; (; std::string_view ; colName); const. Return the RDefine for the requested column name, or nullptr. ; Definition at line 51 of file RDFColumnRegister.cxx. ◆ GetReader(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReader ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName, . const std::type_info & ; requestedType . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; If requestedType does not match the actual type of the Define or Variation, an exception is thrown. ; Definition at line 258 of file RDFColumnRegister.cxx. ◆ GetReaderUnchecked(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReaderUnchecked ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; No type checking is done on the requested reader. ; Definition at line 287 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [1/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::string & ; column); const. Get the names of all variations that directly or indirectly affect a given column. ; This list includes variations applied to the column as well as variations applied to other columns on which the value of this column depends (typically via a Define expr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:8809,avail,available,8809,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['avail'],['available']
Availability,". double GlobalCC(unsigned int ivar) const. return global correlation coefficient for variable i; This is a number between zero and one which gives; the correlation between the i-th parameter and that linear combination of all; other parameters which is most strongly correlated with i.; Minimizer must overload method if implemented. bool GetMinosError(unsigned int ivar, double& errLow, double& errUp, int option = 0). minos error for variable i, return false if Minos failed or not supported; and the lower and upper errors are returned in errLow and errUp; An extra flag specifies if only the lower (option=-1) or the upper (option=+1) error calculation is run; (This feature is not yet implemented). bool Hesse(). perform a full calculation of the Hessian matrix for error calculation. bool Scan(unsigned int ivar, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan function minimum for variable i. Variable and function must be set before using Scan; Return false if an error or if minimizer does not support this functionality. bool Contour(unsigned int ivar, unsigned int jvar, unsigned int& npoints, double* xi, double* xj). find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; The contour will be find for value of the function = Min + ErrorUp();. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const = 0;; print the result according to set level (implemented for TMinuit for mantaining Minuit-style printing). {}. std::string VariableName(unsigned int ivar) const; get name of variables (override if minimizer support storing of variable names); return an empty string if variable is not found. int VariableIndex(const string& name) const; get index of variable given a variable given a name; return -1 if variable is not found. int PrintLevel() const; minimizer configuration parameters ; set print level. { return fOptions.PrintLevel(); }. un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:10986,error,error,10986,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,6,['error'],['error']
Availability,". double MinValue() const; return minimum function value. const double * X() const; return pointer to X values at the minimum. double Edm() const; return expected distance reached from the minimum (re-implement if minimizer provides it. { return -1; }. const double * MinGradient() const; return pointer to gradient values at the minimum. { return NULL; }. unsigned int NCalls() const; number of function calls to reach the minimum. { return 0; }. unsigned int NIterations() const; number of iterations to reach the minimum. { return NCalls(); }. unsigned int NDim() const; this is <= Function().NDim() which is the total; number of variables (free+ constrained ones). unsigned int NFree() const; number of free variables (real dimension of the problem); this is <= Function().NDim() which is the total; (re-implement if minimizer supports bounded parameters). { return NDim(); }. bool ProvidesError() const; minimizer provides error and error matrix. { return false; }. const double * Errors() const; return errors at the minimum. { return NULL; }. double CovMatrix(unsigned int ivar, unsigned int jvar) const; return covariance matrices element for variables ivar,jvar; if the variable is fixed the return value is zero; The ordering of the variables is the same as in the parameter and errors vectors. bool GetCovMatrix(double* covMat) const. Fill the passed array with the covariance matrix elements; if the variable is fixed or const the value is zero.; The array will be filled as cov[i *ndim + j]; The ordering of the variables is the same as in errors and parameter value.; This is different from the direct interface of Minuit2 or TMinuit where the; values were obtained only to variable parameters. bool GetHessianMatrix(double* hMat) const. Fill the passed array with the Hessian matrix elements; The Hessian matrix is the matrix of the second derivatives; and is the inverse of the covariance matrix; If the variable is fixed or const the values for that variables are zero.; The array wil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__Minimizer.html:8544,error,errors,8544,root/html534/ROOT__Math__Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__Minimizer.html,9,"['Error', 'error']","['Errors', 'errors']"
Availability,". double RooAbsReal::PlotOpt::addToWgtOther = 1.0. Definition at line 483 of file RooAbsReal.h. ◆ addToWgtSelf. double RooAbsReal::PlotOpt::addToWgtSelf = 1.0. Definition at line 482 of file RooAbsReal.h. ◆ binProjData. bool RooAbsReal::PlotOpt::binProjData = false. Definition at line 468 of file RooAbsReal.h. ◆ curveInvisible. bool RooAbsReal::PlotOpt::curveInvisible = false. Definition at line 479 of file RooAbsReal.h. ◆ curveName. const char* RooAbsReal::PlotOpt::curveName = nullptr. Definition at line 480 of file RooAbsReal.h. ◆ curveNameSuffix. const char* RooAbsReal::PlotOpt::curveNameSuffix = """". Definition at line 486 of file RooAbsReal.h. ◆ doeeval. bool RooAbsReal::PlotOpt::doeeval = false. Definition at line 489 of file RooAbsReal.h. ◆ drawOptions. Option_t* RooAbsReal::PlotOpt::drawOptions = ""L"". Definition at line 464 of file RooAbsReal.h. ◆ eeval. double RooAbsReal::PlotOpt::eeval = 0.0. Definition at line 488 of file RooAbsReal.h. ◆ errorFR. const RooFitResult* RooAbsReal::PlotOpt::errorFR = nullptr. Definition at line 491 of file RooAbsReal.h. ◆ interleave. RooFit::MPSplit RooAbsReal::PlotOpt::interleave = RooFit::Interleave. Definition at line 485 of file RooAbsReal.h. ◆ normRangeName. const char* RooAbsReal::PlotOpt::normRangeName = nullptr. Definition at line 473 of file RooAbsReal.h. ◆ numCPU. Int_t RooAbsReal::PlotOpt::numCPU = 1. Definition at line 484 of file RooAbsReal.h. ◆ numee. Int_t RooAbsReal::PlotOpt::numee = 10. Definition at line 487 of file RooAbsReal.h. ◆ postRangeFracScale. bool RooAbsReal::PlotOpt::postRangeFracScale = false. Definition at line 476 of file RooAbsReal.h. ◆ precision. double RooAbsReal::PlotOpt::precision = 1e-3. Definition at line 470 of file RooAbsReal.h. ◆ progress. bool RooAbsReal::PlotOpt::progress = false. Definition at line 490 of file RooAbsReal.h. ◆ projData. const RooAbsData* RooAbsReal::PlotOpt::projData = nullptr. Definition at line 467 of file RooAbsReal.h. ◆ projDataSet. const RooArgSet* RooAbsReal::Pl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html:2448,error,errorFR,2448,doc/master/structRooAbsReal_1_1PlotOpt.html,https://root.cern,https://root.cern/doc/master/structRooAbsReal_1_1PlotOpt.html,1,['error'],['errorFR']
Availability,". double ; xErrorFrac = 1.0, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the specified integer bin contents and using an error bar calculated with Poisson statistics. ; The bin width is used to set the relative scale of bins with different widths. ; Definition at line 426 of file RooHist.cxx. ◆ addBinWithError(). void RooHist::addBinWithError ; (; Axis_t ; binCenter, . double ; n, . double ; elow, . double ; ehigh, . double ; binWidth = 0, . double ; xErrorFrac = 1.0, . bool ; correctForBinWidth = true, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the specified bin contents and error. ; The bin width is used to set the relative scale of bins with different widths. ; Definition at line 477 of file RooHist.cxx. ◆ addBinWithXYError(). void RooHist::addBinWithXYError ; (; Axis_t ; binCenter, . double ; n, . double ; exlow, . double ; exhigh, . double ; eylow, . double ; eyhigh, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the specified bin contents and error. ; The bin width is used to set the relative scale of bins with different widths. ; Definition at line 498 of file RooHist.cxx. ◆ addEfficiencyBin(). void RooHist::addEfficiencyBin ; (; Axis_t ; binCenter, . Int_t ; n1, . Int_t ; n2, . double ; binWidth = 0, . double ; xErrorFrac = 1.0, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ; Definition at line 557 of file RooHist.cxx. ◆ addEfficiencyBinWithError(). void RooHist::addEfficiencyBinWithError ; (; Axis_t ; binCenter, . double ; n1, . double ; n2, . double ; en1, . double ; en2, . double ; binWidth = 0, . double ; xErrorFrac = 1.0, . double ; scaleFactor = 1.0 . ). Add a bin to this histogram with the value n1/(n1+n2) using an error bar calculated with Binomial statistics. ; Definition at line 579 of file RooHist.cxx. ◆ addPoint(). void RooHist::addPoint ; (; Axis_t ; binCenter, . double ; y, . double ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:49416,error,error,49416,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['error'],['error']
Availability,". enum ECloneMethod { kDefault; kSortBasketsByBranch; kSortBasketsByOffset; kSortBasketsByEntry; };; enum EClonerOptions { kNone; kNoWarnings; };. private:. UInt_t*fBasketBranchNum[fMaxBaskets] Index of the branch(es) of the basket.; Long64_t*fBasketEntry[fMaxBaskets] list of basket start entries.; UInt_t*fBasketIndex[fMaxBaskets] ordered list of basket indices to be written.; UInt_t*fBasketNum[fMaxBaskets] index of the basket within the branch.; Long64_t*fBasketSeek[fMaxBaskets] list of basket position to be read.; UInt_tfCloneMethodIndicates which cloning method was selected.; TObjArrayfFromBranches; TTree*fFromTree; Bool_tfIsValid; UInt_tfMaxBaskets; Option_t*fMethod; Bool_tfNeedConversionTrue if the fast merge is not possible but a slow merge might possible.; UInt_tfOptions; UShort_tfPidOffsetOffset to be added to the copied key/basket.; TObjArrayfToBranches; Long64_tfToStartEntriesNumber of entries in the target tree before any addition.; TTree*fToTree; TStringfWarningMsgText of the error message lead to an 'invalid' state. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCloner(TTree* from, TTree* to, Option_t* method, UInt_t options = kNone). virtual ~TTreeCloner(). void CloseOutWriteBaskets(). UInt_t CollectBranches(TBranch* from, TBranch* to). UInt_t CollectBranches(TObjArray* from, TObjArray* to). UInt_t CollectBranches(). void CollectBaskets(). void CopyMemoryBaskets(). void CopyStreamerInfos(). void CopyProcessIds(). const char * GetWarning() const; { return fWarningMsg; }. Bool_t Exec(). Bool_t IsValid(); { return fIsValid; }. Bool_t NeedConversion(); { return fNeedConversion; }. void SortBaskets(). void WriteBaskets(). » Author: Philippe Canal 07/11/2005 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/tree:$Id: TTreeCloner.h 29413 2009-07-09 14:10:29Z pcanal $ » Last generated: 2010-09-23 20:22; This page has been automatically generated. For comments or suggestions regard",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCloner.html:2038,error,error,2038,root/html528/TTreeCloner.html,https://root.cern,https://root.cern/root/html528/TTreeCloner.html,1,['error'],['error']
Availability,". enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Thu Sep 23 19:55:51 2010 » Last generated: 2010-09-23 19:55; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PyROOT__TPyROOTApplication.html:13624,error,error,13624,root/html528/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html528/PyROOT__TPyROOTApplication.html,2,['error'],['error']
Availability,". enum TApplication::EStatusBits { kProcessRemotely; kDefaultApplication; };; enum TApplication::EExitOnException { kDontExit; kExit; kAbort; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitCINTMessageCallback(); Install CINT message callback which will turn CINT error message into; python exceptions. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. virtual ~TPyROOTApplication(); { }. » Last changed: Tue Mar 17 20:53:08 2015 » Last generated: 2015-03-17 20:53; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PyROOT__TPyROOTApplication.html:13794,error,error,13794,root/html534/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html534/PyROOT__TPyROOTApplication.html,4,['error'],['error']
Availability,. enum TSelectorDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortAbort status; Int_tTSelectorDraw::fAction! Action type; Bool_tTSelectorDraw::fCleanElisttrue if original Tree elist must be saved; TEvePointSelectorConsumer*fConsumer; Long64_tTSelectorDraw::fCurrentSubEntryCurrent subentry when fSelectMultiple is true. Used to fill TEntryListArray; Int_tTSelectorDraw::fDimensionDimension of the current expression; Long64_tTSelectorDraw::fDraw! Last entry loop number when object was drawn; Int_tTSelectorDraw::fForceReadForce Read flag; TListfInput; TList*TSelector::fInputList of objects available during processing; TTreeFormulaManager*TSelectorDraw::fManagerPointer to the formula manager; Int_tTSelectorDraw::fMultiplicityIndicator of the variability of the size of entries; Int_t*TSelectorDraw::fNbins![fDimension] Number of bins per dimension; Int_tTSelectorDraw::fNfill! Total number of histogram fills; Bool_tTSelectorDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObject!Current object if processing object (vs. TTree); Long64_tTSelectorDraw::fOldEstimatevalue of Tree fEstimate when selector is called; TH1*TSelectorDraw::fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionOption given to TTree::Process; TSelectorList*TSelector::fOutput!List of objects created during processing; TTreeFormula*TSelectorDraw::fSelectPointer to selection formula; Bool_tTSelectorDraw::fSelectMultipletrue if selection has a variable index; Long64_tTSelectorDraw::fSelectedRowsNumber of selected entries; TStringfSelection; Long64_tTSelector::fStatusSelector status; TStringfSubIdExp; Int_tfSubIdN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEvePointSelector.html:9310,avail,available,9310,root/html534/TEvePointSelector.html,https://root.cern,https://root.cern/root/html534/TEvePointSelector.html,2,['avail'],['available']
Availability,. enum TSelectorDraw::[unnamed] { kWarn; };; enum TSelector::EAbort { kContinue; kAbortProcess; kAbortFile; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TSelector::EAbortTSelector::fAbortabort status; Int_tTSelectorDraw::fAction! Action type; Bool_tTSelectorDraw::fCleanElisttrue if original Tree elist must be saved; TEvePointSelectorConsumer*fConsumer; Long64_tTSelectorDraw::fCurrentSubEntryCurrent subentry when fSelectMultiple is true. Used to fill TEntryListArray; Int_tTSelectorDraw::fDimensionDimension of the current expression; Long64_tTSelectorDraw::fDraw! Last entry loop number when object was drawn; Int_tTSelectorDraw::fForceReadForce Read flag; TListfInput; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*TSelectorDraw::fManagerPointer to the formula manager; Int_tTSelectorDraw::fMultiplicityIndicator of the variability of the size of entries; Int_t*TSelectorDraw::fNbins![fDimension] Number of bins per dimension; Int_tTSelectorDraw::fNfill! Total number of histogram fills; Bool_tTSelectorDraw::fObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); Long64_tTSelectorDraw::fOldEstimatevalue of Tree fEstimate when selector is called; TH1*TSelectorDraw::fOldHistogram! Pointer to previously used histogram; TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*TSelectorDraw::fSelectPointer to selection formula; Bool_tTSelectorDraw::fSelectMultipletrue if selection has a variable index; Long64_tTSelectorDraw::fSelectedRowsNumber of selected entries; TStringfSelection; Long64_tTSelector::fStatusselector status; TStringfSubIdExp; Int_tfSubIdNum,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEvePointSelector.html:9244,avail,available,9244,root/html532/TEvePointSelector.html,https://root.cern,https://root.cern/root/html532/TEvePointSelector.html,2,['avail'],['available']
Availability,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(000111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters; kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THistPainter.html:16062,error,error,16062,root/html528/THistPainter.html,https://root.cern,https://root.cern/root/html528/THistPainter.html,32,['error'],['error']
Availability,". gStyle->SetOptStat(11);. displays only the name of histogram and the number of entries, whereas:. gStyle->SetOptStat(1101);. displays the name of histogram, mean value and RMS.; WARNING 1: never do:. gStyle->SetOptStat(0001111);. but instead do:. gStyle->SetOptStat(1111);. because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions. gStyle->SetOptStat(1);. is taken as:. gStyle->SetOptStat(1111). To print only the name of the histogram do:. gStyle->SetOptStat(1000000001);. NOTE that in case of 2D histograms, when selecting only underflow; (10000) or overflow (100000), the statistics box will show all combinations; of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen. k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed. For example, to print only name of histogram and number of entries do:. gStyle->SetOptStat(""ne"");. To print only the name of the histogram do:. gStyle->SetOptStat(""n"");. The default value is:. gStyle->SetOptStat(""nemr"");. When a histogram is painted, a TPaveStats object is created and added; to the list of functions of the histogram. If a TPaveStats object; already exists in the histogram list of functions, the existing object is just; updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using; h->FindObject(""stats""). In the command line it is enough to do:. Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""). because after h->Draw() the histogram is automatically painted. But; in a script file the paint",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TPaveStats.html:2016,error,error,2016,root/html534/TPaveStats.html,https://root.cern,https://root.cern/root/html534/TPaveStats.html,24,['error'],['error']
Availability,". if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionX("" "",firstybin,lastybin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionX("" "",firstybin,lastybin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionX("" "",firstybin,lastybin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the X axis attributes of the TH2 are copied to the X axis of the projection. TH1D * ProjectionY(const char* name = ""_py"", Int_t firstxbin = 0, Int_t lastxbin = -1, Option_t* option = """") const; Project a 2-D histogram into a 1-D histogram along Y*-*-; *-* ====================================================. The projection is always of the type TH1D.; The projection is made from the channels along the X axis; ranging from firstxbin to lastxbin included.; By default, all bins including under- and overflow are included.; The number of entries in the projection is estimated from the; number of effective entries for all the cells included in the projection. To exclude the underflow bins in X, use firstxbin=1;; to exclude the underflow bins in X, use lastxbin=nx. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:48586,error,error,48586,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,4,['error'],['error']
Availability,". if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the taget axes will be; kept, but only bins inside the selected range will be filled. Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; One must create a graphical cut (mouse or C++) and specify the name; of the cut between [] in the option.; For example, with a TCutG named ""cutg"", one can call:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; To invert the cut, it is enough to put a ""-"" in front of its name:; myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; It is possible to apply several cuts:; myhist->ProjectionY("" "",firstxbin,lastxbin,[cutg1,cutg2]"");. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection. void PutStats(Double_t* stats); Replace current statistics with the values in array stats. void Reset(Option_t* option = """"); Reset this histogram: contents, errors, etc; *-* ===========================================. void SetShowProjectionX(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along X corresponding to the; mouse position along Y.; To stop the generation of the projections, delete the canvas; containing the projection. void SetShowProjectionY(Int_t nbins); When the mouse is moved in a pad containing a 2-d view of this histogram; a second canvas shows the projection along Y corresponding to the; mouse position along X.; To stop the generation of the projections, delete the canvas; containing the projection. TH1 * ShowBackground(Int_t niter = 20, Option_t* option = ""sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2.html:50410,error,error,50410,root/html528/TH2.html,https://root.cern,https://root.cern/root/html528/TH2.html,4,['error'],['error']
Availability,". inline . Definition at line 81 of file TMapFile.h. ◆ operator new() [2/2]. void * TMapFile::operator new ; (; size_t ; sz, . void * ; vp . ). inline . Definition at line 83 of file TMapFile.h. ◆ operator new[]() [1/2]. void * TMapFile::operator new[] ; (; size_t ; sz). inline . Definition at line 82 of file TMapFile.h. ◆ operator new[]() [2/2]. void * TMapFile::operator new[] ; (; size_t ; sz, . void * ; vp . ). inline . Definition at line 84 of file TMapFile.h. ◆ operator=(). TMapFile & TMapFile::operator= ; (; const TMapFile & ; rhs). protecteddelete . ◆ OrgAddress(). void * TMapFile::OrgAddress ; (; void * ; addr); const. inline . Definition at line 102 of file TMapFile.h. ◆ Print(). void TMapFile::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print some info about the mapped file. ; Reimplemented from TObject.; Definition at line 1040 of file TMapFile.cxx. ◆ ReleaseSemaphore(). Int_t TMapFile::ReleaseSemaphore ; (; ). protected . Release semaphore. Returns 0 if OK, -1 on error. ; Definition at line 947 of file TMapFile.cxx. ◆ Remove() [1/4]. TObject * TMapFile::Remove ; (; const char * ; name). inline . Definition at line 110 of file TMapFile.h. ◆ Remove() [2/4]. TObject * TMapFile::Remove ; (; const char * ; name, . Bool_t ; lock . ). protected . Remove object by name from shared memory. ; Returns pointer to removed object if successful, 0 otherwise. ; Definition at line 738 of file TMapFile.cxx. ◆ Remove() [3/4]. TObject * TMapFile::Remove ; (; TObject * ; obj). inline . Definition at line 109 of file TMapFile.h. ◆ Remove() [4/4]. TObject * TMapFile::Remove ; (; TObject * ; obj, . Bool_t ; lock . ). protected . Remove object from shared memory. ; Returns pointer to removed object if successful, 0 otherwise. ; Definition at line 699 of file TMapFile.cxx. ◆ RemoveAll(). void TMapFile::RemoveAll ; (; ). Remove all objects from shared memory. ; Definition at line 775 of file TMapFile.cxx. ◆ SetMapAddress(). void TMapFile::SetMapAddress ; (; Long",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMapFile.html:27293,error,error,27293,doc/master/classTMapFile.html,https://root.cern,https://root.cern/doc/master/classTMapFile.html,1,['error'],['error']
Availability,". inline . Get B histo mean. ; Definition at line 59 of file HybridPlot.h. ◆ GetBrms(). double RooStats::HybridPlot::GetBrms ; (; ). inline . Get B histo RMS. ; Definition at line 62 of file HybridPlot.h. ◆ GetCanvas(). TVirtualPad * RooStats::HybridPlot::GetCanvas ; (; ). inline . Get the pad (or canvas) where it has been drawn. ; Definition at line 95 of file HybridPlot.h. ◆ GetHistoCenter(). double HybridPlot::GetHistoCenter ; (; TH1 * ; histo_orig, . double ; n_rms = 1, . bool ; display_result = false . ). Get the center of the histo. ; Perform 2 times a gaussian fit to fetch the center of the histo.; To get the second fit range get an interval that tries to keep into account the skewness of the distribution. ; Definition at line 238 of file HybridPlot.cxx. ◆ GetHistoPvals(). double * HybridPlot::GetHistoPvals ; (; TH1 * ; histo, . double ; percentage . ). Get the ""effective sigmas"" of the histo, call delete [] res to release memory. ; We let an horizontal bar go down and we stop when we have the integral equal to the desired one. ; Definition at line 301 of file HybridPlot.cxx. ◆ GetMedian(). double HybridPlot::GetMedian ; (; TH1 * ; histo). Get the median of an histogram. ; Definition at line 353 of file HybridPlot.cxx. ◆ GetSBCenter(). double RooStats::HybridPlot::GetSBCenter ; (; double ; n_sigmas = 1, . bool ; display = false . ). inline . Get SB histo center. ; Definition at line 80 of file HybridPlot.h. ◆ GetSBhisto(). TH1F * RooStats::HybridPlot::GetSBhisto ; (; ). inline . Get B histo. ; Definition at line 92 of file HybridPlot.h. ◆ GetSBIntExtremes(). double * RooStats::HybridPlot::GetSBIntExtremes ; (; double ; frac). inline . Get SB histo integration extremes to obtain the requested area fraction call delete [] res to release memory. ; Definition at line 88 of file HybridPlot.h. ◆ GetSBmean(). double RooStats::HybridPlot::GetSBmean ; (; ). inline . Get SB histo mean. ; Definition at line 77 of file HybridPlot.h. ◆ GetSBrms(). double RooStats::HybridPl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html:16835,down,down,16835,doc/master/classRooStats_1_1HybridPlot.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HybridPlot.html,1,['down'],['down']
Availability,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; GCValues_t Struct Reference. ; Graphics context structure. ; Definition at line 224 of file GuiTypes.h. Public Member Functions;  GCValues_t ();  . Public Attributes; Int_t fArcMode;  kArcChord, kArcPieSlice ;  ; ULong_t fBackground;  background pixel ;  ; Int_t fCapStyle;  kCapNotLast, kCapButt, kCapRound, kCapProjecting ;  ; Pixmap_t fClipMask;  bitmap clipping; other calls for rects ;  ; Int_t fClipXOrigin;  origin for clipping ;  ; Int_t fClipYOrigin;  ; Char_t fDashes [8];  dash pattern list (dash length per byte) ;  ; Int_t fDashLen;  number of dashes in fDashes ;  ; Int_t fDashOffset;  patterned/dashed line information ;  ; Int_t fFillRule;  kEvenOddRule, kWindingRule ;  ; Int_t fFillStyle;  kFillSolid, kFillTiled, kFillStippled, kFillOpaeueStippled ;  ; FontH_t fFont;  default text font for text operations ;  ; ULong_t fForeground;  foreground pixel ;  ; EGraphicsFunction fFunction;  logical operation ;  ; Bool_t fGraphicsExposures;  boolean, should exposures be generated ;  ; Int_t fJoinStyle;  kJoinMiter, kJoinRound, kJoinBevel ;  ; Int_t fLineStyle;  kLineSolid, kLineOnOffDash, kLineDoubleDash ;  ; Int_t fLineWidth;  line width ;  ; Mask_t fMask;  bit mask specifying which fields are valid ;  ; ULong_t fPlaneMask;  plane mask ;  ; Pixmap_t fStipple;  stipple 1 plane pixmap for stippling ;  ; Int_t fSubwindowMode;  kClipByChildren, kIncludeInferiors ;  ; Pixmap_t fTile;  tile pixmap for tiling operations ;  ; Int_t fTsXOrigin;  offset for tile or stipple operations ;  ; Int_t fTsYOrigin;  . #include <GuiTypes.h>; Constructor & Destructor Documentation. ◆ GCValues_t(). GCValues_t::GCValues_t ; (; ). inline . Definition at line 253 of file GuiTypes.h. Member Data Documentation. ◆ fArcMode. Int_t GCValues_t::fArcMode. kArcChord, kArcPieSlice ; Definition at line 237 of file GuiTypes.h. ◆ fBackgroun",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/structGCValues__t.html:1392,mask,mask,1392,doc/master/structGCValues__t.html,https://root.cern,https://root.cern/doc/master/structGCValues__t.html,2,['mask'],['mask']
Availability,". master. Reference Guide ; .  . Loading...; Searching...; No Matches. exec1.C File ReferenceTutorials » Histograms tutorials. Detailed Description; Echo object at mouse position. ; Example of macro called when a pad is redrawn one must create a TExec object in the following way gPad->AddExec(""ex1"", "".x exec1.C"");; gPad#define gPadDefinition TVirtualPad.h:308; this macro prints the bin number and the bin content when one clicks on the histogram contour of any histogram in a pad; ; ; void exec1(); {; if (!gPad) {; Error(""exec1"", ""gPad is null, you are not supposed to run this macro"");; return;; }; ; Int_t event = gPad->GetEvent();; int px = gPad->GetEventX();; TObject *select = gPad->GetSelected();; ; if (select && select->InheritsFrom(TH1::Class())) {; TH1 *h = (TH1*)select;; Float_t xx = gPad->AbsPixeltoX(px);; Float_t x = gPad->PadtoX(xx);; Int_t binx = h->GetXaxis()->FindBin(x);; printf(""event=%d, hist:%s, bin=%d, content=%f\n"", event, h->GetName(), binx, h->GetBinContent(binx));; }; }; ; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; Float_tfloat Float_tDefinition RtypesCore.h:57; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TAxis::FindBinvirtual Int_t FindBin(Double_t x)Find bin number corresponding to abscissa x.Definition TAxis.cxx:293; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::Classstatic TClass * Class(); TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; xDouble_t x[n]Definition legend1.C:17; AuthorsRene Brun, Sergey Linev ; Definition in file exec1.C. tutorialshistexec1.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/exec1_8C.html:1285,error,error,1285,doc/master/exec1_8C.html,https://root.cern,https://root.cern/doc/master/exec1_8C.html,1,['error'],['error']
Availability,". non-static methods for retrieving options ; absolute tolerance ; Definition at line 61 of file IntegratorOptions.h. ◆ ClearExtra(). void ROOT::Math::BaseIntegratorOptions::ClearExtra ; (; ). protected . Definition at line 161 of file IntegratorOptions.cxx. ◆ ExtraOptions(). IOptions * ROOT::Math::BaseIntegratorOptions::ExtraOptions ; (; ); const. inline . return extra options ; Definition at line 71 of file IntegratorOptions.h. ◆ Integrator(). virtual std::string ROOT::Math::BaseIntegratorOptions::Integrator ; (; ); const. pure virtual . name of 1D integrator ; Implemented in ROOT::Math::IntegratorOneDimOptions, and ROOT::Math::IntegratorMultiDimOptions. ◆ operator=(). BaseIntegratorOptions & ROOT::Math::BaseIntegratorOptions::operator= ; (; const BaseIntegratorOptions & ; opt). assignment operators ; Definition at line 137 of file IntegratorOptions.cxx. ◆ RelTolerance(). double ROOT::Math::BaseIntegratorOptions::RelTolerance ; (; ); const. inline . absolute tolerance ; Definition at line 64 of file IntegratorOptions.h. ◆ SetAbsTolerance(). void ROOT::Math::BaseIntegratorOptions::SetAbsTolerance ; (; double ; tol). inline . non-static methods for setting options ; set the abs tolerance ; Definition at line 77 of file IntegratorOptions.h. ◆ SetExtraOptions(). void ROOT::Math::BaseIntegratorOptions::SetExtraOptions ; (; const IOptions & ; opt). set extra options (in this case pointer is cloned) ; Definition at line 167 of file IntegratorOptions.cxx. ◆ SetRelTolerance(). void ROOT::Math::BaseIntegratorOptions::SetRelTolerance ; (; double ; tol). inline . set the relative tolerance ; Definition at line 80 of file IntegratorOptions.h. ◆ SetWKSize(). void ROOT::Math::BaseIntegratorOptions::SetWKSize ; (; unsigned int ; size). inline . set workspace size ; Definition at line 83 of file IntegratorOptions.h. ◆ WKSize(). unsigned int ROOT::Math::BaseIntegratorOptions::WKSize ; (; ); const. inline . size of the workspace ; Definition at line 67 of file IntegratorOptions.h. M",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html:4016,toler,tolerance,4016,doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1BaseIntegratorOptions.html,1,['toler'],['tolerance']
Availability,". of the volume in mother ref. sys.; Y Y coord. of the volume in mother ref. sys.; Z Z coord. of the volume in mother ref. sys.; IROT Rotation matrix number w.r.t. mother ref. sys.; ISONLY ONLY/MANY flag . Definition at line 1353 of file TGeoManager.cxx. ◆ operator=(). TGeoManager & TGeoManager::operator= ; (; const TGeoManager & ; ). protecteddelete . ◆ OptimizeVoxels(). void TGeoManager::OptimizeVoxels ; (; const char * ; filename = ""tgeovox.C""). Optimize voxelization type for all volumes. Save best choice in a macro. ; Definition at line 2484 of file TGeoManager.cxx. ◆ Parse(). Int_t TGeoManager::Parse ; (; const char * ; expr, . TString & ; expr1, . TString & ; expr2, . TString & ; expr3 . ). static . Parse a string boolean expression and do a syntax check. ; Find top level boolean operator and returns its type. Fill the two substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression. Parentheses should be used to avoid ambiguities. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C) eliminate not needed parentheses . Definition at line 2540 of file TGeoManager.cxx. ◆ PopDummy(). void TGeoManager::PopDummy ; (; Int_t ; ipop = 9999). inline . Definition at line 597 of file TGeoManager.h. ◆ PopPath() [1/2]. Bool_t TGeoManager::PopPath ; (; ). inline . Definition at line 592 of file TGeoManager.h. ◆ PopPath() [2/2]. Bool_t TGeoManager::PopPath ; (; Int_t ; index). inline . Definition at line 593 of file TGeoManager.h. ◆ PopPoint() [1/2]. Bool_t TGeoManager::PopPoint ; (; ). inline . Definition at line 595 of file TGeoManager.h. ◆ PopPoint() [2/2]. Bool_t TGeoManager::PopPoint ; (; Int_t ; index). inline . Definition at line 596 of file TGeoManager.h. ◆ PrintOverlaps(). void TGeoManager::PrintOverlaps ; (; ); const. Prin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:127017,error,error,127017,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['error'],['error']
Availability,. p-value for the alternate hypothesis (small number means disfavoured) ; Definition at line 129 of file HypoTestResult.h. ◆ fAlternatePValueError. double RooStats::HypoTestResult::fAlternatePValueError. mutableprotected . error of p-value for the alternate hypothesis (small number means disfavoured) ; Definition at line 131 of file HypoTestResult.h. ◆ fBackgroundIsAlt. bool RooStats::HypoTestResult::fBackgroundIsAlt. protected . Definition at line 140 of file HypoTestResult.h. ◆ fFitInfo. std::unique_ptr<RooDataSet> RooStats::HypoTestResult::fFitInfo. protected . Definition at line 138 of file HypoTestResult.h. ◆ fNullDetailedOutput. std::unique_ptr<RooDataSet> RooStats::HypoTestResult::fNullDetailedOutput. protected . Definition at line 136 of file HypoTestResult.h. ◆ fNullDistr. std::unique_ptr<SamplingDistribution> RooStats::HypoTestResult::fNullDistr. protected . Definition at line 134 of file HypoTestResult.h. ◆ fNullPValue. double RooStats::HypoTestResult::fNullPValue. mutableprotected . p-value for the null hypothesis (small number means disfavoured) ; Definition at line 128 of file HypoTestResult.h. ◆ fNullPValueError. double RooStats::HypoTestResult::fNullPValueError. mutableprotected . error of p-value for the null hypothesis (small number means disfavoured) ; Definition at line 130 of file HypoTestResult.h. ◆ fPValueIsRightTail. bool RooStats::HypoTestResult::fPValueIsRightTail. protected . Definition at line 139 of file HypoTestResult.h. ◆ fTestStatisticData. double RooStats::HypoTestResult::fTestStatisticData. protected . result of the test statistic evaluated on data ; Definition at line 132 of file HypoTestResult.h. Libraries for RooStats::HypoTestResult:. [legend]; The documentation for this class was generated from the following files:; roofit/roostats/inc/RooStats/HypoTestResult.h; roofit/roostats/src/HypoTestResult.cxx. RooStatsHypoTestResult. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:44:54 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html:28400,error,error,28400,doc/master/classRooStats_1_1HypoTestResult.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1HypoTestResult.html,1,['error'],['error']
Availability,". private . Default canvas top Y position. ; Definition at line 91 of file TStyle.h. ◆ fCanvasPreferGL. Bool_t TStyle::fCanvasPreferGL. private . If true, rendering in canvas is with GL. ; Definition at line 84 of file TStyle.h. ◆ fCapLinePS. Int_t TStyle::fCapLinePS. private . Determines the appearance of line caps on PostScript, PDF and SVG. ; Definition at line 137 of file TStyle.h. ◆ fColorModelPS. Int_t TStyle::fColorModelPS. private . PostScript color model: 0 = RGB, 1 = CMYK. ; Definition at line 37 of file TStyle.h. ◆ fDateX. Float_t TStyle::fDateX. private . X position of the date in the canvas (in NDC) ; Definition at line 53 of file TStyle.h. ◆ fDateY. Float_t TStyle::fDateY. private . Y position of the date in the canvas (in NDC) ; Definition at line 54 of file TStyle.h. ◆ fDrawBorder. Int_t TStyle::fDrawBorder. private . Flag to draw border(=1) or not (0) ; Definition at line 38 of file TStyle.h. ◆ fEndErrorSize. Float_t TStyle::fEndErrorSize. private . Size of lines at the end of error bars. ; Definition at line 55 of file TStyle.h. ◆ fErrorX. Float_t TStyle::fErrorX. private . Per cent of bin width for errors along X. ; Definition at line 56 of file TStyle.h. ◆ fFitFormat. TString TStyle::fFitFormat. private . Printing format for fit parameters. ; Definition at line 133 of file TStyle.h. ◆ fFrameBorderMode. Int_t TStyle::fFrameBorderMode. private . Pad frame border mode. ; Definition at line 76 of file TStyle.h. ◆ fFrameBorderSize. Width_t TStyle::fFrameBorderSize. private . Pad frame border size. ; Definition at line 75 of file TStyle.h. ◆ fFrameFillColor. Color_t TStyle::fFrameFillColor. private . Pad frame fill color. ; Definition at line 70 of file TStyle.h. ◆ fFrameFillStyle. Style_t TStyle::fFrameFillStyle. private . Pad frame fill style. ; Definition at line 72 of file TStyle.h. ◆ fFrameLineColor. Color_t TStyle::fFrameLineColor. private . Pad frame line color. ; Definition at line 71 of file TStyle.h. ◆ fFrameLineStyle. Style_t TStyle::fFrameL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStyle.html:97612,error,error,97612,doc/master/classTStyle.html,https://root.cern,https://root.cern/doc/master/classTStyle.html,1,['error'],['error']
Availability,". private:. voidInitTreePruningMetaData(TMVA::DecisionTreeNode* n); TMVA::MsgLogger&Log() const; voidOptimize(TMVA::DecisionTree* dt, Double_t weights). Data Members; private:. TMVA::MsgLogger*fLogger! output stream to save logging information; Int_tfOptimalK! the optimal index of the prune sequence; vector<TMVA::DecisionTreeNode*,allocator<TMVA::DecisionTreeNode*> >fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Double_t>fPruneStrengthList! map of alpha -> pruning index; vector<Double_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::SeparationBase*fQualityIndexTool! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CostComplexityPruneTool( SeparationBase* qualityIndex ); the constructor for the cost complexity prunig. ~CostComplexityPruneTool(); the destructor for the cost complexity prunig. CalculatePruningInfo(TMVA::DecisionTree* dt, const vector<TMVA::Event*,allocator<TMVA::Event*> >* testEvents = NULL, Bool_t isAutomatic = kFALSE). void InitTreePruningMetaData(TMVA::DecisionTreeNode* n); initialise ""meta data"" for the pruning, like the ""costcomplexity"", the; critical alpha, the minimal alpha down the tree, etc... for each node!!. void Optimize(TMVA::DecisionTree* dt, Double_t weights); after the critical alpha values (at which the corresponding nodes would; be pruned away) had been established in the ""InitMetaData"" we need now:; automatic pruning:; find the value of ""alpha"" for which the test sample gives minimal error,; on the tree with all nodes pruned that have alpha_critital < alpha,; fixed parameter pruning. CostComplexityPruneTool( SeparationBase* qualityIndex = NULL ). » Last changed: Fri Nov 26 14:26:56 2010 » Last generated: 2010-11-26 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html:2134,down,down,2134,root/html528/TMVA__CostComplexityPruneTool.html,https://root.cern,https://root.cern/root/html528/TMVA__CostComplexityPruneTool.html,2,"['down', 'error']","['down', 'error']"
Availability,". protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications; static Long64_tTProofServ::fgLastEntryLast entry before exception; static TStringTProofServ::fgLastMsgMessage about status before exception. private:. TProofServLiteInterruptHandler*fInterruptHandler; TStringfSockPathunix socket path; Bool_tfTerminatedtrue if Terminate() has been already called. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofServLite(Int_t* argc, char** argv, FILE* flog = 0); Main constructor. Int_t CreateServer(); Finalize the server setup. If master, create the TProof instance to talk; the worker or submaster nodes.; Return 0 on success, -1 on error. ~TProofServLite(); Cleanup. Not really necessary since after this dtor there is no; live anyway. void HandleSigPipe(); Called when the client is not alive anymore; terminate the session. void HandleTermination(); Called when the client is not alive anymore; terminate the session. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. void HandleFork(TMessage* mess); Cloning itself via fork. Int_t SetupOnFork(const char* ord); Finalize the server setup afetr forking.; Return 0 on success, -1 on error. » Author: G. Ganis Oct 2005 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proofx:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServLite.html:17846,error,error,17846,root/html534/TProofServLite.html,https://root.cern,https://root.cern/root/html534/TProofServLite.html,10,"['alive', 'error']","['alive', 'error']"
Availability,". read table configurations as special table ; Definition at line 1054 of file TSQLFile.cxx. ◆ ReadFree(). void TSQLFile::ReadFree ; (; ). inlinefinalvirtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented from TFile.; Definition at line 239 of file TSQLFile.h. ◆ ReadSpecialObject(). TObject * TSQLFile::ReadSpecialObject ; (; Long64_t ; keyid, . TObject * ; obj = nullptr . ). protected . Read data of special kind of objects. ; Definition at line 851 of file TSQLFile.cxx. ◆ ReadSQLClassInfos(). void TSQLFile::ReadSQLClassInfos ; (; ). protected . Read all class infos from IdsTable. ; Definition at line 1911 of file TSQLFile.cxx. ◆ Recover(). Int_t TSQLFile::Recover ; (; ). inlinefinalvirtual . Attempt to recover file if not correctly closed. ; The function returns the number of keys that have been recovered. If no keys can be recovered, the file will be declared Zombie by the calling function. This function is automatically called when opening a file. If the file is open in read only mode, the file is not modified. If open in update mode and the function finds something to recover, a new directory header is written to the file. When opening the file gain no message from Recover will be reported. If keys have been recovered, the file is usable and you can safely read the corresponding objects. If the file is not usable (a zombie), you can test for this case with code like:; TFile f(""myfile.root"");; if (f.IsZombie()) {<actions to take if file is unusable>}; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; If the file has been recovered, the bit kRecovered is set in the TFile object in memory. You can test if the file has been recovered with if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; When writing TTrees to a file, it is importa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSQLFile.html:84582,recover,recovered,84582,doc/master/classTSQLFile.html,https://root.cern,https://root.cern/doc/master/classTSQLFile.html,1,['recover'],['recovered']
Availability,". unsigned int VariableParameters() const. const std::vector<ROOT::Minuit2::MinuitParameter>& Parameters() const; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. bool Add(const string& , double , double ); Add free Parameter Name, Value, Error. bool Add(const string& , double , double , double , double ); Add limited Parameter Name, Value, Lower bound, Upper bound. bool Add(const string& , double ); Add const Parameter Name, vale. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void RemoveLimits(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void SetName(unsigned int , const string& ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). void SetUpperLimit(const string& , double ). void SetLowerLimit(const string& , double ). void RemoveLimits(const string& ). double Value(const string& ) const. double Error(const string& ) const. unsigned int Index(const string& ) const; convert Name into external number of Parameter. const std::string & GetName(unsigned int ) const; convert external number into Name of Parameter. const char* Name(unsigned int ) const; mantain interface with const char * for backward compatibility. void SetPrecision(double eps); {fTransformation.SetPrecision(eps);}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__MnUserParameters.html:3553,Error,Error,3553,root/html602/ROOT__Minuit2__MnUserParameters.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__MnUserParameters.html,1,['Error'],['Error']
Availability,". unsigned int VariableParameters() const. const std::vector<ROOT::Minuit2::MinuitParameter>& Parameters() const; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. bool Add(const string& , double , double ); Add free Parameter Name, Value, Error. bool Add(const string& , double , double , double , double ); Add limited Parameter Name, Value, Lower bound, Upper bound. bool Add(const string& , double ); Add const Parameter Name, vale. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void RemoveLimits(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void SetName(unsigned int , const string& ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). void SetUpperLimit(const string& , double ). void SetLowerLimit(const string& , double ). void RemoveLimits(const string& ). double Value(const string& ) const. double Error(const string& ) const. unsigned int Index(const string& ) const; convert Name into external number of Parameter. const std::string & GetName(unsigned int ) const; convert external number into Name of Parameter. const char* Name(unsigned int ) const; mantain interface with const char * for backward compatibility. void SetPrecision(double eps); {fTransformation.SetPrecision(eps);}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:01; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__MnUserParameters.html:3553,Error,Error,3553,root/html534/ROOT__Minuit2__MnUserParameters.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__MnUserParameters.html,1,['Error'],['Error']
Availability,". unsigned int VariableParameters() const. const std::vector<ROOT::Minuit2::MinuitParameter>& Parameters() const; access to parameters (row-wise). std::vector<double> Params() const; access to parameters and errors in column-wise representation. std::vector<double> Errors() const. bool Add(const string& , double , double ); Add free Parameter Name, Value, Error. bool Add(const string& , double , double , double , double ); Add limited Parameter Name, Value, Lower bound, Upper bound. bool Add(const string& , double ); Add const Parameter Name, vale. void Fix(unsigned int ); interaction via external number of Parameter. void Release(unsigned int ). void RemoveLimits(unsigned int ). void SetValue(unsigned int , double ). void SetError(unsigned int , double ). void SetLimits(unsigned int , double , double ). void SetUpperLimit(unsigned int , double ). void SetLowerLimit(unsigned int , double ). void SetName(unsigned int , const string& ). double Value(unsigned int ) const. double Error(unsigned int ) const. void Fix(const string& ); interaction via Name of Parameter. void Release(const string& ). void SetValue(const string& , double ). void SetError(const string& , double ). void SetLimits(const string& , double , double ). void SetUpperLimit(const string& , double ). void SetLowerLimit(const string& , double ). void RemoveLimits(const string& ). double Value(const string& ) const. double Error(const string& ) const. unsigned int Index(const string& ) const; convert Name into external number of Parameter. const std::string & GetName(unsigned int ) const; convert external number into Name of Parameter. const char* Name(unsigned int ) const; mantain interface with const char * for backward compatibility. void SetPrecision(double eps); {fTransformation.SetPrecision(eps);}. » Last changed: root/minuit2:$Id$ » Last generated: 2015-09-08 17:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Minuit2__MnUserParameters.html:3553,Error,Error,3553,root/html604/ROOT__Minuit2__MnUserParameters.html,https://root.cern,https://root.cern/root/html604/ROOT__Minuit2__MnUserParameters.html,1,['Error'],['Error']
Availability,". virtual void TH1::SetBinErrorOption ; (; EBinErrorOpt ; type). inlinevirtual . Definition at line 381 of file TH1.h. ◆ SetBins() [1/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins . ). virtual . Redefine x axis parameters with variable bin sizes. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1 ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 8794 of file TH1.cxx. ◆ SetBins() [2/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins . ). virtual . Redefine x and y axis parameters with variable bin sizes. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1 ; Reimplemented in TProfile2D, TProfile, and TProfile3D.; Definition at line 8848 of file TH1.cxx. ◆ SetBins() [3/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins, . Int_t ; nz, . const Double_t * ; zBins . ). virtual . Redefine x, y and z axis parameters with variable bin sizes. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented in TProfile3D, TProfile, and TProfile2D.; Definition at line 8905 of file TH1.cxx. ◆ SetBins() [4/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). virtual . Redefine x axis parameters.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:205741,error,errors,205741,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,". virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). private:. static doubledummyFunction(double, int, int). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. static RooCFunction3Map<double,double,int,int>*_fmapPointer to mapping service object; void*_ptr! Pointer to embedded function. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& R__b); Custom streamer for function pointer reference object. When writing,; the function pointer is substituted by its registerd name. When function; is unregistered name 'UNKNOWN' is written and a warning is issues. When; reading back, the embedded name is converted back to a function pointer; using the mapping service. When name UNKNOWN is encountered a warning is; issues and a dummy null function is substituted. When the registered function; name can not be mapped to a function pointer an ERROR is issued and a pointer; to the dummy null function is substituted. VO operator()(double x, int y, int z) const; Evaluate embedded function. const char* name() const; Return registered name of embedded function. If function; is not registered return string with hex presentation; of function pointer value. const char* argName(Int_t iarg); Return suggested name for i-th argument. return fmap(). VO dummyFunction(double , int , int ); Dummy function used when registered function was not; found in un-persisting object. » Last changed: Tue Mar 10 17:15:33 2015 » Last generated: 2015-03-10 17:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Ref_double_double_int_int_.html:6992,ERROR,ERROR,6992,root/html534/RooCFunction3Ref_double_double_int_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Ref_double_double_int_int_.html,1,['ERROR'],['ERROR']
Availability,". void BuildOld(); rebuild the TStreamerInfo structure. void Clear(Option_t* ); If opt cointains 'built', reset this StreamerInfo as if Build or BuildOld; was never called on it (usefull to force their re-running). void CallShowMembers(const void* obj, TMemberInspector& insp, Bool_t isTransient) const; Emulated a call ShowMembers() on the obj of this class type, passing insp and parent. TObject * Clone(const char* newname = """") const; Make a clone of an object using the Streamer facility.; If newname is specified, this will be the name of the new object. Bool_t CompareContent(TClass* cl, TVirtualStreamerInfo* info, Bool_t warn, Bool_t complete, TFile* file); Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 'Equivalent' means the same number of persistent data member which the same actual C++ type and; the same name.; if 'warn' is true, Warning message are printed to explicit the differences.; if 'complete' is false, stop at the first error, otherwise continue until all members have been checked. void ComputeSize(); Compute total size of all persistent elements of the class. void ForceWriteInfo(TFile* file, Bool_t force = kFALSE); -- Recursively mark streamer infos for writing to a file. Will force this TStreamerInfo to the file and also; all the dependencies. If argument force > 0 the loop on class dependencies is forced. This function is called when streaming a class that contains; a null pointer. In this case, the TStreamerInfo for the class; with the null pointer must be written to the file and also all; the TStreamerInfo of all the classes referenced by the class. --; We must be given a file to write to. TClass * GetActualClass(const void* obj) const; Assuming that obj points to (the part of) an object that is of the; type described by this streamerInfo, return the actual type of the; object (i.e. the type described by this streamerInfo is a base class; of the actual type of the object.; This routine should only be call",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TStreamerInfo.html:23635,error,error,23635,root/html602/TStreamerInfo.html,https://root.cern,https://root.cern/root/html602/TStreamerInfo.html,4,['error'],['error']
Availability,". void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry. void RecursiveRemove(TObject* obj); If the contained histogram obj is deleted we must set its pointer to zero. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Carsten Hof 16/08/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-02 16:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1Editor.html:33367,error,error,33367,root/html604/TH1Editor.html,https://root.cern,https://root.cern/root/html604/TH1Editor.html,2,['error'],['error']
Availability,". void DoBinOffset(); Slot connected to the OffSetNumberEntry which is related to the; OffSetSlider changes the origin of the histogram inbetween a binwidth. void DoApply(); Slot connected to the Apply button of the Binning tab. void DoCancel(); Slot connected to the Cancel button of the Binning tab. TString GetHistTypeLabel(); Returns the selected histogram type (HIST, LEGO1-2, SURF1-5). TString GetHistCoordsLabel(); Return the selected coordinate system of the histogram (POL,CYL,SPH,PSR). TString GetHistErrorLabel(); Return the selected error type (E,E1-5). TString GetHistAddLabel(); Return the selected shape of the histogram (C, L, LF2). TGComboBox* BuildHistTypeComboBox(TGFrame* parent, Int_t id); Create histogram type combo box. TGComboBox* BuildHistCoordsComboBox(TGFrame* parent, Int_t id); Create coordinate system type combo box. TGComboBox* BuildHistErrorComboBox(TGFrame* parent, Int_t id); Create error type combo box. TGComboBox* BuildHistAddComboBox(TGFrame* parent, Int_t id); Create Line/Bar combo box. TGComboBox* BuildPercentComboBox(TGFrame* parent, Int_t id); Create Percentage combo box for bar option. void ChangeErrorCombo(Int_t i); Change the error combo box entry. void PaintBox3D(Float_t* p1, Float_t* p2, Float_t* p3, Float_t* p4); Paint a 3D box. Int_t* Dividers(Int_t n); Return an array of dividers of n (without the trivial divider n).; The number of dividers is saved in the first entry. void RecursiveRemove(TObject* obj); If the contained histogram obj is deleted we must set its pointer to zero. TH1Editor(const TGWindow* p = 0, Int_t width = 140, Int_t height = 30, UInt_t options = kChildFrame, Pixel_t back = GetDefaultFrameBackground()). » Author: Carsten Hof 16/08/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/ged:$Id$ » Last generated: 2015-06-30 15:07; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1Editor.html:33367,error,error,33367,root/html602/TH1Editor.html,https://root.cern,https://root.cern/root/html602/TH1Editor.html,2,['error'],['error']
Availability,". void Fill(Double_t data); Fills data member with User input data event for the unbinned option. Double_t operator()(const Double_t* x, const Double_t* p = 0) const; The class's unary function: returns the kernel density estimate. Double_t operator()(Double_t x) const; The class's unary function: returns the kernel density estimate. Double_t GetMean() const; return the mean of the data. Double_t GetSigma() const; return the standard deviation of the data. Double_t GetRAMISE() const; Returns the Root Asymptotic Mean Integrated Squared Error according to Silverman's rule of thumb with assumed Gaussian density. void SetBinCentreData(Double_t xmin, Double_t xmax); Returns the bins' centres from the data for using with the binned option. void SetBinCountData(); Returns the bins' count from the data for using with the binned option. void Draw(Option_t* option = """"); Draws either the KDE functions or its errors; Possible options:; """" (default) - draw just the kde; ""same"" draw on top of existing pad; ""Errors"" draw a TGraphErrors with the point and errors; ""confidenceinterval"" draw KDE + conf interval functions (default is 95%); ""confidenceinterval@0.90"" draw KDE + conf interval functions at 90%; Extra options can be passed in opt for drawing the TF1 or the TGraph. NOTE: The functions GetDrawnFunction(), GetDrawnUpperFunction(), GetDrawnLowerFunction(); and GetGraphWithErrors() return the corresponding drawn objects (which are maneged by the TKDE); They can be used to changes style, color, etc... void DrawErrors(TString& drawOpt); Draws a TGraphErrors for the KDE errors. TGraphErrors* GetGraphWithErrors(UInt_t npx = 100, Double_t xMin = 1.0, Double_t xMax = 0.0). void DrawConfidenceInterval(TString& drawOpt, double cl = 0.95); Draws the KDE and its confidence interval. Double_t GetFixedWeight() const; Returns the bandwidth for the non adaptive KDE. const Double_t * GetAdaptiveWeights() const; Returns the bandwidths for the adaptive KDE. UInt_t Index(Double_t x) const; Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TKDE.html:15213,error,errors,15213,root/html528/TKDE.html,https://root.cern,https://root.cern/root/html528/TKDE.html,14,"['Error', 'error']","['Errors', 'errors']"
Availability,. void ROOT::Math::MinimizerOptions::SetDefaultPrintLevel ; (; int ; level). static . Set the default Print Level. ; Possible levels are from 0 (minimal printing) to 3 (maximum printing) ; Definition at line 75 of file MinimizerOptions.cxx. ◆ SetDefaultStrategy(). void ROOT::Math::MinimizerOptions::SetDefaultStrategy ; (; int ; strat). static . Set the default strategy. ; The strategy is a parameter used only by Minuit and Minuit2. Possible values are:; strat = 0 : rough approximation of Hessian using the gradient. Avoid computing the full Hessian matrix; strat = 1 (default and recommended one) - Use Hessian approximation but compute full Hessian at the end of minimization if needed.; strat = 2 Perform several full Hessian computations during the minimization. Slower and not always working better than strat=1. . Definition at line 71 of file MinimizerOptions.cxx. ◆ SetDefaultTolerance(). void ROOT::Math::MinimizerOptions::SetDefaultTolerance ; (; double ; tol). static . Set the Minimization tolerance. ; The Default value for Minuit and Minuit2 is 0.01 ; Definition at line 55 of file MinimizerOptions.cxx. ◆ SetErrorDef(). void ROOT::Math::MinimizerOptions::SetErrorDef ; (; double ; err). inline . set error def ; Definition at line 228 of file MinimizerOptions.h. ◆ SetExtraOptions(). void ROOT::Math::MinimizerOptions::SetExtraOptions ; (; const IOptions & ; opt). set extra options (in this case pointer is cloned) ; Definition at line 210 of file MinimizerOptions.cxx. ◆ SetMaxFunctionCalls(). void ROOT::Math::MinimizerOptions::SetMaxFunctionCalls ; (; unsigned int ; maxfcn). inline . set maximum of function calls ; Definition at line 213 of file MinimizerOptions.h. ◆ SetMaxIterations(). void ROOT::Math::MinimizerOptions::SetMaxIterations ; (; unsigned int ; maxiter). inline . set maximum iterations (one iteration can have many function calls) ; Definition at line 216 of file MinimizerOptions.h. ◆ SetMinimizerAlgorithm(). void ROOT::Math::MinimizerOptions::SetMinimizerA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html:15163,toler,tolerance,15163,doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1MinimizerOptions.html,1,['toler'],['tolerance']
Availability,". void Run(Bool_t retrn = kFALSE); Main server eventloop. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. void SendStatistics(); Send statistics of slave server to master or client. void SendParallel(Bool_t async = kFALSE); Send number of parallel nodes to master or client. Int_t UnloadPackage(const char* package); Removes link to package in working directory,; removes entry from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. TMap * GetDataSetNodeMap(TFileColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:25320,error,error,25320,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,6,['error'],['error']
Availability,". void Run(Bool_t retrn = kFALSE); Main server eventloop. void SendLogFile(Int_t status = 0, Int_t start = -1, Int_t end = -1); Send log file to master.; If start > -1 send only bytes in the range from start to end,; if end <= start send everything from start. void SendStatistics(); Send statistics of slave server to master or client. void SendParallel(Bool_t async = kFALSE); Send number of parallel nodes to master or client. Int_t UnloadPackage(const char* package); Removes link to package in working directory,; removes entry from include path,; removes entry from enabled package list,; does not currently remove entry from interpreter include path.; Returns -1 in case of error, 0 otherwise. Int_t UnloadPackages(); Unloads all enabled packages. Returns -1 in case of error, 0 otherwise. Int_t Setup(); Print the ProofServ logo on standard output.; Return 0 on success, -1 on failure. Int_t SetupCommon(); Common part (between TProofServ and TXProofServ) of the setup phase.; Return 0 on success, -1 on error. void Terminate(Int_t status); Terminate the proof server. Bool_t UnlinkDataDir(const char* path); Scan recursively the datadir and unlink it if empty; Return kTRUE if it can be unlinked, kFALSE otherwise. Bool_t IsActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:24363,error,error,24363,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,4,['error'],['error']
Availability,". void Show(Long64_t entry = -1, Int_t lenmax = 20); Print values of all active leaves for entry. if entry==-1, print current entry (default); if a leaf is an array, a maximum of lenmax elements is printed. void StartViewer(); Start the TTreeViewer on this tree. ww is the width of the canvas in pixels; wh is the height of the canvas in pixels. void StopCacheLearningPhase(); stop the cache learning phase. void Streamer(TBuffer& ); Stream a class object. Int_t UnbinnedFit(const char* funcname, const char* varexp, const char* selection = """", Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Unbinned fit of one or more variable(s) from a tree. funcname is a TF1 function. See TTree::Draw for explanations of the other parameters. Fit the variable varexp using the function funcname using the; selection cuts given by selection. The list of fit options is given in parameter option.; option = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""M"" More. Improve fit results. You can specify boundary limits for some or all parameters via; func->SetParLimits(p_number, parmin, parmax);; if parmin>=parmax, the parameter is fixed; Note that you are not forced to fix the limits for all parameters.; For example, if you fit a function with 6 parameters, you can do:; func->SetParameters(0,3.1,1.e-6,0.1,-8,100);; func->SetParLimits(4,-10,-4);; func->SetParLimits(5, 1,1);; With this setup, parameters 0->3 can vary freely; Parameter 4 has boundaries [-10,-4] with initial value -8; Parameter 5 is fixed to 100. For the fit to be meaningful, the function must be self-normalized. i.e. It must have the same integral regardless of the parameter; settings. Otherwise the fit will effectively just maximize the; area. It is mandatory to have a normalization variable; which is fixed for the fit. e.g. TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:138296,Error,Errors,138296,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['Error'],['Errors']
Availability,". void TFTP::chmod ; (; const char * ; file, . Int_t ; mode . ); const. inline . Definition at line 120 of file TFTP.h. ◆ Class(). static TClass * TFTP::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFTP::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFTP::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 125 of file TFTP.h. ◆ Close(). Int_t TFTP::Close ; (; ). Close ftp connection. ; Returns 0 in case of success and -1 in case of failure. ; Definition at line 884 of file TFTP.cxx. ◆ DeclFileName(). static const char * TFTP::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 125 of file TFTP.h. ◆ DeleteDirectory(). Int_t TFTP::DeleteDirectory ; (; const char * ; dir); const. Delete a remote directory. ; Anonymous users may not delete directories. Returns 0 in case of success and -1 in case of failure. ; Definition at line 702 of file TFTP.cxx. ◆ DeleteFile(). Int_t TFTP::DeleteFile ; (; const char * ; file); const. Delete a remote file. ; Anonymous users may not delete files. Returns 0 in case of success and -1 in case of failure. ; Definition at line 821 of file TFTP.cxx. ◆ FreeDirectory(). void TFTP::FreeDirectory ; (; Bool_t ; print = kFALSE). Free a remotely open directory via rootd. ; Definition at line 956 of file TFTP.cxx. ◆ get(). void TFTP::get ; (; const char * ; file, . const char * ; localName = nullptr . ). inline . Definition at line 112 of file TFTP.h. ◆ GetBlockSize(). Int_t TFTP::GetBlockSize ; (; ); const. inline . Definition at line 80 of file TFTP.h. ◆ GetDirEntry(). const char * TFTP::GetDirEntry ; (; Bool_t ; print = kFALSE). Get directory entry via rootd. ; Returns 0 in case no more entries or in case of error. ; Definition at line 988 of file TFTP.cxx. ◆ GetFile(). Long64_t TFTP::GetFile ; (; const char * ; file, . const char * ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFTP.html:17064,failure,failure,17064,doc/master/classTFTP.html,https://root.cern,https://root.cern/doc/master/classTFTP.html,1,['failure'],['failure']
Availability,". void TFileCollection::SetList ; (; THashList * ; list). inline . Definition at line 71 of file TFileCollection.h. ◆ Sort(). void TFileCollection::Sort ; (; Bool_t ; useindex = kFALSE). Sort the collection. ; Definition at line 688 of file TFileCollection.cxx. ◆ Streamer(). void TFileCollection::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject. ◆ StreamerNVirtual(). void TFileCollection::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 108 of file TFileCollection.h. ◆ Update(). Int_t TFileCollection::Update ; (; Long64_t ; avgsize = -1). Update accumulated information about the elements of the collection (e.g. ; fTotalSize). If 'avgsize' > 0, use an average file size of 'avgsize' bytes when the size info is not available. Also updates the meta data information by summarizing the meta data of the contained objects. Return -1 in case of any failure, 0 if the total size is exact, 1 if incomplete, 2 if complete but (at least partially) estimated. ; Definition at line 312 of file TFileCollection.cxx. Member Data Documentation. ◆ fDefaultTree. TString TFileCollection::fDefaultTree. private . Definition at line 45 of file TFileCollection.h. ◆ fList. THashList* TFileCollection::fList. private . Definition at line 42 of file TFileCollection.h. ◆ fMetaDataList. TList* TFileCollection::fMetaDataList. private . Definition at line 43 of file TFileCollection.h. ◆ fNCorruptFiles. Long64_t TFileCollection::fNCorruptFiles. private . Definition at line 50 of file TFileCollection.h. ◆ fNFiles. Long64_t TFileCollection::fNFiles. private . Definition at line 47 of file TFileCollection.h. ◆ fNStagedFiles. Long64_t TFileCollection::fNStagedFiles. private . Definition at line 49 of file TFileCollection.h. ◆ fTotalSize. Long64_t TFileCollection::fTotalSize. private . Definition at line 46 of file TFileCollection.h. Libraries for TFileCollection:. [legend]; The documentation for this ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileCollection.html:25638,failure,failure,25638,doc/master/classTFileCollection.html,https://root.cern,https://root.cern/doc/master/classTFileCollection.html,1,['failure'],['failure']
Availability,. void TGScrollBarElement::SetEnabled ; (; Bool_t ; on = kTRUE). virtual . Enable/Disable scroll bar button chaging the state. ; Definition at line 149 of file TGScrollBar.cxx. ◆ SetState(). void TGScrollBarElement::SetState ; (; Int_t ; state). virtual . Change state of scrollbar element (either up or down). ; Definition at line 127 of file TGScrollBar.cxx. ◆ Streamer(). void TGScrollBarElement::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TGFrame. ◆ StreamerNVirtual(). void TGScrollBarElement::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 57 of file TGScrollBar.h. Member Data Documentation. ◆ fBgndColor. Pixel_t TGScrollBarElement::fBgndColor. protected . background color ; Definition at line 40 of file TGScrollBar.h. ◆ fHighColor. Pixel_t TGScrollBarElement::fHighColor. protected . highlight color ; Definition at line 41 of file TGScrollBar.h. ◆ fPic. const TGPicture* TGScrollBarElement::fPic. protected . picture in scrollbar element ; Definition at line 37 of file TGScrollBar.h. ◆ fPicD. const TGPicture* TGScrollBarElement::fPicD. protected . picture for disabled state of scrollbar element ; Definition at line 39 of file TGScrollBar.h. ◆ fPicN. const TGPicture* TGScrollBarElement::fPicN. protected . picture for normal state of scrollbar element ; Definition at line 38 of file TGScrollBar.h. ◆ fState. Int_t TGScrollBarElement::fState. protected . state of scrollbar element (button up or down) ; Definition at line 36 of file TGScrollBar.h. ◆ fStyle. Int_t TGScrollBarElement::fStyle. protected . modern or classic style ; Definition at line 42 of file TGScrollBar.h. Libraries for TGScrollBarElement:. [legend]; The documentation for this class was generated from the following files:; gui/gui/inc/TGScrollBar.h; gui/gui/src/TGScrollBar.cxx. TGScrollBarElement. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:43:34 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGScrollBarElement.html:31670,down,down,31670,doc/master/classTGScrollBarElement.html,https://root.cern,https://root.cern/doc/master/classTGScrollBarElement.html,1,['down'],['down']
Availability,". void TMinuit::mnmatu ; (; Int_t ; kode). virtual . Prints the covariance matrix v when KODE=1. ; always prints the global correlations, and calculates and prints the individual correlation coefficients ; Definition at line 4968 of file TMinuit.cxx. ◆ mnmigr(). void TMinuit::mnmigr ; (; ). virtual . Performs a local function minimization. ; Performs a local function minimization using basically the method of Davidon-Fletcher-Powell as modified by Fletcher; ref. – Fletcher, Comp.J. 13,317 (1970) ""switching method"" ; Definition at line 5048 of file TMinuit.cxx. ◆ mnmnos(). void TMinuit::mnmnos ; (; ). virtual . Performs a MINOS error analysis. ; Performs a MINOS error analysis on those parameters for which it is requested on the MINOS command by calling MNMNOT for each parameter requested. ; Definition at line 5388 of file TMinuit.cxx. ◆ mnmnot(). void TMinuit::mnmnot ; (; Int_t ; ilax, . Int_t ; ilax2, . Double_t & ; val2pl, . Double_t & ; val2mi . ). virtual . Performs a MINOS error analysis on one parameter. ; The parameter ILAX is varied, and the minimum of the function with respect to the other parameters is followed until it crosses the value FMIN+UP. ; Definition at line 5463 of file TMinuit.cxx. ◆ mnparm(). void TMinuit::mnparm ; (; Int_t ; k1, . TString ; cnamj, . Double_t ; uk, . Double_t ; wk, . Double_t ; a, . Double_t ; b, . Int_t & ; ierflg . ). virtual . Implements one parameter definition. ; Called from MNPARS and user-callable Implements one parameter definition, that is:; K (external) parameter number; CNAMK parameter name; UK starting value; WK starting step size or uncertainty; A, B lower and upper physical parameter limits and sets up (updates) the parameter lists. Output:; IERFLG=0 if no problems; >0 if MNPARM unable to implement definition . Definition at line 5665 of file TMinuit.cxx. ◆ mnpars(). void TMinuit::mnpars ; (; TString & ; crdbuf, . Int_t & ; icondn . ). virtual . Implements one parameter definition. ; Called from MNREAD and user-ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:56889,error,error,56889,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['error']
Availability,". void TUnixSystem::Openlog ; (; const char * ; name, . Int_t ; options, . ELogFacility ; facility . ). overridevirtual . Open connection to system log daemon. ; For the use of the options and facility see the Unix openlog man page. ; Reimplemented from TSystem.; Definition at line 2616 of file TUnixSystem.cxx. ◆ OpenPipe(). FILE * TUnixSystem::OpenPipe ; (; const char * ; shellcmd, . const char * ; mode . ). overridevirtual . Open a pipe. ; Reimplemented from TSystem.; Definition at line 2163 of file TUnixSystem.cxx. ◆ PrependPathName(). const char * TUnixSystem::PrependPathName ; (; const char * ; dir, . TString & ; name . ). overridevirtual . Concatenate a directory and a file name. ; Reimplemented from TSystem.; Definition at line 1552 of file TUnixSystem.cxx. ◆ RecvBuf(). int TUnixSystem::RecvBuf ; (; int ; sock, . void * ; buf, . int ; length . ). overridevirtual . Receive a buffer headed by a length indicator. ; Length is the size of the buffer. Returns the number of bytes received in buf or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 3316 of file TUnixSystem.cxx. ◆ RecvRaw(). int TUnixSystem::RecvRaw ; (; int ; sock, . void * ; buf, . int ; length, . int ; opt . ). overridevirtual . Receive exactly length bytes into buffer. ; Use opt to receive out-of-band data or to have a peek at what is in the buffer (see TSocket). Buffer must be able to store at least length bytes. Returns the number of bytes received (can be 0 if other side of connection was closed) or -1 in case of error, -2 in case of MSG_OOB and errno == EWOULDBLOCK, -3 in case of MSG_OOB and errno == EINVAL and -4 in case of kNoBlock and errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer (EPIPE || ECONNRESET). ; Reimplemented from TSystem.; Definition at line 3368 of file TUnixSystem.cxx. ◆ RedirectOutput(). Int_t TUnixSystem::RedirectOutput ; (; const char * ; file, . const char * ; mode = ""a"", . RedirectHandle_t * ; h = nullptr . ). overridevirtual . Redire",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:61432,error,error,61432,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability,". we found what we are looking for ... }. const char * GetPathStatic() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). const char * GetPath() const; Returns the full path of the directory. E.g. file:/dir1/dir2.; The returned path will be re-used by the next call to GetPath(). void FillFullPath(TString& buf) const; recursive method to fill full path for directory. TDirectory * mkdir(const char* name, const char* title = """"); Create a sub-directory and return a pointer to the created directory.; Returns 0 in case of error.; Returns 0 if a directory with the same name already exists.; Note that the directory name may be of the form ""a/b/c"" to create a hierarchy of directories.; In this case, the function returns the pointer to the ""a"" directory if the operation is successful. For example the step to the steps to create first a/b/c and then a/b/d without receiving; and errors are:; TFile * file = new TFile(""afile"",""RECREATE"");; file->mkdir(""a"");; file->cd(""a"");; gDirectory->mkdir(""b"");; gDirectory->cd(""b"");; gDirectory->mkdir(""d"");. void ls(Option_t* option = """") const; List Directory contents. Indentation is used to identify the directory tree; Subdirectories are listed first, then objects in memory. The option can has the following format:; [<regexp>]; The <regexp> will be used to match the name of the objects.; By default memory and disk objects are listed. void Paint(Option_t* option = """"); Paint all objects in the directory. void Print(Option_t* option = """") const; Print all objects in the directory. void pwd() const; Print the path of the directory. void RecursiveRemove(TObject* obj); Recursively remove object from a Directory. TObject * Remove(TObject* ); Remove an object from the in-memory list. void rmdir(const char* name); Removes subdirectory from the directory; When directory is deleted, all keys in all subdirectories will be; read first and deleted from file (if exists); E",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDirectory.html:19123,error,errors,19123,root/html534/TDirectory.html,https://root.cern,https://root.cern/root/html534/TDirectory.html,6,['error'],['errors']
Availability,". where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (copy the function if option has been enabled in the constructor). \@param f Function to be differentiated. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html602/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__RichardsonDerivator.html,12,['error'],['error']
Availability,". where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (copy the function if option has been enabled in the constructor). \@param f Function to be differentiated. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:00; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html534/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__RichardsonDerivator.html,12,['error'],['error']
Availability,". where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative2(const ROOT::Math::IGenFunction& f, double x, double h). Second Derivative calculation passing function and step-size. double Derivative3(double x). Returns the third derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundoff error + interpolation error); the estimate of the roundoff error is taken as follows:. where k is the double precision, ai are coefficients used in; central difference formulas; interpolation error is decreased by making the step size h smaller. double Derivative3(const ROOT::Math::IGenFunction& f, double x, double h). Third Derivative calculation passing function and step-size. void SetFunction(const ROOT::Math::IGenFunction& f); Set function for derivative calculation (copy the function if option has been enabled in the constructor). \@param f Function to be differentiated. void SetStepSize(double h); Set step size for derivative calculation. \@param h step size for calculation. { fStepSize = h; }. » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:35; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__RichardsonDerivator.html:6566,error,error,6566,root/html604/ROOT__Math__RichardsonDerivator.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__RichardsonDerivator.html,12,['error'],['error']
Availability,". with neg. and pos. weights in node and don't boost them; Bool_tfPruneBeforeBoostflag to prune before boosting; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig; TStringfPruneMethodSprune method option String; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted; Bool_tfRandomisedTreeschoose a random subset of possible cut variables at each node during training; Bool_tfRenormByClassindividually re-normalize each event class to the original size after boosting; map<TMVA::Event*,std::vector<double> >fResidualsindividual event residuals for gradient boost; Double_tfSampleFractionfraction of events used for bagged grad boost; Double_tfSampleSizeFractionrelative size of bagged event sample to original sample size; TMVA::SeparationBase*fSepTypethe separation used in node splitting; TStringfSepTypeSthe separation (option string) used in node splitting; Double_tfShrinkagelearning rate for gradient boost;; vector<TMVA::Event*>fSubSamplesubsample for bagged grad boost; Double_tfSumOfWeightssum of all event weights; Bool_tfTrainWithNegWeightsyes there are negative event weights and we don't ignore them; Double_tfTransitionPointbreak-down point for gradient regression; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; UInt_tfUseNTrainEventsnumber of randomly picked training events used in randomised (and bagged) trees; UInt_tfUseNvarsthe number of variables used in the randomised tree splitting; Bool_tfUsePoissonNvarsuse ""fUseNvars"" not as fixed number but as mean of a possion distr. in each split; Bool_tfUseWeightedTreesuse average classification from the trees, or have the individual trees trees in the forest weighted (e.g. log(boostweight) from AdaBoost; Bool_tfUseYesNoLeafuse sig or bkg classification in leave nodes or sig/bkg; vector<TMVA::Event*>fValidationSamplethe ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBDT.html:24150,down,down,24150,root/html530/TMVA__MethodBDT.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBDT.html,3,['down'],['down']
Availability,". ◆ ClearDataSetCache(). void TProofLite::ClearDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Clear the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2282 of file TProofLite.cxx. ◆ CopyMacroToCache(). Int_t TProofLite::CopyMacroToCache ; (; const char * ; macro, . Int_t ; headerRequired = 0, . TSelector ** ; selector = 0, . Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ; If headerRequired is 1, return -1 in case the header is not found. If headerRequired is 0, try to copy header too. If headerRequired is -1, don't look for header, only copy macro. If the selector pionter is not 0, consider the macro to be a selector and try to load the selector and set it to the pointer. The mask 'opt' is an or of ESendFileOpt: kCpBin (0x8) Retrieve from the cache the binaries associated with the file kCp (0x10) Retrieve the files from the cache Return -1 in case of error, 0 otherwise. ; Definition at line 1593 of file TProofLite.cxx. ◆ CreateSandbox(). Int_t TProofLite::CreateSandbox ; (; ). private . Create the sandbox for this session. ; Definition at line 880 of file TProofLite.cxx. ◆ DeclFileName(). static const char * TProofLite::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 170 of file TProofLite.h. ◆ DrawSelect(). Long64_t TProofLite::DrawSelect ; (; TDSet * ; dset, . const char * ; varexp, . const char * ; selection = """", . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Execute the specified drawing action on a data set (TDSet). ; Event- or Entry-lists should be set in the data set object using TDSet::SetEntryList. Returns -1 in case of error or number of selected events otherwise. ; Reimplemented from TProof.; Definition at line 1053 of f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:49892,mask,mask,49892,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,2,"['error', 'mask']","['error', 'mask']"
Availability,". ◆ GetSearchJson(). std::string ROOT::RGeomDescription::GetSearchJson ; (; ); const. inline . Definition at line 384 of file RGeomData.hxx. ◆ GetTopVisible(). bool ROOT::RGeomDescription::GetTopVisible ; (; ); const. inline . Returns draw options, used for JSROOT TGeoPainter. ; Definition at line 334 of file RGeomData.hxx. ◆ GetUsedNSegments(). int RGeomDescription::GetUsedNSegments ; (; int ; min = 20). private . Returns really used number of cylindrical segments. ; Definition at line 922 of file RGeomData.cxx. ◆ GetVisLevel(). int ROOT::RGeomDescription::GetVisLevel ; (; ); const. inline . Returns maximal visible level. ; Definition at line 329 of file RGeomData.hxx. ◆ GetVolume(). TGeoVolume * RGeomDescription::GetVolume ; (; int ; nodeid). private . Get volume for specified nodeid If specific volume was configured, it will be returned for nodeid==0. ; Definition at line 583 of file RGeomData.cxx. ◆ HasDrawData(). bool RGeomDescription::HasDrawData ; (; ); const. Check if there is draw data available. ; Definition at line 1331 of file RGeomData.cxx. ◆ IsBuild(). bool ROOT::RGeomDescription::IsBuild ; (; ); const. inline . Definition at line 371 of file RGeomData.hxx. ◆ IsBuildShapes(). int ROOT::RGeomDescription::IsBuildShapes ; (; ); const. inline . Returns true if binary 3D model build already by C++ server (default) ; Definition at line 339 of file RGeomData.hxx. ◆ IsPhysNodeVisible(). int RGeomDescription::IsPhysNodeVisible ; (; const std::vector< int > & ; stack). private . Check if there special settings for specified physical node returns -1 if nothing is found. ; Definition at line 2043 of file RGeomData.cxx. ◆ IsPreferredOffline(). bool ROOT::RGeomDescription::IsPreferredOffline ; (; ); const. inline . Is offline operations preferred. ; After get full description, client can do most operations without extra requests ; Definition at line 361 of file RGeomData.hxx. ◆ IsPrincipalEndNode(). bool RGeomDescription::IsPrincipalEndNode ; (; int ; nodeid). return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:17533,avail,available,17533,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,1,['avail'],['available']
Availability,. ◆ GetTestInterval(). template<typename Architecture_t > . size_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTestInterval ; (; ); const. inline . Definition at line 150 of file DLMinimizers.h. ◆ GetTrainingError(). template<typename Architecture_t > . Scalar_t TMVA::DNN::TDLGradientDescent< Architecture_t >::GetTrainingError ; (; ); const. inline . Definition at line 148 of file DLMinimizers.h. ◆ HasConverged() [1/2]. template<typename Architecture_t > . bool TMVA::DNN::TDLGradientDescent< Architecture_t >::HasConverged. Increases the minimization step counter by the test error evaluation period and uses the current internal value of the test error to determine if the minimization has converged. ; Definition at line 276 of file DLMinimizers.h. ◆ HasConverged() [2/2]. template<typename Architecture_t > . bool TMVA::DNN::TDLGradientDescent< Architecture_t >::HasConverged ; (; Scalar_t ; testError). Increases the minimization step counter by the test error evaluation period and uses the provided test error value to determine if the minimization has converged. ; Definition at line 290 of file DLMinimizers.h. ◆ Reset(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::Reset ; (; ). inline . Reset minimizer object to default state. ; Definition at line 89 of file DLMinimizers.h. ◆ SetBatchSize(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetBatchSize ; (; Scalar_t ; rate). inline . Definition at line 156 of file DLMinimizers.h. ◆ SetConvergenceSteps(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetConvergenceSteps ; (; size_t ; steps). inline . Setters. ; Definition at line 153 of file DLMinimizers.h. ◆ SetLearningRate(). template<typename Architecture_t > . void TMVA::DNN::TDLGradientDescent< Architecture_t >::SetLearningRate ; (; Scalar_t ; rate). inline . Definition at line 155 of file DLMinimizers.h. ◆ SetTestInterval(). t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html:6578,error,error,6578,doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1DNN_1_1TDLGradientDescent.html,2,['error'],['error']
Availability,". ◆ SetDisplay(). void TSystem::SetDisplay ; (; ). virtual . Set DISPLAY environment variable based on utmp entry. Only for UNIX. ; Reimplemented in TUnixSystem.; Definition at line 235 of file TSystem.cxx. ◆ SetDynamicPath(). void TSystem::SetDynamicPath ; (; const char * ; pathname). virtual . Set the dynamic path to a new value. ; If the value of 'path' is zero, the dynamic path is reset to its default value. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1806 of file TSystem.cxx. ◆ Setenv(). void TSystem::Setenv ; (; const char * ; name, . const char * ; value . ). virtual . Set environment variable. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 1649 of file TSystem.cxx. ◆ SetErrorStr(). void TSystem::SetErrorStr ; (; const char * ; errstr). Set the system error string. ; This string will be used by GetError(). To be used in case one does not want or can use the system error string (e.g. because error is generated by a third party POSIX like library that does not use standard errno). ; Definition at line 245 of file TSystem.cxx. ◆ SetFlagsDebug(). void TSystem::SetFlagsDebug ; (; const char * ; flags). virtual . FlagsDebug should contain the options to pass to the C++ compiler in order to compile the library in debug mode. ; Definition at line 4056 of file TSystem.cxx. ◆ SetFlagsOpt(). void TSystem::SetFlagsOpt ; (; const char * ; flags). virtual . FlagsOpt should contain the options to pass to the C++ compiler in order to compile the library in optimized mode. ; Definition at line 4065 of file TSystem.cxx. ◆ SetFPEMask(). Int_t TSystem::SetFPEMask ; (; Int_t ; mask = kDefaultMask). virtual . Set which conditions trigger a floating point exception. ; Return the previous set of conditions. ; Reimplemented in TUnixSystem, and TWinNTSystem.; Definition at line 642 of file TSystem.cxx. ◆ SetIncludePath(). void TSystem::SetIncludePath ; (; const char * ; includePath). virtual . IncludePath should contain the list of comp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSystem.html:84862,error,error,84862,doc/master/classTSystem.html,https://root.cern,https://root.cern/doc/master/classTSystem.html,1,['error'],['error']
Availability,". ◆ TLinearMinimizer() [2/2]. TLinearMinimizer::TLinearMinimizer ; (; const char * ; type). Constructor from a char * (used by PM) ; Definition at line 82 of file TLinearMinimizer.cxx. ◆ ~TLinearMinimizer(). TLinearMinimizer::~TLinearMinimizer ; (; ). override . Destructor (no operations) ; Definition at line 100 of file TLinearMinimizer.cxx. Member Function Documentation. ◆ Class(). static TClass * TLinearMinimizer::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TLinearMinimizer::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TLinearMinimizer::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 126 of file TLinearMinimizer.h. ◆ CovMatrix(). double TLinearMinimizer::CovMatrix ; (; unsigned int ; i, . unsigned int ; j . ); const. inlineoverridevirtual . return covariance matrices elements if the variable is fixed the matrix is zero The ordering of the variables is the same as in errors ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 95 of file TLinearMinimizer.h. ◆ CovMatrixStatus(). int TLinearMinimizer::CovMatrixStatus ; (; ); const. inlineoverridevirtual . return covariance matrix status ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 100 of file TLinearMinimizer.h. ◆ DeclFileName(). static const char * TLinearMinimizer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 126 of file TLinearMinimizer.h. ◆ Edm(). double TLinearMinimizer::Edm ; (; ); const. inlineoverridevirtual . return expected distance reached from the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 66 of file TLinearMinimizer.h. ◆ Errors(). const double * TLinearMinimizer::Errors ; (; ); const. inlineoverridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 89 of file TLinearMinimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearMinimizer.html:12663,error,errors,12663,doc/master/classTLinearMinimizer.html,https://root.cern,https://root.cern/doc/master/classTLinearMinimizer.html,1,['error'],['errors']
Availability,". ◆ writeToStream(). void RooRealVar::writeToStream ; (; std::ostream & ; os, . bool ; compact . ); const. overridevirtual . Write object contents to given stream. ; Reimplemented from RooAbsRealLValue.; Definition at line 700 of file RooRealVar.cxx. Member Data Documentation. ◆ _altNonSharedBinning. std::unordered_map<std::string,std::unique_ptr<RooAbsBinning> > RooRealVar::_altNonSharedBinning. protected . ! Non-shareable alternative binnings ; Definition at line 157 of file RooRealVar.h. ◆ _asymErrHi. double RooRealVar::_asymErrHi. protected . High side of asymmetric error associated with current value. ; Definition at line 155 of file RooRealVar.h. ◆ _asymErrLo. double RooRealVar::_asymErrLo. protected . Low side of asymmetric error associated with current value. ; Definition at line 154 of file RooRealVar.h. ◆ _binning. std::unique_ptr<RooAbsBinning> RooRealVar::_binning. protected . Definition at line 156 of file RooRealVar.h. ◆ _error. double RooRealVar::_error. protected . Symmetric error associated with current value. ; Definition at line 153 of file RooRealVar.h. ◆ _printScientific. bool RooRealVar::_printScientific. staticprotected . Definition at line 139 of file RooRealVar.h. ◆ _printSigDigits. Int_t RooRealVar::_printSigDigits. staticprotected . Definition at line 140 of file RooRealVar.h. ◆ _sharedProp. std::shared_ptr<RooRealVarSharedProperties> RooRealVar::_sharedProp. protected . ! Shared binnings associated with this instance ; Definition at line 169 of file RooRealVar.h. ◆ _valueResetCounter. std::size_t RooRealVar::_valueResetCounter = 0. protected . ! How many times the value of this variable was reset ; Definition at line 171 of file RooRealVar.h. Libraries for RooRealVar:. [legend]; The documentation for this class was generated from the following files:; roofit/roofitcore/inc/RooRealVar.h; roofit/roofitcore/src/RooRealVar.cxx. RooRealVar. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:07 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:93260,error,error,93260,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['error'],['error']
Availability,"."");; 2154 t.ReplaceAll(""#aa"",""\\mbox{\\aa}"");; 2155 t.ReplaceAll(""#AA"",""\\mbox{\\AA}"");; 2156 ; 2157 t.ReplaceAll(""#omicron"",""o"");; 2158 t.ReplaceAll(""#Alpha"",""A"");; 2159 t.ReplaceAll(""#Beta"",""B"");; 2160 t.ReplaceAll(""#Epsilon"",""E"");; 2161 t.ReplaceAll(""#Zeta"",""Z"");; 2162 t.ReplaceAll(""#Eta"",""H"");; 2163 t.ReplaceAll(""#Iota"",""I"");; 2164 t.ReplaceAll(""#Kappa"",""K"");; 2165 t.ReplaceAll(""#Mu"",""M"");; 2166 t.ReplaceAll(""#Nu"",""N"");; 2167 t.ReplaceAll(""#Omicron"",""O"");; 2168 t.ReplaceAll(""#Rho"",""P"");; 2169 t.ReplaceAll(""#Tau"",""T"");; 2170 t.ReplaceAll(""#Chi"",""X"");; 2171 t.ReplaceAll(""#varomega"",""\\varpi"");; 2172 ; 2173 t.ReplaceAll(""#varUpsilon"",""?"");; 2174 t.ReplaceAll(""#corner"",""?"");; 2175 t.ReplaceAll(""#ltbar"",""?"");; 2176 t.ReplaceAll(""#bottombar"",""?"");; 2177 t.ReplaceAll(""#notsubset"",""?"");; 2178 t.ReplaceAll(""#arcbottom"",""?"");; 2179 t.ReplaceAll(""#cbar"",""?"");; 2180 t.ReplaceAll(""#arctop"",""?"");; 2181 t.ReplaceAll(""#topbar"",""?"");; 2182 t.ReplaceAll(""#arcbar"",""?"");; 2183 t.ReplaceAll(""#downleftarrow"",""?"");; 2184 t.ReplaceAll(""#splitline"",""\\genfrac{}{}{0pt}{}"");; 2185 ; 2186 t.ReplaceAll(""#"",""\\"");; 2187 t.ReplaceAll(""%"",""\\%"");; 2188 }; 2189 gVirtualPS->Text(x,y,t.Data());; 2190 } else {; 2191 Bool_t saveb = gPad->IsBatch();; 2192 gPad->SetBatch(kTRUE);; 2193 if (!PaintLatex1( x, y, angle, size, text1)) {; 2194 if (saveps) gVirtualPS = saveps;; 2195 return;; 2196 }; 2197 gPad->SetBatch(saveb);; 2198 }; 2199 gVirtualPS = nullptr;; 2200 }; 2201 ; 2202 if (!gPad->IsBatch()) PaintLatex1( x, y, angle, size, text1);; 2203 if (saveps) gVirtualPS = saveps;; 2204}; 2205 ; 2206////////////////////////////////////////////////////////////////////////////////; 2207/// Drawing function; 2208 ; 2209Int_t TLatex::PaintLatex1(Double_t x, Double_t y, Double_t angle, Double_t size, const Char_t *text1); 2210{; 2211 if (!gPad) return 0;; 2212 TString newText = text1;; 2213 if( newText.Length() == 0) return 0;; 2214 newText.ReplaceAll(""#hbox"",""#mbox"");; 2215 ; 2216 fError = nullptr;; 2217 if (C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:79566,down,downleftarrow,79566,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['down'],['downleftarrow']
Availability,".) const;  Issue system error message. ;  ; R__ALWAYS_INLINE Bool_t TestBit (UInt_t f) const;  ; Int_t TestBits (UInt_t f) const;  ; virtual void UseCurrentStyle ();  Set current style settings in this object This function is called when either TCanvas::UseCurrentStyle or TROOT::ForceStyle have been invoked. ;  ; virtual void Warning (const char *method, const char *msgfmt,...) const;  Issue warning message. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0);  Write this object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Private Attributes; Arrays used to store the packed inputs; TObjArray fSignal;  Packed input signal. ;  ; TObjArray fBackground;  Packed input background. ;  ; TObjArray fCandidates;  Packed input candidates (data) ;  ; TObjArray fErrorOnSignal;  Packed error sources for signal. ;  ; TObjArray fErrorOnBackground;  Packed error sources for background. ;  ; TObjArray fIds;  Packed IDs for the different error sources. ;  . TObjArray fDummyTA;  Dummy objects the class will use and delete. ;  ; TObjArray fDummyIds;  Array of dummy object (used for bookeeping) ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Static Public Member Functions inherited from TObject; static TClass * Class (); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLimitDataSource.html:9595,error,error,9595,doc/master/classTLimitDataSource.html,https://root.cern,https://root.cern/doc/master/classTLimitDataSource.html,1,['error'],['error']
Availability,".); Performs the operation: this = this*c*f1; if errors are defined, errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after THnSparse::Multiply. void Divide(const THnSparse* h); Divide this histogram by h; this = this/(h); Note that if h has Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content. void Divide(const THnSparse* h1, const THnSparse* h2, Double_t c1 = 1., Double_t c2 = 1., Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2; this = (c1*h1)/(c2*h2); Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for; this if not already set.; The resulting errors are calculated assuming uncorrelated content.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. Bool_t CheckConsistency(const THnSparse* h, const char* tag) const; Consistency check on (some of) the parameters of two histograms (for operations). void SetBinEdges(Int_t idim, const Double_t* bins); Set the axis # of bins and bin limits on dimension idim. void SetBinContent(const Int_t* x, Double_t v); Set content of bin with coordinates ""coord"" to ""v"". void SetBinContent(Long64_t bin, Double_t v); Set content of bin with index ""bin"" to ""v"". void SetBinError(const Int_t* x, Double_t e); Set error of bin with coordinates ""coord"" to ""e"", enable errors if needed. void SetBinError(Long64_t bin, Double_t e); Set error of bin with index ""bin"" to ""e"", enable errors if needed. void Sumw2(); Enable calculation of errors. THnSparse* Rebin(Int_t group) const; Combine the content of ""group"" neighboring bins into; a new bin and return the resulting THnSparse.; For group=2 and a 3 dimensional h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THnSparse.html:23156,error,errors,23156,root/html528/THnSparse.html,https://root.cern,https://root.cern/root/html528/THnSparse.html,4,['error'],['errors']
Availability,"., 4., target: 0., 0.1, 0.2, 0.3, 0.4 . Definition at line 859 of file RAxis.hxx. ◆ EColumnType. enum class ROOT::Experimental::EColumnType. strong . EnumeratorkUnknown ; kIndex64 ; kIndex32 ; kSwitch ; kByte ; kChar ; kBit ; kReal64 ; kReal32 ; kReal16 ; kInt64 ; kUInt64 ; kInt32 ; kUInt32 ; kInt16 ; kUInt16 ; kInt8 ; kUInt8 ; kSplitIndex64 ; kSplitIndex32 ; kSplitReal64 ; kSplitReal32 ; kSplitInt64 ; kSplitUInt64 ; kSplitInt32 ; kSplitUInt32 ; kSplitInt16 ; kSplitUInt16 ; kMax . Definition at line 43 of file RColumnModel.hxx. ◆ EIOFeatures. enum class ROOT::Experimental::EIOFeatures. strong . EnumeratorkGenerateOffsetMap ; kSupported . Definition at line 52 of file TIOFeatures.hxx. ◆ EIOUnsupportedFeatures. enum class ROOT::Experimental::EIOUnsupportedFeatures. strong . EnumeratorkUnsupported . Definition at line 61 of file TIOFeatures.hxx. ◆ ELogLevel. enum class ROOT::Experimental::ELogLevel : unsigned char. strong . Kinds of diagnostics. . EnumeratorkUnset ; kFatal An error which causes further processing to be unreliable. . kError An error. . kWarning Warnings about likely unexpected behavior. . kInfo Informational messages; used for instance for tracing. . kDebug Debug information; only useful for developers; can have added verbosity up to 255-kDebug. . Definition at line 36 of file RLogger.hxx. ◆ ENTupleInfo. enum class ROOT::Experimental::ENTupleInfo. strong . Listing of the different options that can be printed by RNTupleReader::GetInfo() . EnumeratorkSummary ; kStorageDetails ; kMetrics . Definition at line 43 of file RNTupleReader.hxx. ◆ ENTupleInspectorHist. enum class ROOT::Experimental::ENTupleInspectorHist. strong . EnumeratorkCount ; kNElems ; kCompressedSize ; kUncompressedSize . Definition at line 43 of file RNTupleInspector.hxx. ◆ ENTupleInspectorPrintFormat. enum class ROOT::Experimental::ENTupleInspectorPrintFormat. strong . EnumeratorkTable ; kCSV . Definition at line 42 of file RNTupleInspector.hxx. ◆ ENTupleStructure. enum ROOT::Experimental:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html:40630,error,error,40630,doc/v632/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Experimental.html,1,['error'],['error']
Availability,"., see THistPainter::Paint; 'Add' : ComboBox: further things which can be added to the; histogram (None, simple/smooth line, fill area; 'Simple Drawing': CheckBox: draw a simple histogram without; errors (= ""HIST"" drawoption). In combination with; some other draw options an outer line is drawn on; top of the histogram; 'Show markers': CheckBox: draw a marker on to of each bin (=""P""; drawoption); 'Draw bar chart': CheckBox: draw a bar chart (=""B"" drawoption); change the Fill Color with Fill in the Style Tab; => will show Bar menue in the Style Tab; 'Bar option': CheckBox: draw a bar chart (=""BAR"" drawoption); => will show Bar menue in the Style Tab; 3d Plot:; 'Type' : ComboBox: set histogram type Lego-Plot or Surface; draw(Lego, Lego1.2, Surf, Surf1..5); see THistPainter::Paint; 'Coords' : ComboBox: set the coordinate system (Cartesian, ..; Spheric) see THistPainter::Paint; 'Error' : see 2D plot; 'Bar' : change the bar attributes; 'W' : change Bar Width; 'O' : change Bar Offset; 'Percentage': specifies the percentage of the bar which is drawn; brighter and darker (10% == BAR1 drawoption); 'Horizontal Bar': draw a horizontal bar chart. 'Marker' : change the Marker attributes (color, appearance,; thickness) see TAttMarkerEditor. /*. */. This Tab has two different layouts. One is for a histogram which; is not drawn from an ntuple. The other one is available for a; histogram which is drawn from an ntuple. In this case the rebin; algorithm can create a rebinned histogram from the original data; i.e. the ntuple.; To see te differences do:; TFile f(""hsimple.root"");; hpx->Draw(""BAR1""); // non ntuple histogram; ntuple->Draw(""px""); // ntuple histogram; Non ntuple histogram:; 'Rebin': with the Slider the number of bins (shown in the field; below the Slider) can be changed to any number which; divides the number of bins of the original histogram.; Pushing 'Apply' will delete the origin histogram and; replace it by the rebinned one on the screen; Pushing 'Ignore' the origin histog",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TH1Editor.html:2010,Error,Error,2010,root/html532/TH1Editor.html,https://root.cern,https://root.cern/root/html532/TH1Editor.html,4,['Error'],['Error']
Availability,"..........; // 1) :; TF1NormSum *fnorm_exp_cb = new TF1NormSum(f_cb, f_exp, nsig, nbkg);; // 4) :; ; TF1 *f_sum = new TF1(""fsum"", *fnorm_exp_cb, -5., 5., fnorm_exp_cb->GetNpar());; ; // III.:; f_sum->SetParameters(fnorm_exp_cb->GetParameters().data());; f_sum->SetParName(1, ""NBackground"");; f_sum->SetParName(0, ""NSignal"");; for (int i = 2; i < f_sum->GetNpar(); ++i); f_sum->SetParName(i, fnorm_exp_cb->GetParName(i));; ; // GENERATE HISTOGRAM TO FIT ..............................................................; TStopwatch w;; w.Start();; TH1D *h_sum = new TH1D(""h_ExpCB"", ""Exponential Bkg + CrystalBall function"", nBins, -5., 5.);; h_sum->FillRandom(""fsum"", nEvents);; printf(""Time to generate %d events: "", nEvents);; w.Print();; ; // need to scale histogram with width since we are fitting a density; h_sum->Sumw2();; h_sum->Scale(1., ""width"");; ; // fit - use Minuit2 if available; ROOT::Math::MinimizerOptions::SetDefaultMinimizer(""Minuit2"");; new TCanvas(""Fit"", ""Fit"", 800, 1000);; // do a least-square fit of the spectrum; auto result = h_sum->Fit(""fsum"", ""SQ"");; result->Print();; h_sum->Draw();; printf(""Time to fit using ROOT TF1Normsum: "");; w.Print();; ; // test if parameters are fine; std::vector<double> pref = {nsig, nbkg, signal_mean};; for (unsigned int i = 0; i < pref.size(); ++i) {; if (!TMath::AreEqualAbs(pref[i], f_sum->GetParameter(i), f_sum->GetParError(i) * 10.)); Error(""testFitNormSum"", ""Difference found in fitted %s - difference is %g sigma"", f_sum->GetParName(i),; (f_sum->GetParameter(i) - pref[i]) / f_sum->GetParError(i));; }; ; gStyle->SetOptStat(0);; // add parameters; auto t1 = new TLatex(; -2.5, 300000, TString::Format(""%s = %8.0f #pm %4.0f"", ""NSignal"", f_sum->GetParameter(0), f_sum->GetParError(0)));; auto t2 = new TLatex(; -2.5, 270000, TString::Format(""%s = %8.0f #pm %4.0f"", ""Nbackgr"", f_sum->GetParameter(1), f_sum->GetParError(1)));; t1->Draw();; t2->Draw();; }; MinimizerOptions.h; TCanvas.h; Errorvoid Error(const char *location, const char *msg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitNormSum_8C.html:2857,avail,available,2857,doc/master/fitNormSum_8C.html,https://root.cern,https://root.cern/doc/master/fitNormSum_8C.html,1,['avail'],['available']
Availability,"...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Private Member Functions |; Static Private Member Functions |; List of all members ; TSVDUnfold Class ReferenceHistogram Library. ; SVD Approach to Data Unfolding. ; Reference: Nucl. Instrum. Meth. A372, 469 (1996) [hep-ph/9509307] ; TSVDUnfold implements the singular value decomposition based unfolding method (see reference). Currently, the unfolding of one-dimensional histograms is supported, with the same number of bins for the measured and the unfolded spectrum. ; The unfolding procedure is based on singular value decomposition of the response matrix. The regularisation of the unfolding is implemented via a discrete minimum-curvature condition. ; Monte Carlo inputs: . xini: true underlying spectrum (TH1D, n bins) . bini: reconstructed spectrum (TH1D, n bins) . Adet: response matrix (TH2D, nxn bins) . Consider the unfolding of a measured spectrum bdat with covariance matrix Bcov (if not passed explicitly, a diagonal covariance will be built given the errors of bdat). The corresponding spectrum in the Monte Carlo is given by bini, with the true underlying spectrum given by xini. The detector response is described by Adet, with Adet filled with events (not probabilities) with the true observable on the y-axis and the reconstructed observable on the x-axis. ; The measured distribution can be unfolded for any combination of resolution, efficiency and acceptance effects, provided an appropriate definition of xini and Adet. The unfolding can be performed by TSVDUnfold *tsvdunf = new TSVDUnfold( bdat, Bcov, bini, xini, Adet );; TH1D* unfresult = tsvdunf->Unfold( kreg );; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TSVDUnfoldSVD Approach to Data Unfolding.Definition TSVDUnfold.h:46; TSVDUnfold::UnfoldTH1D * Unfold(Int_t kreg)Perform the unfolding with regularisation parameter kreg.Definition TSVDUnfold.cxx:237; where kreg determ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSVDUnfold.html:1169,error,errors,1169,doc/master/classTSVDUnfold.html,https://root.cern,https://root.cern/doc/master/classTSVDUnfold.html,1,['error'],['errors']
Availability,"...;  ; class  MnHesse;  API class for calculating the numerical covariance matrix (== 2x Inverse Hessian == 2x Inverse 2nd derivative); can be used by the user or Minuit itself. More...;  ; class  MnLineSearch;  Implements a 1-dimensional minimization along a given direction (i.e. More...;  ; class  MnMachinePrecision;  Sets the relative floating point (double) arithmetic precision. More...;  ; class  MnMigrad;  API class for minimization using Variable Metric technology (""MIGRAD""); allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by MnMinos and MnContours;. More...;  ; class  MnMinimize;  API class for minimization using Variable Metric technology (""MIGRAD""); allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.; also used by MnMinos and MnContours;. More...;  ; class  MnMinos;  API class for Minos Error analysis (asymmetric errors); minimization has to be done before and Minimum must be valid; possibility to ask only for one side of the Minos Error;. More...;  ; class  MnParabola;  This class defines a parabola of the form a*x*x + b*x + c. More...;  ; class  MnParabolaFactory;  ; class  MnParabolaPoint;  A point of a parabola. More...;  ; class  MnParameterScan;  Scans the values of FCN as a function of one Parameter and retains the best function and Parameter values found. More...;  ; class  MnParStr;  ; class  MnPlot;  MnPlot produces a text-screen graphical output of (x,y) points, e.g. More...;  ; class  MnPosDef;  Force the covariance matrix to be positive defined by adding extra terms in the diagonal. More...;  ; class  MnPrint;  ; class  MnRefCountedPointer;  ; class  MnReferenceCounter;  ; class  MnScan;  API class for minimization using a scan method to find the minimum; allows for user interaction: set/change parameters, do minimization, change parameters, re-do minimization etc.;. More...;  ; class  MnSeedGenerator;  concret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html:7636,error,errors,7636,doc/master/namespaceROOT_1_1Minuit2.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Minuit2.html,2,['error'],['errors']
Availability,"...</A>; TGHtmlAnchor*fAnchorStartMost recent <a href=...>; ColorStruct_t*fApColor[32]Information about all colors; Pixel_tTGFrame::fBackgroundframe background color; ColorStruct_t*fBgColorBackground color of the HTML document; TImage*fBgImageBackground image; Int_tTGFrame::fBorderWidthframe border width; TGViewFrame*TGView::fCanvasframe containing the text; TGClient*TGObject::fClientConnection to display server; Atom_tTGView::fClipboardclipboard property; Long_tfColorUsedbit N is 1 if color N is in use. Only; TStringTGWidget::fCommandcommand to be executed; Cursor_tfCursorCurrent cursor for window, or None.; Int_tTGFrame::fDNDStateEDNDFlags; intfDirtyBottomBottom right corner of region to redraw; intfDirtyLeft; intfDirtyRight; intfDirtyTopTop left corner of region to redraw. These; UInt_tTGWindow::fEditDisabledflags used for ""guibuilding""; UInt_tTGFrame::fEventMaskcurrenty active event mask; intfExitingTrue if the widget is being destroyed; intfExportSelectionTrue if the selection is automatically; TGRectangleTGView::fExposedRegionexposed area ; SHtmlExtensions_t*fExtsPointer to user extension data; TGFrameElement*TGFrame::fFEpointer to frame element; ColorStruct_t*fFgColorColor of normal text. apColor[0]; TGHtmlBlock*fFirstBlockList of all TGHtmlBlock tokens; TGHtmlInput*fFirstInputFirst <INPUT> element; intfFlagsVarious flags; see below for definitions.; charfFontValid[9]If bit N%8 of work N/8 of this field is 0; TGHtmlInput*fFormElemLastMost recent <input>, <textarea> or <select>; TGHtmlInput*fFormElemStartMost recent <textarea> or <select>; intfFormPaddingAmount to pad form elements by; TGHtmlForm*fFormStartMost recent <form>; intfGcNextToFree; intfHasFramesTRUE if we can do frames for this page; intfHasScriptTRUE if we can do scripts for this page; UInt_tTGFrame::fHeightframe height; ColorStruct_t*fHighlightBgColorPtrColor for drawing traversal highlight; ColorStruct_t*fHighlightColorPtrColor for drawing traversal highlight.; intfHighlightWidthWidth in pixels ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGHtml.html:24534,mask,mask,24534,root/html528/TGHtml.html,https://root.cern,https://root.cern/root/html528/TGHtml.html,6,['mask'],['mask']
Availability,"..Definition TH1.cxx:826; . The option nostackb allows to draw the histograms next to each other as bar charts:; {; auto cst0 = new TCanvas(""cst0"",""cst0"",600,400);; auto hs = new THStack(""hs"",""Stacked 1D histograms: option #font[82]{\""nostackb\""}"");; ; auto h1 = new TH1F(""h1"",""h1"",10,-4,4);; h1->FillRandom(""gaus"",20000);; h1->SetFillColor(kRed);; hs->Add(h1);; ; auto h2 = new TH1F(""h2"",""h2"",10,-4,4);; h2->FillRandom(""gaus"",15000);; h2->SetFillColor(kBlue);; hs->Add(h2);; ; auto h3 = new TH1F(""h3"",""h3"",10,-4,4);; h3->FillRandom(""gaus"",10000);; h3->SetFillColor(kGreen);; hs->Add(h3);; ; hs->Draw(""nostackb"");; hs->GetXaxis()->SetNdivisions(-10);; cst0->SetGridx();; }; TH1::FillRandomvirtual void FillRandom(const char *fname, Int_t ntimes=5000, TRandom *rng=nullptr)Fill histogram following distribution in function fname.Definition TH1.cxx:3519. If at least one of the histograms in the stack has errors, the whole stack is visualized by default with error bars. To visualize it without errors the option HIST should be used.; {; auto cst1 = new TCanvas(""cst1"",""cst1"",700,400);; cst1->Divide(2,1);; ; auto hst11 = new TH1F(""hst11"", """", 20, -10, 10);; hst11->Sumw2();; hst11->FillRandom(""gaus"", 1000);; hst11->SetFillColor(kViolet);; hst11->SetLineColor(kViolet);; ; auto hst12 = new TH1F(""hst12"", """", 20, -10, 10);; hst12->FillRandom(""gaus"", 500);; hst12->SetFillColor(kBlue);; hst12->SetLineColor(kBlue);; ; THStack st1(""st1"", ""st1"");; st1.Add(hst11);; st1.Add(hst12);; ; cst1->cd(1); st1.Draw();; cst1->cd(2); st1.Draw(""hist"");; }; kViolet@ kVioletDefinition Rtypes.h:67. Drawing of 3D implicit functions; 3D implicit functions (TF3) can be drawn as iso-surfaces. The implicit function f(x,y,z) = 0 is drawn in cartesian coordinates. In the following example the options ""FB"" and ""BB"" suppress the ""Front Box"" and ""Back Box"" around the plot.; {; auto c2 = new TCanvas(""c2"",""c2"",600,400);; auto f3 = new TF3(""f3"",""sin(x*x+y*y+z*z-36)"",-2,2,-2,2,-2,2);; f3->SetClippingBoxOn(0,0,0);; f3->SetFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:121474,error,errors,121474,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['error'],['errors']
Availability,"./(n-1)) * std::exp(-alpha*alpha/2.);; 136 intpow = C - A /(n-1.) * std::pow(B-z,-n+1) ;; 137 }; 138 else {; 139 // for n=1 the primitive of 1/x is log(x); 140 intpow = -A * std::log( n / abs_alpha ) + A * std::log( B -z );; 141 }; 142 intgaus = sqrtpiover2*(1.+ROOT::Math::erf(abs_alpha*oneoversqrt2));; 143 }; 144 else; 145 {; 146 intgaus = ROOT::Math::gaussian_cdf_c(z, 1);; 147 intgaus *= sqrt2pi;; 148 intpow = 0; ; 149 }; 150 return sigma * (intgaus + intpow);; 151 }; 152 ; 153 ; 154 double exponential_cdf_c(double x, double lambda, double x0); 155 {; 156 if ((x-x0) < 0) return 1.0;; 157 else return std::exp(- lambda * (x-x0));; 158 }; 159 ; 160 ; 161 double exponential_cdf(double x, double lambda, double x0); 162 {; 163 if ((x-x0) < 0) return 0.0;; 164 else // use expm1 function to avoid errors at small x; 165 return - ROOT::Math::expm1( - lambda * (x-x0) ) ;; 166 }; 167 ; 168 ; 169 double fdistribution_cdf_c(double x, double n, double m, double x0); 170 {; 171 // f distribution is defined only for both n and m > 0; 172 if (n < 0 || m < 0) return std::numeric_limits<double>::quiet_NaN();; 173 ; 174 double z = m/(m + n*(x-x0));; 175 // fox z->1 and large a and b IB looses precision use complement function; 176 if (z > 0.9 && n > 1 && m > 1) return 1.- fdistribution_cdf(x,n,m,x0);; 177 ; 178 // for the complement use the fact that IB(x,a,b) = 1. - IB(1-x,b,a); 179 return ROOT::Math::inc_beta(m/(m + n*(x-x0)), .5*m, .5*n);; 180 }; 181 ; 182 ; 183 double fdistribution_cdf(double x, double n, double m, double x0); 184 {; 185 // f distribution is defined only for both n and m > 0; 186 if (n < 0 || m < 0); 187 return std::numeric_limits<double>::quiet_NaN();; 188 ; 189 double z = n*(x-x0)/(m + n*(x-x0));; 190 // fox z->1 and large a and b IB looses precision use complement function; 191 if (z > 0.9 && n > 1 && m > 1); 192 return 1. - fdistribution_cdf_c(x,n,m,x0);; 193 ; 194 return ROOT::Math::inc_beta(z, .5*n, .5*m);; 195 }; 196 ; 197 ; 198 double gamma_cdf_c(double x,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html:5296,error,errors,5296,doc/master/ProbFuncMathCore_8cxx_source.html,https://root.cern,https://root.cern/doc/master/ProbFuncMathCore_8cxx_source.html,1,['error'],['errors']
Availability,".0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_g2, 1, 2, 3);; frame->SetTitle(""Minuit contour plot"");; ; // Print the fit result snapshot; fitResult-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:2071,error,error,2071,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,2,['error'],['error']
Availability,".0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;}; 6350 if (Hoption.Error == 16) {optionI0 = 1; option4 = 1; option3 = 1;}; 6351 if (option2+option3 == 0) optionE = 1;; 6352 if (Hoption.Error == 0) optionE = 0;; 6353 if (fXaxis->GetXbins()->fN) fixbin = 0;; 6354 else fixbin = 1;; 6355 ; 6356 offset = fH->GetBarOffset();; 6357 width = fH->GetBarWidth();; 6358 ; 6359 errormarker = TAttMarker::GetMarkerStyleBase(fH->GetMarkerStyle());; 6360 if (optionEX0) {; 6361 xerror = 0;; 6362 } else {; 6363 xerror = gStyle->GetErrorX();; 6364 }; 6365 symbolsize = fH->GetMarkerSize();; 6366 if (errormarker == 1) symbolsize = 0.01;; 6367 sbasex = sbasey = symbolsize*kBASEMARKER;; 6368 if (errormarker >= 20 && errormarker <= 49) {; 6369 sbasex *= cxx[errormarker-20];; 6370 sbasey *= cyy[errormarker-20];; 6371 }; 6372 // set the graphics attributes; 6373 ; 6374 fH->TAttLine::Modify();; 6375 fH->TAttFill::Modify();; 6376 fH->TAttMarker::Modify();; 6377 ; 6378 // set the first and last bin; 6379 ; 6380 Double_t factor = Hparam.factor;; 6381 first = Hparam.xfirst;; 6382 last = Hparam.xlast;; 6383 npoints = last - first +1;; 6384 xmin = gPad->GetUxmin();; 6385 xmax = gPad->GetUxmax();; 6386 ymin = gPad->GetUymin();; 6387 ymax = gPad->GetUymax();; 6388 ; 6389 ; 6390 if (option3) {; 6391 xline.resize(2*npoints);; 6392 yline.resize(2*npoints);; 6393 if ((npoints > 0) && (xline.empty() || yline.empty())) {;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:234097,error,errormarker,234097,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,2,['error'],['errormarker']
Availability,.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105928,error,error,105928,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.65912 0.0202218 0.00185299 43552 0; : 976 | 3.7346 5.23443 0.0200603 0.00176255 43721.2 1; : 977 | 3.73856 4.9727 0.0200443 0.00176151 43757 2; : 978 | 3.60727 4.99113 0.0200479 0.00175633 43736 3; : 979 | 3.40672 4.84357 0.0200357 0.00175685 43766.5 4; : 980 | 3.44899 4.83288 0.0200548 0.0017499 43704.2 5; : 981 | 3.46445 4.72048 0.0203135 0.00176046 43119.7 6; : 982 Minimum Test error found - save the configuration ; : 982 | 3.46604 4.64127 0.0202116 0.00183381 43530.8 0; : 983 Minimum Test error found - save the configuration ; : 983 | 3.37896 4.59559 0.0201715 0.00182642 43608.5 0; : 984 Minimum Test error found - save the configuration ; : 984 | 3.36213 4.34126 0.0202597 0.00185498 43467.1 0; : 985 | 3.39032 4.51659 0.0201503 0.00185184 43719.5 1; : 986 | 3.5234 4.95577 0.0201762 0.0017578 43434.8 2; : 987 | 3.50466 4.60061 0.0201538 0.00175522 43481.6 3; : 988 | 3.61316 4.68965 0.0201071 0.00176 43603.6 4; : 989 | 3.88349 5.24185 0.0200475 0.00175499 43733.8 5; : 990 | 4.0647 4.52576 0.020036 0.00175545 43762.3 6; : 991 | 3.77396 5.32769 0.0200783 0.00175786 43667.1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0.0203306 0.00176616 43093.1 13; : 998 | 3.41797 4.46788 0.0203618 0.00175568 42996.7 14; : 999 Minimum Test error found - save the configuration ; : 999 | 3.31412 4.14973 0.0202938 0.00187677 43438 0; : 1000 | 3.20867 4.17264 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:112138,error,error,112138,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0.0200406 0.00175563 43751.8 2; : 803 | 10.2123 14.6873 0.0200478 0.00175638 43736.3 3; : 804 | 10.1133 14.2109 0.0201368 0.00176313 43540.5 4; : 805 Minimum Test error found - save the configuration ; : 805 | 10.3447 13.9911 0.0201319 0.00182751 43705.3 0; : 806 | 10.3558 15.0191 0.0200537 0.00175652 43722.7 1; : 807 Minimum Test error found - save the configuration ; : 807 | 9.87362 13.4104 0.0202002 0.0018848 43679 0; : 808 | 9.75883 13.5009 0.0202529 0.00175832 43255.9 1; : 809 | 9.54989 13.8103 0.0201225 0.00175709 43560.3 2; : 810 Minimum Test error found - save the configuration ; : 810 | 9.43647 13.1509 0.0201534 0.00182442 43646.8 0; : 811 | 9.40272 13.8504 0.0200559 0.00175676 43717.9 1; : 812 Minimum Test error found - save the configuration ; : 812 | 9.42328 13.0239 0.0202708 0.00183859 43402.3 0; : 813 | 9.26754 13.347 0.0200488 0.00175838 43738.7 1; : 814 | 9.30693 13.2737 0.0200298 0.0017551 43776.4 2; : 815 | 9.2453 13.4411 0.0200383 0.0017608 43769.8 3; : 816 Minimum Test error found - save the configuration ; : 816 | 8.97729 12.8621 0.0200894 0.00181862 43785.8 0; : 817 | 9.05512 13.256 0.0200147 0.0017603 43825 1; : 818 Minimum Test error ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:98739,error,error,98739,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:83497,error,error,83497,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3.28552 3.92634 0.0200717 0.0017618 43692.2 3; : 1031 | 3.09879 3.64842 0.0200603 0.0017557 43704.9 4; : 1032 | 3.23242 4.45782 0.0201318 0.0017893 43614.6 5; : 1033 Minimum Test error found - save the configuration ; : 1033 | 3.57665 3.43738 0.0206178 0.00193324 42816.1 0; : 1034 | 3.26951 3.4755 0.0201231 0.00175901 43563.3 1; : 1035 | 3.0748 4.32816 0.0202002 0.00180771 43496 2; : 1036 | 3.05868 3.88772 0.0202082 0.00176323 43372.3 3; : 1037 | 3.11243 3.8552 0.0200473 0.00176925 43768.4 4; : 1038 | 2.97479 4.01382 0.020048 0.00176307 43752 5; : 1039 | 3.15714 3.85081 0.0200388 0.00176348 43774.8 6; : 1040 | 2.97124 3.72013 0.0200295 0.00176294 43795.8 7; : 1041 | 2.92938 3.63611 0.020078 0.00179099 43746.9 8; : 1042 | 3.04184 3.72584 0.0202124 0.00176555 43367.8 9; : 1043 | 3.24904 3.46339 0.0200395 0.00176046 43765.9 10; : 1044 | 3.08383 3.85222 0.0200574 0.0017582 43717.6 11; : 1045 | 3.00904 3.46043 0.0200555 0.00175872 43723.6 12; : 1046 Minimum Test error found - save the configuration ; : 1046 | 2.89922 3.28968 0.0204754 0.00188349 43029.5 0; : 1047 | 3.06628 3.80261 0.0206565 0.00177157 42361.9 1; : 1048 | 3.0482 4.21427 0.0203272 0.00175981 43086.2 2; : 1049 | 3.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:115357,error,error,115357,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.2 0; : 634 Minimum Test error found - save the configuration ; : 634 | 78.6493 55.4759 0.0202109 0.00182609 43514.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:83383,error,error,83383,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3.28552 3.92634 0.0200717 0.0017618 43692.2 3; : 1031 | 3.09879 3.64842 0.0200603 0.0017557 43704.9 4; : 1032 | 3.23242 4.45782 0.0201318 0.0017893 43614.6 5; : 1033 Minimum Test error found - save the configuration ; : 1033 | 3.57665 3.43738 0.0206178 0.00193324 42816.1 0; : 1034 | 3.26951 3.4755 0.0201231 0.00175901 43563.3 1; : 1035 | 3.0748 4.32816 0.0202002 0.00180771 43496 2; : 1036 | 3.05868 3.88772 0.0202082 0.00176323 43372.3 3; : 1037 | 3.11243 3.8552 0.0200473 0.00176925 43768.4 4; : 1038 | 2.97479 4.01382 0.020048 0.00176307 43752 5; : 1039 | 3.15714 3.85081 0.0200388 0.00176348 43774.8 6; : 1040 | 2.97124 3.72013 0.0200295 0.00176294 43795.8 7; : 1041 | 2.92938 3.63611 0.020078 0.00179099 43746.9 8; : 1042 | 3.04184 3.72584 0.0202124 0.00176555 43367.8 9; : 1043 | 3.24904,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:114960,error,error,114960,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,".2 Drawing a Profile without Error Bars; To draw a profile histogram and not show the error bars use the “HIST” option in the TProfile::Draw method. This will draw the outline of the TProfile.; 3.17.3 Create a Profile from a 2D Histogram; You can make a profile from a histogram using the methods TH2::ProfileX and TH2::ProfileY.; 3.17.4 Create a Histogram from a Profile; To create a regular histogram from a profile histogram, use the method TProfile::ProjectionX .This example instantiates a TH1D object by copying the TH1D piece of TProfile.; TH1D *sum = myProfile.ProjectionX();; You can do the same with a 2D profile using the method TProfile2D::ProjectionXY .; 3.17.5 Generating a Profile from a TTree; The 'prof' and 'profs' options in the TTree::Draw method generate a profile histogram ( TProfile ), given a two dimensional expression in the tree, or a TProfile2D given a three dimensional expression. See “Trees”. Note that you can specify 'prof' or 'profs' : 'prof' generates a TProfile with error on the mean, 'profs' generates a TProfile with error on the spread.; 3.17.6 2D Profiles; The class for a 2D Profile is called TProfile2D . It is in many cases an elegant replacement of a three-dimensional histogram. The relationship of three measured quantities X, Y and Z can be visualized by a three-dimensional histogram or scatter-plot; its representation is not particularly satisfactory, except for sparse data. If Z is an unknown (but single-valued) function of (X,Y), it can be displayed with a TProfile2D with better precision than by a scatter-plot. A TProfile2D displays the mean value of Z and its RMS for each cell in X, Y. The following shows the cumulated contents (capital letters) and the values displayed (small letters) of the elements for cell i,j.; When you fill a profile histogram with TProfile2D.Fill(x,y,z):. E[i,j] contains for each bin i,j the sum of the z values for this bin; L[i,j] contains the number of entries in the bin j; e[j] or s[j] will be the resulting",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:131730,error,error,131730,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['error'],['error']
Availability,".4 */; 4282 case 504:; 4283 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4284 case 505:; 4285 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4286 case 506:; 4287 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4288 case 507:; 4289 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4290 * Section 11.5 */; 4291 case 508:; 4292 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4293 ; 4294 case 510:; 4295 return ""Not Extended""; /* RFC 2774, Section 7 */; 4296 case 511:; 4297 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4298 ; 4299 /* Other status codes, not shown in the IANA HTTP status code; 4300 * assignment.; 4301 * E.g., ""de facto"" standards due to common use, ... */; 4302 case 418:; 4303 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4304 case 419:; 4305 return ""Authentication Timeout""; /* common use */; 4306 case 420:; 4307 return ""Enhance Your Calm""; /* common use */; 4308 case 440:; 4309 return ""Login Timeout""; /* common use */; 4310 case 509:; 4311 return ""Bandwidth Limit Exceeded""; /* common use */; 4312 ; 4313 default:; 4314 /* This error code is unknown. This should not happen. */; 4315 if (conn) {; 4316 mg_cry_internal(conn,; 4317 ""Unknown HTTP response code: %u"",; 4318 response_code);; 4319 }; 4320 ; 4321 /* Return at least a category according to RFC 2616 Section 10. */; 4322 if (response_code >= 100 && response_code < 200) {; 4323 /* Unknown informational status code */; 4324 return ""Information"";; 4325 }; 4326 if (response_code >= 200 && response_code < 300) {; 4327 /* Unknown success code */; 4328 return ""Success"";; 4329 }; 4330 if (response_code >= 300 && response_code < 400) {; 4331 /* Unknown redirection code */; 4332 return ""Redirection"";; 4333 }; 4334 if (response_code >= 400 && response_code < 500) {; 4335 /* Unknown request error code */; 4336 return ""Client Error"";; 4337 }; 4338 if (response_code >= 500 && response_code < 600) {; 4339 /* Unknown server er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:128817,error,error,128817,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,".4 */; 4283 case 504:; 4284 return ""Gateway Time-out""; /* RFC2616 Section 10.5.5 */; 4285 case 505:; 4286 return ""HTTP Version not supported""; /* RFC2616 Section 10.5.6 */; 4287 case 506:; 4288 return ""Variant Also Negotiates""; /* RFC 2295, Section 8.1 */; 4289 case 507:; 4290 return ""Insufficient Storage""; /* RFC2518 Section 10.6, RFC4918; 4291 * Section 11.5 */; 4292 case 508:; 4293 return ""Loop Detected""; /* RFC5842 Section 7.1 */; 4294 ; 4295 case 510:; 4296 return ""Not Extended""; /* RFC 2774, Section 7 */; 4297 case 511:; 4298 return ""Network Authentication Required""; /* RFC 6585, Section 6 */; 4299 ; 4300 /* Other status codes, not shown in the IANA HTTP status code; 4301 * assignment.; 4302 * E.g., ""de facto"" standards due to common use, ... */; 4303 case 418:; 4304 return ""I am a teapot""; /* RFC2324 Section 2.3.2 */; 4305 case 419:; 4306 return ""Authentication Timeout""; /* common use */; 4307 case 420:; 4308 return ""Enhance Your Calm""; /* common use */; 4309 case 440:; 4310 return ""Login Timeout""; /* common use */; 4311 case 509:; 4312 return ""Bandwidth Limit Exceeded""; /* common use */; 4313 ; 4314 default:; 4315 /* This error code is unknown. This should not happen. */; 4316 if (conn) {; 4317 mg_cry_internal(conn,; 4318 ""Unknown HTTP response code: %u"",; 4319 response_code);; 4320 }; 4321 ; 4322 /* Return at least a category according to RFC 2616 Section 10. */; 4323 if (response_code >= 100 && response_code < 200) {; 4324 /* Unknown informational status code */; 4325 return ""Information"";; 4326 }; 4327 if (response_code >= 200 && response_code < 300) {; 4328 /* Unknown success code */; 4329 return ""Success"";; 4330 }; 4331 if (response_code >= 300 && response_code < 400) {; 4332 /* Unknown redirection code */; 4333 return ""Redirection"";; 4334 }; 4335 if (response_code >= 400 && response_code < 500) {; 4336 /* Unknown request error code */; 4337 return ""Client Error"";; 4338 }; 4339 if (response_code >= 500 && response_code < 600) {; 4340 /* Unknown server er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:128849,error,error,128849,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.10,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:83950,error,error,83950,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.4 1; : 673 Minimum Test error found - save the configuration ; : 673 | 47.0153 38.3207 0.0201285 0.00181671 43687.7 0; : 674 Minimum Test error found - save the configuration ; : 674 | 46.5986 38.0788 0.0201224 0.00182147 43713.7 0; : 675 Minimum Test error found - save the configuration ; : 675 | 45.6663 37.2199 0.020138 0.00182969 43696.1 0; : 676 Minimum Test error found - save the configuration ; : 676 | 44.8146 36.9047 0.0201419 0.00182761 43681.7 0; : 677 | 44.1854 37.155 0.0200983 0.0017637 43633.4 1; : 678 Minimum Test error found - save the configuration ; : 678 | 43.7163 36.54 0.0202108 0.00183597 43537.9 0; : 679 Minimum Test error found - save the configuration ; : 679 | 43.1003 36.3421 0.0201203 0.00181258 43697.4 0; : 680 Minimum Test error found - save the configuration ; : 680 | 42.8206 35.8087 0.0201316 0.00181818 43683.7 0; : 681 Minimum Test error found - save the configuration ; : 681 | 42.0593 35.186 0.0205402 0.00185408 42812.5 0; : 682 Minimum Test error found - save the configuration ; : 682 | 41.3592 34.9319 0.0201181 0.00182063 43721.9 0; : 683 | 40.8775 34.9951 0.020058 0.00175108 43699.3 1; : 684 Minimum Test error found - save the configuration ; : 684 | 40.654 34.3931 0.0201589 0.00183818 43666.4 0; : 685 Minimum Test error found - save the configuration ; : 685 | 40.0613 33.8904 0.0201577 0.00183348 43658.1 0; : 686 | 39.3281 34.3645 0.0200576 0.00176772 43739.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Te,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:87576,error,error,87576,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.5 0; : 606 Minimum Test error found - save the configuration ; : 606 | 112.65 73.8117 0.0200987 0.00180944 43741.5 0; : 607 Minimum Test error found - save the configuration ; : 607 | 110.993 73.1273 0.0200934 0.00180455 43742.6 0; : 608 Minimum Test error found - save the configuration ; : 608 | 109.653 72.3206 0.0201066 0.00180567 43713.6 0; : 609 Minimum Test error found - save the configuration ; : 609 | 108.357 71.632 0.0200983 0.00180999 43743.9 0; : 610 Minimum Test error found - save the configuration ; : 610 | 106.875 70.7773 0.0201154 0.00182046 43728 0; : 611 | 105.742 70.7984 0.0200525 0.00175765 43728.1 1; : 612 Minimum Test error found - save the configuration ; : 612 | 104.268 69.338 0.0202166 0.00183521 43522.3 0; : 613 Minimum Test error found - save the configuration ; : 613 | 102.858 68.9009 0.0202348 0.00182917 43464.9 0; : 614 Minimum Test error found - save the configuration ; : 614 | 101.983 68.108 0.0201318 0.00182452 43698.5 0; : 615 Minimum Test error found - save the configuration ; : 615 | 100.329 67.3723 0.0201441 0.00182383 43667.6 0; : 616 Minimum Test error found - save the configuration ; : 616 | 99.0728 66.9343 0.0201375 0.00182665 43689.9 0; : 617 Minimum Test error found - save the configuration ; : 617 | 97.8374 65.9501 0.0201618 0.00184005 43664 0; : 618 Minimum Test error found - save the configuration ; : 618 | 96.3739 65.107 0.0201565 0.0018204 43629.8 0; : 619 Minimum Test error found - save the configuration ; : 619 | 95.4431 64.9258 0.0202106 0.00183339 43532.2 0; : 620 Minimum Test error found - save the configuration ; : 620 | 94.1902 64.0162 0.020412 0.0018551 43110.6 0; : 621 Minimum Test error found - save the configuration ; : 621 | 92.9103 63.3038 0.0201905 0.00182603 43562.4 0; : 622 Minimum Test error found - save the configuration ; : 622 | 91.6075 63.2578 0.0201995 0.00184553 43587.4 0; : 623 Minimum Test error found - save the configuration ; : 623 | 90.7693 62.0703 0.0202228 0.00181118 43450.9 0; : 624 Minimum,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:80441,error,error,80441,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,".5*(dfmax1+dfmax2);; 1603 Double_t z = dfmax*factnm;; 1604 ; 1605 prb = TMath::KolmogorovProb(z);; 1606 ; 1607 Double_t prb1 = 0, prb2 = 0;; 1608 // option N to combine normalization makes sense if both afunc1 and afunc2 are false; 1609 if (opt.Contains(""N"") && !(afunc1 || afunc2 ) ) {; 1610 // Combine probabilities for shape and normalization; 1611 prb1 = prb;; 1612 Double_t d12 = esum1-esum2;; 1613 Double_t chi2 = d12*d12/(esum1+esum2);; 1614 prb2 = TMath::Prob(chi2,1);; 1615 // see Eadie et al., section 11.6.2; 1616 if (prb > 0 && prb2 > 0) prb = prb*prb2*(1-TMath::Log(prb*prb2));; 1617 else prb = 0;; 1618 }; 1619 ; 1620 // debug printout; 1621 if (opt.Contains(""D"")) {; 1622 printf("" Kolmo Prob h1 = %s, sum1=%g\n"",h1->GetName(),sum1);; 1623 printf("" Kolmo Prob h2 = %s, sum2=%g\n"",h2->GetName(),sum2);; 1624 printf("" Kolmo Probabil = %f, Max Dist = %g\n"",prb,dfmax);; 1625 if (opt.Contains(""N"")); 1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657/////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:65210,error,error,65210,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability,".5,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; SeparationType=""GiniIndex"",; nCuts=20,; ); ; ; #### Booking Deep Neural Network; ; # Here we book the DNN of TMVA. See the example TMVA_Higgs_Classification.C for a detailed description of the; # options; ; if useTMVADNN:; layoutString = ROOT.TString(; ""DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,BNORM,DENSE|100|RELU,DENSE|1|LINEAR""; ); ; # Training strategies; # one can catenate several training strings with different parameters (e.g. learning rates or regularizations; # parameters) The training string must be concatenated with the `|` delimiter; trainingString1 = ROOT.TString(; ""LearningRate=1e-3,Momentum=0.9,Repetitions=1,""; ""ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,""; ""WeightDecay=1e-4,Regularization=None,""; ""Optimizer=ADAM,DropConfig=0.0+0.0+0.0+0.""; ) # + ""|"" + trainingString2 + ...; trainingString1 += "",MaxEpochs="" + str(max_epochs); ; # Build now the full DNN Option string; dnnMethodName = ""TMVA_DNN_CPU""; ; # use GPU if available; dnnOptions = ""CPU""; if hasGPU :; dnnOptions = ""GPU""; dnnMethodName = ""TMVA_DNN_GPU""; ; factory.BookMethod(; loader,; TMVA.Types.kDL,; dnnMethodName,; H=False,; V=True,; ErrorStrategy=""CROSSENTROPY"",; VarTransform=None,; WeightInitialization=""XAVIER"",; Layout=layoutString,; TrainingStrategy=trainingString1,; Architecture=dnnOptions; ); ; ; ### Book Convolutional Neural Network in TMVA; ; # For building a CNN one needs to define; ; # - Input Layout : number of channels (in this case = 1) | image height | image width; # - Batch Layout : batch size | number of channels | image size = (height*width); ; # Then one add Convolutional layers and MaxPool layers.; ; # - For Convolutional layer the option string has to be:; # - CONV | number of units | filter height | filter width | stride height | stride width | padding height | paddig; # width | activation function; ; # - note in this case we are using a filer 3x3 and padding=1 and stride=1 so we get the output dimen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:10591,avail,available,10591,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['avail'],['available']
Availability,.6 1; : 733 Minimum Test error found - save the configuration ; : 733 | 21.6244 23.3245 0.0201038 0.00181384 43739.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test error found - save the configuration ; : 736 | 20.9485 22.9069 0.0201996 0.00182864 43547 0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17.9119 20.8249 0.0200825 0.00181515 43794.1 0; : 750 | 17.7295 20.9077 0.0200909 0.00176261 43648.3 1; : 751 Minimum Test error found - save the configuration ; : 751 | 17.6646 20.1562 0.02009 0.00181812 43783 0; : 752 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:93160,error,error,93160,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 0; : 563 Minimum Test error found - save the configuration ; : 563 | 188.987 113.393 0.0203794 0.00207901 43715 0; : 564 Minimum Test error found - save the configuration ; : 564 | 186.85 112.339 0.0201831 0.00181479 43553.4 0; : 565 Minimum Test error found - save the configuration ; : 565 | 185.071 111.259 0.0203048 0.00182605 43292.9 0; : 566 Minimum Test error found - save the configuration ; : 566 | 182.616 110.112 0.0201778 0.00183613 43616.5 0; : 567 Minimum Test error found - save the configuration ; : 567 | 180.473 109.26 0.0202561 0.00182678 43409.1 0; : 568 Minimum Test error found - save the configuration ; : 568 | 178.451 108.059 0.0201373 0.00182611 43689.1 0; : 569 Minimum Test error found - save the configuration ; : 569 | 176.264 106.78 0.0201111 0.00181323 43721.1 0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minim,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:75630,error,error,75630,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 0; : 679 Minimum Test error found - save the configuration ; : 679 | 43.1003 36.3421 0.0201203 0.00181258 43697.4 0; : 680 Minimum Test error found - save the configuration ; : 680 | 42.8206 35.8087 0.0201316 0.00181818 43683.7 0; : 681 Minimum Test error found - save the configuration ; : 681 | 42.0593 35.186 0.0205402 0.00185408 42812.5 0; : 682 Minimum Test error found - save the configuration ; : 682 | 41.3592 34.9319 0.0201181 0.00182063 43721.9 0; : 683 | 40.8775 34.9951 0.020058 0.00175108 43699.3 1; : 684 Minimum Test error found - save the configuration ; : 684 | 40.654 34.3931 0.0201589 0.00183818 43666.4 0; : 685 Minimum Test error found - save the configuration ; : 685 | 40.0613 33.8904 0.0201577 0.00183348 43658.1 0; : 686 | 39.3281 34.3645 0.0200576 0.00176772 43739.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Test error found - save the configuration ; : 693 | 35.9446 31.7942 0.0202985 0.00181447 43280.7 0; : 694 | 35.3125 31.8389 0.0201438 0.00175333 43500.7 1; : 695 Minimum Test error found - save the configuration ; : 695 | 34.8867 31.3734 0.0201347 0.00182018 43681.2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimum Test error found - save the configuration ; : 698 | 33.7716 30.3897 0.0201321 0.00181458 43673.9 0; : 699 | 33.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:88197,error,error,88197,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test error found - save the configuration ; : 736 | 20.9485 22.9069 0.0201996 0.00182864 43547 0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17.9119 20.8249 0.0200825 0.00181515 43794.1 0; : 750 | 17.7295 20.9077 0.0200909 0.00176261 43648.3 1; : 751 Minimum Test error found - save the configuration ; : 751 | 17.6646 20.1562 0.02009 0.00181812 43783 0; : 752 Minimum Test error found - save the configuration ; : 752 | 17.2045 20.1301 0.0200899 0.00181385 43773 0; : 753 Minimum Tes,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:93274,error,error,93274,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Test error found - save the configuration ; : 693 | 35.9446 31.7942 0.0202985 0.00181447 43280.7 0; : 694 | 35.3125 31.8389 0.0201438 0.00175333 43500.7 1; : 695 Minimum Test error found - save the configuration ; : 695 | 34.8867 31.3734 0.0201347 0.00182018 43681.2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimum Test error found - save the configuration ; : 698 | 33.7716 30.3897 0.0201321 0.00181458 43673.9 0; : 699 | 33.1269 30.7769 0.0201928 0.00175872 43397.8 1; : 700 Minimum Test error found - save the configuration ; : 700 | 32.8076 30.1388 0.0201025 0.00181993 43757.5 0; : 701 | 32.6014 30.2991 0.0200398 0.0017563 43755.4 1; : 702 | 32.0925 30.8793 0.0200419 0.00175584 43749.1 2; : 703 Minimum Test error found - save the configuration ; : 703 | 31.9128 29.3224 0.0202722 0.00182152 43358.7 0; : 704 Minimum Test error found - save the configuration ; : 704 | 31.2876 29.167 0.0201013 0.00181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.64,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:88990,error,error,88990,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,".998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:14434,recover,recover,14434,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,".; 156 ; 157void TLeaf::Browse(TBrowser* b); 158{; 159 if (strchr(GetName(), '.')) {; 160 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 161 } else {; 162 if ((fBranch->GetListOfLeaves()->GetEntries() > 1) ||; 163 (strcmp(fBranch->GetName(), GetName()) != 0)) {; 164 TString name(fBranch->GetName());; 165 if (!name.EndsWith(""."")) name += ""."";; 166 name += GetName();; 167 fBranch->GetTree()->Draw(name, """", b ? b->GetDrawOption() : """");; 168 } else {; 169 fBranch->GetTree()->Draw(GetName(), """", b ? b->GetDrawOption() : """");; 170 }; 171 }; 172 if (gPad) {; 173 gPad->Update();; 174 }; 175}; 176 ; 177////////////////////////////////////////////////////////////////////////////////; 178/// Pack leaf elements in Basket output buffer.; 179 ; 180void TLeaf::FillBasket(TBuffer &); 181{; 182}; 183 ; 184////////////////////////////////////////////////////////////////////////////////; 185/// If the class supports it, generate an offset array base.; 186///; 187/// This class only returns `nullptr` on error.; 188Int_t *TLeaf::GenerateOffsetArrayBase(Int_t base, Int_t events) const; 189{; 190 // In order to avoid a virtual call, we assume ROOT developers will override; 191 // the default GenerateOffsetArray for cases where this function does not apply.; 192 ; 193 Int_t *retval = new Int_t[events];; 194 if (R__unlikely(!retval || !fLeafCount)) {; 195 delete [] retval;; 196 return nullptr;; 197 }; 198 ; 199 Long64_t orig_entry = std::max(fBranch->GetReadEntry(), 0LL); // -1 indicates to start at the beginning; 200 const std::vector<Int_t> *countValues = fLeafCount->GetLeafCountValues(orig_entry, events);; 201 ; 202 if (!countValues || ((Int_t)countValues->size()) < events) {; 203 Error(""GenerateOffsetArrayBase"", ""The leaf %s could not retrieve enough entries from its branch count (%s), ask for %d and got %ld"",; 204 GetName(), fLeafCount->GetName(), events, (long)(countValues ? countValues->size() : -1));; 205 delete [] retval;; 206 return nullptr;; 207 }; 208 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLeaf_8cxx_source.html:5526,error,error,5526,doc/master/TLeaf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLeaf_8cxx_source.html,1,['error'],['error']
Availability,".; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name, &finfo) < 0); 1717#else; 1718 struct stat finfo;; 1719 if (lstat(name, &finfo) < 0); 1720#endif; 1721 return -1;; 1722 ; 1723 if (S_ISDIR(finfo.st_mode)); 1724 return ::rmdir(name);; 1725 else; 1726 return ::unlink(name);; 1727}; 1728 ; 1729//---- expand the metacharacters as in the shell --------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:52250,failure,failure,52250,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['failure'],['failure']
Availability,".; 633Int_t TGeoManager::AddRegion(TGeoRegion *region); 634{; 635 Int_t size = fRegions->GetEntriesFast();; 636 fRegions->Add(region);; 637 return size;; 638}; 639 ; 640////////////////////////////////////////////////////////////////////////////////; 641/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:25170,error,error,25170,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,2,['error'],['error']
Availability,".; 6495/// The algorithm makes a copy of the histogram, then loops on all bins; 6496/// of the old histogram to fill the extended histogram.; 6497/// Takes into account errors (Sumw2) if any.; 6498/// The algorithm works for 1-d, 2-D and 3-D histograms.; 6499/// The axis must be extendable before invoking this function.; 6500/// Ex:; 6501///; 6502/// ~~~ {.cpp}; 6503/// h->GetXaxis()->SetCanExtend(kTRUE);; 6504/// ~~~; 6505 ; 6506void TH1::ExtendAxis(Double_t x, TAxis *axis); 6507{; 6508 if (!axis->CanExtend()) return;; 6509 if (TMath::IsNaN(x)) { // x may be a NaN; 6510 SetCanExtend(kNoAxis);; 6511 return;; 6512 }; 6513 ; 6514 if (axis->GetXmin() >= axis->GetXmax()) return;; 6515 if (axis->GetNbins() <= 0) return;; 6516 ; 6517 Double_t xmin, xmax;; 6518 if (!FindNewAxisLimits(axis, x, xmin, xmax)); 6519 return;; 6520 ; 6521 //save a copy of this histogram; 6522 TH1 *hold = (TH1*)IsA()->New();; 6523 hold->SetDirectory(nullptr);; 6524 Copy(*hold);; 6525 //set new axis limits; 6526 axis->SetLimits(xmin,xmax);; 6527 ; 6528 ; 6529 //now loop on all bins and refill; 6530 Int_t errors = GetSumw2N();; 6531 ; 6532 Reset(""ICE""); //reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (conte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:257520,error,errors,257520,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,".; Definition at line 1454 of file TGraphMultiErrors.cxx. ◆ GetErrorY() [2/2]. Double_t TGraphMultiErrors::GetErrorY ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get error e on y coordinate for point i. ; In case of asymmetric errors the mean of the square sum is returned ; Definition at line 1468 of file TGraphMultiErrors.cxx. ◆ GetErrorYhigh() [1/2]. Double_t TGraphMultiErrors::GetErrorYhigh ; (; Int_t ; i); const. overridevirtual . Get high error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1530 of file TGraphMultiErrors.cxx. ◆ GetErrorYhigh() [2/2]. Double_t TGraphMultiErrors::GetErrorYhigh ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get high error e on y coordinate for point i. ; Definition at line 1566 of file TGraphMultiErrors.cxx. ◆ GetErrorYlow() [1/2]. Double_t TGraphMultiErrors::GetErrorYlow ; (; Int_t ; i); const. overridevirtual . Get low error on y coordinate for point i. ; The multiple errors of the dimensions are summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1504 of file TGraphMultiErrors.cxx. ◆ GetErrorYlow() [2/2]. Double_t TGraphMultiErrors::GetErrorYlow ; (; Int_t ; i, . Int_t ; e . ); const. virtual . Get low error e on y coordinate for point i. ; Definition at line 1555 of file TGraphMultiErrors.cxx. ◆ GetEXhigh(). Double_t * TGraphMultiErrors::GetEXhigh ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 142 of file TGraphMultiErrors.h. ◆ GetEXlow(). Double_t * TGraphMultiErrors::GetEXlow ; (; ); const. inlineoverridevirtual . Reimplemented from TGraph.; Definition at line 141 of file TGraphMultiErrors.h. ◆ GetEYhigh() [1/2]. Double_t * TGraphMultiErrors::GetEYhigh ; (; ); const. overridevirtual . Get all high errors on y coordinates as an array summed according to fSumErrorsMode. ; Reimplemented from TGraph.; Definition at line 1588 of file TGraphMul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:63860,error,error,63860,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,".; Definition at line 370 of file RooAbsReal.h. ◆ isSelectedComp(). bool RooAbsReal::isSelectedComp ; (; ); const. If true, the current pdf is a selected component (for use in plotting) ; Definition at line 2956 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 445 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 447 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:119941,error,error,119941,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['error'],['error']
Availability,".; Definition at line 377 of file RooAbsReal.h. ◆ isSelectedComp(). bool RooAbsReal::isSelectedComp ; (; ); const. If true, the current pdf is a selected component (for use in plotting) ; Definition at line 3041 of file RooAbsReal.cxx. ◆ isValid(). bool RooAbsReal::isValid ; (; ); const. inlineoverrideprotectedvirtual . Check if current value is valid. ; Reimplemented from RooAbsArg.; Reimplemented in RooRealIntegral.; Definition at line 452 of file RooAbsReal.h. ◆ isValidReal(). virtual bool RooAbsReal::isValidReal ; (; double ; , . bool ; printError = false . ); const. inlineprotectedvirtual . Interface function to check if given value is a valid value for this object. Returns true unless overridden. ; Reimplemented in RooAbsRealLValue, RooRealIntegral, RooFormulaVar, and RooGenericPdf.; Definition at line 454 of file RooAbsReal.h. ◆ logEvalError() [1/2]. void RooAbsReal::logEvalError ; (; const char * ; message, . const char * ; serverValueString = nullptr . ); const. Log evaluation error message. ; Evaluation errors may be routed through a different protocol than generic RooFit warning message (which go straight through RooMsgService) because evaluation errors can occur in very large numbers in the use of likelihood evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging() messages reported through this function are not printed but all stored in a list, along with server values at the time of reporting. Error messages logged in this way can be printed in a structured way, eliminating duplicates and with the ability to truncate the list by printEvalErrors. This is the standard mode of error logging during MINUIT operations. If enableEvalErrorLogging() is false, all errors reported through this method are passed for immediate printing through RooMsgService. A string with server names and values is constructed automatically for error logging purposes, unless a custom string with similar information is passed as argument. ; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:121271,error,error,121271,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['error'],['error']
Availability,".; Definition at line 8848 of file TH1.cxx. ◆ SetBins() [3/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins, . Int_t ; ny, . const Double_t * ; yBins, . Int_t ; nz, . const Double_t * ; zBins . ). virtual . Redefine x, y and z axis parameters with variable bin sizes. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1, yBins is supposed to be of length ny+1, zBins is supposed to be of length nz+1 ; Reimplemented in TProfile3D, TProfile, and TProfile2D.; Definition at line 8905 of file TH1.cxx. ◆ SetBins() [4/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax . ). virtual . Redefine x axis parameters. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 8767 of file TH1.cxx. ◆ SetBins() [5/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax . ). virtual . Redefine x and y axis parameters. ; The X and Y axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange ; Reimplemented in TProfile2D, TProfile, and TProfile3D.; Definition at line 8820 of file TH1.cxx. ◆ SetBins() [6/6]. void TH1::SetBins ; (; Int_t ; nx, . Double_t ; xmin, . Double_t ; xmax, . Int_t ; ny, . Double_t ; ymin, . Double_t ; ymax, . Int_t ; nz, . Double_t ; zmin, . Double_t ; zmax . ). virtual . Redefine x, y and z axis parameters. ; The X, Y and Z axis parameters are modified. The bins content array is resized if errors (Sumw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:206931,error,errors,206931,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,".; Example:; void atest() {; TH1F *h1 = new TH1F(""h1"",""h1"",110,-110,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.Merge(list);; h->Draw();; }. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histogram",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:93082,error,errors,93082,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,12,"['avail', 'error']","['available', 'errors']"
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2009-12-07 13:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10839,error,error,10839,root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html526/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2010-09-23 19:57; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10905,error,error,10905,root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-07-04 15:20; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10907,error,error,10907,root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,15,['error'],['error']
Availability,".; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector<T,D2> Row(unsigned int therow) const. return a full Matrix row as a vector (copy the content in a new vector). SVector<T,D1> Col(unsigned int thecol) const. return a full Matrix column as a vector (copy the content in a new vector). SVector<T,D1> Diagonal() const. return diagonal elements of a matrix as a Vector.; It works only for squared matrices D1 == D2, otherwise it will produce a compile error. T Trace() const. return the trace of a matrix; Sum of the diagonal elements. SubVector UpperBlock() const. SubVector LowerBlock() const. bool IsInUse(const float* p) const; @name --- Other Functions --- . Function to check if a matrix is sharing same memory location of the passed pointer; This function is used by the expression templates to avoid the alias problem during; expression evaluation. When the matrix is in use, for example in operations; like A = B * A, a temporary object storing the intermediate result is automatically; created when evaluating the expression. std::ostream& Print(ostream& os) const; submatrices; Print: used by operator<<(). » Last changed: root/smatrix:$Id: SMatrix.h 30749 2009-10-15 16:33:04Z brun $ » Last generated: 2011-11-03 20:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:10907,error,error,10907,root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,30,['error'],['error']
Availability,".; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t AddIncludePath(const char* incpath, Bool_t onClient = kFALSE, TList* wrks = 0); Add 'incpath' to the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveDynamicPath(const char* libpath, Bool_t onClient = kFALSE); Remove 'libpath' from the lib path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. Int_t RemoveIncludePath(const char* incpath, Bool_t onClient = kFALSE); Remove 'incpath' from the inc path search.; Multiple paths can be specified at once separating them with a comma or; a blank.; Return 0 on success, -1 otherwise. void HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Handle lib, inc search paths modification request. TList * GetListOfPackages(); Get from the master the list of names of the packages available. TList * GetListOfEnabledPackages(); Get from the master the list of names of the packages enabled. void PrintProgress(Long64_t total, Long64_t processed, Float_t procTime = -1., Long64_t bytesread = -1); Print a progress bar on stderr. Used in batch mode. void Progress(Long64_t total, Long64_t processed); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti); Get query progress information. Connect a slot to this signal; to track progress. void Progress(Long64_t total, Long64_t processed, Long64_t bytesread, Float_t initTime, Float_t procTime, Float_t evtrti, Float_t mbrti, Int_t actw, Int_t tses, Float_t eses); Get query progress information. Connect a slot to this signal; to track progress. void Feedback(TList* objs); Get list of feedback objects. Connect a slot to this sign",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:69561,avail,available,69561,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['avail'],['available']
Availability,".; TH1::GetEntries() - returns the number of entries.; TH1::GetAsymmetry(TH1 *h2,Double_t c2,Double_tdc2). returns an histogram containing the asymmetry of this histogram with h2, where the asymmetry is defined as:. Asymmetry = (h1 - h2)/(h1 + h2); //where h1 = this. It works for 1D , 2D , etc. histograms. The parameter c2 is an optional argument that gives a relative weight between the two histograms, and dc 2 is the error on this weight. This is useful, for example, when forming an asymmetry between two histograms from two different data sets that need to be normalized to each other in some way. The function calculates the errors assuming Poisson statistics on h1 and h2 (that is, dh=sqrt(h)). In the next example we assume that h1 and h2 are already filled:. h3 = h1->GetAsymmetry(h2);. Then h3 is created and filled with the asymmetry between h1 and h2 ; h1 and h2 are left intact.; Note that the user’s responsibility is to manage the created histograms.; TH1::Reset() - resets the bin contents and errors of a histogram. 3.13 Important note on returned statistics (GetMean, GetStdDev, etc.); By default, histogram statistics are computed at fill time using the unbinned data used to update the bin content. This means the values returned by GetMean, GetStdDev, etc., are those of the dataset used to fill the histogram, not those of the binned content of the histogram itself, unless one of the axes has been zoomed. (See the documentation on TH1::GetStats().) This is useful if you want to keep track of the mean and standard deviation of the dataset you are visualizing with the histogram, but it can lead to some unintuitive results.; For example, suppose you have a histogram with one bin between 0 and 100, then you fill it with a Gaussian dataset with mean 20 and standard deviation 2:; TH1F * h = new TH1F(""h"", ""h"", 1, 0, 100);; for(int i=0; i<10000; i++) h->Fill(gRandom->Gaus(20, 2));; Right now, h->GetMean() will return 20 and h->GetStdDev() will return 2; ROOT calculated the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:118055,error,errors,118055,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['errors']
Availability,".; The default (full) range can be denoted with Range("""") / NormRange("""").; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range ''; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf>.removeStringAttribute(""fitrange"");; - Explicitly specify the plotting range: Range(""<rangeName>"").; - Explicitly specify where to compute the normalisation: NormRange(""<rangeName>"").; The default (full) range can be denoted with Range("""") / NormRange("""").; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) only plotting range 'fit_nll_model_modelData'; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f. curve is normalized using explicit choice of ranges 'fit_nll_model_modelData'; result of fit on all data ; ; RooFitResult: minimized FCN value: 25939.4, estimated distance to minimum: 3.77183e-06; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; f 5.0441e-01 +/- 6.32e-03; mx -2.1605e-02 +/- 1.77e-02; ; result of fit in in signal region (note increased error on signal fraction); ; RooFitResult: minimized FCN value: 10339.5, estimated distance to minimum: 0.000279216; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; f 4.8979e-01 +/- 1.62e-02; mx -2.1518e-02 +/- 1.79e-02; ; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf203_ranges.C. tutorialsroofitrf203_ranges.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf203__ranges_8C.html:8178,error,error,8178,doc/master/rf203__ranges_8C.html,https://root.cern,https://root.cern/doc/master/rf203__ranges_8C.html,1,['error'],['error']
Availability,".; The left side of the bar is drawn with a light fill color.; The right side of the bar is drawn with a dark fill color.; The percentage of the bar drawn with either the light or dark color is:. 0% for option ""(h)bar"" or ""(h)bar0""; 10% for option ""(h)bar1""; 20% for option ""(h)bar2""; 30% for option ""(h)bar3""; 40% for option ""(h)bar4"". Picture; Source. // Example of bar charts with 1-d histograms; // Author: Rene Brun; void hbars() {; cout << gSystem->DirName(__FILE__) << endl;; // try to open first the file cernstaff.root in tutorials/tree directory; TString filedir = gSystem->DirName(__FILE__);; filedir += TString(""/../tree/"");; TString filename = ""cernstaff.root"";; bool fileNotFound = gSystem->AccessPathName(filename); // note opposite return code; // if file is not found try to generate it uing the macro tree/cernbuild.C; if (fileNotFound) {; TString macroName = filedir + ""cernbuild.C"";; if (!gInterpreter->IsLoaded(macroName)) gInterpreter->LoadMacro(macroName);; gROOT->ProcessLineFast(""cernbuild()"");; }; TFile * f = TFile::Open(filename);; if (!f) {; Error(""hbars"",""file cernstaff.root not found"");; return;; }; TTree *T = (TTree*)f->Get(""T"");; if (!T) {; Error(""hbars"",""Tree T is not present in file %s"",f->GetName() );; return;; }; T->SetFillColor(45);; TCanvas *c1 = new TCanvas(""c1"",""histograms with bars"",700,800);; c1->SetFillColor(42);; c1->Divide(1,2);. //horizontal bar chart; c1->cd(1); gPad->SetGrid(); gPad->SetLogx(); gPad->SetFrameFillColor(33);; T->Draw(""Nation"","""",""hbar2"");. //vertical bar chart; c1->cd(2); gPad->SetGrid(); gPad->SetFrameFillColor(33);; T->Draw(""Division>>hDiv"","""",""goff"");; TH1F *hDiv = (TH1F*)gDirectory->Get(""hDiv"");; hDiv->SetStats(0);; TH1F *hDivFR = (TH1F*)hDiv->Clone(""hDivFR"");; T->Draw(""Division>>hDivFR"",""Nation==\""FR\"""",""goff"");; hDiv->SetBarWidth(0.45);; hDiv->SetBarOffset(0.1);; hDiv->SetFillColor(49);; TH1 *h1 = hDiv->DrawCopy(""bar2"");; hDivFR->SetBarWidth(0.4);; hDivFR->SetBarOffset(0.55);; hDivFR->SetFillColor(50);; TH1 *h2 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THistPainter.html:24242,Error,Error,24242,root/html602/THistPainter.html,https://root.cern,https://root.cern/root/html602/THistPainter.html,1,['Error'],['Error']
Availability,".; This is particularly important if you fit the histogram after TH1::Divide. void Divide(const TH1* h1); -*-*-*-*-*-*-*-*-*Divide this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:58529,error,errors,58529,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['error'],['errors']
Availability,".; sig1frac = ROOT.RooRealVar(""sig1frac"", ""fraction of component 1 in signal"", 0.8, 0.0, 1.0); sig = ROOT.RooAddPdf(""sig"", ""Signal"", [sig1, sig2], [sig1frac]); ; # Sum the composite signal and background; bkgfrac = ROOT.RooRealVar(""bkgfrac"", ""fraction of background"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""g1+g2+a"", [bkg, sig], [bkgfrac]); ; # Create biuned dataset; # -----------------------------------------; ; d = model.generate({x}, 10000); dh = d.binnedClone(); ; # Construct a chi^2 of the data and the model.; # When a p.d.f. is used in a chi^2 fit, probability density scaled; # by the number of events in the dataset to obtain the fit function; # If model is an extended p.d.f, expected number events is used; # instead of the observed number of events.; ll = ROOT.RooLinkedList(); model.chi2FitTo(dh, ll); ; # NB: It is also possible to fit a ROOT.RooAbsReal function to a ROOT.RooDataHist; # using chi2FitTo().; ; # Note that entries with zero bins are _not_ allowed; # for a proper chi^2 calculation and will give error; # messages; dsmall = d.reduce(ROOT.RooFit.EventRange(1, 100)); dhsmall = dsmall.binnedClone(); chi2_lowstat = model.createChi2(dhsmall); print(chi2_lowstat.getVal()); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- The following expressions have been identified as constant and will be precalculated and cached: (sig1,sig2); [#1] INFO:Minimization -- The following expressions will be evaluated in cache-and-track mode: (bkg); Minuit2Minimizer: Minimize with max-calls 2000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - stat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf602__chi2fit_8py.html:2214,error,error,2214,doc/master/rf602__chi2fit_8py.html,https://root.cern,https://root.cern/doc/master/rf602__chi2fit_8py.html,1,['error'],['error']
Availability,".C:8; For example: gStyle->SetOptStat(11);; displays only the name of histogram and the number of entries, whereas: gStyle->SetOptStat(1101);; displays the name of histogram, mean value and RMS.; WARNING 1: never do: gStyle->SetOptStat(0001111);; but instead do: gStyle->SetOptStat(1111);; because 0001111 will be taken as an octal number!; WARNING 2: for backward compatibility with older versions gStyle->SetOptStat(1);; is taken as: gStyle->SetOptStat(1111); To print only the name of the histogram do: gStyle->SetOptStat(1000000001);; NOTE that in case of 2D histograms, when selecting only underflow (10000) or overflow (100000), the statistics box will show all combinations of underflow/overflows and not just one single number.; The parameter mode can be any combination of the letters kKsSiourRmMen k : kurtosis printed; K : kurtosis and kurtosis error printed; s : skewness printed; S : skewness and skewness error printed; i : integral of bins printed; o : number of overflows printed; u : number of underflows printed; r : rms printed; R : rms and rms error printed; m : mean value printed; M : mean value mean error values printed; e : number of entries printed; n : name of histogram is printed; R#define R(a, b, c, d, e, f, g, h, i)Definition RSha256.hxx:110; For example, to print only name of histogram and number of entries do: gStyle->SetOptStat(""ne"");; To print only the name of the histogram do: gStyle->SetOptStat(""n"");; The default value is: gStyle->SetOptStat(""nemr"");; When a histogram is painted, a TPaveStats object is created and added to the list of functions of the histogram. If a TPaveStats object already exists in the histogram list of functions, the existing object is just updated with the current histogram parameters.; Once a histogram is painted, the statistics box can be accessed using h->FindObject(""stats""). In the command line it is enough to do: Root > h->Draw(); Root > TPaveStats *st = (TPaveStats*)h->FindObject(""stats""); h#define h(i)Definition RSha256",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPaveStats.html:2948,error,error,2948,doc/master/classTPaveStats.html,https://root.cern,https://root.cern/doc/master/classTPaveStats.html,4,['error'],['error']
Availability,".Definition DataRange.h:35; ROOT::Fit::DataRange::AddRangevoid AddRange(unsigned int icoord, double xmin, double xmax)add a range [xmin,xmax] for the new coordinate icoord Adding a range does not delete existing one,...Definition DataRange.cxx:94; ROOT::Fit::DataRange::Sizeunsigned int Size(unsigned int icoord=0) constreturn range size for coordinate icoord (starts from zero) Size == 0 indicates no range is present [-...Definition DataRange.h:71; ROOT::Fit::DataRange::GetRangevoid GetRange(unsigned int irange, unsigned int icoord, double &xmin, double &xmax) constget the i-th range for given coordinate.Definition DataRange.h:104; ROOT::Fit::FitConfigClass describing the configuration of the fit, options and parameter settings using the ROOT::Fit::Pa...Definition FitConfig.h:47; ROOT::Fit::FitConfig::SetMinimizervoid SetMinimizer(const char *type, const char *algo=nullptr)set minimizer typeDefinition FitConfig.h:179; ROOT::Fit::FitConfig::SetMinosErrorsvoid SetMinosErrors(bool on=true)set Minos errors computation to be performed after fittingDefinition FitConfig.h:229; ROOT::Fit::FitConfig::SetNormErrorsvoid SetNormErrors(bool on=true)set the option to normalize the error on the result according to chi2/ndfDefinition FitConfig.h:223; ROOT::Fit::FitConfig::NormalizeErrorsbool NormalizeErrors() constflag to check if resulting errors are be normalized according to chi2/ndfDefinition FitConfig.h:202; ROOT::Fit::FitConfig::SetMinimizerOptionsvoid SetMinimizerOptions(const ROOT::Math::MinimizerOptions &minopt)set all the minimizer options using class MinimizerOptionsDefinition FitConfig.cxx:257; ROOT::Fit::FitConfig::SetWeightCorrectionvoid SetWeightCorrection(bool on=true)apply the weight correction for error matrix computationDefinition FitConfig.h:232; ROOT::Fit::FitConfig::SetParabErrorsvoid SetParabErrors(bool on=true)set parabolic errorsDefinition FitConfig.h:226; ROOT::Fit::FitConfig::MinimizerTypeconst std::string & MinimizerType() constreturn type of minimizer pack",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:46023,error,errors,46023,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['error'],['errors']
Availability,".Definition RooRealVar.h:37; TAttAxis::SetTitleOffsetvirtual void SetTitleOffset(Float_t offset=1)Set distance between the axis and the axis title.Definition TAttAxis.cxx:298; TCanvasThe Canvas class.Definition TCanvas.h:23; TMarker::Printvoid Print(Option_t *option="""") const overrideDump this marker with its attributes.Definition TMarker.cxx:339; xDouble_t x[n]Definition legend1.C:17; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf601_intminuitDefinition rf601_intminuit.py:1; mTMarker mDefinition textangle.C:8; ; [#0] WARNING:InputArguments -- The parameter 'sigma_g1' with range [-inf, inf] of the RooGaussian 'g1' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for frac: using 0.1; [#0] WARNING:Minimization -- RooAbsMinimizerFcn::synchronize: WARNING: no initial error estimate available for sigma_g2: using 0.3; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; ; prevFCN = 2660.220684 frac=0.5036, ; prevFCN = 2660.181264 frac=0.4964, ; prevFCN = 2660.261875 frac=0.5, sigma_g2=4.011, ; prevFCN = 2660.278974 sigma_g2=3.989, ; prevFCN = 2660.167705 sigma_g2=4.005, ; prevFCN = 2660.248509 sigma_g2=3.995, ; prevFCN = 2660.194127 frac=0.5812, sigma_g2=3.889, ; prevFCN = 2660.146969 frac=0.5429, sigma_g2=3.941, ; prevFCN = 2659.83839 frac=0.5459, ; prevFCN = 2659.836693 frac=0.5398, ; prevFCN = 2659.841351 frac=0.5429, sigma_g2=3.946, ; prevFCN = 2659.835035 sigma_g2=3.936, ; prevFCN = 2659.842919 frac=0.5497, sig",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:6062,error,error,6062,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,3,"['avail', 'error']","['available', 'error']"
Availability,".Definition TMath.h:686; TMath::ACosHDouble_t ACosH(Double_t)Returns the nonnegative area hyperbolic cosine of x.Definition TMath.cxx:81; TMath::BesselK0Double_t BesselK0(Double_t x)Modified Bessel function I_0(x)Definition TMath.cxx:1460; TMath::BesselY0Double_t BesselY0(Double_t x)Bessel function J1(x) for any real x.Definition TMath.cxx:1705; TMath::BetaCfDouble_t BetaCf(Double_t x, Double_t a, Double_t b)Continued fraction evaluation by modified Lentz's method used in calculation of incomplete Beta funct...Definition TMath.cxx:2020; TMath::ErfInverseDouble_t ErfInverse(Double_t x)Returns the inverse error function.Definition TMath.cxx:208; TMath::LaplaceDistDouble_t LaplaceDist(Double_t x, Double_t alpha=0, Double_t beta=1)Computes the probability density function of Laplace distribution at point x, with location parameter...Definition TMath.cxx:2364; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::ErfcDouble_t Erfc(Double_t x)Computes the complementary error function erfc(x).Definition TMath.cxx:199; TMath::VavilovIDouble_t VavilovI(Double_t x, Double_t kappa, Double_t beta2)Returns the value of the Vavilov cumulative distribution function (lower tail integral of the probabi...Definition TMath.cxx:2815; TMath::BetaDouble_t Beta(Double_t p, Double_t q)Calculates Beta-function Gamma(p)*Gamma(q)/Gamma(p+q).Definition TMath.cxx:2011; TMath::PoissonDouble_t Poisson(Double_t x, Double_t par)Computes the Poisson distribution function for (x,par).Definition TMath.cxx:587; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::BesselJ0Double_t BesselJ0(Double_t x)Modified Bessel function K_1(x)Definition TMath.cxx:1634; TMath::GammaDouble_t Gamma(Double_t z)Computation of gamma(z) for all z.Definition TMath.cxx:353; TMath::MinShort_t Min(Short_t a, Short_t b)Retur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:125515,error,error,125515,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,".Definition TObjArray.cxx:694; TObjArray::FindObjectTObject * FindObject(const char *name) const overrideFind an object in this collection using its name.Definition TObjArray.cxx:415; TObjArray::Addvoid Add(TObject *obj) overrideDefinition TObjArray.h:68; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::operator=TObject & operator=(const TObject &rhs)TObject assignment operator.Definition TObject.h:296; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TObject::Printvirtual void Print(Option_t *option="""") constThis method must be overridden when a class wants to print itself.Definition TObject.cxx:642; TROOT::GetEtcDirstatic const TString & GetEtcDir()Get the sysconfig directory in the installation. Static utility function.Definition TROOT.cxx:3056; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ReplaceAllTString & ReplaceAll(const TString &s1, const TString &s2)Definition TString.h:704; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoElement_8cxx_source.html:78086,error,error,78086,doc/master/TGeoElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoElement_8cxx_source.html,1,['error'],['error']
Availability,".Definition TSpectrumFit.cxx:1859. Definition at line 1859 of file TSpectrumFit.cxx. ◆ GetAmplitudes(). Double_t * TSpectrumFit::GetAmplitudes ; (; ); const. inline . Definition at line 116 of file TSpectrumFit.h. ◆ GetAmplitudesErrors(). Double_t * TSpectrumFit::GetAmplitudesErrors ; (; ); const. inline . Definition at line 117 of file TSpectrumFit.h. ◆ GetAreas(). Double_t * TSpectrumFit::GetAreas ; (; ); const. inline . Definition at line 118 of file TSpectrumFit.h. ◆ GetAreasErrors(). Double_t * TSpectrumFit::GetAreasErrors ; (; ); const. inline . Definition at line 119 of file TSpectrumFit.h. ◆ GetBackgroundParameters(). void TSpectrumFit::GetBackgroundParameters ; (; Double_t & ; a0, . Double_t & ; a0Err, . Double_t & ; a1, . Double_t & ; a1Err, . Double_t & ; a2, . Double_t & ; a2Err . ). This function gets the background parameters and their errors. . a0 - gets the fitted value of a0 parameter; a0Err - gets error value of a0 parameter; a1 - gets the fitted value of a1 parameter; a1Err - gets error value of a1 parameter; a2 - gets the fitted value of a2 parameter; a2Err - gets error value of a2 parameter . Definition at line 2742 of file TSpectrumFit.cxx. ◆ GetChi(). Double_t TSpectrumFit::GetChi ; (; ); const. inline . Definition at line 121 of file TSpectrumFit.h. ◆ GetPositions(). Double_t * TSpectrumFit::GetPositions ; (; ); const. inline . Definition at line 122 of file TSpectrumFit.h. ◆ GetPositionsErrors(). Double_t * TSpectrumFit::GetPositionsErrors ; (; ); const. inline . Definition at line 123 of file TSpectrumFit.h. ◆ GetSigma(). void TSpectrumFit::GetSigma ; (; Double_t & ; sigma, . Double_t & ; sigmaErr . ). This function gets the sigma parameter and its error. . sigma - gets the fitted value of sigma parameter; sigmaErr - gets error value of sigma parameter . Definition at line 2727 of file TSpectrumFit.cxx. ◆ GetTailParameters(). void TSpectrumFit::GetTailParameters ; (; Double_t & ; t, . Double_t & ; tErr, . Double_t & ; b, . Double_t & ; bErr,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:42699,error,error,42699,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,3,['error'],['error']
Availability,".Gaus();; }; for (i=fraction; i<npoints; i++){; //the bad part of the sample; x[i]=r.Uniform(-1, 1);; e[i]=1;; y[i] = 1 + 2*x[i] + 3*x[i]*x[i] + 4*x[i]*x[i]*x[i] + r.Landau(10, 5);; }; ; TGraphErrors *grr = new TGraphErrors(npoints, x, y, nullptr, e);; grr->SetMinimum(-30);; grr->SetMaximum(80);; TF1 *ffit1 = new TF1(""ffit1"", ""pol3"", -5, 5);; TF1 *ffit2 = new TF1(""ffit2"", ""pol3"", -5, 5);; ffit1->SetLineColor(kBlue);; ffit2->SetLineColor(kRed);; TCanvas *myc = new TCanvas(""myc"", ""Linear and robust linear fitting"");; myc->SetGrid();; grr->Draw(""ap"");; //first, let's try to see the result sof ordinary least-squares fit:; printf(""Ordinary least squares:\n"");; grr->Fit(ffit1);; //the fitted function doesn't really follow the pattern of the data; //and the coefficients are far from the real ones; ; printf(""Resistant Least trimmed squares fit:\n"");; //Now let's try the resistant regression; //The option ""rob=0.75"" means that we want to use robust fitting and; //we know that at least 75% of data is good points (at least 50% of points; //should be good to use this algorithm). If you don't specify any number; //and just use ""rob"" for the option, default value of (npoints+nparameters+1)/2; //will be taken; grr->Fit(ffit2, ""+rob=0.75"");; //; TLegend *leg = new TLegend(0.6, 0.8, 0.89, 0.89);; leg->AddEntry(ffit1, ""Ordinary least squares"", ""l"");; leg->AddEntry(ffit2, ""LTS regression"", ""l"");; leg->Draw();; ; delete [] x;; delete [] y;; delete [] e;; ; }; e#define e(i)Definition RSha256.hxx:103; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; TF1.h; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TGraphErrors.h; TLegend.h; TRandom.h; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TCanvasTh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/fitLinearRobust_8C.html:2568,robust,robust,2568,doc/master/fitLinearRobust_8C.html,https://root.cern,https://root.cern/doc/master/fitLinearRobust_8C.html,1,['robust'],['robust']
Availability,".Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h->Merge(list);; h->Draw();; }. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1); Multiply this histogram by h1. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); Replace contents of this histogram by multiplication of h1 by h2. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. void Paint(Option_t* option = """"); Control routine to paint any kind of histograms. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TH1.html:101425,error,errors,101425,root/html602/TH1.html,https://root.cern,https://root.cern/root/html602/TH1.html,4,['error'],['errors']
Availability,".GetName())<< ""determined event sample size to select test sample from=""<<useForTesting<<Endl;; 1255 ; 1256 ; 1257 ; 1258 // associate undefined events; 1259 if( splitMode == ""ALTERNATE"" ){; 1260 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split 'ALTERNATE'"" << Endl;; 1261 Int_t nTraining = availableTraining;; 1262 for( EventVector::iterator it = eventVectorUndefined.begin(), itEnd = eventVectorUndefined.end(); it != itEnd; ){; 1263 ++nTraining;; 1264 if( nTraining <= requestedTraining ){; 1265 eventVectorTraining.insert( eventVectorTraining.end(), (*it) );; 1266 ++it;; 1267 }; 1268 if( it != itEnd ){; 1269 eventVectorTesting.insert( eventVectorTesting.end(), (*it) );; 1270 ++it;; 1271 }; 1272 }; 1273 } else {; 1274 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split '"" << splitMode << ""'"" << Endl;; 1275 ; 1276 // test if enough events are available; 1277 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableundefined : "" << availableUndefined << Endl;; 1278 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTraining : "" << useForTraining << Endl;; 1279 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTesting : "" << useForTesting << Endl;; 1280 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTraining : "" << availableTraining << Endl;; 1281 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTesting : "" << availableTesting << Endl;; 1282 ; 1283 if( availableUndefined<(useForTraining-availableTraining) ||; 1284 availableUndefined<(useForTesting -availableTesting ) ||; 1285 availableUndefined<(useForTraining+useForTesting-availableTraining-availableTesting ) ){; 1286 Log() << kFATAL << Form(""Dataset[%s] : "",dsi.GetName())<< ""More events requested than available!"" << Endl;; 1287 }; 1288 ; 1289 // select the events; 1290 if (useForTraining>availableTraining){; 1291 eventVectorTraining.insert( eventVectorTraining.end() , eventVectorUndefined.begin(), eventVectorUndef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:55750,avail,availableundefined,55750,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,2,['avail'],"['availableUndefined', 'availableundefined']"
Availability,".GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0][i] = tvEyL(itvEyLL + i);; 448 fEyH[0][i] = tvEyH(itvEyHL + i);; 449 }; 450 ; 451 CalcYErrorsSum();; 452}; 453 ; 454////////////////////////////////////////////////////////////////////////////////; 455/// Constructor with six vectors of doubles in input and a single y error dimension.; 456/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 457/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 458/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 459/// The number of points in the graph is the minimum of number of points; 460/// in `tvX` and `tvY`.; 461 ; 462TGraphMultiErrors::TGraphMultiErrors(const TVectorD &tvX, const TVectorD &tvY, const TVectorD &tvExL,; 463 const TVectorD &tvExH, const TVectorD &tvEyL, const TVectorD &tvEyH, Int_t m); 464 : fNYErrors(1), fSumErrorsMode(m); 465{; 466 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 467 ; 468 if (!TGraph::CtorAllocate()); 469 return;; 470 ; 471 if (!CtorAllocate()); 472 return;; 473 ; 474 Int_t itvXL = tvX.GetLwb();; 475 Int_t itvYL = tvY.GetLwb();; 476 Int_t itvExLL = tvExL.GetLwb();; 477 Int_t itvExHL = tvExH.GetLwb();; 478 Int_t itvEyLL = tvEyL.GetLwb();; 479 Int_t itvEyHL = tvEyH.GetLwb();; 480 ; 481 for (Int_t i = 0; i < fNpoints; i++) {; 482 fX[i] = tvX(i + itvXL);; 483 fY[i] = tvY(i + itvYL);; 484 fExL[i] = tvExL(i + itvExLL);; 485 fExH[i] = tvExH(i + itvExHL);; 486 fEyL[0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:16753,error,errors,16753,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,".M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.; Getting the error via TF1::DerivativeError: (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: ; \[; err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; \]. where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.; AuthorAnna Kreshuk ; Definition at line 1243 of file TF1.cxx. ◆ DerivativeError(). Double_t TF1::DerivativeError ; (; ). static . Static function returning the error of the last call to the of Derivative's functions. ; Definition at line 1277 of file TF1.cxx. ◆ DistancetoPrimitive(). Int_t TF1::DistancetoPrimitive ; (; Int_t ; px, . Int_t ; py . ). overridevirtual . Compute distance from point px,py to a function. ; Compute the closest distance of approach from point px,py to this function. The distance is computed in pixels units.; Note that px is called with a negative value when the TF1 is in TGraph or TH1 list of functions. In this case there is no point looking at the histogram axis. ; Reimplemented from TObject.; Reimplemented in TF2, and TF3.; Definition at line 1293 of file TF1.cxx. ◆ DoCreateHistogram(). TH1 * TF1::DoCreateHistogram ; (; Double_t ; xmin, . Double_t ; xmax, . Bool_t ; recreate = kFALSE . ). protectedvirtual . Create histogram with bin content equal to function value computed at the bin center This histogram will be used to paint the function A re-creation is forced and a new histogram is done if recreate=true. ; Definition at line",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:66361,error,error,66361,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['error'],['error']
Availability,".]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReadBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile. If ReadBuffers; is supported by xrootd it will try to get the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:28607,error,errors,28607,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,4,['error'],['errors']
Availability,".]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note: This is the overloading made in TXNetFile, If ReadBuffers; is supported by xrootd it will try to gt the whole list from one single; call avoiding the latency of multiple calls. Bool_t WriteBuffer(const char* buffer, Int_t B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:26595,error,errors,26595,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,6,['error'],['errors']
Availability,".ch/alice/event_1.zip#3"". This function is normally only called via TFile::Open(). ; Definition at line 121 of file TArchiveFile.cxx. ◆ OpenArchive(). virtual Int_t TArchiveFile::OpenArchive ; (; ). pure virtual . Implemented in TZIPFile. ◆ operator=(). TArchiveFile & TArchiveFile::operator= ; (; const TArchiveFile & ; ). privatedelete . Not implemented because TArchiveFile can not be copied. . ◆ ParseUrl(). Bool_t TArchiveFile::ParseUrl ; (; const char * ; url, . TString & ; archive, . TString & ; member, . TString & ; type . ). staticprotected . Try to determine if url contains an anchor specifying an archive member. ; Returns kFALSE in case of an error. ; Definition at line 149 of file TArchiveFile.cxx. ◆ SetCurrentMember(). virtual Int_t TArchiveFile::SetCurrentMember ; (; ). pure virtual . Implemented in TZIPFile. ◆ SetMember() [1/2]. Int_t TArchiveFile::SetMember ; (; const char * ; member). virtual . Explicitely make the specified member the current member. ; Returns -1 in case of error, 0 otherwise. ; Definition at line 88 of file TArchiveFile.cxx. ◆ SetMember() [2/2]. Int_t TArchiveFile::SetMember ; (; Int_t ; idx). virtual . Explicitely make the member with the specified index the current member. ; Returns -1 in case of error, 0 otherwise. ; Definition at line 100 of file TArchiveFile.cxx. ◆ Streamer(). void TArchiveFile::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TZIPFile. ◆ StreamerNVirtual(). void TArchiveFile::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 61 of file TArchiveFile.h. Member Data Documentation. ◆ fArchiveName. TString TArchiveFile::fArchiveName. protected . Archive file name. ; Definition at line 31 of file TArchiveFile.h. ◆ fCurMember. TArchiveMember* TArchiveFile::fCurMember. protected . Current archive member. ; Definition at line 36 of file TArchiveFile.h. ◆ fFile. TFile* TArchiveFile::fFile. protect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTArchiveFile.html:16271,error,error,16271,doc/master/classTArchiveFile.html,https://root.cern,https://root.cern/doc/master/classTArchiveFile.html,1,['error'],['error']
Availability,".cpp}; 222 Font number TTF Names PostScript/PDF Names; 223 1 : ""Free Serif Italic"" ""Times-Italic""; 224 2 : ""Free Serif Bold"" ""Times-Bold""; 225 3 : ""Free Serif Bold Italic"" ""Times-BoldItalic""; 226 4 : ""Tex Gyre Regular"" ""Helvetica""; 227 5 : ""Tex Gyre Italic"" ""Helvetica-Oblique""; 228 6 : ""Tex Gyre Bold"" ""Helvetica-Bold""; 229 7 : ""Tex Gyre Bold Italic"" ""Helvetica-BoldOblique""; 230 8 : ""Free Mono"" ""Courier""; 231 9 : ""Free Mono Oblique"" ""Courier-Oblique""; 232 10 : ""Free Mono Bold"" ""Courier-Bold""; 233 11 : ""Free Mono Bold Oblique"" ""Courier-BoldOblique""; 234 12 : ""Symbol"" ""Symbol""; 235 13 : ""Free Serif"" ""Times-Roman""; 236 14 : ""Wingdings"" ""ZapfDingbats""; 237~~~; 238 ; 239The PostScript and PDF backends use the original PostScript-defined 13 fonts' styles; 240forming four type families (Courier, Helvetica, Times, Symbol) as listed in the; 241""Core Font Set"" section of [this page](https://en.wikipedia.org/wiki/PostScript_fonts).; 242These fonts are always available and do not need to be loaded in the PS or PDF files; 243allowing to keep the files' sizes small.; 244 ; 245On screen, text is rendered using free TTF fonts similar to the PDF ones. The corresponding; 246font files are coming with the ROOT distribution in `$ROOTSYS/fonts/Free*`.; 247 ; 248Begin_Macro; 249fonts.C; 250End_Macro; 251*/; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// AttText default constructor.; 255///; 256/// Default text attributes are taken from the current style.; 257 ; 258TAttText::TAttText(); 259{; 260 if (!gStyle) {; 261 ResetAttText();; 262 return;; 263 }; 264 fTextAlign = gStyle->GetTextAlign();; 265 fTextAngle = gStyle->GetTextAngle();; 266 fTextColor = gStyle->GetTextColor();; 267 fTextFont = gStyle->GetTextFont();; 268 fTextSize = gStyle->GetTextSize();; 269}; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// AttText normal constructor.; 273///; 274/// Text attributes are taken from the argum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttText_8cxx_source.html:8365,avail,available,8365,doc/master/TAttText_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttText_8cxx_source.html,1,['avail'],['available']
Availability,".cxx. ◆ AssignDtd(). void TXMLEngine::AssignDtd ; (; XMLDocPointer_t ; xmldoc, . const char * ; dtdname, . const char * ; rootname . ). assigns dtd filename to document ; Definition at line 1274 of file TXMLEngine.cxx. ◆ Class(). static TClass * TXMLEngine::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TXMLEngine::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TXMLEngine::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 108 of file TXMLEngine.h. ◆ CleanNode(). void TXMLEngine::CleanNode ; (; XMLNodePointer_t ; xmlnode). remove all children node from xmlnode ; Definition at line 1235 of file TXMLEngine.cxx. ◆ DeclFileName(). static const char * TXMLEngine::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 108 of file TXMLEngine.h. ◆ DisplayError(). void TXMLEngine::DisplayError ; (; Int_t ; error, . Int_t ; linenumber . ). protected . Displays xml parsing error. ; Definition at line 2223 of file TXMLEngine.cxx. ◆ DocGetRootElement(). XMLNodePointer_t TXMLEngine::DocGetRootElement ; (; XMLDocPointer_t ; xmldoc). returns root node of document ; Definition at line 1339 of file TXMLEngine.cxx. ◆ DocSetRootElement(). void TXMLEngine::DocSetRootElement ; (; XMLDocPointer_t ; xmldoc, . XMLNodePointer_t ; xmlnode . ). set main (root) node for document ; Definition at line 1326 of file TXMLEngine.cxx. ◆ FindNs(). XMLNsPointer_t TXMLEngine::FindNs ; (; XMLNodePointer_t ; xmlnode, . const char * ; nsname . ). protected . define if namespace of that name exists for xmlnode ; Definition at line 1562 of file TXMLEngine.cxx. ◆ FreeAllAttr(). void TXMLEngine::FreeAllAttr ; (; XMLNodePointer_t ; xmlnode). Free all attributes of the node. ; Definition at line 647 of file TXMLEngine.cxx. ◆ FreeAttr(). void TXMLEngine::FreeAttr ; (; XMLNodePointer_t ; xmlnode, . const char ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXMLEngine.html:24052,error,error,24052,doc/master/classTXMLEngine.html,https://root.cern,https://root.cern/doc/master/classTXMLEngine.html,1,['error'],['error']
Availability,".cxx. ◆ BinData() [4/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; val, . const double * ; ex, . const double * ; eval . ). constructors using external data ; constructor from external data for 1D with errors on coordinate and value ; Definition at line 73 of file BinData.cxx. ◆ BinData() [5/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; dataY, . const double * ; val, . const double * ; ex, . const double * ; ey, . const double * ; eval . ). constructor from external data for 2D with errors on coordinate and value ; Definition at line 111 of file BinData.cxx. ◆ BinData() [6/7]. ROOT::Fit::BinData::BinData ; (; unsigned int ; n, . const double * ; dataX, . const double * ; dataY, . const double * ; dataZ, . const double * ; val, . const double * ; ex, . const double * ; ey, . const double * ; ez, . const double * ; eval . ). constructor from external data for 3D with errors on coordinate and value ; Definition at line 149 of file BinData.cxx. ◆ ~BinData(). ROOT::Fit::BinData::~BinData ; (; ). override . destructor ; Definition at line 188 of file BinData.cxx. ◆ BinData() [7/7]. ROOT::Fit::BinData::BinData ; (; const BinData & ; rhs). copy constructors ; Definition at line 221 of file BinData.cxx. Member Function Documentation. ◆ Add() [1/8]. void ROOT::Fit::BinData::Add ; (; const double * ; x, . double ; val . ). add multi-dim coordinate data with only value ; Definition at line 504 of file BinData.cxx. ◆ Add() [2/8]. void ROOT::Fit::BinData::Add ; (; const double * ; x, . double ; val, . const double * ; ex, . double ; elval, . double ; ehval . ). add multi-dim coordinate data with both error in coordinates and value ; Definition at line 577 of file BinData.cxx. ◆ Add() [3/8]. void ROOT::Fit::BinData::Add ; (; const double * ; x, . double ; val, . const double * ; ex, . double ; eval . ). add multi-dim coordinate data with both error in coordinates and value ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html:16654,error,errors,16654,doc/master/classROOT_1_1Fit_1_1BinData.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1BinData.html,1,['error'],['errors']
Availability,".cxx. ◆ SetBinContent() [1/3]. void TH2Poly::SetBinContent ; (; Int_t ; bin, . Double_t ; content . ). overridevirtual . Sets the contents of the input bin to the input content Negative values between -1 and -9 are for the overflows and the sea. ; Reimplemented from TH2.; Definition at line 1407 of file TH2Poly.cxx. ◆ SetBinContent() [2/3]. void TH2Poly::SetBinContent ; (; Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH2.; Definition at line 149 of file TH2Poly.h. ◆ SetBinContent() [3/3]. void TH2Poly::SetBinContent ; (; Int_t ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH2.; Definition at line 150 of file TH2Poly.h. ◆ SetBinContentChanged(). void TH2Poly::SetBinContentChanged ; (; Bool_t ; flag). inline . Definition at line 122 of file TH2Poly.h. ◆ SetBinError() [1/3]. void TH2Poly::SetBinError ; (; Int_t ; bin, . Double_t ; error . ). overridevirtual . Set the bin Error. ; Re-implementation for TH2Poly given the different bin indexing in the stored squared error array. See also notes in TH1::SetBinError; Bins are in range [1:nbins] and for bin < 0 in the range [-9:-1] the errors is set for the overflow bins ; Reimplemented from TH1.; Definition at line 893 of file TH2Poly.cxx. ◆ SetBinError() [2/3]. void TH2Poly::SetBinError ; (; Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 151 of file TH2Poly.h. ◆ SetBinError() [3/3]. void TH2Poly::SetBinError ; (; Int_t ; , . Int_t ; , . Int_t ; , . Double_t ;  . ). inlineoverrideprotectedvirtual . NOT IMPLEMENTED for TH2Poly. ; Reimplemented from TH1.; Definition at line 152 of file TH2Poly.h. ◆ SetFloat(). void TH2Poly::SetFloat ; (; Bool_t ; flag = true). When set to kTRUE, allows the histogram to expand if a bin outside the limits is added. ; Definition at line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH2Poly.html:85895,error,error,85895,doc/master/classTH2Poly.html,https://root.cern,https://root.cern/doc/master/classTH2Poly.html,1,['error'],['error']
Availability,".cxx. ◆ SetCovariance(). bool ROOT::Math::Minimizer::SetCovariance ; (; std::span< const double > ; cov, . unsigned int ; nrow . ). virtual . set initial covariance matrix ; set initial values for covariance/error matrix The covariance matrix must be provided in compressed form (row-major ordered upper traingular part) ; Reimplemented in ROOT::Minuit2::Minuit2Minimizer.; Definition at line 25 of file Minimizer.cxx. ◆ SetCovarianceDiag(). bool ROOT::Math::Minimizer::SetCovarianceDiag ; (; std::span< const double > ; d2, . unsigned int ; n . ). virtual . set initial second derivatives ; Reimplemented in ROOT::Minuit2::Minuit2Minimizer.; Definition at line 15 of file Minimizer.cxx. ◆ SetDefaultOptions(). void ROOT::Math::Minimizer::SetDefaultOptions ; (; ). inline . reset the default options (defined in MinimizerOptions) ; Definition at line 361 of file Minimizer.h. ◆ SetErrorDef(). void ROOT::Math::Minimizer::SetErrorDef ; (; double ; up). inline . set scale for calculating the errors ; Definition at line 347 of file Minimizer.h. ◆ SetExtraOptions(). void ROOT::Math::Minimizer::SetExtraOptions ; (; const IOptions & ; extraOptions). inline . set only the extra options ; Definition at line 358 of file Minimizer.h. ◆ SetFixedVariable(). bool ROOT::Math::Minimizer::SetFixedVariable ; (; unsigned int ; ivar, . const std::string & ; name, . double ; val . ). virtual . set a new fixed variable (override if minimizer supports them ) ; Reimplemented in ROOT::Math::GeneticMinimizer, TFumiliMinimizer, ROOT::Math::BasicMinimizer, TLinearMinimizer, TMinuitMinimizer, and ROOT::Minuit2::Minuit2Minimizer.; Definition at line 44 of file Minimizer.cxx. ◆ SetFunction(). virtual void ROOT::Math::Minimizer::SetFunction ; (; const ROOT::Math::IMultiGenFunction & ; func). pure virtual . set the function to minimize ; Implemented in TFumiliMinimizer, ROOT::Math::GeneticMinimizer, ROOT::Math::BasicMinimizer, ROOT::Math::GSLMinimizer, ROOT::Math::GSLNLSMinimizer, TLinearMinimizer, TMinuitMinimi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html:27772,error,errors,27772,doc/master/classROOT_1_1Math_1_1Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1Minimizer.html,1,['error'],['errors']
Availability,".cxx. ◆ mnpsdf(). void TMinuit::mnpsdf ; (; ). virtual . Calculates the eigenvalues of v to see if positive-def. ; if not, adds constant along diagonal to make positive. ; Definition at line 6494 of file TMinuit.cxx. ◆ mnrazz(). void TMinuit::mnrazz ; (; Double_t ; ynew, . Double_t * ; pnew, . Double_t * ; y, . Int_t & ; jh, . Int_t & ; jl . ). virtual . Called only by MNSIMP (and MNIMPR) to add a new point. ; and remove an old one from the current simplex, and get the estimated distance to minimum. ; Definition at line 6568 of file TMinuit.cxx. ◆ mnrn15(). void TMinuit::mnrn15 ; (; Double_t & ; val, . Int_t & ; inseed . ). virtual . This is a super-portable random number generator. ; It should not overflow on any 32-bit machine. The cycle is only ~10**9, so use with care! Note especially that VAL must not be undefined on input.; Set Default Starting Seed ; Definition at line 6619 of file TMinuit.cxx. ◆ mnrset(). void TMinuit::mnrset ; (; Int_t ; iopt). virtual . Resets function value and errors to UNDEFINED. . If IOPT=1,; If IOPT=0, sets only MINOS errors to undefined Called from MNCLER and whenever problem changes, for example after SET LIMITS, SET PARAM, CALL FCN 6 . Definition at line 6661 of file TMinuit.cxx. ◆ mnsave(). void TMinuit::mnsave ; (; ). virtual . Writes current parameter values and step sizes onto file ISYSSA. ; in format which can be reread by Minuit for restarting. The covariance matrix is also output if it exists. ; Definition at line 6695 of file TMinuit.cxx. ◆ mnscan(). void TMinuit::mnscan ; (; ). virtual . Scans the values of FCN as a function of one parameter. ; and plots the resulting values as a curve using MNPLOT. It may be called to scan one parameter or all parameters. retains the best function and parameter values found. ; Definition at line 6708 of file TMinuit.cxx. ◆ mnseek(). void TMinuit::mnseek ; (; ). virtual . Performs a rough (but global) minimization by monte carlo search. ; Each time a new minimum is found, the search area is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:62522,error,errors,62522,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['errors']
Availability,".cxx:249; namechar name[80]Definition TGX11.cxx:110; TGeoElement.h; STP_temperaturestatic const Double_t STP_temperatureDefinition TGeoMaterial.h:31; STP_pressurestatic const Double_t STP_pressureDefinition TGeoMaterial.h:32; TList.h; TNamed.h; TAttFillFill Area Attributes class.Definition TAttFill.h:19; TAttFill::fFillStyleStyle_t fFillStyleFill area style.Definition TAttFill.h:23; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TGDMLMatrixThis class is used in the process of reading and writing the GDML ""matrix"" tag.Definition TGDMLMatrix.h:33; TGeoElementTableTable of elements.Definition TGeoElement.h:398; TGeoElementBase class for chemical elements.Definition TGeoElement.h:36; TGeoExtensionABC for user objects attached to TGeoVolume or TGeoNode.Definition TGeoExtension.h:17; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMaterial::GetConstPropertyDouble_t GetConstProperty(const char *property, Bool_t *error=nullptr) constDefinition TGeoMaterial.cxx:392; TGeoMaterial::GetIntLenvirtual Double_t GetIntLen() constDefinition TGeoMaterial.h:110; TGeoMaterial::SetDensityvirtual void SetDensity(Double_t density)Definition TGeoMaterial.h:137; TGeoMaterial::SetZvirtual void SetZ(Double_t z)Definition TGeoMaterial.h:132; TGeoMaterial::SetUserExtensionvoid SetUserExtension(TGeoExtension *ext)Connect user-defined extension to the material.Definition TGeoMaterial.cxx:346; TGeoMaterial::GetUserExtensionTGeoExtension * GetUserExtension() constDefinition TGeoMaterial.h:118; TGeoMaterial::GetFWExtensionTGeoExtension * GetFWExtension() constDefinition TGeoMaterial.h:119; TGeoMaterial::GetCerenkovPropertiesvirtual TObject * GetCerenkovProperties() constDefinition TGeoMaterial.h:112; TGeoMaterial::fStateEGeoMaterialState fStateDefinition TGeoMaterial.h:48; TGeoMaterial::SetCerenkovPropertiesvirtual void SetCerenkovProperties(TObject *cerenkov)Definition TGeoMaterial.h:143; TGeoMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMaterial_8h_source.html:13852,error,error,13852,doc/master/TGeoMaterial_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoMaterial_8h_source.html,1,['error'],['error']
Availability,".cxx:588; TGraphAsymmErrors::CtorAllocateBool_t CtorAllocate()Should be called from ctors after fNpoints has been set.Definition TGraphAsymmErrors.cxx:1061; TGraphAsymmErrors::SetPointErrorvirtual void SetPointError(Double_t exl, Double_t exh, Double_t eyl, Double_t eyh)Set ex and ey values for point pointed by the mouse.Definition TGraphAsymmErrors.cxx:1299; TGraphAsymmErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t i) const overrideGet high error on X.Definition TGraphAsymmErrors.cxx:1151; TGraphAsymmErrors::fEYhighDouble_t * fEYhigh[fNpoints] array of Y high errorsDefinition TGraphAsymmErrors.h:32; TGraphAsymmErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fE*** to arrays[***] or to f*** Copy points.Definition TGraphAsymmErrors.cxx:1033; TGraphAsymmErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t exl=0., Double_t exh=0., Double_t eyl=0., Double_t eyh=0.)Add a point with asymmetric errorbars to the graph.Definition TGraphAsymmErrors.cxx:451; TGraphAsymmErrors::ComputeRangevoid ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const overrideCompute Range.Definition TGraphAsymmErrors.cxx:977; TGraphAsymmErrors::SetPointEXlowvirtual void SetPointEXlow(Int_t i, Double_t exl)Set EXlow for point i.Definition TGraphAsymmErrors.cxx:1348; TGraphAsymmErrors::SetPointEYhighvirtual void SetPointEYhigh(Int_t i, Double_t eyh)Set EYhigh for point i.Definition TGraphAsymmErrors.cxx:1390; TGraphAsymmErrors::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TGraphAsymmErrors.cxx:1241; TGraphAsymmErrors::BayesDividevirtual void BayesDivide(const TH1 *pass, const TH1 *total, Option_t *opt="""")This function is only kept for backward compatibility.Definition TGraphAsymmErrors.cxx:508; TGraphAsymmErrors::GetEYhighDouble_t * GetEYhigh() const overrideDefinition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html:9351,error,errorbars,9351,doc/master/TGraphAsymmErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8h_source.html,1,['error'],['errorbars']
Availability,.cxx;  Quaternion.cxx;  QuaternionXaxial.cxx;  Rotation3D.cxx;  Rotation3DxAxial.cxx;  RotationZYX.cxx;  Transform3D.cxx;  Translation3D.cxx;  VectorUtil.cxx;  ► test;  coordinates3D.cxx;  coordinates4D.cxx;  CoordinateTraits.h;  rotationApplication.cxx;  RotationTraits.h;  stress2D.cxx;  stress3D.cxx;  testBoost.cxx;  testGenVector.cxx;  testIterator.cxx;  testVectorIO.cxx;  Track.h;  TrackLinkDef.h;  vectorOperation.cxx;  ► mathcore;  ► inc;  ► Fit;  BasicFCN.h;  BinData.h;  BinPoint.h;  Chi2FCN.h;  DataOptions.h;  DataRange.h;  DataVector.h;  DataVectorfwd.h;  FcnAdapter.h;  FitConfig.h;  FitResult.h;  Fitter.h;  FitUtil.h;  FitUtilParallel.h;  LogLikelihoodFCN.h;  ParameterSettings.h;  PoissonLikelihoodFCN.h;  SparseData.h;  UnBinData.h;  ► Math;  AdaptiveIntegratorMultiDim.h;  AllIntegrationTypes.h;  BasicMinimizer.h;  BrentMethods.h;  BrentMinimizer1D.h;  BrentRootFinder.h;  ChebyshevPol.h;  Delaunay2D.h;  DistFunc.h;  DistFuncMathCore.h;  DistSampler.h;  DistSamplerOptions.h;  Error.h;  Factory.h;  FitMethodFunction.h;  Functor.h;  GaussIntegrator.h;  GaussLegendreIntegrator.h;  GenAlgoOptions.h;  GoFTest.h;  IFunction.h;  IFunctionfwd.h;  IMinimizer1D.h;  Integrator.h;  IntegratorMultiDim.h;  IntegratorOptions.h;  IOptions.h;  IParamFunction.h;  IParamFunctionfwd.h;  IRootFinderMethod.h;  KDTree.h;  KDTree.icc;  Math.h;  MersenneTwisterEngine.h;  Minimizer.h;  MinimizerOptions.h;  MinimizerVariableTransformation.h;  MinimTransformFunction.h;  MinimTransformVariable.h;  MixMaxEngine.h;  MultiDimParamFunctionAdapter.h;  OneDimFunctionAdapter.h;  ParamFunctor.h;  PdfFunc.h;  PdfFuncMathCore.h;  ProbFunc.h;  ProbFuncMathCore.h;  QuantFunc.h;  QuantFuncMathCore.h;  Random.h;  RandomFunctions.h;  RichardsonDerivator.h;  RootFinder.h;  SpecFunc.h;  SpecFuncMathCore.h;  StdRandomEngines.h;  TDataPoint.h;  TDataPoint.icc;  TDataPointN.h;  TDataPointN.icc;  TRandomEngine.h;  Util.h;  VirtualIntegrator.h;  WrappedFunction.h;  WrappedParamFunction.h;  LinkDef.h;  LinkDe,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:43469,Error,Error,43469,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,1,['Error'],['Error']
Availability,".d.f evaluates to NaN @ numerator=wrap_pdf=-0.675078, denominator=wrap_pdf_Int[pTV]=86190.2; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.186765 cHl3=8.8591 cHq3=-0.971282; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-6.32705, denominator=wrap_pdf_Int[pTV]=46316; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.218731 cHl3=0.37397 cHq3=-2.08166; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:11548,recover,recover,11548,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,".d.f evaluates to NaN @ numerator=wrap_pdf=38.6705, denominator=wrap_pdf_Int[pTV]=90131.3; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.22694 cHl3=-7.04051 cHq3=0.54016; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=-2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denomi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:12765,recover,recover,12765,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,".dask.org/en/stable/)):; 718 ; 719~~~{.py}; 720import ROOT; 721from dask.distributed import Client; 722 ; 723# Point RDataFrame calls to the Dask specific RDataFrame; 724RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 725 ; 726# In a Python script the Dask client needs to be initalized in a context; 727# Jupyter notebooks / Python session don't need this; 728if __name__ == ""__main__"":; 729 # With an already setup cluster that exposes a Dask scheduler endpoint; 730 client = Client(""dask_scheduler.domain.com:8786""); 731 ; 732 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 733 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 734 # Proceed as usual; 735 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 736~~~; 737 ; 738If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 739provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 740using all cores available.; 741 ; 742### Choosing the number of distributed tasks; 743 ; 744A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 745tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 746generically tries to infer how many cores are available in the cluster through the connection object. The number of; 747tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 748doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 749a batch system. The client object created at the beginning of the application does not automatically know how many cores; 750will be available during distributed execution, since the jobs are submitted to the batch system after the creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:42732,avail,available,42732,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,".dask.org/en/stable/)):; 758 ; 759~~~{.py}; 760import ROOT; 761from dask.distributed import Client; 762 ; 763# Point RDataFrame calls to the Dask specific RDataFrame; 764RDataFrame = ROOT.RDF.Experimental.Distributed.Dask.RDataFrame; 765 ; 766# In a Python script the Dask client needs to be initalized in a context; 767# Jupyter notebooks / Python session don't need this; 768if __name__ == ""__main__"":; 769 # With an already setup cluster that exposes a Dask scheduler endpoint; 770 client = Client(""dask_scheduler.domain.com:8786""); 771 ; 772 # The Dask RDataFrame constructor accepts the Dask Client object as an optional argument; 773 df = RDataFrame(""mytree"",""myfile.root"", daskclient=client); 774 # Proceed as usual; 775 df.Define(""x"",""someoperation"").Histo1D((""name"", ""title"", 10, 0, 10), ""x""); 776~~~; 777 ; 778If an instance of [distributed.Client](http://distributed.dask.org/en/stable/api.html#distributed.Client) is not; 779provided to the RDataFrame object, it will be created for you and it will run the computations in the local machine; 780using all cores available.; 781 ; 782### Choosing the number of distributed tasks; 783 ; 784A distributed RDataFrame has internal logic to define in how many chunks the input dataset will be split before sending; 785tasks to the distributed backend. Each task reads and processes one of said chunks. The logic is backend-dependent, but; 786generically tries to infer how many cores are available in the cluster through the connection object. The number of; 787tasks will be equal to the inferred number of cores. There are cases where the connection object of the chosen backend; 788doesn't have information about the actual resources of the cluster. An example of this is when using Dask to connect to; 789a batch system. The client object created at the beginning of the application does not automatically know how many cores; 790will be available during distributed execution, since the jobs are submitted to the batch system after the creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:44372,avail,available,44372,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['avail'],['available']
Availability,".e. whether the entry is available. ; Definition at line 225 of file TTreeReader.h. ◆ SetEntryBase(). TTreeReader::EEntryStatus TTreeReader::SetEntryBase ; (; Long64_t ; entry, . bool ; local . ). protected . Load an entry into the tree, return the status of the read. ; For chains, entry is the global (i.e. not tree-local) entry number, unless local is true, in which case entry specifies the entry number within the current tree. This is needed for instance for TSelector::Process(). ; Definition at line 630 of file TTreeReader.cxx. ◆ SetLocalEntry(). EEntryStatus TTreeReader::SetLocalEntry ; (; Long64_t ; entry). inline . Set the next local tree entry. ; If a TEntryList is set, this function is equivalent to SetEntry().; Parameters. entryEntry number of the TChain's current TTree. This is the entry number passed for instance by TSelector::Process(entry), i.e. within TSelector::Process() always use SetLocalEntry() and not SetEntry()! . Returnsthe entry's read status, i.e. whether the entry is available. ; Definition at line 235 of file TTreeReader.h. ◆ SetProxies(). bool TTreeReader::SetProxies ; (; ). protected . Tell readers we now have a tree. ; fValues gets insertions during this loop (when parametrized arrays are read), invalidating iterators. Use old-school counting instead. ; Definition at line 376 of file TTreeReader.cxx. ◆ SetTree() [1/3]. void TTreeReader::SetTree ; (; const char * ; keyname, . TDirectory * ; dir, . TEntryList * ; entryList = nullptr . ). Set (or update) the which tree to read from, passing the name of a tree in a directory. ; Parameters. keyname- name of the tree in dir ; dir- the TDirectory to load keyname from (or gDirectory if nullptr) ; entryList- the TEntryList to attach to the TTreeReader. . Definition at line 846 of file TTreeReader.cxx. ◆ SetTree() [2/3]. void TTreeReader::SetTree ; (; const char * ; keyname, . TEntryList * ; entryList = nullptr . ). inline . Definition at line 198 of file TTreeReader.h. ◆ SetTree() [3/3]. void TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:33498,avail,available,33498,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['avail'],['available']
Availability,".findModule(moduleName);; 3602 // We should never be able to build a module without having it in the; 3603 // modulemap. Still, let's print a warning that we at least tell the; 3604 // user that this could lead to problems.; 3605 if (!module) {; 3606 ROOT::TMetaUtils::Warning(nullptr,; 3607 ""Couldn't find module %s in the available modulemaps. This""; 3608 ""prevents us from correctly diagnosing wrongly built modules.\n"",; 3609 moduleName.c_str());; 3610 }; 3611 }; 3612 ; 3613 // A dictionary module could build implicitly a set of implicit modules.; 3614 // For example, the Core module builds libc.pcm and std.pcm implicitly.; 3615 // Those modules do not require I/O information and it is okay to build; 3616 // them as part of another module.; 3617 // However, we can build a module which requires I/O implictly which is; 3618 // an error because rootcling is not able to generate the corresponding; 3619 // dictionary.; 3620 // If we build a I/O requiring module implicitly we should display; 3621 // an error unless -mSystemByproducts or -mByproduct were specified.; 3622 bool isByproductModule = false;; 3623 if (module) {; 3624 // -mSystemByproducts allows implicit building of any system module.; 3625 if (module->IsSystem && gOptSystemModuleByproducts) {; 3626 isByproductModule = true;; 3627 }; 3628 // -mByproduct lists concrete module names that are allowed.; 3629 if (std::find(gOptModuleByproducts.begin(), gOptModuleByproducts.end(), moduleName) !=; 3630 gOptModuleByproducts.end()) {; 3631 isByproductModule = true;; 3632 }; 3633 }; 3634 if (!isByproductModule); 3635 fChild->HandleDiagnostic(DiagLevel, Info);; 3636 ; 3637 if (ID == remark_module_build && !isByproductModule) {; 3638 ROOT::TMetaUtils::Error(nullptr,; 3639 ""Building module '%s' implicitly. If '%s' requires a \n""; 3640 ""dictionary please specify build dependency: '%s' depends on '%s'.\n""; 3641 ""Otherwise, specify '-mByproduct %s' to disable this diagnostic.\n"",; 3642 moduleName.c_str(), moduleName.c_str(), gO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:144682,error,error,144682,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['error'],['error']
Availability,".g. via the method MnMigrad::release(n)), the error matrix is considered as unknown and has to be recalculated with appropriate commands.; 2.5.3 \(\mbox{MINOS}\) errors; The M processor \(\mbox{MINOS}\) (MnMinos, see [api:minos]) was probably the first, and may still be the only, generally available program to calculate parameter errors taking into account both parameter correlations and non-linearities. The \(\mbox{MINOS}\) error intervals are in general assymmetric, and may be expensive to calculate, especially if there are a lot of free parameters and the problem is very non-linear.; \(\mbox{MINOS}\) can only operate after a good minimum has already been found, and the error matrix has been calculated, so the \(\mbox{MINOS}\) error analysis will normally follow a \(\mbox{MIGRAD}\) minimization. The \(\mbox{MINOS}\) error for a given parameter is defined as the change in the value of that parameter which causes \({\displaystyle F'}\) to increase by the amount FCNBase::up(), where \({\displaystyle F'}\) is the minimum of \(\mbox{FCN}\) with respect to all other free parameters, and FCNBase::up() is the return value of the error definition specified by the user (default = 1.).; The algorithm for finding the positive and negative \(\mbox{MINOS}\) errors for parameter \(\mbox{n}\) consists of varying parameter \(\mbox{n}\), each time minimizing \(\mbox{FCN}\) with respect to all the other \(\mbox{npar - 1}\) variable parameters, to find numerically the two values of parameter \(\mbox{n}\) for which the minimum of \(\mbox{FCN}\) takes on the values \(\displaystyle F_{\mathrm{min}} + \mbox{up}\), where \(\displaystyle F_{\mathrm{min}}\) is the minimum of \(\mbox{FCN}\) with respect to all \(\mbox{npar}\) parameters. In order to make the procedure as fast as possible, \(\mbox{MINOS}\) uses the error matrix to predict the values of all parameters at the various sub-minima which it will have to find in the course of the calculation, and in the limit that the problem is near",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:23569,error,error,23569,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['error'],['error']
Availability,".h""; #include ""TList.h""; ; #include <vector>; #include <map>; #include <iostream>; ; double gauss2D(double *x, double *par) {; double z1 = double((x[0]-par[1])/par[2]);; double z2 = double((x[1]-par[3])/par[4]);; return par[0]*exp(-0.5*(z1*z1+z2*z2));; }; double my2Dfunc(double *x, double *par) {; double *p1 = &par[0];; double *p2 = &par[5];; return gauss2D(x,p1) + gauss2D(x,p2);; }; ; ; ; // data need to be globals to be visible by fcn; ; std::vector<std::pair<double, double> > coords;; std::vector<double > values;; std::vector<double > errors;; ; void myFcn(int & /*nPar*/, double * /*grad*/ , double &fval, double *p, int /*iflag */ ); {; int n = coords.size();; double chi2 = 0;; double tmp,x[2];; for (int i = 0; i <n; ++i ) {; x[0] = coords[i].first;; x[1] = coords[i].second;; tmp = ( values[i] - my2Dfunc(x,p))/errors[i];; chi2 += tmp*tmp;; }; fval = chi2;; }; TRandom3 rndm;; void FillHisto(TH2D * h, int n, double * p) {; ; ; const double mx1 = p[1];; const double my1 = p[3];; const double sx1 = p[2];; const double sy1 = p[4];; const double mx2 = p[6];; const double my2 = p[8];; const double sx2 = p[7];; const double sy2 = p[9];; //const double w1 = p[0]*sx1*sy1/(p[5]*sx2*sy2);; const double w1 = 0.5;; ; double x, y;; for (int i = 0; i < n; ++i) {; // generate randoms with larger Gaussians; rndm.Rannor(x,y);; ; double r = rndm.Rndm(1);; if (r < w1) {; x = x*sx1 + mx1;; y = y*sy1 + my1;; }; else {; x = x*sx2 + mx2;; y = y*sy2 + my2;; }; h->Fill(x,y);; ; }; }; ; ; ; ; int TwoHistoFit2D(bool global = true) {; ; // create two histograms; ; int nbx1 = 50;; int nby1 = 50;; int nbx2 = 50;; int nby2 = 50;; double xlow1 = 0.;; double ylow1 = 0.;; double xup1 = 10.;; double yup1 = 10.;; double xlow2 = 5.;; double ylow2 = 5.;; double xup2 = 20.;; double yup2 = 20.;; ; TH2D * h1 = new TH2D(""h1"",""core"",nbx1,xlow1,xup1,nby1,ylow1,yup1);; TH2D * h2 = new TH2D(""h2"",""tails"",nbx2,xlow2,xup2,nby2,ylow2,yup2);; ; double iniParams[10] = { 100, 6., 2., 7., 3, 100, 12., 3., 11., 2. };; /",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TwoHistoFit2D_8C.html:2618,error,errors,2618,doc/master/TwoHistoFit2D_8C.html,https://root.cern,https://root.cern/doc/master/TwoHistoFit2D_8C.html,1,['error'],['errors']
Availability,".h. ◆ BroadcastFile() [1/2]. Int_t TProof::BroadcastFile ; (; const char * ; file, . Int_t ; opt, . const char * ; rfile, . TList * ; wrks . ). private . Broadcast file to all workers in the specified list. ; Returns the number of workers the buffer was sent to. Returns -1 in case of error. ; Definition at line 2610 of file TProof.cxx. ◆ BroadcastFile() [2/2]. Int_t TProof::BroadcastFile ; (; const char * ; file, . Int_t ; opt, . const char * ; rfile = 0, . ESlaves ; list = kAllUnique . ). private . Broadcast file to all workers in the specified list. ; Returns the number of workers the buffer was sent to. Returns -1 in case of error. ; Definition at line 2639 of file TProof.cxx. ◆ BroadcastGroupPriority() [1/2]. Int_t TProof::BroadcastGroupPriority ; (; const char * ; grp, . Int_t ; priority, . ESlaves ; list = kAllUnique . ). private . Broadcast the group priority to all workers in the specified list. ; Returns the number of workers the message was successfully sent to. Returns -1 in case of error. ; Definition at line 2451 of file TProof.cxx. ◆ BroadcastGroupPriority() [2/2]. Int_t TProof::BroadcastGroupPriority ; (; const char * ; grp, . Int_t ; priority, . TList * ; workers . ). private . Broadcast the group priority to all workers in the specified list. ; Returns the number of workers the message was successfully sent to. Returns -1 in case of error. ; Definition at line 2424 of file TProof.cxx. ◆ BroadcastObject() [1/2]. Int_t TProof::BroadcastObject ; (; const TObject * ; obj, . Int_t ; kind, . TList * ; slaves . ). private . Broadcast an object to all slaves in the specified list. ; Use kind to set the TMEssage what field. Returns the number of slaves the message was sent to. Returns -1 in case of error. ; Definition at line 2543 of file TProof.cxx. ◆ BroadcastObject() [2/2]. Int_t TProof::BroadcastObject ; (; const TObject * ; obj, . Int_t ; kind = kMESS_OBJECT, . ESlaves ; list = kActive . ). private . Broadcast an object to all slaves in the specified lis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:69428,error,error,69428,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,".h. ◆ GetMethodCall(). TMethodCall * TMinuit::GetMethodCall ; (; ); const. inline . Definition at line 193 of file TMinuit.h. ◆ GetNumFixedPars(). Int_t TMinuit::GetNumFixedPars ; (; ); const. virtual . returns the number of currently fixed parameters ; Definition at line 855 of file TMinuit.cxx. ◆ GetNumFreePars(). Int_t TMinuit::GetNumFreePars ; (; ); const. virtual . returns the number of currently free parameters ; Definition at line 863 of file TMinuit.cxx. ◆ GetNumPars(). Int_t TMinuit::GetNumPars ; (; ); const. virtual . returns the total number of parameters that have been defined as fixed or free. ; The constant parameters are not counted. ; Definition at line 872 of file TMinuit.cxx. ◆ GetObjectFit(). TObject * TMinuit::GetObjectFit ; (; ); const. inline . Definition at line 194 of file TMinuit.h. ◆ GetParameter(). Int_t TMinuit::GetParameter ; (; Int_t ; parNo, . Double_t & ; currentValue, . Double_t & ; currentError . ); const. virtual . return parameter value and error ; Definition at line 841 of file TMinuit.cxx. ◆ GetPlot(). virtual TObject * TMinuit::GetPlot ; (; ); const. inlinevirtual . Definition at line 200 of file TMinuit.h. ◆ GetStatus(). Int_t TMinuit::GetStatus ; (; ); const. inline . Definition at line 201 of file TMinuit.h. ◆ IsA(). TClass * TMinuit::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 268 of file TMinuit.h. ◆ Migrad(). Int_t TMinuit::Migrad ; (; ). virtual . invokes the MIGRAD minimizer ; Definition at line 880 of file TMinuit.cxx. ◆ mnamin(). void TMinuit::mnamin ; (; ). virtual . Initialize AMIN. ; Called from many places. Initializes the value of AMIN by calling the user function. Prints out the function value and parameter values if Print Flag value is high enough. ; Definition at line 972 of file TMinuit.cxx. ◆ mnbins(). void TMinuit::mnbins ; (; Double_t ; a1, . Double_t ; a2, . Int_t ; naa, . Double_t & ; bl, . Double_t & ; bh, . Int_t & ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMinuit.html:43024,error,error,43024,doc/master/classTMinuit.html,https://root.cern,https://root.cern/doc/master/classTMinuit.html,1,['error'],['error']
Availability,".h. ◆ fAyInit. Double_t TSpectrum2Fit::fAyInit. protected . initial value of background ay parameter(backgroud is estimated as a0+ax*x+ay*y) ; Definition at line 92 of file TSpectrum2Fit.h. ◆ fBxCalc. Double_t TSpectrum2Fit::fBxCalc. protected . calculated value of b parameter for 1D ridges in x direction ; Definition at line 81 of file TSpectrum2Fit.h. ◆ fBxErr. Double_t TSpectrum2Fit::fBxErr. protected . error value of b parameter for 1D ridges in x direction ; Definition at line 82 of file TSpectrum2Fit.h. ◆ fBxInit. Double_t TSpectrum2Fit::fBxInit. protected . initial value of b parameter for 1D ridges in x direction (slope), for details see html manual and references ; Definition at line 80 of file TSpectrum2Fit.h. ◆ fByCalc. Double_t TSpectrum2Fit::fByCalc. protected . calculated value of b parameter for 1D ridges in y direction ; Definition at line 84 of file TSpectrum2Fit.h. ◆ fByErr. Double_t TSpectrum2Fit::fByErr. protected . error value of b parameter for 1D ridges in y direction ; Definition at line 85 of file TSpectrum2Fit.h. ◆ fByInit. Double_t TSpectrum2Fit::fByInit. protected . initial value of b parameter for 1D ridges in y direction (slope), for details see html manual and references ; Definition at line 83 of file TSpectrum2Fit.h. ◆ fChi. Double_t TSpectrum2Fit::fChi. protected . here the fitting functions return resulting chi square ; Definition at line 29 of file TSpectrum2Fit.h. ◆ fFitTaylor. Int_t TSpectrum2Fit::fFitTaylor. protected . order of Taylor expansion, possible values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi fitting function. ; Definition at line 27 of file TSpectrum2Fit.h. ◆ fFixA0. Bool_t TSpectrum2Fit::fFixA0. protected . logical value of a0 parameter, which allows to fix the parameter (not to fit). ; Definition at line 113 of file TSpectrum2Fit.h. ◆ fFixAmp. Bool_t* TSpectrum2Fit::fFixAmp. protected . [fNPeaks] array of logical values which allow to fix appropriate amplitudes of 2D peaks (not fit). How",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrum2Fit.html:82080,error,error,82080,doc/master/classTSpectrum2Fit.html,https://root.cern,https://root.cern/doc/master/classTSpectrum2Fit.html,1,['error'],['error']
Availability,".h:23; TCanvas::cdTVirtualPad * cd(Int_t subpadnumber=0) overrideSet current canvas & pad.Definition TCanvas.cxx:719; TF11-Dim function classDefinition TF1.h:233; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; TF1::Evalvirtual Double_t Eval(Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) constEvaluate this function.Definition TF1.cxx:1439; TF2A 2-Dim function with parameters.Definition TF2.h:29; TF2::GetRandom2virtual void GetRandom2(Double_t &xrandom, Double_t &yrandom, TRandom *rng=nullptr)Return 2 random numbers following this function shape.Definition TF2.cxx:547; TF2::SetNpyvirtual void SetNpy(Int_t npy=100)Set the number of points used to draw the function.Definition TF2.cxx:927; TF2::Drawvoid Draw(Option_t *option="""") overrideDraw this function with its current attributes.Definition TF2.cxx:259; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DGraphics object made of three arrays X, Y and Z with the same number of points each.Definition TGraph2D.h:41; TGraph2D::GetYDouble_t * GetY() constDefinition TGraph2D.h:124; TGraph2D::GetXDouble_t * GetX() constDefinition TGraph2D.h:123; TGraph2D::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""")Fits this graph with function with name fname Predefined functions such as gaus, expo and poln are au...Definition TGraph2D.cxx:815; TGraph2D::SetNamevoid SetName(const char *name) overrideChanges the name of this 2D graph.Definition TGraph2D.cxx:1641; TGraph2D::SetNpyvoid SetNpy(Int_t npx=40)Sets the number of bins along Y used to draw the function.Definition TGraph2D.cxx:1691; TGraph2D::SetTitlevoid SetTitle(const char *ti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ConfidenceIntervals_8C.html:5782,error,errors,5782,doc/master/ConfidenceIntervals_8C.html,https://root.cern,https://root.cern/doc/master/ConfidenceIntervals_8C.html,2,['error'],['errors']
Availability,".h:37; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; templateClassImp#define templateClassImp(name)Definition Rtypes.h:427; kPlus@ kPlusDefinition TAttMarker.h:53; TBuffer.h; operator<=Bool_t operator<=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:108; operator>Bool_t operator>(const TDatime &d1, const TDatime &d2)Definition TDatime.h:110; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; operator>=Bool_t operator>=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:112; operator<Bool_t operator<(const TDatime &d1, const TDatime &d2)Definition TDatime.h:106; TDecompLU.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; targetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMatrixT_8cxx_source.html:125173,error,error,125173,doc/master/TMatrixT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMatrixT_8cxx_source.html,1,['error'],['error']
Availability,".h:39; TApplication::ExitOnExceptionEExitOnException ExitOnException(EExitOnException opt=kExit)Set the exit on exception option.Definition TApplication.cxx:614; TApplication::KeyPressedvirtual void KeyPressed(Int_t key)Emit signal when console keyboard key was pressed.Definition TApplication.cxx:1949; TApplication::ProcessLinevirtual Longptr_t ProcessLine(const char *line, Bool_t sync=kFALSE, Int_t *error=nullptr)Process a single command line, either a C++ statement or an interpreter command starting with a ""....Definition TApplication.cxx:1565; TApplication::fgApplicationsstatic TList * fgApplicationsDefinition TApplication.h:82; TApplication::Closestatic void Close(TApplication *app)Static function used to close a remote application.Definition TApplication.cxx:2070; TApplication::HandleTermInputvirtual Bool_t HandleTermInput()Definition TApplication.h:116; TApplication::IsRunningBool_t IsRunning() constDefinition TApplication.h:152; TApplication::SetEchoModevirtual void SetEchoMode(Bool_t mode)Set console echo mode:Definition TApplication.cxx:1968; TApplication::InputFilesTObjArray * InputFiles() constDefinition TApplication.h:146; TApplication::Helpvirtual void Help(const char *line)The function lists useful commands ("".help"") or opens the online reference guide, generated with Doxy...Definition TApplication.cxx:1208; TApplication::LineProcessedvirtual void LineProcessed(const char *line)Emit signal when a line has been processed.Definition TApplication.cxx:1941; TApplication::ClearInputFilesvoid ClearInputFiles()Clear list containing macro files passed as program arguments.Definition TApplication.cxx:318; TApplication::fAppImpTApplicationImp * fAppImpDefinition TApplication.h:60; TApplication::TApplicationTApplication(const TApplication &)=delete; TApplication::EExitOnExceptionEExitOnExceptionDefinition TApplication.h:51; TApplication::kDontExit@ kDontExitDefinition TApplication.h:52; TApplication::kAbort@ kAbortDefinition TApplication.h:54; TApplication::kExit@",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8h_source.html:11184,echo,echo,11184,doc/master/TApplication_8h_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8h_source.html,1,['echo'],['echo']
Availability,".h; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualPad.h; gPad#define gPadDefinition TVirtualPad.h:308; TAxis::GetBinCentervirtual Double_t GetBinCenter(Int_t bin) constReturn center of bin.Definition TAxis.cxx:478; TAxis::GetXmaxDouble_t GetXmax() constDefinition TAxis.h:140; TAxis::GetXminDouble_t GetXmin() constDefinition TAxis.h:139; TCanvasThe Canvas class.Definition TCanvas.h:23; TComplexDefinition TComplex.h:29; TComplex::RhoDouble_t Rho() constDefinition TComplex.h:48; TH1::GetNbinsYvirtual Int_t GetNbinsY() constDefinition TH1.h:298; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::GetNbinsXvirtual Int_t GetNbinsX() constDefinition TH1.h:297; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::Drawvoid Draw(Option_t *option="""") overrideDraw this histogram with options.Definition TH1.cxx:3066; TH1::SetContourvirtual void SetContour(Int_t nlevels, const Double_t *levels=nullptr)Set the number and values of contour levels.Definition TH1.cxx:8483; TH1::SetBinsvirtual void SetBins(Int_t nx, Double_t xmin, Double_t xmax)Redefine x axis parameters.Definition TH1.cxx:8767; TH1::SetStatsvirtual void SetStats(Bool_t stats=kTRUE)Set statistics option on/off.Definition TH1.cxx:8990; TH2F2-D histogram with a float per channel (see TH1 documentation)Definition TH2.h:307; TH2F::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:3972; TH2::FillInt_t Fill(Double_t) overrideInvalid Fill method.Definition TH2.cxx:393; TStyle::SetPadGridXvoid SetPadGridX(Bool_t gridx)Definition TStyle.h:362; TStyle::SetPadGridYvoid SetPadGridY(Bool_t gridy)Definition TStyle.h:363; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; AuthorLuigi Bardelli barde.nosp@m.lli@.nosp@m.fi.in.nosp@m.fn.i.nosp@m.t ; Definition in file mandelbrot.C. tutorialsgraphicsmandelbrot.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:29 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/mandelbrot_8C.html:4628,error,errors,4628,doc/master/mandelbrot_8C.html,https://root.cern,https://root.cern/doc/master/mandelbrot_8C.html,1,['error'],['errors']
Availability,.h;  ► matrix;  main.cpp;  ► polarcoord;  main.cpp;  ► smatrix;  matrix_op_vec.h;  matrix_util.h;  testKalman.cxx;  testOperations.cxx;  TestTimer.h;  tsc.h;  ► include;  ► Vc;  ► avx;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  sorthelper.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  writemaskedvector.h;  ► common;  aliasingentryhelper.h;  bitscanintrinsics.h;  deinterleave.h;  exponential.h;  fix_clang_emmintrin.h;  iif.h;  interleavedmemory.h;  logarithm.h;  macros.h;  memory.h;  memorybase.h;  memoryfwd.h;  operand.h;  operators.h;  storage.h;  support.h;  trigonometric.h;  types.h;  undomacros.h;  vectortuple.h;  windows_fix_intrin.h;  ► internal;  namespace.h;  ► scalar;  helperimpl.h;  limits.h;  macros.h;  mask.h;  math.h;  types.h;  undomacros.h;  vector.h;  writemaskedvector.h;  ► sse;  casts.h;  const.h;  const_data.h;  debug.h;  helperimpl.h;  intrinsics.h;  limits.h;  macros.h;  mask.h;  math.h;  shuffle.h;  types.h;  undomacros.h;  vector.h;  vectorhelper.h;  cpuid.h;  global.h;  support.h;  vector.h;  version.h;  ► src;  avx_sorthelper.cpp;  const.cpp;  cpuid.cpp;  support.cpp;  trigonometric.cpp;  ► tests;  arithmetics.cpp;  casts.cpp;  const.h;  convert-sincos-reference.cpp;  deinterleave.cpp;  expandandmerge.cpp;  gather.cpp;  implicit_type_conversion.cpp;  implicit_type_conversion_failures.cpp;  linkTest0.cpp;  linkTest1.cpp;  linkTestLib0.cpp;  linkTestLib1.cpp;  linkTestLib2.cpp;  linkTestLib3.cpp;  load.cpp;  mask.cpp;  math.cpp;  memory.cpp;  scalaraccess.cpp;  scatter.cpp;  sse_blend.cpp;  stlcontainer.cpp;  store.cpp;  supportfunctions.cpp;  swizzles.cpp;  ulp.h;  unittest.h;  utils.cpp;  vectormemoryhelper.h;  makeTest.py;  ► vdt;  ► include;  ► vdt;  asin.h;  atan.h;  atan2.h;  cos.h;  exp.h;  inv.h;  log.h;  sin.h;  sincos.h;  sqrt.h;  tan.h;  vdtcore_common.h;  vdtMath.h;  ► tests;  stressVdt.cxx;  ► misc;  ► memstat;  ► inc;  LinkDef.h;  TMemSt,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/files.html:58921,mask,mask,58921,root/html606/files.html,https://root.cern,https://root.cern/root/html606/files.html,2,['mask'],['mask']
Availability,".hxx:100; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBufferFile.h; TBufferText.h; TClassEdit.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h offsetDefinition TGWin32VirtualXProxy.cxx:245; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:206484,error,error,206484,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['error'],['error']
Availability,".hxx>. Inheritance diagram for ROOT::RDataFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ColumnNames_t. using ROOT::RDataFrame::ColumnNames_t = ROOT::RDF::ColumnNames_t. Definition at line 43 of file RDataFrame.hxx. Constructor & Destructor Documentation. ◆ RDataFrame() [1/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treeName, . std::string_view ; fileNameGlob, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]filenameglobTDirectory where the tree is stored, e.g. a TFile. ; [in]defaultColumnsCollection of default columns. The filename glob supports the same type of expressions as TChain::Add(), and it is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1591 of file RDataFrame.cxx. ◆ RDataFrame() [2/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; datasetName, . const std::vector< std::string > & ; fileNameGlobs, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]fileglobsCollection of file names of filename globs ; [in]defaultColumnsCollection of default columns. The filename globs support the same type of expressions as TChain::Add(), and each glob is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1615 of file RDataFrame.cxx. ◆ RDataFrame() [3/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treename, . std::initializer_list< std::string > ; filenames, . const C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:106992,avail,available,106992,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,1,['avail'],['available']
Availability,".hxx>. Inheritance diagram for ROOT::RDataFrame:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ ColumnNames_t. using ROOT::RDataFrame::ColumnNames_t = ROOT::RDF::ColumnNames_t. Definition at line 43 of file RDataFrame.hxx. Constructor & Destructor Documentation. ◆ RDataFrame() [1/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treeName, . std::string_view ; fileNameGlob, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]filenameglobTDirectory where the tree is stored, e.g. a TFile. ; [in]defaultColumnsCollection of default columns. The filename glob supports the same type of expressions as TChain::Add(), and it is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1768 of file RDataFrame.cxx. ◆ RDataFrame() [2/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; datasetName, . const std::vector< std::string > & ; fileNameGlobs, . const ColumnNames_t & ; defaultColumns = {} . ). Build the dataframe. ; Parameters. [in]treeNameName of the tree contained in the directory ; [in]fileglobsCollection of file names of filename globs ; [in]defaultColumnsCollection of default columns. The filename globs support the same type of expressions as TChain::Add(), and each glob is passed as-is to TChain's constructor.; The default columns are looked at in case no column is specified in the booking of actions or transformations. See alsoROOT::RDF::RInterface for the documentation of the methods available. ; Definition at line 1792 of file RDataFrame.cxx. ◆ RDataFrame() [3/10]. ROOT::RDataFrame::RDataFrame ; (; std::string_view ; treename, . std::initializer_list< std::string > ; filenames, . const C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDataFrame.html:114359,avail,available,114359,doc/master/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDataFrame.html,1,['avail'],['available']
Availability,".mm. ◆ ChangeProperty(). void TGCocoa::ChangeProperty ; (; Window_t ; id, . Atom_t ; property, . Atom_t ; type, . UChar_t * ; data, . Int_t ; len . ). overridevirtual . Alters the property for the specified window and causes the X server to generate a PropertyNotify event on that window. ; Parameters. [in]idthe window whose property you want to change ; [in]propertyspecifies the property name ; [in]typethe type of the property; the X server does not interpret the type but simply passes it back to an application that might ask about the window properties ; [in]datathe property data ; [in]lenthe length of the specified data format . Reimplemented from TVirtualX.; Definition at line 3816 of file TGCocoa.mm. ◆ ChangeWindowAttributes(). void TGCocoa::ChangeWindowAttributes ; (; Window_t ; id, . SetWindowAttributes_t * ; attr . ). overridevirtual . Changes the attributes of the specified window ""id"" according the values provided in ""attr"". ; The mask data member of ""attr"" specifies which window attributes are defined in the attributes argument. This mask is the bitwise inclusive OR of the valid attribute mask bits; if it is zero, the attributes are ignored. ; Reimplemented from TVirtualX.; Definition at line 1006 of file TGCocoa.mm. ◆ CheckEvent(). Bool_t TGCocoa::CheckEvent ; (; Window_t ; id, . EGEventType ; type, . Event_t & ; ev . ). overridevirtual . Check if there is for window ""id"" an event of type ""type"". ; If there is it fills in the event structure and return true. If no such event return false. ; Reimplemented from TVirtualX.; Definition at line 3547 of file TGCocoa.mm. ◆ Class(). static TClass * TGCocoa::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGCocoa::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TGCocoa::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 476 of file TGCocoa.h. ◆ ClearArea(). void TGCocoa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:56188,mask,mask,56188,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability,".py File ReferenceTutorials » RooFit Tutorials. Detailed Description; 'LIKELIHOOD AND MINIMIZATION' RooFit tutorial macro #601 ; Interactive minimization with MINUIT. ; ; import ROOT; ; ; # Setup pdf and likelihood; # -----------------------------------------------; ; # Observable; x = ROOT.RooRealVar(""x"", ""x"", -20, 20); ; # Model (intentional strong correlations); mean = ROOT.RooRealVar(""mean"", ""mean of g1 and g2"", 0); sigma_g1 = ROOT.RooRealVar(""sigma_g1"", ""width of g1"", 3); g1 = ROOT.RooGaussian(""g1"", ""g1"", x, mean, sigma_g1); ; sigma_g2 = ROOT.RooRealVar(""sigma_g2"", ""width of g2"", 4, 3.0, 6.0); g2 = ROOT.RooGaussian(""g2"", ""g2"", x, mean, sigma_g2); ; frac = ROOT.RooRealVar(""frac"", ""frac"", 0.5, 0.0, 1.0); model = ROOT.RooAddPdf(""model"", ""model"", [g1, g2], [frac]); ; # Generate 1000 events; data = model.generate({x}, 1000); ; # Construct unbinned likelihood of model w.r.t. data; nll = model.createNLL(data); ; # Interactive minimization, error analysis; # -------------------------------------------------------------------------------; ; # Create MINUIT interface object; m = ROOT.RooMinimizer(nll); ; # Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(True); ; # Call MIGRAD to minimize the likelihood; m.migrad(); ; # Print values of all parameters, reflect values (and error estimates); # that are back propagated from MINUIT; model.getParameters({x}).Print(""s""); ; # Disable verbose logging; m.setVerbose(False); ; # Run HESSE to calculate errors from d2L/dp2; m.hesse(); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Run MINOS on sigma_g2 parameter only; m.minos({sigma_g2}); ; # Print value (and error) of sigma_g2 parameter, reflects; # value and error back propagated from MINUIT; sigma_g2.Print(); ; # Saving results, contour plots; # ---------------------------------------------------------; ; # Save a snapshot of the fit result. ROOT.This object contains the initi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8py.html:1121,error,error,1121,doc/master/rf601__intminuit_8py.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8py.html,1,['error'],['error']
Availability,".reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }; 813 lnk = next;; 814 }; 815}; 816 ; 817////////////////////////////////////////////////////////////////////////////////; 818/// Remove object from the list.; 819 ; 820TObject *TList::Remove(TObject *obj); 821{; 822 R__COLLECTION_WRITE_GUARD();; 823 ; 824 if (!obj) return nullptr;; 825 ; 826 Int_t idx;; 827 TObjLink *lnk = FindLink(obj, idx);; 828 ; 829 if (!lnk) return nullptr;; 830 ; 831 // return object found, which may be (pointer wise) different than the; 832 // input object (depending on what IsEqual() is doing); 833 ; 834 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 835 ; 836 TObject *ob = lnk->GetObject();; 837 lnk->SetObject(nullptr);; 838 if (lnk == fFirst.get()) {; 839 fFirst = lnk->fNext;; 840 // lnk is still alive as we have either fLast; 841 // or the 'new' fFirst->fPrev pointing to it.; 842 if (lnk == fLast.get()) {; 843 fLast.reset();; 844 fFirst.reset();; 845 } else; 846 fFirst->fPrev.reset();; 847 //DeleteLink(lnk);; 848 } else if (lnk == fLast.get()) {; 849 fLast = lnk->fPrev.lock();; 850 fLast->fNext.reset();; 851 //DeleteLink(lnk);; 852 } else {; 853 lnk->Next()->fPrev = lnk->fPrev;; 854 lnk->Prev()->fNext = lnk->fNext;; 855 //DeleteLink(lnk);; 856 }; 857 fSize--;; 858 fCache.reset();; 859 Changed();; 860 ; 861 return ob;; 862}; 863 ; 864////////////////////////////////////////////////////////////////////////////////; 865/// Remove object link (and therefore the object it contains); 866/// from the list.; 867 ; 868TObject *TList::Remove(TObjLink *lnk); 869{; 870 R__COLLECTION_WRITE_GUARD();; 871 ; 872 if (!lnk) return nullptr;; 873 ; 874 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 875 ; 876 TObject *obj = lnk->GetObject();; 877 lnk->SetObject(nullptr);; 878 if (lnk == fFirst.get()) {; 87",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:25564,alive,alive,25564,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['alive'],['alive']
Availability,".root"",""recreate"");; TTree *T = new TTree(""T"",""title"");; T->Fill(); // Loop; file = T->GetCurrentFile(); // To get the pointer to the current file; file->Write();; file->Close();. NoteThis method is never called if the input file is a TMemFile or derivate. ; Definition at line 2749 of file TTree.cxx. ◆ CheckBranchAddressType(). Int_t TTree::CheckBranchAddressType ; (; TBranch * ; branch, . TClass * ; ptrClass, . EDataType ; datatype, . bool ; isptr . ). protectedvirtual . Check whether or not the address described by the last 3 parameters matches the content of the branch. ; If a Data Model Evolution conversion is involved, reset the fInfo of the branch. The return values are:; kMissingBranch (-5) : Missing branch; kInternalError (-4) : Internal error (could not find the type corresponding to a data type number); kMissingCompiledCollectionProxy (-3) : Missing compiled collection proxy for a compiled collection; kMismatch (-2) : Non-Class Pointer type given does not match the type expected by the branch; kClassMismatch (-1) : Class Pointer type given does not match the type expected by the branch; kMatch (0) : perfect match; kMatchConversion (1) : match with (I/O) conversion; kMatchConversionCollection (2) : match with (I/O) conversion of the content of a collection; kMakeClass (3) : MakeClass mode so we can not check.; kVoidPtr (4) : void* passed so no check was made.; kNoCheck (5) : Underlying TBranch not yet available so no check was made. In addition this can be multiplexed with the two bits:; kNeedEnableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to be in Decomposed Object (aka MakeClass) mode.; kNeedDisableDecomposedObj : in order for the address (type) to be 'usable' the branch needs to not be in Decomposed Object (aka MakeClass) mode. This bits can be masked out by using kDecomposedObjMask . Definition at line 2867 of file TTree.cxx. ◆ Class(). static TClass * TTree::Class ; (; ). static . ReturnsTClass describing this class",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:102024,error,error,102024,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['error'],['error']
Availability,".size() ?; 2514 fr.covarianceMatrix() :; 2515 fr.reducedCovarianceMatrix(paramList)) ;; 2516 ; 2517 for (std::size_t ivar=0 ; ivar<paramList.size() ; ivar++) {; 2518 ; 2519 auto& rrv = static_cast<RooRealVar&>(paramList[ivar]);; 2520 ; 2521 double cenVal = rrv.getVal() ;; 2522 double errVal = sqrt(V(ivar,ivar)) ;; 2523 ; 2524 // Make Plus variation; 2525 rrv.setVal(cenVal+errVal) ;; 2526 plusVar.push_back(getVal(nset)) ;; 2527 ; 2528 // Make Minus variation; 2529 rrv.setVal(cenVal-errVal) ;; 2530 minusVar.push_back(getVal(nset)) ;; 2531 ; 2532 rrv.setVal(cenVal) ;; 2533 }; 2534 ; 2535 // Re-evaluate this RooAbsReal with the central parameters just to be; 2536 // extra-safe that a call to `getPropagatedError()` doesn't change any state.; 2537 // It should not be necessary because thanks to the dirty flag propagation; 2538 // the RooAbsReal is re-evaluated anyway the next time getVal() is called.; 2539 // Still there are imaginable corner cases where it would not be triggered,; 2540 // for example if the user changes the RooFit operation more after the error; 2541 // propagation.; 2542 getVal(nset);; 2543 ; 2544 TMatrixDSym C(paramList.size()) ;; 2545 std::vector<double> errVec(paramList.size()) ;; 2546 for (std::size_t i=0 ; i<paramList.size() ; i++) {; 2547 errVec[i] = std::sqrt(V(i,i)) ;; 2548 for (std::size_t j=i ; j<paramList.size() ; j++) {; 2549 C(i,j) = V(i,j) / std::sqrt(V(i,i)*V(j,j));; 2550 C(j,i) = C(i,j) ;; 2551 }; 2552 }; 2553 ; 2554 // Make std::vector of variations; 2555 TVectorD F(plusVar.size()) ;; 2556 for (std::size_t j=0 ; j<plusVar.size() ; j++) {; 2557 F[j] = (plusVar[j]-minusVar[j]) * 0.5;; 2558 }; 2559 ; 2560 // Calculate error in linear approximation from variations and correlation coefficient; 2561 double sum = F*(C*F) ;; 2562 ; 2563 return sqrt(sum) ;; 2564}; 2565 ; 2566 ; 2567 ; 2568////////////////////////////////////////////////////////////////////////////////; 2569/// Plot function or PDF on frame with support for visualization of the un",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:111527,error,error,111527,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,".so, .sl, .dl and then .a (for AIX). ; Reimplemented from TSystem.; Definition at line 4761 of file TUnixSystem.cxx. ◆ FindFile(). const char * TUnixSystem::FindFile ; (; const char * ; search, . TString & ; wfil, . EAccessMode ; mode = kFileExists . ). overridevirtual . Find location of file ""wfil"" in a search path. ; The search path is specified as a : separated list of directories. Return value is pointing to wfile for compatibility with Which(const char*,const char*,EAccessMode) version. ; Reimplemented from TSystem.; Definition at line 1927 of file TUnixSystem.cxx. ◆ FreeDirectory(). void TUnixSystem::FreeDirectory ; (; void * ; dirp). overridevirtual . Close a Unix file system directory. ; Reimplemented from TSystem.; Definition at line 1404 of file TUnixSystem.cxx. ◆ GetCpuInfo(). int TUnixSystem::GetCpuInfo ; (; CpuInfo_t * ; info, . Int_t ; sampleTime = 1000 . ); const. overridevirtual . Returns cpu load average and load info into the CpuInfo_t structure. ; Returns -1 in case of error, 0 otherwise. Use sampleTime to set the interval over which the CPU load will be measured, in ms (default 1000). ; Reimplemented from TSystem.; Definition at line 5344 of file TUnixSystem.cxx. ◆ GetCryptoRandom(). Int_t TUnixSystem::GetCryptoRandom ; (; void * ; buf, . Int_t ; len . ). overridevirtual . Return cryptographic random number Fill provided buffer with random values Returns number of bytes written to buffer or -1 in case of error. ; Reimplemented from TSystem.; Definition at line 740 of file TUnixSystem.cxx. ◆ GetDirEntry(). const char * TUnixSystem::GetDirEntry ; (; void * ; dirp). overridevirtual . Get next Unix file system directory entry. Returns 0 if no more entries. ; Reimplemented from TSystem.; Definition at line 1419 of file TUnixSystem.cxx. ◆ GetDynamicPath(). const char * TUnixSystem::GetDynamicPath ; (; ). overridevirtual . Return the dynamic path (used to find shared libraries). ; Reimplemented from TSystem.; Definition at line 4738 of file TUnixSystem.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnixSystem.html:48165,error,error,48165,doc/master/classTUnixSystem.html,https://root.cern,https://root.cern/doc/master/classTUnixSystem.html,1,['error'],['error']
Availability,"/ (c1sq * c1sq);; 2938 }; 2939 }; 2940 ResetStats();; 2941 return kTRUE;; 2942}; 2943 ; 2944////////////////////////////////////////////////////////////////////////////////; 2945/// Replace contents of this histogram by the division of h1 by h2.; 2946///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:117329,error,errors,117329,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"/ call, or the class is interpreted and we will call the default; 5333 // constructor that way, or no default constructor is available and; 5334 // we fail.; 5335 {; 5336 TClass__GetCallingNewRAII callingNew(defConstructor);; 5337 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5338 }; 5339 if (!p) {; 5340 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5341 }; 5342 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5343 // There is no dictionary at all, so this is an emulated; 5344 // class; however we do have the services of a collection proxy,; 5345 // so this is an emulated STL class.; 5346 {; 5347 TClass__GetCallingNewRAII callingNew(defConstructor);; 5348 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5349 }; 5350 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5351 // There is no dictionary at all and we do not have; 5352 // the services of a collection proxy available, so; 5353 // use the streamer info to approximate calling a; 5354 // constructor (basically we just make sure that the; 5355 // pointer data members are null, unless they are marked; 5356 // as preallocated with the ""->"" comment, in which case; 5357 // we default-construct an object to point at).; 5358 ; 5359 // ???BUG??? ???WHY???; 5360 // Do not register any TObject's that we create; 5361 // as a result of creating this object.; 5362 Bool_t statsave = GetObjectStat();; 5363 if(statsave) {; 5364 SetObjectStat(kFALSE);; 5365 }; 5366 ; 5367 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5368 if (!sinfo) {; 5369 Error(""NewArray with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5370 return nullptr;; 5371 }; 5372 ; 5373 {; 5374 TClass__GetCallingNewRAII callingNew(defConstructor);; 5375 p = { sinfo->NewArray(nElements, arena), sinfo };; 5376 }; 5377 ; 5378 // ???BUG???; 5379 // Allow TObject's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:204796,avail,available,204796,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"/ call, or the class is interpreted and we will call the default; 5400 // constructor that way, or no default constructor is available and; 5401 // we fail.; 5402 {; 5403 TClass__GetCallingNewRAII callingNew(defConstructor);; 5404 p = gCling->ClassInfo_New(GetClassInfo(),nElements, arena);; 5405 }; 5406 if (!p) {; 5407 Error(""NewArray with placement"", ""cannot create object of class %s version %d at address %p"", GetName(), fClassVersion, arena);; 5408 }; 5409 } else if (!HasInterpreterInfo() && fCollectionProxy) {; 5410 // There is no dictionary at all, so this is an emulated; 5411 // class; however we do have the services of a collection proxy,; 5412 // so this is an emulated STL class.; 5413 {; 5414 TClass__GetCallingNewRAII callingNew(defConstructor);; 5415 p = fCollectionProxy->NewObjectArray(nElements, arena);; 5416 }; 5417 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5418 // There is no dictionary at all and we do not have; 5419 // the services of a collection proxy available, so; 5420 // use the streamer info to approximate calling a; 5421 // constructor (basically we just make sure that the; 5422 // pointer data members are null, unless they are marked; 5423 // as preallocated with the ""->"" comment, in which case; 5424 // we default-construct an object to point at).; 5425 ; 5426 // ???BUG??? ???WHY???; 5427 // Do not register any TObject's that we create; 5428 // as a result of creating this object.; 5429 Bool_t statsave = GetObjectStat();; 5430 if(statsave) {; 5431 SetObjectStat(kFALSE);; 5432 }; 5433 ; 5434 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5435 if (!sinfo) {; 5436 Error(""NewArray with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5437 return nullptr;; 5438 }; 5439 ; 5440 {; 5441 TClass__GetCallingNewRAII callingNew(defConstructor);; 5442 p = { sinfo->NewArray(nElements, arena), sinfo };; 5443 }; 5444 ; 5445 // ???BUG???; 5446 // Allow TObject's",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:207547,avail,available,207547,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"/ debug printout; 865 if (opt.Contains(""D"")) {; 866 printf("" Kolmogorov Probability = %g, Max Dist = %g\n"",prob,rdmax);; 867 }; 868 if(opt.Contains(""M"")) return rdmax;; 869 else return prob;; 870}; 871 ; 872 ; 873////////////////////////////////////////////////////////////////////////////////; 874/// Computation of Voigt function (normalised).; 875/// Voigt is a convolution of the two functions:; 876/// \f[; 877/// gauss(xx) = \frac{1}{(\sqrt{2\pi} sigma)} e^{\frac{xx^{2}}{(2 sigma{^2})}}; 878/// \f]; 879/// and; 880/// \f[; 881/// lorentz(xx) = \frac{ \frac{1}{\pi} \frac{lg}{2} }{ (xx^{2} + \frac{lg^{2}}{4}) }; 882/// \f]; 883/// \.; 884///; 885/// The Voigt function is known to be the real part of Faddeeva function also; 886/// called complex error function [2].; 887///; 888/// The algorithm was developed by J. Humlicek [1].; 889/// This code is based on fortran code presented by R. J. Wells [2].; 890/// Translated and adapted by Miha D. Puc; 891///; 892/// To calculate the Faddeeva function with relative error less than 10^(-r).; 893/// r can be set by the user subject to the constraints 2 <= r <= 5.; 894///; 895/// - [1] J. Humlicek, JQSRT, 21, 437 (1982).; 896/// - [2] [R.J. Wells ""Rapid Approximation to the Voigt/Faddeeva Function and its Derivatives"" JQSRT 62 (1999), pp 29-48.](http://www-atm.physics.ox.ac.uk/user/wells/voigt.html); 897 ; 898Double_t TMath::Voigt(Double_t xx, Double_t sigma, Double_t lg, Int_t r); 899{; 900 if ((sigma < 0 || lg < 0) || (sigma==0 && lg==0)) {; 901 return 0; // Not meant to be for those who want to be thinner than 0; 902 }; 903 ; 904 if (sigma == 0) {; 905 return lg * 0.159154943 / (xx*xx + lg*lg /4); //pure Lorentz; 906 }; 907 ; 908 if (lg == 0) { //pure gauss; 909 return 0.39894228 / sigma * TMath::Exp(-xx*xx / (2*sigma*sigma));; 910 }; 911 ; 912 Double_t x, y, k;; 913 x = xx / sigma / 1.41421356;; 914 y = lg / 2 / sigma / 1.41421356;; 915 ; 916 Double_t r0, r1;; 917 ; 918 if (r < 2) r = 2;; 919 if (r > 5) r = 5;; 920 ; 921 r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:29474,error,error,29474,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,"/ don't duplicate the horizontal line; 6538 if (Hoption.Hist != 2) {; 6539 if (yi1<ymax && yi1>ymin) {; 6540 if (xi1 < xi3 - s2x) gPad->PaintLine(xi1,yi1,xi3 - s2x,yi2);; 6541 if (xi3 + s2x < xi2) gPad->PaintLine(xi3 + s2x,yi1,xi2,yi2);; 6542 }; 6543 }; 6544 }; 6545 if (optionE && !drawmarker && (ey1 != 0 || ey2 !=0)) {; 6546 if ((yi3 < yi1) && (yi3 < ymax)) gPad->PaintLine(xi3,yi3,xi4,TMath::Min(yi1,ymax));; 6547 if ((yi1 < yi4) && (yi4 > ymin)) gPad->PaintLine(xi3,TMath::Max(yi1,ymin),xi4,yi4);; 6548 // don't duplicate the horizontal line; 6549 if (Hoption.Hist != 2) {; 6550 if (yi1<ymax && yi1>ymin) {; 6551 if (xi1 < xi3) gPad->PaintLine(xi1,yi1,xi3,yi2);; 6552 if (xi3 < xi2) gPad->PaintLine(xi3,yi1,xi2,yi2);; 6553 }; 6554 }; 6555 }; 6556 ; 6557 // draw line at the end of the error bars; 6558 ; 6559 if (option1 && drawmarker) {; 6560 ; 6561 if (yi3 < yi1-s2y && yi3 < ymax && yi3 > ymin) gPad->PaintLine(xi3 - bxsize, yi3 , xi3 + bxsize, yi3);; 6562 if (yi4 > yi1+s2y && yi4 < ymax && yi4 > ymin) gPad->PaintLine(xi3 - bxsize, yi4 , xi3 + bxsize, yi4);; 6563 if (yi1 <= ymax && yi1 >= ymin) {; 6564 if (xi1 < xi3-s2x) gPad->PaintLine(xi1 , yi1 - bysize, xi1 , yi1 + bysize);; 6565 if (xi2 > xi3+s2x) gPad->PaintLine(xi2 , yi1 - bysize, xi2 , yi1 + bysize);; 6566 }; 6567 }; 6568 ; 6569 // draw the marker; 6570 ; 6571 if (drawmarker) gPad->PaintPolyMarker(1, &xi3, &yi1);; 6572 ; 6573L30:; 6574 if (fixbin) xp += Hparam.xbinsize;; 6575 else {; 6576 if (k < last) {; 6577 delta = fH->GetBinWidth(k+1);; 6578 xp = fH->GetBinLowEdge(k+1) + 0.5*delta;; 6579 }; 6580 }; 6581 } //end of for loop; 6582 ; 6583 // draw the filled area; 6584 ; 6585 if (option3) {; 6586 TGraph graph;; 6587 graph.SetLineStyle(fH->GetLineStyle());; 6588 graph.SetLineColor(fH->GetLineColor());; 6589 graph.SetLineWidth(fH->GetLineWidth());; 6590 graph.SetFillStyle(fH->GetFillStyle());; 6591 graph.SetFillColor(fH->GetFillColor());; 6592 Int_t logx = gPad->GetLogx();; 6593 Int_t logy = gPad->GetLogy();; 6594 gP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:240602,error,error,240602,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['error']
Availability,"/ error handling; 322/// `start` defines the start symbol defined in PyRun_String (Py_eval_input,; 323/// Py_single_input, Py_file_input); 324 ; 325void PyMethodBase::PyRunString(TString code, TString errorMessage, int start) {; 326 //std::cout << ""Run: >> "" << code << std::endl;; 327 fPyReturn = PyRun_String(code, start, fGlobalNS, fLocalNS);; 328 if (!fPyReturn) {; 329 Log() << kWARNING << ""Failed to run python code: "" << code << Endl;; 330 Log() << kWARNING << ""Python error message:"" << Endl;; 331 PyErr_Print();; 332 Log() << kFATAL << errorMessage << Endl;; 333 }; 334}; 335 ; 336///////////////////////////////////////////////////////////////////////////////; 337/// Execute Python code from string; 338///; 339/// \param[in] code Python code as string; 340/// \param[in] globalNS Global Namespace for Python Session; 341/// \param[in] localNS Local Namespace for Python Session; 342///; 343/// Overloaded static Helper function to run python code; 344/// from string and throw runtime error if the Python session; 345/// is unable to execute the code; 346 ; 347void PyMethodBase::PyRunString(TString code, PyObject *globalNS, PyObject *localNS){; 348 PyObject *fPyReturn = PyRun_String(code, Py_single_input, globalNS, localNS);; 349 if (!fPyReturn) {; 350 std::cout<<""\nPython error message:\n"";; 351 PyErr_Print();; 352 throw std::runtime_error(""\nFailed to run python code: ""+code);; 353 }; 354}; 355 ; 356///////////////////////////////////////////////////////////////////////////////; 357/// Returns `const char*` from Python string in PyObject; 358///; 359/// \param[in] string Python String object; 360/// \return String representation in `const char*`; 361 ; 362const char* PyMethodBase::PyStringAsString(PyObject* string){; 363 PyObject* encodedString = PyUnicode_AsUTF8String(string);; 364 const char* cstring = PyBytes_AsString(encodedString);; 365 return cstring;; 366}; 367 ; 368//////////////////////////////////////////////////////////////////////////////////; 369/// \brie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PyMethodBase_8cxx_source.html:11955,error,error,11955,doc/master/PyMethodBase_8cxx_source.html,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html,1,['error'],['error']
Availability,"/ file size.; 4599///; 4600/// \note This method calls `TTree::ChangeFile` when the tree reaches a size; 4601/// greater than `TTree::fgMaxTreeSize`. This doesn't happen if the tree is; 4602/// attached to a `TMemFile` or derivate.; 4603 ; 4604Int_t TTree::Fill(); 4605{; 4606 Int_t nbytes = 0;; 4607 Int_t nwrite = 0;; 4608 Int_t nerror = 0;; 4609 Int_t nbranches = fBranches.GetEntriesFast();; 4610 ; 4611 // Case of one single super branch. Automatically update; 4612 // all the branch addresses if a new object was created.; 4613 if (nbranches == 1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld\n""; 4644 "" This error is symptomatic of a Tree created as a memory-resident Tree\n""; 4645 "" Instead of doing:\n""; 4646 "" TTree *T = new TTree(...)\n""; 4647 "" TFile *f = new TFile(...)\n""; 4648 "" you should do:\n""; 4649 "" TFile *f = new TFile(...)\n""; 4650 "" TTree *T = new TTree(...)\n\n"",; 4651 GetName(), branch->GetName(), nwrite, fEntries + 1);; 4652 } else {; 4653 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld"", GetName(), branch->GetName(), nwrite,; 4654 fEntries + 1);; 4655 }; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:187965,error,error,187965,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"/ histogram does not belong to any directory.; 8932///; 8933/// Note that the directory is not a real property of the histogram and; 8934/// it will not be copied when the histogram is copied or cloned.; 8935/// If the user wants to have the copied (cloned) histogram in the same; 8936/// directory, he needs to set again the directory using SetDirectory to the; 8937/// copied histograms; 8938 ; 8939void TH1::SetDirectory(TDirectory *dir); 8940{; 8941 if (fDirectory == dir) return;; 8942 if (fDirectory) fDirectory->Remove(this);; 8943 fDirectory = dir;; 8944 if (fDirectory) {; 8945 fFunctions->UseRWLock();; 8946 fDirectory->Append(this);; 8947 }; 8948}; 8949 ; 8950////////////////////////////////////////////////////////////////////////////////; 8951/// Replace bin errors by values in array error.; 8952 ; 8953void TH1::SetError(const Double_t *error); 8954{; 8955 for (Int_t i = 0; i < fNcells; ++i) SetBinError(i, error[i]);; 8956}; 8957 ; 8958////////////////////////////////////////////////////////////////////////////////; 8959/// Change the name of this histogram; 8960///; 8961 ; 8962void TH1::SetName(const char *name); 8963{; 8964 // Histograms are named objects in a THashList.; 8965 // We must update the hashlist if we change the name; 8966 // We protect this operation; 8967 R__LOCKGUARD(gROOTMutex);; 8968 if (fDirectory) fDirectory->Remove(this);; 8969 fName = name;; 8970 if (fDirectory) fDirectory->Append(this);; 8971}; 8972 ; 8973////////////////////////////////////////////////////////////////////////////////; 8974/// Change the name and title of this histogram; 8975 ; 8976void TH1::SetNameTitle(const char *name, const char *title); 8977{; 8978 // Histograms are named objects in a THashList.; 8979 // We must update the hashlist if we change the name; 8980 SetName(name);; 8981 SetTitle(title);; 8982}; 8983 ; 8984////////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:349627,error,error,349627,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['error']
Availability,"/ setup; 614 if (!Initialize()); 615 return kFALSE;; 616 ; 617 PyGILRAII gilRaii;; 618 ; 619 // direct pointer comparison of type member; 620 return CPyCppyy::Overload_CheckExact(pyobject);; 621}; 622 ; 623////////////////////////////////////////////////////////////////////////////////; 624/// Extract the object pointer held by the CPPInstance pyobject.; 625 ; 626void *TPython::CPPInstance_AsVoidPtr(PyObject *pyobject); 627{; 628 // setup; 629 if (!Initialize()); 630 return 0;; 631 ; 632 PyGILRAII gilRaii;; 633 ; 634 // get held object (may be null); 635 return CPyCppyy::Instance_AsVoidPtr(pyobject);; 636}; 637 ; 638////////////////////////////////////////////////////////////////////////////////; 639/// Bind the addr to a python object of class defined by classname.; 640 ; 641PyObject *TPython::CPPInstance_FromVoidPtr(void *addr, const char *classname, Bool_t python_owns); 642{; 643 // setup; 644 if (!Initialize()); 645 return 0;; 646 ; 647 PyGILRAII gilRaii;; 648 ; 649 // perform cast (the call will check TClass and addr, and set python errors); 650 // give ownership, for ref-counting, to the python side, if so requested; 651 return CPyCppyy::Instance_FromVoidPtr(addr, classname, python_owns);; 652}; API.h; PyBytes_Check#define PyBytes_CheckDefinition CPyCppyy.h:61; PyObject_object PyObjectDefinition PyMethodBase.h:43; Riostream.h; Bool_tbool Bool_tDefinition RtypesCore.h:63; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClassRef.h; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:21242,error,errors,21242,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['error'],['errors']
Availability,"/ the function to be used in `while (reader.Next()) { ... }`; 216 bool Next() {; 217 return SetEntry(GetCurrentEntry() + 1) == kEntryValid;; 218 }; 219 ; 220 /// Set the next entry (or index of the TEntryList if that is set).; 221 ///; 222 /// \param entry If not TEntryList is set, the entry is a global entry (i.e.; 223 /// not the entry number local to the chain's current tree).; 224 /// \returns the `entry`'s read status, i.e. whether the entry is available.; 225 EEntryStatus SetEntry(Long64_t entry) { return SetEntryBase(entry, false); }; 226 ; 227 /// Set the next local tree entry. If a TEntryList is set, this function is; 228 /// equivalent to `SetEntry()`.; 229 ///; 230 /// \param entry Entry number of the TChain's current TTree. This is the; 231 /// entry number passed for instance by `TSelector::Process(entry)`, i.e.; 232 /// within `TSelector::Process()` always use `SetLocalEntry()` and not; 233 /// `SetEntry()`!; 234 /// \return the `entry`'s read status, i.e. whether the entry is available.; 235 EEntryStatus SetLocalEntry(Long64_t entry) { return SetEntryBase(entry, true); }; 236 ; 237 EEntryStatus SetEntriesRange(Long64_t beginEntry, Long64_t endEntry);; 238 ; 239 /// Get the begin and end entry numbers; 240 ///; 241 /// \return a pair contained the begin and end entry numbers.; 242 std::pair<Long64_t, Long64_t> GetEntriesRange() const { return std::make_pair(fBeginEntry, fEndEntry); }; 243 ; 244 /// Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set).; 245 void Restart();; 246 ; 247 ///\}; 248 ; 249 EEntryStatus GetEntryStatus() const { return fEntryStatus; }; 250 ; 251 Long64_t GetEntries() const;; 252 Long64_t GetEntries(bool force);; 253 ; 254 /// Returns the index of the current entry being read.; 255 ///; 256 /// If `IsChain()`, the returned index corresponds to the global entry number; 257 /// (i.e. not the entry number local to the chain's current tree).; 258 /// If `fEntryList`, the returned index corresponds to an in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:9208,avail,available,9208,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['avail'],['available']
Availability,"/"");; 1845 if (s) {; 1846 comment = 0;; 1847 s += 2;; 1848 ; 1849 while (s && (*s == ' ' || *s == '\t')) s++; // strip-off leading blanks; 1850 if (!*s) continue;; 1851 if (!strncmp(s, ""//"", 2)) continue;; 1852 if (!strncmp(s, ""/*"", 2)) {; 1853 comment = 1;; 1854 goto again;; 1855 }; 1856 }; 1857 }; 1858 if (!comment && *s == '{') tempfile = 1;; 1859 if (!comment) break;; 1860 }; 1861 macro.close();; 1862 ; 1863 if (!execute) {; 1864 TString exname = exnam;; 1865 if (!tempfile) {; 1866 // We have a script that does NOT contain an unnamed macro,; 1867 // so we can call the script compiler on it.; 1868 exname += aclicMode;; 1869 }; 1870 exname += arguments;; 1871 exname += io;; 1872 ; 1873 TString tempbuf;; 1874 if (tempfile) {; 1875 tempbuf.Form("".x %s"", exname.Data());; 1876 } else {; 1877 tempbuf.Form("".X%s %s"", keep ? ""k"" : "" "", exname.Data());; 1878 }; 1879 retval = gInterpreter->ProcessLineSynch(tempbuf,(TInterpreter::EErrorCode*)error);; 1880 }; 1881 ; 1882 delete [] exnam;; 1883 return retval;; 1884}; 1885 ; 1886////////////////////////////////////////////////////////////////////////////////; 1887/// Main application eventloop. Calls system dependent eventloop via gSystem.; 1888 ; 1889void TApplication::Run(Bool_t retrn); 1890{; 1891 SetReturnFromRun(retrn);; 1892 ; 1893 fIsRunning = kTRUE;; 1894 ; 1895 gSystem->Run();; 1896 fIsRunning = kFALSE;; 1897}; 1898 ; 1899////////////////////////////////////////////////////////////////////////////////; 1900/// Set the command to be executed after the system has been idle for; 1901/// idleTimeInSec seconds. Normally called via TROOT::Idle(...).; 1902 ; 1903void TApplication::SetIdleTimer(UInt_t idleTimeInSec, const char *command); 1904{; 1905 if (fIdleTimer) RemoveIdleTimer();; 1906 fIdleCommand = command;; 1907 fIdleTimer = new TIdleTimer(idleTimeInSec*1000);; 1908 gSystem->AddTimer(fIdleTimer);; 1909}; 1910 ; 1911////////////////////////////////////////////////////////////////////////////////; 1912/// Remove idle time",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:71985,error,error,71985,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"/"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDocOutput.html:2604,Error,Error,2604,root/html532/TDocOutput.html,https://root.cern,https://root.cern/root/html532/TDocOutput.html,2,['Error'],['Error']
Availability,"/"", Int_t includeOutput = 0, const char* context = """", TGClient* gclient = 0); virtual voidTObject::Copy(TObject& object) const; Bool_tCopyHtmlFile(const char* sourceName, const char* destName = """"); virtual voidCreateClassIndex(); virtual voidCreateClassTypeDefs(); virtual voidCreateHierarchy(); virtual voidCreateModuleIndex(); virtual voidCreateProductIndex(); virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TDocOutput.html:2548,Error,Error,2548,root/html602/TDocOutput.html,https://root.cern,https://root.cern/root/html602/TDocOutput.html,2,['Error'],['Error']
Availability,"/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 9.9999999999999995E-7) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this histogram to the specified output stream. Standard: number of entries; Shape: error CL and maximum value; Verbose: print our bin contents and errors. void printName(ostream& os) const; Print name of RooHist. void printTitle(ostream& os) const; Print title of RooHist. void printClassName(ostream& os) const; Print class name of RooHist. RooHist* makeResidHist(const RooCurve& curve, bool normalize = false, bool useAverage = false) const; Create and return RooHist containing residuals w.r.t to given curve.; If normalize is true, the residuals are normalized by the histogram; errors creating a RooHist with pull values. RooHist(). void Print(Option_t* options = 0) const; Printing interface. Double_t getNominalBinWidth() const; { return _nominalBinWidth; }. void setRawEntries(Double_t n); { _rawEntries = n ; }. RooHist* makePullHist(const RooCurve& curve, bool useAverage = false) const; {return makeResidHist(curve,true,useAverage); }. » Last changed: Tue Jun 30 14:33:25 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHist.html:26552,error,errors,26552,root/html602/RooHist.html,https://root.cern,https://root.cern/root/html602/RooHist.html,2,['error'],['errors']
Availability,"/* Time (since system start) when the request; 2479 * was received */; 2480 int64_t num_bytes_sent; /* Total bytes sent to client */; 2481 int64_t content_len; /* How many bytes of content can be read; 2482 * !is_chunked: Content-Length header value; 2483 * or -1 (until connection closed,; 2484 * not allowed for a request); 2485 * is_chunked: >= 0, appended gradually; 2486 */; 2487 int64_t consumed_content; /* How many bytes of content have been read */; 2488 int is_chunked; /* Transfer-Encoding is chunked:; 2489 * 0 = not chunked,; 2490 * 1 = chunked, not yet, or some data read,; 2491 * 2 = chunked, has error,; 2492 * 3 = chunked, all data read except trailer,; 2493 * 4 = chunked, all data read; 2494 */; 2495 char *buf; /* Buffer for received data */; 2496 char *path_info; /* PATH_INFO part of the URL */; 2497 ; 2498 int must_close; /* 1 if connection must be closed */; 2499 int accept_gzip; /* 1 if gzip encoding is accepted */; 2500 int in_error_handler; /* 1 if in handler for user defined error; 2501 * pages */; 2502#if defined(USE_WEBSOCKET); 2503 int in_websocket_handling; /* 1 if in read_websocket */; 2504#endif; 2505#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2506 && defined(MG_EXPERIMENTAL_INTERFACES); 2507 /* Parameters for websocket data compression according to rfc7692 */; 2508 int websocket_deflate_server_max_windows_bits;; 2509 int websocket_deflate_client_max_windows_bits;; 2510 int websocket_deflate_server_no_context_takeover;; 2511 int websocket_deflate_client_no_context_takeover;; 2512 int websocket_deflate_initialized;; 2513 int websocket_deflate_flush;; 2514 z_stream websocket_deflate_state;; 2515 z_stream websocket_inflate_state;; 2516#endif; 2517 int handled_requests; /* Number of requests handled by this connection; 2518 */; 2519 int buf_size; /* Buffer size */; 2520 int request_len; /* Size of the request + headers in a buffer */; 2521 int data_len; /* Total size of data in a buffer */; 2522 int status_code; /* HTTP reply status code, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:78042,error,error,78042,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"/* Time (since system start) when the request; 2480 * was received */; 2481 int64_t num_bytes_sent; /* Total bytes sent to client */; 2482 int64_t content_len; /* How many bytes of content can be read; 2483 * !is_chunked: Content-Length header value; 2484 * or -1 (until connection closed,; 2485 * not allowed for a request); 2486 * is_chunked: >= 0, appended gradually; 2487 */; 2488 int64_t consumed_content; /* How many bytes of content have been read */; 2489 int is_chunked; /* Transfer-Encoding is chunked:; 2490 * 0 = not chunked,; 2491 * 1 = chunked, not yet, or some data read,; 2492 * 2 = chunked, has error,; 2493 * 3 = chunked, all data read except trailer,; 2494 * 4 = chunked, all data read; 2495 */; 2496 char *buf; /* Buffer for received data */; 2497 char *path_info; /* PATH_INFO part of the URL */; 2498 ; 2499 int must_close; /* 1 if connection must be closed */; 2500 int accept_gzip; /* 1 if gzip encoding is accepted */; 2501 int in_error_handler; /* 1 if in handler for user defined error; 2502 * pages */; 2503#if defined(USE_WEBSOCKET); 2504 int in_websocket_handling; /* 1 if in read_websocket */; 2505#endif; 2506#if defined(USE_ZLIB) && defined(USE_WEBSOCKET) \; 2507 && defined(MG_EXPERIMENTAL_INTERFACES); 2508 /* Parameters for websocket data compression according to rfc7692 */; 2509 int websocket_deflate_server_max_windows_bits;; 2510 int websocket_deflate_client_max_windows_bits;; 2511 int websocket_deflate_server_no_context_takeover;; 2512 int websocket_deflate_client_no_context_takeover;; 2513 int websocket_deflate_initialized;; 2514 int websocket_deflate_flush;; 2515 z_stream websocket_deflate_state;; 2516 z_stream websocket_inflate_state;; 2517#endif; 2518 int handled_requests; /* Number of requests handled by this connection; 2519 */; 2520 int buf_size; /* Buffer size */; 2521 int request_len; /* Size of the request + headers in a buffer */; 2522 int data_len; /* Total size of data in a buffer */; 2523 int status_code; /* HTTP reply status code, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:78074,error,error,78074,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"/*; ; */. TObject * DrawClone(Option_t* option = """") const; Draw a clone of this object in the current pad. void Dump() const; Dump contents of object on stdout.; Using the information in the object dictionary (class TClass); each data member is interpreted.; If a data member is a pointer, the pointer value is printed. The following output is the Dump of a TArrow object:; fAngle 0 Arrow opening angle (degrees); fArrowSize 0.2 Arrow Size; fOption.*fData; fX1 0.1 X of 1st point; fY1 0.15 Y of 1st point; fX2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style. void Execute(const char* method, const char* params, Int_t* error = 0); Execute method on this object with the given parameter string, e.g.; ""3.14,1,\""text\"""". void Execute(TMethod* method, TObjArray* params, Int_t* error = 0); Execute method on this object with parameters stored in the TObjArray.; The TObjArray should contain an argv vector like:. argv[0] ... argv[n] = the list of TObjString parameters. void ExecuteEvent(Int_t event, Int_t px, Int_t py); Execute action corresponding to an event at (px,py). This method; must be overridden if an object can react to graphics events. TObject * FindObject(const char* name) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object by name inside this object. TObject * FindObject(const TObject* obj) const; Must be redefined in derived classes.; This function is typycally used with TCollections, but can also be used; to find an object inside this object. Option_t * GetDrawOption() const; Get option used by the graphics system to draw this object.; Note that before calling object.GetDrawOption(), you must; have called object.Draw(..) before in the current pad. const char * GetName() const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TObject.html:8674,error,error,8674,root/html528/TObject.html,https://root.cern,https://root.cern/root/html528/TObject.html,10,['error'],['error']
Availability,"// (now without limits!); FunctionMinimum min3 = migrad();. // output; std::cout<<""minimum3: ""<<min3<<std::endl;; }. {; // demonstrate MINOS error analysis. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create MINOS error factory; MnMinos minos(theFCN, min);. {; // 1-sigma MINOS errors; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""1-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean"")<<"" ""; <<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1)<<"" ""; <<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""<<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""; <<e2.second<<std::endl;; }. {; // 2-sigma MINOS errors; theFCN.setErrorDef(4.);; std::pair<double,double> e0 = minos(0);; std::pair<double,double> e1 = minos(1);; std::pair<double,double> e2 = minos(2);. // output; std::cout<<""2-sigma minos errors: ""<<std::endl;; std::cout<<""par0: ""; <<min.userState().value(""mean""); <<"" ""<<e0.first<<"" ""<<e0.second<<std::endl;; std::cout<<""par1: ""; <<min.userState().value(1); <<"" ""<<e1.first<<"" ""<<e1.second<<std::endl;; std::cout<<""par2: ""; <<min.userState().value(""area""); <<"" ""<<e2.first<<"" ""<<e2.second<<std::endl;; }; }. {; // demonstrate how to use the CONTOURs. // create Minuit parameters with names; MnUserParameters upar;; upar.add(""mean"", mean, 0.1);; upar.add(""sigma"", rms, 0.1);; upar.add(""area"", area, 0.1);. // create Migrad minimizer; MnMigrad migrad(theFCN, upar);. // minimize; FunctionMinimum min = migrad();. // create contours factory with FCN and minimum; MnContours contours(theFCN, min);. // 70% confidence level for 2 parameters contour; // around the minimum; theFCN.setErrorDef(2.41",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:86920,error,errors,86920,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['error'],['errors']
Availability,"// Fit again, but pass recovery information to the minimiser:; std::unique_ptr<RooFitResult> fitWithRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(1.), // The magnitude of the recovery information can be chosen here.; // Higher values mean more aggressive recovery.; RooFit::PrintEvalErrors(-1), // We are still expecting a few evaluation errors.; RooFit::PrintLevel(0))};; ; pdf.plotOn(frame, RooFit::LineColor(kBlue), RooFit::Name(""recovery""));; ; ; ; // Collect results and plot.; // --------------------------------; // We print the two fit results, and plot the fitted curves.; // The curve of the fit without recovery cannot be plotted, because the PDF is undefined if a2 < 0.; fitWithoutRecovery->Print();; std::cout << ""Without recovery, the fitter encountered "" << fitWithoutRecovery->numInvalidNLL(); << "" invalid function values. The parameters are unchanged."" << std::endl;; ; fitWithRecovery->Print();; std::cout << ""With recovery, the fitter encountered "" << fitWithRecovery->numInvalidNLL(); << "" invalid function values, but the parameters are fitted."" << std::endl;; ; TLegend* legend = new TLegend(0.5, 0.7, 0.9, 0.9);; legend->SetBorderSize(0);; legend->SetFillStyle(0);; legend->AddEntry(""data"", ""Data"", ""P"");; legend->AddEntry(""noRecovery"", ""Without recovery (cannot be plotted)"", ""L"");; legend->AddEntry(""recovery"", ""With recovery"", ""L"");; frame->Draw();; legend->Draw();; c->Draw();; }; ; c#define c(i)Definition RSha256.hxx:101; RooDataSet.h; RooFitResult.h; RooGlobalFunc.h; RooMsgService.h; RooPlot.h; RooPolynomial.h; RooRealVar.h; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TCanvas.h; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TLegend.h; RooArgSetRooArgSet is a container object that can hold multiple RooAbsArg objects.Definition RooArgSet.h:24; Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:5361,recover,recovery,5361,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recovery']
Availability,"// Increment bin content by 1.; 2956/// Passing an out-of-range bin leads to undefined behavior; 2957 ; 2958void TH2C::AddBinContent(Int_t bin); 2959{; 2960 if (fArray[bin] < 127) fArray[bin]++;; 2961}; 2962 ; 2963 ; 2964////////////////////////////////////////////////////////////////////////////////; 2965/// Increment bin content by w.; 2966/// \warning The value of w is cast to `Int_t` before being added.; 2967/// Passing an out-of-range bin leads to undefined behavior; 2968 ; 2969void TH2C::AddBinContent(Int_t bin, Double_t w); 2970{; 2971 Int_t newval = fArray[bin] + Int_t(w);; 2972 if (newval > -128 && newval < 128) {fArray[bin] = Char_t(newval); return;}; 2973 if (newval < -127) fArray[bin] = -127;; 2974 if (newval > 127) fArray[bin] = 127;; 2975}; 2976 ; 2977 ; 2978////////////////////////////////////////////////////////////////////////////////; 2979/// Copy.; 2980 ; 2981void TH2C::Copy(TObject &newth2) const; 2982{; 2983 TH2::Copy(newth2);; 2984}; 2985 ; 2986 ; 2987////////////////////////////////////////////////////////////////////////////////; 2988/// Reset this histogram: contents, errors, etc.; 2989 ; 2990void TH2C::Reset(Option_t *option); 2991{; 2992 TH2::Reset(option);; 2993 TArrayC::Reset();; 2994}; 2995 ; 2996 ; 2997////////////////////////////////////////////////////////////////////////////////; 2998/// Set total number of bins including under/overflow; 2999/// Reallocate bin contents array; 3000 ; 3001void TH2C::SetBinsLength(Int_t n); 3002{; 3003 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3004 fNcells = n;; 3005 TArrayC::Set(n);; 3006}; 3007 ; 3008 ; 3009////////////////////////////////////////////////////////////////////////////////; 3010/// Stream an object of class TH2C.; 3011 ; 3012void TH2C::Streamer(TBuffer &R__b); 3013{; 3014 if (R__b.IsReading()) {; 3015 UInt_t R__s, R__c;; 3016 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 3017 if (R__v > 2) {; 3018 R__b.ReadClassBuffer(TH2C::Class(), this, R__v, R__s, R__c);; 3019 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:120038,error,errors,120038,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['errors']
Availability,"// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:63839,error,errors,63839,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability,"// This is needed to compute the correct statistical quantities; 2037/// of a profile filled with weights; 2038///; 2039/// This function is automatically called when the histogram is created; 2040/// if the static function TH1::SetDefaultSumw2 has been called before.; 2041/// If flag is false the structure is deleted; 2042 ; 2043void TProfile2D::Sumw2(Bool_t flag); 2044{; 2045 TProfileHelper::Sumw2(this, flag);; 2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:75337,error,error,75337,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability,"// Use THnIter instead.; 895 ; 896ROOT::Internal::THnBaseBinIter* THnSparse::CreateIter(Bool_t respectAxisRange) const; 897{; 898 return new THnSparseBinIter(respectAxisRange, this);; 899}; 900 ; 901////////////////////////////////////////////////////////////////////////////////; 902/// Set content of bin with index ""bin"" to ""v""; 903 ; 904void THnSparse::SetBinContent(Long64_t bin, Double_t v); 905{; 906 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 907 chunk->fContent->SetAt(v, bin % fChunkSize);; 908 ++fEntries;; 909}; 910 ; 911////////////////////////////////////////////////////////////////////////////////; 912/// Set error of bin with index ""bin"" to ""e"", enable errors if needed; 913 ; 914void THnSparse::SetBinError2(Long64_t bin, Double_t e2); 915{; 916 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 917 if (!chunk->fSumw2 ) {; 918 // if fSumw2 is zero GetCalculateErrors should return false; 919 if (GetCalculateErrors()) {; 920 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 921 }; 922 Sumw2(); // enable error calculation; 923 }; 924 ; 925 chunk->fSumw2->SetAt(e2, bin % fChunkSize);; 926}; 927 ; 928////////////////////////////////////////////////////////////////////////////////; 929/// Add ""e"" to error of bin with index ""bin"", enable errors if needed; 930 ; 931void THnSparse::AddBinError2(Long64_t bin, Double_t e2); 932{; 933 THnSparseArrayChunk* chunk = GetChunk(bin / fChunkSize);; 934 if (!chunk->fSumw2 ) {; 935 // if fSumw2 is zero GetCalculateErrors should return false; 936 if (GetCalculateErrors()) {; 937 Error(""SetBinError"", ""GetCalculateErrors() logic error!"");; 938 }; 939 Sumw2(); // enable error calculation; 940 }; 941 ; 942 (*chunk->fSumw2)[bin % fChunkSize] += e2;; 943}; 944 ; 945////////////////////////////////////////////////////////////////////////////////; 946/// Enable calculation of errors; 947 ; 948void THnSparse::Sumw2(); 949{; 950 if (GetCalculateErrors()) return;; 951 ; 952 fTsumw2 = 0.;; 953 TIter iChunk(&fB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:34099,error,error,34099,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,9,['error'],"['error', 'errors']"
Availability,"// and N is the number of bin entries (from TProfile::GetBinEntries(ibin) ); 198/// (i.e the errors are the standard error on the bin content of the profile); 199/// - 's' Errors are the standard deviation of Y, S(Y); 200/// - 'i' Errors are S(Y)/SQRT(N) (standard error on the mean as in the default); 201/// The only difference is only when the standard deviation in Y is zero.; 202/// In this case the error a standard deviation = 1/SQRT(12) is assumed and the error is; 203/// 1./SQRT(12*N).; 204/// This approximation assumes that the Y values are integer (e.g. ADC counts); 205/// and have an implicit uncertainty of y +/- 0.5. With the assumption that the probability that y; 206/// takes any value between y-0.5 and y+0.5 is uniform, its standard error is 1/SQRT(12); 207/// - 'g' Errors are 1./SQRT(W) where W is the sum of the weights for the bin j; 208/// W is obtained as from TProfile::GetBinEntries(ibin); 209/// This errors corresponds to the standard deviation of weighted mean where each; 210/// measurement Y is uncorrelated and has an error sigma, which is expressed in the; 211/// weight used to fill the Profile: w = 1/sigma^2; 212/// The resulting error in TProfile is then 1./SQRT( Sum(1./sigma^2) ); 213///; 214/// In the case of Profile filled weights and with TProfile::Sumw2() called,; 215/// STD(Y) is the standard deviation of the weighted sample Y and N is in this case the; 216/// number of effective entries (TProfile::GetBinEffectiveEntries(ibin) ); 217///; 218/// If a bin has N data points all with the same value Y (especially; 219/// possible when dealing with integers), the spread in Y for that bin; 220/// is zero, and the uncertainty assigned is also zero, and the bin is; 221/// ignored in making subsequent fits.; 222/// To avoid this problem one can use an approximation for the standard deviation S(Y),; 223/// by using the average of all the S(Y) of the other Profile bins. To use this approximation; 224/// one must call before TProfile::Approximate; 22",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:9462,error,errors,9462,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability,"// considerable advantage in speed.; 1201/// When using the linear fitting it is also possible to perform a robust fitting with the; 1202/// Least Trimmed Square (LTS) regression algorithm, by using the fit option `ROB`.; 1203/// See the tutorial `fitLinearRobust.C`.; 1204///; 1205/// ### Notes on TGraph/TGraphErrors Fitting:; 1206///; 1207/// 1. By using the ""effective variance"" method a simple linear regression; 1208/// becomes a non-linear case, which takes several iterations; 1209/// instead of 0 as in the linear case.; 1210/// 2. The effective variance technique assumes that there is no correlation; 1211/// between the x and y coordinate.; 1212/// 3. The standard chi2 (least square) method without error in the coordinates (x) can; 1213/// be forced by using option ""EX0""; 1214/// 4. The linear fitter doesn't take into account the errors in x. When fitting a; 1215/// TGraphErrors with a linear functions the errors in x will not be considered.; 1216/// If errors in x are important, use option ""F"" for linear function fitting.; 1217/// 5. When fitting a TGraph (i.e. no errors associated with each point),; 1218/// a correction is applied to the errors on the parameters with the following; 1219/// formula:; 1220/// `parameter_error *= sqrt(chisquare/(ndf-1))`; 1221///; 1222/// ### General Fitting documentation; 1223///; 1224/// See in TH1::Fit for the documentation of; 1225/// - [Fit Result](\ref HFitRes); 1226/// - [Fit Status](\ref HFitStatus); 1227/// - [Fit Statistics Box](\ref HFitStatBox); 1228/// - [Fitting in a Range](\ref HFitRange); 1229/// - [Setting Initial Conditions](\ref HFitInitial); 1230 ; 1231TFitResultPtr TGraph::Fit(TF1 *f1, Option_t *option, Option_t *goption, Axis_t rxmin, Axis_t rxmax); 1232{; 1233 Foption_t fitOption;; 1234 ROOT::Fit::FitOptionsMake(ROOT::Fit::EFitObjectType::kGraph, option, fitOption);; 1235 // create range and minimizer options with default values; 1236 ROOT::Fit::DataRange range(rxmin, rxmax);; 1237 ROOT::Math::MinimizerOptio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:43704,error,errors,43704,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['error'],['errors']
Availability,"// correct dimensions:; 4338/// Sumw2 just makes sure the errors will be computed properly; 4339/// when we form sums and ratios below.; 4340 ; 4341TH1 *TH1::GetAsymmetry(TH1* h2, Double_t c2, Double_t dc2); 4342{; 4343 TH1 *h1 = this;; 4344 TString name = TString::Format(""Asymmetry_%s-%s"",h1->GetName(),h2->GetName() );; 4345 TH1 *asym = (TH1*)Clone(name);; 4346 ; 4347 // set also the title; 4348 TString title = TString::Format(""(%s - %s)/(%s+%s)"",h1->GetName(),h2->GetName(),h1->GetName(),h2->GetName() );; 4349 asym->SetTitle(title);; 4350 ; 4351 asym->Sumw2();; 4352 Bool_t addStatus = TH1::AddDirectoryStatus();; 4353 TH1::AddDirectory(kFALSE);; 4354 TH1 *top = (TH1*)asym->Clone();; 4355 TH1 *bottom = (TH1*)asym->Clone();; 4356 TH1::AddDirectory(addStatus);; 4357 ; 4358 // form the top and bottom of the asymmetry, and then divide:; 4359 top->Add(h1,h2,1,-c2);; 4360 bottom->Add(h1,h2,1,c2);; 4361 asym->Divide(top,bottom);; 4362 ; 4363 Int_t xmax = asym->GetNbinsX();; 4364 Int_t ymax = asym->GetNbinsY();; 4365 Int_t zmax = asym->GetNbinsZ();; 4366 ; 4367 if (h1->fBuffer) h1->BufferEmpty(1);; 4368 if (h2->fBuffer) h2->BufferEmpty(1);; 4369 if (bottom->fBuffer) bottom->BufferEmpty(1);; 4370 ; 4371 // now loop over bins to calculate the correct errors; 4372 // the reason this error calculation looks complex is because of c2; 4373 for(Int_t i=1; i<= xmax; i++){; 4374 for(Int_t j=1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:180654,error,errors,180654,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,4,['error'],"['error', 'errors']"
Availability,"// fill the data now; 867 next = grList;; 868 while ((gr = (TGraph*) next())) {; 869 DoFillData( dv, gr, type, func);; 870 }; 871 ; 872#ifdef DEBUG; 873 std::cout << ""TGraphFitInterface::FillData MultiGraph FitData size is "" << dv.Size() << std::endl;; 874#endif; 875 ; 876}; 877 ; 878void FillData ( BinData & dv, const TGraph2D * gr, TF1 * func ) {; 879 // fill the data vector from a TGraph2D. Pass also the TF1 function which is; 880 // needed in case to exclude points rejected by the function; 881 // in case of a pure TGraph; 882 assert(gr != nullptr);; 883 ; 884 // get fit option; 885 DataOptions & fitOpt = dv.Opt();; 886 BinData::ErrorType type = GetDataType(gr,fitOpt);; 887 // adjust option according to type; 888 fitOpt.fErrors1 = (type == BinData::kNoError);; 889 fitOpt.fCoordErrors = (type == BinData::kCoordError);; 890 fitOpt.fAsymErrors = false; // a TGraph2D with asymmetric errors does not exist; 891 ; 892 int nPoints = gr->GetN();; 893 double *gx = gr->GetX();; 894 double *gy = gr->GetY();; 895 double *gz = gr->GetZ();; 896 ; 897 // if all errors are zero set option of using errors to 1; 898 if ( gr->GetEZ() == nullptr) fitOpt.fErrors1 = true;; 899 ; 900 double x[2];; 901 double ex[2];; 902 ; 903 // look at data range; 904 const DataRange & range = dv.Range();; 905 bool useRangeX = ( range.Size(0) > 0);; 906 bool useRangeY = ( range.Size(1) > 0);; 907 double xmin = 0;; 908 double xmax = 0;; 909 double ymin = 0;; 910 double ymax = 0;; 911 range.GetRange(xmin,xmax,ymin,ymax);; 912 ; 913 dv.Initialize(nPoints,2, type);; 914 ; 915 for ( int i = 0; i < nPoints; ++i) {; 916 ; 917 x[0] = gx[i];; 918 x[1] = gy[i];; 919 ; 920 //if (fitOpt.fUseRange && HFitInterface::IsPointOutOfRange(func, x) ) continue;; 921 if (useRangeX && ( x[0] < xmin || x[0] > xmax) ) continue;; 922 if (useRangeY && ( x[1] < ymin || x[1] > ymax) ) continue;; 923 ; 924 // need to evaluate function to know about rejected points; 925 // hugly but no other solutions; 926 if (func) {; 927 TF1::Rej",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:29136,error,errors,29136,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,3,['error'],['errors']
Availability,"// we can not use it.; 3591 if (gApplication && gApplication->GetApplicationImp()) {; 3592 while (gROOT->IsLineProcessing() && !gApplication) {; 3593 Warning(""Calc"", ""waiting for cling thread to free"");; 3594 gSystem->Sleep(500);; 3595 }; 3596 gROOT->SetLineIsProcessing();; 3597 }; 3598#endif // R__WIN32; 3599 R__LOCKGUARD_CLING(gInterpreterMutex);; 3600 if (error) {; 3601 *error = TInterpreter::kNoError;; 3602 }; 3603 cling::Value valRef;; 3604 cling::Interpreter::CompilationResult cr = cling::Interpreter::kFailure;; 3605 try {; 3606 cr = fInterpreter->evaluate(line, valRef);; 3607 }; 3608 catch (cling::InterpreterException& ex); 3609 {; 3610 Error(""Calc"", ""%s.\n%s"", ex.what(), ""Evaluation of your expression was aborted."");; 3611 ex.diagnose();; 3612 cr = cling::Interpreter::kFailure;; 3613 }; 3614 ; 3615 if (cr != cling::Interpreter::kSuccess) {; 3616 // Failure in compilation.; 3617 if (error) {; 3618 // Note: Yes these codes are weird.; 3619 *error = TInterpreter::kRecoverable;; 3620 }; 3621 return 0L;; 3622 }; 3623 if (!valRef.isValid()) {; 3624 // Failure at runtime.; 3625 if (error) {; 3626 // Note: Yes these codes are weird.; 3627 *error = TInterpreter::kDangerous;; 3628 }; 3629 return 0L;; 3630 }; 3631 ; 3632 if (valRef.isVoid()) {; 3633 return 0;; 3634 }; 3635 ; 3636 RegisterTemporary(valRef);; 3637#ifdef R__WIN32; 3638 if (gApplication && gApplication->GetApplicationImp()) {; 3639 gROOT->SetLineHasBeenProcessed();; 3640 }; 3641#endif // R__WIN32; 3642 return valRef.castAs<Longptr_t>();; 3643}; 3644 ; 3645////////////////////////////////////////////////////////////////////////////////; 3646/// Set a getline function to call when input is needed.; 3647 ; 3648void TCling::SetGetline(const char * (*getlineFunc)(const char* prompt),; 3649 void (*histaddFunc)(const char* line)); 3650{; 3651 // If cling offers a replacement for G__pause(), it would need to; 3652 // also offer a way to customize at least the history recording.; 3653 ; 3654#if defined(R__MUST_REVIS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:140586,error,error,140586,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"/// For the fit to be meaningful, the function must be self-normalized.; 9679///; 9680/// i.e. It must have the same integral regardless of the parameter; 9681/// settings. Otherwise the fit will effectively just maximize the; 9682/// area.; 9683///; 9684/// It is mandatory to have a normalization variable; 9685/// which is fixed for the fit. e.g.; 9686/// ~~~ {.cpp}; 9687/// TF1* f1 = new TF1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; 9688/// f1->SetParameters(1, 3.1, 0.01);; 9689/// f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; 9690/// data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; 9691/// ~~~; 9692/// 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; 9693///; 9694/// Return status:; 9695///; 9696/// - The function return the status of the fit in the following form; 9697/// fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; 9698/// - The fitResult is 0 is the fit is OK.; 9699/// - The fitResult is negative in case of an error not connected with the fit.; 9700/// - The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; 9701/// - If the number of selected entries is null the function returns -1; 9702 ; 9703Int_t TTree::UnbinnedFit(const char* funcname, const char* varexp, const char* selection, Option_t* option, Long64_t nentries, Long64_t firstentry); 9704{; 9705 GetPlayer();; 9706 if (fPlayer) {; 9707 return fPlayer->UnbinnedFit(funcname, varexp, selection, option, nentries, firstentry);; 9708 }; 9709 return -1;; 9710}; 9711 ; 9712////////////////////////////////////////////////////////////////////////////////; 9713/// Replace current attributes by current style.; 9714 ; 9715void TTree::UseCurrentStyle(); 9716{; 9717 if (gStyle->IsReading()) {; 9718 SetFillColor(gStyle->GetHistFillColor());; 9719 SetFillStyle(gStyle->GetHistFillStyle());; 9720 SetLineColor(gStyle->GetHistLineColor());; 9721 SetLineStyle(gStyle->GetHistLineStyle());; 9722 SetLineWidth(gStyle->GetH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:372377,error,error,372377,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"/// Passing an out-of-range bin leads to undefined behavior; 3485 ; 3486void TH2I::AddBinContent(Int_t bin); 3487{; 3488 if (fArray[bin] < INT_MAX) fArray[bin]++;; 3489}; 3490 ; 3491 ; 3492////////////////////////////////////////////////////////////////////////////////; 3493/// Increment bin content by w.; 3494/// \warning The value of w is cast to `Long64_t` before being added.; 3495/// Passing an out-of-range bin leads to undefined behavior; 3496 ; 3497void TH2I::AddBinContent(Int_t bin, Double_t w); 3498{; 3499 Long64_t newval = fArray[bin] + Long64_t(w);; 3500 if (newval > -INT_MAX && newval < INT_MAX) {fArray[bin] = Int_t(newval); return;}; 3501 if (newval < -INT_MAX) fArray[bin] = -INT_MAX;; 3502 if (newval > INT_MAX) fArray[bin] = INT_MAX;; 3503}; 3504 ; 3505 ; 3506////////////////////////////////////////////////////////////////////////////////; 3507/// Copy.; 3508 ; 3509void TH2I::Copy(TObject &newth2) const; 3510{; 3511 TH2::Copy(newth2);; 3512}; 3513 ; 3514 ; 3515////////////////////////////////////////////////////////////////////////////////; 3516/// Reset this histogram: contents, errors, etc.; 3517 ; 3518void TH2I::Reset(Option_t *option); 3519{; 3520 TH2::Reset(option);; 3521 TArrayI::Reset();; 3522}; 3523 ; 3524 ; 3525////////////////////////////////////////////////////////////////////////////////; 3526/// Set total number of bins including under/overflow; 3527/// Reallocate bin contents array; 3528 ; 3529void TH2I::SetBinsLength(Int_t n); 3530{; 3531 if (n < 0) n = (fXaxis.GetNbins()+2)*(fYaxis.GetNbins()+2);; 3532 fNcells = n;; 3533 TArrayI::Set(n);; 3534}; 3535 ; 3536 ; 3537////////////////////////////////////////////////////////////////////////////////; 3538/// Operator =; 3539 ; 3540TH2I& TH2I::operator=(const TH2I &h2i); 3541{; 3542 if (this != &h2i); 3543 h2i.TH2I::Copy(*this);; 3544 return *this;; 3545}; 3546 ; 3547 ; 3548////////////////////////////////////////////////////////////////////////////////; 3549/// Operator *; 3550 ; 3551TH2I opera",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:135408,error,errors,135408,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['errors']
Availability,"/// is not destroyed in the process and will still retain (shared) ownership of; 201/// the original results.; 202///; 203/// Example usage:; 204/// ~~~{.cpp}; 205/// auto df = ROOT::RDataFrame(10).Define(""x"", [] { return 1; });; 206/// auto h = df.Vary(""x"", [](){return ROOT::RVecI{-1, 2};}, {}, 2).Histo1D<int>(""x"");; 207/// auto hs = ROOT::RDF::Experimental::VariationsFor(h);; 208/// std::unique_ptr<RMergeableVariations<T>> m = ROOT::Detail::RDF::GetMergeableValue(hs);; 209/// ~~~; 210template <typename T>; 211std::unique_ptr<RMergeableVariations<T>> GetMergeableValue(ROOT::RDF::Experimental::RResultMap<T> &rmap); 212{; 213 rmap.RunEventLoopIfNeeded();; 214 ; 215 std::unique_ptr<RMergeableVariationsBase> mVariationsBase;; 216 if (rmap.fVariedAction != nullptr) {; 217 auto mValueBase = rmap.fVariedAction->GetMergeableValue();; 218 mVariationsBase.reset(static_cast<RMergeableVariationsBase *>(mValueBase.release())); // downcast unique_ptr; 219 } else {; 220 mVariationsBase = std::unique_ptr<RMergeableVariationsBase>({}, {});; 221 }; 222 mVariationsBase->AddNominal(rmap.fNominalAction->GetMergeableValue());; 223 ; 224 return std::make_unique<RMergeableVariations<T>>(std::move(*mVariationsBase));; 225}; 226} // namespace RDF; 227} // namespace Detail; 228} // namespace ROOT; 229 ; 230#endif; RActionBase.hxx; RLoopManager.hxx; RMergeableValue.hxx; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Utils.hxx; ROOT::Detail::RDF::RLoopManagerThe head node of a RDF computation graph.Definition RLoopManager.hxx:114; ROOT::Detail::RDF::RMergeableVariationsBaseA container for variation names and variation results.Definition RMergeableValue.hxx:569; ROOT::RDF::Experimental::RResultMapDefinition RResultMap.hxx:98; ROOT::RDF::Experimental::RResultMap::const_iteratortypename decltype(fMap)::const_iterator const_iteratorDefinition RResultMap.hxx:144; ROOT::RDF::Experimental::RResultMap::operator[]T & operator[](const std:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RResultMap_8hxx_source.html:8790,down,downcast,8790,doc/master/RResultMap_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RResultMap_8hxx_source.html,1,['down'],['downcast']
Availability,"//////////////// ;  ; static TString GetSysIncludePath ();  [static utility function]///////////////////////////// ;  ; static Bool_t IsDirectory (const char fileName[]);  [static utility function]///////////////////////////// ;  ; static TSeqCollection * NewListOfFilesInPath (const char path[]);  [static utility function]///////////////////////////// ;  ; static void NoMsg (Int_t errorLevel);  [static utility function]///////////////////////////// ;  ; static Bool_t PathIsSpecifiedInFileName (const TString &fileName);  [static utility function]///////////////////////////// ;  . Private Member Functions;  TTabCom (const TTabCom &)=delete;  ; Int_t Complete (const TRegexp &re, const TSeqCollection *pListOfCandidates, const char appendage[], std::ostream &out, TString::ECaseCompare cmp=TString::kExact);  [private] ;  ; void CopyMatch (char *dest, int dest_len, const char *localName, const char *appendage=nullptr, const char *fullName=nullptr) const;  [private] ;  ; EContext_t DetermineContext () const;  [private] ;  ; TString DeterminePath (const TString &fileName, const char defaultPath[]) const;  [private] ;  ; TString ExtendPath (const char originalPath[], TString newBase) const;  [private] ;  ; void InitPatterns ();  [private] ;  ; TClass * MakeClassFromClassName (const char className[]) const;  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a class. ;  ; TClass * MakeClassFromVarName (const char varName[], EContext_t &context, int iter=0);  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a variable. ;  ; TTabCom & operator= (const TTabCom &)=delete;  ; int ParseReverse (const char *var_str, int start);  Returns the place in the string where to put the \0, starting the search from ""start"". ;  ; void SetPattern (EContext_t handle, const char regexp[]);  [private] ;  ; TClass * TryMakeC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:5403,error,error,5403,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['error'],['error']
Availability,"/////////////////// ;  . Private Member Functions;  TTabCom (const TTabCom &)=delete;  ; Int_t Complete (const TRegexp &re, const TSeqCollection *pListOfCandidates, const char appendage[], std::ostream &out, TString::ECaseCompare cmp=TString::kExact);  [private] ;  ; void CopyMatch (char *dest, int dest_len, const char *localName, const char *appendage=nullptr, const char *fullName=nullptr) const;  [private] ;  ; EContext_t DetermineContext () const;  [private] ;  ; TString DeterminePath (const TString &fileName, const char defaultPath[]) const;  [private] ;  ; TString ExtendPath (const char originalPath[], TString newBase) const;  [private] ;  ; void InitPatterns ();  [private] ;  ; TClass * MakeClassFromClassName (const char className[]) const;  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a class. ;  ; TClass * MakeClassFromVarName (const char varName[], EContext_t &context, int iter=0);  [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a variable. ;  ; TTabCom & operator= (const TTabCom &)=delete;  ; int ParseReverse (const char *var_str, int start);  Returns the place in the string where to put the \0, starting the search from ""start"". ;  ; void SetPattern (EContext_t handle, const char regexp[]);  [private] ;  ; TClass * TryMakeClassFromClassName (const char className[]) const;  Same as above but does not print the error message. ;  . Private Attributes; char * fBuf;  ; Int_t fLastIter;  ; Pattern_t fPat [kNUM_PAT][1024];  ; TSeqCollection * fpClasses;  ; TSeqCollection * fpDirectives;  ; TSeqCollection * fpEnvVars;  ; TSeqCollection * fpFiles;  ; TSeqCollection * fpGlobals;  ; int * fpLoc;  ; TSeqCollection * fpPragmas;  ; ULong64_t fPrevInterpMarker;  ; TSeqCollection * fpSysIncFiles;  ; TSeqCollection * fpUsers;  ; const char * fRegExp [kNUM_PAT];  ; Bool_t fVarIsPointer;  . #",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:5644,error,error,5644,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; 1338/// Return integral of bin contents in range [firstxbin,lastxbin],[firstybin,lastybin]; 1339/// for a 2-D histogram. Calculates also the integral error using error propagation; 1340/// from the bin errors assuming that all the bins are uncorrelated.; 1341/// By default the integral is computed as the sum of bin contents in the range.; 1342/// if option ""width"" is specified, the integral is the sum of; 1343/// the bin contents multiplied by the bin width in x and in y.; 1344 ; 1345Double_t TH2::IntegralAndError(Int_t firstxbin, Int_t lastxbin, Int_t firstybin, Int_t lastybin, Double_t & error, Option_t *option) const; 1346{; 1347 return DoIntegral(firstxbin,lastxbin,firstybin,lastybin,-1,0,error,option,kTRUE);; 1348}; 1349 ; 1350////////////////////////////////////////////////////////////////////////////////; 1351///illegal for a TH2; 1352 ; 1353Double_t TH2::Interpolate(Double_t) const; 1354{; 1355 Error(""Interpolate"",""This function must be called with 2 arguments for a TH2"");; 1356 return 0;; 1357}; 1358 ; 1359////////////////////////////////////////////////////////////////////////////////; 1360/// Given a point P(x,y), Interpolate approximates the value via bilinear; 1361/// interpolation based on the four nearest bin centers; 1362/// see Wikipedia, Bilinear Interpolation; 1363/// Andy Mastbaum 10/8/2008; 1364/// vaguely based on R.Raja 6-Sep-2008; 1365 ; 1366 Double_t TH2::Interpolate(Double_t x, Double_t y) const; 1367{; 1368 Double_t f=0;; 1369 Double_t x1=0,x2=0,y1=0,y2=0;; 1370 Double_t dx,dy;; 1371 Int_t bin_x = fXaxis.FindFixBin(x);; 1372 Int_t bin_y = fYaxis.FindFixBin(y);; 1373 if(bin_x<1 || bin_x>GetNbinsX() || bin_y<1 || bin_y>GetNbinsY()) {; 1374 Error(""Interpolate"",""Cannot interpolate outside histogram domain."");; 1375 return 0;; 1376 }; 1377 Int_t quadrant = 0; // CCW from UR 1,2,3,4; 1378 // which quadrant of the bin (bin_P) are we in?; 1379 dx = fXaxis.GetBinUpEdg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:54738,error,error,54738,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////////////; 2398/// Get x axis of the function.; 2399 ; 2400TAxis *TF1::GetXaxis() const; 2401{; 2402 TH1 *h = GetHistogram();; 2403 if (!h) return nullptr;; 2404 return h->GetXaxis();; 2405}; 2406 ; 2407 ; 2408////////////////////////////////////////////////////////////////////////////////; 2409/// Get y axis of the function.; 2410 ; 2411TAxis *TF1::GetYaxis() const; 2412{; 2413 TH1 *h = GetHistogram();; 2414 if (!h) return nullptr;; 2415 return h->GetYaxis();; 2416}; 2417 ; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// Get z axis of the function. (In case this object is a TF2 or TF3); 2421 ; 2422TAxis *TF1::GetZaxis() const; 2423{; 2424 TH1 *h = GetHistogram();; 2425 if (!h) return nullptr;; 2426 return h->GetZaxis();; 2427}; 2428 ; 2429 ; 2430 ; 2431////////////////////////////////////////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:89051,error,errors,89051,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Breakvoid Break(const char *location, const char *fmt,...)Use this function in case an error occurred.Definition TError.cxx:207; GetErrorHandlerErrorHandlerFunc_t GetErrorHandler()Returns the current error handler function.Definition TError.cxx:100; Infovoid Info(const char *location, const char *fmt,...)Use this function for informational messages.Definition TError.cxx:218; gErrorHandlerstatic ErrorHandlerFunc_t gErrorHandlerDefinition TError.cxx:38; SysErrorvoid SysError(const char *location, const char *fmt,...)Use this function in case a system (OS or GUI) related error occurred.Definition TError.cxx:196; GetErrorSystemMsgHandlerRefstatic ROOT::Internal::ErrorSystemMsgHandlerFunc_t & GetErrorSystemMsgHandlerRef()Definition TError.cxx:41; AbstractMethodvoid AbstractMethod(const char *method)This function can be used in abstract base classes in case one does not want to make the class a ""rea...Definition TError.cxx:159; ErrorHandlervoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:8884,error,error,8884,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////////////; 990/// Issue error message. Use ""location"" to specify the method where the; 991/// error occurred. Accepts standard printf formatting arguments.; 992 ; 993void TObject::Error(const char *location, const char *va_(fmt), ...) const; 994{; 995 va_list ap;; 996 va_start(ap, va_(fmt));; 997 DoError(kError, location, va_(fmt), ap);; 998 va_end(ap);; 999 if (TROOT::Initialized()); 1000 gROOT->Message(1002, this);; 1001}; 1002 ; 1003////////////////////////////////////////////////////////////////////////////////; 1004/// Issue system error message. Use ""location"" to specify the method where; 1005/// the system error occurred. Accepts standard printf formatting arguments.; 1006 ; 1007void TObject::SysError(const char *location, const char *va_(fmt), ...) const; 1008{; 1009 va_list ap;; 1010 va_start(ap, va_(fmt));; 1011 DoError(kSysError, location, va_(fmt), ap);; 1012 va_end(ap);; 1013 if (TROOT::Initialized()); 1014 gROOT->Message(1003, this);; 1015}; 1016 ; 1017////////////////////////////////////////////////////////////////////////////////; 1018/// Issue fatal error message. Use ""location"" to specify the method where the; 1019/// fatal error occurred. Accepts standard printf formatting arguments.; 1020 ; 1021void TObject::Fatal(const char *location, const char *va_(fmt), ...) const; 1022{; 1023 va_list ap;; 1024 va_start(ap, va_(fmt));; 1025 DoError(kFatal, location, va_(fmt), ap);; 1026 va_end(ap);; 1027 if (TROOT::Initialized()); 1028 gROOT->Message(1004, this);; 1029}; 1030 ; 1031////////////////////////////////////////////////////////////////////////////////; 1032/// Use this method to implement an ""abstract"" method that you don't; 1033/// want to leave purely abstract.; 1034 ; 1035void TObject::AbstractMethod(const char *method) const; 1036{; 1037 Warning(method, ""this method must be overridden!"");; 1038}; 1039 ; 1040///////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:37616,error,error,37616,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////; 1500/// Return a user configured or systemwide directory to create; 1501/// temporary files in.; 1502 ; 1503const char *TUnixSystem::TempDirectory() const; 1504{; 1505 const char *dir = gSystem->Getenv(""TMPDIR"");; 1506 if (!dir || gSystem->AccessPathName(dir, kWritePermission)); 1507 dir = ""/tmp"";; 1508 ; 1509 return dir;; 1510}; 1511 ; 1512////////////////////////////////////////////////////////////////////////////////; 1513/// Create a secure temporary file by appending a unique; 1514/// 6 letter string to base. The file will be created in; 1515/// a standard (system) directory or in the directory; 1516/// provided in dir. Optionally one can provide suffix; 1517/// append to the final name - like extension "".txt"" or "".html"".; 1518/// The full filename is returned in base; 1519/// and a filepointer is returned for safely writing to the file; 1520/// (this avoids certain security problems). Returns 0 in case; 1521/// of error.; 1522 ; 1523FILE *TUnixSystem::TempFileName(TString &base, const char *dir, const char *suffix); 1524{; 1525 char *b = ConcatFileName(dir ? dir : TempDirectory(), base);; 1526 base = b;; 1527 base += ""XXXXXX"";; 1528 const bool hasSuffix = suffix && *suffix;; 1529 if (hasSuffix); 1530 base.Append(suffix);; 1531 delete [] b;; 1532 ; 1533 char *arg = StrDup(base);; 1534 int fd = hasSuffix ? mkstemps(arg, strlen(suffix)) : mkstemp(arg);; 1535 base = arg;; 1536 delete [] arg;; 1537 ; 1538 if (fd == -1) {; 1539 SysError(""TempFileName"", ""%s"", base.Data());; 1540 return nullptr;; 1541 } else {; 1542 FILE *fp = fdopen(fd, ""w+"");; 1543 if (!fp); 1544 SysError(""TempFileName"", ""converting filedescriptor (%d)"", fd);; 1545 return fp;; 1546 }; 1547}; 1548 ; 1549////////////////////////////////////////////////////////////////////////////////; 1550/// Concatenate a directory and a file name.; 1551 ; 1552const char *TUnixSystem::PrependPathName(const char *dir, TString& name); 1553{; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:46514,error,error,46514,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////////////; 8985/// Set statistics option on/off.; 8986///; 8987/// By default, the statistics box is drawn.; 8988/// The paint options can be selected via gStyle->SetOptStat.; 8989/// This function sets/resets the kNoStats bit in the histogram object.; 8990/// It has priority over the Style option.; 8991 ; 8992void TH1::SetStats(Bool_t stats); 8993{; 8994 ResetBit(kNoStats);; 8995 if (!stats) {; 8996 SetBit(kNoStats);; 8997 //remove the ""stats"" object from the list of functions; 8998 if (fFunctions) {; 8999 TObject *obj = fFunctions->FindObject(""stats"");; 9000 if (obj) {; 9001 fFunctions->Remove(obj);; 9002 delete obj;; 9003 }; 9004 }; 9005 }; 9006}; 9007 ; 9008////////////////////////////////////////////////////////////////////////////////; 9009/// Create structure to store sum of squares of weights.; 9010///; 9011/// if histogram is already filled, the sum of squares of weights; 9012/// is filled with the existing bin contents; 9013///; 9014/// The error per bin will be computed as sqrt(sum of squares of weight); 9015/// for each bin.; 9016///; 9017/// This function is automatically called when the histogram is created; 9018/// if the static function TH1::SetDefaultSumw2 has been called before.; 9019/// If flag = false the structure containing the sum of the square of weights; 9020/// is rest and it will be empty, but it is not deleted (i.e. GetSumw2()->fN = 0); 9021 ; 9022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:351656,error,error,351656,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.; 681 ; 682Int_t TGraphErrors::Merge(TCollection* li); 683{; 684 TIter next(li);; 685 while (TObject* o = next()) {; 686 TGraph *g = dynamic_cast<TGraph*>(o);; 687 if (!g) {; 688 Error(""Merge"",; 689 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 690 return -1;; 691 }; 692 int n0 = GetN();; 693 int n1 = n0+g->GetN();; 694 Set(n1);; 695 Double_t * x = g->GetX();; 696 Double_t * y = g->GetY();; 697 Double_t * ex = g->GetEX();; 698 Double_t * ey = g->GetEY();; 699 for (Int_t i = 0 ; i < g->GetN(); i++) {; 700 SetPoint(n0+i, x[i], y[i]);; 701 if (ex) fEX[n0+i] = ex[i];; 702 if (ey) fEY[n0+i] = ey[i];; 703 }; 704 }; 705 return GetN();; 706}; 707 ; 708////////////////////////////////////////////////////////////////////////////////; 709/// Print graph and errors values.; 710 ; 711void TGraphErrors::Print(Option_t *) const; 712{; 713 for (Int_t i = 0; i < fNpoints; i++) {; 714 printf(""x[%d]=%g, y[%d]=%g, ex[%d]=%g, ey[%d]=%g\n"", i, fX[i], i, fY[i], i, fEX[i], i, fEY[i]);; 715 }; 716}; 717 ; 718 ; 719////////////////////////////////////////////////////////////////////////////////; 720/// Save primitive as a C++ statement(s) on output stream out; 721 ; 722void TGraphErrors::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 723{; 724 out << "" "" << std::endl;; 725 static Int_t frameNumber = 1000;; 726 frameNumber++;; 727 ; 728 auto fXName = SaveArra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:22656,error,errors,22656,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////////////////; 17// //; 18// TSelector //; 19// //; 20// A utility class for Trees selections. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24 ; 25#include ""TObject.h""; 26#include ""TString.h""; 27#include ""TSelectorList.h""; 28 ; 29class TTree;; 30 ; 31class TSelector : public TObject {; 32 ; 33public:; 34 enum EAbort { kContinue, kAbortProcess, kAbortFile };; 35 ; 36protected:; 37 Long64_t fStatus; ///< Selector status; 38 EAbort fAbort; ///< Abort status; 39 TString fOption; ///< Option given to TTree::Process; 40 TObject *fObject; ///<! Current object if processing object (vs. TTree); 41 TList *fInput; ///< List of objects available during processing; 42 TSelectorList *fOutput; ///<! List of objects created during processing; 43 ; 44private:; 45 TSelector(const TSelector&); // not implemented; 46 TSelector& operator=(const TSelector&); // not implemented; 47 ; 48public:; 49 TSelector();; 50 ~TSelector() override;; 51 ; 52 virtual int Version() const { return 0; }; 53 virtual void Init(TTree *) { }; 54 virtual void Begin(TTree *) { }; 55 virtual void SlaveBegin(TTree *) { }; 56 bool Notify() override { return true; }; 57 const char *GetOption() const override { return fOption.Data(); }; 58 virtual Long64_t GetStatus() const { return fStatus; }; 59 virtual Int_t GetEntry(Long64_t /*entry*/, Int_t /*getall*/ = 0) { return 0; }; 60 virtual bool ProcessCut(Long64_t /*entry*/);; 61 virtual void ProcessFill(Long64_t /*entry*/);; 62 virtual bool Process(Long64_t /*entry*/);; 63 virtual void ImportOutput(TList *output);; 64 virtual void SetOption(const char *option) { fOption = option; }; 65 virtual void SetObject(TObject *obj) { fObject = obj; }; 66 virtual void SetInputList(TList *input) { fInput = input; }; 67 virtual void SetStatus(Long64_t status) { fStatus = status; }; 68 virtual TList *GetInputList() const { return fInput; }; 69 virtual TList *GetOutputList()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8h_source.html:1424,avail,available,1424,doc/master/TSelector_8h_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8h_source.html,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 68",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:24362,error,error,24362,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////////; 740/// Return the content of the filled bin number ""idx"".; 741/// If coord is non-null, it will contain the bin's coordinates for each axis; 742/// that correspond to the bin.; 743 ; 744Double_t THnSparse::GetBinContent(Long64_t idx, Int_t* coord /* = 0 */) const; 745{; 746 if (idx >= 0) {; 747 THnSparseArrayChunk* chunk = GetChunk(idx / fChunkSize);; 748 idx %= fChunkSize;; 749 if (chunk && chunk->fContent->GetSize() > idx) {; 750 if (coord) {; 751 THnSparseCompactBinCoord* cc = GetCompactCoord();; 752 Int_t sizeCompact = cc->GetBufferSize();; 753 cc->SetCoordFromBuffer(chunk->fCoordinates + idx * sizeCompact,; 754 coord);; 755 ; 756 }; 757 return chunk->fContent->GetAt(idx);; 758 }; 759 }; 760 if (coord); 761 memset(coord, -1, sizeof(Int_t) * fNdimensions);; 762 return 0.;; 763}; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Get square of the error of bin addressed by linidx as; 767/// \f$\sum weight^{2}\f$; 768/// If errors are not enabled (via Sumw2() or CalculateErrors()); 769/// return contents.; 770 ; 771Double_t THnSparse::GetBinError2(Long64_t linidx) const {; 772 if (!GetCalculateErrors()); 773 return GetBinContent(linidx);; 774 ; 775 if (linidx < 0) return 0.;; 776 THnSparseArrayChunk* chunk = GetChunk(linidx / fChunkSize);; 777 linidx %= fChunkSize;; 778 if (!chunk || chunk->fContent->GetSize() < linidx); 779 return 0.;; 780 ; 781 return chunk->fSumw2->GetAt(linidx);; 782}; 783 ; 784 ; 785////////////////////////////////////////////////////////////////////////////////; 786/// Return the index for fCurrentBinIndex.; 787/// If it doesn't exist then return -1, or allocate a new bin if allocate is set; 788 ; 789Long64_t THnSparse::GetBinIndexForCurrentBin(Bool_t allocate); 790{; 791 THnSparseCompactBinCoord* cc = GetCompactCoord();; 792 ULong64_t hash = cc->GetHash();; 793 if (fBinContent.GetSize() && !fBins.GetSize()); 794 FillExMap(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THnSparse_8cxx_source.html:28780,error,error,28780,doc/master/THnSparse_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THnSparse_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"////////////////////////////////////////////////////////////////////////; 91/// Assignment operator.; 92/// if needed copy the TFitResult object and delete previous one if existing; 93 ; 94TFitResultPtr & TFitResultPtr::operator=(const TFitResultPtr& rhs); 95{; 96 if ( &rhs == this) return *this; // self assignment; 97 fStatus = rhs.fStatus;; 98 fPointer = rhs.fPointer; ; 99 // if ( fPointer ) delete fPointer;; 100 // fPointer = 0;; 101 // if (rhs.fPointer != 0) fPointer = new TFitResult(*rhs);; 102 return *this;; 103}; 104 ; 105////////////////////////////////////////////////////////////////////////////////; 106/// Print the TFitResultPtr by printing its TFitResult.; 107 ; 108std::string cling::printValue(const TFitResultPtr* val) {; 109 if (TFitResult* fr = val->Get()); 110 return printValue(fr);; 111 return ""<nullptr TFitResult>"";; 112}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TFitResultPtr.h; TFitResult.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; TFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointe...Definition TFitResultPtr.h:32; TFitResultPtr::~TFitResultPtrvirtual ~TFitResultPtr()Destructor.Definition TFitResultPtr.cxx:55; TFitResultPtr::GetTFitResult * Get() constReturn contained pointer.Definition TFitResultPtr.cxx:86; TFitResultPtr::fPointerstd::shared_ptr< TFitResult > fPointer! Smart Pointer to TFitResult classDefinition TFitResultPtr.h:58; TFitResultPtr::fStatusint fStatusfit status codeDefinition TFitResultPtr.h:57; TFitResultPtr::operator*TFitResult & operator*() constImplement the de-reference operator to make the class acts as a pointer to a TFitResult assert in cas...Definition TFitResultPtr.cxx:63; TFitResultPtr::operator->TFitResult * operator->() constImplement the -> operator to make th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html:4230,error,error,4230,doc/master/TFitResultPtr_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFitResultPtr_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////////////; 298/// Default destructor.; 299 ; 300TLegend::~TLegend(); 301{; 302 if (fPrimitives); 303 fPrimitives->Delete();; 304 delete fPrimitives;; 305 fPrimitives = nullptr;; 306}; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Add a new entry to this legend. ""obj"" is the object to be represented.; 310/// ""label"" is the text you wish to associate with obj in the legend.; 311/// If ""label"" is null or empty, the title of the object will be used.; 312///; 313/// Options are:; 314///; 315/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 316/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 317/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 318/// - E: draw vertical error bar if option ""L"" is also specified; 319 ; 320TLegendEntry *TLegend::AddEntry(const TObject *obj, const char *label, Option_t *option); 321{; 322 const char *lab = label;; 323 ; 324 if (obj && (!label || strlen(label)==0)) lab = obj->GetTitle();; 325 TLegendEntry *newentry = new TLegendEntry( obj, lab, option );; 326 if ( !fPrimitives ) fPrimitives = new TList;; 327 fPrimitives->Add(newentry);; 328 return newentry;; 329}; 330 ; 331////////////////////////////////////////////////////////////////////////////////; 332/// Add a new entry to this legend. ""name"" is the name of an object in the pad to; 333/// be represented label is the text you wish to associate with obj in the legend; 334/// if label is null or empty, the title of the object will be used.; 335///; 336/// Options are:; 337///; 338/// - L: draw line associated with TAttLine if obj inherits from TAttLine; 339/// - P: draw polymarker associated with TAttMarker if obj inherits from TAttMarker; 340/// - F: draw a box with fill associated wit TAttFill if obj inherits TAttFill; 341/// - E: draw vertical error bar if option ""L"" is also specified; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLegend_8cxx_source.html:11431,error,error,11431,doc/master/TLegend_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLegend_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////; 149/// Almost the same as TClass::GetMethodWithPrototype().; 150 ; 151TMethod *GetMethodWithPrototype(TClass *cl, const char *method,; 152 const char *proto, Int_t &nargs); 153{; 154 nargs = 0;; 155 ; 156 if (!gInterpreter || cl == nullptr) return nullptr;; 157 ; 158 TMethod *m = cl->GetMethodWithPrototype(method,proto);; 159 if (m) nargs = m->GetNargs();; 160 return m;; 161}; 162 ; 163////////////////////////////////////////////////////////////////////////////////; 164/// Almost the same as TClass::GetMethod().; 165 ; 166static TMethod *GetMethod(TClass *cl, const char *method, const char *params); 167{; 168 if (!gInterpreter || cl == nullptr) return nullptr;; 169 return cl->GetMethod(method,params);; 170}; 171 ; 172}; 173 ; 174////////////////////////////////////////////////////////////////////////////////; 175/// Checking of consistency of sender/receiver methods/arguments.; 176/// Returns -1 on error, otherwise number or arguments of signal function.; 177/// Static method.; 178 ; 179Int_t TQObject::CheckConnectArgs(TQObject *sender,; 180 TClass *sender_class, const char *signal,; 181 TClass *receiver_class, const char *slot); 182{; 183 auto len = strlen(signal)+1;; 184 char *signal_method = new char[len];; 185 if (signal_method) strlcpy(signal_method, signal, len);; 186 ; 187 char *signal_proto;; 188 char *tmp;; 189 ; 190 if ((signal_proto = strchr(signal_method,'('))) {; 191 // substitute first '(' symbol with '\0'; 192 *signal_proto++ = '\0';; 193 // substitute last ')' symbol with '\0'; 194 if ((tmp = strrchr(signal_proto,')'))) *tmp = '\0';; 195 }; 196 ; 197 if (!signal_proto) signal_proto = (char*)""""; // avoid zero strings; 198 ; 199 // if delegation object TQObjSender is used get the real sender class; 200 if (sender && sender_class == TQObjSender::Class()) {; 201 sender_class = TClass::GetClass(sender->GetSenderClassName());; 202 if (!sender_class) {; 203 ::Error(""TQObject::CheckConnec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TQObject_8cxx_source.html:5757,error,error,5757,doc/master/TQObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TQObject_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////////////////////////; 3074/// Reset the interpreter internal state in case a previous action was not correctly; 3075/// terminated.; 3076 ; 3077void TCling::ClearFileBusy(); 3078{; 3079 // No-op there is not equivalent state (to be cleared) in Cling.; 3080}; 3081 ; 3082////////////////////////////////////////////////////////////////////////////////; 3083/// Delete existing temporary values.; 3084 ; 3085void TCling::ClearStack(); 3086{; 3087 // No-op for cling due to cling::Value.; 3088}; 3089 ; 3090////////////////////////////////////////////////////////////////////////////////; 3091/// Declare code to the interpreter, without any of the interpreter actions; 3092/// that could trigger a re-interpretation of the code. I.e. make cling; 3093/// behave like a compiler: no dynamic lookup, no input wrapping for; 3094/// subsequent execution, no automatic provision of declarations but just a; 3095/// plain `#include`.; 3096/// Returns true on success, false on failure.; 3097 ; 3098bool TCling::Declare(const char* code); 3099{; 3100 R__LOCKGUARD_CLING(gInterpreterMutex);; 3101 ; 3102 SuspendAutoLoadingRAII autoLoadOff(this);; 3103 SuspendAutoParsing autoParseRaii(this);; 3104 ; 3105 bool oldDynLookup = fInterpreter->isDynamicLookupEnabled();; 3106 fInterpreter->enableDynamicLookup(false);; 3107 bool oldRawInput = fInterpreter->isRawInputEnabled();; 3108 fInterpreter->enableRawInput(true);; 3109 ; 3110 Bool_t ret = LoadText(code);; 3111 ; 3112 fInterpreter->enableRawInput(oldRawInput);; 3113 fInterpreter->enableDynamicLookup(oldDynLookup);; 3114 return ret;; 3115}; 3116 ; 3117////////////////////////////////////////////////////////////////////////////////; 3118/// It calls a ""fantom"" method to synchronize user keyboard input; 3119/// and ROOT prompt line.; 3120 ; 3121void TCling::EndOfLineAction(); 3122{; 3123 ProcessLineSynch(fantomline);; 3124}; 3125 ; 3126// This static function is a hop of TCling::IsLibraryLoaded, which i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:119635,failure,failure,119635,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['failure'],['failure']
Availability,"//////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316 ; 5317void TH1::LabelsInflate(Option_t *ax); 5318{; 5319 Int_t iaxis = AxisChoice(ax);; 5320 TAxis *axis = nullptr;; 5321 if (iaxis == 1) axis = GetXaxis();; 5322 if (iaxis == 2) axis = GetYaxis();; 5323 if (iaxis == 3) axis = GetZaxis();; 5324 if (!axis) return;; 5325 ; 5326 TH1 *hold = (TH1*)IsA()->New();; 5327 hold->SetDirectory(nullptr);; 5328 Copy(*hold);; 5329 hold->ResetBit(kMustCleanup);; 5330 ; 5331 Bool_t timedisp = axis->GetTimeDisplay();; 5332 Int_t nbins = axis->GetNbins();; 5333 Double_t xmin = axis->GetXmin();; 5334 Double_t xmax = axis->GetXmax();; 5335 xmax = xmin + 2*(xmax-xmin);; 5336 axis->SetRange(0,0);; 5337 // double the bins and recompute ncells; 5338 axis->Set(2*nbins,xmin,xmax);; 5339 SetBinsLength(-1);; 5340 Int_t errors = fSumw2.fN;; 5341 if (errors) fSumw2.Set(fNcells);; 5342 axis->SetTimeDisplay(timedisp);; 5343 ; 5344 Reset(""ICE""); // reset content and error; 5345 ; 5346 //now loop on all bins and refill; 5347 Double_t oldEntries = fEntries;; 5348 Int_t bin,ibin,binx,biny,binz;; 5349 for (ibin =0; ibin < hold->fNcells; ibin++) {; 5350 // get the binx,y,z values . The x-y-z (axis) bin values will stay the same between new-old after the expanding; 5351 hold->GetBinXYZ(ibin,binx,biny,binz);; 5352 bin = GetBin(binx,biny,binz);; 5353 ; 5354 // underflow and overflow will be cleaned up because their meaning has been altered; 5355 if (hold->IsBinUnderflow(ibin,iaxis) || hold->IsBinOverflow(ibin,iaxis)) {; 5356 continue;; 5357 }; 5358 else {; 5359 AddBinContent(bin, hold->RetrieveBinContent(ibin));; 5360 if (errors) fSumw2.fArray[bin] += hold->fSumw2.fArray[ibin];; 5361 }; 5362 }; 5363 fEntries = oldEntries;; 5364 delete hold;; 5365}; 5366 ; 5367////////////////////////////////////////////////////////////////////////////////; 536",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:214644,error,errors,214644,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////////////; 1714/// Read a buffer from the file at the offset 'pos' in the file.; 1715///; 1716/// Returns kTRUE in case of failure.; 1717/// Compared to ReadBuffer(char*, Int_t), this routine does _not_; 1718/// change the cursor on the physical file representation (fD); 1719/// if the data is in this TFile's cache.; 1720 ; 1721Bool_t TFile::ReadBuffer(char *buf, Long64_t pos, Int_t len); 1722{; 1723 if (IsOpen()) {; 1724 ; 1725 SetOffset(pos);; 1726 ; 1727 Int_t st;; 1728 Double_t start = 0;; 1729 if (gPerfStats) start = TTimeStamp();; 1730 ; 1731 if ((st = ReadBufferViaCache(buf, len))) {; 1732 if (st == 2); 1733 return kTRUE;; 1734 return kFALSE;; 1735 }; 1736 ; 1737 Seek(pos);; 1738 ssize_t siz;; 1739 ; 1740 while ((siz = SysRead(fD, buf, len)) < 0 && GetErrno() == EINTR); 1741 ResetErrno();; 1742 ; 1743 if (siz < 0) {; 1744 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1745 return kTRUE;; 1746 }; 1747 if (siz != len) {; 1748 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1749 GetName(), (Long_t)siz, len);; 1750 return kTRUE;; 1751 }; 1752 fBytesRead += siz;; 1753 fgBytesRead += siz;; 1754 fReadCalls++;; 1755 fgReadCalls++;; 1756 ; 1757 if (gMonitoringWriter); 1758 gMonitoringWriter->SendFileReadProgress(this);; 1759 if (gPerfStats) {; 1760 gPerfStats->FileReadEvent(this, len, start);; 1761 }; 1762 return kFALSE;; 1763 }; 1764 return kTRUE;; 1765}; 1766 ; 1767////////////////////////////////////////////////////////////////////////////////; 1768/// Read a buffer from the file. This is the basic low level read operation.; 1769/// Returns kTRUE in case of failure.; 1770 ; 1771Bool_t TFile::ReadBuffer(char *buf, Int_t len); 1772{; 1773 if (IsOpen()) {; 1774 ; 1775 Int_t st;; 1776 if ((st = ReadBufferViaCache(buf, len))) {; 1777 if (st == 2); 1778 return kTRUE;; 1779 return kFALSE;; 1780 }; 1781 ; 1782 ssize_t siz;; 1783 Double_t start = 0;; 1784 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:63540,error,error,63540,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,2,['error'],['error']
Availability,/////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:7311,error,errors,7311,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////////////; 361/// Execute method on this object with the given parameter string, e.g.; 362/// ""3.14,1,\""text\"""".; 363 ; 364void TObject::Execute(const char *method, const char *params, Int_t *error); 365{; 366 if (!IsA()) return;; 367 ; 368 Bool_t must_cleanup = TestBit(kMustCleanup);; 369 ; 370 gInterpreter->Execute(this, IsA(), method, params, error);; 371 ; 372 if (gPad && must_cleanup) gPad->Modified();; 373}; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Execute method on this object with parameters stored in the TObjArray.; 377/// The TObjArray should contain an argv vector like:; 378/// ~~~ {.cpp}; 379/// argv[0] ... argv[n] = the list of TObjString parameters; 380/// ~~~; 381 ; 382void TObject::Execute(TMethod *method, TObjArray *params, Int_t *error); 383{; 384 if (!IsA()) return;; 385 ; 386 Bool_t must_cleanup = TestBit(kMustCleanup);; 387 ; 388 gInterpreter->Execute(this, IsA(), method, params, error);; 389 ; 390 if (gPad && must_cleanup) gPad->Modified();; 391}; 392 ; 393 ; 394////////////////////////////////////////////////////////////////////////////////; 395/// Execute action corresponding to an event at (px,py). This method; 396/// must be overridden if an object can react to graphics events.; 397 ; 398void TObject::ExecuteEvent(Int_t, Int_t, Int_t); 399{; 400 // AbstractMethod(""ExecuteEvent"");; 401}; 402 ; 403////////////////////////////////////////////////////////////////////////////////; 404/// Must be redefined in derived classes.; 405/// This function is typically used with TCollections, but can also be used; 406/// to find an object by name inside this object.; 407 ; 408TObject *TObject::FindObject(const char *) const; 409{; 410 return nullptr;; 411}; 412 ; 413////////////////////////////////////////////////////////////////////////////////; 414/// Must be redefined in derived classes.; 415/// This function is typically used with TColl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:13361,error,error,13361,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,2,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////////; 62/// Releases the resources associated to a file opened with davix; 63int VfsRdOnlyClose(sqlite3_file *pFile); 64{; 65 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 66 // We can't use delete because the storage for p is managed by sqlite; 67 p->~VfsRootFile();; 68 return SQLITE_OK;; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////; 72/// Issues a byte range request for a chunk to the raw file; 73int VfsRdOnlyRead(sqlite3_file *pFile, void *zBuf, int count, sqlite_int64 offset); 74{; 75 VfsRootFile *p = reinterpret_cast<VfsRootFile *>(pFile);; 76 auto nbytes = p->fRawFile->ReadAt(zBuf, count, offset);; 77 return (nbytes != static_cast<unsigned int>(count)) ? SQLITE_IOERR : SQLITE_OK;; 78}; 79 ; 80////////////////////////////////////////////////////////////////////////////; 81/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 82int VfsRdOnlyWrite(sqlite3_file * /*pFile*/, const void * /*zBuf*/, int /*iAmt*/, sqlite_int64 /*iOfst*/); 83{; 84 return SQLITE_OPEN_READONLY;; 85}; 86 ; 87////////////////////////////////////////////////////////////////////////////; 88/// We do not write to a database in the RDataSource and therefore can simply return an error for this callback; 89int VfsRdOnlyTruncate(sqlite3_file * /*pFile*/, sqlite_int64 /*size*/); 90{; 91 return SQLITE_OPEN_READONLY;; 92}; 93 ; 94////////////////////////////////////////////////////////////////////////////; 95/// As the database is read-only, syncing data to disc is a no-op and always succeeds; 96int VfsRdOnlySync(sqlite3_file * /*pFile*/, int /*flags*/); 97{; 98 return SQLITE_OK;; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////; 102/// Returns the cached file size; 103int VfsRdOnlyFileSize(sqlite3_file *pFile, sqlite_int64 *pSize); 104{; 105 VfsRootFile *p = reinterpret_cast<VfsRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:3970,error,error,3970,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////; 1594/// Sets pointer to data array provided by user.; 1595/// Necessary if SetFCN is not called.; 1596///; 1597/// - numpoints: number of experimental points; 1598/// - vecsize: size of data point vector + 2; 1599/// (for N-dimensional fit vecsize=N+2); 1600/// - exdata: data array with following format; 1601///; 1602/// - exdata[0] = ExpValue_0 - experimental data value number 0; 1603/// - exdata[1] = ExpSigma_0 - error of value number 0; 1604/// - exdata[2] = X_0[0]; 1605/// - exdata[3] = X_0[1]; 1606///; 1607/// - exdata[vecsize-1] = X_0[vecsize-3]; 1608/// - exdata[vecsize] = ExpValue_1; 1609/// - exdata[vecsize+1] = ExpSigma_1; 1610/// - exdata[vecsize+2] = X_1[0]; 1611///; 1612/// - exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1); 1613///; 1614/// - exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]; 1615 ; 1616void TFumili::SetData(Double_t *exdata,Int_t numpoints,Int_t vecsize){; 1617 if(exdata){; 1618 fNED1 = numpoints;; 1619 fNED2 = vecsize;; 1620 fEXDA = exdata;; 1621 }; 1622}; 1623 ; 1624 ; 1625////////////////////////////////////////////////////////////////////////////////; 1626/// ret fit method (chisquare or log-likelihood); 1627 ; 1628void TFumili::SetFitMethod(const char *name); 1629{; 1630 if (!strcmp(name,""H1FitChisquare"")) SetFCN(H1FitChisquareFumili);; 1631 if (!strcmp(name,""H1FitLikelihood"")) SetFCN(H1FitLikelihoodFumili);; 1632 if (!strcmp(name,""GraphFitChisquare"")) SetFCN(GraphFitChisquareFumili);; 1633}; 1634 ; 1635////////////////////////////////////////////////////////////////////////////////; 1636/// Sets for parameter number ipar initial parameter value,; 1637/// name parname, initial error verr and limits vlow and vhigh; 1638/// - If vlow = vhigh but not equal to zero, parameter will be fixed.; 1639/// - If vlow = vhigh = 0, parameter is released and its limits are discarded; 1640 ; 1641Int_t TFumili::SetParameter(Int_t ipar,const char *parname,Double_t va",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:45625,error,error,45625,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////////////////; 931/// Project this profile3D into a 3-D histogram along X,Y,Z.; 932///; 933/// The projection is always of the type TH3D.; 934///; 935/// - if option ""E"" is specified, the errors are computed. (default); 936/// - if option ""B"" is specified, the content of bin of the returned histogram; 937/// will be equal to the GetBinEntries(bin) of the profile,; 938/// - if option ""C=E"" the bin contents of the projection are set to the; 939/// bin errors of the profile; 940/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 941/// to be equal to the errors of the profile.; 942/// Option ""E"" is defined as the default one in the header file.; 943/// - if option """" is specified the histogram errors are simply the sqrt of its content; 944/// - if option ""B"" is specified, the content of bin of the returned histogram; 945/// will be equal to the GetBinEntries(bin) of the profile,; 946/// - if option ""C=E"" the bin contents of the projection are set to the; 947/// bin errors of the profile; 948/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 949/// product of the bin content of the profile and the entries.; 950/// With this option the returned histogram will be equivalent to the one obtained by; 951/// filling directly a TH2D using the 3-rd value as a weight.; 952/// This option makes sense only for profile filled with all weights =1.; 953/// When the profile is weighted (filled with weights different than 1) the; 954/// bin error of the projected histogram (obtained using this option ""W"") cannot be; 955/// correctly computed from the information stored in the profile. In that case the; 956/// obtained histogram contains as bin error square the weighted sum of the square of the; 957/// profiled observable (TProfile2D::fSumw2[bin] ); 958///; 959/// Note that the axis range is not considered when doing the projection; 960 ; 961TH3D *TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:33594,error,errors,33594,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,2,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and errors (if any) are scaled.; 6593/// This function uses the services of TH1::Add; 6594///; 6595/// IMPORTANT NOTE: Sumw2() is called automatically when scaling.; 6596/// If you are not interested in the histogram statistics you can call; 6597/// Sumw2(kFALSE) or use the option ""nosw2""; 6598///; 6599/// One can scale a histogram such that the bins integral is equal to; 6600/// the normalization parameter via TH1::Scale(Double_t norm), where norm; 6601/// is the desired normalization divided by the integral of the histogram.; 6602///; 6603/// If option contains ""width"" the bin contents and errors are divided; 6604/// by the bin width.; 6605 ; 6606void TH1::Scale(Double_t c1, Option_t *option); 6607{; 6608 ; 6609 TString opt = option; opt.ToLower();; 6610 // store bin errors when scaling since cannot anymore be computed as sqrt(N); 6611 if (!opt.Contains(""nosw2"") && GetSumw2N() == 0) Sumw2();; 6612 if (opt.Contains(""width"")) Add(this, this, c1, -1);; 6613 else {; 6614 if (fBuffer) BufferEmpty(1);; 6615 for(Int_t i = 0; i < fNcells; ++i) UpdateBinContent(i, c1 * RetrieveBinContent(i));; 6616 if (fSumw2.fN) for(Int_t i = 0; i < fNcells; ++i) fSumw2.fArray[i] *= (c1 * c1); // update errors; 6617 // update global histograms statistics; 6618 Double_t s[kNstat] = {0};; 6619 GetStats(s);; 6620 for (Int_t i=0 ; i < kNstat; i++) {; 6621 if (i == 1) s[i] = c1*c1*s[i];; 6622 else s[i] = c1*s[i];; 6623 }; 6624 PutStats(s);; 6625 SetMinimum(); SetMaximum(); // minimum and maximum value will be recalculated the next time; 6626 }; 6627 ; 6628 // if contours set, must also scale contours; 6629 Int_t ncontours = GetContour();; 6630 if (ncontours == 0) return;; 6631 Double_t* levels = fContour.GetArray();; 6632 for (Int_t i = 0; i < ncontours; ++i) levels[i] *= c1;; 6633}; 6634 ; 6635///////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:260343,error,errors,260343,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"//////////////////////////////////////////////////////////////////; 1046/// histogramming utility; 1047 ; 1048TString TMVA::Tools::GetYTitleWithUnit( const TH1& h, const TString& unit, Bool_t normalised ); 1049{; 1050 TString retval = ( normalised ? ""(1/N) "" : """" );; 1051 retval += TString::Format( ""dN_{ }/^{ }%.3g %s"", h.GetXaxis()->GetBinWidth(1), unit.Data() );; 1052 return retval;; 1053}; 1054 ; 1055////////////////////////////////////////////////////////////////////////////////; 1056/// writes a float value with the available precision to a stream; 1057 ; 1058void TMVA::Tools::WriteFloatArbitraryPrecision( Float_t val, ostream& os ); 1059{; 1060 os << val << "" :: "";; 1061 void * c = &val;; 1062 for (int i=0; i<4; i++) {; 1063 Int_t ic = *((char*)c+i)-'\0';; 1064 if (ic<0) ic+=256;; 1065 os << ic << "" "";; 1066 }; 1067 os << "":: "";; 1068}; 1069 ; 1070////////////////////////////////////////////////////////////////////////////////; 1071/// reads a float value with the available precision from a stream; 1072 ; 1073void TMVA::Tools::ReadFloatArbitraryPrecision( Float_t& val, istream& is ); 1074{; 1075 Float_t a = 0;; 1076 is >> a;; 1077 TString dn;; 1078 is >> dn;; 1079 Int_t c[4];; 1080 void * ap = &a;; 1081 for (int i=0; i<4; i++) {; 1082 is >> c[i];; 1083 *((char*)ap+i) = '\0'+c[i];; 1084 }; 1085 is >> dn;; 1086 val = a;; 1087}; 1088 ; 1089// XML file reading/writing helper functions; 1090 ; 1091////////////////////////////////////////////////////////////////////////////////; 1092/// add attribute from xml; 1093 ; 1094Bool_t TMVA::Tools::HasAttr( void* node, const char* attrname ); 1095{; 1096 return xmlengine().HasAttr(node, attrname);; 1097}; 1098 ; 1099////////////////////////////////////////////////////////////////////////////////; 1100/// add attribute from xml; 1101 ; 1102void TMVA::Tools::ReadAttr( void* node, const char* attrname, TString& value ); 1103{; 1104 if (!HasAttr(node, attrname)) {; 1105 const char * nodename = xmlengine().GetNodeName(node);; 11",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Tools_8cxx_source.html:36538,avail,available,36538,doc/master/Tools_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Tools_8cxx_source.html,2,['avail'],['available']
Availability,"/////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 210void TGraphBentErrors::Apply(TF1 *f); 211{; 212 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 213 ; 214 if (fHistogram) {; 215 delete fHistogram;; 216 fHistogram = nullptr;; 217 }; 218 for (Int_t i = 0; i < GetN(); i++) {; 219 GetPoint(i, x, y);; 220 exl = GetErrorXlow(i);; 221 exh = GetErrorXhigh(i);; 222 eyl = GetErrorYlow(i);; 223 eyh = GetErrorYhigh(i);; 224 ; 225 fxy = f->Eval(x, y);; 226 SetPoint(i, x, fxy);; 227 ; 228 // in the case of the functions like y-> -1*y the roles of the; 229 // upper and lower error bars is reversed; 230 if (f->Eval(x,y-eyl) < f->Eval(x,y+eyh)) {; 231 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 232 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 233 } else {; 234 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 235 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 236 }; 237 ; 238 //error on x doesn't change; 239 SetPointError(i,exl,exh,eyl_new,eyh_new);; 240 }; 241 if (gPad) gPad->Modified();; 242}; 243 ; 244 ; 245////////////////////////////////////////////////////////////////////////////////; 246/// Compute range.; 247 ; 248void TGraphBentErrors::ComputeRange(Double_t &xmin, Double_t &ymin, Double_t &xmax, Double_t &ymax) const; 249{; 250 TGraph::ComputeRange(xmin,ymin,xmax,ymax);; 251 ; 252 for (Int_t i=0;i<fNpoints;i++) {; 253 if (fX[i] -fEXlow[i] < xmin) {; 254 if (gPad && gPad->GetLogx()) {; 255 if (fEXlow[i] < fX[i]) xmin = fX[i]-fEXlow[i];; 256 else xmin = TMath::Min(xmin,fX[i]/3);; 257 } else {; 258 xmin = fX[i]-fEXlow[i];; 259 }; 260 }; 261 if (fX[i] +fEXh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:7672,error,error,7672,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,2,['error'],['error']
Availability,"/////////////////////////////////////////////////////////////////; 7455/// Let the interpreter issue a generic error, and set its error state.; 7456 ; 7457void TCling::GenericError(const char* error) const; 7458{; 7459#if defined(R__MUST_REVISIT); 7460#if R__MUST_REVISIT(6,2); 7461 Warning(""GenericError"",""Interface not available yet."");; 7462#endif; 7463#endif; 7464}; 7465 ; 7466////////////////////////////////////////////////////////////////////////////////; 7467/// This routines used to return the address of the internal wrapper; 7468/// function (of the interpreter) that was used to call *all* the; 7469/// interpreted functions that were bytecode compiled (no longer; 7470/// interpreted line by line). In Cling, there is no such; 7471/// wrapper function.; 7472/// In practice this routines was use to decipher whether the; 7473/// pointer returns by InterfaceMethod could be used to uniquely; 7474/// represent the function. In Cling if the function is in a; 7475/// useable state (its compiled version is available), this is; 7476/// always the case.; 7477/// See TClass::GetMethod.; 7478 ; 7479Long_t TCling::GetExecByteCode() const; 7480{; 7481 return 0;; 7482}; 7483 ; 7484////////////////////////////////////////////////////////////////////////////////; 7485/// Interface to cling function; 7486 ; 7487int TCling::GetSecurityError() const; 7488{; 7489#if defined(R__MUST_REVISIT); 7490#if R__MUST_REVISIT(6,2); 7491 Warning(""GetSecurityError"", ""Interface not available yet."");; 7492#endif; 7493#endif; 7494 return 0;; 7495}; 7496 ; 7497////////////////////////////////////////////////////////////////////////////////; 7498/// Load a source file or library called path into the interpreter.; 7499 ; 7500int TCling::LoadFile(const char* path) const; 7501{; 7502 // Modifying the interpreter state needs locking.; 7503 R__LOCKGUARD(gInterpreterMutex);; 7504 cling::Interpreter::CompilationResult compRes;; 7505 HandleInterpreterException(GetMetaProcessorImpl(), TString::Format("".L %s"",",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:291887,avail,available,291887,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avail'],['available']
Availability,"////////////////////////////////////////////////////////////////; 24 ; 25#include ""TApplication.h""; 26#include ""TString.h""; 27 ; 28class TFileHandler;; 29 ; 30 ; 31class TRint : public TApplication {; 32 ; 33private:; 34 Int_t fNcmd; // command history number; 35 TString fDefaultPrompt; // default prompt: ""root [%d] ""; 36 TString fNonContinuePrompt; // default prompt before continue prompt was set; 37 char fPrompt[64]; // interpreter prompt; 38 Bool_t fInterrupt; // if true macro execution will be stopped; 39 Int_t fCaughtSignal; // TRint just caught a signal; 40 TFileHandler *fInputHandler; // terminal input handler; 41 Bool_t fBackslashContinue{};// whether the last line ended with '\'; 42 ; 43 TRint(const TRint&) = delete;; 44 TRint& operator=(const TRint&) = delete;; 45 ; 46 void ExecLogon();; 47 Longptr_t ProcessRemote(const char *line, Int_t *error = nullptr) override;; 48 Longptr_t ProcessLineNr(const char* filestem, const char *line, Int_t *error = nullptr);; 49 ; 50public:; 51 TRint(const char *appClassName, Int_t *argc, char **argv, void *options = nullptr, Int_t numOptions = 0,; 52 Bool_t noLogo = kFALSE, Bool_t exitOnUnknownArgs = kFALSE);; 53 virtual ~TRint();; 54 virtual char *GetPrompt();; 55 virtual const char *SetPrompt(const char *newPrompt);; 56 void SetEchoMode(Bool_t mode) override;; 57 void HandleException(Int_t sig) override;; 58 Bool_t HandleTermInput() override;; 59 virtual void PrintLogo(Bool_t lite = kFALSE);; 60 void Run(Bool_t retrn = kFALSE) override;; 61 virtual void Terminate(int status) override;; 62 void Interrupt() { fInterrupt = kTRUE; }; 63 Int_t TabCompletionHook(char *buf, int *pLoc, std::ostream& out) override;; 64 ; 65 TFileHandler *GetInputHandler() { return fInputHandler; }; 66 ; 67 ClassDefOverride(TRint,0); //ROOT Interactive Application Interface; 68};; 69 ; 70#endif; Int_tint Int_tDefinition RtypesCore.h:45; Longptr_tlong Longptr_tDefinition RtypesCore.h:75; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8h_source.html:1783,error,error,1783,doc/master/TRint_8h_source.html,https://root.cern,https://root.cern/doc/master/TRint_8h_source.html,2,['error'],['error']
Availability,"///////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 481 memset(fEXlow + begin, 0, n);; 482 memset(fEXhigh + begin, 0, n);; 483 memset(fEYlow + begin, 0, n);; 484 memset(fEYhigh + begin, 0, n);; 485 memset(fEXlowd + begin, 0, n);; 486 memset(fEXhighd + begin, 0, n);; 487 memset(fEYlowd + begin, 0, n);; 488 memset(fEYhighd + begin, 0, n);; 489}; 490 ; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Print graph and errors values.; 494 ; 495void TGraphBentErrors::Print(Option_t *) const; 496{; 497 for (Int_t i=0;i<fNpoints;i++) {; 498 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 499 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 500 }; 501}; 502 ; 503////////////////////////////////////////////////////////////////////////////////; 504/// Multiply the values and errors of a TGraphBentErrors by a constant c1.; 505///; 506/// If option contains ""x"" the x values and errors are scaled; 507/// If option contains ""y"" the y values and errors are scaled; 508/// If option contains ""xy"" both x and y values and errors are scaled; 509 ; 510void TGraphBentErrors::Scale(Double_t c1, Option_t *option); 511{; 512 TGraph::Scale(c1, option);; 513 TString opt = option; opt.ToLower();; 514 if (opt.Contains(""x"") && GetEXlow()) {; 515 for (Int_t i=0; i<GetN(); i++); 516 GetEXlow()[i] *= c1;; 517 }; 518 if (opt.Contains(""x"") && GetEXhigh()) {; 519 for (Int_t i=0; i<GetN(); i++); 520 GetEXhigh()[i] *= c1;; 521 }; 522 if (opt.Contains(""y"") && GetEYlow()) {; 523 for (Int_t i=0; i<GetN(); i++); 524 GetEYlow()[i] *= c1;; 525 }; 526 if (opt.Contains(""y"") && GetEYhigh()) {; 527 for (Int_t i=0; i<GetN()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:16512,error,errors,16512,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//////////////////////////////////////////////////////////////; 737/// Returns `x` raised to the power `y`.; 738 ; 739inline Double_t TMath::Power(Double_t x, Double_t y); 740 { return pow(x, y); }; 741 ; 742////////////////////////////////////////////////////////////////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:28736,mask,mask,28736,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['mask'],['mask']
Availability,"/////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 162",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54563,error,errors,54563,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////; 3566/// Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable `obs`.; 3567/// \param[in] obs Observable to retrieve sampling hint for.; 3568/// \param[in] xlo Beginning of range.; 3569/// \param[in] xhi End of range.; 3570/// \return The caller owns the returned std::list.; 3571std::list<double>* RooAbsReal::plotSamplingHint(RooAbsRealLValue& /*obs*/, double /*xlo*/, double /*xhi*/) const {; 3572 return nullptr;; 3573}; 3574 ; 3575////////////////////////////////////////////////////////////////////////////////; 3576/// Print all outstanding logged evaluation error on the given ostream. If maxPerNode; 3577/// is zero, only the number of errors for each source (object with unique name) is listed.; 3578/// If maxPerNode is greater than zero, up to maxPerNode detailed error messages are shown; 3579/// per source of errors. A truncation message is shown if there were more errors logged; 3580/// than shown.; 3581 ; 3582void RooAbsReal::printEvalErrors(std::ostream &os, Int_t maxPerNode); 3583{; 3584 if (evalErrorData().mode == CountErrors) {; 3585 os << evalErrorData().count << "" errors counted"" << std::endl;; 3586 }; 3587 ; 3588 if (maxPerNode < 0); 3589 return;; 3590 ; 3591 for (auto const &item : evalErrorData().errorList) {; 3592 if (maxPerNode == 0) {; 3593 ; 3594 // Only print node name with total number of errors; 3595 os << item.second.first;; 3596 // item.first->printStream(os,kName|kClassName|kArgs,kInline) ;; 3597 os << "" has "" << item.second.second.size() << "" errors"" << std::endl;; 3598 ; 3599 } else {; 3600 ; 3601 // Print node name and details of 'maxPerNode' errors; 3602 os << item.second.first << std::endl;; 3603 // item.first->printStream(os,kName|kClassName|kArgs,kSingleLine) ;; 3604 ; 3605 Int_t i(0);; 3606 for (auto const &item2 : item.second.second) {; 3607 os << "" "" << item2._msg << "" @ "" << item2._srvval << std::endl;; 360",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:153251,error,errors,153251,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////////////////////////////////////; 87/// Create new canvas instance; 88 ; 89std::shared_ptr<ROOT::Experimental::RCanvas> ROOT::Experimental::RCanvas::Create(const std::string &title); 90{; 91 auto pCanvas = std::make_shared<RCanvas>();; 92 pCanvas->SetTitle(title);; 93 {; 94 std::lock_guard<std::mutex> grd(GetHeldCanvasesMutex());; 95 GetHeldCanvases().emplace_back(pCanvas);; 96 }; 97 ; 98 return pCanvas;; 99}; 100 ; 101//////////////////////////////////////////////////////////////////////////; 102/// Create new display for the canvas; 103/// The parameter `where` specifies which program could be used for display creation; 104/// Possible values:; 105///; 106/// - `cef` Chromium Embeded Framework, local display, local communication; 107/// - `qt5` Qt5 WebEngine (when running via rootqt5), local display, local communication; 108/// - `browser` default system web-browser, communication via random http port from range 8800 - 9800; 109/// - `<prog>` any program name which will be started instead of default browser, like firefox or /usr/bin/opera; 110/// one could also specify $url in program name, which will be replaced with canvas URL; 111/// - `native` either any available local display or default browser; 112///; 113/// Canvas can be displayed in several different places; 114 ; 115void ROOT::Experimental::RCanvas::Show(const std::string &where); 116{; 117 fShown = true;; 118 ; 119 // Do not display canvas in batch mode; 120 if (gROOT->IsWebDisplayBatch()); 121 return;; 122 ; 123 if (fPainter) {; 124 bool isany = (fPainter->NumDisplays() > 0);; 125 ; 126 if (!where.empty()); 127 fPainter->NewDisplay(where);; 128 ; 129 if (isany) return;; 130 }; 131 ; 132 if (!fModified); 133 fModified = 1; // 0 is special value, means no changes and no drawings; 134 ; 135 if (!fPainter); 136 fPainter = Internal::RVirtualCanvasPainter::Create(*this);; 137 ; 138 if (fPainter) {; 139 fPainter->NewDisplay(where);; 140 fPainter->CanvasUpdated(fModified, true, nul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:3905,avail,available,3905,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['avail'],['available']
Availability,////////////////////////////////////////////////////////////; 2335const Ranking *TMVA::MethodDL::CreateRanking(); 2336{; 2337 // TODO; 2338 return NULL;; 2339}; 2340 ; 2341////////////////////////////////////////////////////////////////////////////////; 2342void MethodDL::GetHelpMessage() const; 2343{; 2344 // TODO; 2345}; 2346 ; 2347} // namespace TMVA; Adadelta.h; Adagrad.h; Adam.h; ClassifierFactory.h; REGISTER_METHOD#define REGISTER_METHOD(CLASS)for exampleDefinition ClassifierFactory.h:124; Configurable.h; Cuda.h; DLMinimizers.h; IMethod.h; MethodDL.h; RMSProp.h; e#define e(i)Definition RSha256.hxx:103; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; ClassImp#define ClassImp(name)Definition Rtypes.h:382; SGD.h; TCudnn.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:94382,error,error,94382,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////; 239/// TGraphMultiErrors normal constructor with name, title, `np` points and `ne` y-errors.; 240///; 241/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 242/// The multiple y-errors are passed as std::vectors of std::vectors.; 243 ; 244TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x,; 245 const Float_t *y, const Float_t *exL, const Float_t *exH,; 246 std::vector<std::vector<Float_t>> eyL, std::vector<std::vector<Float_t>> eyH,; 247 Int_t m); 248 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 249{; 250 SetNameTitle(name, title);; 251}; 252 ; 253////////////////////////////////////////////////////////////////////////////////; 254/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 255///; 256/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 257/// The multiple y-errors are passed as std::vectors of std::vectors.; 258 ; 259TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL,; 260 const Double_t *exH, std::vector<std::vector<Double_t>> eyL,; 261 std::vector<std::vector<Double_t>> eyH, Int_t m); 262 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 263{; 264 if (!CtorAllocate()); 265 return;; 266 ; 267 Int_t n = fNpoints * sizeof(Double_t);; 268 ; 269 if (exL); 270 memcpy(fExL, exL, n);; 271 else; 272 memset(fExL, 0, n);; 273 if (exH); 274 memcpy(fExH, exH, n);; 275 else; 276 memset(fExH, 0, n);; 277 ; 278 for (Int_t i = 0; i < fNpoints; i++) {; 279 for (Int_t j = 0; j < fNYErrors; j++) {; 280 if (Int_t(eyL.size()) > j && Int_t(eyL[j].size()) > i); 281 fEyL[j][i] = eyL[j][i];; 282 else; 283 fEyL[j][i] = 0.;; 284 if (Int_t(eyH.size()) > j && Int_t(eyH[j].size()) > i); 285 fEyH[j][i] = eyH[j][i];; 286 else; 287 fEyH[j][i] = 0.;; 288 }; 289 }; 290 ; 291 CalcYErrorsSum();; 292}; 293 ; 294/////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:9305,error,errors,9305,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////////////////////////////; 5276 ; 5277void TCling::Execute(TObject* obj, TClass* cl, const char* method,; 5278 const char* params, int* error); 5279{; 5280 Execute(obj,cl,method,params,false,error);; 5281}; 5282 ; 5283////////////////////////////////////////////////////////////////////////////////; 5284/// Execute a method from class cl with the arguments in array params; 5285/// (params[0] ... params[n] = array of TObjString parameters).; 5286/// Convert the TObjArray array of TObjString parameters to a character; 5287/// string of comma separated parameters.; 5288/// The parameters of type 'char' are enclosed in double quotes and all; 5289/// internal quotes are escaped.; 5290 ; 5291void TCling::Execute(TObject* obj, TClass* cl, TMethod* method,; 5292 TObjArray* params, int* error); 5293{; 5294 if (!method) {; 5295 Error(""Execute"", ""No method was defined"");; 5296 return;; 5297 }; 5298 TList* argList = method->GetListOfMethodArgs();; 5299 // Check number of actual parameters against of expected formal ones; 5300 ; 5301 Int_t nparms = argList->LastIndex() + 1;; 5302 Int_t argc = params ? params->GetEntries() : 0;; 5303 ; 5304 if (argc > nparms) {; 5305 Error(""Execute"",""Too many parameters to call %s, got %d but expected at most %d."",method->GetName(),argc,nparms);; 5306 return;; 5307 }; 5308 if (nparms != argc) {; 5309 // Let's see if the 'missing' argument are all defaulted.; 5310 // if nparms==0 then either we stopped earlier either argc is also zero and we can't reach here.; 5311 assert(nparms > 0);; 5312 ; 5313 TMethodArg *arg = (TMethodArg *) argList->At( 0 );; 5314 if (arg && arg->GetDefault() && arg->GetDefault()[0]) {; 5315 // There is a default value for the first missing; 5316 // argument, so we are fine.; 5317 } else {; 5318 Int_t firstDefault = -1;; 5319 for (Int_t i = 0; i < nparms; i ++) {; 5320 arg = (TMethodArg *) argList->At( i );; 5321 if (arg && arg->GetDefault() && arg->GetDefault()[0]) {; 5322 firstDefault = i;;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:206240,error,error,206240,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////; 915/// Add a new y error to the graph and fill it with the values from `eyL` and `eyH`; 916 ; 917void TGraphMultiErrors::AddYError(Int_t np, const Double_t *eyL, const Double_t *eyH); 918{; 919 fEyL.emplace_back(np, eyL);; 920 fEyH.emplace_back(np, eyH);; 921 fEyL.back().Set(fNpoints);; 922 fEyH.back().Set(fNpoints);; 923 fAttFill.emplace_back();; 924 fAttLine.emplace_back();; 925 ; 926 fNYErrors += 1;; 927 ; 928 CalcYErrorsSum();; 929}; 930 ; 931////////////////////////////////////////////////////////////////////////////////; 932/// Allocate internal data structures for `size` points.; 933Double_t **TGraphMultiErrors::Allocate(Int_t size); 934{; 935 return AllocateArrays(6, size);; 936}; 937 ; 938////////////////////////////////////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // sy",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:32715,error,error,32715,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////////; 971/// Reduce the number of bins for this axis to the number of bins having a label.; 972 ; 973void TProfile::LabelsDeflate(Option_t *option); 974{; 975 TProfileHelper::LabelsDeflate(this, option);; 976}; 977 ; 978////////////////////////////////////////////////////////////////////////////////; 979/// Double the number of bins for axis.; 980/// Refill histogram; 981/// This function is called by TAxis::FindBin(const char *label); 982 ; 983void TProfile::LabelsInflate(Option_t *options); 984{; 985 TProfileHelper::LabelsInflate(this, options);; 986}; 987 ; 988////////////////////////////////////////////////////////////////////////////////; 989/// Set option(s) to draw axis with labels.; 990///; 991/// option might have the following values:; 992///; 993/// - ""a"" sort by alphabetic order; 994/// - "">"" sort by decreasing values; 995/// - ""<"" sort by increasing values; 996/// - ""h"" draw labels horizontal; 997/// - ""v"" draw labels vertical; 998/// - ""u"" draw labels up (end of label right adjusted); 999/// - ""d"" draw labels down (start of label left adjusted); 1000 ; 1001void TProfile::LabelsOption(Option_t *option, Option_t * /*ax */); 1002{; 1003 THashList *labels = fXaxis.GetLabels();; 1004 if (!labels) {; 1005 Warning(""LabelsOption"",""Cannot sort. No labels"");; 1006 return;; 1007 }; 1008 TString opt = option;; 1009 opt.ToLower();; 1010 if (opt.Contains(""h"")) {; 1011 fXaxis.SetBit(TAxis::kLabelsHori);; 1012 fXaxis.ResetBit(TAxis::kLabelsVert);; 1013 fXaxis.ResetBit(TAxis::kLabelsDown);; 1014 fXaxis.ResetBit(TAxis::kLabelsUp);; 1015 }; 1016 if (opt.Contains(""v"")) {; 1017 fXaxis.SetBit(TAxis::kLabelsVert);; 1018 fXaxis.ResetBit(TAxis::kLabelsHori);; 1019 fXaxis.ResetBit(TAxis::kLabelsDown);; 1020 fXaxis.ResetBit(TAxis::kLabelsUp);; 1021 }; 1022 if (opt.Contains(""u"")) {; 1023 fXaxis.SetBit(TAxis::kLabelsUp);; 1024 fXaxis.ResetBit(TAxis::kLabelsVert);; 1025 fXaxis.ResetBit(TAxis::kLabelsDown);; 1026 fXaxis.ResetBit(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:36972,down,down,36972,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['down'],['down']
Availability,"//////////////////////////////////////////////////////////; 1875/// Expand a pathname getting rid of special shell characaters like ~.$, etc.; 1876/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1877/// environment variables in a pathname. If compatibility is not an issue; 1878/// you can use on Unix directly $XXX. The user must delete returned string.; 1879/// Returns the expanded pathname or 0 in case of error.; 1880/// The user must delete returned string (delete []).; 1881 ; 1882char *TUnixSystem::ExpandPathName(const char *path); 1883{; 1884 TString patbuf = path;; 1885 if (ExpandPathName(patbuf)); 1886 return nullptr;; 1887 return StrDup(patbuf.Data());; 1888}; 1889 ; 1890////////////////////////////////////////////////////////////////////////////////; 1891/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1892 ; 1893int TUnixSystem::Chmod(const char *file, UInt_t mode); 1894{; 1895 return ::chmod(file, mode);; 1896}; 1897 ; 1898////////////////////////////////////////////////////////////////////////////////; 1899/// Set the process file creation mode mask.; 1900 ; 1901int TUnixSystem::Umask(Int_t mask); 1902{; 1903 return ::umask(mask);; 1904}; 1905 ; 1906////////////////////////////////////////////////////////////////////////////////; 1907/// Set a files modification and access times. If actime = 0 it will be; 1908/// set to the modtime. Returns 0 on success and -1 in case of error.; 1909 ; 1910int TUnixSystem::Utime(const char *file, Long_t modtime, Long_t actime); 1911{; 1912 if (!actime); 1913 actime = modtime;; 1914 ; 1915 struct utimbuf t;; 1916 t.actime = (time_t)actime;; 1917 t.modtime = (time_t)modtime;; 1918 return ::utime(file, &t);; 1919}; 1920 ; 1921////////////////////////////////////////////////////////////////////////////////; 1922/// Find location of file ""wfil"" in a search path.; 1923/// The search path is specified as a : separated list of directories.; 1924/// Return value is pointing to wfi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:58365,mask,mask,58365,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['mask'],['mask']
Availability,//////////////////////////////////////////////////////////; 2403/// Assign a given node to be checked for overlaps. Any other overlaps will be ignored.; 2404 ; 2405void TGeoManager::SetCheckedNode(TGeoNode *node); 2406{; 2407 GetGeomPainter()->SetCheckedNode(node);; 2408}; 2409 ; 2410////////////////////////////////////////////////////////////////////////////////; 2411/// Set the number of points to be generated on the shape outline when checking; 2412/// for overlaps.; 2413 ; 2414void TGeoManager::SetNmeshPoints(Int_t npoints); 2415{; 2416 GetGeomPainter()->SetNmeshPoints(npoints);; 2417}; 2418 ; 2419////////////////////////////////////////////////////////////////////////////////; 2420/// set drawing mode :; 2421/// - option=0 (default) all nodes drawn down to vislevel; 2422/// - option=1 leaves and nodes at vislevel drawn; 2423/// - option=2 path is drawn; 2424/// - option=4 visibility changed; 2425 ; 2426void TGeoManager::SetVisOption(Int_t option); 2427{; 2428 if ((option >= 0) && (option < 3)); 2429 fVisOption = option;; 2430 if (fPainter); 2431 fPainter->SetVisOption(option);; 2432}; 2433 ; 2434////////////////////////////////////////////////////////////////////////////////; 2435/// Set visualization option (leaves only OR all volumes); 2436 ; 2437void TGeoManager::ViewLeaves(Bool_t flag); 2438{; 2439 if (flag); 2440 SetVisOption(1);; 2441 else; 2442 SetVisOption(0);; 2443}; 2444 ; 2445////////////////////////////////////////////////////////////////////////////////; 2446/// Set density threshold. Volumes with densities lower than this become; 2447/// transparent.; 2448 ; 2449void TGeoManager::SetVisDensity(Double_t density); 2450{; 2451 fVisDensity = density;; 2452 if (fPainter); 2453 fPainter->ModifiedPad();; 2454}; 2455 ; 2456////////////////////////////////////////////////////////////////////////////////; 2457/// set default level down to which visualization is performed; 2458 ; 2459void TGeoManager::SetVisLevel(Int_t level); 2460{; 2461 if (level > 0) {; 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:86774,down,down,86774,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['down'],['down']
Availability,"/////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 490 eyh_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 491 } else {; 492 eyh_new = TMath::Abs(fxy - f->Eval(x,y-eyl));; 493 eyl_new = TMath::Abs(f->Eval(x,y+eyh) - fxy);; 494 }; 495 ; 496 //error on x doesn't change; 497 SetPointError(i,exl,exh,eyl_new,eyh_new);; 498 }; 499 if (gPad) gPad->Modified();; 500}; 501 ; 502////////////////////////////////////////////////////////////////////////////////; 503///This function is only kept for backward compatibility.; 504///You should rather use the Divide method.; 505///It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 506///former BayesDivide method.; 507 ; 508void TGraphAsymmErrors::BayesDivide(const TH1* pass, const TH1* total, Option_t *); 509{; 510 Divide(pass,total,""cl=0.683 b(1,1) mode"");; 511}; 512 ; 513////////////////////////////////////////////////////////////////////////////////; 514/// Fill this TGraphAsymmErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:16829,error,error,16829,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,2,['error'],['error']
Availability,"////////////////////////////////////////////////////////; 4061/// Perform a \f$ \chi^2 \f$ fit to given histogram. By default the fit is executed through the MINUIT; 4062/// commands MIGRAD, HESSE in succession; 4063///; 4064/// The following named arguments are supported; 4065///; 4066/// <table>; 4067/// <tr><th> <th> Options to control construction of chi2; 4068/// <tr><td> `Extended(bool flag)` <td> **Only applicable when fitting a RooAbsPdf**. Scale the normalized pdf by the number of events predicted by the model instead of scaling by the total data weight.; 4069/// This imposes a constraint on the predicted number of events analogous to the extended term in a likelihood fit.; 4070/// - If you don't pass this command, an extended fit will be done by default if the pdf makes a prediction on the number of events; 4071/// (in RooFit jargon, ""if the pdf can be extended"").; 4072/// - Passing `Extended(true)` when the the pdf makes no prediction on the expected number of events will result in error messages,; 4073/// and the chi2 will fall back to the total data weight to scale the normalized pdf.; 4074/// - There are cases where the fit **must** be done in extended mode. This happens for example when you have a RooAddPdf; 4075/// where the coefficients represent component yields. If the fit is not extended, these coefficients will not be; 4076/// well-defined, as the RooAddPdf always normalizes itself. If you pass `Extended(false)` in such a case, an error will be; 4077/// printed and you'll most likely get garbage results.; 4078/// <tr><td> `Range(const char* name)` <td> Fit only data inside range with given name; 4079/// <tr><td> `Range(double lo, double hi)` <td> Fit only data inside given range. A range named ""fit"" is created on the fly on all observables.; 4080/// Multiple comma separated range names can be specified.; 4081/// <tr><td> `NumCPU(int num)` <td> Parallelize NLL calculation on num CPUs; 4082/// <tr><td> `Optimize(bool flag)` <td> Activate constant ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:176493,error,error,176493,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////; 414/// It returns the error along Y at point `i`.; 415 ; 416Double_t TGraphBentErrors::GetErrorY(Int_t i) const; 417{; 418 if (i < 0 || i >= fNpoints) return -1;; 419 if (!fEYlow && !fEYhigh) return -1;; 420 Double_t elow=0, ehigh=0;; 421 if (fEYlow) elow = fEYlow[i];; 422 if (fEYhigh) ehigh = fEYhigh[i];; 423 return TMath::Sqrt(0.5*(elow*elow + ehigh*ehigh));; 424}; 425 ; 426 ; 427////////////////////////////////////////////////////////////////////////////////; 428/// Get high error on X[i].; 429 ; 430Double_t TGraphBentErrors::GetErrorXhigh(Int_t i) const; 431{; 432 if (i<0 || i>fNpoints) return -1;; 433 if (fEXhigh) return fEXhigh[i];; 434 return -1;; 435}; 436 ; 437 ; 438////////////////////////////////////////////////////////////////////////////////; 439/// Get low error on X[i].; 440 ; 441Double_t TGraphBentErrors::GetErrorXlow(Int_t i) const; 442{; 443 if (i<0 || i>fNpoints) return -1;; 444 if (fEXlow) return fEXlow[i];; 445 return -1;; 446}; 447 ; 448 ; 449////////////////////////////////////////////////////////////////////////////////; 450/// Get high error on Y[i].; 451 ; 452Double_t TGraphBentErrors::GetErrorYhigh(Int_t i) const; 453{; 454 if (i<0 || i>fNpoints) return -1;; 455 if (fEYhigh) return fEYhigh[i];; 456 return -1;; 457}; 458 ; 459 ; 460////////////////////////////////////////////////////////////////////////////////; 461/// Get low error on Y[i].; 462 ; 463Double_t TGraphBentErrors::GetErrorYlow(Int_t i) const; 464{; 465 if (i<0 || i>fNpoints) return -1;; 466 if (fEYlow) return fEYlow[i];; 467 return -1;; 468}; 469 ; 470 ; 471////////////////////////////////////////////////////////////////////////////////; 472/// Set zero values for point arrays in the range `[begin, end]`; 473 ; 474void TGraphBentErrors::FillZero(Int_t begin, Int_t end,; 475 Bool_t from_ctor); 476{; 477 if (!from_ctor) {; 478 TGraph::FillZero(begin, end, from_ctor);; 479 }; 480 Int_t n = (end - begin)*sizeof(Double_t);; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:14824,error,error,14824,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////////////; 717/// Terminate the application. Reset the terminal to sane mode and call; 718/// the logoff macro defined via Rint.Logoff environment variable.; 719/// @note The function does not return, unless the class has; 720/// been told to return from Run(), by a call to SetReturnFromRun().; 721 ; 722void TRint::Terminate(Int_t status); 723{; 724 Getlinem(kCleanUp, nullptr);; 725 ; 726 if (ReturnFromRun()) {; 727 gSystem->ExitLoop();; 728 } else {; 729 delete gTabCom;; 730 gTabCom = nullptr;; 731 ; 732 //Execute logoff macro; 733 const char *logoff;; 734 logoff = gEnv->GetValue(""Rint.Logoff"", (char*)nullptr);; 735 if (logoff && !NoLogOpt()) {; 736 char *mac = gSystem->Which(TROOT::GetMacroPath(), logoff, kReadPermission);; 737 if (mac); 738 ProcessFile(logoff);; 739 delete [] mac;; 740 }; 741 ; 742 TApplication::Terminate(status);; 743 }; 744}; 745 ; 746////////////////////////////////////////////////////////////////////////////////; 747/// Set console mode:; 748///; 749/// mode = kTRUE - echo input symbols; 750/// mode = kFALSE - noecho input symbols; 751 ; 752void TRint::SetEchoMode(Bool_t mode); 753{; 754 Gl_config(""noecho"", mode ? 0 : 1);; 755}; 756 ; 757////////////////////////////////////////////////////////////////////////////////; 758/// Process the content of a line starting with "".R"" (already stripped-off); 759/// The format is; 760/// [user@]host[:dir] [-l user] [-d dbg] [script]; 761/// The variable 'dir' is the remote directory to be used as working dir.; 762/// The username can be specified in two ways, ""-l"" having the priority; 763/// (as in ssh).; 764/// A 'dbg' value > 0 gives increasing verbosity.; 765/// The last argument 'script' allows to specify an alternative script to; 766/// be executed remotely to startup the session.; 767 ; 768Longptr_t TRint::ProcessRemote(const char *line, Int_t *); 769{; 770 Longptr_t ret = TApplication::ProcessRemote(line);; 771 ; 772 if (ret == 1) {; 773 if (fAppRemote) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRint_8cxx_source.html:25506,echo,echo,25506,doc/master/TRint_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRint_8cxx_source.html,1,['echo'],['echo']
Availability,"//////////////////////////////////////////////////////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:10593,mask,masks,10593,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['mask'],['masks']
Availability,"//////////////////////////////////////////////////////; 374 /// Add a forward declaration request.; 375 ; 376 void TTreeProxyGenerator::AddPragma(const char *pragma_text); 377 {; 378 TIter i( &fListOfPragmas );; 379 for(TObjString *n = (TObjString*) i(); n; n = (TObjString*)i() ) {; 380 if (pragma_text == n->GetString()) {; 381 return;; 382 }; 383 }; 384 ; 385 fListOfPragmas.Add( new TObjString( pragma_text ) );; 386 ; 387 }; 388 ; 389 ////////////////////////////////////////////////////////////////////////////////; 390 /// Add a branch descriptor.; 391 ; 392 void TTreeProxyGenerator::AddDescriptor(TBranchProxyDescriptor *desc); 393 {; 394 if (desc) {; 395 TBranchProxyDescriptor *existing =; 396 (TBranchProxyDescriptor*)((*fCurrentListOfTopProxies)(desc->GetName()));; 397 if (existing) {; 398 Warning(""TTreeProxyGenerator"",""The branch name \""%s\"" is duplicated. Only the first instance \n""; 399 ""\twill be available directly. The other instance(s) might be available via their complete name\n""; 400 ""\t(including the name of their mother branche's name)."",desc->GetName());; 401 } else {; 402 fCurrentListOfTopProxies->Add(desc);; 403 UInt_t len = strlen(desc->GetTypeName());; 404 if ((len+2)>fMaxDatamemberType) fMaxDatamemberType = len+2;; 405 }; 406 }; 407 }; 408 ; 409 ////////////////////////////////////////////////////////////////////////////////; 410 /// Generate an enum for a given type if it is not known in the list of class; 411 /// unless the type itself a template.; 412 ; 413 void TTreeProxyGenerator::AddMissingClassAsEnum(const char *clname, bool isscope); 414 {; 415 if (!TClassEdit::IsStdClass(clname) && !TClass::GetClass(clname) && gROOT->GetType(clname) == nullptr) {; 416 ; 417 TObject *obj = fListOfForwards.FindObject(clname);; 418 if (obj) return;; 419 ; 420 // The class does not exist, let's create it if ew can.; 421 if (clname[strlen(clname)-1]=='>') {; 422 // Template instantiation.; 423 fListOfForwards.Add(new TNamed(clname,TString::Format(""template <> c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html:11997,avail,available,11997,doc/master/TTreeProxyGenerator_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreeProxyGenerator_8cxx_source.html,1,['avail'],['available']
Availability,"/////////////////////////////////////////////////////; 1217/// Calculates the boundaries using the mid-P binomial; 1218/// interval (Lancaster method) from B. Cousing and J. Tucker.; 1219/// See http://arxiv.org/abs/0905.3831 for a description and references for the method; 1220///; 1221/// Modify equal_tailed to get the kind of interval you want.; 1222/// Can also be converted to interval on ratio of poisson means X/Y by the substitutions; 1223/// ~~~ {.cpp}; 1224/// X = passed; 1225/// total = X + Y; 1226/// lower_poisson = lower/(1 - lower); 1227/// upper_poisson = upper/(1 - upper); 1228/// ~~~; 1229 ; 1230Double_t TEfficiency::MidPInterval(Double_t total,Double_t passed,Double_t level,Bool_t bUpper); 1231{; 1232 const double alpha = 1. - level;; 1233 const bool equal_tailed = true; // change if you don;t want equal tailed interval; 1234 const double alpha_min = equal_tailed ? alpha/2 : alpha;; 1235 const double tol = 1e-9; // tolerance; 1236 double pmin = 0;; 1237 double pmax = 0;; 1238 double p = 0;; 1239 ; 1240 pmin = 0; pmax = 1;; 1241 ; 1242 ; 1243 // treat special case for 0<passed<1; 1244 // do a linear interpolation of the upper limit values; 1245 if ( passed > 0 && passed < 1) {; 1246 double p0 = MidPInterval(total,0.0,level,bUpper);; 1247 double p1 = MidPInterval(total,1.0,level,bUpper);; 1248 p = (p1 - p0) * passed + p0;; 1249 return p;; 1250 }; 1251 ; 1252 while (std::abs(pmax - pmin) > tol) {; 1253 p = (pmin + pmax)/2;; 1254 //double v = 0.5 * ROOT::Math::binomial_pdf(int(passed), p, int(total));; 1255 // make it work for non integer using the binomial - beta relationship; 1256 double v = 0.5 * ROOT::Math::beta_pdf(p, passed+1., total-passed+1)/(total+1);; 1257 //if (passed > 0) v += ROOT::Math::binomial_cdf(int(passed - 1), p, int(total));; 1258 // compute the binomial cdf at passed -1; 1259 if ( (passed-1) >= 0) v += ROOT::Math::beta_cdf_c(p, passed, total-passed+1);; 1260 ; 1261 double vmin = (bUpper) ? alpha_min : 1.- alpha_min;; 1262 if (v > vm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TEfficiency_8cxx_source.html:51441,toler,tolerance,51441,doc/master/TEfficiency_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TEfficiency_8cxx_source.html,1,['toler'],['tolerance']
Availability,/////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ld,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:29538,mask,mask,29538,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['mask'],['mask']
Availability,"///////////////////////////////////////////////////; 538/// Specify the path for this node.; 539 ; 540Bool_t TGeoPhysicalNode::SetPath(const char *path); 541{; 542 if (!gGeoManager->cd(path)) {; 543 Error(""SetPath"", ""wrong path -> maybe RestoreMasterVolume"");; 544 return kFALSE;; 545 }; 546 SetBranchAsState();; 547 return kTRUE;; 548}; 549 ; 550////////////////////////////////////////////////////////////////////////////////; 551/// Checks if a given navigator state matches this physical node; 552 ; 553Bool_t TGeoPhysicalNode::IsMatchingState(TGeoNavigator *nav) const; 554{; 555 TGeoNodeCache *cache = nav->GetCache();; 556 if (!cache) {; 557 Fatal(""SetBranchAsState"", ""no state available"");; 558 return kFALSE;; 559 }; 560 // the first condition is that the levels of navigator and this physical node must match; 561 if (cache->GetLevel() != fLevel) {; 562 return kFALSE;; 563 }; 564 // now we compare the nodes at each level; 565 // starting backwards since that enhances the probability of an early return; 566 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 567 for (Int_t i = fLevel; i >= 1; --i); 568 if (fNodes->At(i) != branch[i]); 569 return kFALSE;; 570 return kTRUE;; 571}; 572 ; 573ClassImp(TGeoPNEntry);; 574 ; 575////////////////////////////////////////////////////////////////////////////////; 576/// Default constructor; 577 ; 578TGeoPNEntry::TGeoPNEntry(); 579{; 580 fNode = nullptr;; 581 fMatrix = nullptr;; 582 fGlobalOrig = nullptr;; 583}; 584 ; 585////////////////////////////////////////////////////////////////////////////////; 586/// Default constructor; 587 ; 588TGeoPNEntry::TGeoPNEntry(const char *name, const char *path) : TNamed(name, path); 589{; 590 if (!gGeoManager || !gGeoManager->IsClosed() || !gGeoManager->CheckPath(path)) {; 591 TString errmsg(""Cannot define a physical node link without a closed geometry and a valid path !"");; 592 Error(""ctor"", ""%s"", errmsg.Data());; 593 throw errmsg;; 594 return;; 595 }; 596 gGeoManager->PushPath();; 597 gGeoMana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:18773,avail,available,18773,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['avail'],['available']
Availability,"///////////////////////////////////////////////////; 901/// When the argument is true the SIGALRM signal handler is set so that; 902/// interrupted syscalls will not be restarted by the kernel. This is; 903/// typically used in case one wants to put a timeout on an I/O operation.; 904/// By default interrupted syscalls will always be restarted (for all; 905/// signals). This can be controlled for each a-synchronous TTimer via; 906/// the method TTimer::SetInterruptSyscalls().; 907 ; 908void TUnixSystem::SigAlarmInterruptsSyscalls(Bool_t set); 909{; 910 UnixSigAlarmInterruptsSyscalls(set);; 911}; 912 ; 913////////////////////////////////////////////////////////////////////////////////; 914/// Return the bitmap of conditions that trigger a floating point exception.; 915 ; 916Int_t TUnixSystem::GetFPEMask(); 917{; 918 Int_t mask = 0;; 919 ; 920#if defined(R__LINUX) && !defined(__powerpc__); 921#if defined(__GLIBC__) && (__GLIBC__>2 || __GLIBC__==2 && __GLIBC_MINOR__>=1); 922 ; 923#if __GLIBC_MINOR__>=3; 924 ; 925 Int_t oldmask = fegetexcept();; 926 ; 927#else; 928 fenv_t oldenv;; 929 fegetenv(&oldenv);; 930 fesetenv(&oldenv);; 931#if __ia64__; 932 Int_t oldmask = ~oldenv;; 933#else; 934 Int_t oldmask = ~oldenv.__control_word;; 935#endif; 936#endif; 937 ; 938 if (oldmask & FE_INVALID ) mask |= kInvalid;; 939 if (oldmask & FE_DIVBYZERO) mask |= kDivByZero;; 940 if (oldmask & FE_OVERFLOW ) mask |= kOverflow;; 941 if (oldmask & FE_UNDERFLOW) mask |= kUnderflow;; 942# ifdef FE_INEXACT; 943 if (oldmask & FE_INEXACT ) mask |= kInexact;; 944# endif; 945#endif; 946#endif; 947 ; 948#if defined(R__MACOSX) && defined(__SSE2__); 949 // OS X uses the SSE unit for all FP math by default, not the x87 FP unit; 950 Int_t oldmask = ~_MM_GET_EXCEPTION_MASK();; 951 ; 952 if (oldmask & _MM_MASK_INVALID ) mask |= kInvalid;; 953 if (oldmask & _MM_MASK_DIV_ZERO ) mask |= kDivByZero;; 954 if (oldmask & _MM_MASK_OVERFLOW ) mask |= kOverflow;; 955 if (oldmask & _MM_MASK_UNDERFLOW) mask |= kUnderf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:27900,mask,mask,27900,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['mask'],['mask']
Availability,"//////////////////////////////////////////////////; 223/// Set the application name (from command line, argv[0]) and copy it in; 224/// gProgName.; 225 ; 226void TSystem::SetProgname(const char *name); 227{; 228 delete [] gProgName;; 229 gProgName = StrDup(name);; 230}; 231 ; 232////////////////////////////////////////////////////////////////////////////////; 233/// Set DISPLAY environment variable based on utmp entry. Only for UNIX.; 234 ; 235void TSystem::SetDisplay(); 236{; 237}; 238 ; 239////////////////////////////////////////////////////////////////////////////////; 240/// Set the system error string. This string will be used by GetError().; 241/// To be used in case one does not want or can use the system error; 242/// string (e.g. because error is generated by a third party POSIX like; 243/// library that does not use standard errno).; 244 ; 245void TSystem::SetErrorStr(const char *errstr); 246{; 247 ResetErrno(); // so GetError() uses the fLastErrorString; 248 GetLastErrorString() = errstr;; 249}; 250 ; 251////////////////////////////////////////////////////////////////////////////////; 252/// Return system error string.; 253 ; 254const char *TSystem::GetError(); 255{; 256 if (GetErrno() == 0 && !GetLastErrorString().IsNull()); 257 return GetLastErrorString().Data();; 258 return Form(""errno: %d"", GetErrno());; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// Return cryptographic random number; 263/// Fill provided buffer with random values; 264/// Returns number of bytes written to buffer or -1 in case of error; 265 ; 266Int_t TSystem::GetCryptoRandom(void * /* buf */, Int_t /* len */); 267{; 268 Error(""GetCryptoRandom"", ""Not implemented"");; 269 return -1;; 270}; 271 ; 272 ; 273////////////////////////////////////////////////////////////////////////////////; 274/// Static function returning system error number.; 275 ; 276Int_t TSystem::GetErrno(); 277{; 278 return errno;; 279}; 280 ; 281/////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:7605,error,error,7605,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////; 2342/// dummy ctor; 2343 ; 2344TGeoIdentity::TGeoIdentity(); 2345{; 2346 if (!gGeoIdentity); 2347 gGeoIdentity = this;; 2348 RegisterYourself();; 2349}; 2350 ; 2351////////////////////////////////////////////////////////////////////////////////; 2352/// constructor; 2353 ; 2354TGeoIdentity::TGeoIdentity(const char *name) : TGeoMatrix(name); 2355{; 2356 if (!gGeoIdentity); 2357 gGeoIdentity = this;; 2358 RegisterYourself();; 2359}; 2360 ; 2361////////////////////////////////////////////////////////////////////////////////; 2362/// Return a temporary inverse of this.; 2363 ; 2364TGeoHMatrix TGeoIdentity::Inverse() const; 2365{; 2366 TGeoHMatrix h = *gGeoIdentity;; 2367 return h;; 2368}; 2369 ; 2370/** \class TGeoHMatrix; 2371\ingroup Geometry_classes; 2372 ; 2373Matrix class used for computing global transformations; 2374Should NOT be used for node definition. An instance of this class; 2375is generally used to pile-up local transformations starting from; 2376the top level physical node, down to the current node.; 2377*/; 2378 ; 2379ClassImp(TGeoHMatrix);; 2380 ; 2381////////////////////////////////////////////////////////////////////////////////; 2382/// dummy ctor; 2383 ; 2384TGeoHMatrix::TGeoHMatrix(); 2385{; 2386 memset(&fTranslation[0], 0, kN3);; 2387 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2388 memcpy(fScale, kUnitScale, kN3);; 2389}; 2390 ; 2391////////////////////////////////////////////////////////////////////////////////; 2392/// constructor; 2393 ; 2394TGeoHMatrix::TGeoHMatrix(const char *name) : TGeoMatrix(name); 2395{; 2396 memset(&fTranslation[0], 0, kN3);; 2397 memcpy(fRotationMatrix, kIdentityMatrix, kN9);; 2398 memcpy(fScale, kUnitScale, kN3);; 2399}; 2400 ; 2401////////////////////////////////////////////////////////////////////////////////; 2402/// assignment; 2403 ; 2404TGeoHMatrix::TGeoHMatrix(const TGeoMatrix &matrix) : TGeoMatrix(matrix); 2405{; 2406 memset(&fTranslation[0], 0, kN3);; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html:81862,down,down,81862,doc/master/TGeoMatrix_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8cxx_source.html,1,['down'],['down']
Availability,//////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::GetErrorYhigh(Int_t i) const; 660{; 661 if (i < 0 || i >= fNpoints) return -1;; 662 if (fEY) return fEY[i];; 663 return -1;; 664}; 665 ; 666 ; 667////////////////////////////////////////////////////////////////////////////////; 668/// It returns the error along Y at point `i`. For TGraphErrors this method is; 669/// the same as GetErrorY.; 670 ; 671Double_t TGraphErrors::GetErrorYlow(Int_t i) const; 672{; 673 if (i < 0 || i >= fNpoints) return -1;; 674 if (fEY) return fEY[i];; 675 return -1;; 676}; 677 ; 678////////////////////////////////////////////////////////////////////////////////; 679/// Adds all graphs with errors from the collection to this graph.; 680/// Returns the total number of points in the result or -1 in case of an error.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20991,error,error,20991,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////////////; 671/// Save this object in the file specified by filename.; 672///; 673/// - if ""filename"" contains "".root"" the object is saved in filename as root; 674/// binary file.; 675///; 676/// - if ""filename"" contains "".xml"" the object is saved in filename as a xml; 677/// ascii file.; 678///; 679/// - if ""filename"" contains "".cc"" the object is saved in filename as C code; 680/// independant from ROOT. The code is generated via SavePrimitive().; 681/// Specific code should be implemented in each object to handle this; 682/// option. Like in TF1::SavePrimitive().; 683///; 684/// - otherwise the object is written to filename as a CINT/C++ script. The; 685/// C++ code to rebuild this object is generated via SavePrimitive(). The; 686/// ""option"" parameter is passed to SavePrimitive. By default it is an empty; 687/// string. It can be used to specify the Draw option in the code generated; 688/// by SavePrimitive.; 689///; 690/// The function is available via the object context menu.; 691 ; 692void TObject::SaveAs(const char *filename, Option_t *option) const; 693{; 694 //==============Save object as a root file===================================; 695 if (filename && strstr(filename,"".root"")) {; 696 if (gDirectory) gDirectory->SaveObjectAs(this,filename,"""");; 697 return;; 698 }; 699 ; 700 //==============Save object as a XML file====================================; 701 if (filename && strstr(filename,"".xml"")) {; 702 if (gDirectory) gDirectory->SaveObjectAs(this,filename,"""");; 703 return;; 704 }; 705 ; 706 //==============Save object as a JSON file================================; 707 if (filename && strstr(filename,"".json"")) {; 708 if (gDirectory) gDirectory->SaveObjectAs(this,filename,option);; 709 return;; 710 }; 711 ; 712 //==============Save object as a C, ROOT independant, file===================; 713 if (filename && strstr(filename,"".cc"")) {; 714 TString fname;; 715 if (filename && strlen(filename) > 0) {; 716 fname = file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TObject_8cxx_source.html:24947,avail,available,24947,doc/master/TObject_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TObject_8cxx_source.html,1,['avail'],['available']
Availability,"//////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886////////////////////////////////////////////////////////////////////////////////; 887/// Return option to compute profile2D errors.; 888 ; 889Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:30252,error,errors,30252,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['errors']
Availability,"//////////////////////////////////////////////////; 939/// Apply a function to all data points \f$ y = f(x,y) \f$.; 940///; 941/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 942/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 943///; 944/// Only the first error dimension is affected.; 945///; 946/// Special treatment has to be applied for the functions where the; 947/// role of ""up"" and ""down"" is reversed.; 948///; 949/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 950 ; 951void TGraphMultiErrors::Apply(TF1 *f); 952{; 953 Double_t x, y, eyL, eyH, eyLNew, eyHNew, fxy;; 954 ; 955 if (fHistogram) {; 956 delete fHistogram;; 957 fHistogram = nullptr;; 958 }; 959 ; 960 for (Int_t i = 0; i < fNpoints; i++) {; 961 GetPoint(i, x, y);; 962 eyL = GetErrorYlow(i, 0);; 963 eyH = GetErrorYhigh(i, 0);; 964 ; 965 fxy = f->Eval(x, y);; 966 SetPoint(i, x, fxy);; 967 ; 968 if (f->Eval(x, y - eyL) < f->Eval(x, y + eyH)) {; 969 eyLNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 970 eyHNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 971 } else {; 972 eyHNew = TMath::Abs(fxy - f->Eval(x, y - eyL));; 973 eyLNew = TMath::Abs(f->Eval(x, y + eyH) - fxy);; 974 }; 975 ; 976 // systematic errors and error on x doesn't change; 977 SetPointEY(i, 0, eyLNew, eyHNew);; 978 }; 979 ; 980 if (gPad); 981 gPad->Modified();; 982}; 983 ; 984////////////////////////////////////////////////////////////////////////////////; 985/// This function is only kept for backward compatibility.; 986/// You should rather use the Divide method.; 987/// It calls `Divide(pass,total,""cl=0.683 b(1,1) mode"")` which is equivalent to the; 988/// former BayesDivide method.; 989 ; 990void TGraphMultiErrors::BayesDivide(const TH1 *pass, const TH1 *total, Option_t *); 991{; 992 Divide(pass, total, ""cl=0.683 b(1,1) mode"");; 993}; 994 ; 995////////////////////////////////////////////////////////////////////////////////; 996/// This function was adapted from the TGraphAsymmErrors class.; 997/// See TGra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:33664,error,errors,33664,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"/////////////////////////////////////////////////; 3248/// Announce UDP service.; 3249 ; 3250int TUnixSystem::AnnounceUdpService(int port, int backlog); 3251{; 3252 return UnixUdpService(port, backlog);; 3253}; 3254 ; 3255////////////////////////////////////////////////////////////////////////////////; 3256/// Announce unix domain service on path ""kServerPath/<port>""; 3257 ; 3258int TUnixSystem::AnnounceUnixService(int port, int backlog); 3259{; 3260 return UnixUnixService(port, backlog);; 3261}; 3262 ; 3263////////////////////////////////////////////////////////////////////////////////; 3264/// Announce unix domain service on path 'sockpath'; 3265 ; 3266int TUnixSystem::AnnounceUnixService(const char *sockpath, int backlog); 3267{; 3268 return UnixUnixService(sockpath, backlog);; 3269}; 3270 ; 3271////////////////////////////////////////////////////////////////////////////////; 3272/// Accept a connection. In case of an error return -1. In case; 3273/// non-blocking I/O is enabled and no connections are available; 3274/// return -2.; 3275 ; 3276int TUnixSystem::AcceptConnection(int sock); 3277{; 3278 int soc = -1;; 3279 ; 3280 while ((soc = ::accept(sock, nullptr, nullptr)) == -1 && GetErrno() == EINTR); 3281 ResetErrno();; 3282 ; 3283 if (soc == -1) {; 3284 if (GetErrno() == EWOULDBLOCK); 3285 return -2;; 3286 else {; 3287 SysError(""AcceptConnection"", ""accept"");; 3288 return -1;; 3289 }; 3290 }; 3291 ; 3292 return soc;; 3293}; 3294 ; 3295////////////////////////////////////////////////////////////////////////////////; 3296/// Close socket.; 3297 ; 3298void TUnixSystem::CloseConnection(int sock, Bool_t force); 3299{; 3300 if (sock < 0) return;; 3301 ; 3302#if !defined(R__AIX) || defined(_AIX41) || defined(_AIX43); 3303 if (force); 3304 ::shutdown(sock, 2); // will also close connection of parent; 3305#endif; 3306 ; 3307 while (::close(sock) == -1 && GetErrno() == EINTR); 3308 ResetErrno();; 3309}; 3310 ; 3311/////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:104858,avail,available,104858,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['avail'],['available']
Availability,"////////////////////////////////////////////////; 295/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 296///; 297/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 298/// The multiple y-errors are passed as std::vectors of std::vectors.; 299 ; 300TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 301 const Double_t *y, const Double_t *exL, const Double_t *exH,; 302 std::vector<std::vector<Double_t>> eyL, std::vector<std::vector<Double_t>> eyH,; 303 Int_t m); 304 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 305{; 306 SetNameTitle(name, title);; 307}; 308 ; 309////////////////////////////////////////////////////////////////////////////////; 310/// TGraphMultiErrors normal constructor with `np` points and `ne` y-errors.; 311///; 312/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 313/// The multiple y-errors are passed as std::vectors of TArrayF objects.; 314 ; 315TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL,; 316 const Float_t *exH, std::vector<TArrayF> eyL, std::vector<TArrayF> eyH, Int_t m); 317 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 318{; 319 if (!CtorAllocate()); 320 return;; 321 ; 322 for (Int_t i = 0; i < fNpoints; i++) {; 323 if (exL); 324 fExL[i] = exL[i];; 325 else; 326 fExL[i] = 0.;; 327 if (exH); 328 fExH[i] = exH[i];; 329 else; 330 fExH[i] = 0.;; 331 ; 332 for (Int_t j = 0; j < fNYErrors; j++) {; 333 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 334 fEyL[j][i] = eyL[j][i];; 335 else; 336 fEyL[j][i] = 0.;; 337 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 338 fEyH[j][i] = eyH[j][i];; 339 else; 340 fEyH[j][i] = 0.;; 341 }; 342 }; 343 ; 344 CalcYErrorsSum();; 345}; 346 ; 347////////////////////////////////////////////////////////////////////////////////; 348/// TGraphMultiErrors normal construct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:11327,error,errors,11327,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"////////////////////////////////////////////////; 497 ; 498static void DylibAdded(const struct mach_header *mh, intptr_t /* vmaddr_slide */); 499{; 500 static int i = 0;; 501 static Bool_t gotFirstSo = kFALSE;; 502 static TString linkedDylibs;; 503 ; 504 // to copy the local linkedDylibs to the global gLinkedDylibs call this; 505 // function with mh==0; 506 if (!mh) {; 507 gLinkedDylibs = linkedDylibs;; 508 return;; 509 }; 510 ; 511 TString lib = _dyld_get_image_name(i++);; 512 ; 513 TRegexp sovers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.so"";; 514 TRegexp dyvers = ""libCore\\.[0-9]+\\.*[0-9]*\\.*[0-9]*\\.dylib"";; 515 ; 516#ifdef ROOTPREFIX; 517 if (gSystem->Getenv(""ROOTIGNOREPREFIX"")) {; 518#endif; 519 if (lib.EndsWith(""libCore.dylib"") || lib.EndsWith(""libCore.so"") ||; 520 lib.Index(sovers) != kNPOS || lib.Index(dyvers) != kNPOS) {; 521 char respath[kMAXPATHLEN];; 522 if (!realpath(lib, respath)) {; 523 if (!gSystem->Getenv(""ROOTSYS"")); 524 ::SysError(""TUnixSystem::DylibAdded"", ""error getting realpath of libCore, please set ROOTSYS in the shell"");; 525 } else {; 526 TString rs = gSystem->GetDirName(respath);; 527 gSystem->Setenv(""ROOTSYS"", gSystem->GetDirName(rs.Data()).Data());; 528 }; 529 }; 530#ifdef ROOTPREFIX; 531 }; 532#endif; 533 ; 534 // when libSystem.B.dylib is loaded we have finished loading all dylibs; 535 // explicitly linked against the executable. Additional dylibs; 536 // come when they are explicitly linked against loaded so's, currently; 537 // we are not interested in these; 538 if (lib.EndsWith(""/libSystem.B.dylib"")) {; 539 gotFirstSo = kTRUE;; 540 if (linkedDylibs.IsNull()) {; 541 // TSystem::GetLibraries() assumes that an empty GetLinkedLibraries(); 542 // means failure to extract the linked libraries. Signal ""we did; 543 // manage, but it's empty"" by returning a single space.; 544 linkedDylibs = ' ';; 545 }; 546 }; 547 ; 548 // add all libs loaded before libSystem.B.dylib; 549 if (!gotFirstSo && (lib.EndsWith("".dylib"") || lib.EndsWith("".so"")))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:15263,error,error,15263,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"///////////////////////////////////////////////; 70/// Internal function to initialize data members.; 71/// Use TF1::Copy instead of Clone.; 72 ; 73void TF1Convolution::InitializeDataMembers(TF1* function1, TF1* function2, Bool_t useFFT); 74{; 75 if (function1) {; 76 // functions must be 1d- if not flag an error; 77 if (function1->GetNdim() != 1); 78 Error(""InitializeDataMembers"",""function1 %s is not of dimension 1 "",function1->GetName());; 79 //TF1 * fnew1 = (TF1*) function1->IsA()->New();; 80 // since function1 is a TF1 (cannot be a derived class) we can instantiate it directly; 81 fFunction1 = std::make_unique<TF1> ();; 82 function1->Copy(*fFunction1);; 83 }; 84 if (function2) {; 85 if (function2->GetNdim() != 1); 86 Error(""InitializeDataMembers"",""function2 %s is not of dimension 1 "",function2->GetName());; 87 //TF1 * fnew2 = (TF1*) function2->IsA()->New();; 88 fFunction2 = std::make_unique<TF1>();; 89 function2->Copy(*fFunction2);; 90 }; 91 if (fFunction1 == nullptr|| fFunction2 == nullptr); 92 Fatal(""InitializeDataMembers"",""Invalid functions - Abort"");; 93 ; 94 // Set kNotGlobal bit; 95 fFunction1->SetBit(TF1::kNotGlobal, kTRUE);; 96 fFunction2->SetBit(TF1::kNotGlobal, kTRUE);; 97 ; 98 // use by default range of first function; 99 fFunction1->GetRange(fXmin, fXmax);; 100 // when using FFT add by default an extra 10% on each side; 101 if (useFFT) {; 102 SetExtraRange(fgExtraRangeFraction);; 103 }; 104 fNofParams1 = fFunction1->GetNpar();; 105 fNofParams2 = fFunction2->GetNpar();; 106 fParams1 = std::vector<Double_t>(fNofParams1);; 107 fParams2 = std::vector<Double_t>(fNofParams2);; 108 fCstIndex = (fFunction1->GetParNumber(""Constant"") == -1); 109 ? -1; 110 : fFunction2->GetParNumber(""Constant""); // TODO: add dropConstantParam flag?; 111 fFlagFFT = useFFT;; 112 fFlagGraph = false;; 113 fNofPoints = 10000;; 114 ; 115 fParNames.reserve( fNofParams1 + fNofParams2);; 116 for (int i=0; i<fNofParams1; i++); 117 {; 118 fParams1[i] = fFunction1 -> GetParameter(i);; 119 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:2769,error,error,2769,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////////; 2432/// Compute the gradient (derivative) wrt a parameter ipar; 2433///; 2434/// \param ipar index of parameter for which the derivative is computed; 2435/// \param x point, where the derivative is computed; 2436/// \param eps - if the errors of parameters have been computed, the step used in; 2437/// numerical differentiation is eps*parameter_error.; 2438///; 2439/// if the errors have not been computed, step=eps is used; 2440/// default value of eps = 0.01; 2441/// Method is the same as in Derivative() function; 2442///; 2443/// If a parameter is fixed, the gradient on this parameter = 0; 2444 ; 2445Double_t TF1::GradientPar(Int_t ipar, const Double_t *x, Double_t eps); 2446{; 2447 return GradientParTempl<Double_t>(ipar, x, eps);; 2448}; 2449 ; 2450////////////////////////////////////////////////////////////////////////////////; 2451/// Compute the gradient wrt parameters; 2452/// If the TF1 object is based on a formula expression (TFormula); 2453/// and TFormula::GenerateGradientPar() has been successfully called; 2454/// automatic differentiation using CLAD is used instead of the default; 2455/// numerical differentiation; 2456///; 2457/// \param x point, were the gradient is computed; 2458/// \param grad used to return the computed gradient, assumed to be of at least fNpar size; 2459/// \param eps if the errors of parameters have been computed, the step used in; 2460/// numerical differentiation is eps*parameter_error.; 2461///; 2462/// if the errors have not been computed, step=eps is used; 2463/// default value of eps = 0.01; 2464/// Method is the same as in Derivative() function; 2465///; 2466/// If a parameter is fixed, the gradient on this parameter = 0; 2467 ; 2468void TF1::GradientPar(const Double_t *x, Double_t *grad, Double_t eps); 2469{; 2470 if (fFormula && fFormula->HasGeneratedGradient()) {; 2471 // need to zero the gradient buffer; 2472 std::fill(grad, grad + fNpar, 0.);; 2473 fFormula->GradientPar(x,g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:90146,error,errors,90146,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['errors']
Availability,"////////////////////////////////////////////; 846/// Return bin effective entries for a weighted filled Profile histogram.; 847/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 848/// The effective entries is defined as the square of the sum of the weights divided by the; 849/// sum of the weights square.; 850/// TProfile::Sumw2() must be called before filling the profile with weights.; 851/// Only by calling this method the sum of the square of the weights per bin is stored.; 852 ; 853Double_t TProfile::GetBinEffectiveEntries(Int_t bin) const; 854{; 855 return TProfileHelper::GetBinEffectiveEntries((TProfile*)this, bin);; 856}; 857 ; 858////////////////////////////////////////////////////////////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 87",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:31327,error,errors,31327,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////////////; 1240/// Multiply this profile by h1.; 1241///; 1242/// `this = this*h1`; 1243 ; 1244Bool_t TProfile::Multiply(const TH1 *); 1245{; 1246 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1247 return kFALSE;; 1248}; 1249 ; 1250 ; 1251////////////////////////////////////////////////////////////////////////////////; 1252/// Replace contents of this profile by multiplication of h1 by h2.; 1253///; 1254/// `this = (c1*h1)*(c2*h2)`; 1255 ; 1256Bool_t TProfile::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1257{; 1258 Error(""Multiply"",""Multiplication of profile histograms not implemented"");; 1259 return kFALSE;; 1260}; 1261 ; 1262////////////////////////////////////////////////////////////////////////////////; 1263/// Project this profile into a 1-D histogram along X; 1264///; 1265/// The projection is always of the type TH1D.; 1266///; 1267/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1268/// to be equal to the errors of the profile.; 1269/// Option ""E"" is defined as the default one in the header file.; 1270/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1271/// - if option ""B"" is specified, the content of bin of the returned histogram; 1272/// will be equal to the GetBinEntries(bin) of the profile,; 1273/// otherwise (default) it will be equal to GetBinContent(bin); 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH1D using the 2-nd value as a weight.; 1280/// This makes sense only for profile filled with weights =1. If not, the error of the; 1281/// project",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:46081,error,errors,46081,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,2,['error'],['errors']
Availability,///////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYErrors); 1661 return fAttFill[e].GetFillStyle();; 1662 else; 1663 return 0;; 1664}; 1665 ; 1666////////////////////////////////////////////////////////////////////////////////; 1667/// Get Line Color for specified error e (-1 = Global and x errors).; 1668 ; 1669Color_t TGraphMultiErrors::GetLineColor(Int_t e) const; 1670{; 1671 if (e,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55906,error,error,55906,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"///////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAndDelete(TString& target, char *tobedeleted); 2498{; 2499 // Assign the char* value to the TString and then delete it.; 2500 ; 2501 target = tobedeleted;; 2502 delete [] tobedeleted;; 2503}; 2504 ; 2505#ifdef WIN32; 2506 ; 2507static TString R__Exec(const char *cmd); 2508{; 2509 // Execute a command and return the stdout in a string.; 2510 ; 2511 FILE * f = gSystem->OpenPipe(cmd,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:79971,error,error,79971,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////; 2670/// Return Error on Integral of a parametric function between a and b; 2671/// due to the parameter uncertainties and their covariance matrix from the fit.; 2672/// In addition to the integral limits, this method takes as input a pointer to the fitted parameter values; 2673/// and a pointer the covariance matrix from the fit. These pointers should be retrieved from the; 2674/// previously performed fit using the TFitResult class.; 2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:100279,error,error,100279,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////////; 46/// TInterpreter ctor only called by derived classes.; 47 ; 48TInterpreter::TInterpreter(const char *name, const char *title); 49 : TNamed(name, title); 50{; 51 gInterpreterLocal = this;; 52 gCling = this;; 53}; 54 ; 55////////////////////////////////////////////////////////////////////////////////; 56/// returns gInterpreter global; 57 ; 58TInterpreter *TInterpreter::Instance(); 59{; 60 if (gInterpreterLocal == nullptr) {; 61 static TROOT *getROOT = ROOT::GetROOT(); // Make sure gInterpreterLocal is set; 62 if (!getROOT) {; 63 ::Fatal(""TInterpreter::Instance"",""TROOT object is required before accessing a TInterpreter"");; 64 }; 65 }; 66 return gInterpreterLocal;; 67}; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; namechar name[80]Definition TGX11.cxx:110; TGlobal.h; gInterpreterLocalstatic TInterpreter * gInterpreterLocalDefinition TInterpreter.cxx:25; gClingTInterpreter * gClingDefinition TInterpreter.cxx:24; TInterpreter.h; gClingR__EXTERN TInterpreter * gClingDefinition TInterpreter.h:574; TROOT.h; TGlobalMappedFunction::MakeFunctorstatic void MakeFunctor(const char *name, const char *type, GlobFunc &func)Definition TGlobal.h:73; TInterpreterThis class defines an abstract interface to a generic command line interpreter.Definition TInterpreter.h:60; TInterpreter::TInterpreterTInterpreter()Definition TInterpreter.h:135; TInterpreter::Instancestatic TInterpreter * Instance()returns gInterpreter globalDefinition TInterpreter.cxx:58; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Fatalvirtual void Fatal(const char *method, const char *msgfmt,...) constIssue fatal error message.Definition TObject.cxx:1021; TROOTROOT top level object description.Definition TROOT.h:94; ROOT::GetROOTTROOT * GetROOT()Definition TROOT.cxx:472. coremetasrcTInterpreter.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:11 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TInterpreter_8cxx_source.html:3207,error,error,3207,doc/master/TInterpreter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TInterpreter_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 617}; 618 ; 619 ; 620////////////////////////////////////////////////////////////////////////////////; 621/// It returns the error along Y at point `i`.; 622 ; 623Double_t TGraphErrors::GetErrorY(Int_t i) const; 624{; 625 if (i < 0 || i >= fNpoints) return -1;; 626 if (fEY) return fEY[i];; 627 return -1;; 628}; 629 ; 630 ; 631////////////////////////////////////////////////////////////////////////////////; 632/// It returns the error along X at point `i`. For TGraphErrors this method is; 633/// the same as GetErrorX.; 634 ; 635Double_t TGraphErrors::GetErrorXhigh(Int_t i) const; 636{; 637 if (i < 0 || i >= fNpoints) return -1;; 638 if (fEX) return fEX[i];; 639 return -1;; 640}; 641 ; 642 ; 643////////////////////////////////////////////////////////////////////////////////; 644/// It returns the error along X at point `i`. For TGraphErrors this method is; 645/// the same as GetErrorX.; 646 ; 647Double_t TGraphErrors::GetErrorXlow(Int_t i) const; 648{; 649 if (i < 0 || i >= fNpoints) return -1;; 650 if (fEX) return fEX[i];; 651 return -1;; 652}; 653 ; 654 ; 655////////////////////////////////////////////////////////////////////////////////; 656/// It returns the error along Y at point `i`. For TGraphErrors this method is; 657/// the same as GetErrorY.; 658 ; 659Double_t TGraphErrors::Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:20244,error,error,20244,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////////; 121/// Create a 3-D Profile with variable bins in X , Y and Z.; 122 ; 123TProfile3D::TProfile3D(const char *name,const char *title,Int_t nx,const Double_t *xbins,Int_t ny,const Double_t *ybins,Int_t nz,const Double_t *zbins,Option_t *option); 124 : TH3D(name,title,nx,xbins,ny,ybins,nz,zbins); 125{; 126 BuildOptions(0,0,option);; 127}; 128 ; 129////////////////////////////////////////////////////////////////////////////////; 130/// Set Profile3D histogram structure and options.; 131///; 132/// - tmin: minimum value allowed for t; 133/// - tmax: maximum value allowed for t; 134/// if (tmin = tmax = 0) there are no limits on the allowed t values (tmin = -inf, tmax = +inf); 135///; 136/// - option: this is the option for the computation of the t error of the profile ( TProfile3D::GetBinError ); 137/// possible values for the options are documented in TProfile3D::SetErrorOption; 138///; 139/// see also TProfile::BuildOptions for a detailed description; 140 ; 141void TProfile3D::BuildOptions(Double_t tmin, Double_t tmax, Option_t *option); 142{; 143 SetErrorOption(option);; 144 ; 145 // create extra profile data structure (bin entries/ y^2 and sum of weight square); 146 TProfileHelper::BuildArray(this);; 147 ; 148 fTmin = tmin;; 149 fTmax = tmax;; 150 fScaling = kFALSE;; 151 fTsumwt = fTsumwt2 = 0;; 152}; 153 ; 154////////////////////////////////////////////////////////////////////////////////; 155/// Copy constructor.; 156 ; 157TProfile3D::TProfile3D(const TProfile3D &profile3d) : TH3D(); 158{; 159 profile3d.TProfile3D::Copy(*this);; 160}; 161 ; 162TProfile3D &TProfile3D::operator=(const TProfile3D &profile3d); 163{; 164 if (this != &profile3d); 165 profile3d.TProfile3D::Copy(*this);; 166 return *this;; 167}; 168 ; 169////////////////////////////////////////////////////////////////////////////////; 170/// Performs the operation: `this = this + c1*f1` .; 171 ; 172Bool_t TProfile3D::Add(TF1 *, Double_t , Option_t*); 173{; 174 Error(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:5764,error,error,5764,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 1653////////////////////////////////////////////////////////////////////////////////; 1654/// Get Fill Style for specified error e (-1 = Global and x errors).; 1655 ; 1656Style_t TGraphMultiErrors::GetFillStyle(Int_t e) const; 1657{; 1658 if (e == -1); 1659 return GetFillStyle();; 1660 else if (e >= 0 && e < fNYEr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55585,error,error,55585,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////////////////; 17// //; 18// TProfile2D //; 19// //; 20// Profile2D histogram class. //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TH2.h""; 25#include ""TProfile.h""; 26 ; 27class TProfile2D : public TH2D {; 28 ; 29public:; 30 friend class TProfileHelper;; 31 friend class TH1Merger;; 32 ; 33protected:; 34 TArrayD fBinEntries; ///< Number of entries per bin; 35 EErrorType fErrorMode; ///< Option to compute errors; 36 Double_t fZmin; ///< Lower limit in Z (if set); 37 Double_t fZmax; ///< Upper limit in Z (if set); 38 Bool_t fScaling; ///<! True when TProfile2D::Scale is called; 39 Double_t fTsumwz; ///< Total Sum of weight*Z; 40 Double_t fTsumwz2; ///< Total Sum of weight*Z*Z; 41 TArrayD fBinSumw2; ///< Array of sum of squares of weights per bin; 42 static Bool_t fgApproximate; ///< Bin error approximation option; 43 ; 44 Int_t BufferFill(Double_t, Double_t) override {return -2;} //may not use; 45 Int_t BufferFill(Double_t, Double_t, Double_t) override {return -2;} //may not use; 46 virtual Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w);; 47 ; 48 // helper methods for the Merge unification in TProfileHelper; 49 void SetBins(const Int_t* nbins, const Double_t* range) { SetBins(nbins[0], range[0], range[1],; 50 nbins[1], range[2], range[3]); };; 51 Int_t Fill(const Double_t* v) { return Fill(v[0], v[1], v[2], v[3]); };; 52 ; 53 TProfile *DoProfile(bool onX, const char *name, Int_t firstbin, Int_t lastbin, Option_t *option) const override;; 54 ; 55 using TH2::Fill;; 56 Int_t Fill(Double_t, Double_t) override {return TH2::Fill(0); } //MayNotUse; 57 ; 58 Double_t RetrieveBinContent(Int_t bin) const override { return (fBinEntries.fArray[bin] > 0) ? fArray[bin]/fBinEntries.fArray[bin] : 0; }; 59 //virtual void UpdateBinContent(Int_t bin, Double_t content);; 60 Double_t GetBinErrorSqUnchecked(Int_t bin) const override { Double_t err = GetBinError(bin); return err*err; }; 61 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8h_source.html:1215,error,errors,1215,doc/master/TProfile2D_8h_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8h_source.html,2,['error'],"['error', 'errors']"
Availability,"//////////////////////////////////////; 431/// TGraphAsymmErrors default destructor.; 432 ; 433TGraphAsymmErrors::~TGraphAsymmErrors(); 434{; 435 if(fEXlow) delete [] fEXlow;; 436 if(fEXhigh) delete [] fEXhigh;; 437 if(fEYlow) delete [] fEYlow;; 438 if(fEYhigh) delete [] fEYhigh;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Allocate internal data structures for `size` points.; 443 ; 444Double_t** TGraphAsymmErrors::Allocate(Int_t size) {; 445 return AllocateArrays(6, size);; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Add a point with asymmetric errorbars to the graph.; 450 ; 451void TGraphAsymmErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 452{; 453 AddPoint(x, y);; 454 SetPointError(fNpoints - 1, exl, exh, eyl, eyh);; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHistogram = nullptr;; 475 }; 476 for (Int_t i=0;i<GetN();i++) {; 477 GetPoint(i,x,y);; 478 exl = GetErrorXlow(i);; 479 exh = GetErrorXhigh(i);; 480 eyl = GetErrorYlow(i);; 481 eyh = GetErrorYhigh(i);; 482 ; 483 fxy = f->Eval(x,y);; 484 SetPoint(i,x,fxy);; 485 ; 486 // in the case of the functions like y-> -1*y the roles of the; 487 // upper and lower error bars is reversed; 488 if (f->Eval(x,y-eyl)<f->Eval(x,y+eyh)) {; 489 eyl_new =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:16199,down,down,16199,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['down'],['down']
Availability,"/////////////////////////////////////; 6312/// [Draw 1D histograms error bars.](\ref HP09); 6313 ; 6314void THistPainter::PaintErrors(Option_t *); 6315{; 6316 ; 6317 // On iOS, we do not highlight histogram, if it's not picked at the moment; 6318 // (but part of histogram (axis or pavestat) was picked, that's why this code; 6319 // is called at all. This conditional statement never executes on non-iOS platform.; 6320 if (gPad->PadInHighlightMode() && gPad->GetSelected() != fH) return;; 6321 ; 6322 const Int_t kBASEMARKER=8;; 6323 Double_t xp, yp, ex1, ex2, ey1, ey2;; 6324 Double_t delta;; 6325 Double_t s2x, s2y, bxsize, bysize, symbolsize, xerror, sbasex, sbasey;; 6326 Double_t xi1, xi2, xi3, xi4, yi1, yi2, yi3, yi4;; 6327 Double_t xmin, xmax, ymin, ymax;; 6328 Double_t logxmin = 0;; 6329 Double_t logymin = 0;; 6330 Double_t offset = 0.;; 6331 Double_t width = 0.;; 6332 Int_t i, k, npoints, first, last, fixbin;; 6333 Int_t if1 = 0;; 6334 Int_t if2 = 0;; 6335 Int_t drawmarker, errormarker;; 6336 Int_t option0, option1, option2, option3, option4, optionE, optionEX0, optionI0;; 6337 static Float_t cxx[30] = {1.0,1.0,0.5,0.5,1.0,1.0,0.5,0.6,1.0,0.5,0.5,1.0,0.5,0.6,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6338 static Float_t cyy[30] = {1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.5,0.5,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.5,0.5,0.5,1.0};; 6339 ; 6340 std::vector<Double_t> xline, yline;; 6341 option0 = option1 = option2 = option3 = option4 = optionE = optionEX0 = optionI0 = 0;; 6342 if (Hoption.Error >= 40) {Hoption.Error -=40; option0 = 1;}; 6343 if (Int_t(Hoption.Error/10) == 2) {optionEX0 = 1; Hoption.Error -= 10;}; 6344 if (Hoption.Error == 31) {optionEX0 = 1; Hoption.Error = 1;}; 6345 if (Hoption.Error == 11) option1 = 1;; 6346 if (Hoption.Error == 12) option2 = 1;; 6347 if (Hoption.Error == 13) option3 = 1;; 6348 if (Hoption.Error == 14) {option4 = 1; option3 = 1;}; 6349 if (Hoption.Error == 15) {optionI0 = 1; option3 = 1;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:232768,error,errormarker,232768,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['errormarker']
Availability,"////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the UserGroup_t structure for this call are:; 2115/// fGid and fGroup; 2116/// If group = 0, returns current user's group. The returned structure; 2117/// must be deleted by the user. In case of error 0 is returned.; 2118 ; 2119UserGroup_t *TUnixSystem::GetGroupInfo(const char *group); 2120{; 2121 return GetGroupInfo(GetGid(group));; 2122}; 2123 ; 2124//---- environment manipulation ------------------------------------------------; 2125 ; 2126////////////////////////////////////////////////////////////////////////////////; 2127/// Set environment variable.; 2128 ; 2129void TUnixSystem::Setenv(const char *name, const char *value); 2130{; 2131 ::setenv(name, value, 1);; 2132}; 2133 ; 2134////////////////////////////////////////////////////////////////////////////////; 2135/// Get environment variable.; 2136 ; 2137const char *TUnixSystem::Getenv(const char *name); 2138{; 2139 return ::getenv(name);; 2140}; 2141 ; 2142////////////////////////////////////////////////////////////////////////////////; 2143/// Unset environment variable.; 2144 ; 2145void TUnixSystem::Unsetenv(const char *name); 2146{; 2147 ::unsetenv(name);; 2148}; 2149 ; 2150//---- Processes -----------------------------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:65472,error,error,65472,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////////; 24 ; 25#include ""TString.h""; 26#include ""TDictionary.h""; 27#include ""TBranchProxy.h""; 28 ; 29#include <type_traits>; 30#include <vector>; 31#include <string>; 32 ; 33class TBranch;; 34class TBranchElement;; 35class TLeaf;; 36class TTreeReader;; 37 ; 38namespace ROOT {; 39namespace Internal {; 40 ; 41/** \class TTreeReaderValueBase; 42Base class of TTreeReaderValue.; 43*/; 44 ; 45 class TTreeReaderValueBase {; 46 public:; 47 ; 48 /// Status flags, 0 is good; 49 enum ESetupStatus {; 50 kSetupNotSetup = -7, ///< No initialization has happened yet.; 51 kSetupTreeDestructed = -8, ///< The TTreeReader has been destructed / not set.; 52 kSetupMakeClassModeMismatch = -9, ///< readers disagree on whether TTree::SetMakeBranch() should be on; 53 kSetupMissingCounterBranch = -6, ///< The array cannot find its counter branch: Array[CounterBranch]; 54 kSetupMissingBranch = -5, ///< The specified branch cannot be found.; 55 kSetupInternalError = -4, ///< Some other error - hopefully the error message helps.; 56 kSetupMissingDictionary = -3, ///< To read this branch, we need a dictionary.; 57 kSetupMismatch = -2, ///< Mismatch of branch type and reader template type.; 58 kSetupNotACollection = -1, ///< The branch class type is not a collection.; 59 kSetupMatch = 0, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 60 kSetupMatchBranch = 7, ///< This branch has been set up, branch data type and reader template type match, reading should succeed.; 61 //kSetupMatchConversion = 1, /// This branch has been set up, the branch data type can be converted to the reader template type, reading should succeed.; 62 //kSetupMatchConversionCollection = 2, /// This branch has been set up, the data type of the branch's collection elements can be converted to the reader template type, reading should succeed.; 63 //kSetupMakeClass = 3, /// This branch has been set up, enabling MakeClass mode for it, reading",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReaderValue_8h_source.html:2020,error,error,2020,doc/master/TTreeReaderValue_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReaderValue_8h_source.html,2,['error'],['error']
Availability,"////////////////////////////////////; 649/// Browse; 650 ; 651void TGraph::Browse(TBrowser *b); 652{; 653 TString opt = gEnv->GetValue(""TGraph.BrowseOption"", """");; 654 if (opt.IsNull()) {; 655 opt = b ? b->GetDrawOption() : ""alp"";; 656 opt = (opt == """") ? ""alp"" : opt.Data();; 657 }; 658 Draw(opt.Data());; 659 gPad->Update();; 660}; 661 ; 662////////////////////////////////////////////////////////////////////////////////; 663/// Return the chisquare of this graph with respect to f1.; 664/// The chisquare is computed as the sum of the quantity below at each point:; 665/// \f[; 666/// \frac{(y-f1(x))^{2}}{ey^{2}+(\frac{1}{2}(exl+exh)f1'(x))^{2}}; 667/// \f]; 668/// where x and y are the graph point coordinates and f1'(x) is the derivative of function f1(x).; 669/// This method to approximate the uncertainty in y because of the errors in x, is called; 670/// ""effective variance"" method.; 671/// In case of a pure TGraph, the denominator is 1.; 672/// In case of a TGraphErrors or TGraphAsymmErrors the errors are taken; 673/// into account.; 674/// By default the range of the graph is used whatever function range.; 675/// Use option ""R"" to use the function range; 676 ; 677Double_t TGraph::Chisquare(TF1 *func, Option_t * option) const; 678{; 679 if (!func) {; 680 Error(""Chisquare"",""Function pointer is Null - return -1"");; 681 return -1;; 682 }; 683 ; 684 TString opt(option); opt.ToUpper();; 685 bool useRange = opt.Contains(""R"");; 686 ; 687 return ROOT::Fit::Chisquare(*this, *func,useRange);; 688}; 689 ; 690////////////////////////////////////////////////////////////////////////////////; 691/// Return kTRUE if point number ""left""'s argument (angle with respect to positive; 692/// x-axis) is bigger than that of point number ""right"". Can be used by Sort.; 693 ; 694Bool_t TGraph::CompareArg(const TGraph* gr, Int_t left, Int_t right); 695{; 696 Double_t xl = 0, yl = 0, xr = 0, yr = 0;; 697 gr->GetPoint(left, xl, yl);; 698 gr->GetPoint(right, xr, yr);; 699 return (TMath::ATan2(yl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph_8cxx_source.html:21726,error,errors,21726,doc/master/TGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////; 169 ; 170 if( pos == std::string::npos ) {; 171 error_string = ""Parsing error, no key found!"";; 172 return false;; 173 }; 174 ; 175 //--------------------------------------------------------------------; 176 // The key was found - process the arguments; 177 ///////////////////////////////////////////////////////////////////////; 178 ; 179 std::string key = TSchemaRuleProcessor::Trim( command.substr( 0, pos ) );; 180 command = TSchemaRuleProcessor::Trim( command.substr( pos+1 ) );; 181 ; 182 //--------------------------------------------------------------------; 183 // Nothing left to be processed; 184 ///////////////////////////////////////////////////////////////////////; 185 ; 186 if( command.size() < 1 ) {; 187 error_string = ""Parsing error, wrond or no value specified for key: "" + key;; 188 return false;; 189 }; 190 ; 191 Bool_t hasquote = command[0] == '""';; 192 ; 193 //--------------------------------------------------------------------; 194 // Processing code tag: ""{ code }""; 195 ///////////////////////////////////////////////////////////////////////; 196 ; 197 if( key == ""code"" ) {; 198 // Cleaning of the input command:; 199 // - Trim whitespaces at the borders; 200 // - Get the inner command (i.e. the part between quotes); 201 // - Trim whitespaces again; 202 // - Stitch back together; 203 auto clean_command = [](const std::string &c) {; 204 auto first_trim = TSchemaRuleProcessor::Trim(c);; 205 auto inner_command =; 206 first_trim.substr(first_trim.find_first_of('""') + 1, first_trim.find_last_of('""') - 1);; 207 auto second_trim = TSchemaRuleProcessor::Trim(inner_command);; 208 return '""' + second_trim + '""';; 209 };; 210 command = clean_command(command);; 211 ; 212 if( command[1] != '{' ) {; 213 error_string = ""Parsing error while processing key: code\n"";; 214 error_string += ""Expected \""{ at the beginning of the value."";; 215 return false;; 216 }; 217 l = command.find( ""}\"""" );; 218 if( l == std::string::npos ) {; 219 er",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:6872,error,error,6872,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['error'],['error']
Availability,"///////////////////////////////////; 1716/// Redefine x axis parameters.; 1717 ; 1718void TProfile::SetBins(Int_t nx, const Double_t *xbins); 1719{; 1720 fXaxis.Set(nx,xbins);; 1721 fNcells = nx+2;; 1722 SetBinsLength(fNcells);; 1723}; 1724 ; 1725////////////////////////////////////////////////////////////////////////////////; 1726/// Set total number of bins including under/overflow.; 1727/// Reallocate bin contents array; 1728 ; 1729void TProfile::SetBinsLength(Int_t n); 1730{; 1731 TH1D::SetBinsLength(n);; 1732 TProfileHelper::BuildArray(this);; 1733}; 1734 ; 1735////////////////////////////////////////////////////////////////////////////////; 1736/// Set the buffer size in units of 8 bytes (double).; 1737 ; 1738void TProfile::SetBuffer(Int_t buffersize, Option_t *); 1739{; 1740 if (fBuffer) {; 1741 BufferEmpty();; 1742 delete [] fBuffer;; 1743 fBuffer = nullptr;; 1744 }; 1745 if (buffersize <= 0) {; 1746 fBufferSize = 0;; 1747 return;; 1748 }; 1749 if (buffersize < 100) buffersize = 100;; 1750 fBufferSize = 1 + 3*buffersize;; 1751 fBuffer = new Double_t[fBufferSize];; 1752 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:63786,error,errors,63786,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////////////; 294/// static: Set the maximum number of function calls for the minimization algorithm; 295/// For example for MIGRAD this is the maxcalls value passed as first argument; 296/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 297 ; 298void TVirtualFitter::SetMaxIterations(Int_t niter); 299{; 300 ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCalls(niter);; 301}; 302 ; 303////////////////////////////////////////////////////////////////////////////////; 304/// static: Set the Error Definition (default=1); 305/// For Minuit this is the value passed with the ""SET ERR"" command; 306/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html); 307 ; 308void TVirtualFitter::SetErrorDef(Double_t errdef); 309{; 310// fgErrorDef = errdef;; 311 ROOT::Math::MinimizerOptions::SetDefaultErrorDef(errdef);; 312 if (!GetGlobalFitter()) return;; 313 Double_t arglist[1];; 314 arglist[0] = errdef;; 315 GetGlobalFitter()->ExecuteCommand(""SET ERRORDEF"", arglist, 1);; 316}; 317 ; 318////////////////////////////////////////////////////////////////////////////////; 319/// static: Set the tolerance used in the minimization algorithm; 320/// For example for MIGRAD this is tolerance value passed as second argument; 321/// (see https://cern-tex.web.cern.ch/cern-tex/minuit/node18.html ); 322 ; 323void TVirtualFitter::SetPrecision(Double_t prec); 324{; 325 //fgPrecision = prec;; 326 ROOT::Math::MinimizerOptions::SetDefaultTolerance(prec);; 327}; MinimizerOptions.h; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; Int_tint Int_tDefinition RtypesCore.h:45; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TEnv.h; gEnvR__EXTERN TEnv * gEnvDefinition TEnv.h:170; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFitter.h; ThreadLocalStorage.h; ROOT::Math::MinimizerOptions::SetDefaultMaxFunctionCallsstatic void SetDefaultMaxFunctionCal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html:10346,toler,tolerance,10346,doc/master/TVirtualFitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFitter_8cxx_source.html,2,['toler'],['tolerance']
Availability,"//////////////////////////////////; 3112/// Dummy function kept for back compatibility.; 3113/// The cache is now activated automatically when processing TTrees/TChain.; 3114 ; 3115void TChain::UseCache(Int_t /* maxCacheSize */, Int_t /* pageSize */); 3116{; 3117}; InternalTreeUtils.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; h#define h(i)Definition RSha256.hxx:106; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Version_tshort Version_tDefinition RtypesCore.h:65; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition RtypesCore.h:69; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBranch.h; TBrowser.h; TBuffer.h; TChainElement.h; TChain.h; TClass.h; TColor.h; TCut.h; EDataTypeEDataTypeDefinition TDataType.h:28; TEntryListFromFile.h; TEntryList.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; TEventList.h; TFileInfo.h; TFilePrefetch.h; TFileStager.h; TFile.h; TFriendElement.h; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; onOption_t Option_t TPoint TPoint const char GetTextMagnitude",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:113740,error,error,113740,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////////; 1242/// Multiply this profile2D by h1.; 1243///; 1244/// `this = this*h1`; 1245 ; 1246Bool_t TProfile2D::Multiply(const TH1 *); 1247{; 1248 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1249 return kFALSE;; 1250}; 1251 ; 1252////////////////////////////////////////////////////////////////////////////////; 1253/// Replace contents of this profile2D by multiplication of h1 by h2.; 1254///; 1255/// `this = (c1*h1)*(c2*h2)`; 1256 ; 1257Bool_t TProfile2D::Multiply(const TH1 *, const TH1 *, Double_t, Double_t, Option_t *); 1258{; 1259 Error(""Multiply"",""Multiplication of profile2D histograms not implemented"");; 1260 return kFALSE;; 1261}; 1262 ; 1263////////////////////////////////////////////////////////////////////////////////; 1264/// Project this profile2D into a 2-D histogram along X,Y.; 1265///; 1266/// The projection is always of the type TH2D.; 1267///; 1268/// - if option ""E"" is specified the errors of the projected histogram are computed and set; 1269/// to be equal to the errors of the profile.; 1270/// Option ""E"" is defined as the default one in the header file.; 1271/// - if option """" is specified the histogram errors are simply the sqrt of its content; 1272/// - if option ""B"" is specified, the content of bin of the returned histogram; 1273/// will be equal to the GetBinEntries(bin) of the profile,; 1274/// - if option ""C=E"" the bin contents of the projection are set to the; 1275/// bin errors of the profile; 1276/// - if option ""W"" is specified the bin content of the projected histogram is set to the; 1277/// product of the bin content of the profile and the entries.; 1278/// With this option the returned histogram will be equivalent to the one obtained by; 1279/// filling directly a TH2D using the 3-rd value as a weight.; 1280/// This option makes sense only for profile filled with all weights =1.; 1281/// When the profile is weighted (filled with weights different than 1) the; 1282/// bin erro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:44448,error,errors,44448,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,2,['error'],['errors']
Availability,"/////////////////////////////////; 1960/// Minimization function for H1s using a Likelihood method.; 1961/// Basically, it forms the likelihood by determining the Poisson; 1962/// probability that given a number of entries in a particular bin,; 1963/// the fit would predict it's value. This is then done for each bin,; 1964/// and the sum of the logs is taken as the likelihood.; 1965///; 1966/// The ""I""ntegral method is used; 1967/// for each point the cache contains the following info; 1968/// - 1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); 1969/// - 2D : bc,e,xc,xw,yc,yw; 1970/// - 3D : bc,e,xc,xw,yc,yw,zc,zw; 1971 ; 1972void TFumili::FitLikelihoodI(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag); 1973{; 1974 Double_t cu,fu,fobs,fsub;; 1975 Double_t dersum[100];; 1976 Double_t x[3];; 1977 Int_t icu;; 1978 ; 1979 TH1 *hfit = (TH1*)GetObjectFit();; 1980 TF1 *f1 = (TF1*)GetUserFunc();; 1981 Int_t nd = hfit->GetDimension();; 1982 Int_t j;; 1983 Double_t *zik = GetZ();; 1984 Double_t *pl0 = GetPL0();; 1985 ; 1986 Double_t *df=new Double_t[npar];; 1987 ; 1988 npar = f1->GetNpar();; 1989 SetParNumber(npar);; 1990 if(flag == 9) {delete [] df; return;}; 1991 if (flag == 2) for (j=0;j<npar;j++) dersum[j] = gin[j] = 0;; 1992 f1->InitArgs(x,u);; 1993 f = 0;; 1994 ; 1995 Int_t npfit = 0;; 1996 Double_t *cache = fCache;; 1997 for (Int_t i=0;i<fNpoints;i++) {; 1998 if (nd > 2) x[2] = cache[4];; 1999 if (nd > 1) x[1] = cache[3];; 2000 x[0] = cache[2];; 2001 cu = cache[0];; 2002 TF1::RejectPoint(kFALSE);; 2003 if (nd < 2) {; 2004 fu = f1->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3])/cache[3];; 2005 } else if (nd < 3) {; 2006 fu = ((TF2*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5])/(cache[3]*cache[5]);; 2007 } else {; 2008 fu = ((TF3*)f1)->Integral(cache[2] - 0.5*cache[3],cache[2] + 0.5*cache[3],cache[4] - 0.5*cache[5],cache[4] + 0.5*cache[5],cache[6] - 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:56970,error,error,56970,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////; 319/// Add a float spectator or expression to the reader; 320 ; 321void TMVA::Reader::AddSpectator( const TString& expression, Float_t* datalink ); 322{; 323 DataInfo().AddSpectator( expression, """", """", 0, 0, 'F', kFALSE ,(void*)datalink );; 324}; 325 ; 326////////////////////////////////////////////////////////////////////////////////; 327/// Add an integer spectator or expression to the reader; 328 ; 329void TMVA::Reader::AddSpectator( const TString& expression, Int_t* datalink ); 330{; 331 DataInfo().AddSpectator(expression, """", """", 0, 0, 'I', kFALSE, (void*)datalink );; 332}; 333 ; 334////////////////////////////////////////////////////////////////////////////////; 335/// read the method type from the file; 336 ; 337TString TMVA::Reader::GetMethodTypeFromFile( const TString& filename ); 338{; 339 std::ifstream fin( filename );; 340 if (!fin.good()) { // file not found --> Error; 341 Log() << kFATAL << ""<BookMVA> fatal error: ""; 342 << ""unable to open input weight file: "" << filename << Endl;; 343 }; 344 ; 345 TString fullMethodName("""");; 346 if (filename.EndsWith("".xml"")) {; 347 fin.close();; 348 void* doc = gTools().xmlengine().ParseFile(filename,gTools().xmlenginebuffersize());// the default buffer size in TXMLEngine::ParseFile is 100k. Starting with ROOT 5.29 one can set the buffer size, see: http://savannah.cern.ch/bugs/?78864. This might be necessary for large XML files; 349 void* rootnode = gTools().xmlengine().DocGetRootElement(doc); // node ""MethodSetup""; 350 gTools().ReadAttr(rootnode, ""Method"", fullMethodName);; 351 gTools().xmlengine().FreeDoc(doc);; 352 }; 353 else {; 354 char buf[512];; 355 fin.getline(buf,512);; 356 while (!TString(buf).BeginsWith(""Method"")) fin.getline(buf,512);; 357 fullMethodName = TString(buf);; 358 fin.close();; 359 }; 360 TString methodType = fullMethodName(0,fullMethodName.Index(""::""));; 361 if (methodType.Contains("" "")) methodType = methodType(methodType.Last(' ')+1,methodType.Length());; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8cxx_source.html:12197,error,error,12197,doc/master/Reader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html,1,['error'],['error']
Availability,"////////////////////////////////; 3875/// Fit histogram with function fname.; 3876///; 3877///; 3878/// fname is the name of a function available in the global ROOT list of functions; 3879/// `gROOT->GetListOfFunctions`; 3880/// The list include any TF1 object created by the user plus some pre-defined functions; 3881/// which are automatically created by ROOT the first time a pre-defined function is requested from `gROOT`; 3882/// (i.e. when calling `gROOT->GetFunction(const char *name)`).; 3883/// These pre-defined functions are:; 3884/// - `gaus, gausn` where gausn is the normalized Gaussian; 3885/// - `landau, landaun`; 3886/// - `expo`; 3887/// - `pol1,...9, chebyshev1,...9`.; 3888///; 3889/// For printing the list of all available functions do:; 3890///; 3891/// TF1::InitStandardFunctions(); // not needed if `gROOT->GetFunction` is called before; 3892/// gROOT->GetListOfFunctions()->ls(); 3893///; 3894/// `fname` can also be a formula that is accepted by the linear fitter containing the special operator `++`,; 3895/// representing linear components separated by `++` sign, for example `x++sin(x)` for fitting `[0]*x+[1]*sin(x)`; 3896///; 3897/// This function finds a pointer to the TF1 object with name `fname` and calls TH1::Fit(TF1 *, Option_t *, Option_t *,; 3898/// Double_t, Double_t). See there for the fitting options and the details about fitting histograms; 3899 ; 3900TFitResultPtr TH1::Fit(const char *fname ,Option_t *option ,Option_t *goption, Double_t xxmin, Double_t xxmax); 3901{; 3902 char *linear;; 3903 linear= (char*)strstr(fname, ""++"");; 3904 Int_t ndim=GetDimension();; 3905 if (linear){; 3906 if (ndim<2){; 3907 TF1 f1(fname, fname, xxmin, xxmax);; 3908 return Fit(&f1,option,goption,xxmin,xxmax);; 3909 }; 3910 else if (ndim<3){; 3911 TF2 f2(fname, fname);; 3912 return Fit(&f2,option,goption,xxmin,xxmax);; 3913 }; 3914 else{; 3915 TF3 f3(fname, fname);; 3916 return Fit(&f3,option,goption,xxmin,xxmax);; 3917 }; 3918 }; 3919 else{; 3920 TF1 * f1 = (TF1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:153902,avail,available,153902,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['avail'],['available']
Availability,"///////////////////////////////; 2025/// Static function used to attach to an existing remote application; 2026/// or to start one.; 2027 ; 2028TApplication *TApplication::Open(const char *url,; 2029 Int_t debug, const char *script); 2030{; 2031 TApplication *ap = nullptr;; 2032 TUrl nu(url);; 2033 Int_t nnew = 0;; 2034 ; 2035 // Look among the existing ones; 2036 if (fgApplications) {; 2037 TIter nxa(fgApplications);; 2038 while ((ap = (TApplication *) nxa())) {; 2039 TString apn(ap->ApplicationName());; 2040 if (apn == url) {; 2041 // Found matching application; 2042 return ap;; 2043 } else {; 2044 // Check if same machine and user; 2045 TUrl au(apn);; 2046 if (strlen(au.GetUser()) > 0 && strlen(nu.GetUser()) > 0 &&; 2047 !strcmp(au.GetUser(), nu.GetUser())) {; 2048 if (!strncmp(au.GetHost(), nu.GetHost(), strlen(nu.GetHost()))); 2049 // New session on a known machine; 2050 nnew++;; 2051 }; 2052 }; 2053 }; 2054 } else {; 2055 ::Error(""TApplication::Open"", ""list of applications undefined - protocol error"");; 2056 return ap;; 2057 }; 2058 ; 2059 // If new session on a known machine pass the number as option; 2060 if (nnew > 0) {; 2061 nnew++;; 2062 nu.SetOptions(TString::Format(""%d"", nnew).Data());; 2063 }; 2064 ; 2065 // Instantiate the TApplication object to be run; 2066 TPluginHandler *h = nullptr;; 2067 if ((h = gROOT->GetPluginManager()->FindHandler(""TApplication"",""remote""))) {; 2068 if (h->LoadPlugin() == 0) {; 2069 ap = (TApplication *) h->ExecPlugin(3, nu.GetUrl(), debug, script);; 2070 } else {; 2071 ::Error(""TApplication::Open"", ""failed to load plugin for TApplicationRemote"");; 2072 }; 2073 } else {; 2074 ::Error(""TApplication::Open"", ""failed to find plugin for TApplicationRemote"");; 2075 }; 2076 ; 2077 // Add to the list; 2078 if (ap && !(ap->TestBit(kInvalidObject))) {; 2079 fgApplications->Add(ap);; 2080 gROOT->GetListOfBrowsables()->Add(ap, ap->ApplicationName());; 2081 TIter next(gROOT->GetListOfBrowsers());; 2082 TBrowser *b;; 2083 while ((b = (TBrow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:77564,error,error,77564,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////////////; 589 ; 590 for( it = source.begin(); it != source.end(); ++it ) {; 591 output << "" "";; 592 output << ""static Long_t offset_Onfile_"" << mappedName;; 593 output << ""_"" << it->second << "" = oldObj->GetClass()->GetDataMemberOffset(\"""";; 594 output << it->second << ""\"");\n"";; 595 }; 596 output << "" "" << ""char *onfile_add = (char*)oldObj->GetObject();\n"";; 597 output << "" "" << mappedName << ""_Onfile onfile(\n"";; 598 ; 599 for( start = true, it = source.begin(); it != source.end(); ++it ) {; 600 if( it->first.fType == """" ); 601 continue;; 602 ; 603 if( !start ); 604 output << "",\n"";; 605 ; 606 else; 607 start = false;; 608 ; 609 output << "" "";; 610 output << ""*("";; 611 if (it->first.fDimensions.size() == 0) {; 612 output << it->first.fType;; 613 } else {; 614 output << mappedName << ""_Onfile::onfile_"" << it->second << ""_t"";; 615 }; 616 output << ""*)(onfile_add+offset_Onfile_"";; 617 output << mappedName << ""_"" << it->second << "")"";; 618 }; 619 output << "" );\n\n"";; 620 }; 621 }; 622 ; 623 //-----------------------------------------------------------------------; 624 // Write down the targets; 625 //////////////////////////////////////////////////////////////////////////; 626 ; 627 if( !target.empty() ) {; 628 output << "" static TClassRef cls(\"""";; 629 output << className << ""\"");"" << std::endl;; 630 ; 631 std::list<std::string>::const_iterator it;; 632 for( it = target.begin(); it != target.end(); ++it ) {; 633 Internal::TSchemaType memData = members[*it];; 634 output << "" static Long_t offset_"" << *it << "" = "";; 635 output << ""cls->GetDataMemberOffset(\"""" << *it << ""\"");"";; 636 output << std::endl;; 637 if (memData.fDimensions.size()) {; 638 output << "" typedef "" << memData.fType << "" "" << *it << ""_t"" << memData.fDimensions << "";"" << std::endl;; 639 output << "" "" << *it << ""_t& "" << *it << "" = "";; 640 output << ""*("" << *it << ""_t *)(target+offset_"" << *it;; 641 output << "");"" << std::endl;; 642 } else {; 643 output << "" "" << memData.fType << ""&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:23107,down,down,23107,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['down'],['down']
Availability,"/////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation.; 743/// (see also comments in TProfile::GetBinError); 744 ; 745Double_t TProfile3D::GetBinError(Int_t bin) const; 746{; 747 return TProfileHelper::GetBinError((TProfile3D*)this, bin);; 748}; 749 ; 750////////////////////////////////////////////////////////////////////////////////; 751/// Return option to compute profile2D errors.; 752 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:25334,error,errors,25334,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////////////; 800/// Set zero values for point arrays in the range `[begin, end]`.; 801 ; 802void TGraphMultiErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 803{; 804 if (!from_ctor); 805 TGraph::FillZero(begin, end, from_ctor);; 806 ; 807 Int_t n = (end - begin) * sizeof(Double_t);; 808 memset(fExL + begin, 0, n);; 809 memset(fExH + begin, 0, n);; 810 memset(fEyLSum + begin, 0, n);; 811 memset(fEyHSum + begin, 0, n);; 812 ; 813 for (Int_t j = 0; j < fNYErrors; j++) {; 814 memset(fEyL[j].GetArray() + begin, 0, n);; 815 memset(fEyH[j].GetArray() + begin, 0, n);; 816 }; 817}; 818 ; 819////////////////////////////////////////////////////////////////////////////////; 820/// Recalculates the summed y error arrays.; 821 ; 822void TGraphMultiErrors::CalcYErrorsSum() const; 823{; 824 if (!fEyLSum); 825 fEyLSum = new Double_t[fNpoints];; 826 if (!fEyHSum); 827 fEyHSum = new Double_t[fNpoints];; 828 ; 829 for (Int_t i = 0; i < fNpoints; i++) {; 830 fEyLSum[i] = GetErrorYlow(i);; 831 fEyHSum[i] = GetErrorYhigh(i);; 832 }; 833}; 834 ; 835////////////////////////////////////////////////////////////////////////////////; 836/// Protected function to perform the merge operation of a graph with multiple asymmetric errors.; 837 ; 838Bool_t TGraphMultiErrors::DoMerge(const TGraph *tg); 839{; 840 if (tg->GetN() == 0); 841 return kFALSE;; 842 ; 843 if (tg->IsA() == TGraphMultiErrors::Class()) {; 844 auto tgme = (TGraphMultiErrors *)tg;; 845 ; 846 for (Int_t i = 0; i < tgme->GetN(); i++) {; 847 Int_t ipoint = GetN();; 848 Double_t x, y;; 849 tgme->GetPoint(i, x, y);; 850 SetPoint(ipoint, x, y);; 851 SetPointEX(ipoint, tgme->GetErrorXlow(i), tgme->GetErrorXhigh(i));; 852 for (Int_t j = 0; j < tgme->GetNYErrors(); j++); 853 SetPointEY(ipoint, j, tgme->GetErrorYlow(i, j), tgme->GetErrorYhigh(i, j));; 854 }; 855 ; 856 return kTRUE;; 857 } else {; 858 Warning(""DoMerge"", ""Merging a %s is not compatible with a TGraphMultiErrors - Errors will be ignored"",; 859 tg->Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:28680,error,errors,28680,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////////////; 1489/// Create a secure temporary file by appending a unique; 1490/// 6 letter string to base. The file will be created in; 1491/// a standard (system) directory or in the directory; 1492/// provided in dir. Optionally one can provide suffix; 1493/// append to the final name - like extension "".txt"" or "".html"".; 1494/// The full filename is returned in base; 1495/// and a filepointer is returned for safely writing to the file; 1496/// (this avoids certain security problems). Returns 0 in case; 1497/// of error.; 1498 ; 1499FILE *TSystem::TempFileName(TString &, const char *, const char *); 1500{; 1501 AbstractMethod(""TempFileName"");; 1502 return nullptr;; 1503}; 1504 ; 1505////////////////////////////////////////////////////////////////////////////////; 1506/// Set the file permission bits. Returns -1 in case or error, 0 otherwise.; 1507 ; 1508int TSystem::Chmod(const char *, UInt_t); 1509{; 1510 AbstractMethod(""Chmod"");; 1511 return -1;; 1512}; 1513 ; 1514////////////////////////////////////////////////////////////////////////////////; 1515/// Set the process file creation mode mask.; 1516 ; 1517int TSystem::Umask(Int_t); 1518{; 1519 AbstractMethod(""Umask"");; 1520 return -1;; 1521}; 1522 ; 1523////////////////////////////////////////////////////////////////////////////////; 1524/// Set the a files modification and access times. If actime = 0 it will be; 1525/// set to the modtime. Returns 0 on success and -1 in case of error.; 1526 ; 1527int TSystem::Utime(const char *, Long_t, Long_t); 1528{; 1529 AbstractMethod(""Utime"");; 1530 return -1;; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Find location of file in a search path. Return value points to TString for; 1535/// compatibility with Which(const char *, const char *, EAccessMode).; 1536/// Returns 0 in case file is not found.; 1537 ; 1538const char *TSystem::FindFile(const char *, TString&, EAccessMode); 1539{; 1540 Abstrac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:47815,mask,mask,47815,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['mask'],['mask']
Availability,"///////////////////////////; 859/// Return bin error of a Profile histogram; 860///; 861/// Computing errors: A moving field; 862///; 863/// The computation of errors for a TProfile has evolved with the versions; 864/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 865///; 866/// - prior to version 3.00, we had no special treatment of low statistic bins.; 867/// As a result, these bins had huge errors. The reason is that the; 868/// expression eprim2 is very close to 0 (rounding problems) or 0.; 869/// - in version 3.00 (18 Dec 2000), the algorithm is protected for values of; 870/// eprim2 very small and the bin errors set to the average bin errors, following; 871/// recommendations from a group of users.; 872/// - in version 3.01 (19 Apr 2001), it is realized that the algorithm above; 873/// should be applied only to low statistic bins.; 874/// - in version 3.02 (26 Sep 2001), the same group of users recommend instead; 875/// to take two times the average error on all bins for these low; 876/// statistics bins giving a very small value for eprim2.; 877/// - in version 3.04 (Nov 2002), the algorithm is modified/protected for the case; 878/// when a TProfile is projected (ProjectionX). The previous algorithm; 879/// generated a N^2 problem when projecting a TProfile with a large number of; 880/// bins (eg 100000).; 881/// - in version 3.05/06, a new static function TProfile::Approximate; 882/// is introduced to enable or disable (default) the approximation.; 883///; 884/// Ideas for improvements of this algorithm are welcome. No suggestions; 885/// received since our call for advice to roottalk in Jul 2002.; 886/// see for instance: http://root.cern/root/roottalk/roottalk02/2916.html; 887 ; 888Double_t TProfile::GetBinError(Int_t bin) const; 889{; 890 return TProfileHelper::GetBinError((TProfile*)this, bin);; 891}; 892 ; 893////////////////////////////////////////////////////////////////////////////////; 894/// Return option to compute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:32070,error,error,32070,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////; 1892/// Set eyL values for point `i`.; 1893 ; 1894void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t ne, const Double_t *eyL); 1895{; 1896 for (Int_t j = 0; j < fNYErrors; j++) {; 1897 if (j < ne); 1898 SetPointEYlow(i, j, eyL[j]);; 1899 else; 1900 SetPointEYlow(i, j, 0.);; 1901 }; 1902}; 1903 ; 1904////////////////////////////////////////////////////////////////////////////////; 1905/// Set eyH values for point `i`.; 1906 ; 1907void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t ne, const Double_t *eyH); 1908{; 1909 for (Int_t j = 0; j < fNYErrors; j++) {; 1910 if (j < ne); 1911 SetPointEYhigh(i, j, eyH[j]);; 1912 else; 1913 SetPointEYhigh(i, j, 0.);; 1914 }; 1915}; 1916 ; 1917////////////////////////////////////////////////////////////////////////////////; 1918/// Set error e ey values for point `i`.; 1919 ; 1920void TGraphMultiErrors::SetPointEY(Int_t i, Int_t e, Double_t eyL, Double_t eyH); 1921{; 1922 SetPointEYlow(i, e, eyL);; 1923 SetPointEYhigh(i, e, eyH);; 1924}; 1925 ; 1926////////////////////////////////////////////////////////////////////////////////; 1927/// Set error e eyL value for point `i`.; 1928 ; 1929void TGraphMultiErrors::SetPointEYlow(Int_t i, Int_t e, Double_t eyL); 1930{; 1931 if (i < 0 || e < 0); 1932 return;; 1933 ; 1934 if (i >= fNpoints); 1935 // re-allocate the object; 1936 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1937 ; 1938 while (e >= fNYErrors); 1939 AddYError(fNpoints);; 1940 ; 1941 fEyL[e][i] = eyL;; 1942 if (fEyLSum); 1943 fEyLSum[i] = GetErrorYlow(i);; 1944 else; 1945 CalcYErrorsSum();; 1946}; 1947 ; 1948////////////////////////////////////////////////////////////////////////////////; 1949/// Set error e eyH value for point `i`.; 1950 ; 1951void TGraphMultiErrors::SetPointEYhigh(Int_t i, Int_t e, Double_t eyH); 1952{; 1953 if (i < 0 || e < 0); 1954 return;; 1955 ; 1956 if (i >= fNpoints); 1957 // re-allocate the object; 1958 TGraphMultiErrors::SetPoint(i, 0., 0.);; 1959 ; 1960 while (e >= fNYErrors)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:65227,error,error,65227,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////; 2261/// The following named arguments are supported; 2262/// <table>; 2263/// <tr><th> Type of CmdArg <th> Effect on parameter box; 2264/// <tr><td> `Parameters(const RooArgSet& param)` <td> Only the specified subset of parameters will be shown. By default all non-constant parameters are shown.; 2265/// <tr><td> `ShowConstants(bool flag)` <td> Also display constant parameters; 2266/// <tr><td> `Format(const char* what,...)` <td> Parameter formatting options.; 2267/// | Parameter | Format; 2268/// | ---------------------- | --------------------------; 2269/// | `const char* what` | Controls what is shown. ""N"" adds name (alternatively, ""T"" adds the title), ""E"" adds error, ""A"" shows asymmetric error, ""U"" shows unit, ""H"" hides the value; 2270/// | `FixedPrecision(int n)`| Controls precision, set fixed number of digits; 2271/// | `AutoPrecision(int n)` | Controls precision. Number of shown digits is calculated from error + n specified additional digits (1 is sensible default); 2272/// <tr><td> `Label(const chat* label)` <td> Add label to parameter box. Use `\n` for multi-line labels.; 2273/// <tr><td> `Layout(double xmin, double xmax, double ymax)` <td> Specify relative position of left/right side of box and top of box.; 2274/// Coordinates are given as position on the pad between 0 and 1.; 2275/// The lower end of the box is calculated automatically from the number of lines in the box.; 2276/// </table>; 2277///; 2278///; 2279/// Example use:; 2280/// ```; 2281/// pdf.paramOn(frame, Label(""fit result""), Format(""NEU"",AutoPrecision(1)) ) ;; 2282/// ```; 2283///; 2284 ; 2285RooPlot* RooAbsPdf::paramOn(RooPlot* frame, const RooCmdArg& arg1, const RooCmdArg& arg2,; 2286 const RooCmdArg& arg3, const RooCmdArg& arg4, const RooCmdArg& arg5,; 2287 const RooCmdArg& arg6, const RooCmdArg& arg7, const RooCmdArg& arg8); 2288{; 2289 // Stuff all arguments in a list; 2290 RooLinkedList cmdList;; 2291 cmdList.Add(const_cast<RooCmdArg*>(&arg1)) ; cmdList.Add(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:110542,error,error,110542,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////////; 472/// Refresh this physical node. Called for all registered physical nodes; 473/// after an Align() call.; 474 ; 475void TGeoPhysicalNode::Refresh(); 476{; 477 SetPath(fName.Data());; 478}; 479 ; 480////////////////////////////////////////////////////////////////////////////////; 481/// Set node branch according to current state; 482 ; 483void TGeoPhysicalNode::SetBranchAsState(); 484{; 485 TGeoNodeCache *cache = gGeoManager->GetCache();; 486 if (!cache) {; 487 Error(""SetBranchAsState"", ""no state available"");; 488 return;; 489 }; 490 if (!cache->IsDummy()) {; 491 Error(""SetBranchAsState"", ""not implemented for full cache"");; 492 return;; 493 }; 494 if (!fNodes); 495 fNodes = new TObjArray(30);; 496 if (!fMatrices); 497 fMatrices = new TObjArray(30);; 498 TGeoHMatrix **matrices = (TGeoHMatrix **)cache->GetMatrices();; 499 TGeoNode **branch = (TGeoNode **)cache->GetBranch();; 500 ; 501 Bool_t refresh = (fLevel > 0) ? kTRUE : kFALSE;; 502 if (refresh) {; 503 TGeoHMatrix *current;; 504 for (Int_t i = 0; i <= fLevel; i++) {; 505 fNodes->AddAtAndExpand(branch[i], i);; 506 current = (TGeoHMatrix *)fMatrices->UncheckedAt(i);; 507 *current = *matrices[i];; 508 }; 509 return;; 510 }; 511 fLevel = gGeoManager->GetLevel();; 512 for (Int_t i = 0; i <= fLevel; i++) {; 513 fNodes->AddAtAndExpand(branch[i], i);; 514 fMatrices->AddAtAndExpand(new TGeoHMatrix(*matrices[i]), i);; 515 }; 516 TGeoNode *node = (TGeoNode *)fNodes->UncheckedAt(fLevel);; 517 if (!fMatrixOrig); 518 fMatrixOrig = new TGeoHMatrix();; 519 *fMatrixOrig = node->GetMatrix();; 520}; 521 ; 522////////////////////////////////////////////////////////////////////////////////; 523/// Allows PN entries (or users) to preset the local original matrix for the; 524/// last node pointed by the path.; 525 ; 526void TGeoPhysicalNode::SetMatrixOrig(const TGeoMatrix *local); 527{; 528 if (!fMatrixOrig); 529 fMatrixOrig = new TGeoHMatrix();; 530 if (!local) {; 531 fMatrixOrig->Clear();; 532 return;; 533",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html:16544,avail,available,16544,doc/master/TGeoPhysicalNode_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPhysicalNode_8cxx_source.html,1,['avail'],['available']
Availability,"///////////////////////; 1193/// Print the path of the directory.; 1194 ; 1195void TDirectory::pwd() const; 1196{; 1197 Printf(""%s"", GetPath());; 1198}; 1199 ; 1200////////////////////////////////////////////////////////////////////////////////; 1201/// Recursively remove object from a Directory.; 1202 ; 1203void TDirectory::RecursiveRemove(TObject *obj); 1204{; 1205 if (fList); 1206 fList->RecursiveRemove(obj);; 1207}; 1208 ; 1209////////////////////////////////////////////////////////////////////////////////; 1210/// Remove an object from the in-memory list.; 1211 ; 1212TObject *TDirectory::Remove(TObject* obj); 1213{; 1214 TObject *p = nullptr;; 1215 if (fList) {; 1216 p = fList->Remove(obj);; 1217 }; 1218 return p;; 1219}; 1220 ; 1221////////////////////////////////////////////////////////////////////////////////; 1222/// Removes subdirectory from the directory; 1223/// When directory is deleted, all keys in all subdirectories will be; 1224/// read first and deleted from file (if exists); 1225/// Equivalent call is Delete(""name;*"");; 1226 ; 1227void TDirectory::rmdir(const char *name); 1228{; 1229 if ((name==nullptr) || (*name==0)) return;; 1230 ; 1231 TString mask(name);; 1232 mask+="";*"";; 1233 Delete(mask);; 1234}; 1235 ; 1236////////////////////////////////////////////////////////////////////////////////; 1237/// Save object in filename,; 1238/// if filename is `nullptr` or """", a file with ""<objectname>.root"" is created.; 1239/// The name of the key is the object name.; 1240/// By default new file will be created. Using option ""a"", one can append object; 1241/// to the existing ROOT file.; 1242/// If the operation is successful, it returns the number of bytes written to the file; 1243/// otherwise it returns 0.; 1244/// By default a message is printed. Use option ""q"" to not print the message.; 1245/// If filename contains "".json"" extension, JSON representation of the object; 1246/// will be created and saved in the text file. Such file can be used in; 1247///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:42225,mask,mask,42225,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,3,['mask'],['mask']
Availability,"///////////////////////; 2013/// Attempt to recover file if not correctly closed; 2014///; 2015/// The function returns the number of keys that have been recovered.; 2016/// If no keys can be recovered, the file will be declared Zombie by; 2017/// the calling function. This function is automatically called when; 2018/// opening a file.; 2019/// If the file is open in read only mode, the file is not modified.; 2020/// If open in update mode and the function finds something to recover,; 2021/// a new directory header is written to the file. When opening the file gain; 2022/// no message from Recover will be reported.; 2023/// If keys have been recovered, the file is usable and you can safely; 2024/// read the corresponding objects.; 2025/// If the file is not usable (a zombie), you can test for this case; 2026/// with code like:; 2027///; 2028/// ~~~{.cpp}; 2029/// TFile f(""myfile.root"");; 2030/// if (f.IsZombie()) {<actions to take if file is unusable>}; 2031/// ~~~; 2032///; 2033/// If the file has been recovered, the bit kRecovered is set in the TFile object in memory.; 2034/// You can test if the file has been recovered with; 2035///; 2036/// if (f.TestBit(TFile::kRecovered)) {... the file has been recovered}; 2037///; 2038/// When writing TTrees to a file, it is important to save the Tree header; 2039/// at regular intervals (see TTree::AutoSave). If a file containing a Tree; 2040/// is recovered, the last Tree header written to the file will be used.; 2041/// In this case all the entries in all the branches written before writing; 2042/// the header are valid entries.; 2043/// One can disable the automatic recovery procedure by setting; 2044///; 2045/// TFile.Recover 0; 2046///; 2047/// in the <em>system.rootrc</em> file.; 2048 ; 2049Int_t TFile::Recover(); 2050{; 2051 Short_t keylen,cycle;; 2052 UInt_t datime;; 2053 Int_t nbytes,date,time,objlen,nwheader;; 2054 Long64_t seekkey,seekpdir;; 2055 char header[1024];; 2056 char *buffer, *bufread;; 2057 char nwhc;; 20",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:72634,recover,recovered,72634,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['recover'],['recovered']
Availability,"///////////////////////; 3368/// Interface function to force use of a given normalization range; 3369/// to interpret function value. Needed for functions or p.d.f.s; 3370/// whose shape depends on the choice of normalization such as; 3371/// RooAddPdf; 3372 ; 3373void RooAbsReal::selectNormalizationRange(const char*, bool); 3374{; 3375}; 3376 ; 3377 ; 3378 ; 3379////////////////////////////////////////////////////////////////////////////////; 3380/// Advertise capability to determine maximum value of function for given set of; 3381/// observables. If no direct generator method is provided, this information; 3382/// will assist the accept/reject generator to operate more efficiently as; 3383/// it can skip the initial trial sampling phase to empirically find the function; 3384/// maximum; 3385 ; 3386Int_t RooAbsReal::getMaxVal(const RooArgSet& /*vars*/) const; 3387{; 3388 return 0 ;; 3389}; 3390 ; 3391 ; 3392 ; 3393////////////////////////////////////////////////////////////////////////////////; 3394/// Return maximum value for set of observables identified by code assigned; 3395/// in getMaxVal; 3396 ; 3397double RooAbsReal::maxVal(Int_t /*code*/) const; 3398{; 3399 assert(1) ;; 3400 return 0 ;; 3401}; 3402 ; 3403 ; 3404 ; 3405////////////////////////////////////////////////////////////////////////////////; 3406/// Interface to insert remote error logging messages received by RooRealMPFE into current error logging stream.; 3407 ; 3408void RooAbsReal::logEvalError(const RooAbsReal* originator, const char* origName, const char* message, const char* serverValueString); 3409{; 3410 if (evalErrorData().mode == Ignore) {; 3411 return ;; 3412 }; 3413 ; 3414 if (evalErrorData().mode == CountErrors) {; 3415 evalErrorData().count++ ;; 3416 return ;; 3417 }; 3418 ; 3419 static bool inLogEvalError = false ;; 3420 ; 3421 if (inLogEvalError) {; 3422 return ;; 3423 }; 3424 inLogEvalError = true ;; 3425 ; 3426 EvalError ee ;; 3427 ee.setMessage(message) ;; 3428 ; 3429 if (serverVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:146257,error,error,146257,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,2,['error'],['error']
Availability,"///////////////////////; 840/// Return bin entries of a Profile2D histogram.; 841 ; 842Double_t TProfile2D::GetBinEntries(Int_t bin) const; 843{; 844 if (fBuffer) ((TProfile2D*)this)->BufferEmpty();; 845 ; 846 if (bin < 0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:30030,error,error,30030,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////////; 2682/// Visit all members over members, recursing over base classes.; 2683 ; 2684void TCling::InspectMembers(TMemberInspector& insp, const void* obj,; 2685 const TClass* cl, Bool_t isTransient); 2686{; 2687 if (insp.GetObjectValidity() == TMemberInspector::kUnset) {; 2688 insp.SetObjectValidity(obj ? TMemberInspector::kValidObjectGiven; 2689 : TMemberInspector::kNoObjectGiven);; 2690 }; 2691 ; 2692 if (!cl || cl->GetCollectionProxy()) {; 2693 // We do not need to investigate the content of the STL; 2694 // collection, they are opaque to us (and details are; 2695 // uninteresting).; 2696 return;; 2697 }; 2698 ; 2699 static const TClassRef clRefString(""std::string"");; 2700 if (clRefString == cl) {; 2701 // We stream std::string without going through members..; 2702 return;; 2703 }; 2704 ; 2705 if (TClassEdit::IsStdArray(cl->GetName())) {; 2706 // We treat std arrays as C arrays; 2707 return;; 2708 }; 2709 ; 2710 if (TClassEdit::IsUniquePtr(cl->GetName())) {; 2711 // Ignore error caused by the inside of std::unique_ptr; 2712 // This is needed solely because of rootclingIO's IsUnsupportedUniquePointer; 2713 // which checks the number of elements in the GetListOfRealData.; 2714 // If this usage is removed, this can be replaced with a return statement.; 2715 // See https://github.com/root-project/root/issues/13574; 2716 isTransient = true;; 2717 }; 2718 ; 2719 const char* cobj = (const char*) obj; // for ptr arithmetics; 2720 ; 2721 // Treat the case of std::complex in a special manner. We want to enforce; 2722 // the layout of a stl implementation independent class, which is the; 2723 // complex as implemented in ROOT5.; 2724 ; 2725 // A simple lambda to simplify the code; 2726 auto inspInspect = [&] (ptrdiff_t offset){; 2727 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_real"", cobj, isTransient);; 2728 insp.Inspect(const_cast<TClass*>(cl), insp.GetParent(), ""_imag"", cobj + offset, isTransient);; 2729 };; 2730 ; 2731 auto complexType =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:104551,error,error,104551,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////////; 126/// Constructor with four vectors of floats in input.; 127///; 128/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 129/// and the errors from vectors vex and vey.; 130/// The number of points in the graph is the minimum of number of points; 131/// in vx and vy.; 132 ; 133TGraphErrors::TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey); 134 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 135{; 136 if (!CtorAllocate()) return;; 137 Int_t ivexlow = vex.GetLwb();; 138 Int_t iveylow = vey.GetLwb();; 139 for (Int_t i = 0; i < fNpoints; i++) {; 140 fEX[i] = vex(i + ivexlow);; 141 fEY[i] = vey(i + iveylow);; 142 }; 143}; 144 ; 145 ; 146////////////////////////////////////////////////////////////////////////////////; 147/// Constructor with four vectors of doubles in input.; 148///; 149/// A grapherrors is built with the X coordinates taken from vx and Y coord from vy; 150/// and the errors from vectors vex and vey.; 151/// The number of points in the graph is the minimum of number of points; 152/// in vx and vy.; 153 ; 154TGraphErrors::TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey); 155 : TGraph(TMath::Min(vx.GetNrows(), vy.GetNrows()), vx.GetMatrixArray(), vy.GetMatrixArray() ); 156{; 157 if (!CtorAllocate()) return;; 158 Int_t ivexlow = vex.GetLwb();; 159 Int_t iveylow = vey.GetLwb();; 160 for (Int_t i = 0; i < fNpoints; i++) {; 161 fEX[i] = vex(i + ivexlow);; 162 fEY[i] = vey(i + iveylow);; 163 }; 164}; 165 ; 166 ; 167////////////////////////////////////////////////////////////////////////////////; 168/// TGraphErrors copy constructor.; 169 ; 170TGraphErrors::TGraphErrors(const TGraphErrors &gr); 171 : TGraph(gr); 172{; 173 if (!CtorAllocate()) return;; 174 ; 175 Int_t n = sizeof(Double_t) * fNpoints;; 176 memcpy(fEX, gr.fEX, n);; 177 memcpy(fEY, gr.fEY, n);; 178}; 179 ; 180",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:4874,error,errors,4874,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/////////////////////; 743/// Returns `x` raised to the power `y`.; 744 ; 745inline Double_t TMath::Power(Double_t x, Int_t y) {; 746#ifdef R__ANSISTREAM; 747 return std::pow(x, y);; 748#else; 749 return pow(x, (Double_t) y);; 750#endif; 751}; 752 ; 753////////////////////////////////////////////////////////////////////////////////; 754/// Returns the natural logarithm of `x`.; 755 ; 756inline Double_t TMath::Log(Double_t x); 757 { return log(x); }; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Returns the common (base-10) logarithm of `x`.; 761 ; 762inline Double_t TMath::Log10(Double_t x); 763 { return log10(x); }; 764 ; 765////////////////////////////////////////////////////////////////////////////////; 766/// Check if it is finite with a mask in order to be consistent in presence of; 767/// fast math.; 768/// Inspired from the CMSSW FWCore/Utilities package; 769 ; 770inline Int_t TMath::Finite(Double_t x); 771#if defined(R__FAST_MATH); 772 ; 773{; 774 const unsigned long long mask = 0x7FF0000000000000LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:28979,mask,mask,28979,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,1,['mask'],['mask']
Availability,"////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()); 1558 return -1.;; 1559 ; 1560 return fEyL[e][i];; 1561}; 1562 ; 1563////////////////////////////////////////////////////////////////////////////////; 1564/// Get high error e on y coordinate for point `i`.; 1565 ; 1566Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i, Int_t e) const; 1567{; 1568 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyH.empty()); 1569 return -1.;; 1570 ; 1571 return fEyH[e][i];; 1572}; 1573 ; 1574////////////////////////////////////////////////////////////////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54229,error,errors,54229,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,////////////////////; 1575/// Get all low errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1576 ; 1577Double_t *TGraphMultiErrors::GetEYlow() const; 1578{; 1579 if (!fEyLSum); 1580 CalcYErrorsSum();; 1581 ; 1582 return fEyLSum;; 1583}; 1584 ; 1585////////////////////////////////////////////////////////////////////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640//////////////////////////////////////////////////////////////////,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:54900,error,errors,54900,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"////////////////////; 3873/// Set interval timer to time-out in ms milliseconds.; 3874 ; 3875int TUnixSystem::UnixSetitimer(Long_t ms); 3876{; 3877 struct itimerval itv;; 3878 itv.it_value.tv_sec = 0;; 3879 itv.it_value.tv_usec = 0;; 3880 itv.it_interval.tv_sec = 0;; 3881 itv.it_interval.tv_usec = 0;; 3882 if (ms > 0) {; 3883 itv.it_value.tv_sec = time_t(ms / 1000);; 3884 itv.it_value.tv_usec = time_t((ms % 1000) * 1000);; 3885 }; 3886 int st = setitimer(ITIMER_REAL, &itv, nullptr);; 3887 if (st == -1); 3888 ::SysError(""TUnixSystem::UnixSetitimer"", ""setitimer"");; 3889 return st;; 3890}; 3891 ; 3892//---- file descriptors --------------------------------------------------------; 3893 ; 3894////////////////////////////////////////////////////////////////////////////////; 3895/// Wait for events on the file descriptors specified in the readready and; 3896/// writeready masks or for timeout (in milliseconds) to occur. Returns; 3897/// the number of ready descriptors, or 0 in case of timeout, or < 0 in; 3898/// case of an error, with -2 being EINTR and -3 EBADF. In case of EINTR; 3899/// the errno has been reset and the method can be called again.; 3900 ; 3901int TUnixSystem::UnixSelect(Int_t nfds, TFdSet *readready, TFdSet *writeready,; 3902 Long_t timeout); 3903{; 3904 int retcode;; 3905 ; 3906 fd_set *rd = (readready) ? (fd_set*)readready->GetBits() : nullptr;; 3907 fd_set *wr = (writeready) ? (fd_set*)writeready->GetBits() : nullptr;; 3908 ; 3909 if (timeout >= 0) {; 3910 struct timeval tv;; 3911 tv.tv_sec = Int_t(timeout / 1000);; 3912 tv.tv_usec = (timeout % 1000) * 1000;; 3913 retcode = select(nfds, rd, wr, nullptr, &tv);; 3914 } else {; 3915 retcode = select(nfds, rd, wr, nullptr, nullptr);; 3916 }; 3917 if (retcode == -1) {; 3918 if (GetErrno() == EINTR) {; 3919 ResetErrno(); // errno is not self reseting; 3920 return -2;; 3921 }; 3922 if (GetErrno() == EBADF); 3923 return -3;; 3924 return -1;; 3925 }; 3926 ; 3927 return retcode;; 3928}; 3929 ; 3930//---- direct",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:124919,error,error,124919,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,///////////////////; 203/// This function is called by Graph2DFitChisquare.; 204/// It returns the error along X at point i.; 205 ; 206Double_t TGraph2DErrors::GetErrorX(Int_t i) const; 207{; 208 if (i < 0 || i >= fNpoints) return -1;; 209 if (fEX) return fEX[i];; 210 return -1;; 211}; 212 ; 213 ; 214////////////////////////////////////////////////////////////////////////////////; 215/// This function is called by Graph2DFitChisquare.; 216/// It returns the error along Y at point i.; 217 ; 218Double_t TGraph2DErrors::GetErrorY(Int_t i) const; 219{; 220 if (i < 0 || i >= fNpoints) return -1;; 221 if (fEY) return fEY[i];; 222 return -1;; 223}; 224 ; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// This function is called by Graph2DFitChisquare.; 228/// It returns the error along Z at point i.; 229 ; 230Double_t TGraph2DErrors::GetErrorZ(Int_t i) const; 231{; 232 if (i < 0 || i >= fNpoints) return -1;; 233 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:6986,error,errors,6986,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"///////////////////; 675/// Canvas destructor; 676 ; 677TCanvas::~TCanvas(); 678{; 679 Destructor();; 680}; 681 ; 682////////////////////////////////////////////////////////////////////////////////; 683/// Browse.; 684 ; 685void TCanvas::Browse(TBrowser *b); 686{; 687 Draw();; 688 cd();; 689 if (fgIsFolder) fPrimitives->Browse(b);; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Actual canvas destructor.; 694 ; 695void TCanvas::Destructor(); 696{; 697 if (gThreadXAR) {; 698 void *arr[2];; 699 arr[1] = this;; 700 if ((*gThreadXAR)(""CDEL"", 2, arr, nullptr)) return;; 701 }; 702 ; 703 if (ROOT::Detail::HasBeenDeleted(this)) return;; 704 ; 705 SafeDelete(fContextMenu);; 706 if (!gPad) return;; 707 ; 708 Close();; 709 ; 710 //If not yet (batch mode?).; 711 SafeDelete(fPainter);; 712}; 713 ; 714////////////////////////////////////////////////////////////////////////////////; 715/// Set current canvas & pad. Returns the new current pad,; 716/// or 0 in case of failure.; 717/// See TPad::cd() for an explanation of the parameter.; 718 ; 719TVirtualPad *TCanvas::cd(Int_t subpadnumber); 720{; 721 if (fCanvasID == -1) return nullptr;; 722 ; 723 TPad::cd(subpadnumber);; 724 ; 725 // in case doublebuffer is off, draw directly onto display window; 726 if (!IsBatch() && !IsWeb() && !fDoubleBuffer); 727 gVirtualX->SelectWindow(fCanvasID);//Ok, does not matter for glpad.; 728 ; 729 return gPad;; 730}; 731 ; 732////////////////////////////////////////////////////////////////////////////////; 733/// Remove all primitives from the canvas.; 734/// If option ""D"" is specified, direct sub-pads are cleared but not deleted.; 735/// This option is not recursive, i.e. pads in direct sub-pads are deleted.; 736 ; 737void TCanvas::Clear(Option_t *option); 738{; 739 if (fCanvasID == -1) return;; 740 ; 741 R__LOCKGUARD(gROOTMutex);; 742 ; 743 TString opt = option;; 744 opt.ToLower();; 745 if (opt.Contains(""d"")) {; 746 // clear subpads, but do no",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:23349,failure,failure,23349,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['failure'],['failure']
Availability,"//////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is needed to compute the correct statistical quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is deleted; 1378 ; 1379void TProfile3D::Sumw2(Bool_t flag); 1380{; 1381 TProfileHelper::Sumw2(this, flag);; 1382}; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; THashList.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfile3D.h; TProfileHelper.h; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:53120,error,error,53120,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"//////////////////; 4910/// Cast obj of this class type up to baseclass cl if up is true.; 4911/// Cast obj of this class type down from baseclass cl if up is false.; 4912/// If this class is not a baseclass of cl return 0, else the pointer; 4913/// to the cl part of this (up) or to this (down).; 4914 ; 4915void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4916{; 4917 if (cl == this) return obj;; 4918 ; 4919 if (!HasDataMemberInfo()) return nullptr;; 4920 ; 4921 Int_t off;; 4922 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4923 if (up); 4924 return (void*)((Longptr_t)obj+off);; 4925 else; 4926 return (void*)((Longptr_t)obj-off);; 4927 }; 4928 return nullptr;; 4929}; 4930 ; 4931////////////////////////////////////////////////////////////////////////////////; 4932/// Cast obj of this class type up to baseclass cl if up is true.; 4933/// Cast obj of this class type down from baseclass cl if up is false.; 4934/// If this class is not a baseclass of cl return 0, else the pointer; 4935/// to the cl part of this (up) or to this (down).; 4936 ; 4937const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 4938{; 4939 return DynamicCast(cl,const_cast<void*>(obj),up);; 4940}; 4941 ; 4942////////////////////////////////////////////////////////////////////////////////; 4943/// Return a pointer to a newly allocated object of this class.; 4944/// The class must have a default constructor. For meaning of; 4945/// defConstructor, see TClass::IsCallingNew().; 4946///; 4947/// If quiet is true, do no issue a message via Error on case; 4948/// of problems, just return 0.; 4949///; 4950/// The constructor actually called here can be customized by; 4951/// using the rootcint pragma:; 4952/// ~~~ {.cpp}; 4953/// #pragma link C++ ioctortype UserClass;; 4954/// ~~~; 4955/// For example, with this pragma and a class named MyClass,; 4956/// this method will called the first of the following 3; 4957/// constructors which exists and is public:; 4958///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:188112,down,down,188112,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['down'],['down']
Availability,"//////////////////; 4977/// Cast obj of this class type up to baseclass cl if up is true.; 4978/// Cast obj of this class type down from baseclass cl if up is false.; 4979/// If this class is not a baseclass of cl return 0, else the pointer; 4980/// to the cl part of this (up) or to this (down).; 4981 ; 4982void *TClass::DynamicCast(const TClass *cl, void *obj, Bool_t up); 4983{; 4984 if (cl == this) return obj;; 4985 ; 4986 if (!HasDataMemberInfo()) return nullptr;; 4987 ; 4988 Int_t off;; 4989 if ((off = GetBaseClassOffset(cl, obj)) != -1) {; 4990 if (up); 4991 return (void*)((Longptr_t)obj+off);; 4992 else; 4993 return (void*)((Longptr_t)obj-off);; 4994 }; 4995 return nullptr;; 4996}; 4997 ; 4998////////////////////////////////////////////////////////////////////////////////; 4999/// Cast obj of this class type up to baseclass cl if up is true.; 5000/// Cast obj of this class type down from baseclass cl if up is false.; 5001/// If this class is not a baseclass of cl return 0, else the pointer; 5002/// to the cl part of this (up) or to this (down).; 5003 ; 5004const void *TClass::DynamicCast(const TClass *cl, const void *obj, Bool_t up); 5005{; 5006 return DynamicCast(cl,const_cast<void*>(obj),up);; 5007}; 5008 ; 5009////////////////////////////////////////////////////////////////////////////////; 5010/// Return a pointer to a newly allocated object of this class.; 5011/// The class must have a default constructor. For meaning of; 5012/// defConstructor, see TClass::IsCallingNew().; 5013///; 5014/// If quiet is true, do no issue a message via Error on case; 5015/// of problems, just return 0.; 5016///; 5017/// The constructor actually called here can be customized by; 5018/// using the rootcint pragma:; 5019/// ~~~ {.cpp}; 5020/// #pragma link C++ ioctortype UserClass;; 5021/// ~~~; 5022/// For example, with this pragma and a class named MyClass,; 5023/// this method will called the first of the following 3; 5024/// constructors which exists and is public:; 5025///",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:190863,down,down,190863,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['down'],['down']
Availability,"/////////////////; 1071/// Main minimization procedure; 1072///; 1073/// This function is called after setting theoretical function; 1074/// by means of TFumili::SetUserFunc and initializing parameters.; 1075/// Optionally one can set FCN function (see TFumili::SetFCN and TFumili::Eval); 1076/// If FCN is undefined then user has to provide data arrays by calling; 1077/// TFumili::SetData procedure.; 1078///; 1079/// TFumili::Minimize return following values:; 1080/// - 0 - fit is converged; 1081/// - -2 - function is not decreasing (or bad derivatives); 1082/// - -3 - error estimations are infinite; 1083/// - -4 - maximum number of iterations is exceeded; 1084 ; 1085Int_t TFumili::Minimize(); 1086{; 1087 Int_t i;; 1088 // Flag3 - is fit is chi2 or likelihood? 0 - chi2, 1 - likelihood; 1089 fINDFLG[2]=0;; 1090 //; 1091 // Are the parameters outside of the boundaries ?; 1092 //; 1093 Int_t parn;; 1094 ; 1095 if(fFCN) {; 1096 Eval(parn,fGr,fS,fA,9); fNfcn++;; 1097 }; 1098 for( i = 0; i < fNpar; i++) {; 1099 if(fA[i] > fAMX[i]) fA[i] = fAMX[i];; 1100 if(fA[i] < fAMN[i]) fA[i] = fAMN[i];; 1101 }; 1102 ; 1103 Int_t nn2, n, fixFLG, ifix1, fi, nn3, nn1, n0;; 1104 Double_t t1;; 1105 Double_t sp, t, olds=0;; 1106 Double_t bi, aiMAX=0, amb;; 1107 Double_t afix, sigi, akap;; 1108 Double_t alambd, al, bm, abi, abm;; 1109 Int_t l1, k, ifix;; 1110 ; 1111 nn2=0;; 1112 ; 1113 // Number of parameters;; 1114 n=fNpar;; 1115 fixFLG=0;; 1116 ; 1117 // Exit flag; 1118 fENDFLG=0;; 1119 ; 1120 // Flag2; 1121 fINDFLG[1] = 0;; 1122 ifix1=-1;; 1123 fi=0;; 1124 nn3=0;; 1125 ; 1126 // Initialize param.step limits; 1127 for( i=0; i < n; i++) {; 1128 fR[i]=0.;; 1129 if ( fEPS > 0.) fParamError[i] = 0.;; 1130 fPL[i] = fPL0[i];; 1131 }; 1132 ; 1133L3: // Start Iteration; 1134 ; 1135 nn1 = 1;; 1136 t1 = 1.;; 1137 ; 1138L4: // New iteration; 1139 ; 1140 // fS - objective function value - zero first; 1141 fS = 0.;; 1142 // n0 - number of variable parameters in fit; 1143 n0 = 0;; 1144 for( i = 0; i < n;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFumili_8cxx_source.html:31307,error,error,31307,doc/master/TFumili_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFumili_8cxx_source.html,1,['error'],['error']
Availability,/////////////////; 1586/// Get all high errors on y coordinates as an array summed according to `fSumErrorsMode`.; 1587 ; 1588Double_t *TGraphMultiErrors::GetEYhigh() const; 1589{; 1590 if (!fEyHSum); 1591 CalcYErrorsSum();; 1592 ; 1593 return fEyHSum;; 1594}; 1595 ; 1596////////////////////////////////////////////////////////////////////////////////; 1597/// Get all low errors `e` on y coordinates as an array.; 1598 ; 1599Double_t *TGraphMultiErrors::GetEYlow(Int_t e); 1600{; 1601 if (e >= fNYErrors || fEyL.empty()); 1602 return nullptr;; 1603 else; 1604 return fEyL[e].GetArray();; 1605}; 1606 ; 1607////////////////////////////////////////////////////////////////////////////////; 1608/// Get all high errors `e` on y coordinates as an array.; 1609 ; 1610Double_t *TGraphMultiErrors::GetEYhigh(Int_t e); 1611{; 1612 if (e >= fNYErrors || fEyH.empty()); 1613 return nullptr;; 1614 else; 1615 return fEyH[e].GetArray();; 1616}; 1617 ; 1618////////////////////////////////////////////////////////////////////////////////; 1619/// Get AttFill pointer for specified error dimension.; 1620 ; 1621TAttFill *TGraphMultiErrors::GetAttFill(Int_t e); 1622{; 1623 if (e >= 0 && e < fNYErrors); 1624 return &fAttFill.at(e);; 1625 else; 1626 return nullptr;; 1627}; 1628 ; 1629////////////////////////////////////////////////////////////////////////////////; 1630/// Get AttLine pointer for specified error dimension.; 1631 ; 1632TAttLine *TGraphMultiErrors::GetAttLine(Int_t e); 1633{; 1634 if (e >= 0 && e < fNYErrors); 1635 return &fAttLine.at(e);; 1636 else; 1637 return nullptr;; 1638}; 1639 ; 1640////////////////////////////////////////////////////////////////////////////////; 1641/// Get Fill Color for specified error e (-1 = Global and x errors).; 1642 ; 1643Color_t TGraphMultiErrors::GetFillColor(Int_t e) const; 1644{; 1645 if (e == -1); 1646 return GetFillColor();; 1647 else if (e >= 0 && e < fNYErrors); 1648 return fAttFill[e].GetFillColor();; 1649 else; 1650 return 0;; 1651}; 1652 ; 165,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:55259,error,error,55259,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////; 443/// Scan the memory lists of all files for an object with name; 444 ; 445TObject *TDirectoryFile::FindObjectAnyFile(const char *name) const; 446{; 447 TFile *f;; 448 R__LOCKGUARD(gROOTMutex);; 449 TIter next(gROOT->GetListOfFiles());; 450 while ((f = (TFile*)next())) {; 451 TObject *obj = f->GetList()->FindObject(name);; 452 if (obj) return obj;; 453 }; 454 return nullptr;; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Find a directory named ""apath"".; 459///; 460/// It apath is null or empty, returns ""this"" directory.; 461/// Otherwise use the name ""apath"" to find a directory.; 462/// The absolute path syntax is:; 463///; 464/// file.root:/dir1/dir2; 465///; 466/// where file.root is the file and /dir1/dir2 the desired subdirectory; 467/// in the file. Relative syntax is relative to ""this"" directory. E.g:; 468/// ../aa.; 469/// Returns 0 in case path does not exist.; 470/// If printError is true, use Error with 'funcname' to issue an error message.; 471 ; 472TDirectory *TDirectoryFile::GetDirectory(const char *apath,; 473 Bool_t printError, const char *funcname); 474{; 475 Int_t nch = 0;; 476 if (apath) nch = strlen(apath);; 477 if (!nch) {; 478 return this;; 479 }; 480 ; 481 if (funcname==0 || strlen(funcname)==0) funcname = ""GetDirectory"";; 482 ; 483 TDirectory *result = this;; 484 ; 485 char *path = new char[nch+1]; path[0] = 0;; 486 if (nch) strlcpy(path,apath,nch+1);; 487 char *s = (char*)strchr(path, ':');; 488 if (s) {; 489 *s = '\0';; 490 R__LOCKGUARD(gROOTMutex);; 491 TDirectory *f = (TDirectory *)gROOT->GetListOfFiles()->FindObject(path);; 492 // Check if this is a duplicate (2nd opening) on this file and prefer; 493 // this file.; 494 if (GetFile()) {; 495 auto url = GetFile()->GetEndpointUrl();; 496 if (f && 0 == url->Compare(f->GetFile()->GetEndpointUrl())) {; 497 result = GetDirectory(s+1,printError,funcname);; 498 delete [] path;; 499 return result;; 500 }; 501 }; 502 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:15540,error,error,15540,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['error'],['error']
Availability,"/////////////////; 854/// Swap points.; 855 ; 856void TGraphErrors::SwapPoints(Int_t pos1, Int_t pos2); 857{; 858 SwapValues(fEX, pos1, pos2);; 859 SwapValues(fEY, pos1, pos2);; 860 TGraph::SwapPoints(pos1, pos2);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Update the fX, fY, fEX, and fEY arrays with the sorted values.; 865 ; 866void TGraphErrors::UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low); 867{; 868 std::vector<Double_t> fEXSorted(numSortedPoints);; 869 std::vector<Double_t> fEYSorted(numSortedPoints);; 870 ; 871 // Fill the sorted X and Y error values based on the sorted indices; 872 std::generate(fEXSorted.begin(), fEXSorted.end(),; 873 [begin = low, &sorting_indices, this]() mutable { return fEX[sorting_indices[begin++]]; });; 874 std::generate(fEYSorted.begin(), fEYSorted.end(),; 875 [begin = low, &sorting_indices, this]() mutable { return fEY[sorting_indices[begin++]]; });; 876 ; 877 // Copy the sorted X and Y error values back to the original arrays; 878 std::copy(fEXSorted.begin(), fEXSorted.end(), fEX + low);; 879 std::copy(fEYSorted.begin(), fEYSorted.end(), fEY + low);; 880 ; 881 TGraph::UpdateArrays(sorting_indices, numSortedPoints, low);; 882}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; g#define g(i)Definition RSha256.hxx:105; h#define h(i)Definition RSha256.hxx:106; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TF1.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineCol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:28191,error,error,28191,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"//////////////; 17// //; 18// TGraphErrors //; 19// //; 20// a Graph with error bars //; 21// //; 22//////////////////////////////////////////////////////////////////////////; 23 ; 24#include ""TGraph.h""; 25 ; 26class TGraphErrors : public TGraph {; 27 ; 28protected:; 29 Double_t *fEX{nullptr}; ///<[fNpoints] array of X errors; 30 Double_t *fEY{nullptr}; ///<[fNpoints] array of Y errors; 31 ; 32 void SwapPoints(Int_t pos1, Int_t pos2) override;; 33 void UpdateArrays(const std::vector<Int_t> &sorting_indices, Int_t numSortedPoints, Int_t low) override;; 34 ; 35 Double_t** Allocate(Int_t size) override;; 36 void CopyAndRelease(Double_t **newarrays,; 37 Int_t ibegin, Int_t iend, Int_t obegin) override;; 38 Bool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend,; 39 Int_t obegin) override;; 40 Bool_t CtorAllocate();; 41 void FillZero(Int_t begin, Int_t end,; 42 Bool_t from_ctor = kTRUE) override;; 43 Bool_t DoMerge(const TGraph * g) override;; 44 ; 45 ; 46public:; 47 TGraphErrors();; 48 TGraphErrors(Int_t n);; 49 TGraphErrors(Int_t n, const Float_t *x, const Float_t *y, const Float_t *ex = nullptr, const Float_t *ey = nullptr);; 50 TGraphErrors(Int_t n, const Double_t *x, const Double_t *y, const Double_t *ex = nullptr, const Double_t *ey = nullptr);; 51 TGraphErrors(const TVectorF &vx, const TVectorF &vy, const TVectorF &vex, const TVectorF &vey);; 52 TGraphErrors(const TVectorD &vx, const TVectorD &vy, const TVectorD &vex, const TVectorD &vey);; 53 TGraphErrors(const TGraphErrors &gr);; 54 TGraphErrors& operator=(const TGraphErrors &gr);; 55 TGraphErrors(const TH1 *h);; 56 TGraphErrors(const char *filename, const char *format=""%lg %lg %lg %lg"", Option_t *option="""");; 57 ~TGraphErrors() override;; 58 virtual void AddPointError(Double_t x, Double_t y, Double_t ex = 0., Double_t ey = 0.);; 59 void Apply(TF1 *f) override;; 60 virtual void ApplyX(TF1 *f);; 61 static Int_t CalculateScanfFields(const char *fmt);; 62 void ComputeRange(Double_t &xmin, Double_t &ymin, Dou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8h_source.html:1073,error,errors,1073,doc/master/TGraphErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html,2,['error'],['errors']
Availability,"/////////////; 6155// Get the list of 'published'/'known' library for the class and load them.; 6156Int_t TCling::ShallowAutoLoadImpl(const char *cls); 6157{; 6158 Int_t status = 0;; 6159 ; 6160 // lookup class to find list of dependent libraries; 6161 TString deplibs = gCling->GetClassSharedLibs(cls);; 6162 if (!deplibs.IsNull()) {; 6163 TString delim("" "");; 6164 TObjArray* tokens = deplibs.Tokenize(delim);; 6165 for (Int_t i = (tokens->GetEntriesFast() - 1); i > 0; --i) {; 6166 const char* deplib = ((TObjString*)tokens->At(i))->GetName();; 6167 if (gROOT->LoadClass(cls, deplib) == 0) {; 6168 if (gDebug > 0) {; 6169 gCling->Info(""TCling::AutoLoad"",; 6170 ""loaded dependent library %s for %s"", deplib, cls);; 6171 }; 6172 }; 6173 else {; 6174 gCling->Error(""TCling::AutoLoad"",; 6175 ""failure loading dependent library %s for %s"",; 6176 deplib, cls);; 6177 }; 6178 }; 6179 const char* lib = ((TObjString*)tokens->At(0))->GetName();; 6180 if (lib && lib[0]) {; 6181 if (gROOT->LoadClass(cls, lib) == 0) {; 6182 if (gDebug > 0) {; 6183 gCling->Info(""TCling::AutoLoad"",; 6184 ""loaded library %s for %s"", lib, cls);; 6185 }; 6186 status = 1;; 6187 }; 6188 else {; 6189 gCling->Error(""TCling::AutoLoad"",; 6190 ""failure loading library %s for %s"", lib, cls);; 6191 }; 6192 }; 6193 delete tokens;; 6194 }; 6195 ; 6196 return status;; 6197}; 6198 ; 6199////////////////////////////////////////////////////////////////////////////////; 6200// Iterate through the data member of the class (either through the TProtoClass; 6201// or through Cling) and trigger, recursively, the loading the necessary libraries.; 6202// \note `cls` is expected to be already normalized!; 6203// \returns 1 on success.; 6204Int_t TCling::DeepAutoLoadImpl(const char *cls, std::unordered_set<std::string> &visited,; 6205 bool nameIsNormalized); 6206{; 6207 // Try to insert; if insertion failed because the entry existed, DeepAutoLoadImpl(); 6208 // has previously (within the same call to `AutoLoad()`) tried to load this cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:239285,failure,failure,239285,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['failure'],['failure']
Availability,"///////////; 636/// Scan parameter ipar between value of xmin and xmax; 637/// A array for x and y points should be provided; 638 ; 639bool FitResult::Scan(unsigned int ipar, unsigned int &npoints, double *pntsx, double *pntsy, double xmin, double xmax); 640{; 641 if (!pntsx || !pntsy || !npoints); 642 return false;; 643 ; 644 if (!fMinimizer) {; 645 MATH_ERROR_MSG(""FitResult::Scan"", ""Minimizer is not available - cannot Scan"");; 646 return false;; 647 }; 648 ; 649 return fMinimizer->Scan(ipar, npoints, pntsx, pntsy, xmin, xmax);; 650}; 651 ; 652////////////////////////////////////////////////////////////////////////////////; 653/// Create a 2D contour around the minimum for the parameter ipar and jpar; 654/// if a minimum does not exist or is invalid it will return false; 655/// A array for x and y points should be provided; 656/// Pass optionally the confidence level, default is 0.683; 657/// it is assumed that ErrorDef() defines the right error definition; 658/// (i.e 1 sigma error for one parameter). If not the confidence level are scaled to new level; 659 ; 660bool FitResult::Contour(unsigned int ipar, unsigned int jpar, unsigned int &npoints, double *pntsx, double *pntsy, double confLevel); 661{; 662 if (!pntsx || !pntsy || !npoints); 663 return false;; 664 ; 665 if (!fMinimizer) {; 666 MATH_ERROR_MSG(""FitResult::Contour"", ""Minimizer is not available - cannot produce Contour"");; 667 return false;; 668 }; 669 ; 670 // get error level used for fitting; 671 double upScale = fMinimizer->ErrorDef();; 672 ; 673 double upVal = TMath::ChisquareQuantile(confLevel, 2); // 2 is number of parameter we do the contour; 674 ; 675 // set required error definition in minimizer; 676 fMinimizer->SetErrorDef(upScale * upVal);; 677 ; 678 bool ret = fMinimizer->Contour(ipar, jpar, npoints, pntsx, pntsy);; 679 ; 680 // restore the error level used for fitting; 681 fMinimizer->SetErrorDef(upScale);; 682 ; 683 return ret;; 684}; 685 ; 686 } // end namespace Fit; 687 ; 688} // end namesp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:24400,error,error,24400,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,1,['error'],['error']
Availability,"//////////; 1501/// Get low error on y coordinate for point `i`.; 1502/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1503 ; 1504Double_t TGraphMultiErrors::GetErrorYlow(Int_t i) const; 1505{; 1506 if (i < 0 || i >= fNpoints || fEyL.empty()); 1507 return -1.;; 1508 ; 1509 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1510 return fEyL[0][i];; 1511 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1512 Double_t sum = 0.;; 1513 for (Int_t j = 0; j < fNYErrors; j++); 1514 sum += fEyL[j][i] * fEyL[j][i];; 1515 return TMath::Sqrt(sum);; 1516 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1517 Double_t sum = 0.;; 1518 for (Int_t j = 0; j < fNYErrors; j++); 1519 sum += fEyL[j][i];; 1520 return sum;; 1521 }; 1522 ; 1523 return -1.;; 1524}; 1525 ; 1526////////////////////////////////////////////////////////////////////////////////; 1527/// Get high error on y coordinate for point `i`.; 1528/// The multiple errors of the dimensions are summed according to `fSumErrorsMode`.; 1529 ; 1530Double_t TGraphMultiErrors::GetErrorYhigh(Int_t i) const; 1531{; 1532 if (i < 0 || i >= fNpoints || fEyH.empty()); 1533 return -1.;; 1534 ; 1535 if (fSumErrorsMode == TGraphMultiErrors::kOnlyFirst); 1536 return fEyH[0][i];; 1537 else if (fSumErrorsMode == TGraphMultiErrors::kSquareSum) {; 1538 Double_t sum = 0.;; 1539 for (Int_t j = 0; j < fNYErrors; j++); 1540 sum += fEyH[j][i] * fEyH[j][i];; 1541 return TMath::Sqrt(sum);; 1542 } else if (fSumErrorsMode == TGraphMultiErrors::kAbsSum) {; 1543 Double_t sum = 0.;; 1544 for (Int_t j = 0; j < fNYErrors; j++); 1545 sum += fEyH[j][i];; 1546 return sum;; 1547 }; 1548 ; 1549 return -1.;; 1550}; 1551 ; 1552////////////////////////////////////////////////////////////////////////////////; 1553/// Get low error e on y coordinate for point `i`.; 1554 ; 1555Double_t TGraphMultiErrors::GetErrorYlow(Int_t i, Int_t e) const; 1556{; 1557 if (i < 0 || i >= fNpoints || e >= fNYErrors || fEyL.empty()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:52340,error,errors,52340,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//////////; 2245/// To list all objects of the application.; 2246/// Loop on all objects created in the ROOT linked lists.; 2247/// Objects may be files and windows or any other object directly; 2248/// attached to the ROOT linked list.; 2249 ; 2250void TROOT::ls(Option_t *option) const; 2251{; 2252// TObject::SetDirLevel();; 2253// GetList()->R__FOR_EACH(TObject,ls)(option);; 2254 TDirectory::ls(option);; 2255}; 2256 ; 2257////////////////////////////////////////////////////////////////////////////////; 2258/// Load a macro in the interpreter's memory. Equivalent to the command line; 2259/// command "".L filename"". If the filename has ""+"" or ""++"" appended; 2260/// the macro will be compiled by ACLiC. The filename must have the format:; 2261/// [path/]macro.C[+|++[g|O]].; 2262/// The possible error codes are defined by TInterpreter::EErrorCode.; 2263/// If check is true it will only check if filename exists and is; 2264/// readable.; 2265/// Returns 0 on successful loading and -1 in case filename does not; 2266/// exist or in case of error.; 2267 ; 2268Int_t TROOT::LoadMacro(const char *filename, int *error, Bool_t check); 2269{; 2270 Int_t err = -1;; 2271 Int_t lerr, *terr;; 2272 if (error); 2273 terr = error;; 2274 else; 2275 terr = &lerr;; 2276 ; 2277 if (fInterpreter) {; 2278 TString aclicMode;; 2279 TString arguments;; 2280 TString io;; 2281 TString fname = gSystem->SplitAclicMode(filename, aclicMode, arguments, io);; 2282 ; 2283 if (arguments.Length()) {; 2284 Warning(""LoadMacro"", ""argument(%s) ignored in %s"", arguments.Data(), GetMacroPath());; 2285 }; 2286 char *mac = gSystem->Which(GetMacroPath(), fname, kReadPermission);; 2287 if (!mac) {; 2288 if (!check); 2289 Error(""LoadMacro"", ""macro %s not found in path %s"", fname.Data(), GetMacroPath());; 2290 *terr = TInterpreter::kFatal;; 2291 } else {; 2292 err = 0;; 2293 if (!check) {; 2294 fname = mac;; 2295 fname += aclicMode;; 2296 fname += io;; 2297 gInterpreter->LoadMacro(fname.Data(), (TInterpreter::EErrorCo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:86631,error,error,86631,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['error'],['error']
Availability,"/////////; 702/// Return bin entries of a Profile3D histogram.; 703 ; 704Double_t TProfile3D::GetBinEntries(Int_t bin) const; 705{; 706 if (fBuffer) ((TProfile3D*)this)->BufferEmpty();; 707 ; 708 if (bin < 0 || bin >= fNcells) return 0;; 709 return fBinEntries.fArray[bin];; 710}; 711 ; 712////////////////////////////////////////////////////////////////////////////////; 713/// Return bin effective entries for a weighted filled Profile histogram.; 714///; 715/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 716/// The effective entries is defined as the square of the sum of the weights divided by the; 717/// sum of the weights square.; 718/// TProfile::Sumw2() must be called before filling the profile with weights.; 719/// Only by calling this method the sum of the square of the weights per bin is stored.; 720 ; 721Double_t TProfile3D::GetBinEffectiveEntries(Int_t bin); 722{; 723 return TProfileHelper::GetBinEffectiveEntries((TProfile3D*)this, bin);; 724}; 725 ; 726////////////////////////////////////////////////////////////////////////////////; 727/// Return bin error of a Profile3D histogram.; 728///; 729/// ### Computing errors: A moving field; 730///; 731/// The computation of errors for a TProfile3D has evolved with the versions; 732/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 733///; 734/// - prior to version 3.10, we had no special treatment of low statistic bins.; 735/// As a result, these bins had huge errors. The reason is that the; 736/// expression eprim2 is very close to 0 (rounding problems) or 0.; 737/// - The algorithm is modified/protected for the case; 738/// when a TProfile3D is projected (ProjectionX). The previous algorithm; 739/// generated a N^2 problem when projecting a TProfile3D with a large number of; 740/// bins (eg 100000).; 741/// - in version 3.10/02, a new static function TProfile::Approximate; 742/// is introduced to enable or disable (default) the approximation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:25112,error,error,25112,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"/////////; 829/// Returns the content of the input bin; 830/// Bin numbers are from [1,nbins] and; 831/// for the overflow/underflow/sea bins the range is [-9,-1]:; 832///~~~ {.cpp}; 833/// -1 | -2 | -3; 834/// ---+----+----; 835/// -4 | -5 | -6; 836/// ---+----+----; 837/// -7 | -8 | -9; 838///~~~; 839/// where -5 is the ""sea"" bin (i.e. unbinned areas); 840 ; 841Double_t TH2Poly::GetBinContent(Int_t bin) const; 842{; 843 if (bin > GetNumberOfBins() || bin == 0 || bin < -kNOverflow) return 0;; 844 if (bin<0) return fOverflow[-bin - 1];; 845 return ((TH2PolyBin*) fBins->At(bin-1))->GetContent();; 846}; 847 ; 848////////////////////////////////////////////////////////////////////////////////; 849/// Returns the value of error associated to bin number bin.; 850/// If the sum of squares of weights has been defined (via Sumw2),; 851/// this function returns the sqrt(sum of w2).; 852/// otherwise it returns the sqrt(contents) for this bin.; 853/// Bins are in range [1:nbins] and for bin < 0 in range [-9:-1] it returns errors for overflow bins.; 854/// See also TH2Poly::GetBinContent; 855 ; 856Double_t TH2Poly::GetBinError(Int_t bin) const; 857{; 858 if (bin == 0 || bin > GetNumberOfBins() || bin < - kNOverflow) return 0;; 859 if (fBuffer) ((TH1*)this)->BufferEmpty();; 860 // in case of weighted events the sum of the weights are stored in a different way than; 861 // a normal histogram; 862 // fSumw2.fArray[0:kNOverflow-1] : sum of weight squares for the overflow bins (; 863 // fSumw2.fArray[kNOverflow:fNcells] : sum of weight squares for the standard bins; 864 // fNcells = kNOverflow (9) + Number of bins; 865 if (fSumw2.fN) {; 866 Int_t binIndex = (bin > 0) ? bin+kNOverflow-1 : -(bin+1);; 867 Double_t err2 = fSumw2.fArray[binIndex];; 868 return TMath::Sqrt(err2);; 869 }; 870 Double_t error2 = TMath::Abs(GetBinContent(bin));; 871 return TMath::Sqrt(error2);; 872}; 873 ; 874////////////////////////////////////////////////////////////////////////////////; 875/// Return the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2Poly_8cxx_source.html:30285,error,errors,30285,doc/master/TH2Poly_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2Poly_8cxx_source.html,1,['error'],['errors']
Availability,"////////; 375/// static: set name of default fft; 376 ; 377void TVirtualFFT::SetDefaultFFT(const char *name); 378{; 379 if (fgDefault == name) return;; 380 delete fgFFT;; 381 fgFFT = nullptr;; 382 fgDefault = name;; 383}; h#define h(i)Definition RSha256.hxx:106; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TError.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; TPluginManager.h; TROOT.h; gROOTMutexR__EXTERN TVirtualMutex * gROOTMutexDefinition TROOT.h:63; gROOT#define gROOTDefinition TROOT.h:406; TVirtualFFT.h; R__LOCKGUARD#define R__LOCKGUARD(mutex)Definition TVirtualMutex.h:95; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TPluginHandlerDefinition TPluginManager.h:103; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::Dataconst char * Data() constDefinition TString.h:376; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TVirtualFFTTVirtualFFT is an interface class for Fast Fourier Transforms.Definition TVirtualFFT.h:88; TVirtualFFT::~TVirtualFFTvirtual ~TVirtualFFT()destructorDefinition TVirtualFFT.cxx:96; TVirtualFFT::SetDefaultFFTstatic void SetDefaultFFT(const char *name="""")static: set name of default fftDefinition TVirtualFFT.cxx:377; TVirtualFFT::SetTransformstatic void SetTransform(TVirtualFFT *fft)static: set the current transfrom to parameterDefinition TVirtualFFT.cxx:361; TVirtualFFT::Initvirtual void Init(Option_t *flag, Int_t sign, const In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html:14462,error,error,14462,doc/master/TVirtualFFT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TVirtualFFT_8cxx_source.html,1,['error'],['error']
Availability,"///////; 1882/// Get number of types.; 1883 ; 1884Int_t TROOT::GetNtypes() const; 1885{; 1886 return fTypes->GetSize();; 1887}; 1888 ; 1889////////////////////////////////////////////////////////////////////////////////; 1890/// Execute command when system has been idle for idleTimeInSec seconds.; 1891 ; 1892void TROOT::Idle(UInt_t idleTimeInSec, const char *command); 1893{; 1894 if (!fApplication.load()); 1895 TApplication::CreateApplication();; 1896 ; 1897 if (idleTimeInSec <= 0); 1898 (*fApplication).RemoveIdleTimer();; 1899 else; 1900 (*fApplication).SetIdleTimer(idleTimeInSec, command);; 1901}; 1902 ; 1903////////////////////////////////////////////////////////////////////////////////; 1904/// Check whether className is a known class, and only autoload; 1905/// if we can. Helper function for TROOT::IgnoreInclude().; 1906 ; 1907static TClass* R__GetClassIfKnown(const char* className); 1908{; 1909 // Check whether the class is available for auto-loading first:; 1910 const char* libsToLoad = gInterpreter->GetClassSharedLibs(className);; 1911 TClass* cla = nullptr;; 1912 if (libsToLoad) {; 1913 // trigger autoload, and only create TClass in this case.; 1914 return TClass::GetClass(className);; 1915 } else if (gROOT->GetListOfClasses(); 1916 && (cla = (TClass*)gROOT->GetListOfClasses()->FindObject(className))) {; 1917 // cla assigned in if statement; 1918 } else if (gClassTable->FindObject(className)) {; 1919 return TClass::GetClass(className);; 1920 }; 1921 return cla;; 1922}; 1923 ; 1924////////////////////////////////////////////////////////////////////////////////; 1925/// Return 1 if the name of the given include file corresponds to a class that; 1926/// is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector.; 1927 ; 1928Int_t TROOT::IgnoreInclude(const char *fname, const char * /*expandedfname*/); 1929{; 1930 if (fname == nullptr) return 0;; 1931 ; 1932 TString stem(fname);; 1933 // Remove extension if any, ignore files with extension not being .h*; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:73351,avail,available,73351,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avail'],['available']
Availability,"///////; 2425/// Send a buffer headed by a length indicator.; 2426 ; 2427int TSystem::SendBuf(int, const void *, int); 2428{; 2429 AbstractMethod(""SendBuf"");; 2430 return -1;; 2431}; 2432 ; 2433////////////////////////////////////////////////////////////////////////////////; 2434/// Set socket option.; 2435 ; 2436int TSystem::SetSockOpt(int, int, int); 2437{; 2438 AbstractMethod(""SetSockOpt"");; 2439 return -1;; 2440}; 2441 ; 2442////////////////////////////////////////////////////////////////////////////////; 2443/// Get socket option.; 2444 ; 2445int TSystem::GetSockOpt(int, int, int*); 2446{; 2447 AbstractMethod(""GetSockOpt"");; 2448 return -1;; 2449}; 2450 ; 2451//---- System, CPU and Memory info ---------------------------------------------; 2452 ; 2453////////////////////////////////////////////////////////////////////////////////; 2454/// Returns static system info, like OS type, CPU type, number of CPUs; 2455/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 2456/// 0 otherwise.; 2457 ; 2458int TSystem::GetSysInfo(SysInfo_t *) const; 2459{; 2460 AbstractMethod(""GetSysInfo"");; 2461 return -1;; 2462}; 2463 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485/////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:79159,error,error,79159,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"//////; 1059/// Recursive method to fill full path for directory.; 1060 ; 1061void TDirectory::FillFullPath(TString& buf) const; 1062{; 1063 TDirectory* mom = GetMotherDir();; 1064 if (mom) {; 1065 mom->FillFullPath(buf);; 1066 buf += ""/"";; 1067 buf += GetName();; 1068 } else {; 1069 buf = GetName();; 1070 buf += "":"";; 1071 }; 1072}; 1073 ; 1074////////////////////////////////////////////////////////////////////////////////; 1075/// Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."".; 1076///; 1077/// Returns 0 in case of error or if a sub-directory (hierarchy) with the requested; 1078/// name already exists.; 1079/// returnExistingDirectory returns a pointer to an already existing sub-directory with the same name.; 1080/// Returns a pointer to the created sub-directory or to the top sub-directory of; 1081/// the hierarchy (in the above example, the returned TDirectory * always points; 1082/// to ""a"").; 1083/// In particular, the steps to create first a/b/c and then a/b/d without receiving; 1084/// errors are:; 1085/// ~~~ {.cpp}; 1086/// TFile * file = new TFile(""afile"",""RECREATE"");; 1087/// file->mkdir(""a"");; 1088/// file->cd(""a"");; 1089/// gDirectory->mkdir(""b/c"");; 1090/// gDirectory->cd(""b"");; 1091/// gDirectory->mkdir(""d"");; 1092/// ~~~; 1093/// or; 1094/// ~~~ {.cpp}; 1095/// TFile * file = new TFile(""afile"",""RECREATE"");; 1096/// file->mkdir(""a"");; 1097/// file->cd(""a"");; 1098/// gDirectory->mkdir(""b/c"");; 1099/// gDirectory->mkdir(""b/d"", """", true);; 1100/// ~~~; 1101 ; 1102TDirectory *TDirectory::mkdir(const char *name, const char *title, Bool_t returnExistingDirectory); 1103{; 1104 if (returnExistingDirectory) {; 1105 auto existingdir = GetDirectory(name);; 1106 if (existingdir); 1107 return existingdir;; 1108 }; 1109 if (!name || !title || !name[0]) return nullptr;; 1110 if (!title[0]) title = name;; 1111 if (const char *slash = strchr(name,'/')) {; 1112 Long_t size = Long_t(slash-name);; 1113 char *workname = new char[size+1];; 1114 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8cxx_source.html:37734,error,errors,37734,doc/master/TDirectory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8cxx_source.html,1,['error'],['errors']
Availability,"//////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];; 1218 if (exhigh) fEXhigh[n0+i] = exhigh[i];; 1219 if (eylow) fEYlow[n0+i] = eylow[i];; 1220 if (eyhigh) fEYhigh[n0+i] = eyhigh[i];; 1221 }; 1222 }; 1223 return GetN();; 1224}; 1225 ; 1226////////////////////////////////////////////////////////////////////////////////; 1227/// Print graph and errors values.; 1228 ; 1229void TGraphAsymmErrors::Print(Option_t *) const; 1230{; 1231 for (Int_t i=0;i<fNpoints;i++) {; 1232 printf(""x[%d]=%g, y[%d]=%g, exl[%d]=%g, exh[%d]=%g, eyl[%d]=%g, eyh[%d]=%g\n""; 1233 ,i,fX[i],i,fY[i],i,fEXlow[i],i,fEXhigh[i],i,fEYlow[i],i,fEYhigh[i]);; 1234 }; 1235}; 1236 ; 1237 ; 1238////////////////////////////////////////////////////////////////////////////////; 1239/// Save primitive as a C++ statement(s) on output stream out.; 1240 ; 1241void TGraphAsymmE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:42352,error,errors,42352,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//////; 1980/// Set error e eyL values.; 1981 ; 1982void TGraphMultiErrors::SetEYlow(Int_t e, Int_t np, const Double_t *eyL); 1983{; 1984 for (Int_t i = 0; i < fNpoints; i++) {; 1985 if (i < np); 1986 SetPointEYlow(i, e, eyL[i]);; 1987 else; 1988 SetPointEYlow(i, e, 0.);; 1989 }; 1990}; 1991 ; 1992////////////////////////////////////////////////////////////////////////////////; 1993/// Set error e eyH values.; 1994 ; 1995void TGraphMultiErrors::SetEYhigh(Int_t e, Int_t np, const Double_t *eyH); 1996{; 1997 for (Int_t i = 0; i < fNpoints; i++) {; 1998 if (i < np); 1999 SetPointEYhigh(i, e, eyH[i]);; 2000 else; 2001 SetPointEYhigh(i, e, 0.);; 2002 }; 2003}; 2004 ; 2005////////////////////////////////////////////////////////////////////////////////; 2006/// Set the sum errors mode and recalculate summed errors.; 2007void TGraphMultiErrors::SetSumErrorsMode(Int_t m); 2008{; 2009 if (fSumErrorsMode == m); 2010 return;; 2011 fSumErrorsMode = m;; 2012 CalcYErrorsSum();; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Set TAttFill parameters of error e by copying from another TAttFill (-1 = Global and x errors).; 2017 ; 2018void TGraphMultiErrors::SetAttFill(Int_t e, TAttFill *taf); 2019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMulti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:67759,error,error,67759,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"//////; 4645/// Search for an object at pixel position px,py.; 4646///; 4647/// Check if point is in this pad.; 4648///; 4649/// If yes, check if it is in one of the sub-pads; 4650///; 4651/// If found in the pad, compute closest distance of approach; 4652/// to each primitive.; 4653///; 4654/// If one distance of approach is found to be within the limit Distancemaximum; 4655/// the corresponding primitive is selected and the routine returns.; 4656 ; 4657TPad *TPad::Pick(Int_t px, Int_t py, TObjLink *&pickobj); 4658{; 4659 //the two following statements are necessary under NT (multithreaded); 4660 //when a TCanvas object is being created and a thread calling TPad::Pick; 4661 //before the TPad constructor has completed in the other thread; 4662 if (!gPad) return nullptr; //Andy Haas; 4663 if (!GetListOfPrimitives()) return nullptr; //Andy Haas; 4664 ; 4665 Int_t dist;; 4666 // Search if point is in pad itself; 4667 Double_t x = AbsPixeltoX(px);; 4668 Double_t y = AbsPixeltoY(py);; 4669 if (this != gPad->GetCanvas()) {; 4670 if (!((x >= fX1 && x <= fX2) && (y >= fY1 && y <= fY2))) return nullptr;; 4671 }; 4672 ; 4673 // search for a primitive in this pad or its sub-pads; 4674 static TObjOptLink dummyLink(nullptr,""""); //place holder for when no link available; 4675 ; 4676 TContext ctxt(this, kFALSE); // since no drawing will be done, don't use cd() for efficiency reasons; 4677 ; 4678 TPad *pick = nullptr;; 4679 TPad *picked = this;; 4680 pickobj = nullptr;; 4681 if (DistancetoPrimitive(px,py) < fgMaxPickDistance) {; 4682 dummyLink.SetObject(this);; 4683 pickobj = &dummyLink;; 4684 }; 4685 ; 4686 // Loop backwards over the list of primitives. The first non-pad primitive; 4687 // found is the selected one. However, we have to keep going down the; 4688 // list to see if there is maybe a pad overlaying the primitive. In that; 4689 // case look into the pad for a possible primitive. Once a pad has been; 4690 // found we can terminate the loop.; 4691 Bool_t gotPrim = kFALSE;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPad_8cxx_source.html:148579,avail,available,148579,doc/master/TPad_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPad_8cxx_source.html,1,['avail'],['available']
Availability,"/////; 1070/// Replace contents of this histogram by the addition of h1 and h2.; 1071///; 1072/// `this = c1*h1 + c2*h2`; 1073/// if errors are defined (see TH1::Sumw2), errors are also recalculated; 1074///; 1075/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 1076/// if not already set.; 1077///; 1078/// Note also that adding histogram with labels is not supported, histogram will be; 1079/// added merging them by bin number independently of the labels.; 1080/// For adding histogram ith labels one should use TH1::Merge; 1081///; 1082/// SPECIAL CASE (Average/Efficiency histograms); 1083/// For histograms representing averages or efficiencies, one should compute the average; 1084/// of the two histograms and not the sum. One can mark a histogram to be an average; 1085/// histogram by setting its bit kIsAverage with; 1086/// myhist.SetBit(TH1::kIsAverage);; 1087/// Note that the two histograms must have their kIsAverage bit set; 1088///; 1089/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 1090/// you should call Sumw2 before making this operation.; 1091/// This is particularly important if you fit the histogram after TH1::Add; 1092///; 1093/// IMPORTANT NOTE2: You should be careful about the statistics of the; 1094/// returned histogram, whose statistics may be binned or unbinned,; 1095/// depending on whether c1 is negative, whether TAxis::kAxisRange is true,; 1096/// and whether TH1::ResetStats has been called on either this or h1.; 1097/// See TH1::GetStats.; 1098///; 1099/// ANOTHER SPECIAL CASE : h1 = h2 and c2 < 0; 1100/// do a scaling this = c1 * h1 / (bin Volume); 1101///; 1102/// The function returns kFALSE if the Add operation failed; 1103 ; 1104Bool_t TH1::Add(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2); 1105{; 1106 ; 1107 if (!h1 || !h2) {; 1108 Error(""Add"",""Attempt to add a non-existing histogram"");; 1109 return kFALSE;; 1110 }; 1111 ; 1112 // delete buffer if it is there since it ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:43530,error,errors,43530,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"/////; 2680/// Static function creating a color table with several connected linear gradients.; 2681///; 2682/// - Number: The number of end point colors that will form the gradients.; 2683/// Must be at least 2.; 2684/// - Stops: Where in the whole table the end point colors should lie.; 2685/// Each entry must be on [0, 1], each entry must be greater than; 2686/// the previous entry.; 2687/// - Red, Green, Blue: The end point color values.; 2688/// Each entry must be on [0, 1]; 2689/// - NColors: Total number of colors in the table. Must be at least 1.; 2690/// - alpha: the opacity factor, between 0 and 1. Default is no transparency (1).; 2691/// - setPalette: activate the newly created palette (true by default). If false,; 2692/// the caller is in charge of calling TColor::SetPalette using the; 2693/// return value of the function (first palette color index) and; 2694/// reconstructing the Int_t palette[NColors+1] array.; 2695///; 2696/// Returns a positive value (the index of the first color of the palette) on; 2697/// success and -1 on error.; 2698///; 2699/// The table is constructed by tracing lines between the given points in; 2700/// RGB space. Each color value may have a value between 0 and 1. The; 2701/// difference between consecutive ""Stops"" values gives the fraction of; 2702/// space in the whole table that should be used for the interval between; 2703/// the corresponding color values.; 2704///; 2705/// Normally the first element of Stops should be 0 and the last should be 1.; 2706/// If this is not true, fewer than NColors will be used in proportion with; 2707/// the total interval between the first and last elements of Stops.; 2708///; 2709/// This definition is similar to the povray-definition of gradient; 2710/// color tables.; 2711///; 2712/// For instance:; 2713/// ~~~ {.cpp}; 2714/// UInt_t Number = 3;; 2715/// Double_t Red[3] = { 0.0, 1.0, 1.0 };; 2716/// Double_t Green[3] = { 0.0, 0.0, 1.0 };; 2717/// Double_t Blue[3] = { 1.0, 0.0, 1.0 };; 27",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:98251,error,error,98251,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['error'],['error']
Availability,"////; 1842/// Rebin only the Y axis.; 1843/// see Rebin2D; 1844 ; 1845TProfile2D * TProfile2D::RebinY(Int_t ngroup,const char * newname ) {; 1846 return Rebin2D(1,ngroup,newname);; 1847}; 1848 ; 1849////////////////////////////////////////////////////////////////////////////////; 1850/// Save primitive as a C++ statement(s) on output stream out.; 1851///; 1852/// Note the following restrictions in the code generated:; 1853/// - variable bin size not implemented; 1854/// - SetErrorOption not implemented; 1855 ; 1856void TProfile2D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1857{; 1858 char quote = '""';; 1859 out <<"" ""<<std::endl;; 1860 out <<"" ""<<ClassName()<<"" *"";; 1861 ; 1862 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1863 << GetName() << quote << "","" << quote<< GetTitle() << quote; 1864 << "","" << GetXaxis()->GetNbins();; 1865 out << "","" << GetXaxis()->GetXmin(); 1866 << "","" << GetXaxis()->GetXmax();; 1867 out << "","" << GetYaxis()->GetNbins();; 1868 out << "","" << GetYaxis()->GetXmin(); 1869 << "","" << GetYaxis()->GetXmax();; 1870 out << "","" << fZmin; 1871 << "","" << fZmax;; 1872 out << "");"" << std::endl;; 1873 ; 1874 ; 1875 // save bin entries; 1876 Int_t bin;; 1877 for (bin=0;bin<fNcells;bin++) {; 1878 Double_t bi = GetBinEntries(bin);; 1879 if (bi) {; 1880 out<<"" ""<<GetName()<<""->SetBinEntries(""<<bin<<"",""<<bi<<"");""<<std::endl;; 1881 }; 1882 }; 1883 //save bin contents; 1884 for (bin=0;bin<fNcells;bin++) {; 1885 Double_t bc = fArray[bin];; 1886 if (bc) {; 1887 out<<"" ""<<GetName()<<""->SetBinContent(""<<bin<<"",""<<bc<<"");""<<std::endl;; 1888 }; 1889 }; 1890 // save bin errors; 1891 if (fSumw2.fN) {; 1892 for (bin=0;bin<fNcells;bin++) {; 1893 Double_t be = TMath::Sqrt(fSumw2.fArray[bin]);; 1894 if (be) {; 1895 out<<"" ""<<GetName()<<""->SetBinError(""<<bin<<"",""<<be<<"");""<<std::endl;; 1896 }; 1897 }; 1898 }; 1899 ; 1900 TH1::SavePrimitiveHelp(out, GetName(), option);; 1901}; 1902 ; 1903//////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:68981,error,errors,68981,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['errors']
Availability,"////; 257class TProcessEventTimer : public TTimer {; 258public:; 259 TProcessEventTimer(Long_t delay);; 260 Bool_t Notify() override { return kTRUE; }; 261 Bool_t ProcessEvents();; 262 ClassDefOverride(TProcessEventTimer,0) // Process pending events at fixed time intervals; 263};; 264 ; 265 ; 266class TSystem : public TNamed {; 267 ; 268public:; 269 enum EAclicMode { kDefault, kDebug, kOpt };; 270 enum EAclicProperties {; 271 kFlatBuildDir = BIT(0) // If set and a BuildDir is selected, then do not created sub-directories; 272 };; 273 ; 274protected:; 275 TFdSet *fReadmask{nullptr}; //!Files that should be checked for read events; 276 TFdSet *fWritemask{nullptr}; //!Files that should be checked for write events; 277 TFdSet *fReadready{nullptr}; //!Files with reads waiting; 278 TFdSet *fWriteready{nullptr}; //!Files with writes waiting; 279 TFdSet *fSignals{nullptr}; //!Signals that were trapped; 280 Int_t fNfd{0}; //Number of fd's in masks; 281 Int_t fMaxrfd{-1}; //Largest fd in read mask; 282 Int_t fMaxwfd{-1}; //Largest fd in write mask; 283 Int_t fSigcnt{0}; //Number of pending signals; 284 TString fWdpath; //Working directory; 285 TString fHostname; //Hostname; 286 std::atomic<Bool_t> fInsideNotify{kFALSE}; //Used by DispatchTimers(); 287 Int_t fBeepFreq{0}; //Used by Beep(); 288 Int_t fBeepDuration{0}; //Used by Beep(); 289 ; 290 Bool_t fInControl{kFALSE}; //True if in eventloop; 291 Bool_t fDone{kFALSE}; //True if eventloop should be finished; 292 Int_t fLevel{0}; //Level of nested eventloops; 293 ; 294 TList *fTimers{nullptr}; //List of timers; 295 TSeqCollection *fSignalHandler{nullptr}; //List of signal handlers; 296 TSeqCollection *fFileHandler{nullptr}; //List of file handlers; 297 TSeqCollection *fStdExceptionHandler{nullptr}; //List of std::exception handlers; 298 TSeqCollection *fOnExitList{nullptr}; //List of items to be cleaned-up on exit; 299 ; 300 TString fListLibs; //List shared libraries, cache used by GetLibraries; 301 ; 302 TString fBuildArch; //",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8h_source.html:10644,mask,mask,10644,doc/master/TSystem_8h_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8h_source.html,1,['mask'],['mask']
Availability,"////; 7582/// Enable/Disable the Autoparsing of headers.; 7583/// Returns the old value, i.e whether it was enabled or not.; 7584 ; 7585int TCling::SetClassAutoparsing(int autoparse); 7586{; 7587 bool oldVal = fHeaderParsingOnDemand;; 7588 fHeaderParsingOnDemand = autoparse;; 7589 return oldVal;; 7590}; 7591 ; 7592////////////////////////////////////////////////////////////////////////////////; 7593/// Suspend the Autoparsing of headers.; 7594/// Returns the old value, i.e whether it was suspended or not.; 7595 ; 7596Bool_t TCling::SetSuspendAutoParsing(Bool_t value) {; 7597 Bool_t old = fIsAutoParsingSuspended;; 7598 fIsAutoParsingSuspended = value;; 7599 if (fClingCallbacks) fClingCallbacks->SetAutoParsingSuspended(value);; 7600 return old;; 7601}; 7602 ; 7603////////////////////////////////////////////////////////////////////////////////; 7604/// Set a callback to receive error messages.; 7605 ; 7606void TCling::SetErrmsgcallback(void* p) const; 7607{; 7608#if defined(R__MUST_REVISIT); 7609#if R__MUST_REVISIT(6,2); 7610 Warning(""SetErrmsgcallback"", ""Interface not available yet."");; 7611#endif; 7612#endif; 7613}; 7614 ; 7615void TCling::ReportDiagnosticsToErrorHandler(bool enable); 7616{; 7617 if (enable) {; 7618 auto consumer = new TClingDelegateDiagnosticPrinter(; 7619 &fInterpreter->getDiagnostics().getDiagnosticOptions(),; 7620 fInterpreter->getCI()->getLangOpts(),; 7621 [] (clang::DiagnosticsEngine::Level Level, const std::string &Info) {; 7622 if (Level == clang::DiagnosticsEngine::Warning) {; 7623 ::Warning(""cling"", ""%s"", Info.c_str());; 7624 } else if (Level == clang::DiagnosticsEngine::Error; 7625 || Level == clang::DiagnosticsEngine::Fatal) {; 7626 ::Error(""cling"", ""%s"", Info.c_str());; 7627 } else {; 7628 ::Info(""cling"", ""%s"", Info.c_str());; 7629 }; 7630 });; 7631 fInterpreter->replaceDiagnosticConsumer(consumer, /*Own=*/true);; 7632 } else {; 7633 fInterpreter->replaceDiagnosticConsumer(nullptr);; 7634 }; 7635}; 7636 ; 7637 ; 7638/////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:296914,avail,available,296914,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['avail'],['available']
Availability,"///; 189/// Get the scatter's x axis.; 190 ; 191TAxis *TScatter::GetXaxis() const; 192{; 193 auto h = GetHistogram();; 194 return h ? h->GetXaxis() : nullptr;; 195}; 196 ; 197 ; 198////////////////////////////////////////////////////////////////////////////////; 199/// Get the scatter's y axis.; 200 ; 201TAxis *TScatter::GetYaxis() const; 202{; 203 auto h = GetHistogram();; 204 return h ? h->GetYaxis() : nullptr;; 205}; 206 ; 207 ; 208////////////////////////////////////////////////////////////////////////////////; 209/// Get the scatter's z axis.; 210 ; 211TAxis *TScatter::GetZaxis() const; 212{; 213 auto h = GetHistogram();; 214 return h ? h->GetZaxis() : nullptr;; 215}; 216 ; 217 ; 218////////////////////////////////////////////////////////////////////////////////; 219/// Paint this scatter plot with its current attributes.; 220 ; 221void TScatter::Paint(Option_t *option); 222{; 223 TVirtualGraphPainter *painter = TVirtualGraphPainter::GetPainter();; 224 if (painter) painter->PaintScatter(this, option);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Print graph and errors values.; 230 ; 231void TScatter::Print(Option_t *) const; 232{; 233 Double_t *X = fGraph->GetX();; 234 Double_t *Y = fGraph->GetY();; 235 for (Int_t i = 0; i < fNpoints; i++) {; 236 printf(""x[%d]=%g, y[%d]=%g"", i, X[i], i, Y[i]);; 237 if (fColor) printf("", color[%d]=%g"", i, fColor[i]);; 238 if (fSize) printf("", size[%d]=%g"", i, fSize[i]);; 239 printf(""\n"");; 240 }; 241}; 242 ; 243 ; 244////////////////////////////////////////////////////////////////////////////////; 245/// Set the margin around the plot in %; 246 ; 247void TScatter::SetMargin(Double_t margin); 248{; 249 if (fMargin != margin) {; 250 delete fHistogram;; 251 fHistogram = nullptr;; 252 fMargin = margin;; 253 }; 254}; 255 ; 256 ; 257////////////////////////////////////////////////////////////////////////////////; 258/// Save primitive as a C++ statement(s) on output stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TScatter_8cxx_source.html:7233,error,errors,7233,doc/master/TScatter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TScatter_8cxx_source.html,1,['error'],['errors']
Availability,"///; 2947/// `this = c1*h1/(c2*h2)`; 2948///; 2949/// If errors are defined (see TH1::Sumw2), errors are also recalculated; 2950/// Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; 2951/// if not already set.; 2952/// The resulting errors are calculated assuming uncorrelated histograms.; 2953/// However, if option =""B"" is specified, Binomial errors are computed.; 2954/// In this case c1 and c2 do not make real sense and they are ignored.; 2955///; 2956/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2957/// you should call Sumw2 before making this operation.; 2958/// This is particularly important if you fit the histogram after TH1::Divide; 2959///; 2960/// Please note also that in the binomial case errors are calculated using standard; 2961/// binomial statistics, which means when b1 = b2, the error is zero.; 2962/// If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; 2963/// use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; 2964/// error for the case b1=b2.; 2965///; 2966/// The function return kFALSE if the divide operation failed; 2967 ; 2968Bool_t TH1::Divide(const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2, Option_t *option); 2969{; 2970 ; 2971 TString opt = option;; 2972 opt.ToLower();; 2973 Bool_t binomial = kFALSE;; 2974 if (opt.Contains(""b"")) binomial = kTRUE;; 2975 if (!h1 || !h2) {; 2976 Error(""Divide"", ""At least one of the input histograms passed does not exist (NULL)."");; 2977 return kFALSE;; 2978 }; 2979 ; 2980 // delete buffer if it is there since it will become invalid; 2981 if (fBuffer) BufferEmpty(1);; 2982 ; 2983 if (LoggedInconsistency(""Divide"", this, h1) >= kDifferentNumberOfBins ||; 2984 LoggedInconsistency(""Divide"", h1, h2) >= kDifferentNumberOfBins) {; 2985 return false;; 2986 }; 2987 ; 2988 if (!c2) {; 2989 Error(""Divide"",""Coefficient of dividing histogram cannot be zero"");; 2990 return ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:117483,error,errors,117483,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"//; /// Compute distance from point px,py to a function; ///; /// \param[in] px x position; /// \param[in] py y position; ///; /// Compute the closest distance of approach from point px,py to this function.; /// The distance is computed in pixels units.;  ; Int_t TF2::DistancetoPrimitive(Int_t px, Int_t py); {; ...; }; Free functions documentation; Doxygen does not document default parameters of free functions if the only doxygen documentation provided for the function is in source files (as opposed to header files). To bypass this issue it is enough to provide a brief documentation for such functions in the header file. For example if the source file is:; ////////////////////////////////////////////////////////////////////////////////; /// @param[in] numthreads Number of threads to use. If not specified or; /// set to zero, the number of threads is automatically; /// decided by the implementation. Any other value is; /// used as a hint.; ///; /// ROOT must be built with the compilation flag `imt=ON` for this feature to be available.;  ; [...];  ; void EnableImplicitMT(UInt_t numthreads); and the header file:; /// Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; /// parallelisation mechanism.; void EnableImplicitMT(UInt_t numthreads = 0);; Then a proper documentation with the default parameters is generated.; Data Member documentation; IMPORTANT: It is crucial to use ""///<"" and only ""///<"" to comment data members: this comment is correctly understood by genreflex/rootcling. The usage of other Doxygen constructs can interfere with the I/O subsystem!; Double_t fMymember ///< My Member; Double_t fMyTransientMember ///<! My Member; The usage of ""//!"" will still result in transiency of members but not in Doxygen documentation.; Tutorials' documentation; ROOT tutorials are also included in the ROOT documentation. The tutorials'; macros headers should look like:; \file; \ingroup tutorial_hist; \notebook; Getting Contours From TH2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/formatting-comments-doxygen.html:4891,avail,available,4891,d/formatting-comments-doxygen.html,https://root.cern,https://root.cern/d/formatting-comments-doxygen.html,1,['avail'],['available']
Availability,"//; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TGraphMultiErrors(const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 424 const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m); 425 : fNYErrors(1), fSumErrorsMode(m); 426{; 427 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); 430 return;; 431 ; 432 if (!CtorAllocate()); 433 return;; 434 ; 435 Int_t itvXL = tvX.GetLwb();; 436 Int_t itvYL = tvY.GetLwb();; 437 Int_t itvExLL = tvExL.GetLwb();; 438 Int_t itvExHL = tvExH.GetLwb();; 439 Int_t itvEyLL = tvEyL.GetLwb();; 440 Int_t itvEyHL = tvEyH.GetLwb();; 441 ; 442 for (Int_t i = 0; i < fNpoints; i++) {; 443 fX[i] = tvX(itvXL + i);; 444 fY[i] = tvY(itvYL + i);; 445 fExL[i] = tvExL(itvExLL + i);; 446 fExH[i] = tvExH(itvExHL + i);; 447 fEyL[0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:15273,error,errors,15273,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"//fill d array with (x,y,z,t) components of v1; v1.GetCoordinates(d);; //fill d array with (pt,eta,phi,e) components of v2; v2.GetCoordinates(d);; std::vector w(4);; //fill std::vector with (x,y,z,t); v1.GetCoordinates(w.begin(),w.end());; //components of v1; To get information on all the coordinate accessors see the ROOT::Math::LorentzVector reference documentation.; 13.12.4.3 Setter Methods; One can set only all the three coordinates via:; //sets the (x,y,z,t) for a XYZTVector; v1.SetCoordinates(c1,c2,c3,c4);; //sets pt,eta,phi,e for a PtEtaPhiEVector; v2.SetCoordinates(c1,c2,c3,c4);; //sets cartesian components for PtEtaPhiEVector; v2.SetXYZ(x,y,z,t);; Single coordinate setter methods are available for the basic vector coordinates, like SetX() for a XYZTVector or SetPt() for a PtEtaPhiEVector. Attempting to do a SetX() on a non-Cartesian vector will not compile.; XYZTVector v1;; v1.SetX(1); //OK setting x for a cartesian vector; PtEtaPhiEVector v2;; v2.SetX(1); //ERROR: cannot set X for a non-cartesian; //vector. Method will not compile.; v2.SetR(1) // OK setting Pt for a PtEtaPhiEVector vector; In addition, there are setter methods from C arrays or iterators.; double d[4] = {1.,2.,3.,4.};; XYZTVector v;; //set (x,y,z,t) components of v using values from d; v.SetCoordinates(d);; or for example from an std::vectorusing the iterators; std::vector w(4);; //set (x,y,z,t) components of v using values from w; v.SetCoordinates(w.begin(),w.end());; 13.12.4.4 Arithmetic Operations; The following operations are possible between Lorentz vectors classes, even of different coordinate system types: (v andw are two Lorentz vector of the same type, qis a generic Lorentz vector implementing x(), y(), z() and t(), and a is a generic scalar type: double, float, int, etc.) .; v += q;; v -= q;; v = -q;; v *= a;; v /= a;; w = v + q;; w = v - q;; w = v * a;; w = a * v;; w = v / a;; 13.12.4.5 Comparison; v == w;; v != w;; 13.12.4.6 Other Methods; a = v.Dot(q); //dot product in metric(+,+",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:738827,ERROR,ERROR,738827,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['ERROR'],['ERROR']
Availability,"//reset only Integral, contents and Errors; 6533 ; 6534 int iaxis = 0;; 6535 if (axis == &fXaxis) iaxis = 1;; 6536 if (axis == &fYaxis) iaxis = 2;; 6537 if (axis == &fZaxis) iaxis = 3;; 6538 bool firstw = kTRUE;; 6539 Int_t binx,biny, binz = 0;; 6540 Int_t ix = 0,iy = 0,iz = 0;; 6541 Double_t bx,by,bz;; 6542 Int_t ncells = hold->GetNcells();; 6543 for (Int_t bin = 0; bin < ncells; ++bin) {; 6544 hold->GetBinXYZ(bin,binx,biny,binz);; 6545 bx = hold->GetXaxis()->GetBinCenter(binx);; 6546 ix = fXaxis.FindFixBin(bx);; 6547 if (fDimension > 1) {; 6548 by = hold->GetYaxis()->GetBinCenter(biny);; 6549 iy = fYaxis.FindFixBin(by);; 6550 if (fDimension > 2) {; 6551 bz = hold->GetZaxis()->GetBinCenter(binz);; 6552 iz = fZaxis.FindFixBin(bz);; 6553 }; 6554 }; 6555 // exclude underflow/overflow; 6556 double content = hold->RetrieveBinContent(bin);; 6557 if (content == 0) continue;; 6558 if (IsBinUnderflow(bin,iaxis) || IsBinOverflow(bin,iaxis) ) {; 6559 if (firstw) {; 6560 Warning(""ExtendAxis"",""Histogram %s has underflow or overflow in the axis that is extendable""; 6561 "" their content will be lost"",GetName() );; 6562 firstw= kFALSE;; 6563 }; 6564 continue;; 6565 }; 6566 Int_t ibin= GetBin(ix,iy,iz);; 6567 AddBinContent(ibin, content);; 6568 if (errors) {; 6569 fSumw2.fArray[ibin] += hold->GetBinErrorSqUnchecked(bin);; 6570 }; 6571 }; 6572 delete hold;; 6573}; 6574 ; 6575////////////////////////////////////////////////////////////////////////////////; 6576/// Recursively remove object from the list of functions; 6577 ; 6578void TH1::RecursiveRemove(TObject *obj); 6579{; 6580 // Rely on TROOT::RecursiveRemove to take the readlock.; 6581 ; 6582 if (fFunctions) {; 6583 if (!fFunctions->TestBit(kInvalidObject)) fFunctions->RecursiveRemove(obj);; 6584 }; 6585}; 6586 ; 6587////////////////////////////////////////////////////////////////////////////////; 6588/// Multiply this histogram by a constant c1.; 6589///; 6590/// `this = c1*this`; 6591///; 6592/// Note that both contents and err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:258822,error,errors,258822,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"//srv//mss/event?remote=1' root://srv//mss/event_<ord>_<#>?remote=1.root Default selector is TSelEventGen. Use SetDataGenSel and SetDataGenPar to change it and to pass the list of PARs defining the alternative selector. The argument 'nevt' controls the number of events per file (-1 for the default, which is 30000). Return 0 on success, -1 on error ; Definition at line 1343 of file TProofBench.cxx. ◆ OpenOutFile(). Int_t TProofBench::OpenOutFile ; (; Bool_t ; wrt = kFALSE, . Bool_t ; verbose = kTRUE . ). Set the otuput file Return 0 on success, -1 on error. ; Definition at line 261 of file TProofBench.cxx. ◆ ReleaseCache(). Int_t TProofBench::ReleaseCache ; (; const char * ; dset). Release memory cache for dataset 'dset' Return 0 on success, -1 on error. ; Definition at line 1303 of file TProofBench.cxx. ◆ RemoveDataSet(). Int_t TProofBench::RemoveDataSet ; (; const char * ; dset). Physically remove the dataset 'dset', i.e. ; remove the dataset and the files it describes Return 0 on success, -1 on error ; Definition at line 1315 of file TProofBench.cxx. ◆ RunCPU(). Int_t TProofBench::RunCPU ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1, . Int_t ; step = -1 . ). Perform the CPU run Return 0 on success, -1 on error. ; Definition at line 336 of file TProofBench.cxx. ◆ RunCPUx(). Int_t TProofBench::RunCPUx ; (; Long64_t ; nevents = -1, . Int_t ; start = -1, . Int_t ; stop = -1 . ). Perform the CPU run scanning over the number of workers per node Return 0 on success, -1 on error. ; Definition at line 365 of file TProofBench.cxx. ◆ RunDataSet(). Int_t TProofBench::RunDataSet ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ; stop = -1, . Int_t ; step = 1 . ). Perform a test using dataset 'dset' Return 0 on success, -1 on error Open the file for the results. ; Definition at line 897 of file TProofBench.cxx. ◆ RunDataSetx(). Int_t TProofBench::RunDataSetx ; (; const char * ; dset = ""BenchDataSet"", . Int_t ; start = 1, . Int_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofBench.html:21066,error,error,21066,doc/master/classTProofBench.html,https://root.cern,https://root.cern/doc/master/classTProofBench.html,1,['error'],['error']
Availability,"//www.chilkatsoft.com/p/p_299.asp */; 6377 return -2;; 6378 } else {; 6379 DEBUG_TRACE(""recv() failed, error %d"", err);; 6380 return -2;; 6381 }; 6382#else; 6383 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6384 * if the timeout is reached and if the socket was set to non-; 6385 * blocking in close_socket_gracefully, so we can not distinguish; 6386 * here. We have to wait for the timeout in both cases for now.; 6387 */; 6388 if (ERROR_TRY_AGAIN(err)) {; 6389 /* TODO (low): check if this is still required */; 6390 /* EAGAIN/EWOULDBLOCK:; 6391 * standard case if called from close_socket_gracefully; 6392 * => should return -1 */; 6393 /* or timeout occurred; 6394 * => the code must stay in the while loop */; 6395 ; 6396 /* EINTR can be generated on a socket with a timeout set even; 6397 * when SA_RESTART is effective for all relevant signals; 6398 * (see signal(7)).; 6399 * => stay in the while loop */; 6400 } else {; 6401 DEBUG_TRACE(""recv() failed, error %d"", err);; 6402 return -2;; 6403 }; 6404#endif; 6405 }; 6406 ; 6407 /* Timeout occurred, but no data available. */; 6408 return -1;; 6409}; 6410 ; 6411 ; 6412static int; 6413pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6414{; 6415 int n, nread = 0;; 6416 double timeout = -1.0;; 6417 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6418 ; 6419 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6420 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6421 }; 6422 if (timeout <= 0.0) {; 6423 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6424 / 1000.0;; 6425 }; 6426 start_time = mg_get_current_time_ns();; 6427 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6428 ; 6429 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6430 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6431 if (n == -2) {; 6432 if (nread == 0) {; 6433 nread = -1; /* Propagate the error */; 6434 }; 6435 break;; 6436 } else if (n == -1) {; 6437 /* timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:186599,error,error,186599,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,"['avail', 'error']","['available', 'error']"
Availability,"//www.chilkatsoft.com/p/p_299.asp */; 6378 return -2;; 6379 } else {; 6380 DEBUG_TRACE(""recv() failed, error %d"", err);; 6381 return -2;; 6382 }; 6383#else; 6384 /* TODO: POSIX returns either EAGAIN or EWOULDBLOCK in both cases,; 6385 * if the timeout is reached and if the socket was set to non-; 6386 * blocking in close_socket_gracefully, so we can not distinguish; 6387 * here. We have to wait for the timeout in both cases for now.; 6388 */; 6389 if (ERROR_TRY_AGAIN(err)) {; 6390 /* TODO (low): check if this is still required */; 6391 /* EAGAIN/EWOULDBLOCK:; 6392 * standard case if called from close_socket_gracefully; 6393 * => should return -1 */; 6394 /* or timeout occurred; 6395 * => the code must stay in the while loop */; 6396 ; 6397 /* EINTR can be generated on a socket with a timeout set even; 6398 * when SA_RESTART is effective for all relevant signals; 6399 * (see signal(7)).; 6400 * => stay in the while loop */; 6401 } else {; 6402 DEBUG_TRACE(""recv() failed, error %d"", err);; 6403 return -2;; 6404 }; 6405#endif; 6406 }; 6407 ; 6408 /* Timeout occurred, but no data available. */; 6409 return -1;; 6410}; 6411 ; 6412 ; 6413static int; 6414pull_all(FILE *fp, struct mg_connection *conn, char *buf, int len); 6415{; 6416 int n, nread = 0;; 6417 double timeout = -1.0;; 6418 uint64_t start_time = 0, now = 0, timeout_ns = 0;; 6419 ; 6420 if (conn->dom_ctx->config[REQUEST_TIMEOUT]) {; 6421 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 6422 }; 6423 if (timeout <= 0.0) {; 6424 timeout = strtod(config_options[REQUEST_TIMEOUT].default_value, NULL); 6425 / 1000.0;; 6426 }; 6427 start_time = mg_get_current_time_ns();; 6428 timeout_ns = (uint64_t)(timeout * 1.0E9);; 6429 ; 6430 while ((len > 0) && STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 6431 n = pull_inner(fp, conn, buf + nread, len, timeout);; 6432 if (n == -2) {; 6433 if (nread == 0) {; 6434 nread = -1; /* Propagate the error */; 6435 }; 6436 break;; 6437 } else if (n == -1) {; 6438 /* timeo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:186631,error,error,186631,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,"['avail', 'error']","['available', 'error']"
Availability,"/; 1036/// Returns the transient buffer currently used by this TTree for reading/writing baskets.; 1037 ; 1038TBuffer* TTree::GetTransientBuffer(Int_t size); 1039{; 1040 if (fTransientBuffer) {; 1041 if (fTransientBuffer->BufferSize() < size) {; 1042 fTransientBuffer->Expand(size);; 1043 }; 1044 return fTransientBuffer;; 1045 }; 1046 fTransientBuffer = new TBufferFile(TBuffer::kRead, size);; 1047 return fTransientBuffer;; 1048}; 1049 ; 1050////////////////////////////////////////////////////////////////////////////////; 1051/// Add branch with name bname to the Tree cache.; 1052/// If bname=""*"" all branches are added to the cache.; 1053/// if subbranches is true all the branches of the subbranches are; 1054/// also put to the cache.; 1055///; 1056/// Returns:; 1057/// - 0 branch added or already included; 1058/// - -1 on error; 1059 ; 1060Int_t TTree::AddBranchToCache(const char*bname, bool subbranches); 1061{; 1062 if (!GetTree()) {; 1063 if (LoadTree(0)<0) {; 1064 Error(""AddBranchToCache"",""Could not load a tree"");; 1065 return -1;; 1066 }; 1067 }; 1068 if (GetTree()) {; 1069 if (GetTree() != this) {; 1070 return GetTree()->AddBranchToCache(bname, subbranches);; 1071 }; 1072 } else {; 1073 Error(""AddBranchToCache"", ""No tree is available. Branch was not added to the cache"");; 1074 return -1;; 1075 }; 1076 ; 1077 TFile *f = GetCurrentFile();; 1078 if (!f) {; 1079 Error(""AddBranchToCache"", ""No file is available. Branch was not added to the cache"");; 1080 return -1;; 1081 }; 1082 TTreeCache *tc = GetReadCache(f,true);; 1083 if (!tc) {; 1084 Error(""AddBranchToCache"", ""No cache is available, branch not added"");; 1085 return -1;; 1086 }; 1087 return tc->AddBranch(bname,subbranches);; 1088}; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Add branch b to the Tree cache.; 1092/// if subbranches is true all the branches of the subbranches are; 1093/// also put to the cache.; 1094///; 1095/// Returns:; 1096/// - 0 branch ad",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:38038,error,error,38038,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,2,"['avail', 'error']","['available', 'error']"
Availability,"/; 1960/// Copy the command line argument, stripping MODULE/inc if; 1961/// necessary.; 1962 ; 1963void StrcpyArg(string &dest, const char *original); 1964{; 1965 dest = CopyArg(original);; 1966}; 1967 ; 1968////////////////////////////////////////////////////////////////////////////////; 1969/// Write the extra header injected into the module:; 1970/// umbrella header if (umbrella) else content header.; 1971 ; 1972static bool InjectModuleUtilHeader(const char *argv0,; 1973 TModuleGenerator &modGen,; 1974 cling::Interpreter &interp,; 1975 bool umbrella); 1976{; 1977 std::ostringstream out;; 1978 if (umbrella) {; 1979 // This will duplicate the -D,-U from clingArgs - but as they are surrounded; 1980 // by #ifndef there is no problem here.; 1981 modGen.WriteUmbrellaHeader(out);; 1982 if (interp.declare(out.str()) != cling::Interpreter::kSuccess) {; 1983 const std::string &hdrName; 1984 = umbrella ? modGen.GetUmbrellaName() : modGen.GetContentName();; 1985 ROOT::TMetaUtils::Error(nullptr, ""%s: compilation failure (%s)\n"", argv0,; 1986 hdrName.c_str());; 1987 return false;; 1988 }; 1989 } else {; 1990 modGen.WriteContentHeader(out);; 1991 }; 1992 return true;; 1993}; 1994 ; 1995////////////////////////////////////////////////////////////////////////////////; 1996/// Write the AST of the given CompilerInstance to the given File while; 1997/// respecting the given isysroot.; 1998/// If module is not a null pointer, we only write the given module to the; 1999/// given file and not the whole AST.; 2000/// Returns true if the AST was successfully written.; 2001static bool WriteAST(llvm::StringRef fileName, clang::CompilerInstance *compilerInstance,; 2002 llvm::StringRef iSysRoot,; 2003 clang::Module *module = nullptr); 2004{; 2005 // From PCHGenerator and friends:; 2006 llvm::SmallVector<char, 128> buffer;; 2007 llvm::BitstreamWriter stream(buffer);; 2008 clang::ASTWriter writer(stream, buffer, compilerInstance->getModuleCache(), /*Extensions=*/{});; 2009 std::unique_ptr<llv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:78546,failure,failure,78546,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['failure'],['failure']
Availability,"/; 2 ; 3/*************************************************************************; 4 * Copyright (C) 1995-2002, Rene Brun and Fons Rademakers. *; 5 * All rights reserved. *; 6 * *; 7 * For the licensing terms see $ROOTSYS/LICENSE. *; 8 * For the list of contributors see $ROOTSYS/README/CREDITS. *; 9 *************************************************************************/; 10 ; 11#ifndef ROOT_RConfig; 12#define ROOT_RConfig; 13 ; 14/*************************************************************************; 15 * *; 16 * RConfig *; 17 * *; 18 * Defines used by ROOT. *; 19 * *; 20 *************************************************************************/; 21 ; 22#include ""../RVersion.h""; 23#include ""RConfigure.h""; 24 ; 25 ; 26/*---- new C++ features ------------------------------------------------------*/; 27 ; 28#if defined __has_feature; 29# if __has_feature(modules); 30# define R__CXXMODULES; 31# endif; 32#endif; 33 ; 34#define R__USE_SHADOW_CLASS; 35 ; 36/* Now required, thus defined by default for backward compatibility */; 37#define R__ANSISTREAM /* ANSI C++ Standard Library conformant */; 38#define R__SSTREAM /* use sstream or strstream header */; 39 ; 40#if defined(_MSC_VER); 41# if (_MSC_VER < 1910); 42# error ""ROOT requires Visual Studio 2017 or higher.""; 43# else; 44# define R__NULLPTR; 45# endif; 46#else; 47#if defined(__cplusplus) && (__cplusplus < 201703L); 48#error ""ROOT requires support for C++17 or higher.""; 49# if defined(__GNUC__) || defined(__clang__); 50#error ""Pass `-std=c++17` as compiler argument.""; 51# endif; 52# endif; 53#endif; 54 ; 55/*---- machines --------------------------------------------------------------*/; 56 ; 57#ifdef __hpux; 58 /* R__HPUX10 or R__HPUX11 is determined in the Makefile */; 59# define R__HPUX; 60# define R__UNIX; 61# define ANSICPP; 62# ifdef __LP64__; 63# define R__B64; 64# endif; 65# ifdef R__HPUX10; 66# define NEED_SNPRINTF; 67# endif; 68#endif; 69 ; 70#ifdef _AIX; 71# define R__AIX; 72# define R__UNIX; 73# define",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConfig_8hxx_source.html:1446,error,error,1446,doc/master/RConfig_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RConfig_8hxx_source.html,1,['error'],['error']
Availability,"/; 2583/// where; 2584/// \f[; 2585/// F_a(x) = \frac{ f(x,a+\mathrm{d}a) - f(x,a-\mathrm{d}a) }{2},; 2586/// \f]; 2587/// with \f$ f(x) \f$ the plotted curve and \f$ \mathrm{d}a \f$ taken from the fit result, and; 2588/// \f$ \mathrm{Corr}(a,a') \f$ = the correlation matrix from the fit result, and \f$ Z \f$ = requested signifance (\f$ Z \sigma \f$ band); 2589///; 2590/// The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may; 2591/// not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; 2592///; 2593/// Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves; 2594/// is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed; 2595/// from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations; 2596/// for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such; 2597/// that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111); 2598/// Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much); 2599/// longer to calculate.; 2600 ; 2601RooPlot* RooAbsReal::plotOnWithErrorBand(RooPlot* frame,const RooFitResult& fr, double Z,const RooArgSet* params, const RooLinkedList& argList, bool linMethod) const; 2602{; 2603 RooLinkedList plotArgListTmp(argList) ;; 2604 RooCmdConfig::stripCmdList(plotArgListTmp,""VisualizeError,MoveToBack"") ;; 2605 ; 2606 // Strip any 'internal normalization' arguments from list; 2607 RooLinkedList plotArgList ;; 2608 for (auto * cmd : static_range_cast<RooCmdArg*>(plotArgListTmp)) {; 2609 if (std::string(""Normal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:114200,error,error,114200,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,"/; 3999/// \anchor HFitChi2; 4000/// ### Chi-square Fits; 4001///; 4002/// By default a chi-square (least-square) fit is performed on the histogram. The so-called modified least-square method; 4003/// is used where the residual for each bin is computed using as error the observed value (the bin error) returned by `TH1::GetBinError`; 4004///; 4005/// \f[; 4006/// Chi2 = \sum_{i}{ \left(\frac{y(i) - f(x(i) | p )}{e(i)} \right)^2 }; 4007/// \f]; 4008///; 4009/// where `y(i)` is the bin content for each bin `i`, `x(i)` is the bin center and `e(i)` is the bin error (`sqrt(y(i)` for; 4010/// an un-weighted histogram). Bins with zero errors are excluded from the fit. See also later the note on the treatment; 4011/// of empty bins. When using option ""I"" the residual is computed not using the function value at the bin center, `f(x(i)|p)`,; 4012/// but the integral of the function in the bin, Integral{ f(x|p)dx }, divided by the bin volume.; 4013/// When using option `P` (Pearson chi2), the expected error computed as `e(i) = sqrt(f(x(i)|p))` is used.; 4014/// In this case empty bins are considered in the fit.; 4015/// Both chi-square methods should not be used when the bin content represent counts, especially in case of low bin statistics,; 4016/// because they could return a biased result.; 4017///; 4018/// \anchor HFitNLL; 4019/// ### Likelihood Fits; 4020///; 4021/// When using option ""L"" a likelihood fit is used instead of the default chi-square fit.; 4022/// The likelihood is built assuming a Poisson probability density function for each bin.; 4023/// The negative log-likelihood to be minimized is; 4024///; 4025/// \f[; 4026/// NLL = - \sum_{i}{ \log {\mathrm P} ( y(i) | f(x(i) | p ) ) }; 4027/// \f]; 4028/// where `P(y|f)` is the Poisson distribution of observing a count `y(i)` in the bin when the expected count is `f(x(i)|p)`.; 4029/// The exact likelihood used is the Poisson likelihood described in this paper:; 4030/// S. Baker and R. D. Cousins, “Clarification of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:163001,error,error,163001,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"/; 4316/// In case of a 3-Dim expression, one can generate a TProfile2D histogram; 4317/// instead of a TH3F histogram by specifying option=prof or option=profs.; 4318/// or option=profi or option=profg ; the trailing letter select the way; 4319/// the bin error are computed, See TProfile2D::SetErrorOption for; 4320/// details on the differences.; 4321/// The option=prof is automatically selected in case of z:y:x>>pf; 4322/// where pf is an existing TProfile2D histogram.; 4323///; 4324/// ### Making a 5D plot using GL; 4325///; 4326/// If option GL5D is specified together with 5 variables, a 5D plot is drawn; 4327/// using OpenGL. See $ROOTSYS/tutorials/tree/staff.C as example.; 4328///; 4329/// ### Making a parallel coordinates plot; 4330///; 4331/// In case of a 2-Dim or more expression with the option=para, one can generate; 4332/// a parallel coordinates plot. With that option, the number of dimensions is; 4333/// arbitrary. Giving more than 4 variables without the option=para or; 4334/// option=candle or option=goff will produce an error.; 4335///; 4336/// ### Making a candle sticks chart; 4337///; 4338/// In case of a 2-Dim or more expression with the option=candle, one can generate; 4339/// a candle sticks chart. With that option, the number of dimensions is; 4340/// arbitrary. Giving more than 4 variables without the option=para or; 4341/// option=candle or option=goff will produce an error.; 4342///; 4343/// ### Normalizing the output histogram to 1; 4344///; 4345/// When option contains ""norm"" the output histogram is normalized to 1.; 4346///; 4347/// ### Saving the result of Draw to a TEventList, a TEntryList or a TEntryListArray; 4348///; 4349/// TTree::Draw can be used to fill a TEventList object (list of entry numbers); 4350/// instead of histogramming one variable.; 4351/// If varexp0 has the form >>elist , a TEventList object named ""elist""; 4352/// is created in the current directory. elist will contain the list; 4353/// of entry numbers satisfying th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:174820,error,error,174820,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"/; 53class RLogDiagCount {; 54protected:; 55 std::atomic<long long> fNumWarnings{0ll}; /// Number of warnings.; 56 std::atomic<long long> fNumErrors{0ll}; /// Number of errors.; 57 std::atomic<long long> fNumFatalErrors{0ll}; /// Number of fatal errors.; 58 ; 59public:; 60 /// Returns the current number of warnings.; 61 long long GetNumWarnings() const { return fNumWarnings; }; 62 ; 63 /// Returns the current number of errors.; 64 long long GetNumErrors() const { return fNumErrors; }; 65 ; 66 /// Returns the current number of fatal errors.; 67 long long GetNumFatalErrors() const { return fNumFatalErrors; }; 68 ; 69 /// Increase warning or error count.; 70 void Increment(ELogLevel severity); 71 {; 72 switch (severity) {; 73 case ELogLevel::kFatal: ++fNumFatalErrors; break;; 74 case ELogLevel::kError: ++fNumErrors; break;; 75 case ELogLevel::kWarning: ++fNumWarnings; break;; 76 default:;; 77 }; 78 }; 79};; 80 ; 81/**; 82 Abstract RLogHandler base class. ROOT logs everything from info to error; 83 to entities of this class.; 84 */; 85class RLogHandler {; 86public:; 87 virtual ~RLogHandler();; 88 /// Emit a log entry.; 89 /// \param entry - the RLogEntry to be emitted.; 90 /// \returns false if further emission of this Log should be suppressed.; 91 ///; 92 /// \note This function is called concurrently; log emission must be locked; 93 /// if needed. (The default log handler using ROOT's DefaultErrorHandler is locked.); 94 virtual bool Emit(const RLogEntry &entry) = 0;; 95};; 96 ; 97/**; 98 A log configuration for a channel, e.g. ""RHist"".; 99 Each ROOT module has its own log, with potentially distinct verbosity.; 100 */; 101class RLogChannel : public RLogDiagCount {; 102 /// Name as shown in diagnostics; 103 std::string fName;; 104 ; 105 /// Verbosity of this channel. By default, use the global verbosity.; 106 ELogLevel fVerbosity = ELogLevel::kUnset;; 107 ; 108public:; 109 /// Construct an anonymous channel.; 110 RLogChannel() = default;; 111 ; 112 /// Construct an anony",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:2792,error,error,2792,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['error']
Availability,"/; 552/// Constructor allocate.; 553///; 554/// Note: This function should be called only from the constructor; 555/// since it does not delete previously existing arrays.; 556 ; 557Bool_t TGraphErrors::CtorAllocate(); 558{; 559 ; 560 if (!fNpoints) {; 561 fEX = fEY = nullptr;; 562 return kFALSE;; 563 } else {; 564 fEX = new Double_t[fMaxSize];; 565 fEY = new Double_t[fMaxSize];; 566 }; 567 return kTRUE;; 568}; 569 ; 570////////////////////////////////////////////////////////////////////////////////; 571/// Protected function to perform the merge operation of a graph with errors.; 572 ; 573Bool_t TGraphErrors::DoMerge(const TGraph *g); 574{; 575 if (g->GetN() == 0) return kFALSE;; 576 ; 577 Double_t * ex = g->GetEX();; 578 Double_t * ey = g->GetEY();; 579 if (ex == nullptr || ey == nullptr) {; 580 if (g->IsA() != TGraph::Class() ); 581 Warning(""DoMerge"",""Merging a %s is not compatible with a TGraphErrors - errors will be ignored"",g->IsA()->GetName());; 582 return TGraph::DoMerge(g);; 583 }; 584 for (Int_t i = 0 ; i < g->GetN(); i++) {; 585 Int_t ipoint = GetN();; 586 Double_t x = g->GetX()[i];; 587 Double_t y = g->GetY()[i];; 588 SetPoint(ipoint, x, y);; 589 SetPointError( ipoint, ex[i], ey[i] );; 590 }; 591 return kTRUE;; 592}; 593 ; 594 ; 595////////////////////////////////////////////////////////////////////////////////; 596/// Set zero values for point arrays in the range `[begin, end]`.; 597 ; 598void TGraphErrors::FillZero(Int_t begin, Int_t end, Bool_t from_ctor); 599{; 600 if (!from_ctor) {; 601 TGraph::FillZero(begin, end, from_ctor);; 602 }; 603 Int_t n = (end - begin) * sizeof(Double_t);; 604 memset(fEX + begin, 0, n);; 605 memset(fEY + begin, 0, n);; 606}; 607 ; 608 ; 609////////////////////////////////////////////////////////////////////////////////; 610/// It returns the error along X at point `i`.; 611 ; 612Double_t TGraphErrors::GetErrorX(Int_t i) const; 613{; 614 if (i < 0 || i >= fNpoints) return -1;; 615 if (fEX) return fEX[i];; 616 return -1;; 61",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:18734,error,errors,18734,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"/QT and shows the current print option in use.; ""Predefined"" combo box - contains a list of predefined functions in ROOT. The default one is Gaussian.; ""Operation"" radio button group defines selected operational mode between functions: NOP - no operation (default); ADD - addition CONV - convolution (will be implemented in the future).; Users can enter the function expression in a text entry field. The entered string is checked after Enter key was pressed. An error message shows up if the string is not accepted. The current prototype is limited and users have no freedom to enter file/user function names in this field.; ""Set Parameters"" button opens a dialog for parameters settings.; ""Fit Settings"" provides user interface elements related to the fitter. Currently there are two method choices: Chi-square and Binned Likelihood.; ""Linear Fit"" check button sets the use of Linear fitter is it is selected. Otherwise the option 'F' is applied if polN is selected. ""Robust"" number entry sets the robust value when fitting graphs. ""No Chi-square"" check button sets ON/OFF option 'C' - do not calculate Chi-square (for Linear fitter).; Fit options: ""Integral"" check button switch ON/OFF option 'I' - use integral of function instead of value in bin center. ""Best Errors"" sets ON/OFF option 'E' - better errors estimation using Minos technique. ""All weights = 1"" sets ON/OFF option 'W' - all weights set to 1, excluding empty bins and ignoring error bars. ""Empty bins, weights=1"" sets ON/OFF option 'WW' - all weights equal to 1, including empty bins, error bars ignored. ""Use range"" sets ON/OFF option 'R' - fit only data within the specified function range with the slider. ""Improve fit results"" sets ON/OFF option 'M' - after minimum is found, search for a new one. ""Add to list"" sets On/Off option '+'- add function to the list without deleting the previous.; Draw options: ""SAME"" sets On/Off function drawing on the same pad. ""No drawing"" sets On/Off option '0'- do not draw function graphics. """,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:2063,robust,robust,2063,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['robust'],['robust']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void ExecuteEvent (Int_t event, Int_t px, Int_t py);  Execute action corresponding to an event at (px,py). ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTXTRU.html:8579,error,error,8579,doc/master/classTXTRU.html,https://root.cern,https://root.cern/doc/master/classTXTRU.html,19,['error'],['error']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFileDrawMap.html:6977,error,error,6977,doc/master/classTFileDrawMap.html,https://root.cern,https://root.cern/doc/master/classTFileDrawMap.html,3,['error'],['error']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this object is known to have an inconsistent setup for Hash and RecursiveRemove (i.e. ;  ; virtual void Info (const char *method, const char *msgfmt,...) const;  Issue info message. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAxis3D.html:10146,error,error,10146,doc/master/classTAxis3D.html,https://root.cern,https://root.cern/doc/master/classTAxis3D.html,1,['error'],['error']
Availability,"/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Delete (Option_t *option="""");  Delete this object. ;  ; virtual void Draw (Option_t *option="""");  Default Draw method for all objects. ;  ; virtual void DrawClass () const;  Draw class inheritance tree of the class to which this object belongs. ;  ; virtual TObject * DrawClone (Option_t *option="""") const;  Draw a clone of this object in the current selected pad with: gROOT->SetSelectedPad(c1). ;  ; virtual void Dump () const;  Dump contents of object on stdout. ;  ; virtual void Error (const char *method, const char *msgfmt,...) const;  Issue error message. ;  ; virtual void Execute (const char *method, const char *params, Int_t *error=nullptr);  Execute method on this object with the given parameter string, e.g. ;  ; virtual void Execute (TMethod *method, TObjArray *params, Int_t *error=nullptr);  Execute method on this object with parameters stored in the TObjArray. ;  ; virtual void Fatal (const char *method, const char *msgfmt,...) const;  Issue fatal error message. ;  ; virtual TObject * FindObject (const char *name) const;  Must be redefined in derived classes. ;  ; virtual TObject * FindObject (const TObject *obj) const;  Must be redefined in derived classes. ;  ; virtual Option_t * GetDrawOption () const;  Get option used by the graphics system to draw this object. ;  ; virtual const char * GetIconName () const;  Returns mime type name of object. ;  ; virtual char * GetObjectInfo (Int_t px, Int_t py) const;  Returns string containing info about the object at position (px,py). ;  ; virtual Option_t * GetOption () const;  ; virtual UInt_t GetUniqueID () const;  Return the unique object id. ;  ; virtual Bool_t HandleTimer (TTimer *timer);  Execute action in response of a timer timing out. ;  ; Bool_t HasInconsistentHash () const;  Return true is the type of this obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAnnotation.html:15552,error,error,15552,doc/master/classTAnnotation.html,https://root.cern,https://root.cern/doc/master/classTAnnotation.html,8,['error'],['error']
Availability,"/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionaly; compute Binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by the division of h1 by h2*-*-*. this = c1*h1/(c2*h2). if errors are defined (see TH1::Sumw2), errors are also recalculated; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; However, if option =""B"" is specified, Binomial errors are computed.; In this case c1 and c2 do not make real sense and they are ignored. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. Please note also that in the binomial case errors are calculated using standard; binomial statistics, which means when b1 = b2, the error is zero.; If you prefer to have efficiency errors not going to zero when the efficiency is 1, you must; use the function TGraphAsymmErrors::BayesDivide, which will return an asymmetric and non-zero lower; error for the case b1=b2. void Draw(Option_t* option = """"); -*-*-*-*-*-*-*-*-*Draw this histogram with options*-*-*-*-*-*-*-*-*-*-*-*. Histograms are drawn via the THistPainter class. Each histogram has; a pointer to its own painter (to be usable in a multithreaded program).; The same histogram can be drawn with different options in different pads.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:58813,error,errors,58813,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,2,['error'],['errors']
Availability,"/mathcore:$Id$; 2// Author: David Gonzalez Maline Wed Aug 28 15:33:03 2009; 3 ; 4/**********************************************************************; 5 * *; 6 * Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; 7 * *; 8 * *; 9 **********************************************************************/; 10 ; 11// Implementation file for class BinData; 12 ; 13#include <iostream>; 14#include <iterator>; 15#include <algorithm>; 16 ; 17#include <vector>; 18#include <list>; 19 ; 20#include <stdexcept>; 21 ; 22#include <cmath>; 23#include <limits>; 24 ; 25#include ""Fit/BinData.h""; 26#include ""Fit/SparseData.h""; 27 ; 28using std::cout, std::endl, std::vector, std::list, std::ostream, std::ostream_iterator;; 29 ; 30namespace ROOT {; 31 ; 32 namespace Fit {; 33 ; 34 //This class is a helper. It represents a bin in N; 35 //dimensions. The change in the name is to avoid name collision.; 36 class Box; 37 {; 38 public:; 39 // Creates a Box with limits specified by the vectors and; 40 // content=value and error=error; 41 Box(const vector<double>& min, const vector<double>& max,; 42 const double value = 0.0, const double error = 1.0):; 43 fMin(min), fMax(max), fVal(value), fError(error); 44 { }; 45 ; 46 // Compares to Boxes to see if they are equal in all its; 47 // variables. This is to be used by the std::find algorithm; 48 bool operator==(const Box& b); 49 { return (fMin == b.fMin) && (fMax == b.fMax); 50 && (fVal == b.fVal) && (fError == b.fError); }; 51 ; 52 // Get the list of minimum coordinates; 53 const vector<double>& GetMin() const { return fMin; }; 54 // Get the list of maximum coordinates; 55 const vector<double>& GetMax() const { return fMax; }; 56 // Get the value of the Box; 57 double GetVal() const { return fVal; }; 58 // Get the error of the Box; 59 double GetError() const { return fError; }; 60 ; 61 // Add an amount to the content of the Box; 62 void AddVal(const double value) { fVal += value; }; 63 ; 64 friend class BoxContainer;; 65 friend ostream& operator <",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SparseData_8cxx_source.html:1211,error,error,1211,doc/master/SparseData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SparseData_8cxx_source.html,2,['error'],['error']
Availability,"/o buffer.; 2591 //; 2592 ; 2593 if (isptrptr) {; 2594 branch->SetAddress(addr);; 2595 } else {; 2596 branch->SetObject(addr);; 2597 }; 2598 ; 2599 if (delobj) {; 2600 cl->Destructor(objptr);; 2601 objptr = nullptr;; 2602 }; 2603 ; 2604 return branch;; 2605}; 2606 ; 2607////////////////////////////////////////////////////////////////////////////////; 2608/// Browse content of the TTree.; 2609 ; 2610void TTree::Browse(TBrowser* b); 2611{; 2612 fBranches.Browse(b);; 2613 if (fUserInfo) {; 2614 if (strcmp(""TList"",fUserInfo->GetName())==0) {; 2615 fUserInfo->SetName(""UserInfo"");; 2616 b->Add(fUserInfo);; 2617 fUserInfo->SetName(""TList"");; 2618 } else {; 2619 b->Add(fUserInfo);; 2620 }; 2621 }; 2622}; 2623 ; 2624////////////////////////////////////////////////////////////////////////////////; 2625/// Build a Tree Index (default is TTreeIndex).; 2626/// See a description of the parameters and functionality in; 2627/// TTreeIndex::TTreeIndex().; 2628///; 2629/// The return value is the number of entries in the Index (< 0 indicates failure).; 2630///; 2631/// A TTreeIndex object pointed by fTreeIndex is created.; 2632/// This object will be automatically deleted by the TTree destructor.; 2633/// If an index is already existing, this is replaced by the new one without being; 2634/// deleted. This behaviour prevents the deletion of a previously external index; 2635/// assigned to the TTree via the TTree::SetTreeIndex() method.; 2636/// \see also comments in TTree::SetTreeIndex().; 2637 ; 2638Int_t TTree::BuildIndex(const char* majorname, const char* minorname /* = ""0"" */); 2639{; 2640 fTreeIndex = GetPlayer()->BuildIndex(this, majorname, minorname);; 2641 if (fTreeIndex->IsZombie()) {; 2642 delete fTreeIndex;; 2643 fTreeIndex = nullptr;; 2644 return 0;; 2645 }; 2646 return fTreeIndex->GetN();; 2647}; 2648 ; 2649////////////////////////////////////////////////////////////////////////////////; 2650/// Build StreamerInfo for class cl.; 2651/// pointer is an optional argument tha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:103545,failure,failure,103545,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['failure'],['failure']
Availability,"/partial Pint is zero no matter; what the real derivative partial F/partial Pext is. ((partial F)/(partial P ))= ((partial F)/(partial P ))((partial P )/(partial P )) =((partial F)/(partial P ))= 0; int ext ext int ext. Getting the right parameter errors with limits. In the best case, where the minimum is far from any limits, MINUIT will; correctly transform the error matrix, and the parameter errors it reports; should be accurate and very close to those you would have got without; limits. In other cases (which should be more common, since otherwise you; wouldn't need limits), the very meaning of parameter errors becomes; problematic. Mathematically, since the limit is an absolute constraint on; the parameter, a parameter at its limit has no error, at least in one; direction. The error matrix, which can assign only symmetric errors, then; becomes essentially meaningless. Interpretation of Parameter Errors:. There are two kinds of problems that can arise: the reliability of; MINUIT's error estimates, and their statistical interpretation, assuming; they are accurate. Statistical interpretation:. For discussuion of basic concepts, such as the meaning of the elements of; the error matrix, or setting of exact confidence levels see:. F.James.; Determining the statistical Significance of experimental Results.; Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; Statistical Methods in Experimental Physics.; North-Holland, 1971. Reliability of MINUIT error estimates. MINUIT always carries around its own current estimates of the parameter; errors, which it will print out on request, no matter how accurate they; are at any given point in the execution. For example, at initialization,; these estimates are just the starting step sizes as specified by the user.; After a HESSE step, the errors are usually quite accurate,; unless there has been a problem. MINUIT, when it prints out error values,; also gives some indic",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMinuit.html:7170,reliab,reliability,7170,root/html528/TMinuit.html,https://root.cern,https://root.cern/root/html528/TMinuit.html,20,"['error', 'reliab']","['error', 'reliability']"
Availability,"/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution object (which is copied inside) and a string for a method.; 148 For the list of available method for 1D discrete distribution see the; 149 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fDISCR"">UnuRan doc</A>; 150 A re-initialization is needed whenever distribution parameters have been changed.; 151 ; 152 */; 153 bool Init(const TUnuranDiscrDist & distr, const std::string & method = ""auto"");; 154 ; 155 ; 156 /**; 157 Initialize method for continuous empirical distribution.; 158 User must provide a distribution object (which is copied inside) and a string for a method.; 159 The distribution object can represent binned (only 1D) or unbinned (1D or multi-dim) data; 160 The method for the unbinned empirical distribution are based on the kernel smoothing, see; 161 <A href=""http://statmath.wu-wien.ac.at/software/unuran/doc/unuran.html#EMPK"">UnuRan doc</A>; 162 A re-initialization is needed whenever distribution parameters have been changed.; 163 ; 164 */; 165 bool Init(const TUnuranEmpDist & distr, const std::string & method = ""empk"");; 166 ; 167 ; 168 /**; 169 Initi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:5836,avail,available,5836,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,1,['avail'],['available']
Availability,"0 (!=log(50.5)); NB: if the low edge of the bin is negative, the function returns the bin center; as computed by TAxis::GetBinCenter. Double_t GetBinLowEdge(Int_t bin) const; Return low edge of bin. Double_t GetBinUpEdge(Int_t bin) const; Return up edge of bin. Double_t GetBinWidth(Int_t bin) const; Return bin width. void GetCenter(Double_t* center) const; Return an array with the center of all bins. void GetLowEdge(Double_t* edge) const; Return an array with the lod edge of all bins. const char * GetTimeFormatOnly() const; Return *only* the time format from the string fTimeFormat. const char * GetTicks() const; Return the ticks option (see SetTicks). Bool_t HasBinWithoutLabel() const; this helper function checks if there is a bin without a label; if all bins have labels, the axis can / will become alphanumeric. void LabelsOption(Option_t* option = ""h""); Set option(s) to draw axis with labels; option = ""a"" sort by alphabetic order; = "">"" sort by decreasing values; = ""<"" sort by increasing values; = ""h"" draw labels horizonthal; = ""v"" draw labels vertical; = ""u"" draw labels up (end of label right adjusted); = ""d"" draw labels down (start of label left adjusted). void ImportAttributes(const TAxis* axis); Copy axis attributes to this. void SaveAttributes(ostream& out, const char* name, const char* subname); Save axis attributes as C++ statement(s) on output stream out. void Set(Int_t nbins, Double_t xmin, Double_t xmax); Initialize axis with fix bins. void Set(Int_t nbins, const Float_t* xbins); Initialize axis with variable bins. void Set(Int_t nbins, const Double_t* xbins); Initialize axis with variable bins. void SetAlphanumeric(Bool_t alphanumeric = kTRUE). void SetDefaults(); Set axis default values (from TStyle). void SetBinLabel(Int_t bin, const char* label); Set label for bin; If no label list exists, it is created. If all the bins have labels, the; axis becomes alphanumeric and extendable.; New labels will not be added with the Fill method but will end-up in the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TAxis.html:16827,down,down,16827,root/html602/TAxis.html,https://root.cern,https://root.cern/root/html602/TAxis.html,4,['down'],['down']
Availability,"0 // highlight object tracked over; 1251 pad = Pick(px, py, prevSelObj);; 1252 if (!pad) return;; 1253 ; 1254 EnterLeave(prevSelPad, prevSelObj);; 1255 ; 1256 gPad = pad; // don't use cd() we will use the current; 1257 // canvas via the GetCanvas member and not via; 1258 // gPad->GetCanvas; 1259 ; 1260 if (fSelected) {; 1261 fSelected->ExecuteEvent(event, px, py);; 1262 RunAutoExec();; 1263 }; 1264 ; 1265 break;; 1266 ; 1267 case kMouseEnter:; 1268 // mouse enters canvas; 1269 if (!fDoubleBuffer) FeedbackMode(kTRUE);; 1270 break;; 1271 ; 1272 case kMouseLeave:; 1273 // mouse leaves canvas; 1274 {; 1275 // force popdown of tooltips; 1276 TObject *sobj = fSelected;; 1277 TPad *spad = fSelectedPad;; 1278 fSelected = nullptr;; 1279 fSelectedPad = nullptr;; 1280 EnterLeave(prevSelPad, prevSelObj);; 1281 fSelected = sobj;; 1282 fSelectedPad = spad;; 1283 if (!fDoubleBuffer) FeedbackMode(kFALSE);; 1284 }; 1285 break;; 1286 ; 1287 case kButton1Double:; 1288 // triggered on the second button down within 350ms and within; 1289 // 3x3 pixels of the first button down, button up finishes action; 1290 ; 1291 case kButton1Down:; 1292 // find pad in which input occurred; 1293 pad = Pick(px, py, prevSelObj);; 1294 if (!pad) return;; 1295 ; 1296 gPad = pad; // don't use cd() because we won't draw in pad; 1297 // we will only use its coordinate system; 1298 ; 1299 if (fSelected) {; 1300 FeedbackMode(kTRUE); // to draw in rubberband mode; 1301 fSelected->ExecuteEvent(event, px, py);; 1302 ; 1303 RunAutoExec();; 1304 }; 1305 ; 1306 break;; 1307 ; 1308 case kArrowKeyPress:; 1309 case kArrowKeyRelease:; 1310 case kButton1Motion:; 1311 case kButton1ShiftMotion: //8 == kButton1Motion + shift modifier; 1312 if (fSelected) {; 1313 gPad = fSelectedPad;; 1314 ; 1315 fSelected->ExecuteEvent(event, px, py);; 1316 if (!IsWeb()); 1317 gVirtualX->Update();; 1318 if (fSelected && !fSelected->InheritsFrom(TAxis::Class())) {; 1319 Bool_t resize = kFALSE;; 1320 if (fSelected->InheritsFrom(TBox::Class()))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCanvas_8cxx_source.html:41048,down,down,41048,doc/master/TCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCanvas_8cxx_source.html,1,['down'],['down']
Availability,"0 in case of success and -1 in case of error. Int_t BuildPackage(const char* package, TProof::EBuildPackageOpt opt = kBuildAll, Int_t chkveropt = 2, TList* workers = 0); Build specified package. Executes the PROOF-INF/BUILD.sh; script if it exists on all unique nodes. If opt is kBuildOnSlavesNoWait; then submit build command to slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0, Int_t chkveropt = 2); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0, TList* workers = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the clie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:71914,down,downloading,71914,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['down'],['downloading']
Availability,"0 of file RDFColumnRegister.cxx. ◆ GetDefine(). RDFDetail::RDefineBase * ROOT::Internal::RDF::RColumnRegister::GetDefine ; (; std::string_view ; colName); const. Return the RDefine for the requested column name, or nullptr. ; Definition at line 51 of file RDFColumnRegister.cxx. ◆ GetReader(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReader ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName, . const std::type_info & ; requestedType . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; If requestedType does not match the actual type of the Define or Variation, an exception is thrown. ; Definition at line 258 of file RDFColumnRegister.cxx. ◆ GetReaderUnchecked(). RDFDetail::RColumnReaderBase * ROOT::Internal::RDF::RColumnRegister::GetReaderUnchecked ; (; unsigned int ; slot, . const std::string & ; colName, . const std::string & ; variationName . ). Return a RDefineReader or a RVariationReader, or nullptr if not available. ; No type checking is done on the requested reader. ; Definition at line 287 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [1/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::string & ; column); const. Get the names of all variations that directly or indirectly affect a given column. ; This list includes variations applied to the column as well as variations applied to other columns on which the value of this column depends (typically via a Define expression). ; Definition at line 130 of file RDFColumnRegister.cxx. ◆ GetVariationDeps() [2/2]. std::vector< std::string > ROOT::Internal::RDF::RColumnRegister::GetVariationDeps ; (; const std::vector< std::string > & ; columns); const. Get the names of all variations that directly or indirectly affect the specified columns. ; This list includes variations applied to the columns as well as variations applied to other columns on which the value of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html:9256,avail,available,9256,doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1RDF_1_1RColumnRegister.html,1,['avail'],['available']
Availability,"0 old Branch; style = 1 new Bronch. Int_t SetCacheSize(Long64_t cachesize = -1); Set maximum size of the file cache .; if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing; the Tree (default is 30 MBytes).; Returns 0 size set, cache was created if possible; -1 on error. Int_t SetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0); Set the size of the file cache and create it if possible. If autocache is true:; this may be an autocreated cache, possibly enlarging an existing; autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false:; this is a user requested cache. cacheSize is used to size the cache.; This cache should never be automatically adjusted.; Returns 0 size set, or existing autosized cache almost large enough.; (cache was created if possible); -1 on error. Int_t SetCacheEntryRange(Long64_t first, Long64_t last); interface to TTreeCache to set the cache entry range; Returns 0 entry range set; -1 on error. void SetCacheLearnEntries(Int_t n = 10); interface to TTreeCache to set the number of entries for the learning phase. void SetCircular(Long64_t maxEntries); Enable/Disable circularity for this tree. if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket; per branch in memory.; Note that when this function is called (maxEntries>0) the Tree; must be empty or having only one basket per branch.; if maxEntries <= 0 the tree circularity is disabled. NOTE 1:; Circular Trees are interesting in online real time environments; to store the results of the last maxEntries events.; NOTE 2:; Calling SetCircular with maxEntries <= 0 is necessary before; merging circular Trees that have been saved on files.; NOTE 3:; SetCircular with maxEntries <= 0 is automatically called; by TChain::Merge; NOTE 4:; A circular Tre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:134209,error,error,134209,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['error'],['error']
Availability,"0 std::cout << ""Number of iterations = "" << iter<< std::endl;; 311 ; 312 PrintState();; 313 }; 314 }; 315 fIter = iter;; 316 fStatus = status;; 317 return (fStatus == GSL_SUCCESS);; 318 ; 319}; 320 ; 321void GSLMultiRootFinder::PrintState(std::ostream & os) {; 322 // print current state; 323 if (!fSolver) return;; 324 double ndigits = std::log10( double( Dim() ) );; 325 int wi = int(ndigits)+1;; 326 const double * xtmp = fSolver->X();; 327 const double * ftmp = fSolver->FVal();; 328 os << ""Root values = "";; 329 for (unsigned int i = 0; i< Dim(); ++i); 330 os << ""x["" << std::setw(wi) << i << ""] = "" << std::setw(12) << xtmp[i] << "" "";; 331 os << std::endl;; 332 os << ""Function values = "";; 333 for (unsigned int i = 0; i< Dim(); ++i); 334 os << ""f["" << std::setw(wi) << i << ""] = "" << std::setw(12) << ftmp[i] << "" "";; 335 os << std::endl;; 336}; 337 ; 338 ; 339 ; 340} // namespace Math; 341} // namespace ROOT; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_INFO_MSGVAL#define MATH_INFO_MSGVAL(loc, txt, x)Definition Error.h:101; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; GSLMultiRootFinder.h; GSLMultiRootSolver.h; IFunction.h; f#define f(i)Definition RSha256.hxx:104; GSL_SUCCESS#define GSL_SUCCESSDefinition RooAdaptiveGaussKronrodIntegrator1D.cxx:379; typeOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html:12171,error,error,12171,doc/master/GSLMultiRootFinder_8cxx_source.html,https://root.cern,https://root.cern/doc/master/GSLMultiRootFinder_8cxx_source.html,1,['error'],['error']
Availability,"0 || bin >= fNcells) return 0;; 847 return fBinEntries.fArray[bin];; 848}; 849 ; 850////////////////////////////////////////////////////////////////////////////////; 851/// Return bin effective entries for a weighted filled Profile histogram.; 852/// In case of an unweighted profile, it is equivalent to the number of entries per bin; 853/// The effective entries is defined as the square of the sum of the weights divided by the; 854/// sum of the weights square.; 855/// TProfile::Sumw2() must be called before filling the profile with weights.; 856/// Only by calling this method the sum of the square of the weights per bin is stored.; 857 ; 858Double_t TProfile2D::GetBinEffectiveEntries(Int_t bin); 859{; 860 return TProfileHelper::GetBinEffectiveEntries(this, bin);; 861}; 862 ; 863////////////////////////////////////////////////////////////////////////////////; 864/// Return bin error of a Profile2D histogram.; 865///; 866/// ### Computing errors: A moving field; 867///; 868/// The computation of errors for a TProfile2D has evolved with the versions; 869/// of ROOT. The difficulty is in computing errors for bins with low statistics.; 870/// - prior to version 3.10, we had no special treatment of low statistic bins.; 871/// As a result, these bins had huge errors. The reason is that the; 872/// expression eprim2 is very close to 0 (rounding problems) or 0.; 873/// - The algorithm is modified/protected for the case; 874/// when a TProfile2D is projected (ProjectionX). The previous algorithm; 875/// generated a N^2 problem when projecting a TProfile2D with a large number of; 876/// bins (eg 100000).; 877/// - in version 3.10/02, a new static function TProfile::Approximate; 878/// is introduced to enable or disable (default) the approximation.; 879/// (see also comments in TProfile::GetBinError); 880 ; 881Double_t TProfile2D::GetBinError(Int_t bin) const; 882{; 883 return TProfileHelper::GetBinError((TProfile2D*)this, bin);; 884}; 885 ; 886/////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:30092,error,errors,30092,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,2,['error'],['errors']
Availability,"0 }; 4551 }; 4552 }; 4553}; 4554 ; 4555////////////////////////////////////////////////////////////////////////////////; 4556/// Fill all branches.; 4557///; 4558/// This function loops on all the branches of this tree. For; 4559/// each branch, it copies to the branch buffer (basket) the current; 4560/// values of the leaves data types. If a leaf is a simple data type,; 4561/// a simple conversion to a machine independent format has to be done.; 4562///; 4563/// This machine independent version of the data is copied into a; 4564/// basket (each branch has its own basket). When a basket is full; 4565/// (32k worth of data by default), it is then optionally compressed; 4566/// and written to disk (this operation is also called committing or; 4567/// 'flushing' the basket). The committed baskets are then; 4568/// immediately removed from memory.; 4569///; 4570/// The function returns the number of bytes committed to the; 4571/// individual branches.; 4572///; 4573/// If a write error occurs, the number of bytes returned is -1.; 4574///; 4575/// If no data are written, because, e.g., the branch is disabled,; 4576/// the number of bytes returned is 0.; 4577///; 4578/// __The baskets are flushed and the Tree header saved at regular intervals__; 4579///; 4580/// At regular intervals, when the amount of data written so far is; 4581/// greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; 4582/// This makes future reading faster as it guarantees that baskets belonging to nearby; 4583/// entries will be on the same disk region.; 4584/// When the first call to flush the baskets happen, we also take this opportunity; 4585/// to optimize the baskets buffers.; 4586/// We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; 4587/// In this case we also write the Tree header. This makes the Tree recoverable up to this point; 4588/// in case the program writing the Tree crashes.; 4589/// The decisions to FlushBaskets and A",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:185324,error,error,185324,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"0"" When fitting a TGraphErrors do not consider errors in the coordinate; = ""ROB"" In case of linear fitting, compute the LTS regression; coefficients (robust (resistant) regression), using; the default fraction of good points; ""ROB=0.x"" - compute the LTS regression coefficients, using; 0.x as a fraction of good points; = ""S"" The result of the fit is returned in the TFitResultPtr; (see below Access to the Fit Result). When the fit is drawn (by default), the parameter goption may be used; to specify a list of graphics options. See TGraphPainter for a complete; list of these options. In order to use the Range option, one must first create a function; with the expression to be fitted. For example, if your graph; has a defined range between -4 and 4 and you want to fit a gaussian; only in the interval 1 to 3, you can do:; TF1 *f1 = new TF1(""f1"",""gaus"",1,3);; graph->Fit(""f1"",""R"");. Who is calling this function:. Note that this function is called when calling TGraphErrors::Fit; or TGraphAsymmErrors::Fit ot TGraphBentErrors::Fit; See the discussion below on error calulation. Linear fitting:. When the fitting function is linear (contains the ""++"" sign) or the fitting; function is a polynomial, a linear fitter is initialised.; To create a linear function, use the following syntax: linear parts; separated by ""++"" sign.; Example: to fit the parameters of ""[0]*x + [1]*sin(x)"", create a; TF1 *f1=new TF1(""f1"", ""x++sin(x)"", xmin, xmax);; For such a TF1 you don't have to set the initial conditions.; Going via the linear fitter for functions, linear in parameters, gives a; considerable advantage in speed. Setting initial conditions:. Parameters must be initialized before invoking the Fit function.; The setting of the parameter initial values is automatic for the; predefined functions : poln, expo, gaus, landau. One can however disable; this automatic computation by specifying the option ""B"".; You can specify boundary limits for some or all parameters via; f1->SetParLimits(p_number, pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraph.html:23198,error,error,23198,root/html528/TGraph.html,https://root.cern,https://root.cern/root/html528/TGraph.html,4,['error'],['error']
Availability,"0""""""; 51); 52 ; 53df = df.DefinePerSample(""scale"", ""scale(rdfslot_, rdfsampleinfo_)""); 54 ; 55# Select events for the analysis; 56ROOT.gInterpreter.Declare(; 57 """"""; 58using ROOT::RVecF;; 59using ROOT::RVecI;; 60bool GoodElectronsAndMuons(const RVecI &type, const RVecF &pt, const RVecF &eta, const RVecF &phi, const RVecF &e, const RVecF &trackd0pv, const RVecF &tracksigd0pv, const RVecF &z0); 61{; 62 for (size_t i = 0; i < type.size(); i++) {; 63 ROOT::Math::PtEtaPhiEVector p(0.001*pt[i], eta[i], phi[i], 0.001*e[i]);; 64 if (type[i] == 11) {; 65 if (pt[i] < 7000 || abs(eta[i]) > 2.47 || abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 66 } else {; 67 if (abs(trackd0pv[i] / tracksigd0pv[i]) > 5 || abs(z0[i] * sin(p.Theta())) > 0.5) return false;; 68 }; 69 }; 70 return true;; 71}; 72""""""; 73); 74 ; 75# Select electron or muon trigger; 76df = df.Filter(""trigE || trigM""); 77 ; 78# Select events with exactly four good leptons conserving charge and lepton numbers; 79# Note that all collections are RVecs and good_lep is the mask for the good leptons.; 80# The lepton types are PDG numbers and set to 11 or 13 for an electron or muon; 81# irrespective of the charge.; 82 ; 83df = (; 84 df.Define(; 85 ""good_lep"",; 86 ""abs(lep_eta) < 2.5 && lep_pt > 5000 && lep_ptcone30 / lep_pt < 0.3 && lep_etcone20 / lep_pt < 0.3"",; 87 ); 88 .Filter(""Sum(good_lep) == 4""); 89 .Filter(""Sum(lep_charge[good_lep]) == 0""); 90 .Define(""goodlep_sumtypes"", ""Sum(lep_type[good_lep])""); 91 .Filter(""goodlep_sumtypes == 44 || goodlep_sumtypes == 52 || goodlep_sumtypes == 48""); 92); 93 ; 94# Apply additional cuts depending on lepton flavour; 95df = df.Filter(; 96 ""GoodElectronsAndMuons(lep_type[good_lep], lep_pt[good_lep], lep_eta[good_lep], lep_phi[good_lep], lep_E[good_lep], lep_trackd0pvunbiased[good_lep], lep_tracksigd0pvunbiased[good_lep], lep_z0[good_lep])""; 97); 98 ; 99# Create new columns with the kinematics of good leptons; 100df = (; 101 df.Define(""goodlep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:3911,mask,mask,3911,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['mask'],['mask']
Availability,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:43303,error,error,43303,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,2,['error'],['error']
Availability,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. Bool_t traceEvalHook(Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsPdf.html:47069,error,error,47069,root/html534/RooAbsPdf.html,https://root.cern,https://root.cern/root/html534/RooAbsPdf.html,12,['error'],['error']
Availability,"0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCachin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:43916,error,error,43916,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,6,['error'],['error']
Availability,"0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Private Member Functions; MsgLogger & Log () const;  . Private Attributes; Int_t fCount;  number of updates contributing to error field ;  ; Double_t fDEDw;  sum of deltas ;  ; Double_t fDelta;  local error field ;  ; Double_t fLearnRate;  learning rate parameter ;  ; TNeuron * fPostNeuron;  pointer to post-neuron ;  ; TNeuron * fPreNeuron;  pointer to pre-neuron ;  ; Double_t fWeight;  weight of the synapse ;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TObject; virtual vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1TSynapse.html:9826,error,error,9826,doc/master/classTMVA_1_1TSynapse.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1TSynapse.html,2,['error'],['error']
Availability,"0). explicit . Class constructor. ; nWorkers is the number of times this ROOT session will be forked, i.e. the number of workers that will be spawned. ; Definition at line 90 of file TTreeProcessorMP.cxx. ◆ ~TTreeProcessorMP(). ROOT::TTreeProcessorMP::~TTreeProcessorMP ; (; ). default . ◆ TTreeProcessorMP() [2/2]. ROOT::TTreeProcessorMP::TTreeProcessorMP ; (; const TTreeProcessorMP & ; ). delete . Member Function Documentation. ◆ Collect(). template<class T > . void ROOT::TTreeProcessorMP::Collect ; (; std::vector< T > & ; reslist). private . Listen for messages sent by the workers and call the appropriate handler function. ; TTreeProcessorMP::HandlePoolCode is called on messages with a code < 1000 and TMPClient::HandleMPCode is called on messages with a code >= 1000. ; Definition at line 433 of file TTreeProcessorMP.hxx. ◆ FixLists(). void ROOT::TTreeProcessorMP::FixLists ; (; std::vector< TObject * > & ; lists). private . Fix list of lists before merging (to avoid errors about duplicated objects) ; Definition at line 324 of file TTreeProcessorMP.cxx. ◆ GetNWorkers(). unsigned ROOT::TTreeProcessorMP::GetNWorkers ; (; ); const. inline . Definition at line 166 of file TTreeProcessorMP.hxx. ◆ HandlePoolCode(). template<class T > . void ROOT::TTreeProcessorMP::HandlePoolCode ; (; MPCodeBufPair & ; msg, . TSocket * ; sender, . std::vector< T > & ; reslist . ). private . Handle message and reply to the worker. ; Definition at line 407 of file TTreeProcessorMP.hxx. ◆ operator=(). TTreeProcessorMP & ROOT::TTreeProcessorMP::operator= ; (; const TTreeProcessorMP & ; ). delete . ◆ Process() [1/20]. template<class F > . auto ROOT::TTreeProcessorMP::Process ; (; const std::string & ; fileName, . F ; procFunc, . const std::string & ; treeName = """", . ULong64_t ; nToProcess = 0, . ULong64_t ; jFirst = 0 . ); -> InvokeResult_t<F, std::reference_wrapper<TTreeReader>>. Definition at line 366 of file TTreeProcessorMP.hxx. ◆ Process() [2/20]. template<class F > . auto ROOT::TTreeProces",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html:13136,error,errors,13136,doc/v632/classROOT_1_1TTreeProcessorMP.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TTreeProcessorMP.html,2,['error'],['errors']
Availability,"0); Int_tTProof::Retrieve(const char* queryref, const char* path = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); voidTProof::SendDataSetStatus(const char* msg, UInt_t n, UInt_t tot, Bool_t st); Bool_tTProof::SendingLogToWindow() const; voidTProof::SendLogToWindow(Bool_t mode); voidTProof::SetActive(Bool_t = kTRUE); virtual voidTProof::SetAlias(const char* alias = """"); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTProof::SetDataPoolUrl(const char* url); virtual Int_tTProof::SetDataSetTreeName(const char* dataset, const char* treename); voidTProof::SetDrawFeedbackOption(TDrawFeedback* f, Option_t* opt); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidTProof::SetInputDataFile(const char* datafile); voidTProof::SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); voidTProof::SetManager(TProofMgr* mgr); voidTProof::SetMaxDrawQueries(Int_t max); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); Int_tTProof::SetParallel(Int_t nodes = 9999, Bool_t random = kFALSE); voidTProof::SetParameter(const char* par, const char* value); voidTProof::SetParameter(const char* par, Int_t value); voidTProof::SetParameter(const char* par, Long_t value); voidTProof::SetParameter(const char* par, Long64_t value); voidTProof::SetParameter(const char* par, Double_t value); voidTProof::SetPrintProgress(PrintProgress_t pp); voidTProof::SetProgressDialog(Bool_t on = kTRUE); voidTProof::SetQueryMode(TProof::EQueryMode mode); voidTProof::SetRealTimeLog(Bool_t on = kTRUE); virtual voidTNamed::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidTProof::ShowCache(Bool_t all = kFALSE); voidT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofSuperMaster.html:15374,mask,mask,15374,root/html528/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html,1,['mask'],['mask']
Availability,"0); TDecompQRH(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TDecompQRH(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompQRH.html:2073,Error,Error,2073,root/html532/TDecompQRH.html,https://root.cern,https://root.cern/root/html532/TDecompQRH.html,2,['Error'],['Error']
Availability,"0); TDecompSVD(Int_t row_lwb, Int_t row_upb, Int_t col_lwb, Int_t col_upb); virtual~TDecompSVD(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tCondition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompSVD.html:2330,Error,Error,2330,root/html532/TDecompSVD.html,https://root.cern,https://root.cern/root/html532/TDecompSVD.html,2,['Error'],['Error']
Availability,"0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 40096 2011-07-01 10:08:17Z moneta $ » Last generated: 2011-07-04 15:24; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HypoTestInverter.html:11741,error,error,11741,root/html530/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html530/RooStats__HypoTestInverter.html,1,['error'],['error']
Availability,"0); rebuild the sampling distributions by; generating some toys and find for each of theam a new upper limit; Return the upper limit distribution and optionally also the pValue distributions for Cls, Clsb and Clbxs; as a TList for each scanned point. void SetFixedScan(int nBins, double xMin = 1, double xMax = -1); set for a fixed scan in nbins. void SetAutoScan(); set auto scan (default). { SetFixedScan(0); }. void UseCLs(bool on = true); { fUseCLs = on; if (fResults) fResults->UseCLs(on); }. void SetModel(const RooStats::ModelConfig& ); { }. void SetTestSize(Double_t size); set the size of the test (rate of Type I error) ( Eg. 0.05 for a 95% Confidence Interval). {fSize = size; if (fResults) fResults->SetTestSize(size); }. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (eg. 0.95 for a 95% Confidence Interval). {fSize = 1.-cl; if (fResults) fResults->SetConfidenceLevel(cl); }. Double_t Size() const; Get the size of the test (eg. rate of Type I error). {return fSize;}. Double_t ConfidenceLevel() const; Get the Confidence level for the test. {return 1.-fSize;}. HypoTestCalculatorGeneric * GetHypoTestCalculator() const; retrieved a reference to the internally used HypoTestCalculator; it might be invalid when the class is deleted. { return fCalculator0; }. void SetVerbose(int level = 1); set verbose level (0,1,2). { fVerbose = level; }. void SetMaximumToys(int ntoys); set maximum number of toys. { fMaxToys = ntoys;}. void SetNumErr(double err); set numerical error in test statistic evaluation (default is zero). { fNumErr = err; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Rademakers. *; » Last changed: root/roostats:$Id: HypoTestInverter.h 41455 2011-10-18 13:23:21Z moneta $ » Last generated: 2011-11-03 20:09; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HypoTestInverter.html:12258,error,error,12258,root/html532/RooStats__HypoTestInverter.html,https://root.cern,https://root.cern/root/html532/RooStats__HypoTestInverter.html,2,['error'],['error']
Availability,"0); virtual voidAddWithBurnIn(RooStats::MarkovChain& otherChain, Int_t burnIn = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__MarkovChain.html:1784,error,error,1784,root/html534/RooStats__MarkovChain.html,https://root.cern,https://root.cern/root/html534/RooStats__MarkovChain.html,3,"['Error', 'error']","['Error', 'error']"
Availability,"0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__MarkovChain.html:1621,error,error,1621,root/html526/RooStats__MarkovChain.html,https://root.cern,https://root.cern/root/html526/RooStats__MarkovChain.html,11,"['Error', 'error']","['Error', 'error']"
Availability,0); virtual~TDecompBK(); voidTObject::AbstractMethod(co,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompBK.html:2862,Error,Error,2862,root/html532/TDecompBK.html,https://root.cern,https://root.cern/root/html532/TDecompBK.html,2,['Error'],['Error']
Availability,"0); virtual~TDecompChol(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* err",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompChol.html:1785,Error,Error,1785,root/html532/TDecompChol.html,https://root.cern,https://root.cern/root/html532/TDecompChol.html,2,['Error'],['Error']
Availability,"0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 }; 4463 ; 4464 /* Start with the file extenstion from the configuration. */; 4465 tstr = strchr(error_page_file_ext, '.');; 4466 ; 4467 while ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:132510,error,error,132510,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 }; 4464 ; 4465 /* Start with the file extenstion from the configuration. */; 4466 tstr = strchr(error_page_file_ext, '.');; 4467 ; 4468 while ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:132542,error,error,132542,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"0, -3, 3);; 66 h->FillRandom(""gaus"", nh);; 67 TF1 *f = new TF1(""fgaus"", ""gaus"", -3, 3);; 68 f->SetLineWidth(2);; 69 h->Fit(f, ""Q"");; 70 h->Draw();; 71 ; 72 /*Create a histogram to hold the confidence intervals*/; 73 TH1D *hint = new TH1D(""hint"",; 74 ""Fitted Gaussian with .95 conf.band"", 100, -3, 3);; 75 (TVirtualFitter::GetFitter())->GetConfidenceIntervals(hint);; 76 //Now the ""hint"" histogram has the fitted function values as the; 77 //bin contents and the confidence intervals as bin errors; 78 hint->SetStats(false);; 79 hint->SetFillColor(2);; 80 hint->Draw(""e3 same"");; 81 ; 82//### 3. A 2d graph; 83 //Create and fill the graph; 84 int ngr2 = 100;; 85 double z, rnd, e=0.3;; 86 TGraph2D *gr2 = new TGraph2D(ngr2);; 87 gr2->SetName(""Graph2DNoError"");; 88 TF2 *f2 = new TF2(""f2"",; 89 ""1000*(([0]*sin(x)/x)*([1]*sin(y)/y))+250"",-6,6,-6,6);; 90 f2->SetParameters(1,1);; 91 for (i=0; i<ngr2; i++){; 92 f2->GetRandom2(x,y);; 93 // Generate a random number in [-e,e]; 94 rnd = 2*gRandom->Rndm()*e-e;; 95 z = f2->Eval(x,y)*(1+rnd);; 96 gr2->SetPoint(i,x,y,z);; 97 }; 98 //Create a graph with errors to store the intervals; 99 TGraph2DErrors *grint2 = new TGraph2DErrors(ngr2);; 100 for (i=0; i<ngr2; i++); 101 grint2->SetPoint(i, gr2->GetX()[i], gr2->GetY()[i], 0);; 102 ; 103 //Fit the graph; 104 f2->SetParameters(0.5,1.5);; 105 gr2->Fit(f2, ""Q"");; 106 /*Compute the confidence intervals*/; 107 (TVirtualFitter::GetFitter())->GetConfidenceIntervals(grint2);; 108 //Now the ""grint2"" graph contains function values as z-coordinates; 109 //and confidence intervals as their errors; 110 //draw; 111 myc->cd(3);; 112 f2->SetNpx(30);; 113 f2->SetNpy(30);; 114 f2->SetFillColor(kBlue);; 115 f2->Draw(""surf4"");; 116 grint2->SetNpx(20);; 117 grint2->SetNpy(20);; 118 grint2->SetMarkerStyle(24);; 119 grint2->SetMarkerSize(0.7);; 120 grint2->SetMarkerColor(kRed);; 121 grint2->SetLineColor(kRed);; 122 grint2->Draw(""E0 same"");; 123 grint2->SetTitle(""Fitted 2d function with .95 error bars"");; 124 ; 125 myc-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/ConfidenceIntervals_8C_source.html:3242,error,errors,3242,doc/master/ConfidenceIntervals_8C_source.html,https://root.cern,https://root.cern/doc/master/ConfidenceIntervals_8C_source.html,1,['error'],['errors']
Availability,"0, 5.30);; ; // Parameters; RooRealVar m0(""m0"", ""m0"", 5.291, 5.20, 5.30);; RooRealVar k(""k"", ""k"", -30, -50, -10);; ; // Pdf; RooArgusBG argus(""argus"", ""argus"", m, m0, k);; ; // Sample 1000 events in m from argus; std::unique_ptr<RooDataSet> data{argus.generate(m, 1000)};; ; // P l o t m o d e l a n d d a t a; // --------------------------------------; ; RooPlot *frame1 = m.frame(Bins(40), Title(""Argus model and data""));; data->plotOn(frame1);; argus.plotOn(frame1);; ; // F i t m o d e l t o d a t a; // ---------------------------------; ; // The ARGUS background shape has a sharp kinematic cutoff at m=m0; // and is prone to evaluation errors if the cutoff parameter m0; // is floated: when the pdf cutoff value is lower than that in data; // events with m>m0 will have zero probability; ; // Perform unbinned ML fit. Print detailed error messages for up to; // 10 events per likelihood evaluation. The default error handling strategy; // is to return a very high value of the likelihood to MINUIT if errors occur,; // which will force MINUIT to retreat from the problematic area; ; argus.fitTo(*data, PrintEvalErrors(10));; ; // Perform another fit. In this configuration only the number of errors per; // likelihood evaluation is shown, if it is greater than zero. The; // EvalErrorWall(false) arguments disables the default error handling strategy; // and will cause the actual (problematic) value of the likelihood to be passed; // to MINUIT.; //; // NB: Use of this option is NOT recommended as default strategy as broken -log(L) values; // can often be lower than 'good' ones because offending events are removed.; // This may effectively create a false minimum in problem areas. This is clearly; // illustrated in the second plot; ; m0.setError(0.1);; argus.fitTo(*data, PrintEvalErrors(0), EvalErrorWall(false));; ; // P l o t l i k e l i h o o d a s f u n c t i o n o f m 0; // ------------------------------------------------------------------; ; // Construct likelihood function of m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html:1600,error,error,1600,doc/master/rf606__nllerrorhandling_8C.html,https://root.cern,https://root.cern/doc/master/rf606__nllerrorhandling_8C.html,2,['error'],"['error', 'errors']"
Availability,"0, Int_t implicit = 1); virtual~TDecompLU(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual Double_tTDecompBase::Condition(); virtual voidTObject::Copy(TObject& object) const; virtual Bool_tDecompose(); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual voidDet(Double_t& d1, Double_t& d2); virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObjec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDecompLU.html:2159,Error,Error,2159,root/html532/TDecompLU.html,https://root.cern,https://root.cern/root/html532/TDecompLU.html,2,['Error'],['Error']
Availability,"0, UInt_t padbottom = 0); virtual~TGTableLayoutHints(); voidTObject::AbstractMethod(const char* method) const; voidTRefCnt::AddReference(); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; UInt_tGetAttachBottom() const; UInt_tGetAttachLeft() const; UInt_tGetAttachRight() const; UInt_tGetAttachTop() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; ULong_tTGLayoutHints::GetLayoutHints() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; Int_tTGLayoutHints::GetPadBottom() const; Int_tTGLayoutHints::GetPadLeft() const; Int_tTGLayoutHints::GetPadRight() const; Int_tTGLayoutHints::GetPadT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGTableLayoutHints.html:3237,error,error,3237,root/html528/TGTableLayoutHints.html,https://root.cern,https://root.cern/root/html528/TGTableLayoutHints.html,6,['error'],['error']
Availability,"0, const char* description = 0); voidAddToSet(const char* key, const char* value); voidAddToSetDescription(const char* key, const char* description); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidClear(Option_t* = 0); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual TStringGenerate(); const char*GetDescription(const char* key); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; const char*GetValue(const char* key); virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTObject::Hash() const; virtual voidTObject::Info(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGridJDL.html:2297,error,error,2297,root/html528/TGridJDL.html,https://root.cern,https://root.cern/root/html528/TGridJDL.html,6,['error'],['error']
Availability,"0,0);; TH1F *h2 = new TH1F(""h2"",""h2"",220,0,110);; TH1F *h3 = new TH1F(""h3"",""h3"",330,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h->Merge(list);; h->Draw();; }. Bool_t Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if the Multiply operation failed. Bool_t Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. The function return kFALSE if th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:98810,error,errors,98810,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,6,"['avail', 'error']","['available', 'errors']"
Availability,"0,; 11452 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11453 (unsigned int)buflen);; 11454 mg_cry_internal(; 11455 conn,; 11456 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11457 ""bytes)"",; 11458 prog,; 11459 (unsigned int)buflen);; 11460 goto done;; 11461 }; 11462 ; 11463 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11464 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11465 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11466 ; 11467 if (headers_len <= 0) {; 11468 ; 11469 /* Could not parse the CGI response. Check if some error message on; 11470 * stderr. */; 11471 i = pull_all(err, conn, buf, (int)buflen);; 11472 if (i > 0) {; 11473 /* CGI program explicitly sent an error */; 11474 /* Write the error message to the internal log */; 11475 mg_cry_internal(conn,; 11476 ""Error: CGI program \""%s\"" sent error ""; 11477 ""message: [%.*s]"",; 11478 prog,; 11479 i,; 11480 buf);; 11481 /* Don't send the error message back to the client */; 11482 mg_send_http_error(conn,; 11483 500,; 11484 ""Error: CGI program \""%s\"" failed."",; 11485 prog);; 11486 } else {; 11487 /* CGI program did not explicitly send an error, but a broken; 11488 * respon header */; 11489 mg_cry_internal(conn,; 11490 ""Error: CGI program sent malformed or too big ""; 11491 ""(>%u bytes) HTTP headers: [%.*s]"",; 11492 (unsigned)buflen,; 11493 data_len,; 11494 buf);; 11495 ; 11496 mg_send_http_error(conn,; 11497 500,; 11498 ""Error: CGI program sent malformed or too big ""; 11499 ""(>%u bytes) HTTP headers: [%.*s]"",; 11500 (unsigned)buflen,; 11501 data_len,; 11502 buf);; 11503 }; 11504 ; 11505 /* in both cases, abort processing CGI */; 11506 goto done;; 11507 }; 11508 ; 11509 pbuf = buf;; 11510 buf[headers_len - 1] = '\0';; 11511 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11512 ; 11513 /* Make up and send the status line */; 11514 status_text = ""OK"";; 11515 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11516 != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:332333,error,error,332333,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0,; 11453 ""Error: Not enough memory for CGI buffer (%u bytes)"",; 11454 (unsigned int)buflen);; 11455 mg_cry_internal(; 11456 conn,; 11457 ""Error: CGI program \""%s\"": Not enough memory for buffer (%u ""; 11458 ""bytes)"",; 11459 prog,; 11460 (unsigned int)buflen);; 11461 goto done;; 11462 }; 11463 ; 11464 DEBUG_TRACE(""CGI: %s"", ""wait for response"");; 11465 headers_len = read_message(out, conn, buf, (int)buflen, &data_len);; 11466 DEBUG_TRACE(""CGI: response: %li"", (signed long)headers_len);; 11467 ; 11468 if (headers_len <= 0) {; 11469 ; 11470 /* Could not parse the CGI response. Check if some error message on; 11471 * stderr. */; 11472 i = pull_all(err, conn, buf, (int)buflen);; 11473 if (i > 0) {; 11474 /* CGI program explicitly sent an error */; 11475 /* Write the error message to the internal log */; 11476 mg_cry_internal(conn,; 11477 ""Error: CGI program \""%s\"" sent error ""; 11478 ""message: [%.*s]"",; 11479 prog,; 11480 i,; 11481 buf);; 11482 /* Don't send the error message back to the client */; 11483 mg_send_http_error(conn,; 11484 500,; 11485 ""Error: CGI program \""%s\"" failed."",; 11486 prog);; 11487 } else {; 11488 /* CGI program did not explicitly send an error, but a broken; 11489 * respon header */; 11490 mg_cry_internal(conn,; 11491 ""Error: CGI program sent malformed or too big ""; 11492 ""(>%u bytes) HTTP headers: [%.*s]"",; 11493 (unsigned)buflen,; 11494 data_len,; 11495 buf);; 11496 ; 11497 mg_send_http_error(conn,; 11498 500,; 11499 ""Error: CGI program sent malformed or too big ""; 11500 ""(>%u bytes) HTTP headers: [%.*s]"",; 11501 (unsigned)buflen,; 11502 data_len,; 11503 buf);; 11504 }; 11505 ; 11506 /* in both cases, abort processing CGI */; 11507 goto done;; 11508 }; 11509 ; 11510 pbuf = buf;; 11511 buf[headers_len - 1] = '\0';; 11512 ri.num_headers = parse_http_headers(&pbuf, ri.http_headers);; 11513 ; 11514 /* Make up and send the status line */; 11515 status_text = ""OK"";; 11516 if ((status = get_header(ri.http_headers, ri.num_headers, ""Status"")); 11517 != ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:332366,error,error,332366,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"0,Relative) ;; 1660 pc.defineSet(""sliceSet"",""SliceVars"",0) ;; 1661 pc.defineObject(""sliceCatList"",""SliceCat"",0,nullptr,true) ;; 1662 // This dummy is needed for plotOn to recognize the ""SliceCatMany"" command.; 1663 // It is not used directly, but the ""SliceCat"" commands are nested in it.; 1664 // Removing this dummy definition results in ""ERROR: unrecognized command: SliceCatMany"".; 1665 pc.defineObject(""dummy1"",""SliceCatMany"",0) ;; 1666 pc.defineSet(""projSet"",""Project"",0) ;; 1667 pc.defineObject(""asymCat"",""Asymmetry"",0) ;; 1668 pc.defineDouble(""precision"",""Precision"",0,1e-3) ;; 1669 pc.defineDouble(""evalErrorVal"",""EvalErrorValue"",0,0) ;; 1670 pc.defineInt(""doEvalError"",""EvalErrorValue"",0,0) ;; 1671 pc.defineInt(""shiftToZero"",""ShiftToZero"",0,0) ;; 1672 pc.defineSet(""projDataSet"",""ProjData"",0) ;; 1673 pc.defineObject(""projData"",""ProjData"",1) ;; 1674 pc.defineObject(""errorFR"",""VisualizeError"",0) ;; 1675 pc.defineDouble(""errorZ"",""VisualizeError"",0,1.) ;; 1676 pc.defineSet(""errorPars"",""VisualizeError"",0) ;; 1677 pc.defineInt(""linearMethod"",""VisualizeError"",0,0) ;; 1678 pc.defineInt(""binProjData"",""ProjData"",0,0) ;; 1679 pc.defineDouble(""rangeLo"",""Range"",0,-999.) ;; 1680 pc.defineDouble(""rangeHi"",""Range"",1,-999.) ;; 1681 pc.defineInt(""numee"",""PrintEvalErrors"",0,10) ;; 1682 pc.defineInt(""rangeAdjustNorm"",""Range"",0,0) ;; 1683 pc.defineInt(""rangeWNAdjustNorm"",""RangeWithName"",0,0) ;; 1684 pc.defineInt(""VLines"",""VLines"",0,2) ; // 2==ExtendedWings; 1685 pc.defineString(""rangeName"",""RangeWithName"",0,"""") ;; 1686 pc.defineString(""normRangeName"",""NormRange"",0,"""") ;; 1687 pc.defineInt(""markerColor"",""MarkerColor"",0,-999) ;; 1688 pc.defineInt(""markerStyle"",""MarkerStyle"",0,-999) ;; 1689 pc.defineDouble(""markerSize"",""MarkerSize"",0,-999) ;; 1690 pc.defineInt(""lineColor"",""LineColor"",0,-999) ;; 1691 pc.defineInt(""lineStyle"",""LineStyle"",0,-999) ;; 1692 pc.defineInt(""lineWidth"",""LineWidth"",0,-999) ;; 1693 pc.defineInt(""fillColor"",""FillColor"",0,-999) ;; 1694 pc.defineInt(""fillStyle"",""FillStyle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:72701,error,errorPars,72701,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errorPars']
Availability,"0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProfile3D::SetErrorOption(Option_t *option); 1366{; 1367 TProfileHelper::SetErrorOption(this, option);; 1368}; 1369 ; 1370////////////////////////////////////////////////////////////////////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is needed to compute the correct statistical quantities; 1373/// of a profile filled with weights; 1374///; 1375/// This function is automatically called when the histogram is created; 1376/// if the static function TH1::SetDefaultSumw2 has been called before.; 1377/// If flag = false the structure is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:51519,error,error,51519,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['error']
Availability,"0,sizeof(Double_t)*fBufferSize);; 1753}; 1754 ; 1755////////////////////////////////////////////////////////////////////////////////; 1756/// Set option to compute profile errors.; 1757///; 1758/// The computation of the bin errors is based on the parameter option:; 1759///; 1760/// -' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; 1761/// i.e. the standard error of the bin contents.; 1762/// Note that if TProfile::Approximate() is called, an approximation is used when; 1763/// the spread in Y is 0 and the number of bin entries is > 0; 1764/// -'s' The bin errors are the standard deviations of the Y bin values; 1765/// Note that if TProfile::Approximate() is called, an approximation is used when; 1766/// the spread in Y is 0 and the number of bin entries is > 0; 1767/// -'i' Errors are as in default case (standard errors of the bin contents); 1768/// The only difference is for the case when the spread in Y is zero.; 1769/// In this case for N > 0 the error is 1./SQRT(12.*N); 1770/// -'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1771/// W is the sum in the bin of the weights of the profile.; 1772/// This option is for combining measurements y +/- dy,; 1773/// and the profile is filled with values y and weights w = 1/dy**2; 1774///; 1775/// See TProfile::BuildOptions for a detailed explanation of all options; 1776 ; 1777void TProfile::SetErrorOption(Option_t *option); 1778{; 1779 TProfileHelper::SetErrorOption(this, option);; 1780}; 1781 ; 1782////////////////////////////////////////////////////////////////////////////////; 1783/// Stream an object of class TProfile.; 1784 ; 1785void TProfile::Streamer(TBuffer &R__b); 1786{; 1787 if (R__b.IsReading()) {; 1788 UInt_t R__s, R__c;; 1789 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1790 if (R__v > 2) {; 1791 R__b.ReadClassBuffer(TProfile::Class(), this, R__v, R__s, R__c);; 1792 return;; 1793 }; 1794 //====process old versions before automatic schema ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:64627,error,error,64627,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,1,['error'],['error']
Availability,"0.0, . Double_t ; oneOverZeroError = 0.0, . const TH2 * ; hist_vyy = nullptr, . const TH2 * ; hist_vyy_inv = nullptr . ). virtual . Define input data for subsequent calls to DoUnfold(tau) ; Parameters. [in]inputinput distribution with uncertainties ; [in]scaleBias(default=nullptr) scale factor applied to the bias ; [in]oneOverZeroError(default=nullptr) for bins with zero error, this number defines 1/error. ; [in]hist_vyy(default=nullptr) if non-zero, this defines the data covariance matrix ; [in]hist_vyy_inv(default=nullptr) if non-zero and hist_vyy is set, defines the inverse of the data covariance matrix. This feature can be useful for repeated unfoldings in cases where the inversion of the input covariance matrix is lengthy. Return value: nError1+10000*nError2 . nError1: number of bins where the uncertainty is zero. these bins either are not used for the unfolding (if oneOverZeroError==nullptr) or 1/uncertainty is set to oneOverZeroError. . nError2: return values>10000 are fatal errors, because the unfolding can not be done. The number nError2 corresponds to the number of truth bins which are not constrained by data points. . Reimplemented in TUnfoldSys.; Definition at line 2274 of file TUnfold.cxx. ◆ Streamer(). void TUnfold::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TObject. ; Reimplemented from TObject.; Reimplemented in TUnfoldDensity, and TUnfoldSys. ◆ StreamerNVirtual(). void TUnfold::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 357 of file TUnfold.h. Member Data Documentation. ◆ fA. TMatrixDSparse* TUnfold::fA. protected . response matrix A ; Definition at line 154 of file TUnfold.h. ◆ fAx. TMatrixDSparse* TUnfold::fAx. private . result x folded back A*x ; Definition at line 191 of file TUnfold.h. ◆ fBiasScale. Double_t TUnfold::fBiasScale. protected . scale factor for the bias ; Definition at line 162 of file TUnfold.h. ◆ fChi2A. Double_t TUnfold::fChi2A. private . chi**2 co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTUnfold.html:58514,error,errors,58514,doc/master/classTUnfold.html,https://root.cern,https://root.cern/doc/master/classTUnfold.html,1,['error'],['errors']
Availability,"0.00000000001244332, 0.00000000000182256,; 129 -0.00000000000027007, 0.00000000000004042,-0.00000000000000610,; 130 0.00000000000000093,-0.00000000000000014, 0.00000000000000002};; 131 ; 132 Double_t t,h,y,s,a,alfa,b1,b2,b0;; 133 t=h=y=s=a=alfa=b1=b2=b0=0.;; 134 ; 135 if (x == 1) {; 136 h = pi6;; 137 } else if (x == -1) {; 138 h = -pi12;; 139 } else {; 140 t = -x;; 141 if (t <= -2) {; 142 y = -1/(1+t);; 143 s = 1;; 144 b1= TMath::Log(-t);; 145 b2= TMath::Log(1+1/t);; 146 a = -pi3+hf*(b1*b1-b2*b2);; 147 } else if (t < -1) {; 148 y = -1-t;; 149 s = -1;; 150 a = TMath::Log(-t);; 151 a = -pi6+a*(a+TMath::Log(1+1/t));; 152 } else if (t <= -0.5) {; 153 y = -(1+t)/t;; 154 s = 1;; 155 a = TMath::Log(-t);; 156 a = -pi6+a*(-hf*a+TMath::Log(1+t));; 157 } else if (t < 0) {; 158 y = -t/(1+t);; 159 s = -1;; 160 b1= TMath::Log(1+t);; 161 a = hf*b1*b1;; 162 } else if (t <= 1) {; 163 y = t;; 164 s = 1;; 165 a = 0;; 166 } else {; 167 y = 1/t;; 168 s = -1;; 169 b1= TMath::Log(t);; 170 a = pi6+hf*b1*b1;; 171 }; 172 h = y+y-1;; 173 alfa = h+h;; 174 b1 = 0;; 175 b2 = 0;; 176 for (Int_t i=19;i>=0;i--){; 177 b0 = c[i] + alfa*b1-b2;; 178 b2 = b1;; 179 b1 = b0;; 180 }; 181 h = -(s*(b0-h*b2)+a);; 182 }; 183 return h;; 184}; 185 ; 186////////////////////////////////////////////////////////////////////////////////; 187/// Computation of the error function erf(x).; 188/// Erf(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between 0 and x; 189 ; 190Double_t TMath::Erf(Double_t x); 191{; 192 return ::ROOT::Math::erf(x);; 193}; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// Computes the complementary error function erfc(x).; 197/// Erfc(x) = (2/sqrt(pi)) Integral(exp(-t^2))dt between x and infinity; 198 ; 199Double_t TMath::Erfc(Double_t x); 200{; 201 return ::ROOT::Math::erfc(x);; 202}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Returns the inverse error function.; 206/// x must be <-1<x<1; 207 ; 208D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:5475,error,error,5475,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756 0.0202606 0.00194113 43669.3 2; : 963 | 3.72111 5.2317 0.020058 0.00176556 43733.9 3; : 964 | 3.60317 5.20936 0.020113 0.00175786 43584.5 4; : 965 | 3.63413 5.37485 0.0201057 0.00175921 43605 5; : 966 | 3.74764 5.16986 0.0200985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:110243,error,error,110243,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 0.0200333 0.00176264 43785.9 6; : 850 | 6.72856 10.6877 0.0200521 0.00176189 43739.2 7; : 851 | 6.84236 10.8522 0.0200238 0.00176009 43802.7 8; : 852 Minimum Test error found - save the configuration ; : 852 | 6.78011 10.0733 0.0201111 0.00182524 43749.6 0; : 853 Minimum Test error found - save the configuration ; : 853 | 6.53284 9.90736 0.0201187 0.00181829 43714.8 0; : 854 | 6.67108 10.0768 0.0205443 0.0017732 42618.8 1; : 855 | 6.58878 10.7427 0.0200637 0.00176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9.34508 0.0201279 0.00182025 43697.5 0; : 865 | 6.18959 10.0219 0.0205128 0.00175205 42642.3 1; : 866 Minimum Test error found - save the configuration ; : 866 | 6.05678 9.24173 0.0204648 0.00182051 42908.5 0; : 867 | 5.92011 9.34278 0.0202303 0.00193747 43733 1; : 868 Minimum Test error found - save the configuration ; : 868 | 5.90509 9.03441 0.0202616 0.0019877 43778.3 0; : 869 | 5.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:102667,error,error,102667,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756 0.0202606 0.00194113 43669.3 2; : 963 | 3.72111 5.2317 0.020058 0.00176556 43733.9 3; : 964 | 3.60317 5.20936 0.020113 0.00175786 43584.5 4; : 965 | 3.63413 5.37485 0.0201057 0.00175921 43605 5; : 966 | 3.74764 5.16986 0.0200985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.659,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:110523,error,error,110523,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Min,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:84911,error,error,84911,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0.623882 0.0409529 4288.69 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.616834 0.0410715 4342.07 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.607427 0.0404816 4409.59 0; : 8 | 0.616397 0.638352 0.60791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.598324 0.0405273 4481.92 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.509836 0.557055 0.617073 0.042121 4348.19 0; : 20 | 0.510257 0.574511 0.617241 0.0402784 4333.04 1; : ; : Elapsed time for training with 3200 events: 12.3 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.22 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:16851,error,error,16851,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"0.777 -0.839; 3 0.99995 0.259 -0.777 1.000 0.990; 4 0.99980 0.141 -0.839 0.990 1.000; ; #include ""TMinuit.h""; ; float z[5],x[5],y[5],errorz[5];; ; //______________________________________________________________________________; double func(float x,float y,double *par); {; double value=( (par[0]*par[0])/(x*x)-1)/ ( par[1]+par[2]*y-par[3]*y*y);; return value;; }; ; //______________________________________________________________________________; void fcn(int &npar, double *gin, double &f, double *par, int iflag); {; const int nbins = 5;; int i;; ; //calculate chisquare; double chisq = 0;; double delta;; for (i=0;i<nbins; i++) {; delta = (z[i]-func(x[i],y[i],par))/errorz[i];; chisq += delta*delta;; }; f = chisq;; }; ; //______________________________________________________________________________; void Ifit(); {; // The z values; z[0]=1;; z[1]=0.96;; z[2]=0.89;; z[3]=0.85;; z[4]=0.78;; // The errors on z values; float error = 0.01;; errorz[0]=error;; errorz[1]=error;; errorz[2]=error;; errorz[3]=error;; errorz[4]=error;; // the x values; x[0]=1.5751;; x[1]=1.5825;; x[2]=1.6069;; x[3]=1.6339;; x[4]=1.6706;; // the y values; y[0]=1.0642;; y[1]=0.97685;; y[2]=1.13168;; y[3]=1.128654;; y[4]=1.44016;; ; TMinuit *gMinuit = new TMinuit(5); //initialize TMinuit with a maximum of 5 params; gMinuit->SetFCN(fcn);; ; double arglist[10];; int ierflg = 0;; ; arglist[0] = 1;; gMinuit->mnexcm(""SET ERR"", arglist ,1,ierflg);; ; // Set starting values and step sizes for parameters; static double vstart[4] = {3, 1 , 0.1 , 0.01};; static double step[4] = {0.1 , 0.1 , 0.01 , 0.001};; gMinuit->mnparm(0, ""a1"", vstart[0], step[0], 0,0,ierflg);; gMinuit->mnparm(1, ""a2"", vstart[1], step[1], 0,0,ierflg);; gMinuit->mnparm(2, ""a3"", vstart[2], step[2], 0,0,ierflg);; gMinuit->mnparm(3, ""a4"", vstart[3], step[3], 0,0,ierflg);; ; // Now ready for minimization step; arglist[0] = 500;; arglist[1] = 1.;; gMinuit->mnexcm(""MIGRAD"", arglist ,2,ierflg);; ; // Print results; double amin,edm,errdef;; int nvpar,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Ifit_8C.html:4034,error,errorz,4034,doc/master/Ifit_8C.html,https://root.cern,https://root.cern/doc/master/Ifit_8C.html,10,['error'],"['error', 'errorz']"
Availability,"0.8};; 52 auto gme = new TGraphMultiErrors(""gme"", ""TGraphMultiErrors Example"", np, x, y, exl, exh, eylstat, eyhstat);; 53 gme->AddYError(np, eylsys, eyhsys);; 54 gme->SetMarkerStyle(20);; 55 gme->SetLineColor(kRed);; 56 gme->GetAttLine(0)->SetLineColor(kRed);; 57 gme->GetAttLine(1)->SetLineColor(kBlue);; 58 gme->GetAttFill(1)->SetFillStyle(0);; 59 gme->Draw(""APS ; Z ; 5 s=0.5"");; 60}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMultiErrors::TGraphMultiErrors(); 67 : fNYErrors(0), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst), fExL(nullptr), fExH(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3056,error,errors,3056,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.625222 0.0421632 4287.73 0; : 2 | 0.694153 0.694394 0.638111 0.0419725 4193.66 1; : 3 | 0.689625 0.697522 0.634816 0.0412563 4211.88 2; : 4 | 0.681203 0.694822 0.628686 0.0407413 4252.1 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.619972 0.0411822 4319.36 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.614022 0.0406714 4360.33 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.602694 0.0404119 4446.16 0; : 8 | 0.616397 0.638352 0.610274 0.0409979 4391.54 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.618875 0.0405848 4323.09 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.603058 0.0404042 4443.23 0; : ; : Elapsed time for training with 3200 events: 6.25 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.214 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = C; Layer 0 DENSE Layer: ( Input = 300 , Width = 64 ) Ou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:16518,error,error,16518,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['error'],['error']
Availability,"0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.70799; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.70053 0.692869 0.629389 0.0419042 4255.43 0; : 2 | 0.694153 0.694394 0.642643 0.0421501 4163.24 1; : 3 | 0.689625 0.697522 0.642119 0.0416746 4163.58 2; : 4 | 0.681203 0.694822 0.637781 0.0412238 4190.71 3; : 5 Minimum Test error found - save the configuration ; : 5 | 0.673678 0.681248 0.623882 0.0409529 4288.69 0; : 6 Minimum Test error found - save the configuration ; : 6 | 0.660284 0.667264 0.616834 0.0410715 4342.07 0; : 7 Minimum Test error found - save the configuration ; : 7 | 0.640131 0.636981 0.607427 0.0404816 4409.59 0; : 8 | 0.616397 0.638352 0.60791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:16183,error,error,16183,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"00 ) Output = ( 1 , 100 , 100 ) Activation Function = Relu; Layer 7 DENSE Layer: ( Input = 100 , Width = 1 ) Output = ( 1 , 100 , 1 ) Activation Function = Identity; : Using 1280 events for training and 320 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 119.005; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.881238 0.852851 0.181896 0.0160504 7235.64 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.658204 0.827727 0.182292 0.0161751 7223.84 0; : 3 Minimum Test error found - save the configuration ; : 3 | 0.58547 0.792475 0.182478 0.0158424 7201.32 0; : 4 Minimum Test error found - save the configuration ; : 4 | 0.508772 0.760461 0.18258 0.0158465 7197.11 0; : 5 Minimum Test error found - save the configuration ; : 5 | 0.445197 0.705323 0.183204 0.015935 7174.07 0; : 6 | 0.409018 0.708257 0.18274 0.0151517 7160.42 1; : 7 | 0.369062 0.747523 0.18295 0.0151377 7150.84 2; : 8 | 0.31294 0.740134 0.183339 0.015769 7161.2 3; : 9 | 0.256184 0.756239 0.181088 0.0154708 7245.63 4; : 10 | 0.224257 0.809455 0.18089 0.0153446 7248.78 5; : ; : Elapsed time for training with 1600 events: 1.86 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_DNN_CPU : [dataset] : Evaluation of TMVA_DNN_CPU on training sample (1600 events); : Elapsed time for evaluation of 1600 events: 0.0796 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVA_CNN_Classification_TMVA_DNN_CPU.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:11904,error,error,11904,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['error'],['error']
Availability,"00 *ret = evhdl;; 2601 } else {; 2602 (void)close(evhdl);; 2603 }; 2604 ; 2605 return (void *)ret;; 2606}; 2607 ; 2608 ; 2609static int; 2610event_wait(void *eventhdl); 2611{; 2612 uint64_t u;; 2613 int evhdl, s;; 2614 ; 2615 if (!eventhdl) {; 2616 /* error */; 2617 return 0;; 2618 }; 2619 evhdl = *(int *)eventhdl;; 2620 ; 2621 s = (int)read(evhdl, &u, sizeof(u));; 2622 if (s != sizeof(u)) {; 2623 /* error */; 2624 return 0;; 2625 }; 2626 (void)u; /* the value is not required */; 2627 return 1;; 2628}; 2629 ; 2630 ; 2631static int; 2632event_signal(void *eventhdl); 2633{; 2634 uint64_t u = 1;; 2635 int evhdl, s;; 2636 ; 2637 if (!eventhdl) {; 2638 /* error */; 2639 return 0;; 2640 }; 2641 evhdl = *(int *)eventhdl;; 2642 ; 2643 s = (int)write(evhdl, &u, sizeof(u));; 2644 if (s != sizeof(u)) {; 2645 /* error */; 2646 return 0;; 2647 }; 2648 return 1;; 2649}; 2650 ; 2651 ; 2652static void; 2653event_destroy(void *eventhdl); 2654{; 2655 int evhdl;; 2656 ; 2657 if (!eventhdl) {; 2658 /* error */; 2659 return;; 2660 }; 2661 evhdl = *(int *)eventhdl;; 2662 ; 2663 close(evhdl);; 2664 mg_free(eventhdl);; 2665}; 2666 ; 2667 ; 2668#endif; 2669 ; 2670#endif; 2671 ; 2672 ; 2673#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE); 2674 ; 2675struct posix_event {; 2676 pthread_mutex_t mutex;; 2677 pthread_cond_t cond;; 2678 int signaled;; 2679};; 2680 ; 2681 ; 2682static void *; 2683event_create(void); 2684{; 2685 struct posix_event *ret = mg_malloc(sizeof(struct posix_event));; 2686 if (ret == 0) {; 2687 /* out of memory */; 2688 return 0;; 2689 }; 2690 if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {; 2691 /* pthread mutex not available */; 2692 mg_free(ret);; 2693 return 0;; 2694 }; 2695 if (0 != pthread_cond_init(&(ret->cond), NULL)) {; 2696 /* pthread cond not available */; 2697 pthread_mutex_destroy(&(ret->mutex));; 2698 mg_free(ret);; 2699 return 0;; 2700 }; 2701 ret->signaled = 0;; 2702 return (void *)ret;; 2703}; 2704 ; 2705 ; 2706static int; 2707e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:82466,error,error,82466,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"00) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,10000) = 1.25331; g->IntegralFast(n,x,w,0,100000)= 1.253. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t epsilon = 1e-12); Return Integral of a 2d function in range [ax,bx],[ay,by]. Double_t Integral(Double_t ax, Double_t bx, Double_t ay, Double_t by, Double_t az, Double_t bz, Double_t epsilon = 1e-12); Return Integral of a 3d function in range [ax,bx],[ay,by],[az,bz]. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 1e-12); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TF1.html:53445,error,error,53445,root/html528/TF1.html,https://root.cern,https://root.cern/root/html528/TF1.html,6,['error'],['error']
Availability,"00);; h1->Fit(""gaus"", ""0"");; h1->GetXaxis()->SetTitle(""x"");; auto rp1 = new TRatioPlot(h1);; rp1->Draw();; rp1->GetLowerRefYaxis()->SetTitle(""ratio"");; rp1->GetUpperRefYaxis()->SetTitle(""entries"");; }; TH1::GetXaxisTAxis * GetXaxis()Definition TH1.h:324; TH1::Fitvirtual TFitResultPtr Fit(const char *formula, Option_t *option="""", Option_t *goption="""", Double_t xmin=0, Double_t xmax=0)Fit histogram with function fname.Definition TH1.cxx:3898; TNamed::SetTitlevirtual void SetTitle(const char *title="""")Set the title of the TNamed.Definition TNamed.cxx:164; c1return c1Definition legend1.C:41; ratioplot2Definition ratioplot2.py:1; . Error options for difference divided by uncertainty and fit residual; The uncertainty that is used in the calculation can be steered by providing options to the option argument. Option Description . errasym Uses calculated asymmetric errors from TH1::GetBinErrorUp/TH1::GetBinErrorLow. Note that you need to set TH1::SetBinErrorOption first . errfunc Uses \( \sqrt{f(x)} \) as the error . The asymmetric error case uses the upper or lower error depending on the relative size of the bin contents, or the bin content and the function value. Access to internal parts; You can access the internal objects that are used to construct the plot via a series of methods. TRatioPlot::GetUpperPad and TRatioPlot::GetLowerPad can be used to draw additional elements on top of the existing ones. TRatioPlot::GetLowerRefGraph returns a reference to the lower pad's graph that is responsible for the range, which enables you to modify the range. Definition at line 43 of file TRatioPlot.h. Public Member Functions;  TRatioPlot ();  TRatioPlot default constructor. ;  ;  TRatioPlot (TH1 *h1, Option_t *option="""", TFitResult *fitres=nullptr);  Constructor for one histogram and a fit. ;  ;  TRatioPlot (TH1 *h1, TH1 *h2, Option_t *option=""pois"");  Constructor for two histograms. ;  ;  TRatioPlot (TH1 *h1, THStack *st, Option_t *option=""pois"");  Constructor which accepts a THStac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:6108,error,error,6108,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['error'],['error']
Availability,00.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3.28552 3.92634 0.0200717 0.0017618 43692.2 3; : 1031 | 3.09879 3.64842 0.0200603 0.0017557 43704.9 4; : 1032 | 3.23242 4.45782 0.0201318 0.0017893 43614.6 5; : 1033 Minimum Test error found - save the configuration ; : 1033 | 3.57665 3.43738 0.0206178 0.00193324 42816.1 0; : 1034 | 3.26951 3.4755 0.0201231 0.00175901 43563.3 1; : 1035 | 3.0748 4.32816 0.0202002 0.00180771 43496 2; : 1036 | 3.05868 3.88772 0.0202082 0.00176323 43372.3 3; : 1037 | 3.11243 3.8552 0.0200473 0.00176925 43768.4 4; : 1038 | 2.97479 4.01382 0.020048 0.00176307 43752 5; : 1039 | 3.15714,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:114733,error,error,114733,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"000) = %g\n"",r2);; printf(""g->IntegralFast(n,x,w,0,5) = %g\n"",r3);; printf(""g->IntegralFast(n,x,w,0,1000) = %g\n"",r4);; printf(""g->IntegralFast(n,x,w,0,10000) = %g\n"",r5);; printf(""g->IntegralFast(n,x,w,0,100000)= %g\n"",r6);; delete [] x;; delete [] w;; }. This example produces the following results:. g->Integral(0,5) = 1.25331; g->Integral(0,1000) = 1.25319; g->IntegralFast(n,x,w,0,5) = 1.25331; g->IntegralFast(n,x,w,0,1000) = 1.25331; g->IntegralFast(n,x,w,0,10000) = 1.25331; g->IntegralFast(n,x,w,0,100000)= 1.253. Double_t IntegralError(Double_t a, Double_t b, const Double_t* params = 0, const Double_t* covmat = 0, Double_t epsilon = 0.01); Return Error on Integral of a parameteric function between a and b; due to the parameter uncertainties.; A pointer to a vector of parameter values and to the elements of the covariance matrix (covmat); can be optionally passed. By default (i.e. when a zero pointer is passed) the current stored; parameter values are used to estimate the integral error together with the covariance matrix; from the last fit (retrieved from the global fitter instance). IMPORTANT NOTE1: When no covariance matrix is passed and in the meantime a fit is done; using another function, the routine will signal an error and it will return zero only; when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; In the case that npar is the same, an incorrect result is returned. IMPORTANT NOTE2: The user must pass a pointer to the elements of the full covariance matrix; dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; including also the fixed parameters. When there are fixed parameters, the pointer returned from; TVirtualFitter::GetCovarianceMatrix() cannot be used.; One should use the TFitResult class, as shown in the example below. To get the matrix and values from an old fit do for example:; TFitResultPtr r = histo->Fit(func, ""S"");; ..... after performing other f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:56025,error,error,56025,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,4,['error'],['error']
Availability,"000.0;; 10828 }; 10829 }; 10830 ; 10831 request_len = get_http_header_len(buf, *nread);; 10832 ; 10833 while (request_len == 0) {; 10834 /* Full request not yet received */; 10835 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10836 /* Server is to be stopped. */; 10837 return -1;; 10838 }; 10839 ; 10840 if (*nread >= bufsiz) {; 10841 /* Request too long */; 10842 return -2;; 10843 }; 10844 ; 10845 n = pull_inner(; 10846 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10847 if (n == -2) {; 10848 /* Receive error */; 10849 return -1;; 10850 }; 10851 ; 10852 /* update clock after every read request */; 10853 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10854 ; 10855 if (n > 0) {; 10856 *nread += n;; 10857 request_len = get_http_header_len(buf, *nread);; 10858 }; 10859 ; 10860 if ((request_len == 0) && (request_timeout >= 0)) {; 10861 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10862 > request_timeout) {; 10863 /* Timeout */; 10864 return -1;; 10865 }; 10866 }; 10867 }; 10868 ; 10869 return request_len;; 10870}; 10871 ; 10872 ; 10873#if !defined(NO_CGI) || !defined(NO_FILES); 10874static int; 10875forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10876{; 10877 const char *expect;; 10878 char buf[MG_BUF_LEN];; 10879 int success = 0;; 10880 ; 10881 if (!conn) {; 10882 return 0;; 10883 }; 10884 ; 10885 expect = mg_get_header(conn, ""Expect"");; 10886 DEBUG_ASSERT(fp != NULL);; 10887 if (!fp) {; 10888 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10889 return 0;; 10890 }; 10891 ; 10892 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10893 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10894 */; 10895 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10896 } else {; 10897 if (expect != NULL) {; 10898 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10899 conn->status_code = 100;; 10900 } else {; 10901 conn->status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:312184,error,error,312184,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"000.0;; 10829 }; 10830 }; 10831 ; 10832 request_len = get_http_header_len(buf, *nread);; 10833 ; 10834 while (request_len == 0) {; 10835 /* Full request not yet received */; 10836 if (!STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag)) {; 10837 /* Server is to be stopped. */; 10838 return -1;; 10839 }; 10840 ; 10841 if (*nread >= bufsiz) {; 10842 /* Request too long */; 10843 return -2;; 10844 }; 10845 ; 10846 n = pull_inner(; 10847 fp, conn, buf + *nread, bufsiz - *nread, request_timeout);; 10848 if (n == -2) {; 10849 /* Receive error */; 10850 return -1;; 10851 }; 10852 ; 10853 /* update clock after every read request */; 10854 clock_gettime(CLOCK_MONOTONIC, &last_action_time);; 10855 ; 10856 if (n > 0) {; 10857 *nread += n;; 10858 request_len = get_http_header_len(buf, *nread);; 10859 }; 10860 ; 10861 if ((request_len == 0) && (request_timeout >= 0)) {; 10862 if (mg_difftimespec(&last_action_time, &(conn->req_time)); 10863 > request_timeout) {; 10864 /* Timeout */; 10865 return -1;; 10866 }; 10867 }; 10868 }; 10869 ; 10870 return request_len;; 10871}; 10872 ; 10873 ; 10874#if !defined(NO_CGI) || !defined(NO_FILES); 10875static int; 10876forward_body_data(struct mg_connection *conn, FILE *fp, SOCKET sock, SSL *ssl); 10877{; 10878 const char *expect;; 10879 char buf[MG_BUF_LEN];; 10880 int success = 0;; 10881 ; 10882 if (!conn) {; 10883 return 0;; 10884 }; 10885 ; 10886 expect = mg_get_header(conn, ""Expect"");; 10887 DEBUG_ASSERT(fp != NULL);; 10888 if (!fp) {; 10889 mg_send_http_error(conn, 500, ""%s"", ""Error: NULL File"");; 10890 return 0;; 10891 }; 10892 ; 10893 if ((expect != NULL) && (mg_strcasecmp(expect, ""100-continue"") != 0)) {; 10894 /* Client sent an ""Expect: xyz"" header and xyz is not 100-continue.; 10895 */; 10896 mg_send_http_error(conn, 417, ""Error: Can not fulfill expectation"");; 10897 } else {; 10898 if (expect != NULL) {; 10899 (void)mg_printf(conn, ""%s"", ""HTTP/1.1 100 Continue\r\n\r\n"");; 10900 conn->status_code = 100;; 10901 } else {; 10902 conn->status",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:312217,error,error,312217,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"0000000."");; ; auto ptr = std::make_shared<double>();; KahanSum<double> helper(ptr);; ; auto kahanResult = dd.Book<double>(std::move(helper), {""x""});; auto plainResult = dd.Sum<double>({""x""});; ; std::cout << std::setprecision(24) << ""Kahan: "" << *kahanResult << "" Classical: "" << *plainResult << std::endl;; // Outputs: Kahan: 1000000000.00000011920929 Classical: 1000000000; }; d#define d(i)Definition RSha256.hxx:102; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; ROOT::Detail::RDF::RActionImplBase class for action helpers, see RInterface::Book() for more information.Definition RActionImpl.hxx:26; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; TTreeReaderA simple, robust and fast interface to read values from ROOT columnar datasets such as TTree,...Definition TTreeReader.h:46; yDouble_t y[n]Definition legend1.C:17; xDouble_t x[n]Definition legend1.C:17; CPyCppyy::ExecCPYCPPYY_EXTERN bool Exec(const std::string &cmd)Definition API.cxx:446; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; ROOT::GetThreadPoolSizeUInt_t GetThreadPoolSize()Returns the size of ROOT's thread pool.Definition TROOT.cxx:577; TMVA::TMVAGlob::Initializevoid Initialize(Bool_t useTMVAStyle=kTRUE)Definition tmvaglob.cxx:176; v@ vDefinition rootcling_impl.cxx:3699; sumstatic uint64_t sum(uint64_t i)Definition Factory.cxx:2345; ; Kahan: 1000000000.00000",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df022__useKahan_8C.html:3032,robust,robust,3032,doc/master/df022__useKahan_8C.html,https://root.cern,https://root.cern/doc/master/df022__useKahan_8C.html,1,['robust'],['robust']
Availability,"000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-06-30 14:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html:7239,error,error,7239,root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__AdaptiveIntegratorMultiDim.html,6,"['error', 'toler']","['error', 'tolerance']"
Availability,"000000000000001E-9, double relTol = 1.0000000000000001E-9, unsigned int maxcall = 100000, unsigned int size = 0). Construct with a reference to the integrand function and given optionally; tolerance (absolute and relative), maximum number of function evaluation (maxpts) and; size of the working array. virtual ~AdaptiveIntegratorMultiDim(). destructor (no operations). {}. double Integral(const double* xmin, const double* xmax). evaluate the integral with the previously given function between xmin[] and xmax[]. return DoIntegral(const double* xmin, const double* xmax, bool absVal = false). double Integral(const ROOT::Math::IMultiGenFunction& f, const double* xmin, const double* xmax); evaluate the integral passing a new function. void SetFunction(const ROOT::Math::IMultiGenFunction& f); set the integration function (must implement multi-dim function interface: IBaseFunctionMultiDim). double Result() const; return result of integration. { return fResult; }. double Error() const; return integration error. { return fError; }. double RelError() const; return relative error. { return fRelError; }. int Status() const; return status of integration. { return fStatus; }. int NEval() const; return number of function evaluations in calculating the integral. { return fNEval; }. void SetRelTolerance(double relTol); set relative tolerance. void SetAbsTolerance(double absTol); set absolute tolerance. void SetSize(unsigned int size); set workspace size. { fSize = size; }. void SetMinPts(unsigned int n); set min points. { fMinPts = n; }. void SetMaxPts(unsigned int n); set max points. { fMaxPts = n; }. void SetOptions(const ROOT::Math::IntegratorMultiDimOptions& opt); set the options. » Author: M. Slawinska 08/2007 » Copyright (c) 2007 , LCG ROOT MathLib Team *; » Last changed: root/mathcore:$Id$ » Last generated: 2015-09-08 17:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html:7239,error,error,7239,root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html,https://root.cern,https://root.cern/root/html604/ROOT__Math__AdaptiveIntegratorMultiDim.html,6,"['error', 'toler']","['error', 'tolerance']"
Availability,"000000000001, Option_t* option = """") const; Overlap checking tool. Check for illegal overlaps within a limit OVLP.; Use option=""s[number]"" to force overlap checking by sampling volume with; [number] points.; Ex: myVol->CheckOverlaps(0.01, ""s10000000""); // shoot 10000000 points; myVol->CheckOverlaps(0.01, ""s""); // shoot the default value of 1e6 points. void CheckShape(Int_t testNo, Int_t nsamples = 10000, Option_t* option = """"); Tests for checking the shape navigation algorithms. See TGeoShape::CheckShape(). void CleanAll(); Clean data of the volume. void ClearShape(); Clear the shape of this volume from the list held by the current manager. void CheckShapes(); check for negative parameters in shapes.; THIS METHOD LEAVES SOME GARBAGE NODES -> memory leak, to be fixed; printf(""---Checking daughters of volume %s\n"", GetName());. Int_t CountNodes(Int_t nlevels = 1000, Int_t option = 0); Count total number of subnodes starting from this volume, nlevels down; option = 0 (default) - count only once per volume; option = 1 - count every time; option = 2 - count volumes on visible branches; option = 3 - return maximum level counted already with option = 0. Bool_t IsAllInvisible() const; Return TRUE if volume and all daughters are invisible. void InvisibleAll(Bool_t flag = kTRUE); Make volume and each of it daughters (in)visible. Bool_t IsFolder() const; Return TRUE if volume contains nodes; return (GetNdaughters()?kTRUE:kFALSE);. Bool_t IsStyleDefault() const; check if the visibility and attributes are the default ones. Bool_t IsTopVolume() const; True if this is the top volume of the geometry. Bool_t IsRaytracing() const; Check if the painter is currently ray-tracing the content of this volume. void InspectMaterial() const; Inspect the material for this volume. TGeoVolume * Import(const char* filename, const char* name = """", Option_t* option = """"); Import a volume from a file. Int_t Export(const char* filename, const char* name = """", Option_t* option = """"); Export this volume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoVolume.html:35287,down,down,35287,root/html602/TGeoVolume.html,https://root.cern,https://root.cern/root/html602/TGeoVolume.html,4,['down'],['down']
Availability,"000000001, Option_t* option = """")MENU ; voidCheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tCountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidDrawOnly(Option_t* option = """"); voidDrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidFillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) const; Int_tFindNode(const TGeoNode* node, Int_t level); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Int_tGetByteCount() const; Int_tGetColour() const; TGeoNode*GetDaughter(Int_t ind) const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual TGeoPatternFinder*GetFinder() const; TGeoExtension*GetFWExtension() const; virtual const char*TObject::GetIconName() const; virtual Int_tGetIndex() const; virtual TGeoMatrix*GetMatrix() const; TGeoMedium*GetMedium() const; TGeoVolume*GetMotherVolume() const; virtual const char*TNamed::GetName() const; Int_tGetNdaughters() const; TObjArray*GetNodes() const; Int_tGetNumber() con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNode.html:4642,error,error,4642,root/html602/TGeoNode.html,https://root.cern,https://root.cern/root/html602/TGeoNode.html,4,['error'],['error']
Availability,"0000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::GradientCalculator&, const ROOT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html:2401,toler,toler,2401,root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,4,['toler'],['toler']
Availability,"000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TMultiDimFit ();  Empty CTOR. Do not use. ;  ;  TMultiDimFit (Int_t dimension, EMDFPolyType type=kMonomials, Option_t *option="""");  Constructor Second argument is the type of polynomials to use in parameterisation, one of: TMultiDimFit::kMonomials TMultiDimFit::kChebyshev TMultiDimFit::kLegendre. ;  ;  ~TMultiDimFit () override;  Destructor. ;  ; virtual void AddRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the training sample to be used for the parameterization. ;  ; virtual void AddTestRow (const Double_t *x, Double_t D, Double_t E=0);  Add a row consisting of fNVariables independent variables, the known, dependent quantity, and optionally, the square error in the dependent quantity, to the test sample to be used for the test of the parameterization. ;  ; void Browse (TBrowser *b) override;  Browse the TMultiDimFit object in the TBrowser. ;  ; void Clear (Option_t *option="""") override;  Clear internal structures and variables. ;  ; void Draw (Option_t *=""d"") override;  Default Draw method for all objects. ;  ; virtual Double_t Eval (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization at point x. ;  ; virtual Double_t EvalError (const Double_t *x, const Double_t *coeff=nullptr) const;  Evaluate parameterization error at point x. ;  ; virtual void FindParameterization (Opti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMultiDimFit.html:19062,error,error,19062,doc/master/classTMultiDimFit.html,https://root.cern,https://root.cern/doc/master/classTMultiDimFit.html,1,['error'],['error']
Availability,"0000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }. TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h.Merge(list);; h->Draw();; }. void Multiply(TF1* h1, Double_t c1 = 1); Performs the operation: this = this*c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1); -*-*-*-*-*-*-*-*-*Multiply this histogram by h1*-*-*-*-*-*-*-*-*-*-*-*-*. this = this*h1. If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Multiply(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*-*Replace contents of this histogram by multiplication of h1 by h2*-*. this = (c1*h1)*(c2*h2). If errors of this are available (TH1::Sumw2), errors are recalculated.; Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this; if not already set. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Multiply. void Paint(Option_t* option = """"); -*-*-*-*-*-*-*Control routine to paint any kind of histograms*-*-*-*-*-*-*. This function is automatically called by TCanvas::Update.; (see TH1::Draw for the list of options). TH1 * Rebin(Int_t ngroup = 2, const char* newname = """", const Double_t* xb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH1.html:93283,error,errors,93283,root/html528/TH1.html,https://root.cern,https://root.cern/root/html528/TH1.html,4,['error'],['errors']
Availability,"001) const; static Double_tTF1::DerivativeError(); Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tTF1::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTF1::Draw(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF12.html:2743,error,error,2743,root/html604/TF12.html,https://root.cern,https://root.cern/root/html604/TF12.html,3,"['Error', 'error']","['Error', 'error']"
Availability,00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 6.77041 0.0201181 0.00182552 43733.5 0; : 913 | 4.96617 7.29752 0.0200675 0.00175608 43688.5 1; : 914 | 4.79524 7.25946 0.0200357 0.00175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error found - save the configuration ; : 916 | 4.49553 6.65717 0.0201015 0.00180949 43734.9 0; : 917 Minimum Test error found - save the configuration ; : 917 | 4.36563 6.60613 0.0201007 0.00181415 43748 0; : 918 Minimum Test error found - save the configuration ; : 918 | 4.47049 6.3479 0.0200865 0.00182018 43796.4 0; : 919 | 4.35846 6.60136 0.0200632 0.00176343 43716.3 1; : 920 | 4.30933 6.53557 0.0200239 0.00175965 43801.4 2; : 921 Minimum Test error found - save the configuration ; : 921 | 4.32266 6.29119 0.0200952 0.00182605 43789.5 0; : 922 | 4.32742 6.39561 0.0200257 0.00176292 43804.9 1; : 923 | 4.33774 6.46608 0.0200201 0.00176071 43813 2; : 924 | 4.36503 6.31,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:106879,error,error,106879,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,00176071 43813 2; : 924 | 4.36503 6.3111 0.0200702 0.00177545 43728.3 3; : 925 | 4.7314 7.24632 0.0202093 0.00176259 43368.2 4; : 926 | 4.61316 6.64099 0.020249 0.00181216 43391.3 5; : 927 Minimum Test error found - save the configuration ; : 927 | 4.41727 6.09792 0.0203192 0.00184107 43294.4 0; : 928 | 4.15393 6.23618 0.0200677 0.00177036 43722.3 1; : 929 | 4.2848 6.29195 0.0202769 0.00175908 43201.6 2; : 930 | 4.39879 6.60248 0.0204218 0.00176177 42872.3 3; : 931 | 4.17549 6.55946 0.0200581 0.00175886 43717.6 4; : 932 | 4.18849 6.67063 0.0200652 0.00175543 43692.5 5; : 933 Minimum Test error found - save the configuration ; : 933 | 4.07608 6.08713 0.0202588 0.00184594 43447.8 0; : 934 | 4.3998 6.10426 0.0204691 0.00178412 42815.1 1; : 935 | 4.23034 6.39854 0.0202977 0.00176426 43165.2 2; : 936 Minimum Test error found - save the configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.29174 0.0201055 0.00180854 43723.1 1; : 941 | 3.89757 5.80965 0.0203179 0.00179759 43195.8 2; : 942 | 3.94904 5.73464 0.0200877 0.00175468 43637.1 3; : 943 | 3.90362 5.73888 0.0200954 0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:108842,error,error,108842,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,00176171 43266.9 2; : 871 Minimum Test error found - save the configuration ; : 871 | 5.78015 8.79318 0.0200883 0.00182097 43794.1 0; : 872 | 5.76603 9.46642 0.0200354 0.00176138 43778.1 1; : 873 Minimum Test error found - save the configuration ; : 873 | 5.70638 8.71803 0.0200731 0.00181478 43815.7 0; : 874 Minimum Test error found - save the configuration ; : 874 | 5.53455 8.53383 0.0201925 0.00181685 43535.8 0; : 875 | 5.74708 8.69754 0.0202376 0.00177647 43334.2 1; : 876 | 5.6794 9.00589 0.0202045 0.00176006 43373.5 2; : 877 | 5.64383 8.64736 0.0203248 0.00179972 43184.7 3; : 878 Minimum Test error found - save the configuration ; : 878 | 5.55379 8.16524 0.0206602 0.00187795 42593.5 0; : 879 | 5.63754 8.31065 0.0203728 0.00175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5.7556 8.5037 0.0200424 0.00175411 43743.8 3; : 882 | 5.47815 8.64255 0.0200508 0.00175977 43737.3 4; : 883 | 5.49484 8.19099 0.0201663 0.00175135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:104749,error,error,104749,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.014,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90788,error,error,90788,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.0149 24.223 0.0201139 0.00181842 43726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.677,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90901,error,error,90901,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"001 . ); const. virtual . Returns the first derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - f(x-h)}{2h}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used, otherwise the parameters in params are used.; the argument eps may be specified to control the step size (precision). the step size is taken as eps*(xmax-xmin). the default value (0.001) should be good enough for the vast majority of functions. Give a smaller value if your function has many changes of the second derivative in the function range.; Getting the error via TF1::DerivativeError: (total error = roundoff error + interpolation error) the estimate of the roundoff error is taken as follows: ; \[; err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; \]. where k is the double precision, ai are coefficients used in central difference formulas interpolation error is decreased by making the step size h smaller.; AuthorAnna Kreshuk ; Definition at line 1113 of file TF1.cxx. ◆ Derivative2(). Double_t TF1::Derivative2 ; (; Double_t ; x, . Double_t * ; params = nullptr, . Double_t ; eps = 0.001 . ); const. virtual . Returns the second derivative of the function at point x, computed by Richardson's extrapolation method (use 2 derivative estimates to compute a third, more accurate estimation) first, derivatives with steps h and h/2 are computed by central difference formulas. . \[; D(h) = \frac{f(x+h) - 2f(x) + f(x-h)}{h^{2}}; \]. the final estimate ; \[; D = \frac{4D(h/2) - D(h)}{3}; \]. ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; if the argument params is null, the current function parameters are used",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:62896,error,error,62896,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,5,['error'],['error']
Availability,"004////////////////////////////////////////////////////////////////////////////////; 2005/// Set number of points to be generated on the shape outline when checking for overlaps.; 2006 ; 2007void TGeoPainter::SetNmeshPoints(Int_t npoints); 2008{; 2009 fChecker->SetNmeshPoints(npoints);; 2010}; 2011 ; 2012////////////////////////////////////////////////////////////////////////////////; 2013/// Select a node to be checked for overlaps. All overlaps not involving it will; 2014/// be ignored.; 2015 ; 2016void TGeoPainter::SetCheckedNode(TGeoNode *node); 2017{; 2018 fChecker->SetSelectedNode(node);; 2019}; 2020 ; 2021////////////////////////////////////////////////////////////////////////////////; 2022/// Set default level down to which visualization is performed; 2023 ; 2024void TGeoPainter::SetVisLevel(Int_t level); 2025{; 2026 if (level == fVisLevel && fLastVolume == fTopVolume); 2027 return;; 2028 fVisLevel = level;; 2029 if (!fTopVolume); 2030 return;; 2031 if (fVisLock) {; 2032 ClearVisibleVolumes();; 2033 fVisLock = kFALSE;; 2034 }; 2035 if (!fLastVolume) {; 2036 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2037 return;; 2038 }; 2039 if (!gPad); 2040 return;; 2041 if (gPad->GetView()) {; 2042 // printf(""--- Drawing %6d nodes with %d visible levels\n"",fNVisNodes,fVisLevel);; 2043 ModifiedPad();; 2044 }; 2045}; 2046 ; 2047////////////////////////////////////////////////////////////////////////////////; 2048/// Set top geometry volume as visible.; 2049 ; 2050void TGeoPainter::SetTopVisible(Bool_t vis); 2051{; 2052 if (fTopVisible == vis); 2053 return;; 2054 fTopVisible = vis;; 2055 ModifiedPad();; 2056}; 2057 ; 2058////////////////////////////////////////////////////////////////////////////////; 2059/// Set drawing mode :; 2060/// - option=0 (default) all nodes drawn down to vislevel; 2061/// - option=1 leaves and nodes at vislevel drawn; 2062/// - option=2 path is drawn; 2063 ; 2064void TGeoPainter::SetVisOption(Int_t option); 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoPainter_8cxx_source.html:66116,down,down,66116,doc/master/TGeoPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoPainter_8cxx_source.html,1,['down'],['down']
Availability,"00:Layout=DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM:CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""1|1|300"" [The Layout of the input]; : Layout: ""DENSE|64|TANH,DENSE|TANH|64,DENSE|TANH|64,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIER"" [Weight initialization strategy]; : RandomSeed: ""0"" [Random seed used for weight initialization and batch shuffling]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=10,BatchSize=256,TestRepetitions=1,WeightDecay=1e-4,Regularization=None,MaxEpochs=20DropConfig=0.0+0.+0.+0.,Optimizer=ADAM"" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]; : BatchLayout: ""0|0|0"" [The Layout of the batch]; : ValidationSize: ""20%"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:9929,error,error,9929,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,2,['error'],['error']
Availability,"01 *ret = evhdl;; 2602 } else {; 2603 (void)close(evhdl);; 2604 }; 2605 ; 2606 return (void *)ret;; 2607}; 2608 ; 2609 ; 2610static int; 2611event_wait(void *eventhdl); 2612{; 2613 uint64_t u;; 2614 int evhdl, s;; 2615 ; 2616 if (!eventhdl) {; 2617 /* error */; 2618 return 0;; 2619 }; 2620 evhdl = *(int *)eventhdl;; 2621 ; 2622 s = (int)read(evhdl, &u, sizeof(u));; 2623 if (s != sizeof(u)) {; 2624 /* error */; 2625 return 0;; 2626 }; 2627 (void)u; /* the value is not required */; 2628 return 1;; 2629}; 2630 ; 2631 ; 2632static int; 2633event_signal(void *eventhdl); 2634{; 2635 uint64_t u = 1;; 2636 int evhdl, s;; 2637 ; 2638 if (!eventhdl) {; 2639 /* error */; 2640 return 0;; 2641 }; 2642 evhdl = *(int *)eventhdl;; 2643 ; 2644 s = (int)write(evhdl, &u, sizeof(u));; 2645 if (s != sizeof(u)) {; 2646 /* error */; 2647 return 0;; 2648 }; 2649 return 1;; 2650}; 2651 ; 2652 ; 2653static void; 2654event_destroy(void *eventhdl); 2655{; 2656 int evhdl;; 2657 ; 2658 if (!eventhdl) {; 2659 /* error */; 2660 return;; 2661 }; 2662 evhdl = *(int *)eventhdl;; 2663 ; 2664 close(evhdl);; 2665 mg_free(eventhdl);; 2666}; 2667 ; 2668 ; 2669#endif; 2670 ; 2671#endif; 2672 ; 2673 ; 2674#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE); 2675 ; 2676struct posix_event {; 2677 pthread_mutex_t mutex;; 2678 pthread_cond_t cond;; 2679 int signaled;; 2680};; 2681 ; 2682 ; 2683static void *; 2684event_create(void); 2685{; 2686 struct posix_event *ret = mg_malloc(sizeof(struct posix_event));; 2687 if (ret == 0) {; 2688 /* out of memory */; 2689 return 0;; 2690 }; 2691 if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {; 2692 /* pthread mutex not available */; 2693 mg_free(ret);; 2694 return 0;; 2695 }; 2696 if (0 != pthread_cond_init(&(ret->cond), NULL)) {; 2697 /* pthread cond not available */; 2698 pthread_mutex_destroy(&(ret->mutex));; 2699 mg_free(ret);; 2700 return 0;; 2701 }; 2702 ret->signaled = 0;; 2703 return (void *)ret;; 2704}; 2705 ; 2706 ; 2707static int; 2708e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:82498,error,error,82498,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"01 /* Local variables */; 7702 Double_t si;; 7703 Int_t i, j, k, kp1, km1;; 7704 ; 7705 /* Parameter adjustments */; 7706 a_offset = l + 1;; 7707 a -= a_offset;; 7708 ; 7709 /* Function Body */; 7710 ifail = 0;; 7711 if (n < 1) goto L100;; 7712 if (n > fMaxint) goto L100;; 7713// scale matrix by sqrt of diag elements; 7714 for (i = 1; i <= n; ++i) {; 7715 si = a[i + i*l];; 7716 if (si <= 0) goto L100;; 7717 fVERTs[i-1] = 1 / TMath::Sqrt(si);; 7718 }; 7719 for (i = 1; i <= n; ++i) {; 7720 for (j = 1; j <= n; ++j) {; 7721 a[i + j*l] = a[i + j*l]*fVERTs[i-1]*fVERTs[j-1];; 7722 }; 7723 }; 7724// start main loop; 7725 for (i = 1; i <= n; ++i) {; 7726 k = i;; 7727// preparation for elimination step1; 7728 if (a[k + k*l] != 0) fVERTq[k-1] = 1 / a[k + k*l];; 7729 else goto L100;; 7730 fVERTpp[k-1] = 1;; 7731 a[k + k*l] = 0;; 7732 kp1 = k + 1;; 7733 km1 = k - 1;; 7734 if (km1 < 0) goto L100;; 7735 else if (km1 == 0) goto L50;; 7736 else goto L40;; 7737L40:; 7738 for (j = 1; j <= km1; ++j) {; 7739 fVERTpp[j-1] = a[j + k*l];; 7740 fVERTq[j-1] = a[j + k*l]*fVERTq[k-1];; 7741 a[j + k*l] = 0;; 7742 }; 7743L50:; 7744 if (k - n < 0) goto L51;; 7745 else if (k - n == 0) goto L60;; 7746 else goto L100;; 7747L51:; 7748 for (j = kp1; j <= n; ++j) {; 7749 fVERTpp[j-1] = a[k + j*l];; 7750 fVERTq[j-1] = -a[k + j*l]*fVERTq[k-1];; 7751 a[k + j*l] = 0;; 7752 }; 7753// elimination proper; 7754L60:; 7755 for (j = 1; j <= n; ++j) {; 7756 for (k = j; k <= n; ++k) { a[j + k*l] += fVERTpp[j-1]*fVERTq[k-1]; }; 7757 }; 7758 }; 7759// elements of left diagonal and unscaling; 7760 for (j = 1; j <= n; ++j) {; 7761 for (k = 1; k <= j; ++k) {; 7762 a[k + j*l] = a[k + j*l]*fVERTs[k-1]*fVERTs[j-1];; 7763 a[j + k*l] = a[k + j*l];; 7764 }; 7765 }; 7766 return;; 7767// failure return; 7768L100:; 7769 ifail = 1;; 7770}; 7771 ; 7772////////////////////////////////////////////////////////////////////////////////; 7773/// Prints Warning messages; 7774///; 7775/// - If COPT='W', CMES is a WARning message from CORG.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:248225,failure,failure,248225,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['failure'],['failure']
Availability,"01 of file TCondor.cxx. ◆ Class(). static TClass * TCondor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCondor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCondor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 88 of file TCondor.h. ◆ DeclFileName(). static const char * TCondor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 88 of file TCondor.h. ◆ GetImage(). TString TCondor::GetImage ; (; const char * ; host); const. Get image of the worker. ; Definition at line 440 of file TCondor.cxx. ◆ GetState(). EState TCondor::GetState ; (; ); const. inline . Definition at line 79 of file TCondor.h. ◆ GetVirtualMachines(). TList * TCondor::GetVirtualMachines ; (; ); const. Get the names of the virtual machines in the pool. ; Return a TList of TObjString or 0 in case of failure ; Definition at line 194 of file TCondor.cxx. ◆ GetVmInfo(). Bool_t TCondor::GetVmInfo ; (; const char * ; vm, . TString & ; image, . Int_t & ; perfidx . ); const. Get info about worker status. ; Definition at line 401 of file TCondor.cxx. ◆ IsA(). TClass * TCondor::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 88 of file TCondor.h. ◆ IsValid(). Bool_t TCondor::IsValid ; (; ); const. inline . Definition at line 72 of file TCondor.h. ◆ Print(). void TCondor::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print master status. ; Reimplemented from TObject.; Definition at line 89 of file TCondor.cxx. ◆ Release(). Bool_t TCondor::Release ; (; ). Release worker. ; Definition at line 357 of file TCondor.cxx. ◆ Resume(). Bool_t TCondor::Resume ; (; ). Resume worker. ; Definition at line 343 of file TCondor.cxx. ◆ SetState(). Bool_t TCondor::SetState ; (; EState ; state). Set the state ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:13444,failure,failure,13444,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,1,['failure'],['failure']
Availability,"01) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; ROOT::Minuit2::ModularFunctionMinimizerModularFunctionMinimizer(); ROOT::Minuit2::ModularFunctionMinimizerModularFunctionMinimizer(const ROOT::Minuit2::ModularFunctionMinimizer&); ROOT::Minuit2::ModularFunctionMinimizer&operator=(const ROOT::Minuit2::ModularFunctionMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~ModularFunctionMinimizer(); {}. FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1); inherited interface. FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, unsigned int, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1); extension. FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameters&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNBase&, const MnUserParameters&, const MnUserCovariance&, const MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum Minimize(const FCNGradientBase&, const MnUserParameters&, const MnUserCovariance&, const MnStra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html:4474,toler,toler,4474,root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,4,['toler'],['toler']
Availability,"01); virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSVDUnfold.html:1641,error,error,1641,root/html528/TSVDUnfold.html,https://root.cern,https://root.cern/root/html528/TSVDUnfold.html,2,['error'],['error']
Availability,"01); virtual~TGeoOverlap(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidBrowse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tCompare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Int_tTAttLine::DistancetoLine(Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2); virtual Int_tDistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoOverlap.html:1649,Error,Error,1649,root/html532/TGeoOverlap.html,https://root.cern,https://root.cern/root/html532/TGeoOverlap.html,2,['Error'],['Error']
Availability,"01);  Return nth moment of function between a and b. ;  ; template<class T > ; T operator() (const T *x, const Double_t *params=nullptr);  ; virtual Double_t operator() (Double_t x, Double_t y=0, Double_t z=0, Double_t t=0) const;  ; TF1 & operator= (const TF1 &rhs);  Operator =. ;  ; void Paint (Option_t *option="""") override;  Paint this function with its current attributes. ;  ; void Print (Option_t *option="""") const override;  This method must be overridden when a class wants to print itself. ;  ; virtual void ReleaseParameter (Int_t ipar);  Release parameter number ipar during a fit operation. ;  ; virtual void Save (Double_t xmin, Double_t xmax, Double_t ymin, Double_t ymax, Double_t zmin, Double_t zmax);  Save values of function in array fSave. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; virtual void SetChisquare (Double_t chi2);  ; virtual void SetFitResult (const ROOT::Fit::FitResult &result, const Int_t *indpar=nullptr);  Set the result from the fit parameter values, errors, chi2, etc... Optionally a pointer to a vector (with size fNpar) of the parameter indices in the FitResult can be passed This is useful in the case of a combined fit with different functions, and the FitResult contains the global result By default it is assume that indpar = {0,1,2,....,fNpar-1}. ;  ; template<typename Func > ; void SetFunction (Func f);  ; template<class PtrObj , typename MemFn > ; void SetFunction (PtrObj &p, MemFn memFn);  ; virtual void SetMaximum (Double_t maximum=-1111);  Set the maximum value along Y for this function In case the function is already drawn, set also the maximum in the helper histogram. ;  ; virtual void SetMinimum (Double_t minimum=-1111);  Set the minimum value along Y for this function In case the function is already drawn, set also the minimum in the helper histogram. ;  ; virtual void SetNDF (Int_t ndf);  Set the number of degrees of freedom ndf shoul",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF1.html:25471,error,errors,25471,doc/master/classTF1.html,https://root.cern,https://root.cern/doc/master/classTF1.html,1,['error'],['errors']
Availability,"01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TProofServLogHandler (const char *cmd, TSocket *s, const char *pfx="""");  Execute 'cmd' in a pipe and handle output messages from the related file. ;  ;  TProofServLogHandler (FILE *f, TSocket *s, const char *pfx="""");  Handle available message from the open file 'f'. ;  ;  ~TProofServLogHandler () override;  Handle available message in the open file. ;  ; Bool_t IsValid ();  ; Bool_t Notify () override;  Handle available message in the open file. ;  ; Bool_t ReadNotify () override;  Notify when something can be read from the descriptor associated with this handler. ;  ;  Public Member Functions inherited from TFileHandler;  TFileHandler (int fd, int mask);  Create a file descriptor event handler. ;  ; virtual ~TFileHandler ();  ; void Add () override;  Add file event handler to system file handler list. ;  ; int GetFd () const;  ; virtual Bool_t HasReadInterest ();  True if handler is interested in read events. ;  ; virtual Bool_t HasWriteInterest ();  True if handler is interested in write events. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsReadReady () const;  ; virtual Bool_t IsWriteReady () const;  ; void Remove () override;  Remove file event handler from system file handler list. ;  ; virtual void ResetReadyMask ();  ; void SetFd (int fd);  ; virtual void SetInterest (Int_t mask);  Set interest mask to 'mask'. ;  ; virtual void SetReadReady ();  ; virtual void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServLogHandler.html:1617,avail,available,1617,doc/master/classTProofServLogHandler.html,https://root.cern,https://root.cern/doc/master/classTProofServLogHandler.html,1,['avail'],['available']
Availability,"0130 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20131 mg_free(ctx->worker_threadids);; 20132 ; 20133 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20134 mg_snprintf(NULL,; 20135 NULL, /* No truncation check for error buffers */; 20136 error->text,; 20137 error->text_buffer_size,; 20138 ""%s"",; 20139 err_msg);; 20140 }; 20141 free_context(ctx);; 20142 pthread_setspecific(sTlsKey, NULL);; 20143 return NULL;; 20144 }; 20145 ; 20146 ctx->client_socks =; 20147 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20148 sizeof(ctx->client_socks[0]),; 20149 ctx);; 20150 if (ctx->client_socks == NULL) {; 20151 const char *err_msg = ""Not enough memory for worker socket array"";; 20152 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20153 mg_free(ctx->client_wait_events);; 20154 mg_free(ctx->worker_threadids);; 20155 ; 20156 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20157 mg_snprintf(NULL,; 20158 NULL, /* No truncation check for error buffers */; 20159 error->text,; 20160 error->text_buffer_size,; 20161 ""%s"",; 20162 err_msg);; 20163 }; 20164 free_context(ctx);; 20165 pthread_setspecific(sTlsKey, NULL);; 20166 return NULL;; 20167 }; 20168 ; 20169 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20170 ctx->client_wait_events[i] = event_create();; 20171 if (ctx->client_wait_events[i] == 0) {; 20172 const char *err_msg = ""Error creating worker event %i"";; 20173 mg_cry_ctx_internal(ctx, err_msg, i);; 20174 while (i > 0) {; 20175 i--;; 20176 event_destroy(ctx->client_wait_events[i]);; 20177 }; 20178 mg_free(ctx->client_socks);; 20179 mg_free(ctx->client_wait_events);; 20180 mg_free(ctx->worker_threadids);; 20181 ; 20182 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20183 mg_snprintf(NULL,; 20184 NULL, /* No truncation check for error buffers */; 20185 error->text,; 20186 error->text_buffer_size,; 20187 err_msg,; 20188 i);; 20189 }; 20190 free_context(ctx);; 20191 pthread_setspecific(sTlsKey, NULL);; 20192 return NULL;; 20193 }; 20194 }; 2019",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:602662,error,error,602662,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_setspecific(sTlsKey, NULL);; 20144 return NULL;; 20145 }; 20146 ; 20147 ctx->client_socks =; 20148 (struct socket *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20149 sizeof(ctx->client_socks[0]),; 20150 ctx);; 20151 if (ctx->client_socks == NULL) {; 20152 const char *err_msg = ""Not enough memory for worker socket array"";; 20153 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20154 mg_free(ctx->client_wait_events);; 20155 mg_free(ctx->worker_threadids);; 20156 ; 20157 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20158 mg_snprintf(NULL,; 20159 NULL, /* No truncation check for error buffers */; 20160 error->text,; 20161 error->text_buffer_size,; 20162 ""%s"",; 20163 err_msg);; 20164 }; 20165 free_context(ctx);; 20166 pthread_setspecific(sTlsKey, NULL);; 20167 return NULL;; 20168 }; 20169 ; 20170 for (i = 0; (unsigned)i < ctx->cfg_worker_threads; i++) {; 20171 ctx->client_wait_events[i] = event_create();; 20172 if (ctx->client_wait_events[i] == 0) {; 20173 const char *err_msg = ""Error creating worker event %i"";; 20174 mg_cry_ctx_internal(ctx, err_msg, i);; 20175 while (i > 0) {; 20176 i--;; 20177 event_destroy(ctx->client_wait_events[i]);; 20178 }; 20179 mg_free(ctx->client_socks);; 20180 mg_free(ctx->client_wait_events);; 20181 mg_free(ctx->worker_threadids);; 20182 ; 20183 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20184 mg_snprintf(NULL,; 20185 NULL, /* No truncation check for error buffers */; 20186 error->text,; 20187 error->text_buffer_size,; 20188 err_msg,; 20189 i);; 20190 }; 20191 free_context(ctx);; 20192 pthread_setspecific(sTlsKey, NULL);; 20193 return NULL;; 20194 }; 20195 }; 2019",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:602695,error,error,602695,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,017578 43434.8 2; : 987 | 3.50466 4.60061 0.0201538 0.00175522 43481.6 3; : 988 | 3.61316 4.68965 0.0201071 0.00176 43603.6 4; : 989 | 3.88349 5.24185 0.0200475 0.00175499 43733.8 5; : 990 | 4.0647 4.52576 0.020036 0.00175545 43762.3 6; : 991 | 3.77396 5.32769 0.0200783 0.00175786 43667.1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0.0203306 0.00176616 43093.1 13; : 998 | 3.41797 4.46788 0.0203618 0.00175568 42996.7 14; : 999 Minimum Test error found - save the configuration ; : 999 | 3.31412 4.14973 0.0202938 0.00187677 43438 0; : 1000 | 3.20867 4.17264 0.0201802 0.00179416 43511.4 1; : 1001 | 3.31742 4.17699 0.020287 0.00175118 43159.8 2; : 1002 | 3.35839 4.8143 0.0207434 0.00177731 42180.6 3; : 1003 Minimum Test error found - save the configuration ; : 1003 | 3.42381 4.04915 0.0202591 0.00184351 43441.4 0; : 1004 Minimum Test error found - save the configuration ; : 1004 | 3.27488 4.0384 0.0205262 0.00189376 42935.9 0; : 1005 | 3.09776 4.19224 0.0200956 0.00176781 43649.6 1; : 1006 Minimum Test error found - save the configuration ; : 1006 | 3.1757 3.91876 0.0201134 0.00183093 43757.7 0; : 1007 | 3.17471 4.33126 0.0203423 0.00178093 43100.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:113313,error,error,113313,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9.34508 0.0201279 0.00182025 43697.5 0; : 865 | 6.18959 10.0219 0.0205128 0.00175205 42642.3 1; : 866 Minimum Test error found - save the configuration ; : 866 | 6.05678 9.24173 0.0204648 0.00182051 42908.5 0; : 867 | 5.92011 9.34278 0.0202303 0.00193747 43733 1; : 868 Minimum Test error found - save the configuration ; : 868 | 5.90509 9.03441 0.0202616 0.0019877 43778.3 0; : 869 | 5.98345 9.15873 0.0200325 0.00175472 43768.9 1; : 870 | 5.90893 9.16507 0.0202516 0.00176171 43266.9 2; : 871 Minimum Test error found - save the configuration ; : 871 | 5.78015 8.79318 0.0200883 0.00182097 43794.1 0; : 872 | 5.76603 9.46642 0.0200354 0.00176138 43778.1 1; : 873 Minimum Test error found - save the configuration ; : 873 | 5.70638 8.71803 0.0200731 0.00181478 43815.7 0; : 874 Minimum Test error found - save the configuration ; : 874 | 5.53455 8.53383 0.0201925 0.00181685 43535.8 0; : 875 | 5.74708 8.69754 0.0202376 0.00177647 43334.2 1; : 876 | 5.6794 9.00589 0.0202045 0.00176006 43373.5 2; : 877 | 5.64383 8.64736 0.0203248 0.00179972 43184.7 3; : 878 Minimum Test error found - save the configuration ; : 878 | 5.55379 8.16524 0.0206602 0.00187795 42593.5 0; : 879 | 5.63754 8.31065 0.0203728 0.00175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:103569,error,error,103569,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"019 ; 1020An example of transparency usage with parallel coordinates can be found; 1021in parallelcoordtrans.C.; 1022 ; 1023To ease the creation of a transparent color the static method; 1024`GetColorTransparent(Int_t color, Float_t a)` is provided.; 1025In the following example the `trans_red` color index point to; 1026a red color 30% opaque (70% transparent). The alpha value of; 1027the color index `kRed` is not modified.; 1028 ; 1029~~~ {.cpp}; 1030 Int_t trans_red = GetColorTransparent(kRed, 0.3);; 1031~~~; 1032 ; 1033This function is also used in the methods; 1034`SetFillColorAlpha()`, `SetLineColorAlpha()`,; 1035`SetMarkerColorAlpha()` and `SetTextColorAlpha()`.; 1036In the following example the fill color of the histogram `histo`; 1037is set to blue with an opacity of 35% (i.e. a transparency of 65%).; 1038(The color `kBlue` itself is internally stored as fully opaque.); 1039 ; 1040~~~ {.cpp}; 1041 histo->SetFillColorAlpha(kBlue, 0.35);; 1042~~~; 1043 ; 1044The transparency is available on all platforms when the flag `OpenGL.CanvasPreferGL` is set to `1`; 1045in `$ROOTSYS/etc/system.rootrc`, or on Mac with the Cocoa backend. On the file output; 1046it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; 1047 ; 1048Alternatively, you can call at the top of your script `gSytle->SetCanvasPreferGL();`.; 1049Or if you prefer to activate GL for a single canvas `c`, then use `c->SetSupportGL(true);`.; 1050 ; 1051The following macro gives an example of transparency usage:; 1052 ; 1053Begin_Macro(source); 1054../../../tutorials/graphics/transparency.C; 1055End_Macro; 1056 ; 1057*/; 1058 ; 1059////////////////////////////////////////////////////////////////////////////////; 1060/// Default constructor.; 1061 ; 1062TColor::TColor(): TNamed(); 1063{; 1064 fNumber = -1;; 1065 fRed = fGreen = fBlue = fHue = fLight = fSaturation = -1;; 1066 fAlpha = 1;; 1067}; 1068 ; 1069////////////////////////////////////////////////////////////////////////////////; 1070/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:37199,avail,available,37199,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['avail'],['available']
Availability,"01998 0.192893 0.0153949 14422.7 2; : 6 | 0.6867 0.696275 0.191869 0.0152227 14492.2 3; : 7 Minimum Test error found - save the configuration ; : 7 | 0.692231 0.691692 0.197632 0.0164904 14132.6 0; : 8 | 0.683383 0.694963 0.194299 0.0156318 14328.3 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.682898 0.684979 0.192122 0.0157399 14513.9 0; : 10 | 0.670592 0.688549 0.192796 0.0152906 14422.1 1; : 11 Minimum Test error found - save the configuration ; : 11 | 0.670202 0.684295 0.191832 0.0154715 14515.7 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.675447 0.682107 0.194058 0.0158608 14366.1 0; : 13 | 0.678105 0.691356 0.193716 0.0152633 14345.5 1; : 14 | 0.684972 0.687408 0.191852 0.0154194 14509.8 2; : 15 | 0.676423 0.689156 0.193176 0.0153404 14395.3 3; : 16 | 0.683185 0.689966 0.191807 0.0149908 14478.3 4; : 17 | 0.672717 0.689982 0.192316 0.0149466 14433.2 5; : 18 | 0.670449 0.68412 0.190877 0.0151753 14570.1 6; : 19 Minimum Test error found - save the configuration ; : 19 | 0.661329 0.670317 0.192098 0.0154074 14488.6 0; : 20 Minimum Test error found - save the configuration ; : 20 | 0.658253 0.661402 0.192014 0.0155677 14508.7 0; : ; : Elapsed time for training with 3200 events: 3.87 sec ; : Evaluate deep neural network on CPU using batches with size = 256; : ; TMVA_DNN : [dataset] : Evaluation of TMVA_DNN on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.102 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_DNN.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: PyKeras_LSTM for Classification; : ; : Split TMVA training data in 2560 training events and 640 validation events; : Training Model Summary; Model: ""sequential""; _________________________________________________________________; Layer (type) Output Shape Param # ; ========================",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:20419,error,error,20419,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"019{; 2020 if (e == -1); 2021 taf->TAttFill::Copy(*this);; 2022 else if (e >= 0 && e < fNYErrors); 2023 taf->TAttFill::Copy(fAttFill[e]);; 2024}; 2025 ; 2026////////////////////////////////////////////////////////////////////////////////; 2027/// Set TAttLine parameters of error e by copying from another TAttLine (-1 = Global and x errors).; 2028 ; 2029void TGraphMultiErrors::SetAttLine(Int_t e, TAttLine *taf); 2030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLine",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:68963,error,error,68963,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"022void TH1::Sumw2(Bool_t flag); 9023{; 9024 if (!flag) {; 9025 // clear the array if existing - do nothing otherwise; 9026 if (fSumw2.fN > 0 ) fSumw2.Set(0);; 9027 return;; 9028 }; 9029 ; 9030 if (fSumw2.fN == fNcells) {; 9031 if (!fgDefaultSumw2 ); 9032 Warning(""Sumw2"",""Sum of squares of weights structure already created"");; 9033 return;; 9034 }; 9035 ; 9036 fSumw2.Set(fNcells);; 9037 ; 9038 // empty the buffer; 9039 if (fBuffer) BufferEmpty();; 9040 ; 9041 if (fEntries > 0); 9042 for (Int_t i = 0; i < fNcells; ++i); 9043 fSumw2.fArray[i] = TMath::Abs(RetrieveBinContent(i));; 9044}; 9045 ; 9046////////////////////////////////////////////////////////////////////////////////; 9047/// Return pointer to function with name.; 9048///; 9049///; 9050/// Functions such as TH1::Fit store the fitted function in the list of; 9051/// functions of this histogram.; 9052 ; 9053TF1 *TH1::GetFunction(const char *name) const; 9054{; 9055 return (TF1*)fFunctions->FindObject(name);; 9056}; 9057 ; 9058////////////////////////////////////////////////////////////////////////////////; 9059/// Return value of error associated to bin number bin.; 9060///; 9061/// if the sum of squares of weights has been defined (via Sumw2),; 9062/// this function returns the sqrt(sum of w2).; 9063/// otherwise it returns the sqrt(contents) for this bin.; 9064 ; 9065Double_t TH1::GetBinError(Int_t bin) const; 9066{; 9067 if (bin < 0) bin = 0;; 9068 if (bin >= fNcells) bin = fNcells-1;; 9069 if (fBuffer) ((TH1*)this)->BufferEmpty();; 9070 if (fSumw2.fN) return TMath::Sqrt(fSumw2.fArray[bin]);; 9071 ; 9072 return TMath::Sqrt(TMath::Abs(RetrieveBinContent(bin)));; 9073}; 9074 ; 9075////////////////////////////////////////////////////////////////////////////////; 9076/// Return lower error associated to bin number bin.; 9077///; 9078/// The error will depend on the statistic option used will return; 9079/// the binContent - lower interval value; 9080 ; 9081Double_t TH1::GetBinErrorLow(Int_t bin) const; 9082{; 90",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:353189,error,error,353189,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,02416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test error found - save the configuration ; : 959 | 3.68258 5.15386 0.0202548 0.00182461 43407 0; : 960 Minimum Test error found - save the configuration ; : 960 | 3.74165 4.97436 0.0200851 0.00180832 43771.4 0; : 961 | 3.60053 5.18492 0.0200347 0.00175376 43761.4 1; : 962 | 4.06747 4.98756 0.0202606 0.00194113 43669.3 2; : 963 | 3.72111 5.2317 0.020058 0.00176556 43733.9 3; : 964 | 3.60317 5.20936 0.020113 0.00175786 43584.5 4; : 965 | 3.63413 5.37485 0.0201057 0.00175921 43605 5; : 966 | 3.74764 5.16986 0.0200985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.65912 0.0202218 0.00185299 43552 0; : 976 | 3.7346 5.23443 0.0200603 0.00176255 43721.2 1; : 977 | 3.73856 4.9727 0.0200443 0.00176151 43757 2; : 978 | 3.60727 4.99113 0.0200479 0.00175633 43736 3; : 979 | 3.40672 4.84357 0.0200357 0.00175685 43766.5 4; : 980 | 3.44899 4.83288 0.0200548 0.0017499 43704.2 5; : 981 | 3.46445 4.72048 0.0203135 0.00176046 43119.7 6; : 982 Minimum Test error found - save the configuration ; : 982 | 3.46604 4.64127 0.0202116 0.00183381 43530.8 0; : 983 Minimum Test error foun,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:111021,error,error,111021,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"030{; 2031 if (e == -1); 2032 taf->TAttLine::Copy(*this);; 2033 else if (e >= 0 && e < fNYErrors); 2034 taf->TAttLine::Copy(fAttLine[e]);; 2035}; 2036 ; 2037////////////////////////////////////////////////////////////////////////////////; 2038/// Set Fill Color of error e (-1 = Global and x errors).; 2039 ; 2040void TGraphMultiErrors::SetFillColor(Int_t e, Color_t fcolor); 2041{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcol",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69381,error,error,69381,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"0316 ; 20317 if ((ctx == NULL) || (options == NULL)) {; 20318 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20319 mg_snprintf(NULL,; 20320 NULL, /* No truncation check for error buffers */; 20321 error->text,; 20322 error->text_buffer_size,; 20323 ""%s"",; 20324 ""Invalid parameters"");; 20325 }; 20326 return -1;; 20327 }; 20328 ; 20329 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20330 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20331 mg_snprintf(NULL,; 20332 NULL, /* No truncation check for error buffers */; 20333 error->text,; 20334 error->text_buffer_size,; 20335 ""%s"",; 20336 ""Server already stopped"");; 20337 }; 20338 return -1;; 20339 }; 20340 ; 20341 new_dom = (struct mg_domain_context *); 20342 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20343 ; 20344 if (!new_dom) {; 20345 /* Out of memory */; 20346 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20347 mg_snprintf(NULL,; 20348 NULL, /* No truncation check for error buffers */; 20349 error->text,; 20350 error->text_buffer_size,; 20351 ""%s"",; 20352 ""Out or memory"");; 20353 }; 20354 return -6;; 20355 }; 20356 ; 20357 /* Store options - TODO: unite duplicate code */; 20358 while (options && (name = *options++) != NULL) {; 20359 if ((idx = get_option_index(name)) == -1) {; 20360 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20361 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20362 mg_snprintf(NULL,; 20363 NULL, /* No truncation check for error buffers */; 20364 error->text,; 20365 error->text_buffer_size,; 20366 ""Invalid option: %s"",; 20367 name);; 20368 }; 20369 mg_free(new_dom);; 20370 return -2;; 20371 } else if ((value = *options++) == NULL) {; 20372 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20373 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20374 mg_snprintf(NULL,; 20375 NULL, /* No truncation check for error buffers */; 20376 error->text,; 20377 error->text_buffer_size,; 20378 ""Invalid option value: %s"",; 203",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:608253,error,error,608253,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0317 ; 20318 if ((ctx == NULL) || (options == NULL)) {; 20319 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20320 mg_snprintf(NULL,; 20321 NULL, /* No truncation check for error buffers */; 20322 error->text,; 20323 error->text_buffer_size,; 20324 ""%s"",; 20325 ""Invalid parameters"");; 20326 }; 20327 return -1;; 20328 }; 20329 ; 20330 if (!STOP_FLAG_IS_ZERO(&ctx->stop_flag)) {; 20331 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20332 mg_snprintf(NULL,; 20333 NULL, /* No truncation check for error buffers */; 20334 error->text,; 20335 error->text_buffer_size,; 20336 ""%s"",; 20337 ""Server already stopped"");; 20338 }; 20339 return -1;; 20340 }; 20341 ; 20342 new_dom = (struct mg_domain_context *); 20343 mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);; 20344 ; 20345 if (!new_dom) {; 20346 /* Out of memory */; 20347 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20348 mg_snprintf(NULL,; 20349 NULL, /* No truncation check for error buffers */; 20350 error->text,; 20351 error->text_buffer_size,; 20352 ""%s"",; 20353 ""Out or memory"");; 20354 }; 20355 return -6;; 20356 }; 20357 ; 20358 /* Store options - TODO: unite duplicate code */; 20359 while (options && (name = *options++) != NULL) {; 20360 if ((idx = get_option_index(name)) == -1) {; 20361 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 20362 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20363 mg_snprintf(NULL,; 20364 NULL, /* No truncation check for error buffers */; 20365 error->text,; 20366 error->text_buffer_size,; 20367 ""Invalid option: %s"",; 20368 name);; 20369 }; 20370 mg_free(new_dom);; 20371 return -2;; 20372 } else if ((value = *options++) == NULL) {; 20373 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 20374 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20375 mg_snprintf(NULL,; 20376 NULL, /* No truncation check for error buffers */; 20377 error->text,; 20378 error->text_buffer_size,; 20379 ""Invalid option value: %s"",; 203",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:608286,error,error,608286,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"039through filters, defines and actions, and RDataFrame will take these dependencies into account when producing varied; 1040results. \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" is included in header `ROOT/RDFHelpers.hxx`. The compiled C++ programs must include this header; 1041explicitly, this is not required for ROOT macros. ; 1042 ; 1043An example usage of Vary() and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in C++:; 1044 ; 1045~~~{.cpp}; 1046auto nominal_hx =; 1047 df.Vary(""pt"", ""ROOT::RVecD{pt*0.9f, pt*1.1f}"", {""down"", ""up""}); 1048 .Filter(""pt > pt_cut""); 1049 .Define(""x"", someFunc, {""pt""}); 1050 .Histo1D<float>(""x"");; 1051 ; 1052// request the generation of varied results from the nominal_hx; 1053ROOT::RDF::Experimental::RResultMap<TH1D> hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1054 ; 1055// the event loop runs here, upon first access to any of the results or varied results:; 1056hx[""nominal""].Draw(); // same effect as nominal_hx->Draw(); 1057hx[""pt:down""].Draw(""SAME"");; 1058hx[""pt:up""].Draw(""SAME"");; 1059~~~; 1060 ; 1061A list of variation ""tags"" is passed as the last argument to Vary(). The tags give names to the varied values that are returned; 1062as elements of an RVec of the appropriate C++ type. The number of variation tags must correspond to the number of elements of; 1063this RVec (2 in the example above: the first element will correspond to the tag ""down"", the second; 1064to the tag ""up""). The _full_ variation name will be composed of the varied column name and the variation tags (e.g.; 1065""pt:down"", ""pt:up"" in this example). Python usage looks similar.; 1066 ; 1067Note how we use the ""pt"" column as usual in the Filter() and Define() calls and we simply use ""x"" as the value to fill; 1068the resulting histogram. To produce the varied results, RDataFrame will automatically execute the Filter and Define; 1069calls for each variation and fill the histogram with values and cuts that depend on the var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:61467,down,down,61467,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['down'],['down']
Availability,"04 leaf->SetName(branchname);; 605 leaf->SetTitle(branchname);; 606 leaf->SetRange(true);; 607 // Create sub branches for each data member of an STL container.; 608 Unroll(name, valueClass, valueClass, pointer, basketsize, splitlevel+splitSTLP, 41);; 609 BuildTitle(name);; 610 SetReadLeavesPtr();; 611 SetFillLeavesPtr();; 612 return;; 613 }; 614 } else if (!strchr(elemType, '*') && ((fStreamerType == TVirtualStreamerInfo::kObject) || (fStreamerType == TVirtualStreamerInfo::kAny))) {; 615 // -- Create sub-branches for members that are classes.; 616 //; 617 // Note: This can only happen if we were called directly; 618 // (usually by TClass::Bronch) because Unroll never; 619 // calls us for an element of this type.; 620 fType = 2;; 621 TClass* clm = elementClass;; 622 Int_t err = Unroll(name, clm, clm, pointer, basketsize, splitlevel+splitSTLP, 0);; 623 if (err >= 0) {; 624 // Return on success.; 625 // FIXME: Why not on error too?; 626 SetReadLeavesPtr();; 627 SetFillLeavesPtr();; 628 return;; 629 }; 630 }; 631 }; 632 }; 633 ; 634 //; 635 // Create a leaf to represent this branch.; 636 //; 637 ; 638 TLeaf* leaf = new TLeafElement(this, GetTitle(), fID, fStreamerType);; 639 leaf->SetTitle(GetTitle());; 640 fNleaves = 1;; 641 fLeaves.Add(leaf);; 642 fTree->GetListOfLeaves()->Add(leaf);; 643 ; 644 //; 645 // If we have a counter branch set it now that we have; 646 // created our leaf, we cannot do it before then.; 647 //; 648 ; 649 if (brOfCounter) {; 650 SetBranchCount(brOfCounter);; 651 }; 652 ; 653 SetReadLeavesPtr();; 654 SetFillLeavesPtr();; 655}; 656 ; 657////////////////////////////////////////////////////////////////////////////////; 658/// Constructor when the branch object is a TClonesArray.; 659///; 660/// If splitlevel > 0 this branch in turn is split into sub branches.; 661 ; 662TBranchElement::TBranchElement(TTree *tree, const char* bname, TClonesArray* clones, Int_t basketsize, Int_t splitlevel, Int_t compress); 663: TBranch(); 664, fClassName(""TClonesArra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:22936,error,error,22936,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['error'],['error']
Availability,"0406e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 4.2647e-01 +/- 7.59e-02; a1 1.7594e-01 +/- 1.10e-01; nbkg 5.1101e+02 +/- 3.60e+01; nsig 4.8899e+02 +/- 3.57e+01; sig1frac 8.6392e-01 +/- 1.08e-01; ; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'right' created with bounds [6,10]; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_left' created with bounds [0,4]; [#1] INFO:Eval -- RooRealVar::setRange(x) new range named 'fit_nll_model_modelData_right' created with bounds [6,10]; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: -1134.15, estimated distance to minimum: 3.61209e-05; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 3.2415e-01 +/- 1.09e-01; a1 3.0373e-02 +/- 2.12e-01; nbkg 5.0182e+02 +/- 3.94e+01; nsig 4.1091e+02 +/- 2.63e+02; sig1frac 8.5838e-01 +/- 2.74e-01; ; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) p.d.f was fitted in a subrange and no explicit Range() and NormRange() was specified. Plotting / normalising in fit range. To override, do one of the following; - Clear the automatic fit range attribute: <pdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html:8815,error,error,8815,doc/master/rf204a__extendedLikelihood_8C.html,https://root.cern,https://root.cern/doc/master/rf204a__extendedLikelihood_8C.html,2,['error'],['error']
Availability,"05 // compute size of the lines at the end of the error bars; 6406 Int_t dxend = Int_t(gStyle->GetEndErrorSize());; 6407 bxsize = gPad->PixeltoX(dxend) - gPad->PixeltoX(0);; 6408 bysize =-gPad->PixeltoY(dxend) + gPad->PixeltoY(0);; 6409 ; 6410 ; 6411 if (fixbin) {; 6412 if (Hoption.Logx) xp = TMath::Power(10,Hparam.xmin) + 0.5*Hparam.xbinsize;; 6413 else xp = Hparam.xmin + 0.5*Hparam.xbinsize;; 6414 } else {; 6415 delta = fH->GetBinWidth(first);; 6416 xp = fH->GetBinLowEdge(first) + 0.5*delta;; 6417 }; 6418 ; 6419 // if errormarker = 0 or symbolsize = 0. no symbol is drawn; 6420 if (Hoption.Logx) logxmin = TMath::Power(10,Hparam.xmin);; 6421 if (Hoption.Logy) logymin = TMath::Power(10,Hparam.ymin);; 6422 ; 6423 // ---------------------- Loop over the points---------------------; 6424 for (k=first; k<=last; k++) {; 6425 ; 6426 // get the data; 6427 // xp = X position of the current point; 6428 // yp = Y position of the current point; 6429 // ex1 = Low X error; 6430 // ex2 = Up X error; 6431 // ey1 = Low Y error; 6432 // ey2 = Up Y error; 6433 // (xi,yi) = Error bars coordinates; 6434 ; 6435 // apply offset on errors for bar histograms; 6436 Double_t xminTmp = gPad->XtoPad(fXaxis->GetBinLowEdge(k));; 6437 Double_t xmaxTmp = gPad->XtoPad(fXaxis->GetBinUpEdge(k));; 6438 if (Hoption.Logx) {; 6439 xminTmp = TMath::Power(10, xminTmp);; 6440 xmaxTmp = TMath::Power(10, xmaxTmp);; 6441 }; 6442 Double_t w = (xmaxTmp-xminTmp)*width;; 6443 xminTmp += offset*(xmaxTmp-xminTmp);; 6444 xmaxTmp = xminTmp + w;; 6445 xp = (xminTmp+xmaxTmp)/2.;; 6446 ; 6447 if (Hoption.Logx) {; 6448 if (xp <= 0) goto L30;; 6449 if (xp < logxmin) goto L30;; 6450 if (xp > TMath::Power(10,xmax)) break;; 6451 } else {; 6452 if (xp < xmin) goto L30;; 6453 if (xp > xmax) break;; 6454 }; 6455 yp = factor*fH->GetBinContent(k);; 6456 if (optionI0 && yp==0) goto L30;; 6457 if (fixbin) {; 6458 ex1 = xerror*Hparam.xbinsize;; 6459 } else {; 6460 delta = fH->GetBinWidth(k);; 6461 ex1 = xerror*delta;; 6462 }; 6463 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:236449,error,error,236449,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,5,['error'],"['error', 'errors']"
Availability,05 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Minimum Test error found - save the configuration ; : 666 | 51.2956 40.6256 0.0201396 0.00182896 43690.5 0; : 667 Mi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:85024,error,error,85024,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"051 ; 1052The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"".; 1053 ; 1054#### Combining multiple variations; 1055 ; 1056Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; 1057by applying multiple systematic variations at the same time.; 1058For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1059""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1060 ; 1061~~~{.cpp}; 1062auto df = _df.Vary(""pt"",; 1063 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1064 {""down"", ""up""}); 1065 .Vary(""eta"",; 1066 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1067 {""eta""},; 1068 2);; 1069 ; 1070auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1071auto all_hs = VariationsFor(nom_h);; 1072all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1073~~~; 1074 ; 1075Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1076shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1077 ; 1078\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1079 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1080 programming model will be streamlined in future versions.; 1081 ; 1082\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1083 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1084 ; 1085See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1086for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1087 ; 1088\anchor rno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:62839,down,down,62839,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['down'],['down']
Availability,"057 static UserInfoCache_t gUserInfo;; 2058 ; 2059 UserInfoCache_t::const_iterator iUserInfo = gUserInfo.find(uid);; 2060 if (iUserInfo != gUserInfo.end()); 2061 return new UserGroup_t(iUserInfo->second);; 2062 ; 2063 struct passwd *apwd = getpwuid(uid);; 2064 if (apwd) {; 2065 UserGroup_t *ug = new UserGroup_t;; 2066 ug->fUid = apwd->pw_uid;; 2067 ug->fGid = apwd->pw_gid;; 2068 ug->fUser = apwd->pw_name;; 2069 ug->fPasswd = apwd->pw_passwd;; 2070 ug->fRealName = apwd->pw_gecos;; 2071 ug->fShell = apwd->pw_shell;; 2072 UserGroup_t *gr = GetGroupInfo(apwd->pw_gid);; 2073 if (gr) ug->fGroup = gr->fGroup;; 2074 delete gr;; 2075 ; 2076 gUserInfo[uid] = *ug;; 2077 return ug;; 2078 }; 2079 return nullptr;; 2080}; 2081 ; 2082////////////////////////////////////////////////////////////////////////////////; 2083/// Returns all user info in the UserGroup_t structure. If user = 0, returns; 2084/// current user's id info. The returned structure must be deleted by the; 2085/// user. In case of error 0 is returned.; 2086 ; 2087UserGroup_t *TUnixSystem::GetUserInfo(const char *user); 2088{; 2089 return GetUserInfo(GetUid(user));; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Returns all group info in the UserGroup_t structure. The only active; 2094/// fields in the UserGroup_t structure for this call are:; 2095/// fGid and fGroup; 2096/// The returned structure must be deleted by the user. In case of; 2097/// error 0 is returned.; 2098 ; 2099UserGroup_t *TUnixSystem::GetGroupInfo(Int_t gid); 2100{; 2101 struct group *grp = getgrgid(gid);; 2102 if (grp) {; 2103 UserGroup_t *gr = new UserGroup_t;; 2104 gr->fUid = 0;; 2105 gr->fGid = grp->gr_gid;; 2106 gr->fGroup = grp->gr_name;; 2107 return gr;; 2108 }; 2109 return nullptr;; 2110}; 2111 ; 2112////////////////////////////////////////////////////////////////////////////////; 2113/// Returns all group info in the UserGroup_t structure. The only active; 2114/// fields in the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:64277,error,error,64277,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"06 ; 21107 ; 21108void; 21109mg_disable_connection_keep_alive(struct mg_connection *conn); 21110{; 21111 /* https://github.com/civetweb/civetweb/issues/727 */; 21112 if (conn != NULL) {; 21113 conn->must_close = 1;; 21114 }; 21115}; 21116 ; 21117 ; 21118#if defined(MG_EXPERIMENTAL_INTERFACES); 21119/* Get connection information. It can be printed or stored by the caller.; 21120 * Return the size of available information. */; 21121int; 21122mg_get_connection_info(const struct mg_context *ctx,; 21123 int idx,; 21124 char *buffer,; 21125 int buflen); 21126{; 21127 const struct mg_connection *conn;; 21128 const struct mg_request_info *ri;; 21129 char *end, *append_eoobj = NULL, block[256];; 21130 size_t connection_info_length = 0;; 21131 int state = 0;; 21132 const char *state_str = ""unknown"";; 21133 ; 21134#if defined(_WIN32); 21135 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21136#else; 21137 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21138#endif; 21139 ; 21140 if ((buffer == NULL) || (buflen < 1)) {; 21141 buflen = 0;; 21142 end = buffer;; 21143 } else {; 21144 *buffer = 0;; 21145 end = buffer + buflen;; 21146 }; 21147 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21148 /* has enough space to append eoobj */; 21149 append_eoobj = buffer;; 21150 end -= sizeof(eoobj) - 1;; 21151 }; 21152 ; 21153 if ((ctx == NULL) || (idx < 0)) {; 21154 /* Parameter error */; 21155 return 0;; 21156 }; 21157 ; 21158 if ((unsigned)idx >= ctx->cfg_worker_threads) {; 21159 /* Out of range */; 21160 return 0;; 21161 }; 21162 ; 21163 /* Take connection [idx]. This connection is not locked in; 21164 * any way, so some other thread might use it. */; 21165 conn = (ctx->worker_connections) + idx;; 21166 ; 21167 /* Initialize output string */; 21168 connection_info_length += mg_str_append(&buffer, end, ""{"");; 21169 ; 21170 /* Init variables */; 21171 ri = &(conn->request_info);; 21172 ; 21173#if defined(USE_SERVER_STATS); 21174 state = conn->conn_state;; 21175 ; 21176 /* State as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:631284,error,error,631284,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"06 fColors = new TExMap;; 307 Long64_t key, value;; 308 TExMapIter it(org.fColors);; 309 while (it.Next(key, value)) {; 310 XColor_t *colo = (XColor_t *) (Long_t)value;; 311 XColor_t *col = new XColor_t;; 312 col->fPixel = colo->fPixel;; 313 col->fRed = colo->fRed;; 314 col->fGreen = colo->fGreen;; 315 col->fBlue = colo->fBlue;; 316 col->fDefined = colo->fDefined;; 317 fColors->Add(key, (Long_t) col);; 318 }; 319}; 320 ; 321////////////////////////////////////////////////////////////////////////////////; 322/// Destructor.; 323 ; 324TGX11::~TGX11(); 325{; 326 delete (XEvent*)fXEvent;; 327 if (fWindows) TStorage::Dealloc(fWindows);; 328 ; 329 if (!fColors) return;; 330 Long64_t key, value;; 331 TExMapIter it(fColors);; 332 while (it.Next(key, value)) {; 333 XColor_t *col = (XColor_t *) (Long_t)value;; 334 delete col;; 335 }; 336 delete fColors;; 337}; 338 ; 339////////////////////////////////////////////////////////////////////////////////; 340/// Initialize X11 system. Returns kFALSE in case of failure.; 341 ; 342Bool_t TGX11::Init(void *display); 343{; 344 if (OpenDisplay(display) == -1) return kFALSE;; 345 return kTRUE;; 346}; 347 ; 348////////////////////////////////////////////////////////////////////////////////; 349/// Allocate color in colormap. If we are on an <= 8 plane machine; 350/// we will use XAllocColor. If we are on a >= 15 (15, 16 or 24) plane; 351/// true color machine we will calculate the pixel value using:; 352/// for 15 and 16 bit true colors have 6 bits precision per color however; 353/// only the 5 most significant bits are used in the color index.; 354/// Except for 16 bits where green uses all 6 bits. I.e.:; 355/// ~~~ {.cpp}; 356/// 15 bits = rrrrrgggggbbbbb; 357/// 16 bits = rrrrrggggggbbbbb; 358/// ~~~; 359/// for 24 bits each r, g and b are represented by 8 bits.; 360///; 361/// Since all colors are set with a max of 65535 (16 bits) per r, g, b; 362/// we just right shift them by 10, 11 and 10 bits for 16 planes, and; 363/// (10, 10, 10 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:10643,failure,failure,10643,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['failure'],['failure']
Availability,"065 }; 7066 }; 7067 }; 7068 if (fDimension == 3) {; 7069 for (binz=firstz;binz<=lastz;binz++) {; 7070 z = fZaxis.GetBinCenter(binz);; 7071 for (biny=firsty;biny<=lasty;biny++) {; 7072 y = fYaxis.GetBinCenter(biny);; 7073 for (binx=firstx;binx<=lastx;binx++) {; 7074 bin = GetBin(binx,biny,binz);; 7075 x = fXaxis.GetBinCenter(binx);; 7076 w = RetrieveBinContent(bin);; 7077 e = GetBinError(bin);; 7078 if(fSumw2.fN) printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g, error=%g\n"",binx,biny,binz,w,x,y,z,e);; 7079 else printf("" fSumw[%d][%d][%d]=%g, x=%g, y=%g, z=%g\n"",binx,biny,binz,w,x,y,z);; 7080 }; 7081 }; 7082 }; 7083 }; 7084}; 7085 ; 7086////////////////////////////////////////////////////////////////////////////////; 7087/// Using the current bin info, recompute the arrays for contents and errors; 7088 ; 7089void TH1::Rebuild(Option_t *); 7090{; 7091 SetBinsLength();; 7092 if (fSumw2.fN) {; 7093 fSumw2.Set(fNcells);; 7094 }; 7095}; 7096 ; 7097////////////////////////////////////////////////////////////////////////////////; 7098/// Reset this histogram: contents, errors, etc.; 7099/// \param[in] option; 7100/// - if ""ICE"" is specified, resets only Integral, Contents and Errors.; 7101/// - if ""ICES"" is specified, resets only Integral, Contents, Errors and Statistics; 7102/// This option is used; 7103/// - if ""M"" is specified, resets also Minimum and Maximum; 7104 ; 7105void TH1::Reset(Option_t *option); 7106{; 7107 // The option ""ICE"" is used when extending the histogram (in ExtendAxis, LabelInflate, etc..); 7108 // The option ""ICES is used in combination with the buffer (see BufferEmpty and BufferFill); 7109 ; 7110 TString opt = option;; 7111 opt.ToUpper();; 7112 fSumw2.Reset();; 7113 if (fIntegral) {; 7114 delete [] fIntegral;; 7115 fIntegral = nullptr;; 7116 }; 7117 ; 7118 if (opt.Contains(""M"")) {; 7119 SetMinimum();; 7120 SetMaximum();; 7121 }; 7122 ; 7123 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 7124 ; 7125 // Setting fBuffer[0] = 0 is like resetting t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:277562,error,errors,277562,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"068 for (i = 0; i <= newxbins; ++i) xbins[i] = fXaxis.GetBinLowEdge(1+i*nxgroup);; 3069 Double_t *ybins = new Double_t[newybins+1];; 3070 for (i = 0; i <= newybins; ++i) ybins[i] = fYaxis.GetBinLowEdge(1+i*nygroup);; 3071 Double_t *zbins = new Double_t[newzbins+1];; 3072 for (i = 0; i <= newzbins; ++i) zbins[i] = fZaxis.GetBinLowEdge(1+i*nzgroup);; 3073 hnew->SetBins(newxbins,xbins, newybins, ybins, newzbins, zbins);//changes also errors array (if any); 3074 delete [] xbins;; 3075 delete [] ybins;; 3076 delete [] zbins;; 3077 } else {; 3078 hnew->SetBins(newxbins, xmin, xmax, newybins, ymin, ymax, newzbins, zmin, zmax);//changes also errors array; 3079 }; 3080 ; 3081 Double_t binContent, binSumw2;; 3082 Int_t oldxbin = 1;; 3083 Int_t oldybin = 1;; 3084 Int_t oldzbin = 1;; 3085 Int_t bin;; 3086 for (xbin = 1; xbin <= newxbins; xbin++) {; 3087 oldybin=1;; 3088 oldzbin=1;; 3089 for (ybin = 1; ybin <= newybins; ybin++) {; 3090 oldzbin=1;; 3091 for (zbin = 1; zbin <= newzbins; zbin++) {; 3092 binContent = 0;; 3093 binSumw2 = 0;; 3094 for (i = 0; i < nxgroup; i++) {; 3095 if (oldxbin+i > nxbins) break;; 3096 for (j =0; j < nygroup; j++) {; 3097 if (oldybin+j > nybins) break;; 3098 for (k =0; k < nzgroup; k++) {; 3099 if (oldzbin+k > nzbins) break;; 3100 //get global bin (same conventions as in TH1::GetBin(xbin,ybin); 3101 bin = oldxbin + i + (oldybin + j)*(nxbins + 2) + (oldzbin + k)*(nxbins + 2)*(nybins + 2);; 3102 binContent += oldBins[bin];; 3103 if (oldSumw2) binSumw2 += oldSumw2[bin];; 3104 }; 3105 }; 3106 }; 3107 Int_t ibin = hnew->GetBin(xbin,ybin,zbin); // new bin number; 3108 hnew->SetBinContent(ibin, binContent);; 3109 if (oldSumw2) hnew->fSumw2.fArray[ibin] = binSumw2;; 3110 oldzbin += nzgroup;; 3111 }; 3112 oldybin += nygroup;; 3113 }; 3114 oldxbin += nxgroup;; 3115 }; 3116 ; 3117 // compute new underflow/overflows for the 8 vertices; 3118 for (Int_t xover = 0; xover <= 1; xover++) {; 3119 for (Int_t yover = 0; yover <= 1; yover++) {; 3120 for (Int_t zover = 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:122039,error,errors,122039,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,2,['error'],['errors']
Availability,"07 ; 21108 ; 21109void; 21110mg_disable_connection_keep_alive(struct mg_connection *conn); 21111{; 21112 /* https://github.com/civetweb/civetweb/issues/727 */; 21113 if (conn != NULL) {; 21114 conn->must_close = 1;; 21115 }; 21116}; 21117 ; 21118 ; 21119#if defined(MG_EXPERIMENTAL_INTERFACES); 21120/* Get connection information. It can be printed or stored by the caller.; 21121 * Return the size of available information. */; 21122int; 21123mg_get_connection_info(const struct mg_context *ctx,; 21124 int idx,; 21125 char *buffer,; 21126 int buflen); 21127{; 21128 const struct mg_connection *conn;; 21129 const struct mg_request_info *ri;; 21130 char *end, *append_eoobj = NULL, block[256];; 21131 size_t connection_info_length = 0;; 21132 int state = 0;; 21133 const char *state_str = ""unknown"";; 21134 ; 21135#if defined(_WIN32); 21136 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21137#else; 21138 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21139#endif; 21140 ; 21141 if ((buffer == NULL) || (buflen < 1)) {; 21142 buflen = 0;; 21143 end = buffer;; 21144 } else {; 21145 *buffer = 0;; 21146 end = buffer + buflen;; 21147 }; 21148 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21149 /* has enough space to append eoobj */; 21150 append_eoobj = buffer;; 21151 end -= sizeof(eoobj) - 1;; 21152 }; 21153 ; 21154 if ((ctx == NULL) || (idx < 0)) {; 21155 /* Parameter error */; 21156 return 0;; 21157 }; 21158 ; 21159 if ((unsigned)idx >= ctx->cfg_worker_threads) {; 21160 /* Out of range */; 21161 return 0;; 21162 }; 21163 ; 21164 /* Take connection [idx]. This connection is not locked in; 21165 * any way, so some other thread might use it. */; 21166 conn = (ctx->worker_connections) + idx;; 21167 ; 21168 /* Initialize output string */; 21169 connection_info_length += mg_str_append(&buffer, end, ""{"");; 21170 ; 21171 /* Init variables */; 21172 ri = &(conn->request_info);; 21173 ; 21174#if defined(USE_SERVER_STATS); 21175 state = conn->conn_state;; 21176 ; 21177 /* State as",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:631317,error,error,631317,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,07.7 0; : 625 | 88.1287 61.343 0.0200847 0.00175821 43652.7 1; : 626 Minimum Test error found - save the configuration ; : 626 | 87.0203 60.0927 0.0202246 0.00182742 43485 0; : 627 | 86.1022 60.6165 0.020286 0.00178227 43234.5 1; : 628 Minimum Test error found - save the configuration ; : 628 | 84.7933 59.0719 0.0201769 0.00183209 43609.1 0; : 629 Minimum Test error found - save the configuration ; : 629 | 83.7285 58.2513 0.0204361 0.0018731 43096.5 0; : 630 Minimum Test error found - save the configuration ; : 630 | 82.639 58.0942 0.0203377 0.00185077 43273.9 0; : 631 Minimum Test error found - save the configuration ; : 631 | 81.6101 57.1049 0.0203504 0.00184845 43238.6 0; : 632 | 80.6827 57.1221 0.0201225 0.00176999 43590.8 1; : 633 Minimum Test error found - save the configuration ; : 633 | 79.5527 56.2669 0.0201884 0.00185082 43626.2 0; : 634 Minimum Test error found - save the configuration ; : 634 | 78.6493 55.4759 0.0202109 0.00182609 43514.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.8,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:82535,error,error,82535,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"0791 0.0403928 4405.16 1; : 9 Minimum Test error found - save the configuration ; : 9 | 0.599679 0.608826 0.606268 0.0407993 4421.11 0; : 10 Minimum Test error found - save the configuration ; : 10 | 0.585295 0.60026 0.604906 0.0402508 4427.48 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.568589 0.592822 0.598106 0.0406425 4484.6 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.559657 0.589421 0.600393 0.0404151 4464.46 0; : 13 Minimum Test error found - save the configuration ; : 13 | 0.552318 0.583187 0.601709 0.0405559 4455.11 0; : 14 Minimum Test error found - save the configuration ; : 14 | 0.540541 0.58147 0.593964 0.0401674 4514.29 0; : 15 Minimum Test error found - save the configuration ; : 15 | 0.532596 0.581192 0.589633 0.0399271 4547.88 0; : 16 Minimum Test error found - save the configuration ; : 16 | 0.529842 0.56732 0.599541 0.040336 4470.63 0; : 17 | 0.521737 0.574812 0.603666 0.0406979 4440.75 1; : 18 Minimum Test error found - save the configuration ; : 18 | 0.517445 0.565391 0.598324 0.0405273 4481.92 0; : 19 Minimum Test error found - save the configuration ; : 19 | 0.509836 0.557055 0.617073 0.042121 4348.19 0; : 20 | 0.510257 0.574511 0.617241 0.0402784 4333.04 1; : ; : Elapsed time for training with 3200 events: 12.3 sec ; : Evaluate deep neural network on CPU using batches with size = 100; : ; TMVA_LSTM : [dataset] : Evaluation of TMVA_LSTM on training sample (3200 events); : Elapsed time for evaluation of 3200 events: 0.22 sec ; : Creating xml weight file: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.weights.xml␛[0m; : Creating standalone class: ␛[0;36mdataset/weights/TMVAClassification_TMVA_LSTM.class.C␛[0m; Factory : Training finished; : ; Factory : Train method: TMVA_DNN for Classification; : ; : Start of deep neural network training on CPU using MT, nthreads = 4; : ; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 4 Input = ( 1, 1, 300 ) Batch size = 256 Loss function = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html:17128,error,error,17128,doc/master/TMVA__RNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8C.html,1,['error'],['error']
Availability,"08 exh = value[3];; 409 eyl = value[4];; 410 eyh = value[5];; 411 SetPoint(np, x, y);; 412 SetPointError(np, exl, exh, eyl, eyh);; 413 np++ ;; 414 }; 415 }; 416 isLineToBeSkipped = kFALSE;; 417 token = nullptr;; 418 token_idx = 0;; 419 value_idx = 0;; 420 }; 421 Set(np) ;; 422 ; 423 // Cleaning; 424 delete [] isTokenToBeSaved;; 425 delete token;; 426 }; 427 infile.close();; 428}; 429 ; 430////////////////////////////////////////////////////////////////////////////////; 431/// TGraphAsymmErrors default destructor.; 432 ; 433TGraphAsymmErrors::~TGraphAsymmErrors(); 434{; 435 if(fEXlow) delete [] fEXlow;; 436 if(fEXhigh) delete [] fEXhigh;; 437 if(fEYlow) delete [] fEYlow;; 438 if(fEYhigh) delete [] fEYhigh;; 439}; 440 ; 441////////////////////////////////////////////////////////////////////////////////; 442/// Allocate internal data structures for `size` points.; 443 ; 444Double_t** TGraphAsymmErrors::Allocate(Int_t size) {; 445 return AllocateArrays(6, size);; 446}; 447 ; 448////////////////////////////////////////////////////////////////////////////////; 449/// Add a point with asymmetric errorbars to the graph.; 450 ; 451void TGraphAsymmErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh); 452{; 453 AddPoint(x, y);; 454 SetPointError(fNpoints - 1, exl, exh, eyl, eyh);; 455}; 456 ; 457////////////////////////////////////////////////////////////////////////////////; 458/// Apply a function to all data points \f$ y = f(x,y) \f$; 459///; 460/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 461/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$; 462///; 463/// Special treatment has to be applied for the functions where the; 464/// role of ""up"" and ""down"" is reversed.; 465///; 466/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 467 ; 468void TGraphAsymmErrors::Apply(TF1 *f); 469{; 470 Double_t x,y,exl,exh,eyl,eyh,eyl_new,eyh_new,fxy;; 471 ; 472 if (fHistogram) {; 473 delete fHistogram;; 474 fHi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:15583,error,errorbars,15583,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['errorbars']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <ROOT/REveTreeTools.hxx>. Inheritance diagram for ROOT::Experimental::REvePointSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ REvePointSelector() [1/2]. ROOT::Experimental::REvePointSelector::REvePointSelector ; (; const REvePointSelector & ; ). privatedelete . ◆ REvePointSelector() [2/2]. REvePointSelector::REvePointSelector ; (; TTree * ; t = nullptr, . REvePointSelectorConsumer * ; c = nullptr, . const char * ; vexp = """", . const char * ; sel = """" . ). Constructor. ; Definition at line 67 of file REveTreeTools.cxx. ◆ ~REvePointSelector(). ROOT::Experimental::REvePointSelector::~REvePointSele",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html:18271,avail,available,18271,doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REvePointSelector.html,1,['avail'],['available']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <ROOT/REveTreeTools.hxx>. Inheritance diagram for ROOT::Experimental::REveSelectorToEventList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ REveSelectorToEventList() [1/2]. ROOT::Experimental::REveSelectorToEventList::REveSelectorToEventList ; (; const REveSelectorToEventList & ; ). privatedelete . ◆ REveSelectorToEventList() [2/2]. REveSelectorToEventList::REveSelectorToEventList ; (; TEventList * ; evl, . const char * ; sel . ). Constructor. ; Definition at line 33 of file REveTreeTools.cxx. ◆ ~REveSelectorToEventList(). ROOT::Experimental::REveSelectorToEventList::~REveSelectorToEventList ; (; ). in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html:17525,avail,available,17525,doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1REveSelectorToEventList.html,1,['avail'],['available']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TEveTreeTools.h>. Inheritance diagram for TEvePointSelector:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEvePointSelector() [1/2]. TEvePointSelector::TEvePointSelector ; (; const TEvePointSelector & ; ). privatedelete . ◆ TEvePointSelector() [2/2]. TEvePointSelector::TEvePointSelector ; (; TTree * ; t = nullptr, . TEvePointSelectorConsumer * ; c = nullptr, . const char * ; vexp = """", . const char * ; sel = """" . ). Constructor. ; Definition at line 69 of file TEveTreeTools.cxx. ◆ ~TEvePointSelector(). TEvePointSelector::~TEvePointSelector ; (; ). inlineoverride . Definition at line 86 of file TEveTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEvePointSelector.html:18269,avail,available,18269,doc/master/classTEvePointSelector.html,https://root.cern,https://root.cern/doc/master/classTEvePointSelector.html,1,['avail'],['available']
Availability,"08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TSelectorDraw; enum  EStatusBits { kWarn = (1ULL << ( 12 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TSelectorDraw; virtual void ClearFormula ();  Delete internal buffers. ;  ; virtual bool CompileVariables (const char *varexp="""", const char *selection="""");  Compile input variables and selection expression. ;  ; virtual void InitArrays (Int_t newsize);  Initialization of the primitive type arrays if the new size is bigger than the available space. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . #include <TEveTreeTools.h>. Inheritance diagram for TEveSelectorToEventList:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ TEveSelectorToEventList() [1/2]. TEveSelectorToEventList::TEveSelectorToEventList ; (; const TEveSelectorToEventList & ; ). privatedelete . ◆ TEveSelectorToEventList() [2/2]. TEveSelectorToEventList::TEveSelectorToEventList ; (; TEventList * ; evl, . const char * ; sel . ). Constructor. ; Definition at line 32 of file TEveTreeTools.cxx. Member Function Documentation. ◆ Class(). static TClass * TEveSelectorToEventList::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveSelectorToEventList.html:17445,avail,available,17445,doc/master/classTEveSelectorToEventList.html,https://root.cern,https://root.cern/doc/master/classTEveSelectorToEventList.html,1,['avail'],['available']
Availability,"081 /*! \brief d'tor; 1082 *; 1083 *; 1084 */; 1085 Net (const Net& other); 1086 : m_eErrorFunction (other.m_eErrorFunction); 1087 , m_sizeInput (other.m_sizeInput); 1088 , m_layers (other.m_layers); 1089 {; 1090 }; 1091 ; 1092 void setInputSize (size_t sizeInput) { m_sizeInput = sizeInput; } ///< set the input size of the DNN; 1093 void setOutputSize (size_t sizeOutput) { m_sizeOutput = sizeOutput; } ///< set the output size of the DNN; 1094 void addLayer (Layer& layer) { m_layers.push_back (layer); } ///< add a layer (layout); 1095 void addLayer (Layer&& layer) { m_layers.push_back (layer); }; 1096 void setErrorFunction (ModeErrorFunction eErrorFunction) { m_eErrorFunction = eErrorFunction; } ///< which error function is to be used; 1097 ; 1098 size_t inputSize () const { return m_sizeInput; } ///< input size of the DNN; 1099 size_t outputSize () const { return m_sizeOutput; } ///< output size of the DNN; 1100 ; 1101 /*! \brief set the drop out configuration; 1102 *; 1103 *; 1104 */; 1105 template <typename WeightsType, typename DropProbabilities>; 1106 void dropOutWeightFactor (WeightsType& weights,; 1107 const DropProbabilities& drops,; 1108 bool inverse = false);; 1109 ; 1110 /*! \brief start the training; 1111 *; 1112 * \param weights weight vector; 1113 * \param trainPattern training pattern; 1114 * \param testPattern test pattern; 1115 * \param minimizer use this minimizer for training (e.g. SGD); 1116 * \param settings settings used for this training run; 1117 */; 1118 template <typename Minimizer>; 1119 double train (std::vector<double>& weights,; 1120 std::vector<Pattern>& trainPattern,; 1121 const std::vector<Pattern>& testPattern,; 1122 Minimizer& minimizer,; 1123 Settings& settings);; 1124 ; 1125 /*! \brief pre-training for future use; 1126 *; 1127 *; 1128 */; 1129 template <typename Minimizer>; 1130 void preTrain (std::vector<double>& weights,; 1131 std::vector<Pattern>& trainPattern,; 1132 const std::vector<Pattern>& testPattern,; 1133 Minimizer& mini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:39450,error,error,39450,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,1,['error'],['error']
Availability,"081 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20082 sizeof(pthread_t),; 20083 ctx);; 20084 ; 20085 if (ctx->worker_threadids == NULL) {; 20086 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20087 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20088 ; 20089 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20090 mg_snprintf(NULL,; 20091 NULL, /* No truncation check for error buffers */; 20092 error->text,; 20093 error->text_buffer_size,; 20094 ""%s"",; 20095 err_msg);; 20096 }; 20097 free_context(ctx);; 20098 pthread_setspecific(sTlsKey, NULL);; 20099 return NULL;; 20100 }; 20101 ctx->worker_connections =; 20102 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20103 sizeof(struct mg_connection),; 20104 ctx);; 20105 if (ctx->worker_connections == NULL) {; 20106 const char *err_msg =; 20107 ""Not enough memory for worker thread connection array"";; 20108 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20109 ; 20110 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20111 mg_snprintf(NULL,; 20112 NULL, /* No truncation check for error buffers */; 20113 error->text,; 20114 error->text_buffer_size,; 20115 ""%s"",; 20116 err_msg);; 20117 }; 20118 free_context(ctx);; 20119 pthread_setspecific(sTlsKey, NULL);; 20120 return NULL;; 20121 }; 20122 ; 20123#if defined(ALTERNATIVE_QUEUE); 20124 ctx->client_wait_events =; 20125 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20126 sizeof(ctx->client_wait_events[0]),; 20127 ctx);; 20128 if (ctx->client_wait_events == NULL) {; 20129 const char *err_msg = ""Not enough memory for worker event array"";; 20130 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20131 mg_free(ctx->worker_threadids);; 20132 ; 20133 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20134 mg_snprintf(NULL,; 20135 NULL, /* No truncation check for error buffers */; 20136 error->text,; 20137 error->text_buffer_size,; 20138 ""%s"",; 20139 err_msg);; 20140 }; 20141 free_context(ctx);; 20142 pthread_s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:601033,error,error,601033,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"082 ctx->worker_threadids = (pthread_t *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20083 sizeof(pthread_t),; 20084 ctx);; 20085 ; 20086 if (ctx->worker_threadids == NULL) {; 20087 const char *err_msg = ""Not enough memory for worker thread ID array"";; 20088 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20089 ; 20090 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20091 mg_snprintf(NULL,; 20092 NULL, /* No truncation check for error buffers */; 20093 error->text,; 20094 error->text_buffer_size,; 20095 ""%s"",; 20096 err_msg);; 20097 }; 20098 free_context(ctx);; 20099 pthread_setspecific(sTlsKey, NULL);; 20100 return NULL;; 20101 }; 20102 ctx->worker_connections =; 20103 (struct mg_connection *)mg_calloc_ctx(ctx->cfg_worker_threads,; 20104 sizeof(struct mg_connection),; 20105 ctx);; 20106 if (ctx->worker_connections == NULL) {; 20107 const char *err_msg =; 20108 ""Not enough memory for worker thread connection array"";; 20109 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20110 ; 20111 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20112 mg_snprintf(NULL,; 20113 NULL, /* No truncation check for error buffers */; 20114 error->text,; 20115 error->text_buffer_size,; 20116 ""%s"",; 20117 err_msg);; 20118 }; 20119 free_context(ctx);; 20120 pthread_setspecific(sTlsKey, NULL);; 20121 return NULL;; 20122 }; 20123 ; 20124#if defined(ALTERNATIVE_QUEUE); 20125 ctx->client_wait_events =; 20126 (void **)mg_calloc_ctx(ctx->cfg_worker_threads,; 20127 sizeof(ctx->client_wait_events[0]),; 20128 ctx);; 20129 if (ctx->client_wait_events == NULL) {; 20130 const char *err_msg = ""Not enough memory for worker event array"";; 20131 mg_cry_ctx_internal(ctx, ""%s"", err_msg);; 20132 mg_free(ctx->worker_threadids);; 20133 ; 20134 if ((error != NULL) && (error->text_buffer_size > 0)) {; 20135 mg_snprintf(NULL,; 20136 NULL, /* No truncation check for error buffers */; 20137 error->text,; 20138 error->text_buffer_size,; 20139 ""%s"",; 20140 err_msg);; 20141 }; 20142 free_context(ctx);; 20143 pthread_s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:601066,error,error,601066,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"091 ; 1092The above call will produce variations ""ptAndEta:down"" and ""ptAndEta:up"".; 1093 ; 1094#### Combining multiple variations; 1095 ; 1096Even if a result depends on multiple variations, only one variation is applied at a time, i.e. there will be no result produced; 1097by applying multiple systematic variations at the same time.; 1098For example, in the following example snippet, the RResultMap instance `all_h` will contain keys ""nominal"", ""pt:down"",; 1099""pt:up"", ""eta:0"", ""eta:1"", but no ""pt:up&&eta:0"" or similar:; 1100 ; 1101~~~{.cpp}; 1102auto df = _df.Vary(""pt"",; 1103 ""ROOT::RVecD{pt*0.9, pt*1.1}"",; 1104 {""down"", ""up""}); 1105 .Vary(""eta"",; 1106 [](float eta) { return RVecF{eta*0.9f, eta*1.1f}; },; 1107 {""eta""},; 1108 2);; 1109 ; 1110auto nom_h = df.Histo2D(histoModel, ""pt"", ""eta"");; 1111auto all_hs = VariationsFor(nom_h);; 1112all_hs.GetKeys(); // returns {""nominal"", ""pt:down"", ""pt:up"", ""eta:0"", ""eta:1""}; 1113~~~; 1114 ; 1115Note how we passed the integer `2` instead of a list of variation tags to the second Vary() invocation: this is a; 1116shorthand that automatically generates tags 0 to N-1 (in this case 0 and 1).; 1117 ; 1118\note Currently, VariationsFor() and RResultMap are in the `ROOT::RDF::Experimental` namespace, to indicate that these; 1119 interfaces might still evolve and improve based on user feedback. We expect that some aspects of the related; 1120 programming model will be streamlined in future versions.; 1121 ; 1122\note Currently, the results of a Snapshot(), Report() or Display() call cannot be varied (i.e. it is not possible to; 1123 call \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" on them. These limitations will be lifted in future releases.; 1124 ; 1125See the Vary() method for more information and [this tutorial](https://root.cern/doc/master/df106__HiggsToFourLeptons_8C.html) ; 1126for an example usage of Vary and \ref ROOT::RDF::Experimental::VariationsFor ""VariationsFor()"" in the analysis.; 1127 ; 1128\anchor rno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:64519,down,down,64519,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['down'],['down']
Availability,"092 while (libs.Tokenize(tok, from, "" "")) {; 2093 if ((tok.Index(pat, &ext) != 0) || (ext != tok.Length())); 2094 continue;; 2095 std::cout << tok << ""\n"";; 2096 }; 2097}; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// Return the thread local storage for the custom last error message; 2101 ; 2102TString &TSystem::GetLastErrorString(); 2103{; 2104 TTHREAD_TLS_DECL( TString, gLastErrorString);; 2105 return gLastErrorString;; 2106}; 2107 ; 2108////////////////////////////////////////////////////////////////////////////////; 2109/// Return the thread local storage for the custom last error message; 2110 ; 2111const TString &TSystem::GetLastErrorString() const; 2112{; 2113 return const_cast<TSystem*>(this)->GetLastErrorString();; 2114}; 2115 ; 2116////////////////////////////////////////////////////////////////////////////////; 2117/// Get list of shared libraries loaded at the start of the executable.; 2118/// Returns 0 in case list cannot be obtained or in case of error.; 2119 ; 2120const char *TSystem::GetLinkedLibraries(); 2121{; 2122 return nullptr;; 2123}; 2124 ; 2125////////////////////////////////////////////////////////////////////////////////; 2126/// Return a space separated list of loaded shared libraries.; 2127/// Regexp is a wildcard expression, see TRegexp::MakeWildcard.; 2128/// This list is of a format suitable for a linker, i.e it may contain; 2129/// -Lpathname and/or -lNameOfLib.; 2130/// Option can be any of:; 2131/// - S: shared libraries loaded at the start of the executable, because; 2132/// they were specified on the link line.; 2133/// - D: shared libraries dynamically loaded after the start of the program.; 2134/// - L: this option is ignored, and available for backward compatibility.; 2135 ; 2136const char *TSystem::GetLibraries(const char *regexp, const char *options,; 2137 Bool_t isRegexp); 2138{; 2139 fListLibs.Clear();; 2140 ; 2141 TString libs;; 2142 TString opt(options);; 2143 Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:68694,error,error,68694,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"0935 ; 10936#if defined(USE_TIMERS); 10937 ; 10938#define TIMER_API static; 10939#include ""timer.inl""; 10940 ; 10941#endif /* USE_TIMERS */; 10942 ; 10943 ; 10944#if !defined(NO_CGI); 10945/* This structure helps to create an environment for the spawned CGI; 10946 * program.; 10947 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10948 * last element must be NULL.; 10949 * However, on Windows there is a requirement that all these; 10950 * VARIABLE=VALUE\0; 10951 * strings must reside in a contiguous buffer. The end of the buffer is; 10952 * marked by two '\0' characters.; 10953 * We satisfy both worlds: we create an envp array (which is vars), all; 10954 * entries are actually pointers inside buf. */; 10955struct cgi_environment {; 10956 struct mg_connection *conn;; 10957 /* Data block */; 10958 char *buf; /* Environment buffer */; 10959 size_t buflen; /* Space available in buf */; 10960 size_t bufused; /* Space taken in buf */; 10961 /* Index block */; 10962 char **var; /* char **envp */; 10963 size_t varlen; /* Number of variables available in var */; 10964 size_t varused; /* Number of variables stored in var */; 10965};; 10966 ; 10967 ; 10968static void addenv(struct cgi_environment *env,; 10969 PRINTF_FORMAT_STRING(const char *fmt),; 10970 ...) PRINTF_ARGS(2, 3);; 10971 ; 10972/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10973 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10974static void; 10975addenv(struct cgi_environment *env, const char *fmt, ...); 10976{; 10977 size_t i, n, space;; 10978 int truncated = 0;; 10979 char *added;; 10980 va_list ap;; 10981 ; 10982 if ((env->varlen - env->varused) < 2) {; 10983 mg_cry_internal(env->conn,; 10984 ""%s: Cannot register CGI variable [%s]"",; 10985 __func__,; 10986 fmt);; 10987 return;; 10988 }; 10989 ; 10990 /* Calculate how much space is left in the buffer */; 10991 space = (env->buflen - env->bufused);; 10992 ; 10993 do {; 10994 /* Space for ""\0\0"" is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:315452,avail,available,315452,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['avail'],['available']
Availability,"0936 ; 10937#if defined(USE_TIMERS); 10938 ; 10939#define TIMER_API static; 10940#include ""timer.inl""; 10941 ; 10942#endif /* USE_TIMERS */; 10943 ; 10944 ; 10945#if !defined(NO_CGI); 10946/* This structure helps to create an environment for the spawned CGI; 10947 * program.; 10948 * Environment is an array of ""VARIABLE=VALUE\0"" ASCII strings,; 10949 * last element must be NULL.; 10950 * However, on Windows there is a requirement that all these; 10951 * VARIABLE=VALUE\0; 10952 * strings must reside in a contiguous buffer. The end of the buffer is; 10953 * marked by two '\0' characters.; 10954 * We satisfy both worlds: we create an envp array (which is vars), all; 10955 * entries are actually pointers inside buf. */; 10956struct cgi_environment {; 10957 struct mg_connection *conn;; 10958 /* Data block */; 10959 char *buf; /* Environment buffer */; 10960 size_t buflen; /* Space available in buf */; 10961 size_t bufused; /* Space taken in buf */; 10962 /* Index block */; 10963 char **var; /* char **envp */; 10964 size_t varlen; /* Number of variables available in var */; 10965 size_t varused; /* Number of variables stored in var */; 10966};; 10967 ; 10968 ; 10969static void addenv(struct cgi_environment *env,; 10970 PRINTF_FORMAT_STRING(const char *fmt),; 10971 ...) PRINTF_ARGS(2, 3);; 10972 ; 10973/* Append VARIABLE=VALUE\0 string to the buffer, and add a respective; 10974 * pointer into the vars array. Assumes env != NULL and fmt != NULL. */; 10975static void; 10976addenv(struct cgi_environment *env, const char *fmt, ...); 10977{; 10978 size_t i, n, space;; 10979 int truncated = 0;; 10980 char *added;; 10981 va_list ap;; 10982 ; 10983 if ((env->varlen - env->varused) < 2) {; 10984 mg_cry_internal(env->conn,; 10985 ""%s: Cannot register CGI variable [%s]"",; 10986 __func__,; 10987 fmt);; 10988 return;; 10989 }; 10990 ; 10991 /* Calculate how much space is left in the buffer */; 10992 space = (env->buflen - env->bufused);; 10993 ; 10994 do {; 10995 /* Space for ""\0\0"" is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:315485,avail,available,315485,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['avail'],['available']
Availability,"0977] - Exit code 0 with failing C++ notebook in nbconvert; [ROOT-11006] - [TTreeReader] Crash when reading array branch. Release 6.32.02; Published on June 18, 2024; Items addressed in this release. [#7236] - Memory leak in TFile::WriteObjectAny, depending on data type; [#10075] - Difficult to configure Xrootd to use non-builtin openssl; [#14051] - [web graphics] Web graphics resizes canvas despite canvas size definition in the macro; [#15321] - [MSVC] Root is failed with error G694476FC: static_assert failed “Unexpected size”; [#15405] - [RF] ExternalConstraints documentation incorrect for RooMCStudy; [#15430] - Test failures with Python 3.13; [#15473] - Segmentation fault when building with the mold linker; [#15498] - gPad is not consistent in pyROOT with web canvas; [#15511] - Possible memory corruption in cling; [#15579] - Performance regression (slowdown) in ALICE event generation; [#15686] - JITted code changes the execution order of computation graph nodes; [#15688] - PyROOT TProfile2D::Fill ambiguities preventing use of some signatures in pyROOT; [#15690] - [RF] SegFault in RooBernstein::fillBuffer; [#15694] - [RF] New RooFit EvalBackend returning incorrect result for binned likelihoods; [#15703] - Leaking memory though strings in PyROOT; [#15727] - Windows CMake project cannot find_library() after integrating with ROOT.; [#15751] - [RF] Using a conditional RooProdPdf in a multi-channel fit spawns too many integrals with new CPU evaluation backend; [#15791] - JS ROOT does not draw tprofile2d correctly with “TEXT” draw option; [#15799] - pyunittests-pyroot-pyz-ttree-setbranchaddress segfaults with Python 3.13; [ROOT-7412] - Strange results looking for nested types; [ROOT-8439] - PyROOT does not treat exceptions properly in overloaded methods; [ROOT-9307] - TPad::GetListOfPrimitives() double deletion error in TList::Clear(). Release 6.32.04; Published on August 14, 2024; Items addressed in this release. [#7223] - [RF] RDataFrame to RooDataSet/RooDataHist conve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:42987,fault,fault,42987,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['fault'],['fault']
Availability,0985 0.00180899 43741 6; : 967 | 3.64317 5.0911 0.0200896 0.00175556 43634.6 7; : 968 Minimum Test error found - save the configuration ; : 968 | 3.75704 4.83525 0.0200988 0.00182012 43766.9 0; : 969 | 3.53402 4.87481 0.020433 0.0017954 42924.1 1; : 970 | 3.39152 4.92875 0.0207012 0.00184125 42417.9 2; : 971 | 3.38481 4.91243 0.0205923 0.00181714 42609.4 3; : 972 | 3.49443 4.93416 0.0204303 0.00180084 42942.7 4; : 973 | 3.50169 4.88411 0.0201535 0.00176496 43505.4 5; : 974 | 3.70493 4.95915 0.0200555 0.00176513 43738.9 6; : 975 Minimum Test error found - save the configuration ; : 975 | 3.52504 4.65912 0.0202218 0.00185299 43552 0; : 976 | 3.7346 5.23443 0.0200603 0.00176255 43721.2 1; : 977 | 3.73856 4.9727 0.0200443 0.00176151 43757 2; : 978 | 3.60727 4.99113 0.0200479 0.00175633 43736 3; : 979 | 3.40672 4.84357 0.0200357 0.00175685 43766.5 4; : 980 | 3.44899 4.83288 0.0200548 0.0017499 43704.2 5; : 981 | 3.46445 4.72048 0.0203135 0.00176046 43119.7 6; : 982 Minimum Test error found - save the configuration ; : 982 | 3.46604 4.64127 0.0202116 0.00183381 43530.8 0; : 983 Minimum Test error found - save the configuration ; : 983 | 3.37896 4.59559 0.0201715 0.00182642 43608.5 0; : 984 Minimum Test error found - save the configuration ; : 984 | 3.36213 4.34126 0.0202597 0.00185498 43467.1 0; : 985 | 3.39032 4.51659 0.0201503 0.00185184 43719.5 1; : 986 | 3.5234 4.95577 0.0201762 0.0017578 43434.8 2; : 987 | 3.50466 4.60061 0.0201538 0.00175522 43481.6 3; : 988 | 3.61316 4.68965 0.0201071 0.00176 43603.6 4; : 989 | 3.88349 5.24185 0.0200475 0.00175499 43733.8 5; : 990 | 4.0647 4.52576 0.020036 0.00175545 43762.3 6; : 991 | 3.77396 5.32769 0.0200783 0.00175786 43667.1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:111910,error,error,111910,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"0; , kCheckROOT = 1; , kCheckGIT = 2; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TPackMgr (const char *dir, const char *key=""L0"");  Create a PROOF package manager. ;  ;  ~TPackMgr () override;  Destroy a TPackMgr instance. ;  ; Int_t Build (const char *pack, Int_t opt=TPackMgr::kCheckROOT);  Method to build a package. ;  ; Int_t Clean (const char *pack);  Clean dir for package 'pack' Return -1 in case of error, 0 otherwise. ;  ; const char * GetDir () const;  ; Int_t GetDownloadDir (TString &dldir);  Method to get the download dir; create if not existing Return -1 in case of error (not found; not created), 0 otherwise. ;  ; void GetEnabledPackages (TString &packlist);  Method to get a semi-colon separated list with the names of the enabled packages. ;  ; TList * GetList () const;  Get list of available packages Returns a pointer to a TList object, transferring ownership to the caller. ;  ; TList * GetListOfEnabled () const;  Get list of enabled packages Returns a pointer to a TList object, transferring ownership to the caller. ;  ; TLockPath * GetLock ();  ; TMD5 * GetMD5 (const char *pack);  Get MD5 checksum of the PAR file corresponding to given package Returns a pointer to a TMD5 object, transferring ownership to the caller. ;  ; const char * GetName () const override;  Returns name of object. ;  ; Int_t GetPackDir (const char *pack, TString &pdir)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:1658,error,error,1658,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['error'],['error']
Availability,"0; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Member Functions inherited from TGraphErrors; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for newsize points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin != iend. ;  ; Bool_t CtorAllocate ();  Constructor allocate. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end]. ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEX, and fEY arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphPolar.html:33993,error,errors,33993,doc/master/classTGraphPolar.html,https://root.cern,https://root.cern/doc/master/classTGraphPolar.html,1,['error'],['errors']
Availability,0; : 568 Minimum Test error found - save the configuration ; : 568 | 178.451 108.059 0.0201373 0.00182611 43689.1 0; : 569 Minimum Test error found - save the configuration ; : 569 | 176.264 106.78 0.0201111 0.00181323 43721.1 0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minimum Test error found - save the configuration ; : 581 | 153.026 95.3539 0.0201307 0.0018172 43683.7 0; : 582 Minimum Test error found - save the configuration ; : 582 | 151.197 94.0449 0.020143 0.00182303 43668.3 0; : 583 Minimum Test error found - save the configuration ; : 583 | 149.229 93.6244 0.0201231 0.00181874 43705.4 0; : 584 Minimum Test error found - save the configuration ; : 584 | 147.504 92.2301 0.0202996 0.00182281 43297.5 0; : 585 Minimum Test error found - save the configuration ; : 585 | 145.457 91.5459 0.020121 0.00181177 43693.8 0; : 586 Minimum,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:76199,error,error,76199,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 569 Minimum Test error found - save the configuration ; : 569 | 176.264 106.78 0.0201111 0.00181323 43721.1 0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minimum Test error found - save the configuration ; : 581 | 153.026 95.3539 0.0201307 0.0018172 43683.7 0; : 582 Minimum Test error found - save the configuration ; : 582 | 151.197 94.0449 0.020143 0.00182303 43668.3 0; : 583 Minimum Test error found - save the configuration ; : 583 | 149.229 93.6244 0.0201231 0.00181874 43705.4 0; : 584 Minimum Test error found - save the configuration ; : 584 | 147.504 92.2301 0.0202996 0.00182281 43297.5 0; : 585 Minimum Test error found - save the configuration ; : 585 | 145.457 91.5459 0.020121 0.00181177 43693.8 0; : 586 Minimum Test error found - save the configuration ; : 586 | 143.954 90.9958 0.02013 0.00181326 43675.8 0; : 587 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:76313,error,error,76313,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 570 Minimum Test error found - save the configuration ; : 570 | 174.355 105.885 0.0201445 0.00181905 43655.2 0; : 571 | 172.647 106.784 0.0200848 0.0017791 43702.2 1; : 572 Minimum Test error found - save the configuration ; : 572 | 170.589 104.683 0.020165 0.00182763 43626.8 0; : 573 Minimum Test error found - save the configuration ; : 573 | 168.468 102.528 0.0201413 0.00182619 43679.9 0; : 574 Minimum Test error found - save the configuration ; : 574 | 166.622 102.085 0.0201407 0.00181861 43663.2 0; : 575 Minimum Test error found - save the configuration ; : 575 | 164.293 100.588 0.0203765 0.00182671 43127.2 0; : 576 Minimum Test error found - save the configuration ; : 576 | 162.136 99.7953 0.0201485 0.00182291 43654.8 0; : 577 Minimum Test error found - save the configuration ; : 577 | 160.429 98.8873 0.0202404 0.00182125 43433.1 0; : 578 Minimum Test error found - save the configuration ; : 578 | 158.663 98.2522 0.020118 0.00181189 43701.3 0; : 579 Minimum Test error found - save the configuration ; : 579 | 156.666 96.9925 0.0201133 0.00181082 43710 0; : 580 Minimum Test error found - save the configuration ; : 580 | 154.635 96.1367 0.0201142 0.00181294 43712.9 0; : 581 Minimum Test error found - save the configuration ; : 581 | 153.026 95.3539 0.0201307 0.0018172 43683.7 0; : 582 Minimum Test error found - save the configuration ; : 582 | 151.197 94.0449 0.020143 0.00182303 43668.3 0; : 583 Minimum Test error found - save the configuration ; : 583 | 149.229 93.6244 0.0201231 0.00181874 43705.4 0; : 584 Minimum Test error found - save the configuration ; : 584 | 147.504 92.2301 0.0202996 0.00182281 43297.5 0; : 585 Minimum Test error found - save the configuration ; : 585 | 145.457 91.5459 0.020121 0.00181177 43693.8 0; : 586 Minimum Test error found - save the configuration ; : 586 | 143.954 90.9958 0.02013 0.00181326 43675.8 0; : 587 Minimum Test error found - save the configuration ; : 587 | 142.242 89.8853 0.0201892 0.0018256 43564.4 0; : 588 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:76426,error,error,76426,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Minimum Test error found - save the configuration ; : 666 | 51.2956 40.6256 0.0201396 0.00182896 43690.5 0; : 667 Minimum Test error found - save the configuration ; : 667 | 50.7315 40.0752 0.0201193 0.00182284 43724.4 0; : 668 | 49.9429 40.0919 0.0200598 0.00176937 43738.7 1; : 669 Minimum Test error found - save the configuration ; : 669 | 49.7924 39.9525 0.02013 0.00182828 43711.6 0; : 670 Minimum Test error found - save the configuration ; : 670 | 48,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:85366,error,error,85366,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17.9119 20.8249 0.0200825 0.00181515 43794.1 0; : 750 | 17.7295 20.9077 0.0200909 0.00176261 43648.3 1; : 751 Minimum Test error found - save the configuration ; : 751 | 17.6646 20.1562 0.02009 0.00181812 43783 0; : 752 Minimum Test error found - save the configuration ; : 752 | 17.2045 20.1301 0.0200899 0.00181385 43773 0; : 753 Minimum Test error found - save the configuration ; : 753 | 17.2492 20.0483 0.0200805 0.00181433 43796.8 0; : 754 Minimum Test error found - save the configuration ; : 754 | 16.8738 20.0271 0.0201173 0.00182078 43724.2 0; : 755 | 16.6744 20.3793 0.0200328 0.00175569 43770.5 1; : 756 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:93556,error,error,93556,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"0; TProfileHelper::Addstatic Bool_t Add(T *p, const TH1 *h1, const TH1 *h2, Double_t c1, Double_t c2=1)Definition TProfileHelper.h:71; TProfileHelper::GetBinEffectiveEntriesstatic Double_t GetBinEffectiveEntries(T *p, Int_t bin)Definition TProfileHelper.h:143; TProfileHelper::LabelsDeflatestatic void LabelsDeflate(T *p, Option_t *)Definition TProfileHelper.h:560; TProfileProfile Histogram.Definition TProfile.h:32; TProfile::GetBinSumw2virtual TArrayD * GetBinSumw2()Definition TProfile.h:111; TProfile::SetBinEntriesvirtual void SetBinEntries(Int_t bin, Double_t w)Set the number of entries in bin.Definition TProfile.cxx:1700; TProfile::Sumw2void Sumw2(Bool_t flag=kTRUE) overrideCreate/delete structure to store sum of squares of weights per bin.Definition TProfile.cxx:1825; TStringBasic string class.Definition TString.h:139; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::ToUppervoid ToUpper()Change string to upper case.Definition TString.cxx:1195; TString::IsNullBool_t IsNull() constDefinition TString.h:414; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; bool; double; int; unsigned int; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; h1TH1F * h1Definition legend1.C:5; c2return c2Definition legend2.C:14; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123. histhistsrcTProfile2D.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:96332,down,down,96332,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['down'],['down']
Availability,"0; k < n; ++k); 960 newCov[i*n+j] += cov[i*n + k] * tmp[k*n + j];; 961 }; 962 }; 963 // update fit result with new corrected covariance matrix; 964 unsigned int k = 0;; 965 for (unsigned int i = 0; i < n; ++i) {; 966 fResult->fErrors[i] = std::sqrt( newCov[i*(n+1)] );; 967 for (unsigned int j = 0; j <= i; ++j); 968 fResult->fCovMatrix[k++] = newCov[i *n + j];; 969 }; 970 ; 971 // restore previous used objective function; 972 fObjFunction.swap( objFunc );; 973 ; 974 return true;; 975}; 976 ; 977 ; 978 ; 979void Fitter::ExamineFCN() {; 980 // return a pointer to the binned data used in the fit; 981 // works only for chi2 or binned likelihood fits; 982 // thus when the objective function stored is a Chi2Func or a PoissonLikelihood; 983 // This also set the model function correctly if it has not been set; 984 ; 985 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 986 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGenFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 987 ; 988 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, BinData> >() ) return;; 989 if ( GetDataFromFCN<BasicFCN<ROOT::Math::IMultiGradFunction, ROOT::Math::IParamMultiFunction, UnBinData> >() ) return;; 990 ; 991 //MATH_INFO_MSG(""Fitter::ExamineFCN"",""Objective function is not of a known type - FitData and ModelFunction objects are not available"");; 992 return;; 993}; 994 ; 995 } // end namespace Fit; 996 ; 997} // end namespace ROOT; BasicFCN.h; BinData.h; Chi2FCN.h; Error.h; MATH_INFO_MSG#define MATH_INFO_MSG(loc, str)Pre-processor macro to report messages which can be configured to use ROOT error or simply an std::io...Definition Error.h:77; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; FcnAdapter.h; FitConfig.h; FitMethodFunction.h; FitResult.h; Fitter.h; IParamFunction.h; LogLikelihoo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Fitter_8cxx_source.html:39206,avail,available,39206,doc/master/Fitter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Fitter_8cxx_source.html,1,['avail'],['available']
Availability,"0; kbeg = 0;}; 1600 if (opt.Contains(""O"")) {iend = ncx1+1; jend = ncy1+1; kend = ncz1+1;}; 1601 ; 1602 Int_t i,j,k,bin;; 1603 Double_t sum1 = 0;; 1604 Double_t sum2 = 0;; 1605 Double_t w1 = 0;; 1606 Double_t w2 = 0;; 1607 for (i = ibeg; i <= iend; i++) {; 1608 for (j = jbeg; j <= jend; j++) {; 1609 for (k = kbeg; k <= kend; k++) {; 1610 bin = h1->GetBin(i,j,k);; 1611 sum1 += h1->GetBinContent(bin);; 1612 sum2 += h2->GetBinContent(bin);; 1613 Double_t ew1 = h1->GetBinError(bin);; 1614 Double_t ew2 = h2->GetBinError(bin);; 1615 w1 += ew1*ew1;; 1616 w2 += ew2*ew2;; 1617 }; 1618 }; 1619 }; 1620 ; 1621 ; 1622 // Check that both scatterplots contain events; 1623 if (sum1 == 0) {; 1624 Error(""KolmogorovTest"",""Integral is zero for h1=%s\n"",h1->GetName());; 1625 return 0;; 1626 }; 1627 if (sum2 == 0) {; 1628 Error(""KolmogorovTest"",""Integral is zero for h2=%s\n"",h2->GetName());; 1629 return 0;; 1630 }; 1631 // calculate the effective entries.; 1632 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 1633 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 1634 Double_t esum1 = 0, esum2 = 0;; 1635 if (w1 > 0); 1636 esum1 = sum1 * sum1 / w1;; 1637 else; 1638 afunc1 = kTRUE; // use later for calculating z; 1639 ; 1640 if (w2 > 0); 1641 esum2 = sum2 * sum2 / w2;; 1642 else; 1643 afunc2 = kTRUE; // use later for calculating z; 1644 ; 1645 if (afunc2 && afunc1) {; 1646 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 1647 return 0;; 1648 }; 1649 ; 1650 // Find Kolmogorov distance; 1651 // order is arbitrary take average of all possible 6 starting orders x,y,z; 1652 int order[3] = {0,1,2};; 1653 int binbeg[3];; 1654 int binend[3];; 1655 int ibin[3];; 1656 binbeg[0] = ibeg; binbeg[1] = jbeg; binbeg[2] = kbeg;; 1657 binend[0] = iend; binend[1] = jend; binend[2] = kend;; 1658 Double_t vdfmax[6]; // there are in total 6 combinations; 1659 int icomb = 0;; 1660 Double_t s1 = 1./(6.*sum1);; 1661 Double_t s2 = ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:64147,error,errors,64147,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['error'],['errors']
Availability,"0;; 16732 } else if (callback_ret > 0) {; 16733 /* Callback exists and returns >0: Initializing complete,; 16734 * civetweb should not modify the SSL context. */; 16735 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16736 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16737 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16738 return 0;; 16739 }; 16740 return 1;; 16741 }; 16742 /* If the callback does not exist or return 0, civetweb must initialize; 16743 * the SSL context. Handle ""domain"" callback next. */; 16744 ; 16745 /* Check for external domain SSL_CTX callback. */; 16746 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16747 ? 0; 16748 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16749 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16750 &ssl_ctx,; 16751 phys_ctx->user_data));; 16752 ; 16753 if (callback_ret < 0) {; 16754 /* Callback < 0: Error. Abort init. */; 16755 mg_cry_ctx_internal(; 16756 phys_ctx,; 16757 ""external_ssl_ctx_domain callback returned error: %i"",; 16758 callback_ret);; 16759 return 0;; 16760 } else if (callback_ret > 0) {; 16761 /* Callback > 0: Consider init done. */; 16762 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16763 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16764 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16765 return 0;; 16766 }; 16767 return 1;; 16768 }; 16769 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16770 * 0, CivetWeb should continue initializing SSL */; 16771 ; 16772 /* If PEM file is not specified and the init_ssl callbacks; 16773 * are not specified, setup will fail. */; 16774 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16775 && (phys_ctx->callbacks.init_ssl == NULL); 16776 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16777 /* No certificate and no init_ssl callbacks:; 16778 * Essential data to set up TLS is missing.; 16779 */; 16780 mg_cry_ctx_internal(phys_ctx,; 16781 ""Initializing SSL failed: -%s is not set"",; 16782 config_options[SSL_CERTIFICATE].name);; 1678",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:497311,error,error,497311,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0;; 16733 } else if (callback_ret > 0) {; 16734 /* Callback exists and returns >0: Initializing complete,; 16735 * civetweb should not modify the SSL context. */; 16736 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16737 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16738 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16739 return 0;; 16740 }; 16741 return 1;; 16742 }; 16743 /* If the callback does not exist or return 0, civetweb must initialize; 16744 * the SSL context. Handle ""domain"" callback next. */; 16745 ; 16746 /* Check for external domain SSL_CTX callback. */; 16747 callback_ret = (phys_ctx->callbacks.external_ssl_ctx_domain == NULL); 16748 ? 0; 16749 : (phys_ctx->callbacks.external_ssl_ctx_domain(; 16750 dom_ctx->config[AUTHENTICATION_DOMAIN],; 16751 &ssl_ctx,; 16752 phys_ctx->user_data));; 16753 ; 16754 if (callback_ret < 0) {; 16755 /* Callback < 0: Error. Abort init. */; 16756 mg_cry_ctx_internal(; 16757 phys_ctx,; 16758 ""external_ssl_ctx_domain callback returned error: %i"",; 16759 callback_ret);; 16760 return 0;; 16761 } else if (callback_ret > 0) {; 16762 /* Callback > 0: Consider init done. */; 16763 dom_ctx->ssl_ctx = (SSL_CTX *)ssl_ctx;; 16764 if (!initialize_openssl(ebuf, sizeof(ebuf))) {; 16765 mg_cry_ctx_internal(phys_ctx, ""%s"", ebuf);; 16766 return 0;; 16767 }; 16768 return 1;; 16769 }; 16770 /* else: external_ssl_ctx/external_ssl_ctx_domain do not exist or return; 16771 * 0, CivetWeb should continue initializing SSL */; 16772 ; 16773 /* If PEM file is not specified and the init_ssl callbacks; 16774 * are not specified, setup will fail. */; 16775 if (((pem = dom_ctx->config[SSL_CERTIFICATE]) == NULL); 16776 && (phys_ctx->callbacks.init_ssl == NULL); 16777 && (phys_ctx->callbacks.init_ssl_domain == NULL)) {; 16778 /* No certificate and no init_ssl callbacks:; 16779 * Essential data to set up TLS is missing.; 16780 */; 16781 mg_cry_ctx_internal(phys_ctx,; 16782 ""Initializing SSL failed: -%s is not set"",; 16783 config_options[SSL_CERTIFICATE].name);; 1678",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:497344,error,error,497344,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"0;; 3374 ; 3375 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3376 ; 3377 if (!conn) {; 3378 puts(buf);; 3379 return;; 3380 }; 3381 ; 3382 /* Do not lock when getting the callback value, here and below.; 3383 * I suppose this is fine, since function cannot disappear in the; 3384 * same way string option can. */; 3385 if ((conn->phys_ctx->callbacks.log_message == NULL); 3386 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3387 ; 3388 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3389 if (mg_fopen(conn,; 3390 conn->dom_ctx->config[ERROR_LOG_FILE],; 3391 MG_FOPEN_MODE_APPEND,; 3392 &fi); 3393 == 0) {; 3394 fi.access.fp = NULL;; 3395 }; 3396 } else {; 3397 fi.access.fp = NULL;; 3398 }; 3399 ; 3400 if (fi.access.fp != NULL) {; 3401 flockfile(fi.access.fp);; 3402 timestamp = time(NULL);; 3403 ; 3404 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3405 fprintf(fi.access.fp,; 3406 ""[%010lu] [error] [client %s] "",; 3407 (unsigned long)timestamp,; 3408 src_addr);; 3409 ; 3410 if (conn->request_info.request_method != NULL) {; 3411 fprintf(fi.access.fp,; 3412 ""%s %s: "",; 3413 conn->request_info.request_method,; 3414 conn->request_info.request_uri; 3415 ? conn->request_info.request_uri; 3416 : """");; 3417 }; 3418 ; 3419 fprintf(fi.access.fp, ""%s"", buf);; 3420 fputc('\n', fi.access.fp);; 3421 fflush(fi.access.fp);; 3422 funlockfile(fi.access.fp);; 3423 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3424 * mg_cry here anyway ;-) */; 3425 }; 3426 }; 3427}; 3428#else; 3429#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3430#endif /* Externally provided function */; 3431 ; 3432 ; 3433/* Construct fake connection structure. Used for logging, if connection; 3434 * is not applicable at the moment of logging. */; 3435static struct mg_connection *; 3436fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3437{; 3438 static const struct mg_connection conn_z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:101362,error,error,101362,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"0;; 3375 ; 3376 DEBUG_TRACE(""mg_cry called from %s:%u: %s"", func, line, buf);; 3377 ; 3378 if (!conn) {; 3379 puts(buf);; 3380 return;; 3381 }; 3382 ; 3383 /* Do not lock when getting the callback value, here and below.; 3384 * I suppose this is fine, since function cannot disappear in the; 3385 * same way string option can. */; 3386 if ((conn->phys_ctx->callbacks.log_message == NULL); 3387 || (conn->phys_ctx->callbacks.log_message(conn, buf) == 0)) {; 3388 ; 3389 if (conn->dom_ctx->config[ERROR_LOG_FILE] != NULL) {; 3390 if (mg_fopen(conn,; 3391 conn->dom_ctx->config[ERROR_LOG_FILE],; 3392 MG_FOPEN_MODE_APPEND,; 3393 &fi); 3394 == 0) {; 3395 fi.access.fp = NULL;; 3396 }; 3397 } else {; 3398 fi.access.fp = NULL;; 3399 }; 3400 ; 3401 if (fi.access.fp != NULL) {; 3402 flockfile(fi.access.fp);; 3403 timestamp = time(NULL);; 3404 ; 3405 sockaddr_to_string(src_addr, sizeof(src_addr), &conn->client.rsa);; 3406 fprintf(fi.access.fp,; 3407 ""[%010lu] [error] [client %s] "",; 3408 (unsigned long)timestamp,; 3409 src_addr);; 3410 ; 3411 if (conn->request_info.request_method != NULL) {; 3412 fprintf(fi.access.fp,; 3413 ""%s %s: "",; 3414 conn->request_info.request_method,; 3415 conn->request_info.request_uri; 3416 ? conn->request_info.request_uri; 3417 : """");; 3418 }; 3419 ; 3420 fprintf(fi.access.fp, ""%s"", buf);; 3421 fputc('\n', fi.access.fp);; 3422 fflush(fi.access.fp);; 3423 funlockfile(fi.access.fp);; 3424 (void)mg_fclose(&fi.access); /* Ignore errors. We can't call; 3425 * mg_cry here anyway ;-) */; 3426 }; 3427 }; 3428}; 3429#else; 3430#error Must either enable filesystems or provide a custom mg_cry_internal_impl implementation; 3431#endif /* Externally provided function */; 3432 ; 3433 ; 3434/* Construct fake connection structure. Used for logging, if connection; 3435 * is not applicable at the moment of logging. */; 3436static struct mg_connection *; 3437fake_connection(struct mg_connection *fc, struct mg_context *ctx); 3438{; 3439 static const struct mg_connection conn_z",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:101394,error,error,101394,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,0=7.28945 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=7.28945 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=7.28945 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so fa,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:28240,error,error,28240,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"0LL;; 775 union { unsigned long long l; double d;} v;; 776 v.d =x;; 777 return (v.l&mask)!=mask;; 778}; 779#else; 780# if defined(R__HPUX11); 781 { return isfinite(x); }; 782# elif defined(R__MACOSX); 783# ifdef isfinite; 784 // from math.h; 785 { return isfinite(x); }; 786# else; 787 // from cmath; 788 { return std::isfinite(x); }; 789# endif; 790# else; 791 { return finite(x); }; 792# endif; 793#endif; 794 ; 795////////////////////////////////////////////////////////////////////////////////; 796/// Check if it is finite with a mask in order to be consistent in presence of; 797/// fast math.; 798/// Inspired from the CMSSW FWCore/Utilities package; 799 ; 800inline Int_t TMath::Finite(Float_t x); 801#if defined(R__FAST_MATH); 802 ; 803{; 804 const unsigned int mask = 0x7f800000;; 805 union { unsigned int l; float d;} v;; 806 v.d =x;; 807 return (v.l&mask)!=mask;; 808}; 809#else; 810{ return std::isfinite(x); }; 811#endif; 812 ; 813// This namespace provides all the routines necessary for checking if a number; 814// is a NaN also in presence of optimisations affecting the behaviour of the; 815// floating point calculations.; 816// Inspired from the CMSSW FWCore/Utilities package; 817 ; 818#if defined (R__FAST_MATH); 819namespace ROOT {; 820namespace Internal {; 821namespace Math {; 822// abridged from GNU libc 2.6.1 - in detail from; 823// math/math_private.h; 824// sysdeps/ieee754/ldbl-96/math_ldbl.h; 825 ; 826// part of this file:; 827 /*; 828 * ====================================================; 829 * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.; 830 *; 831 * Developed at SunPro, a Sun Microsystems, Inc. business.; 832 * Permission to use, copy, modify, and distribute this; 833 * software is freely granted, provided that this notice; 834 * is preserved.; 835 * ====================================================; 836 */; 837 ; 838 // A union which permits us to convert between a double and two 32 bit ints.; 839 typedef union {; 840 Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8h_source.html:29865,mask,mask,29865,doc/master/TMath_8h_source.html,https://root.cern,https://root.cern/doc/master/TMath_8h_source.html,2,['mask'],['mask']
Availability,"0[1]. exdata[vecsize-1] = X_0[vecsize-3]; exdata[vecsize] = ExpValue_1; exdata[vecsize+1] = ExpSigma_1; exdata[vecsize+2] = X_1[0]. exdata[vecsize*(numpoints-1)] = ExpValue_(numpoints-1). exdata[vecsize*numpoints-1] = X_(numpoints-1)[vecsize-3]. void SetFitMethod(const char* name); ret fit method (chisquare or loglikelihood). Int_t SetParameter(Int_t ipar, const char* parname, Double_t value, Double_t verr, Double_t vlow, Double_t vhigh); Sets for prameter number ipar initial parameter value,; name parname, initial error verr and limits vlow and vhigh; If vlow = vhigh but not equil to zero, parameter will be fixed.; If vlow = vhigh = 0, parameter is released and its limits are discarded. Int_t SGZ(); Evaluates objective function ( chi-square ), gradients and; Z-matrix using data provided by user via TFumili::SetData. void FitChisquare(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; Default method (function evaluated at center of bin); for each point the cache contains the following info; -1D : bc,e,xc (bin content, error, x of center of bin); -2D : bc,e,xc,yc; -3D : bc,e,xc,yc,zc. void FitChisquareI(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Chisquare method; The ""I""ntegral method is used; for each point the cache contains the following info; -1D : bc,e,xc,xw (bin content, error, x of center of bin, x bin width of bin); -2D : bc,e,xc,xw,yc,yw; -3D : bc,e,xc,xw,yc,yw,zc,zw. void FitLikelihood(Int_t& npar, Double_t* gin, Double_t& f, Double_t* u, Int_t flag); Minimization function for H1s using a Likelihood method*-*-*-*-*-*; Basically, it forms the likelihood by determining the Poisson; probability that given a number of entries in a particular bin,; the fit would predict it's value. This is then done for each bin,; and the sum of the logs is taken as the likelihood.; Default method (function evaluated at center of bin); for each po",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFumili.html:22899,error,error,22899,root/html528/TFumili.html,https://root.cern,https://root.cern/root/html528/TFumili.html,10,['error'],['error']
Availability,"0] PROGRESS:Caching -- current storage has size 10; [#0] PROGRESS:ObjectHandling -- observable: pTV; [#0] PROGRESS:ObjectHandling -- binWidth: binWidth_pTV; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(wrap_pdf_over_wrap_pdf_Int[pTV]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_wrap_pdf_over_wrap_pdf_Int[pTV]_pseudo_dh) Summation contains a RooNLLVar, using its error level; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0 cHl3=0 cHq3=-0.0202918; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0376648, denominator=wrap_pdf_Int[pTV]=10358.6; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.213672 cHl3=1.97898 cHq3=0.00773174; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=0.0882577, denominator=wrap_pdf_Int[pTV]=4536.67; getLogVal",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:8740,recover,recover,8740,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,"0|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR:TrainingStrategy=LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0.:Architecture=CPU""; : The following options are set:; : - By User:; : V: ""True"" [Verbose output (short form of ""VerbosityLevel"" below - overrides the latter one)]; : VarTransform: ""None"" [List of variable transformations performed before training, e.g., ""D_Background,P_Signal,G,N_AllClasses"" for: ""Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)""]; : H: ""False"" [Print method-specific help message]; : InputLayout: ""10|30"" [The Layout of the input]; : Layout: ""LSTM|10|30|10|0|1,RESHAPE|FLAT,DENSE|64|TANH,LINEAR"" [Layout of the network.]; : ErrorStrategy: ""CROSSENTROPY"" [Loss function: Mean squared error (regression) or cross entropy (binary classification).]; : WeightInitialization: ""XAVIERUNIFORM"" [Weight initialization strategy]; : RandomSeed: ""1234"" [Random seed used for weight initialization and batch shuffling]; : ValidationSize: ""0.2"" [Part of the training data to use for validation. Specify as 0.2 or 20% to use a fifth of the data set as validation set. Specify as 100 to use exactly 100 events. (Default: 20%)]; : Architecture: ""CPU"" [Which architecture to perform the training on.]; : TrainingStrategy: ""LearningRate=1e-3,Momentum=0.0,Repetitions=1,ConvergenceSteps=5,BatchSize=100,TestRepetitions=1,WeightDecay=1e-2,Regularization=None,MaxEpochs=10Optimizer=ADAM,DropConfig=0.0+0.+0.+0."" [Defines the training strategies.]; : - Default:; : VerbosityLevel: ""Default"" [Verbosity level]; : CreateMVAPdfs: ""False"" [Create PDFs for classifier outputs (signal and background)]; : IgnoreNegWeightsInTraining: ""False"" [Events with negative weights are ignored in the training (but are in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:2491,error,error,2491,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['error'],['error']
Availability,"0}; 61End_Macro; 62*/; 63////////////////////////////////////////////////////////////////////////////////; 64/// TGraphMultiErrors default constructor.; 65 ; 66TGraphMultiErrors::TGraphMultiErrors(); 67 : fNYErrors(0), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst), fExL(nullptr), fExH(nullptr); 68{; 69}; 70 ; 71////////////////////////////////////////////////////////////////////////////////; 72/// TGraphMultiErrors default constructor with name and title.; 73 ; 74TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title) : TGraphMultiErrors(); 75{; 76 SetNameTitle(name, title);; 77}; 78 ; 79////////////////////////////////////////////////////////////////////////////////; 80/// TGraphMultiErrors normal constructor with np points and ne y-errors.; 81///; 82/// All values are initialized to 0.; 83 ; 84TGraphMultiErrors::TGraphMultiErrors(Int_t np, Int_t ne); 85 : TGraph(np), fNYErrors(ne), fSumErrorsMode(TGraphMultiErrors::kOnlyFirst); 86{; 87 CtorAllocate();; 88}; 89 ; 90////////////////////////////////////////////////////////////////////////////////; 91/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 92///; 93/// All values are initialized to 0.; 94 ; 95TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne); 96 : TGraphMultiErrors(np, ne); 97{; 98 SetNameTitle(name, title);; 99}; 100 ; 101////////////////////////////////////////////////////////////////////////////////; 102/// TGraphMultiErrors normal constructor with `np` points and a single y-error.; 103///; 104/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 105/// If `exL`,`exH` or `eyL`,`exH` are NULL, the corresponding values are preset to zero.; 106 ; 107TGraphMultiErrors::TGraphMultiErrors(Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL,; 108 const Float_t *exH, const Float_t *eyL, const Float_t *eyH, Int_t m); 109 : TGraph(np, x, y),",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:3463,error,errors,3463,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,1 0; : 629 Minimum Test error found - save the configuration ; : 629 | 83.7285 58.2513 0.0204361 0.0018731 43096.5 0; : 630 Minimum Test error found - save the configuration ; : 630 | 82.639 58.0942 0.0203377 0.00185077 43273.9 0; : 631 Minimum Test error found - save the configuration ; : 631 | 81.6101 57.1049 0.0203504 0.00184845 43238.6 0; : 632 | 80.6827 57.1221 0.0201225 0.00176999 43590.8 1; : 633 Minimum Test error found - save the configuration ; : 633 | 79.5527 56.2669 0.0201884 0.00185082 43626.2 0; : 634 Minimum Test error found - save the configuration ; : 634 | 78.6493 55.4759 0.0202109 0.00182609 43514.1 0; : 635 Minimum Test error found - save the configuration ; : 635 | 77.3887 55.223 0.020166 0.00184577 43667.6 0; : 636 Minimum Test error found - save the configuration ; : 636 | 76.4488 55.0573 0.020202 0.00188181 43667.6 0; : 637 Minimum Test error found - save the configuration ; : 637 | 75.4894 54.0711 0.0202555 0.00186268 43495.3 0; : 638 Minimum Test error found - save the configuration ; : 638 | 74.5839 53.0373 0.0201113 0.00181775 43731.4 0; : 639 Minimum Test error found - save the configuration ; : 639 | 73.497 52.6629 0.0200838 0.00181639 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:82874,error,error,82874,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Minimum Test error found - save the configuration ; : 665 | 52.1886 40.6761 0.020181 0.00182542 43583.6 0; : 666 Minimum Test error found - save the configuration ; : 666 | 51.2956 40.6256 0.0201396 0.00182896 43690.5 0; : 667 Minimum Test error found - save the configuration ; : 667 | 50.7315 40.0752 0.0201193 0.00182284 43724.4 0; : 668 | 49.9429 40.0919 0.0200598 0.00176937 43738.7 1; : 669 Minimum Test error found - save the configuration ; : 669 | ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:85252,error,error,85252,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1 43774.1 0; : 822 | 8.40042 12.784 0.0200174 0.0017606 43819.3 1; : 823 | 8.60218 12.5837 0.0200326 0.00176535 43794.3 2; : 824 | 8.73942 12.9376 0.0204734 0.00180446 42851.9 3; : 825 Minimum Test error found - save the configuration ; : 825 | 8.34428 12.1043 0.0201737 0.00186372 43692 0; : 826 Minimum Test error found - save the configuration ; : 826 | 8.00332 12.0945 0.0202264 0.00188916 43627.1 0; : 827 Minimum Test error found - save the configuration ; : 827 | 7.99254 11.726 0.0202903 0.00182656 43328.1 0; : 828 | 7.97363 11.7656 0.0202489 0.00176045 43270.2 1; : 829 | 7.98909 11.7293 0.0200352 0.00175475 43762.5 2; : 830 | 7.96378 12.2512 0.0200553 0.00175667 43719.1 3; : 831 Minimum Test error found - save the configuration ; : 831 | 8.22376 11.6427 0.0201223 0.00181824 43706.2 0; : 832 Minimum Test error found - save the configuration ; : 832 | 7.83287 11.3952 0.0201042 0.0018127 43736.1 0; : 833 | 7.77712 11.6148 0.0201377 0.00175591 43521.3 1; : 834 Minimum Test error found - save the configuration ; : 834 | 7.55905 11.3034 0.0200924 0.00180566 43747.5 0; : 835 | 7.51796 11.4086 0.0200653 0.00174972 43678.7 1; : 836 | 7.6539 11.6743 0.0201454 0.00175856 43509.3 2; : 837 | 7.98319 11.3225 0.0201169 0.00175643 43571.8 3; : 838 | 7.66699 11.6657 0.0201662 0.00181142 43585.5 4; : 839 Minimum Test error found - save the configuration ; : 839 | 7.52525 10.9666 0.0202646 0.00182844 43392.9 0; : 840 | 7.48548 11.313 0.020051 0.00174873 43710.5 1; : 841 | 7.28024 11.1847 0.0200374 0.0017493 43744.4 2; : 842 | 7.18939 11.0082 0.0200397 0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:101098,error,error,101098,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1 7; : 992 | 3.45322 4.61211 0.0200841 0.00175232 43640 8; : 993 | 3.32586 4.54016 0.0200585 0.00176018 43719.9 9; : 994 | 3.54317 4.65875 0.0201539 0.00181263 43617.4 10; : 995 | 3.38008 5.03795 0.0206532 0.00179392 42419.4 11; : 996 | 3.40103 4.41295 0.0204644 0.00176564 42783.5 12; : 997 | 3.23461 4.8031 0.0203306 0.00176616 43093.1 13; : 998 | 3.41797 4.46788 0.0203618 0.00175568 42996.7 14; : 999 Minimum Test error found - save the configuration ; : 999 | 3.31412 4.14973 0.0202938 0.00187677 43438 0; : 1000 | 3.20867 4.17264 0.0201802 0.00179416 43511.4 1; : 1001 | 3.31742 4.17699 0.020287 0.00175118 43159.8 2; : 1002 | 3.35839 4.8143 0.0207434 0.00177731 42180.6 3; : 1003 Minimum Test error found - save the configuration ; : 1003 | 3.42381 4.04915 0.0202591 0.00184351 43441.4 0; : 1004 Minimum Test error found - save the configuration ; : 1004 | 3.27488 4.0384 0.0205262 0.00189376 42935.9 0; : 1005 | 3.09776 4.19224 0.0200956 0.00176781 43649.6 1; : 1006 Minimum Test error found - save the configuration ; : 1006 | 3.1757 3.91876 0.0201134 0.00183093 43757.7 0; : 1007 | 3.17471 4.33126 0.0203423 0.00178093 43100.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.151,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:113601,error,error,113601,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(ESlaves list, Long_t timeout, Int_t endtype, Bool_t deactonfail); Collect responses from the slave servers. Returns the number of slaves; that responded.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. Int_t Collect(TMonitor* mon, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect responses from the slave servers. Returns the number of messages; received. Can be 0 if there are no active slaves.; If timeout >= 0, wait at most timeout seconds (timeout = -1 by default,; which means wait forever).; If defined (>= 0) endtype is the message that stops this collection. void CleanGDirectory(TList* ol); Remove links to objects in list 'ol' from gDirectory. Int_t CollectInputFrom(TSocket* s, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Collect and analyze available input from socket s.; Returns 0 on success, -1 if any failure occurs. Int_t HandleInputMessage(TSlave* wrk, TMessage* m, Bool_t deactonfail = kFALSE); Analyze the received message.; Returns 0 on success (1 if this the last message from this socket), -1 if; any failure occurs. void HandleSubmerger(TMessage* mess, TSlave* sl); Process a message of type kPROOF_SUBMERGER. void RedirectWorker(TSocket* s, TSlave* sl, Int_t output_size); Redirect output of worker sl to some merger. Int_t FindNextFreeMerger(); Return a merger, which is both active and still accepts some workers to be; assigned to it. It works on the 'round-robin' basis. void AskForOutput(TSlave* sl); Master asks for output from worker sl. void UpdateDialog(); Final update of the progress dialog. void ActivateAsyncInput(); Activate the a-sync input handler. void DeActivateAsyncInput(); De-activate a-sync input handler. Int_t GetActiveMergersCount(); Get the active mergers count. B",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:43228,avail,available,43228,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['avail'],['available']
Availability,"1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Bool_t IsUseable() const; Check the file is open and isn't a zombie. Bool_t GetVectorReadLimits(); Find the server-specific readv config params. Returns kFALSE in case of; error, kTRUE otherwise. void SetEnv(); Map ROOT and xrootd environment variables. TNetXNGFile(); {}. TNetXNGFile(const char* url, Option_t* mode = """", const char* title = """", Int_t compress = 1, Int_t netopt = 0, Bool_t parallelopen = kFALSE). TString GetNewUrl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TNetXNGFile.html:25211,failure,failure,25211,root/html534/TNetXNGFile.html,https://root.cern,https://root.cern/root/html534/TNetXNGFile.html,2,['failure'],['failure']
Availability,"1 in case; the mode did not change (was already as requested or wrong; input arguments) and -1 in case of failure, in which case; the file cannot be used anymore. Bool_t ReadBuffer(char* buffer, Int_t length); Read a data chunk of the given size. param buffer: a pointer to a buffer big enough to hold the data; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffer(char* buffer, Long64_t position, Int_t length); Read a data chunk of the given size, starting from the given offset. param buffer: a pointer to a buffer big enough to hold the data; param position: offset from the beginning of the file; param length: number of bytes to be read; returns: kTRUE in case of failure. Bool_t ReadBuffers(char* buffer, Long64_t* position, Int_t* length, Int_t nbuffs); Read scattered data chunks in one operation. param buffer: a pointer to a buffer big enough to hold all of the; requested data; param position: position[i] is the seek position of chunk i of len; length[i]; param length: length[i] is the length of the chunk at offset; position[i]; param nbuffs: number of chunks; returns: kTRUE in case of failure. Bool_t WriteBuffer(const char* buffer, Int_t length); Write a data chunk. param buffer: the data to be written; param length: the size of the buffer; returns: kTRUE in case of failure. void Flush(). void Seek(Long64_t offset, TFile::ERelativeTo position = kBeg); Set the position within the file. param offset: the new offset relative to position; param position: the relative position, either kBeg, kCur or kEnd. Int_t ParseOpenMode(Option_t* in, TString& modestr, XrdCl::OpenFlags::Flags& mode, Bool_t assumeRead); Parse a file open mode given as a string into a canonically formatted; output mode string and an integer code that the xroot client can use. param in: the file open mode as a string (in); modestr: open mode string after parsing (out); mode: correctly parsed option mode code (out); assumeRead: if the open mode is not recognised a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TNetXNGFile.html:26559,failure,failure,26559,root/html602/TNetXNGFile.html,https://root.cern,https://root.cern/root/html602/TNetXNGFile.html,4,['failure'],['failure']
Availability,1 nsig=145.338 sig1frac=0.822833; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-798.509) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.791035 a1=-0.287544 mean=4.98693 nbkg=127.577 nsig=149.203 sig1frac=0.914567; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 410; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 400; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 390; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-977.775) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.565967 a1=-0.529635 mean=5.0065 nbkg=153.38 nsig=185.083 sig1frac=0.751239; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 380; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 370; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-945.036) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.824344 a1=-0.338546 mean=5.06339 nbkg=161.705 nsig=169.087 sig1frac=0.910016; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 360; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 350; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 340; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 330; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 320; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 310; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-831.776) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.823781 a1=-0.287947 mean=4.96347 nbkg=133.185 nsig=155.535 sig1,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:20402,error,errors,20402,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,4,['error'],"['error', 'errors']"
Availability,"1 of file GSLMultiRootFinder.cxx. ◆ GetGSLType(). const gsl_multiroot_fsolver_type * ROOT::Math::GetGSLType ; (; GSLMultiRootFinder::EType ; type). Definition at line 183 of file GSLMultiRootFinder.cxx. ◆ getSum(). int ROOT::Math::getSum ; (; const int * ; x, . int ; n . ). Definition at line 534 of file GoFTest.cxx. ◆ human_readable(). template<class char_t , class traits_t > . std::basic_ios< char_t, traits_t > & ROOT::Math::human_readable ; (; std::basic_ios< char_t, traits_t > & ; ios). inline . Definition at line 197 of file GenVectorIO.h. ◆ Lmag(). template<class A , class T > . T ROOT::Math::Lmag ; (; const VecExpr< A, T, 4 > & ; rhs). inline . Definition at line 308 of file Functions.h. ◆ Lmag2(). template<class A , class T > . T ROOT::Math::Lmag2 ; (; const VecExpr< A, T, 4 > & ; rhs). inline . Definition at line 284 of file Functions.h. ◆ log1p(). double ROOT::Math::log1p ; (; double ; x). inline . declarations for functions which are not implemented by some compilers ; log(1+x) with error cancelation when x is small ; Definition at line 98 of file Math.h. ◆ machine_readable(). template<class char_t , class traits_t > . std::basic_ios< char_t, traits_t > & ROOT::Math::machine_readable ; (; std::basic_ios< char_t, traits_t > & ; ios). inline . Definition at line 208 of file GenVectorIO.h. ◆ Mag(). template<class A , class T , unsigned int D> . T ROOT::Math::Mag ; (; const VecExpr< A, T, D > & ; rhs). inline . Definition at line 261 of file Functions.h. ◆ Mag2(). template<class A , class T , unsigned int D> . T ROOT::Math::Mag2 ; (; const VecExpr< A, T, D > & ; rhs). inline . Definition at line 238 of file Functions.h. ◆ minfunction(). double ROOT::Math::minfunction ; (; const std::vector< double > & ; x). function to return the function values at point x ; Definition at line 19 of file RMinimizer.cxx. ◆ mingradfunction(). TVectorD ROOT::Math::mingradfunction ; (; TVectorD ; y). function to return the gradient values at point y ; Definition at line 25 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/namespaceROOT_1_1Math.html:153674,error,error,153674,doc/v632/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/v632/namespaceROOT_1_1Math.html,1,['error'],['error']
Availability,"1 of file TProof.cxx. ◆ SetMaxDrawQueries(). void TProof::SetMaxDrawQueries ; (; Int_t ; max). Set max number of draw queries whose results are saved. ; Definition at line 2115 of file TProof.cxx. ◆ SetMonitor(). void TProof::SetMonitor ; (; TMonitor * ; mon = 0, . Bool_t ; on = kTRUE . ). private . Activate (on == TRUE) or deactivate (on == FALSE) all sockets monitored by 'mon'. ; Definition at line 2408 of file TProof.cxx. ◆ SetParallel(). Int_t TProof::SetParallel ; (; Int_t ; nodes = -1, . Bool_t ; random = kFALSE . ). Tell PROOF how many slaves to use in parallel. ; Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7140 of file TProof.cxx. ◆ SetParallelSilent(). Int_t TProof::SetParallelSilent ; (; Int_t ; nodes, . Bool_t ; random = kFALSE . ). private . Tell PROOF how many slaves to use in parallel. ; If random is TRUE a random selection is done (if nodes is less than the available nodes). Returns the number of parallel slaves. Returns -1 in case of error. ; Definition at line 7112 of file TProof.cxx. ◆ SetParameter() [1/5]. void TProof::SetParameter ; (; const char * ; par, . const char * ; value . ). Set input list parameter. ; If the parameter is already set it will be set to the new value. ; Definition at line 9822 of file TProof.cxx. ◆ SetParameter() [2/5]. void TProof::SetParameter ; (; const char * ; par, . Double_t ; value . ). Set an input list parameter. ; Definition at line 9898 of file TProof.cxx. ◆ SetParameter() [3/5]. void TProof::SetParameter ; (; const char * ; par, . Int_t ; value . ). Set an input list parameter. ; Definition at line 9841 of file TProof.cxx. ◆ SetParameter() [4/5]. void TProof::SetParameter ; (; const char * ; par, . Long64_t ; value . ). Set an input list parameter. ; Definition at line 9879 of file TProof.cxx. ◆ SetParameter() [5/5]. void TProof::SetParameter ; (; const char * ; par, . Long_t ; value . ). Set an input list parameter. ; Definition at line 9860 of file TProof.cxx. ◆ SetP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:145119,error,error,145119,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['error'],['error']
Availability,"1 of file TProofPlayerLite.cxx. ◆ Finalize() [2/2]. Long64_t TProofPlayerLite::Finalize ; (; TQueryResult * ; qr). inlineoverridevirtual . Finalize query (may not be used in this class). ; Reimplemented from TProofPlayer.; Definition at line 48 of file TProofPlayerLite.h. ◆ HandleTimer(). Bool_t TProofPlayerLite::HandleTimer ; (; TTimer * ; timer). overrideprotectedvirtual . Send feedback objects to client. ; Reimplemented from TObject.; Definition at line 442 of file TProofPlayerLite.cxx. ◆ IsA(). TClass * TProofPlayerLite::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TProofPlayer.; Definition at line 53 of file TProofPlayerLite.h. ◆ MakeSelector(). Int_t TProofPlayerLite::MakeSelector ; (; const char * ; selfile). protected . Create the selector object and save the relevant files and binary information in the cache so that the worker can pick it up. ; Returns 0 and fill fSelector in case of success. Returns -1 and sets fSelector to 0 in case of failure. ; Definition at line 45 of file TProofPlayerLite.cxx. ◆ Process() [1/2]. Long64_t TProofPlayerLite::Process ; (; TDSet * ; dset, . const char * ; selector_file, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master. The return value is -1 in case of error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProofPlayer.; Definition at line 109 of file TProofPlayerLite.cxx. ◆ Process() [2/2]. Long64_t TProofPlayerLite::Process ; (; TDSet * ; dset, . TSelector * ; selector, . Option_t * ; option = """", . Long64_t ; nentries = -1, . Long64_t ; first = 0 . ). overridevirtual . Process specified TDSet on PROOF. ; This method is called on client and on the PROOF master. The return value is -1 in case of an error and TSelector::GetStatus() in in case of success. ; Reimplemented from TProofPlayer.; Definition a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofPlayerLite.html:29550,failure,failure,29550,doc/master/classTProofPlayerLite.html,https://root.cern,https://root.cern/doc/master/classTProofPlayerLite.html,1,['failure'],['failure']
Availability,"1 return fTree->GetLeaf(branchname, leafname);; 1092 }; 1093 return nullptr;; 1094}; 1095 ; 1096////////////////////////////////////////////////////////////////////////////////; 1097/// Return a pointer to the leaf name in the current tree.; 1098 ; 1099TLeaf* TChain::GetLeaf(const char* name); 1100{; 1101 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1102 // Make sure the element list is up to date; 1103 if (!TestBit(kProofUptodate)); 1104 SetProof(true, true);; 1105 return fProofChain->GetLeaf(name);; 1106 }; 1107 if (fTree) {; 1108 return fTree->GetLeaf(name);; 1109 }; 1110 LoadTree(0);; 1111 if (fTree) {; 1112 return fTree->GetLeaf(name);; 1113 }; 1114 return nullptr;; 1115}; 1116 ; 1117////////////////////////////////////////////////////////////////////////////////; 1118/// Return a pointer to the list of branches of the current tree.; 1119///; 1120/// Warning: If there is no current TTree yet, this routine will open the; 1121/// first in the chain.; 1122///; 1123/// Returns 0 on failure.; 1124 ; 1125TObjArray* TChain::GetListOfBranches(); 1126{; 1127 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1128 // Make sure the element list is up to date; 1129 if (!TestBit(kProofUptodate)); 1130 SetProof(true, true);; 1131 return fProofChain->GetListOfBranches();; 1132 }; 1133 if (fTree) {; 1134 return fTree->GetListOfBranches();; 1135 }; 1136 LoadTree(0);; 1137 if (fTree) {; 1138 return fTree->GetListOfBranches();; 1139 }; 1140 return nullptr;; 1141}; 1142 ; 1143////////////////////////////////////////////////////////////////////////////////; 1144/// Return a pointer to the list of leaves of the current tree.; 1145///; 1146/// Warning: May set the current tree!; 1147 ; 1148TObjArray* TChain::GetListOfLeaves(); 1149{; 1150 if (fProofChain && !(fProofChain->TestBit(kProofLite))) {; 1151 // Make sure the element list is up to date; 1152 if (!TestBit(kProofUptodate)); 1153 SetProof(true, true);; 1154 return fProofChain->GetListOfLeaves();; 1155 }; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:41777,failure,failure,41777,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['failure'],['failure']
Availability,"1 same"");; 207 ; 208 ; 209The default drawing option can be set with `TH1::SetOption` and retrieve; 210using `TH1::GetOption`:; 211 ; 212 root [0] h->Draw(); // Draw ""h"" using the standard histogram representation.; 213 root [1] h->Draw(""E""); // Draw ""h"" using error bars; 214 root [3] h->SetOption(""E""); // Change the default drawing option for ""h""; 215 root [4] h->Draw(); // Draw ""h"" using error bars; 216 root [5] h->GetOption(); // Retrieve the default drawing option for ""h""; 217 (const Option_t* 0xa3ff948)""E""; 218 ; 219 ; 220\anchor HP01a; 221#### Options supported for 1D and 2D histograms; 222 ; 223| Option | Description |; 224|----------|-------------------------------------------------------------------|; 225| ""E"" | Draw error bars. |; 226| ""AXIS"" | Draw only axis. |; 227| ""AXIG"" | Draw only grid (if the grid is requested). |; 228| \anchor OPTHIST ""HIST"" | When an histogram has errors it is visualized by default with error bars. To visualize it without errors use the option ""HIST"" together with the required option (eg ""hist same c""). The ""HIST"" option can also be used to plot only the histogram and not the associated function(s). |; 229| ""FUNC"" | When an histogram has a fitted function, this option allows to draw the fit result only. |; 230| ""SAME"" | Superimpose on previous picture in the same pad. |; 231| ""SAMES"" | Same as ""SAME"" and draw the statistics box|; 232| ""PFC"" | Palette Fill Color: histogram's fill color is taken in the current palette. |; 233| ""PLC"" | Palette Line Color: histogram's line color is taken in the current palette. |; 234| ""PMC"" | Palette Marker Color: histogram's marker color is taken in the current palette. |; 235| ""LEGO"" | Draw a lego plot with hidden line removal. |; 236| ""LEGO1"" | Draw a lego plot with hidden surface removal. |; 237| ""LEGO2"" | Draw a lego plot using colors to show the cell contents When the option ""0"" is used with any LEGO option, the empty bins are not drawn.|; 238| ""LEGO3"" | Draw a lego plot with hidden surface remo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:8898,error,errors,8898,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['error'],['errors']
Availability,"1 }; 2812}; 2813 ; 2814////////////////////////////////////////////////////////////////////////////////; 2815/// Compute distance from point px,py to a line.; 2816///; 2817/// Compute the closest distance of approach from point px,py to elements; 2818/// of a histogram.; 2819/// The distance is computed in pixels units.; 2820///; 2821/// #### Algorithm:; 2822/// Currently, this simple model computes the distance from the mouse; 2823/// to the histogram contour only.; 2824 ; 2825Int_t TH1::DistancetoPrimitive(Int_t px, Int_t py); 2826{; 2827 if (!fPainter) return 9999;; 2828 return fPainter->DistancetoPrimitive(px,py);; 2829}; 2830 ; 2831////////////////////////////////////////////////////////////////////////////////; 2832/// Performs the operation: `this = this/(c1*f1)`; 2833/// if errors are defined (see TH1::Sumw2), errors are also recalculated.; 2834///; 2835/// Only bins inside the function range are recomputed.; 2836/// IMPORTANT NOTE: If you intend to use the errors of this histogram later; 2837/// you should call Sumw2 before making this operation.; 2838/// This is particularly important if you fit the histogram after TH1::Divide; 2839///; 2840/// The function return kFALSE if the divide operation failed; 2841 ; 2842Bool_t TH1::Divide(TF1 *f1, Double_t c1); 2843{; 2844 if (!f1) {; 2845 Error(""Divide"",""Attempt to divide by a non-existing function"");; 2846 return kFALSE;; 2847 }; 2848 ; 2849 // delete buffer if it is there since it will become invalid; 2850 if (fBuffer) BufferEmpty(1);; 2851 ; 2852 Int_t nx = GetNbinsX() + 2; // normal bins + uf / of; 2853 Int_t ny = GetNbinsY() + 2;; 2854 Int_t nz = GetNbinsZ() + 2;; 2855 if (fDimension < 2) ny = 1;; 2856 if (fDimension < 3) nz = 1;; 2857 ; 2858 ; 2859 SetMinimum();; 2860 SetMaximum();; 2861 ; 2862 // - Loop on bins (including underflows/overflows); 2863 Int_t bin, binx, biny, binz;; 2864 Double_t cu, w;; 2865 Double_t xx[3];; 2866 Double_t *params = nullptr;; 2867 f1->InitArgs(xx,params);; 2868 for (binz = 0;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:112710,error,errors,112710,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"1"", -0.5, -10., 20.);; RooRealVar a2(""a2"", ""a2"", 0.2, -10., 20.);; RooRealVar a3(""a3"", ""a3"", 0.01);; RooPolynomial pdf(""pol3"", ""c + a1 * x + a2 * x*x + 0.01 * x*x*x"", x, RooArgSet(a1, a2, a3));; ; // Create toy data with all-positive coefficients:; std::unique_ptr<RooDataSet> data(pdf.generate(x, 10000));; ; // For plotting.; // We create pointers to the plotted objects. We want these objects to leak out of the function,; // so we can still see them after it returns.; TCanvas* c = new TCanvas();; RooPlot* frame = x.frame();; data->plotOn(frame, RooFit::Name(""data""));; ; // Plotting a PDF with disallowed parameters doesn't work. We would get a lot of error messages.; // Therefore, we disable plotting messages in RooFit's message streams:; RooMsgService::instance().getStream(0).removeTopic(RooFit::Plotting);; RooMsgService::instance().getStream(1).removeTopic(RooFit::Plotting);; ; ; // RooFit before ROOT 6.24; // --------------------------------; // Before 6.24, RooFit wasn't able to recover from invalid parameters. The minimiser just errs around; // the starting values of the parameters without finding any improvement.; ; // Set up the parameters such that the PDF would come out negative. The PDF is now undefined.; a1.setVal(10.);; a2.setVal(-1.);; ; // Perform a fit:; std::unique_ptr<RooFitResult> fitWithoutRecovery{pdf.fitTo(*data, RooFit::Save(),; RooFit::RecoverFromUndefinedRegions(0.), // This is how RooFit behaved prior to ROOT 6.24; RooFit::PrintEvalErrors(-1), // We are expecting a lot of evaluation errors. -1 switches off printing.; RooFit::PrintLevel(-1))};; ; pdf.plotOn(frame, RooFit::LineColor(kRed), RooFit::Name(""noRecovery""));; ; ; ; // RooFit since ROOT 6.24; // --------------------------------; // The minimiser gets information about the ""badness"" of the violation of the function definition. It uses this; // to find its way out of the disallowed parameter regions.; std::cout << ""\n\n\n-------------- Starting second fit ---------------\n\n"" << std::end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html:3286,recover,recover,3286,doc/master/rf612__recoverFromInvalidParameters_8C.html,https://root.cern,https://root.cern/doc/master/rf612__recoverFromInvalidParameters_8C.html,1,['recover'],['recover']
Availability,"1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:670; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; Return status:. The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1 . Definition at line 9692 of file TTree.cxx. ◆ UseCurrentStyle(). void TTree::UseCurrentStyle ; (; ). overridevirtual . Replace current attributes by current style. ; Reimplemented from TObject.; Definition at line 9704 of file TTree.cxx. ◆ Write() [1/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ); const. overridevirtual . Write this object to the current directory. ; For more see TObject::Write If option & kFlushBasket, call FlushBasket before writing the tree. ; Reimplemented from TObject.; Definition at line 9731 of file TTree.cxx. ◆ Write() [2/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ). overridevirtual . Write this object to the current directory. ; For more see TObject::Wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:221895,error,error,221895,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['error'],['error']
Availability,"1(""f1"", ""gaus(0)/sqrt(2*3.14159)/[2]"", 0, 5);; f1->SetParameters(1, 3.1, 0.01);; f1->SetParLimits(0, 1, 1); // fix the normalization parameter to 1; data->UnbinnedFit(""f1"", ""jpsimass"", ""jpsipt>3.0"");; dataOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void dataDefinition TGWin32VirtualXProxy.cxx:104; TF11-Dim function classDefinition TF1.h:233; TF1::SetParLimitsvirtual void SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax)Set lower and upper limits for parameter ipar.Definition TF1.cxx:3507; TF1::SetParametersvirtual void SetParameters(const Double_t *params)Definition TF1.h:677; 1, 2 and 3 Dimensional fits are supported. See also TTree::Fit; Return status:. The function return the status of the fit in the following form fitResult = migradResult + 10*minosResult + 100*hesseResult + 1000*improveResult; The fitResult is 0 is the fit is OK.; The fitResult is negative in case of an error not connected with the fit.; The number of entries used in the fit can be obtained via mytree.GetSelectedRows();; If the number of selected entries is null the function returns -1 . Definition at line 9702 of file TTree.cxx. ◆ UseCurrentStyle(). void TTree::UseCurrentStyle ; (; ). overridevirtual . Replace current attributes by current style. ; Reimplemented from TObject.; Definition at line 9714 of file TTree.cxx. ◆ Write() [1/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ); const. overridevirtual . Write this object to the current directory. ; For more see TObject::Write If option & kFlushBasket, call FlushBasket before writing the tree. ; Reimplemented from TObject.; Definition at line 9741 of file TTree.cxx. ◆ Write() [2/2]. Int_t TTree::Write ; (; const char * ; name = nullptr, . Int_t ; option = 0, . Int_t ; bufsize = 0 . ). overridevirtual . Write this object to the current directory. ; For more see TObject::Wr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:224858,error,error,224858,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['error'],['error']
Availability,"1(const char* name, const char* title, Int_t nbinsx, const Double_t* xbins); -*-*-*-*-*Normal constructor for variable bin size histograms*-*-*-*-*-*-*. Creates the main histogram structure:; name : name of histogram (avoid blanks); title : histogram title; if title is of the form ""stringt;stringx;stringy;stringz""; the histogram title is set to stringt,; the x axis title to stringx, the y axis title to stringy, etc.; nbins : number of bins; xbins : array of low-edges for each bin; This is an array of size nbins+1. -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*. TH1(const TH1& ); Copy constructor.; The list of functions is not copied. (Use Clone if needed). Bool_t AddDirectoryStatus(); static function: cannot be inlined on Windows/NT. void Browse(TBrowser* b); Browe the Histogram object. void Build(); -*-*-*-*-*-*-*-*Creates histogram basic data structure*-*-*-*-*-*-*-*-*-*. Bool_t Add(TF1* h1, Double_t c1 = 1, Option_t* option = """"); Performs the operation: this = this + c1*f1; if errors are defined (see TH1::Sumw2), errors are also recalculated. By default, the function is computed at the centre of the bin.; if option ""I"" is specified (1-d histogram only), the integral of the; function in each bin is used instead of the value of the function at; the centre of the bin.; Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Add. The function return kFALSE if the Add operation failed. Bool_t Add(const TH1* h1, Double_t c1 = 1); Performs the operation: this = this + c1*h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; Note also that adding histogram with labels is not supported, histogram will be; added merging them by bin number independen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TH1.html:41194,error,errors,41194,root/html534/TH1.html,https://root.cern,https://root.cern/root/html534/TH1.html,4,['error'],['errors']
Availability,"1) >= 1) {; 2182 Warning(""Chi2TestX"",""First histogram is not unweighted and option UW has been requested"");; 2183 }; 2184 }; 2185 if ( (!scaledHistogram && comparisonUU) ) {; 2186 if ( ( TMath::Abs(sumBinContent1 - effEntries1) >= 1) || (TMath::Abs(sumBinContent2 - effEntries2) >= 1) ) {; 2187 Warning(""Chi2TestX"",""Both histograms are not unweighted and option UU has been requested"");; 2188 }; 2189 }; 2190 ; 2191 ; 2192 //get number of events in histogram; 2193 if (comparisonUU && scaledHistogram) {; 2194 for (Int_t i = i_start; i <= i_end; ++i) {; 2195 for (Int_t j = j_start; j <= j_end; ++j) {; 2196 for (Int_t k = k_start; k <= k_end; ++k) {; 2197 ; 2198 Int_t bin = GetBin(i, j, k);; 2199 ; 2200 Double_t cnt1 = RetrieveBinContent(bin);; 2201 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2202 Double_t e1sq = GetBinErrorSqUnchecked(bin);; 2203 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2204 ; 2205 if (e1sq > 0.0) cnt1 = TMath::Floor(cnt1 * cnt1 / e1sq + 0.5); // avoid rounding errors; 2206 else cnt1 = 0.0;; 2207 ; 2208 if (e2sq > 0.0) cnt2 = TMath::Floor(cnt2 * cnt2 / e2sq + 0.5); // avoid rounding errors; 2209 else cnt2 = 0.0;; 2210 ; 2211 // sum contents; 2212 sum1 += cnt1;; 2213 sum2 += cnt2;; 2214 sumw1 += e1sq;; 2215 sumw2 += e2sq;; 2216 }; 2217 }; 2218 }; 2219 if (sumw1 <= 0.0 || sumw2 <= 0.0) {; 2220 Error(""Chi2TestX"", ""Cannot use option NORM when one histogram has all zero errors"");; 2221 return 0.0;; 2222 }; 2223 ; 2224 } else {; 2225 for (Int_t i = i_start; i <= i_end; ++i) {; 2226 for (Int_t j = j_start; j <= j_end; ++j) {; 2227 for (Int_t k = k_start; k <= k_end; ++k) {; 2228 ; 2229 Int_t bin = GetBin(i, j, k);; 2230 ; 2231 sum1 += RetrieveBinContent(bin);; 2232 sum2 += h2->RetrieveBinContent(bin);; 2233 ; 2234 if ( comparisonWW ) sumw1 += GetBinErrorSqUnchecked(bin);; 2235 if ( comparisonUW || comparisonWW ) sumw2 += h2->GetBinErrorSqUnchecked(bin);; 2236 }; 2237 }; 2238 }; 2239 }; 2240 //checks that the histograms are not empty; 2241 if (sum1 == 0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:89550,error,errors,89550,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH2.; 2829 ; 2830void TH2::Streamer(TBuffer &R__b); 2831{; 2832 if (R__b.IsReading()) {; 2833 UInt_t R__s, R__c;; 2834 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2835 if (R__v > 2) {; 2836 R__b.ReadClassBuffer(TH2::Class(), this, R__v, R__s, R__c);; 2837 return;; 2838 }; 2839 //====process old versions before automatic schema evolution; 2840 TH1::Streamer(R__b);; 2841 R__b >> fScalefactor;; 2842 R__b >> fTsumwy;; 2843 R__b >> fTsumwy2;; 2844 R__b >> fTsumwxy;; 2845 //====end of old versions; 2846 ; 2847 } else {; 2848 R__b.WriteClassBuffer(TH2::Class(),this);; 2849 }; 2850}; 2851 ; 2852 ; 2853//______________________________________________________________________________; 2854// TH2C methods; 2855// TH2C a 2-D histogram with one byte per cell (char); 2856//______________________________________",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:114672,error,error,114672,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,2,['error'],['error']
Availability,"1); 4614 ((TBranch *)fBranches.UncheckedAt(0))->UpdateAddress();; 4615 ; 4616 if (fBranchRef); 4617 fBranchRef->Clear();; 4618 ; 4619#ifdef R__USE_IMT; 4620 const auto useIMT = ROOT::IsImplicitMTEnabled() && fIMTEnabled;; 4621 ROOT::Internal::TBranchIMTHelper imtHelper;; 4622 if (useIMT) {; 4623 fIMTFlush = true;; 4624 fIMTZipBytes.store(0);; 4625 fIMTTotBytes.store(0);; 4626 }; 4627#endif; 4628 ; 4629 for (Int_t i = 0; i < nbranches; ++i) {; 4630 // Loop over all branches, filling and accumulating bytes written and error counts.; 4631 TBranch *branch = (TBranch *)fBranches.UncheckedAt(i);; 4632 ; 4633 if (branch->TestBit(kDoNotProcess)); 4634 continue;; 4635 ; 4636#ifndef R__USE_IMT; 4637 nwrite = branch->FillImpl(nullptr);; 4638#else; 4639 nwrite = branch->FillImpl(useIMT ? &imtHelper : nullptr);; 4640#endif; 4641 if (nwrite < 0) {; 4642 if (nerror < 2) {; 4643 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld\n""; 4644 "" This error is symptomatic of a Tree created as a memory-resident Tree\n""; 4645 "" Instead of doing:\n""; 4646 "" TTree *T = new TTree(...)\n""; 4647 "" TFile *f = new TFile(...)\n""; 4648 "" you should do:\n""; 4649 "" TFile *f = new TFile(...)\n""; 4650 "" TTree *T = new TTree(...)\n\n"",; 4651 GetName(), branch->GetName(), nwrite, fEntries + 1);; 4652 } else {; 4653 Error(""Fill"", ""Failed filling branch:%s.%s, nbytes=%d, entry=%lld"", GetName(), branch->GetName(), nwrite,; 4654 fEntries + 1);; 4655 }; 4656 ++nerror;; 4657 } else {; 4658 nbytes += nwrite;; 4659 }; 4660 }; 4661 ; 4662#ifdef R__USE_IMT; 4663 if (fIMTFlush) {; 4664 imtHelper.Wait();; 4665 fIMTFlush = false;; 4666 const_cast<TTree *>(this)->AddTotBytes(fIMTTotBytes);; 4667 const_cast<TTree *>(this)->AddZipBytes(fIMTZipBytes);; 4668 nbytes += imtHelper.GetNbytes();; 4669 nerror += imtHelper.GetNerrors();; 4670 }; 4671#endif; 4672 ; 4673 if (fBranchRef); 4674 fBranchRef->Fill();; 4675 ; 4676 ++fEntries;; 4677 ; 4678 if (fEntries > fMaxEntries); 4679 KeepCircular();; 4680 ; 4681 if (gD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:188401,error,error,188401,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['error'],['error']
Availability,"1);; for (i = 0; i < nbins; i++) response[i]=d->GetBinContent(i + 1);; TCanvas *Decon1 = gROOT->GetListOfCanvases()->FindObject(""Decon1"");; if (!Decon1) Decon1 = new TCanvas(""Decon1"",; ""Deconvolution of closely positioned overlapping peaks using boosted Gold deconvolution method"",10,10,1000,700);; h->SetMaximum(110000);; h->Draw(""L"");; TSpectrum *s = new TSpectrum();; s->Deconvolution(source,response,256,200,50,1.2);; for (i = 0; i < nbins; i++) d->SetBinContent(i + 1,source[i]);; d->SetLineColor(kRed);; d->Draw(""SAME L"");; }; ; . const char * DeconvolutionRL(Double_t* source, const Double_t* response, Int_t ssize, Int_t numberIterations, Int_t numberRepetitions, Double_t boost). One-dimensional deconvolution function. This function calculates deconvolution from source spectrum according to; response spectrum using Richardson-Lucy deconvolution algorithm. The result; is placed in the vector pointed by source pointer. On successful completion; it returns 0. On error it returns pointer to the string describing error.; If desired after every numberIterations one can apply boosting operation; (exponential function with exponent given by boost coefficient) and repeat; it numberRepetitions times (see Gold deconvolution).; ; Function parameters:; ; source: pointer to the vector of source spectrum; response: pointer to the vector of response spectrum; ssize: length of source and response spectra; numberIterations, for details we refer to the reference given above; numberRepetitions, for repeated boosted deconvolution; boost, boosting coefficient; . Richardson-Lucy deconvolution algorithm:. For discrete systems it has the form:; . for positive input data and response matrix this iterative method forces; the deconvoluted spectra to be non-negative. The Richardson-Lucy; iteration converges to the maximum likelihood solution for Poisson statistics; in the data.; ; References:. Abreu M.C. et al., A four-dimensional deconvolution method to correct NA38; experimental data, NIM A 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:42949,error,error,42949,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,8,['error'],['error']
Availability,"1)MENU ; virtual voidTF1::SetMinimum(Double_t minimum = -1111)MENU ; virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); virtual voidTF1::SetNDF(Int_t ndf); virtual voidTF1::SetNormalized(Bool_t flag); virtual voidTF1::SetNpx(Int_t npx = 100)MENU ; virtual voidTF2::SetNpy(Int_t npy = 100)MENU ; virtual voidSetNpz(Int_t npz = 30); virtual voidTF1::SetNumberFitPoints(Int_t npfits); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTF1::SetParameter(Int_t param, Double_t value); virtual voidTF1::SetParameter(const TString& name, Double_t value); virtual voidTF1::SetParameters(const Double_t* params); virtual voidTF1::SetParameters(Double_t p0, Double_t p1, Double_t p2 = 0, Double_t p3 = 0, Double_t p4 = 0, Double_t p5 = 0, Double_t p6 = 0, Double_t p7 = 0, Double_t p8 = 0, Double_t p9 = 0, Double_t p10 = 0)MENU ; virtual voidTF1::SetParent(TObject* p = 0); virtual voidTF1::SetParError(Int_t ipar, Double_t error); virtual voidTF1::SetParErrors(const Double_t* errors); virtual voidTF1::SetParLimits(Int_t ipar, Double_t parmin, Double_t parmax); virtual voidTF1::SetParName(Int_t ipar, const char* name); virtual voidTF1::SetParNames(const char* name0 = ""p0"", const char* name1 = ""p1"", const char* name2 = ""p2"", const char* name3 = ""p3"", const char* name4 = ""p4"", const char* name5 = ""p5"", const char* name6 = ""p6"", const char* name7 = ""p7"", const char* name8 = ""p8"", const char* name9 = ""p9"", const char* name10 = ""p10"")MENU ; virtual voidSetRange(Double_t xmin, Double_t xmax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t xmax, Double_t ymax); virtual voidSetRange(Double_t xmin, Double_t ymin, Double_t zmin, Double_t xmax, Double_t ymax, Double_t zmax)MENU ; virtual voidTF1::SetSavedPoint(Int_t point, Double_t value); virtual voidTF1::SetTitle(const char* title = """")MENU ; virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF3.html:16103,error,error,16103,root/html604/TF3.html,https://root.cern,https://root.cern/root/html604/TF3.html,2,['error'],['error']
Availability,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoTube::DistFromOutsideS(Double_t* point, Double_t* dir, Double_t rmin, Double_t rmax, Double_t dz); static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); static voidTGeoTube::DistToTube(Double_t rsq, Double_t nsq, Double_t rdotn, Double_t radius, Double_t& b, Double_t& delta); virtual TGeoVolume*Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Double_tGetA() const; virtual const char*TGeoTube::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoTube::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; virtual Double_tGetB() const; virtual voidGetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoTube::GetByteCount() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual Double_tTGeoBBox::GetDX() const; virtual Double_tTGeoBBox::GetDY() const; virtual Double_tTGeoTube::GetDz(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoEltu.html:3154,error,error,3154,root/html528/TGeoEltu.html,https://root.cern,https://root.cern/root/html528/TGeoEltu.html,4,['error'],['error']
Availability,"1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; virtual Double_tDistFromOutside(Double_t* point, Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; static Double_tTGeoShape::DistToPhiMin(Double_t* point, Double_t* dir, Double_t s1, Double_t c1, Double_t s2, Double_t c2, Double_t sm, Double_t cm, Bool_t in = kTRUE); Double_tTGeoArb8::DistToPlane(Double_t* point, Double_t* dir, Int_t ipl, Bool_t in) const; virtual TGeoVolume*TGeoTrap::Divide(TGeoVolume* voldiv, const char* divname, Int_t iaxis, Int_t ndiv, Double_t start, Double_t step); virtual voidTGeoShape::Draw(Option_t* option = """")MENU ; virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; static Double_tTGeoShape::EpsMch(); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoShape::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tTGeoTrap::GetAlpha1() const; Double_tTGeoTrap::GetAlpha2() const; virtual const char*TGeoBBox::GetAxisName(Int_t iaxis) const; virtual Double_tTGeoArb8::GetAxisRange(Int_t iaxis, Double_t& xlo, Double_t& xhi) const; Double_tTGeoTrap::GetBl1() const; Double_tTGeoTrap::GetBl2() const; virtual voidTGeoArb8::GetBoundingCylinder(Double_t* param) const; virtual const TBuffer3D&TGeoBBox::GetBuffer3D(Int_t reqSections, Bool_t localFrame) const; virtual Int_tTGeoArb8::GetByteCount() const; Double_tTGeoArb8::GetClosestEdge(Double_t* point, Double_t* vert, Int_t& isegment) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoGtra.html:3853,error,error,3853,root/html528/TGeoGtra.html,https://root.cern,https://root.cern/root/html528/TGeoGtra.html,4,['error'],['error']
Availability,"1, Option_t* option = """"); *-*-*-*-*Multiply this profile by a constant c1*-*-*-*-*-*-*-*-*; *-* ======================================. this = c1*this. This function uses the services of TProfile::Add. void SetBinEntries(Int_t bin, Double_t w); Set the number of entries in bin*-*-*-; *-* ================================. void SetBins(Int_t nbins, Double_t xmin, Double_t xmax); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBins(Int_t nx, const Double_t* xbins); Redefine x axis parameters*-*-*-; *-* ===========================. void SetBinsLength(Int_t n = -1); Set total number of bins including under/overflow; Reallocate bin contents array. void SetBuffer(Int_t buffersize, Option_t* option = """"); set the buffer size in units of 8 bytes (double). void SetErrorOption(Option_t* option = """"); -*Set option to compute profile errors; *-* =====================================. The computation of the bin errors is based on the parameter option:; option:; ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Y),; i.e. the standard error of the bin contents.; Note that if TProfile::Approximate() is called, an approximation is used when; the spread in Y is 0 and the number of bin entries is > 0. 's' The bin errors are the standard deviations of the Y bin values; Note that if TProfile::Approximate() is called, an approximation is used when; the spread in Y is 0 and the number of bin entries is > 0. 'i' Errors are as in default case (standard errors of the bin contents); The only difference is for the case when the spread in Y is zero.; In this case for N > 0 the error is 1./SQRT(12.*N). 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; W is the sum in the bin of the weights of the profile.; This option is for combining measurements y +/- dy,; and the profile is filled with values y and weights w = 1/dy**2. See TProfile::BuildOptions for a detailed explanation of all options. void Streamer(TBuffer&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile.html:45282,error,errors,45282,root/html534/TProfile.html,https://root.cern,https://root.cern/root/html534/TProfile.html,18,['error'],"['error', 'errors']"
Availability,"1, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoNodeMatrix.html:1713,error,error,1713,root/html528/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html528/TGeoNodeMatrix.html,8,"['Error', 'error']","['Error', 'error']"
Availability,"1, i.e. fit without errors (default is false); 53 bool fExpErrors; ///< use expected errors from the function and not from the data; 54 bool fCoordErrors; ///< use errors on the x coordinates when available (default is true); 55 bool fAsymErrors; ///< use asymmetric errors in the value when available, selecting them according to the on sign of residual (default is true); 56 ; 57 ; 58};; 59 ; 60 } // end namespace Fit; 61 ; 62} // end namespace ROOT; 63 ; 64 ; 65#endif /* ROOT_Fit_DataOptions */; HFit::FitTFitResultPtr Fit(FitObject *h1, TF1 *f1, Foption_t &option, const ROOT::Math::MinimizerOptions &moption, const char *goption, ROOT::Fit::DataRange &range)Definition HFitImpl.cxx:133; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::Fit::DataOptionsDataOptions : simple structure holding the options on how the data are filled.Definition DataOptions.h:28; ROOT::Fit::DataOptions::fErrors1bool fErrors1use all errors equal to 1, i.e. fit without errors (default is false)Definition DataOptions.h:52; ROOT::Fit::DataOptions::fAsymErrorsbool fAsymErrorsuse asymmetric errors in the value when available, selecting them according to the on sign of residua...Definition DataOptions.h:55; ROOT::Fit::DataOptions::fNormBinVolumebool fNormBinVolumenormalize data by a normalized the bin volume (bin volume divided by a reference value)Definition DataOptions.h:49; ROOT::Fit::DataOptions::fUseRangebool fUseRangeuse the function range when creating the fit data (default is false)Definition DataOptions.h:51; ROOT::Fit::DataOptions::fUseEmptybool fUseEmptyuse empty bins (default is false) with a fixed error of 1Definition DataOptions.h:50; ROOT::Fit::DataOptions::fIntegralbool fIntegraluse integral of bin content instead of bin center (default is false)Definition DataOptions.h:47; ROOT::Fit::DataOptions::fExpErrorsbool fExpErrorsuse expected errors from the function and not from the dataDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataOptions_8h_source.html:2788,error,errors,2788,doc/master/DataOptions_8h_source.html,https://root.cern,https://root.cern/doc/master/DataOptions_8h_source.html,1,['error'],['errors']
Availability,"1,y1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);. TGraph *gr2 = new TGraph(n,x2,y2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. TGraph *gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");. return c1;; }; Graphs with error bars; Three classes are available to handle graphs with error bars:; TGraphErrors, TGraphAsymmErrors and TGraphBentErrors.; In addition to the drawing options previously described, the graphs with error; bars can be drawn with the following extra options:. ""Z""; By default horizonthal and vertical small lines are drawn at; the end of the error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""0""; By default, when a data point is outside the visible range along the Y axis the error; bars are not drawn. Combined with other options, this option forces error bars'; drawing for the data points outside the visible range along the Y axis. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smooth",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraphPainter.html:5281,error,error,5281,root/html530/TGraphPainter.html,https://root.cern,https://root.cern/root/html530/TGraphPainter.html,1,['error'],['error']
Availability,"1,y1);; gr1->SetLineColor(2);; gr1->SetLineWidth(1504);; gr1->SetFillStyle(3005);. TGraph *gr2 = new TGraph(n,x2,y2);; gr2->SetLineColor(4);; gr2->SetLineWidth(-2002);; gr2->SetFillStyle(3004);; gr2->SetFillColor(9);. TGraph *gr3 = new TGraph(n,x3,y3);; gr3->SetLineColor(5);; gr3->SetLineWidth(-802);; gr3->SetFillStyle(3002);; gr3->SetFillColor(2);. mg->Add(gr1);; mg->Add(gr2);; mg->Add(gr3);; mg->Draw(""AC"");. return c1;; }; Graphs with error bars; Three classes are available to handle graphs with error bars:; TGraphErrors, TGraphAsymmErrors and TGraphBentErrors.; In addition to the drawing options previously described, the graphs with error; bars can be drawn with the following extra options:. ""Z""; By default horizonthal and vertical small lines are drawn at; the end of the error bars. If option ""z"" or ""Z"" is specified,; these lines are not drawn. "">""; An arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""|>""; A filled arrow is drawn at the end of the error bars.; The size of the arrow is set to 2/3 of the marker size. ""X""; By default the error bars are drawn. If option ""X"" is specified,; the errors are not drawn. The graph with errors in drawn like a normal graph. ""||""; Only the end vertical/horizonthal lines; of the error bars are drawn. This option is interesting to superimpose; systematic errors on top of a graph with statistical errors. ""[]""; Does the same as option ""||"" except that it draws additionnal tick marks at the; end of the vertical/horizonthal lines. This makes less ambiguous plots; in case several graphs are drawn on the same picture. ""2""; Error rectangles are drawn. ""3""; A filled area is drawn through the end points of the vertical error bars. ""4""; A smoothed filled area is drawn through the end points of the vertical error; bars. gStyle->SetErrorX(dx) controls the size of the error along x.; dx = 0 removes the error along x. gStyle->SetEndErrorSize(np) controls the size of the lines; at the end o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGraphPainter.html:5281,error,error,5281,root/html528/TGraphPainter.html,https://root.cern,https://root.cern/root/html528/TGraphPainter.html,1,['error'],['error']
Availability,"1->28]; fSeekFree; Pointer to FREE data record. 21 -> 24 [29->32]; fNbytesFree; Number of bytes in FREE data record. 25 -> 28 [33->36]; nfree; Number of free data records. 29 -> 32 [37->40]; fNbytesName; Number of bytes in TNamed at creation time. 33 -> 33 [41->41]; fUnits; Number of bytes for file pointers. 34 -> 37 [42->45]; fCompress; Zip compression level. 38 -> 41 [46->53]; fSeekInfo; Pointer to TStreamerInfo record. 42 -> 45 [54->57]; fNBytesInfo; Number of bytes in TStreamerInfo record. 46 -> 63 [58->75]; fCompress; Universal Unique ID. The first four bytes of the file header contain the string “root” which identifies a file as a ROOT file. Because of this identifier, ROOT is not dependent on the “.root” extension. It is still a good idea to use the extension, just for us to recognize them easier. The nfree and value is the number of free records. This variable along with FNBytesFree keeps track of the free space in terms of records and bytes. This count also includes the deleted records, which are available again.; 11.1.2 The Top Directory Description; The 84 bytes after the file header contain the top directory description, including the name, the date and time it was created, and the date and time of the last modification.; 20010404/092347 At:64 N=84 TFile; 11.1.3 The Histogram Records; What follows are the 15 histograms, in records of variable length.; 20010404/092347 At:148 N=380 TH1F CX = 2.49; 20010404/092347 At:528 N=377 TH1F CX = 2.51; The first 4 bytes of each record is an integer holding the number of bytes in this record. A negative number flags the record as deleted, and makes the space available for recycling in the next writing. The rest of bytes in the header contain all the information to identify uniquely a data block on the file. It is followed by the object data.; The next table explains the values in each individual record. If the key is located past the 32 bit file limit (> 2 GB) then some fields will be 8 bytes instead of 4 bytes (values",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:433966,avail,available,433966,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['avail'],['available']
Availability,"1->Draw(""AC*"");. // superimpose the second graph by leaving out the axis option ""A""; gr2->SetLineWidth(3);; gr2->SetMarkerStyle(21);; gr2->SetLineColor(2);; gr2->Draw(""CP"");; }; 4.3 Graphs with Error Bars; A TGraphErrors is a TGraph with error bars. The various draw format options of TGraphErrors::Paint() are derived from TGraph.; void TGraphErrors::Paint(Option_t *option). Graphs with different draw options of error bars. In addition, it can be drawn with the “Z” option to leave off the small lines at the end of the error bars. If option contains “>”, an arrow is drawn at the end of the error bars. If option contains “|>”, a full arrow is drawn at the end of the error bars. The size of the arrow is set to 2/3 of the marker size.; The option “[]” is interesting to superimpose systematic errors on top of the graph with the statistical errors. When it is specified, only the end vertical/horizontal lines of the error bars are drawn.; To control the size of the lines at the end of the error bars (when option 1 is chosen) use SetEndErrorSize(np). By default np=1; np represents the number of pixels.; gStyle->SetEndErrorSize(np);; The four parameters of TGraphErrors are: X, Y (as in TGraph), X-errors, and Y-errors - the size of the errors in the x and y direction. Next example is $ROOTSYS/tutorials/graphs/gerrors.C.; {; c1 = new TCanvas(""c1"",""A Simple Graph with error bars"",200,10,700,500);; c1->SetGrid();. // create the coordinate arrays; Int_t n = 10;; Float_t x[n] = {-.22,.05,.25,.35,.5,.61,.7,.85,.89,.95};; Float_t y[n] = {1,2.9,5.6,7.4,9,9.6,8.7,6.3,4.5,1};. // create the error arrays; Float_t ex[n] = {.05,.1,.07,.07,.04,.05,.06,.07,.08,.05};; Float_t ey[n] = {.8,.7,.6,.5,.4,.4,.5,.6,.7,.8};. // create the TGraphErrors and draw it; gr = new TGraphErrors(n,x,y,ex,ey);; gr->SetTitle(""TGraphErrors Example"");; gr->SetMarkerColor(4);; gr->SetMarkerStyle(21);; gr->Draw(""ALP"");; c1->Update();; }; 4.4 Graphs with Asymmetric Error Bars. A graph with asymmetric error bars. A TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:146667,error,error,146667,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['error'],['error']
Availability,1.002) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.744046 a1=-0.311529 mean=5.09799 nbkg=161.409 nsig=148.884 sig1frac=0.512806; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 660; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 650; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 640; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 630; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 620; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 610; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-809.027) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.719517 a1=-0.347533 mean=5.00927 nbkg=127.977 nsig=152.559 sig1frac=0.917291; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 600; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 590; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 580; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-869.586) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.621299 a1=-0.442393 mean=5.13262 nbkg=131.7 nsig=167.982 sig1frac=0.776177; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 570; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 560; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 550; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 540; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 530; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-820.086) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.699182 a1=-0.532303 mean=4.90748 nbkg=130.722 nsig=155.109 sig1frac=0.843514; RooAddPdf::model,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:16781,error,errors,16781,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,4,['error'],"['error', 'errors']"
Availability,"1.1 MnSimplex(const FCNBase&, const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&, unsigned int); 5.11.2 MnSimplex(const FCNBase&, const MnUserParameters&,; unsigned int); 5.11.3 MnSimplex(const FCNBase&, const MnUserParameterState&,; const MnStrategy&); 5.11.4 operator(); 5.11.5 Parameter interaction; 5.11.6 SimplexMinimizer(); 5.11.7 minimize(const FCNBase&, …). 5.12 MnStrategy; 5.12.1 MnStrategy(); 5.12.2 MnStrategy(unsigned int level); 5.12.3 setLowStrategy(), setMediumStrategy(), setHighStrategy(); 5.12.4 Other methods. 5.13 MnUserCovariance; 5.13.1 MnUserCovariance(const std::vector\(<\)double\(>\)&, unsigned int nrow); 5.13.2 MnUserCovariance(unsigned int nrow); 5.13.3 MnUserCovariance::operator()(unsigned int, unsigned int). 5.14 MnUserParameters; 5.14.1 add(…); 5.14.2 setValue(…); 5.14.3 setError(…); 5.14.4 fix(…); 5.14.5 release(…); 5.14.6 setLimits(…); 5.14.7 setUpperLimit(…); 5.14.8 setLowerLimit(…); 5.14.9 removeLimits(…); 5.14.10 value(…); 5.14.11 error(…); 5.14.12 index(…); 5.14.13 name(…). 5.15 MnUserParameterState; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&); 5.15.2 MnUserParameterState(const MnUserParameters&); 5.15.3 MnUserParameterState(const MnUserParameters&,; const MnUserCovariance&); 5.15.4 parameters(); 5.15.5 covariance(); 5.15.6 globalCC(); 5.15.7 MnUserParameterState::isValid() and; MnUserParameterState::hasCovariance(); 5.15.8 MnUserParameterState::fval(), MnUserParameterState::edm(),; MnUserParameterState::nfcn(). 5.16 MnPrint.h; 5.16.1 operator\(<<\)(std::ostream&, const FunctionMinimum&); 5.16.2 operator\(<<\)(std::ostream&, const MnUserParameters&); 5.16.3 operator\(<<\)(std::ostream&, const MnUserCovariance&); 5.16.4 operator\(<<\)(std::ostream&, const MnGlobalCorrelationCoeff&); 5.16.5 operator\(<<\)(std::ostream&, const MnUserParameterState&); 5.16.6 operator\(<<\)(std::ostream&, const MinosError&); 5.16.7 operator\(<<\)(std::ostream&, const ContoursErros&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:3783,error,error,3783,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['error'],['error']
Availability,"1.cxx:3343; TF1::fAlphastd::vector< Double_t > fAlpha! Array alpha. for each bin in x the deconvolution r of fIntegralDefinition TF1.h:279; TF1::Integralvirtual Double_t Integral(Double_t a, Double_t b, Double_t epsrel=1.e-12)IntegralOneDim or analytical integral.Definition TF1.cxx:2531; TF1::SetTitlevoid SetTitle(const char *title="""") overrideSet function title if title has the form ""fffffff;xxxx;yyyy"", it is assumed that the function title i...Definition TF1.cxx:3558; TF1::fFormulastd::unique_ptr< TFormula > fFormulaPointer to TFormula in case when user define formula.Definition TF1.h:288; TF1::SetParNamesvirtual void SetParNames(const char *name0="""", const char *name1="""", const char *name2="""", const char *name3="""", const char *name4="""", const char *name5="""", const char *name6="""", const char *name7="""", const char *name8="""", const char *name9="""", const char *name10="""")Set up to 10 parameter names.Definition TF1.cxx:3463; TF1::DerivativeErrorstatic Double_t DerivativeError()Static function returning the error of the last call to the of Derivative's functions.Definition TF1.cxx:1277; TF1::fParMinstd::vector< Double_t > fParMinArray of lower limits of the fNpar parameters.Definition TF1.h:275; TF1::InitStandardFunctionsstatic void InitStandardFunctions()Create the basic function objects.Definition TF1.cxx:2497; TF1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TF1.h:273; TF1::SetNpxvirtual void SetNpx(Int_t npx=100)Set the number of points used to draw the function.Definition TF1.cxx:3433; TF1::GetParametersvirtual Double_t * GetParameters() constDefinition TF1.h:548; TF1::fMinimumDouble_t fMinimumMinimum value for plotting.Definition TF1.h:272; TF1::TermCoeffLengthint TermCoeffLength(TString &term)Definition TF1.cxx:924; TF1::fgRejectPointstatic Bool_t fgRejectPointDefinition TF1.h:325; TF1::Copyvoid Copy(TObject &f1) const overrideCopy this F1 to a new F1.Definition TF1.cxx:1005; TF1::Streamervoid Streamer(TBuffer &) overrideStream a class object.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:181721,error,error,181721,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"1/(n1+n2); using an error bar calculated with Binomial statistics. void addEfficiencyBinWithError(Axis_t binCenter, Double_t n1, Double_t n2, Double_t en1, Double_t en2, Double_t binWidth = 0, Double_t xErrorFrac = 1., Double_t scaleFactor = 1.); Add a bin to this histogram with the value n1/(n1+n2); using an error bar calculated with Binomial statistics. ~RooHist(); Destructor. Bool_t hasIdenticalBinning(const RooHist& other) const; Return kTRUE if binning of this RooHist is identical to that of 'other'. Bool_t isIdentical(const RooHist& other, Double_t tol = 9.9999999999999995E-7) const; Return kTRUE if contents of this RooHIst is identical within given; relative tolerance to that of 'other'. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Print info about this histogram to the specified output stream. Standard: number of entries; Shape: error CL and maximum value; Verbose: print our bin contents and errors. void printName(ostream& os) const; Print name of RooHist. void printTitle(ostream& os) const; Print title of RooHist. void printClassName(ostream& os) const; Print class name of RooHist. RooHist* makeResidHist(const RooCurve& curve, bool normalize = false, bool useAverage = false) const; Create and return RooHist containing residuals w.r.t to given curve.; If normalize is true, the residuals are normalized by the histogram; errors creating a RooHist with pull values. RooHist(). void Print(Option_t* options = 0) const; Printing interface. Double_t getNominalBinWidth() const; { return _nominalBinWidth; }. void setRawEntries(Double_t n); { _rawEntries = n ; }. RooHist* makePullHist(const RooCurve& curve, bool useAverage = false) const; {return makeResidHist(curve,true,useAverage); }. » Last changed: Tue Jun 2 15:31:27 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooHist.html:26552,error,errors,26552,root/html604/RooHist.html,https://root.cern,https://root.cern/root/html604/RooHist.html,2,['error'],['errors']
Availability,"10 ; 11#include ""ROOT/InternalTreeUtils.hxx""; 12#include ""ROOT/RDataFrame.hxx""; 13#include ""ROOT/RDataSource.hxx""; 14#include ""ROOT/RDF/RDatasetSpec.hxx""; 15#include ""ROOT/RDF/RInterface.hxx""; 16#include ""ROOT/RDF/RLoopManager.hxx""; 17#include ""ROOT/RDF/Utils.hxx""; 18#include <string_view>; 19#include ""TChain.h""; 20#include ""TDirectory.h""; 21#include ""RtypesCore.h"" // for ULong64_t; 22#include ""TTree.h""; 23 ; 24#include <fstream> // std::ifstream; 25#include <nlohmann/json.hpp> // nlohmann::json::parse; 26#include <memory> // for make_shared, allocator, shared_ptr; 27#include <ostream> // ostringstream; 28#include <stdexcept>; 29#include <string>; 30#include <vector>; 31 ; 32// clang-format off; 33/**; 34* \class ROOT::RDataFrame; 35* \ingroup dataframe; 36* \brief ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python.; 37 ; 38In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available; 39on their machines completely transparently.<br>; 40Skip to the [class reference](#reference) or keep reading for the user guide.; 41 ; 42In a nutshell:; 43~~~{.cpp}; 44ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; 45ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; 46auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; 47myHisto->Draw(); // Event loop is run here, upon first access to a result; 48~~~; 49 ; 50Calculations are expressed in terms of a type-safe *functional chain of actions and transformations*, RDataFrame takes; 51care of their execution. The implementation automatically puts in place several low level optimisations such as; 52multi-thread parallelization and caching.; 53 ; 54\htmlonly; 55<a href=""https://doi.org/10.5281/zenodo.260230""><img src=""https://zenodo.org/badge/DOI/10.5281/zenodo.260230.svg""; 56alt=""DOI""></a>; 57\endhtmlonly; 58 ; 59## For the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:1650,avail,available,1650,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,['avail'],['available']
Availability,"10 TClass__GetCallingNewRAII callingNew(defConstructor);; 5211 p = fCollectionProxy->NewObject(arena);; 5212 }; 5213 } else if (!HasInterpreterInfo() && !fCollectionProxy) {; 5214 // There is no dictionary at all and we do not have; 5215 // the services of a collection proxy available, so; 5216 // use the streamer info to approximate calling a; 5217 // constructor (basically we just make sure that the; 5218 // pointer data members are null, unless they are marked; 5219 // as preallocated with the ""->"" comment, in which case; 5220 // we default-construct an object to point at).; 5221 ; 5222 // ???BUG??? ???WHY???; 5223 // Do not register any TObject's that we create; 5224 // as a result of creating this object.; 5225 Bool_t statsave = GetObjectStat();; 5226 if(statsave) {; 5227 SetObjectStat(kFALSE);; 5228 }; 5229 ; 5230 TVirtualStreamerInfo* sinfo = GetStreamerInfo();; 5231 if (!sinfo) {; 5232 Error(""New with placement"", ""Cannot construct class '%s' version %d at address %p, no streamer info available!"", GetName(), fClassVersion, arena);; 5233 return nullptr;; 5234 }; 5235 ; 5236 {; 5237 TClass__GetCallingNewRAII callingNew(defConstructor);; 5238 p = { sinfo->New(arena), sinfo };; 5239 }; 5240 ; 5241 // ???BUG???; 5242 // Allow TObject's to be registered again.; 5243 if(statsave) {; 5244 SetObjectStat(statsave);; 5245 }; 5246 ; 5247 } else {; 5248 Error(""New with placement"", ""This cannot happen!"");; 5249 }; 5250 ; 5251 return p;; 5252}; 5253 ; 5254////////////////////////////////////////////////////////////////////////////////; 5255/// Return a pointer to a newly allocated array of objects; 5256/// of this class.; 5257/// The class must have a default constructor. For meaning of; 5258/// defConstructor, see TClass::IsCallingNew().; 5259 ; 5260void *TClass::NewArray(Long_t nElements, ENewType defConstructor) const; 5261{; 5262 auto obj = NewObjectArray(nElements, defConstructor);; 5263 if (obj.GetPtr() && obj.GetAllocator()) {; 5264 // Register the object for special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:200048,avail,available,200048,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"10) const; Find the nearest point to xvalue. Return -1 if distance; exceeds tolerance. Double_t interpolate(Double_t x, Double_t tolerance = 1.0E-10) const; Return linearly interpolated value of curve at xvalue. If distance; to nearest point is less than tolerance, return nearest point value; instead. RooCurve* makeErrorBand(const vector<RooCurve*>& variations, Double_t Z = 1) const; Construct filled RooCurve represented error band that captures alpha% of the variations; of the curves passed through argument variations, where the percentage alpha corresponds to; the central interval fraction of a significance Z. RooCurve* makeErrorBand(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, const TMatrixD& V, Double_t Z = 1) const; Construct filled RooCurve represented error band represent the error added in quadrature defined by the curves arguments; plusVar and minusVar corresponding to one-sigma variations of each parameter. The resulting error band, combined used the correlation matrix C; is multiplied with the significance parameter Z to construct the equivalent of a Z sigma error band (in Gaussian approximation). void calcBandInterval(const vector<RooCurve*>& plusVar, const vector<RooCurve*>& minusVar, Int_t i, const TMatrixD& V, Double_t Z, Double_t& lo, Double_t& hi) const; Retrieve variation points from curves. void calcBandInterval(const vector<RooCurve*>& variations, Int_t i, Double_t Z, Double_t& lo, Double_t& hi, Bool_t approxGauss) const. Bool_t isIdentical(const RooCurve& other, Double_t tol = 9.9999999999999995E-7) const; Return true if curve is identical to other curve allowing for given; absolute tolerance on each point compared point. RooCurve(). void Print(Option_t* options = 0) const; Printing interface. » Last changed: Tue Jun 30 14:32:21 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCurve.html:24434,error,error,24434,root/html602/RooCurve.html,https://root.cern,https://root.cern/root/html602/RooCurve.html,6,"['error', 'toler']","['error', 'tolerance']"
Availability,"10, 10 for 15 planes) and by 8 bits for 24 planes.; Returns kFALSE in case color allocation failed. void QueryColors(unsigned long cmap, XColor* colors, Int_t ncolors); Returns the current RGB value for the pixel in the XColor structure. void ClearPixmap(unsigned long* pix); Clear the pixmap pix. void ClearWindow(); Clear current window. void ClosePixmap(); Delete current pixmap. void CloseWindow(); Delete current window. void CloseWindow1(); Delete current window. void CopyPixmap(Int_t wid, Int_t xpos, Int_t ypos); Copy the pixmap wid at the position xpos, ypos in the current window. void CopyWindowtoPixmap(unsigned long* pix, Int_t xpos, Int_t ypos); Copy area of current window in the pixmap pix. void DrawBox(Int_t x1, Int_t y1, Int_t x2, Int_t y2, TVirtualX::EBoxMode mode); Draw a box.; mode=0 hollow (kHollow); mode=1 solid (kSolid). void DrawCellArray(Int_t x1, Int_t y1, Int_t x2, Int_t y2, Int_t nx, Int_t ny, Int_t* ic); Draw a cell array.; x1,y1 : left down corner; x2,y2 : right up corner; nx,ny : array size; ic : array. Draw a cell array. The drawing is done with the pixel presicion; if (X2-X1)/NX (or Y) is not a exact pixel number the position of; the top rigth corner may be wrong. void DrawFillArea(Int_t n, TPoint* xy); Fill area described by polygon.; n : number of points; xy(2,n) : list of points. void DrawLine(Int_t x1, Int_t y1, Int_t x2, Int_t y2); Draw a line.; x1,y1 : begin of line; x2,y2 : end of line. void DrawPolyLine(Int_t n, TPoint* xy); Draw a line through all points.; n : number of points; xy : list of points. void DrawPolyMarker(Int_t n, TPoint* xy); Draw n markers with the current attributes at position x, y.; n : number of markers to draw; xy : x,y coordinates of markers. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw a text string using current font.; mode : drawing mode; mode=0 : the background is not drawn (kClear); mode=1 : the background is drawn (kOpaque); x,y : text posi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11.html:26397,down,down,26397,root/html528/TGX11.html,https://root.cern,https://root.cern/root/html528/TGX11.html,6,['down'],['down']
Availability,"10// template ROOT::Double_v vecCore::math::Cbrt(const ROOT::Double_v & x);; 3211#endif; PdfFuncMathCore.h; ProbFuncMathCore.h; d#define d(i)Definition RSha256.hxx:102; b#define b(i)Definition RSha256.hxx:100; c#define c(i)Definition RSha256.hxx:101; g#define g(i)Definition RSha256.hxx:105; a#define a(i)Definition RSha256.hxx:99; s1#define s1(x)Definition RSha256.hxx:91; h#define h(i)Definition RSha256.hxx:106; e#define e(i)Definition RSha256.hxx:103; Int_tint Int_tDefinition RtypesCore.h:45; ULong_tunsigned long ULong_tDefinition RtypesCore.h:55; Long_tlong Long_tDefinition RtypesCore.h:54; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; NamespaceImp#define NamespaceImp(name)Definition Rtypes.h:398; SpecFuncMathCore.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Infovoid Info(const char *location, const char *msgfmt,...)Use this function for informational messages.Definition TError.cxx:218; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; N#define N; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; vvwinID h TVirtualViewer3D vvDefinition TGWin32VirtualGLProxy.cxx:49; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; delOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t delDefinition TGWin32VirtualXProxy.cxx:188; rOption_t Option_t TPoint TPoint co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:114217,error,error,114217,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['error'],['error']
Availability,"10000000000000001, Option_t* option = """")MENU ; voidTGeoNode::CheckShapes(); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; Int_tTGeoNode::CountDaughters(Bool_t unique_volumes = kFALSE); virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTGeoNode::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTGeoNode::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; voidTGeoNode::DrawOnly(Option_t* option = """"); voidTGeoNode::DrawOverlaps(); virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTGeoNode::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); voidTGeoNode::FillIdArray(Int_t& ifree, Int_t& nodeid, Int_t* array) ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNodeMatrix.html:1646,error,error,1646,root/html602/TGeoNodeMatrix.html,https://root.cern,https://root.cern/root/html602/TGeoNodeMatrix.html,6,"['Error', 'error']","['Error', 'error']"
Availability,"1024 *16)THnBaseprotectedstatic; CreateHnAny(const char *name, const char *title, const THnBase *hn, Bool_t sparse, Int_t chunkSize=1024 *16)THnBaseprotectedstatic; CreateIter(Bool_t respectAxisRange) const overrideTHnvirtual; DeclFileName()THninlinestatic; Delete(Option_t *option="""")TObjectvirtual; DistancetoPrimitive(Int_t px, Int_t py)TObjectvirtual; Divide(const THnBase *h)THnBase; Divide(const THnBase *h1, const THnBase *h2, Double_t c1=1., Double_t c2=1., Option_t *option="""")THnBase; DoError(int level, const char *location, const char *fmt, va_list va) constTObjectprotectedvirtual; Draw(Option_t *option="""")TObjectvirtual; DrawClass() constTObjectvirtual; DrawClone(Option_t *option="""") constTObjectvirtual; Dump() constTObjectvirtual; EDeprecatedStatusBits enum nameTObject; Error(const char *method, const char *msgfmt,...) constTObjectvirtual; EStatusBits enum nameTObject; Execute(const char *method, const char *params, Int_t *error=nullptr)TObjectvirtual; Execute(TMethod *method, TObjArray *params, Int_t *error=nullptr)TObjectvirtual; ExecuteEvent(Int_t event, Int_t px, Int_t py)TObjectvirtual; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fAxesTHnBaseprotected; fBitsTObjectprivate; fBrowsablesTHnBaseprotected; fCoordBufTHnmutableprotected; fEntriesTHnBaseprotected; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; Fill(const Double_t *x, Double_t w=1.)THnBaseinline; Fill(const char *name[], Double_t w=1.)THnBaseinline; Fill(Double_t firstval, MoreTypes... morevals)THnBaseinline; FillBin(Long64_t bin, Double_t w) overrideTHninlinevirtual; FillBinBase(Double_t w)THnBaseinlineprotected; FillBuffer(char *&buffer)TNamedvirtual; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; fIntegralTHnBaseprotected; fIntegralStatusTHnBaseprotected; Fit(TF1 *f1, Option_t *option="""", Option_t *goption="""")THnBase; fNameTNamedprotected; fNdimensionsTHnBaseprotected; fSumw2THnprotected; fTit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHn-members.html:2711,error,error,2711,doc/master/classTHn-members.html,https://root.cern,https://root.cern/doc/master/classTHn-members.html,2,['error'],['error']
Availability,"103 ; 104//; 105// Text management; 106//; 107const Int_t kMAXFONT = 4;; 108static struct {; 109 XFontStruct *id;; 110 char name[80]; // Font name; 111} gFont[kMAXFONT]; // List of fonts loaded; 112 ; 113static XFontStruct *gTextFont; // Current font; 114static Int_t gCurrentFontNumber = 0; // Current font number in gFont[]; 115 ; 116//; 117// Markers; 118//; 119const Int_t kMAXMK = 100;; 120static struct {; 121 int type;; 122 int n;; 123 XPoint xy[kMAXMK];; 124} gMarker; // Point list to draw marker; 125static int gMarkerLineWidth = 0;; 126static int gMarkerLineStyle = LineSolid;; 127static int gMarkerCapStyle = CapRound;; 128static int gMarkerJoinStyle = JoinRound;; 129 ; 130//; 131// Keep style values for line GC; 132//; 133static int gLineWidth = 0;; 134static int gLineStyle = LineSolid;; 135static int gCapStyle = CapButt;; 136static int gJoinStyle = JoinMiter;; 137static char gDashList[10];; 138static int gDashLength = 0;; 139static int gDashOffset = 0;; 140static int gDashSize = 0;; 141 ; 142//; 143// Event masks; 144//; 145static ULong_t gMouseMask = ButtonPressMask | ButtonReleaseMask |; 146 EnterWindowMask | LeaveWindowMask |; 147 PointerMotionMask | KeyPressMask |; 148 KeyReleaseMask;; 149static ULong_t gKeybdMask = ButtonPressMask | KeyPressMask |; 150 EnterWindowMask | LeaveWindowMask;; 151 ; 152//; 153// Data to create an invisible cursor; 154//; 155const char null_cursor_bits[] = {; 1560x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,; 1570x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,; 1580x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};; 159static Cursor gNullCursor = 0;; 160 ; 161struct RXGCValues:XGCValues{};; 162struct RXColor:XColor{};; 163struct RXImage:XImage{};; 164struct RXPoint:XPoint{};; 165struct RXVisualInfo:XVisualInfo{};; 166struct RVisual:Visual{};; 167 ; 168ClassImp(TGX11);; 169 ; 170////////////////////////////////////////////////////////////////////////////////; 171/// Default constructor.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:4560,mask,masks,4560,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['mask'],['masks']
Availability,"1049 /// \brief Register systematic variations for a single existing column using custom variation tags.; 1050 /// \param[in] colName name of the column for which varied values are provided.; 1051 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec containing the varied; 1052 /// values for the specified column.; 1053 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1054 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1055 /// colName is used if none is provided.; 1056 ///; 1057 /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; 1058 /// compiled. The example below shows how Vary() is used while dealing with a single column. The variation tags are; 1059 /// defined as `{""down"", ""up""}`.; 1060 /// ~~~{.cpp}; 1061 /// auto nominal_hx =; 1062 /// df.Vary(""pt"", ""ROOT::RVecD{pt*0.9, pt*1.1}"", {""down"", ""up""}); 1063 /// .Filter(""pt > k""); 1064 /// .Define(""x"", someFunc, {""pt""}); 1065 /// .Histo1D(""x"");; 1066 ///; 1067 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1068 /// hx[""nominal""].Draw();; 1069 /// hx[""pt:down""].Draw(""SAME"");; 1070 /// hx[""pt:up""].Draw(""SAME"");; 1071 /// ~~~; 1072 ///; 1073 /// \sa This Vary() overload for more information.; 1074 RInterface<Proxied, DS_t> Vary(std::string_view colName, std::string_view expression,; 1075 const std::vector<std::string> &variationTags, std::string_view variationName = """"); 1076 {; 1077 std::vector<std::string> colNames{{std::string(colName)}};; 1078 const std::string theVariationName{variationName.empty() ? colName : variationName};; 1079 ; 1080 return JittedVaryImpl(colNames, expression, variationTags, theVariationName, /*isSingleColumn=*/true);; 1081 }; 1082 ; 1083 /// \brief Register systematic variations for a single existing column using auto-generated variation tags.; 1084 /// \param[in] colName name of the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:58236,down,down,58236,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['down'],['down']
Availability,"1074 PrependPathName(dir, nameString);; 1075 return StrDup(nameString.Data());; 1076}; 1077 ; 1078////////////////////////////////////////////////////////////////////////////////; 1079/// Concatenate a directory and a file name.; 1080 ; 1081const char *TSystem::PrependPathName(const char *, TString&); 1082{; 1083 AbstractMethod(""PrependPathName"");; 1084 return nullptr;; 1085}; 1086 ; 1087 ; 1088//---- Paths & Files -----------------------------------------------------------; 1089 ; 1090////////////////////////////////////////////////////////////////////////////////; 1091/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1092/// For Unix/Win32 compatibility use $(XXX) instead of $XXX when using; 1093/// environment variables in a pathname. If compatibility is not an issue; 1094/// you can use on Unix directly $XXX. This is a protected function called; 1095/// from the OS specific system classes, like TUnixSystem and TWinNTSystem.; 1096/// Returns the expanded filename or 0 in case of error.; 1097 ; 1098const char *TSystem::ExpandFileName(const char *fname); 1099{; 1100 const int kBufSize = kMAXPATHLEN;; 1101 TTHREAD_TLS_ARRAY(char, kBufSize, xname);; 1102 ; 1103 Bool_t res = ExpandFileName(fname, xname, kBufSize);; 1104 if (res); 1105 return nullptr;; 1106 else; 1107 return xname;; 1108}; 1109 ; 1110//////////////////////////////////////////////////////////////////////////////; 1111/// Expand a pathname getting rid of special shell characters like ~.$, etc.; 1112/// This function is analogous to ExpandFileName(const char *), except that; 1113/// it receives a TString reference of the pathname to be expanded.; 1114/// Returns kTRUE in case of error and kFALSE otherwise.; 1115 ; 1116Bool_t TSystem::ExpandFileName(TString &fname); 1117{; 1118 const int kBufSize = kMAXPATHLEN;; 1119 char xname[kBufSize];; 1120 ; 1121 Bool_t res = ExpandFileName(fname.Data(), xname, kBufSize);; 1122 if (!res); 1123 fname = xname;; 1124 ; 1125 return res;; 1126};",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:33716,error,error,33716,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"1078 ""\""now\"" : \""%s\""%s""; 21079 ""}"",; 21080 eol,; 21081 eol,; 21082 difftime(now, start_time),; 21083 eol,; 21084 start_time_str,; 21085 eol,; 21086 now_str,; 21087 eol);; 21088 context_info_length += mg_str_append(&buffer, end, block);; 21089 }; 21090 ; 21091 /* Terminate string */; 21092 if (append_eoobj) {; 21093 strcat(append_eoobj, eoobj);; 21094 }; 21095 context_info_length += sizeof(eoobj) - 1;; 21096 ; 21097 return (int)context_info_length;; 21098#else; 21099 (void)ctx;; 21100 if ((buffer != NULL) && (buflen > 0)) {; 21101 *buffer = 0;; 21102 }; 21103 return 0;; 21104#endif; 21105}; 21106 ; 21107 ; 21108void; 21109mg_disable_connection_keep_alive(struct mg_connection *conn); 21110{; 21111 /* https://github.com/civetweb/civetweb/issues/727 */; 21112 if (conn != NULL) {; 21113 conn->must_close = 1;; 21114 }; 21115}; 21116 ; 21117 ; 21118#if defined(MG_EXPERIMENTAL_INTERFACES); 21119/* Get connection information. It can be printed or stored by the caller.; 21120 * Return the size of available information. */; 21121int; 21122mg_get_connection_info(const struct mg_context *ctx,; 21123 int idx,; 21124 char *buffer,; 21125 int buflen); 21126{; 21127 const struct mg_connection *conn;; 21128 const struct mg_request_info *ri;; 21129 char *end, *append_eoobj = NULL, block[256];; 21130 size_t connection_info_length = 0;; 21131 int state = 0;; 21132 const char *state_str = ""unknown"";; 21133 ; 21134#if defined(_WIN32); 21135 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21136#else; 21137 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21138#endif; 21139 ; 21140 if ((buffer == NULL) || (buflen < 1)) {; 21141 buflen = 0;; 21142 end = buffer;; 21143 } else {; 21144 *buffer = 0;; 21145 end = buffer + buflen;; 21146 }; 21147 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21148 /* has enough space to append eoobj */; 21149 append_eoobj = buffer;; 21150 end -= sizeof(eoobj) - 1;; 21151 }; 21152 ; 21153 if ((ctx == NULL) || (idx < 0)) {; 21154 /* Parameter error */; 21",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:630299,avail,available,630299,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avail'],['available']
Availability,"1079 ""\""now\"" : \""%s\""%s""; 21080 ""}"",; 21081 eol,; 21082 eol,; 21083 difftime(now, start_time),; 21084 eol,; 21085 start_time_str,; 21086 eol,; 21087 now_str,; 21088 eol);; 21089 context_info_length += mg_str_append(&buffer, end, block);; 21090 }; 21091 ; 21092 /* Terminate string */; 21093 if (append_eoobj) {; 21094 strcat(append_eoobj, eoobj);; 21095 }; 21096 context_info_length += sizeof(eoobj) - 1;; 21097 ; 21098 return (int)context_info_length;; 21099#else; 21100 (void)ctx;; 21101 if ((buffer != NULL) && (buflen > 0)) {; 21102 *buffer = 0;; 21103 }; 21104 return 0;; 21105#endif; 21106}; 21107 ; 21108 ; 21109void; 21110mg_disable_connection_keep_alive(struct mg_connection *conn); 21111{; 21112 /* https://github.com/civetweb/civetweb/issues/727 */; 21113 if (conn != NULL) {; 21114 conn->must_close = 1;; 21115 }; 21116}; 21117 ; 21118 ; 21119#if defined(MG_EXPERIMENTAL_INTERFACES); 21120/* Get connection information. It can be printed or stored by the caller.; 21121 * Return the size of available information. */; 21122int; 21123mg_get_connection_info(const struct mg_context *ctx,; 21124 int idx,; 21125 char *buffer,; 21126 int buflen); 21127{; 21128 const struct mg_connection *conn;; 21129 const struct mg_request_info *ri;; 21130 char *end, *append_eoobj = NULL, block[256];; 21131 size_t connection_info_length = 0;; 21132 int state = 0;; 21133 const char *state_str = ""unknown"";; 21134 ; 21135#if defined(_WIN32); 21136 static const char eol[] = ""\r\n"", eoobj[] = ""\r\n}\r\n"";; 21137#else; 21138 static const char eol[] = ""\n"", eoobj[] = ""\n}\n"";; 21139#endif; 21140 ; 21141 if ((buffer == NULL) || (buflen < 1)) {; 21142 buflen = 0;; 21143 end = buffer;; 21144 } else {; 21145 *buffer = 0;; 21146 end = buffer + buflen;; 21147 }; 21148 if (buflen > (int)(sizeof(eoobj) - 1)) {; 21149 /* has enough space to append eoobj */; 21150 append_eoobj = buffer;; 21151 end -= sizeof(eoobj) - 1;; 21152 }; 21153 ; 21154 if ((ctx == NULL) || (idx < 0)) {; 21155 /* Parameter error */; 21",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:630332,avail,available,630332,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avail'],['available']
Availability,10; : 1102 Minimum Test error found - save the configuration ; : 1102 | 2.66188 2.52638 0.020367 0.00185502 43215.3 0; : 1103 | 3.01155 3.18843 0.0202364 0.00176536 43311 1; : 1104 | 2.71885 3.00051 0.0201103 0.00176305 43603.3 2; : 1105 Minimum Test error found - save the configuration ; : 1105 | 2.73591 2.50832 0.0201341 0.0018587 43774.7 0; : 1106 | 2.7002 2.7081 0.0203577 0.00176876 43036.3 1; : 1107 | 2.85017 3.38001 0.0201747 0.00176074 43445.3 2; : 1108 | 2.78494 2.55451 0.0203389 0.00176376 43068.3 3; : 1109 | 2.71632 3.12003 0.0200899 0.00175276 43627.4 4; : 1110 | 3.16531 2.9918 0.020346 0.00180026 43136.7 5; : 1111 Minimum Test error found - save the configuration ; : 1111 | 2.97087 2.45167 0.0201922 0.00182484 43555.6 0; : 1112 | 2.60355 2.50464 0.0200664 0.00176061 43702 1; : 1113 | 2.54376 2.96916 0.0200737 0.00178101 43733.3 2; : 1114 | 2.77186 2.89815 0.0200657 0.00175793 43697.4 3; : 1115 | 2.58652 2.73506 0.020068 0.00175912 43694.6 4; : 1116 Minimum Test error found - save the configuration ; : 1116 | 2.82496 2.31503 0.0201083 0.00181922 43742 0; : 1117 | 2.74168 2.90157 0.0200454 0.00175765 43745.2 1; : 1118 | 2.51176 4.00704 0.0201409 0.00176812 43542.7 2; : 1119 | 3.03618 2.55498 0.0202517 0.00178949 43331.7 3; : 1120 | 2.66116 2.61177 0.0204165 0.00176394 42889.5 4; : 1121 | 3.00965 2.56116 0.0204562 0.00180217 42886.2 5; : 1122 | 3.0625 3.75816 0.0204635 0.00176149 42776.2 6; : 1123 | 2.88666 2.6576 0.0204265 0.00178135 42906.6 7; : 1124 | 2.54231 2.73598 0.020225 0.00176346 43333.4 8; : 1125 | 2.44231 2.73459 0.0201498 0.00175906 43500.1 9; : 1126 | 2.45201 2.82465 0.0200726 0.00175651 43677.5 10; : 1127 | 2.54248 2.42056 0.0201867 0.00176633 43430.3 11; : 1128 | 2.47016 2.53962 0.0206089 0.00182988 42600.8 12; : 1129 | 2.38268 2.44496 0.0204067 0.00176828 42922.1 13; : 1130 | 2.59925 2.55821 0.0200531 0.00176378 43741.4 14; : 1131 | 2.55367 2.59723 0.0200573 0.00177202 43751.1 15; : 1132 | 2.73554 2.74944 0.020135 0.00176885 43558.3 16; : 11,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:120744,error,error,120744,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,11 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.5877 43.7448 0.0201275 0.00181379 43683.2 0; : 660 Minimum Test error found - save the configuration ; : 660 | 56.1107 42.9226 0.0200887 0.00181275 43773.3 0; : 661 Minimum Test error found - save the configuration ; : 661 | 55.5039 42.6809 0.0201245 0.00180935 43679.7 0; : 662 Minimum Test error found - save the configuration ; : 662 | 54.3572 42.2723 0.0202587 0.00183315 43417.9 0; : 663 Minimum Test error found - save the configuration ; : 663 | 53.566 41.7624 0.0203991 0.00186617 43166.5 0; : 664 Minimum Test error found - save the configuration ; : 664 | 52.9086 41.2393 0.0201899 0.00182999 43573.1 0; : 665 Min,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:84798,error,error,84798,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"11.h""; #include ""TPoint.h""; #include ""TMath.h""; #include ""TStorage.h""; #include ""TStyle.h""; #include ""TExMap.h""; #include ""TEnv.h""; #include ""TString.h""; #include ""TObjString.h""; #include ""TObjArray.h""; #include ""RStipples.h""; #include ""strlcpy.h""; #include <X11/Xlib.h>; #include <X11/Xutil.h>; #include <X11/Xatom.h>; #include <X11/cursorfont.h>; #include <X11/keysym.h>; #include <X11/xpm.h>; #include <cstdio>; #include <cstring>; #include <cstdlib>; #include <cctype>; #include <unistd.h>. Include dependency graph for TGX11.cxx:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead. Classes; struct  RVisual;  ; struct  RXColor;  ; struct  RXGCValues;  ; struct  RXImage;  ; struct  RXPoint;  ; struct  RXVisualInfo;  . Namespaces; namespace  ROOT;  tbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tbb::task_arena without forward declaring tbb::interface7 ;  . Functions; static Int_t DummyX11ErrorHandler (Display *, XErrorEvent *);  Dummy error handler for X11. Used by FindUsableVisual(). ;  ; static void GetPixel (int y, int width, Byte_t *scline);  Get pixels in line y and put in array scline. ;  ; int GIFdecode (Byte_t *gifArr, Byte_t *pixArr, int *Width, int *Height, int *Ncols, Byte_t *R, Byte_t *G, Byte_t *B);  ; long GIFencode (int Width, int Height, Int_t Ncol, Byte_t R[], Byte_t G[], Byte_t B[], Byte_t ScLine[], void(*get_scline)(int, int, Byte_t *), void(*pb)(Byte_t));  ; int GIFinfo (Byte_t *gifArr, int *Width, int *Height, int *Ncols);  ; int GIFquantize (UInt_t width, UInt_t height, Int_t *ncol, Byte_t *red, Byte_t *green, Byte_t *blue, Byte_t *outputBuf, Byte_t *outputCmap);  ; static void PutByte (Byte_t b);  Put byte b in output stream. ;  ; int XRotDrawAlignedImageString (Display *, XFontStruct *, float, Drawable, GC, int, int, char *, int);  A front end to XRotPaintAlignedString: -does alignment, paints background. ;  ; int XRotDrawAlignedString (Display *, XFontStruct *, f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx.html:1290,error,error,1290,doc/master/TGX11_8cxx.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx.html,2,['error'],['error']
Availability,"11134 conn->path_info);; 11135 }; 11136 ; 11137 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11138 ; 11139 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11140 addenv(env, ""CONTENT_TYPE=%s"", s);; 11141 }; 11142 if (conn->request_info.query_string != NULL) {; 11143 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11144 }; 11145 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11146 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11147 }; 11148 if ((s = getenv(""PATH"")) != NULL) {; 11149 addenv(env, ""PATH=%s"", s);; 11150 }; 11151 if (conn->path_info != NULL) {; 11152 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11153 }; 11154 ; 11155 if (conn->status_code > 0) {; 11156 /* CGI error handler should show the status code */; 11157 addenv(env, ""STATUS=%d"", conn->status_code);; 11158 }; 11159 ; 11160#if defined(_WIN32); 11161 if ((s = getenv(""COMSPEC"")) != NULL) {; 11162 addenv(env, ""COMSPEC=%s"", s);; 11163 }; 11164 if ((s = getenv(""SYSTEMROOT"")) != NULL) {; 11165 addenv(env, ""SYSTEMROOT=%s"", s);; 11166 }; 11167 if ((s = getenv(""SystemDrive"")) != NULL) {; 11168 addenv(env, ""SystemDrive=%s"", s);; 11169 }; 11170 if ((s = getenv(""ProgramFiles"")) != NULL) {; 11171 addenv(env, ""ProgramFiles=%s"", s);; 11172 }; 11173 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11174 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11175 }; 11176#else; 11177 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11178 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11179 }; 11180#endif /* _WIN32 */; 11181 ; 11182 if ((s = getenv(""PERLLIB"")) != NULL) {; 11183 addenv(env, ""PERLLIB=%s"", s);; 11184 }; 11185 ; 11186 if (conn->request_info.remote_user != NULL) {; 11187 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11188 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11189 }; 11190 ; 11191 /* Add all headers as HTTP_* variables */; 11192 for (i = 0; i < conn->request_info.num_headers; i++) {; 11193 ; 11194 (void)mg_snprintf(conn,; 11195 &truncated,; 11196 http_var_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:322088,error,error,322088,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"11135 conn->path_info);; 11136 }; 11137 ; 11138 addenv(env, ""HTTPS=%s"", (conn->ssl == NULL) ? ""off"" : ""on"");; 11139 ; 11140 if ((s = mg_get_header(conn, ""Content-Type"")) != NULL) {; 11141 addenv(env, ""CONTENT_TYPE=%s"", s);; 11142 }; 11143 if (conn->request_info.query_string != NULL) {; 11144 addenv(env, ""QUERY_STRING=%s"", conn->request_info.query_string);; 11145 }; 11146 if ((s = mg_get_header(conn, ""Content-Length"")) != NULL) {; 11147 addenv(env, ""CONTENT_LENGTH=%s"", s);; 11148 }; 11149 if ((s = getenv(""PATH"")) != NULL) {; 11150 addenv(env, ""PATH=%s"", s);; 11151 }; 11152 if (conn->path_info != NULL) {; 11153 addenv(env, ""PATH_INFO=%s"", conn->path_info);; 11154 }; 11155 ; 11156 if (conn->status_code > 0) {; 11157 /* CGI error handler should show the status code */; 11158 addenv(env, ""STATUS=%d"", conn->status_code);; 11159 }; 11160 ; 11161#if defined(_WIN32); 11162 if ((s = getenv(""COMSPEC"")) != NULL) {; 11163 addenv(env, ""COMSPEC=%s"", s);; 11164 }; 11165 if ((s = getenv(""SYSTEMROOT"")) != NULL) {; 11166 addenv(env, ""SYSTEMROOT=%s"", s);; 11167 }; 11168 if ((s = getenv(""SystemDrive"")) != NULL) {; 11169 addenv(env, ""SystemDrive=%s"", s);; 11170 }; 11171 if ((s = getenv(""ProgramFiles"")) != NULL) {; 11172 addenv(env, ""ProgramFiles=%s"", s);; 11173 }; 11174 if ((s = getenv(""ProgramFiles(x86)"")) != NULL) {; 11175 addenv(env, ""ProgramFiles(x86)=%s"", s);; 11176 }; 11177#else; 11178 if ((s = getenv(""LD_LIBRARY_PATH"")) != NULL) {; 11179 addenv(env, ""LD_LIBRARY_PATH=%s"", s);; 11180 }; 11181#endif /* _WIN32 */; 11182 ; 11183 if ((s = getenv(""PERLLIB"")) != NULL) {; 11184 addenv(env, ""PERLLIB=%s"", s);; 11185 }; 11186 ; 11187 if (conn->request_info.remote_user != NULL) {; 11188 addenv(env, ""REMOTE_USER=%s"", conn->request_info.remote_user);; 11189 addenv(env, ""%s"", ""AUTH_TYPE=Digest"");; 11190 }; 11191 ; 11192 /* Add all headers as HTTP_* variables */; 11193 for (i = 0; i < conn->request_info.num_headers; i++) {; 11194 ; 11195 (void)mg_snprintf(conn,; 11196 &truncated,; 11197 http_var_na",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:322121,error,error,322121,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,1142 43585.5 4; : 839 Minimum Test error found - save the configuration ; : 839 | 7.52525 10.9666 0.0202646 0.00182844 43392.9 0; : 840 | 7.48548 11.313 0.020051 0.00174873 43710.5 1; : 841 | 7.28024 11.1847 0.0200374 0.0017493 43744.4 2; : 842 | 7.18939 11.0082 0.0200397 0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 0.0200333 0.00176264 43785.9 6; : 850 | 6.72856 10.6877 0.0200521 0.00176189 43739.2 7; : 851 | 6.84236 10.8522 0.0200238 0.00176009 43802.7 8; : 852 Minimum Test error found - save the configuration ; : 852 | 6.78011 10.0733 0.0201111 0.00182524 43749.6 0; : 853 Minimum Test error found - save the configuration ; : 853 | 6.53284 9.90736 0.0201187 0.00181829 43714.8 0; : 854 | 6.67108 10.0768 0.0205443 0.0017732 42618.8 1; : 855 | 6.58878 10.7427 0.0200637 0.00176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9.34508 0.0201279 0.00182025 43697.5 0; : 865 | 6.18959 10.0219 0.0205128 0.00175205 42642.3 1; : 866 Minimum Test ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:102388,error,error,102388,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"116 /**; 117 Initialize method for continuous one-dimensional distribution.; 118 User must provide a distribution object (which is copied inside) and a string for a method.; 119 For the list of available method for 1D cont. distribution see the; 120 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCONT"">UnuRan doc</A>.; 121 A re-initialization is needed whenever distribution parameters have been changed.; 122 Note that the method string can contain in addition to the method name all the specific method; 123 parameters specified using the UNURAN method string API.; 124 For example a valid string can be `""method=arou; max_segments=1000; max_sqhratio = 0.9""`; 125 */; 126 bool Init(const TUnuranContDist & distr, const std::string & method = ""auto"");; 127 ; 128 /**; 129 Initialize method for continuous multi-dimensional distribution.; 130 User must provide a distribution object (which is copied inside) and a string for a method.; 131 For the list of available method for multivariate cont. distribution see the; 132 <A href=""http://statmath.wu-wien.ac.at/unuran/doc/unuran.html#Methods_005ffor_005fCVEC"">UnuRan doc</A>; 133 A re-initialization is needed whenever distribution parameters have been changed.; 134 ; 135 The default method used for multi-dimensional distributions is ""vnrou""; 136 Note that some of the multi-dimensional continuous distribution methods like ""hitro"" are based on Markov-CHain sampler and; 137 they are much faster for sampling but require more time to converge. Furthermore, since they are Markov-Chain methods their; 138 generated sample values are correlated and cannot be used as i.i.d., one can instead use the obtained sample distribution.; 139 (see also the ROOT issue: #10222 ).; 140 ; 141 */; 142 bool Init(const TUnuranMultiContDist & distr, const std::string & method = ""vnrou"");; 143 ; 144 ; 145 /**; 146 Initialize method for continuous one-dimensional discrete distribution.; 147 User must provide a distribution objec",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnuran_8h_source.html:4752,avail,available,4752,doc/master/TUnuran_8h_source.html,https://root.cern,https://root.cern/doc/master/TUnuran_8h_source.html,1,['avail'],['available']
Availability,"116; 216; 126; 130. Poisson(m-10); 147; 1161; 162; 239. Poisson(m=10) UNURAN; 80; 294; 89; 99. 13.5 Mathematical Functions; The mathematical functions are present in both MathCore and MathMore libraries. All mathematical functions are implemented as free functions in the namespace ROOT::Math. The most used functions are in the MathCore library while the others are in the MathMore library. The functions in MathMore are all using the implementation of the GNU Scientific Library (GSL). The naming of the special functions is the same defined in the C++ Technical Report on Standard Library extensions. The special functions are defined in the header file Math/SpecFunc.h.; 13.5.1 Special Functions in MathCore. ROOT::Math::beta(double x,double y) -evaluates the beta function: \[B(x,y) = \frac{\Gamma(x) \Gamma(y)}{\Gamma(x+y)}\]; double ROOT::Math::erf(double x) - evaluates the error function encountered in integrating the normal distribution: \[erf(x) = \frac{2}{\sqrt{\pi}} \int_{0}^{x} e^{-t^2} dt\]; double ROOT::Math::erfc(double x) - evaluates the complementary error function: \[erfc(x) = 1 - erf(x) = \frac{2}{\sqrt{\pi}} \int_{x}^{\infty} e^{-t^2} dt\]; double ROOT::Math::tgamma(double x) - calculates the gamma function: \[\Gamma(x) = \int_{0}^{\infty} t^{x-1} e^{-t} dt\]. 13.5.2 Special Functions in MathMore. double ROOT::Math::assoc_legendre(unsigned l,unsigned m,double x) -computes the associated Legendre polynomials (with m>=0, l>=m and |x|<1): \[P_{l}^{m}(x) = (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l}(x)\]; double ROOT::Math::comp_ellint_1(double k) - calculates the complete elliptic integral of the first kind (with \(0 \le k^2 \le 1\): \[; K(k) = F(k, \pi / 2) = \int_{0}^{\pi /2} \frac{d \theta}{\sqrt{1 - k^2 \sin^2{\theta}}}; \]; double ROOT::Math::comp_ellint_2(double k) - calculates the complete elliptic integral of the second kind (with \(0 \le k^2 \le 1\)): \[; E(k) = E(k , \pi / 2) = \int_{0}^{\pi /2} \sqrt{1 - k^2 \sin^2{\theta}} d \theta; \]; double ROOT::Math::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:676778,error,error,676778,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,4,['error'],['error']
Availability,"11::DrawLine(Drawable_t id, GContext_t gc, Int_t x1, Int_t y1, Int_t x2, Int_t y2); virtual voidTGX11::DrawPolyLine(Int_t n, TPoint* xy); virtual voidTGX11::DrawPolyMarker(Int_t n, TPoint* xy); virtual voidTGX11::DrawRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual voidTGX11::DrawSegments(Drawable_t id, GContext_t gc, Segment_t* seg, Int_t nseg); virtual voidDrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); virtual voidDrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); virtual voidTObject::Dump() constMENU ; virtual Bool_tTGX11::EmptyRegion(Region_t reg); virtual Bool_tTGX11::EqualRegion(Region_t rega, Region_t regb); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual Int_tTGX11::EventsPending(); virtual UInt_tTVirtualX::ExecCommand(TGWin32Command* code); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual voidTGX11::FillPolygon(Window_t id, GContext_t gc, Point_t* points, Int_t npnt); virtual voidTGX11::FillRectangle(Drawable_t id, GContext_t gc, Int_t x, Int_t y, UInt_t w, UInt_t h); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; virtual Window_tTGX11::FindRWindow(Window_t win, Window_t dragwin, Window_t input, int x, int y, int maxd); virtual voidTGX11::FreeColor(Colormap_t cmap, ULong_t pixel); virtual voidTGX11::FreeFontNames(char** fontlist); virtual voidTGX11::FreeFontStruct(FontStruct_t fs); virtual voidTGX11::GetCharacterUp(Float_t& chupx, Float_t& chupy); virtual unsigned char*TGX11::GetColorBits(Drawable_t wid, Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGX11TTF.html:6131,error,error,6131,root/html528/TGX11TTF.html,https://root.cern,https://root.cern/root/html528/TGX11TTF.html,4,['error'],['error']
Availability,"11; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:659; TGraphErrors::operator=TGraphErrors & operator=(const TGraphErrors &gr)TGraphErrors assignment operator.Definition TGraphErrors.cxx:184; TGraphErrors::CopyPointsBool_t CopyPoints(Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy errors from fEX and fEY to arrays[0] and arrays[1] or to fEX and fEY if arrays == 0 and ibegin !...Definition TGraphErrors.cxx:532; TGraphErrors::IsATClass * IsA() const overrideDefinition TGraphErrors.h:78; TGraphErrors::MergeInt_t Merge(TCollection *list) overrideAdds all graphs with errors from the collection to this graph.Definition TGraphErrors.cxx:682; TGraphErrors::CopyAndReleasevoid CopyAndRelease(Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) overrideCopy and release.Definition TGraphErrors.cxx:510; TGraphErrors::TGraphErrorsTGraphErrors()TGraphErrors default constructor.Definition TGraphErrors.cxx:69; TGraphErrors::GetErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:35126,error,error,35126,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"11]. template<typename Proxied , typename DataSource = void> . template<typename F > . RInterface< Proxied, DS_t > ROOT::RDF::RInterface< Proxied, DataSource >::Vary ; (; const std::vector< std::string > & ; colNames, . F && ; expression, . const ColumnNames_t & ; inputColumns, . const std::vector< std::string > & ; variationTags, . std::string_view ; variationName . ). inline . Register systematic variations for multiple existing columns using custom variation tags. ; Parameters. [in]colNamesset of names of the columns for which varied values are provided. ; [in]expressiona callable that evaluates the varied values for the specified columns. The callable can take any column values as input, similarly to what happens during Filter and Define calls. It must return an RVec of varied values, one for each variation tag, in the same order as the tags. ; [in]inputColumnsthe names of the columns to be passed to the callable. ; [in]variationTagsnames for each of the varied values, e.g. ""up"" and ""down"". ; [in]variationNamea generic name for this set of varied values, e.g. ""ptvariation"". This overload of Vary takes a list of column names as first argument and requires that the expression returns an RVec of RVecs of values: one inner RVec for the variations of each affected column. The variationTags are defined as {""down"", ""up""}.; Example usage: // produce variations ""ptAndEta:down"" and ""ptAndEta:up""; auto nominal_hx =; df.Vary({""pt"", ""eta""}, // the columns that will vary simultaneously; [](double pt, double eta) { return RVec<RVecF>{{pt*0.9, pt*1.1}, {eta*0.9, eta*1.1}}; },; {""pt"", ""eta""}, // inputs to the Vary expression, independent of what columns are varied; {""down"", ""up""}, // variation tags; ""ptAndEta"") // variation name; .Histo1D(""pt"", ""eta"");; ; auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; hx[""nominal""].Draw();; hx[""ptAndEta:down""].Draw(""SAME"");; hx[""ptAndEta:up""].Draw(""SAME"");; ROOT::RDF::RInterface::Histo1DRResultPtr<::TH1D > Histo1D(const TH1DModel ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:137396,down,down,137396,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['down'],['down']
Availability,"1243 // nS = Max(S,s) + 0.5 * Nfree; 1244 Int_t stillNeedForTraining = TMath::Max(requestedTraining-availableTraining,0);; 1245 Int_t stillNeedForTesting = TMath::Max(requestedTesting-availableTesting,0);; 1246 ; 1247 int NFree = availableUndefined - stillNeedForTraining - stillNeedForTesting;; 1248 if (NFree <0) NFree = 0;; 1249 useForTraining = TMath::Max(requestedTraining,availableTraining) + NFree/2;; 1250 useForTesting= allAvailable - useForTraining; // the rest; 1251 }; 1252 ; 1253 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select training sample from=""<<useForTraining<<Endl;; 1254 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""determined event sample size to select test sample from=""<<useForTesting<<Endl;; 1255 ; 1256 ; 1257 ; 1258 // associate undefined events; 1259 if( splitMode == ""ALTERNATE"" ){; 1260 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split 'ALTERNATE'"" << Endl;; 1261 Int_t nTraining = availableTraining;; 1262 for( EventVector::iterator it = eventVectorUndefined.begin(), itEnd = eventVectorUndefined.end(); it != itEnd; ){; 1263 ++nTraining;; 1264 if( nTraining <= requestedTraining ){; 1265 eventVectorTraining.insert( eventVectorTraining.end(), (*it) );; 1266 ++it;; 1267 }; 1268 if( it != itEnd ){; 1269 eventVectorTesting.insert( eventVectorTesting.end(), (*it) );; 1270 ++it;; 1271 }; 1272 }; 1273 } else {; 1274 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""split '"" << splitMode << ""'"" << Endl;; 1275 ; 1276 // test if enough events are available; 1277 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableundefined : "" << availableUndefined << Endl;; 1278 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTraining : "" << useForTraining << Endl;; 1279 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""useForTesting : "" << useForTesting << Endl;; 1280 Log() << kDEBUG << Form(""Dataset[%s] : "",dsi.GetName())<< ""availableTraining :",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/DataSetFactory_8cxx_source.html:55102,avail,availableTraining,55102,doc/master/DataSetFactory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/DataSetFactory_8cxx_source.html,1,['avail'],['availableTraining']
Availability,"12947 *(uint32_t *)(void *)(out + i) =; 12948 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12949 i += 4;; 12950 }; 12951 }; 12952 if (i != in_len) {; 12953 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12954 while (i < in_len) {; 12955 *(uint8_t *)(void *)(out + i) =; 12956 *(uint8_t *)(void *)(in + i); 12957 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12958 i++;; 12959 }; 12960 }; 12961}; 12962 ; 12963 ; 12964int; 12965mg_websocket_client_write(struct mg_connection *conn,; 12966 int opcode,; 12967 const char *data,; 12968 size_t dataLen); 12969{; 12970 int retval = -1;; 12971 char *masked_data =; 12972 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12973 uint32_t masking_key = 0;; 12974 ; 12975 if (masked_data == NULL) {; 12976 /* Return -1 in an error case */; 12977 mg_cry_internal(conn,; 12978 ""%s"",; 12979 ""Cannot allocate buffer for masked websocket response: ""; 12980 ""Out of memory"");; 12981 return -1;; 12982 }; 12983 ; 12984 do {; 12985 /* Get a masking key - but not 0 */; 12986 masking_key = (uint32_t)get_random();; 12987 } while (masking_key == 0);; 12988 ; 12989 mask_data(data, dataLen, masking_key, masked_data);; 12990 ; 12991 retval = mg_websocket_write_exec(; 12992 conn, opcode, masked_data, dataLen, masking_key);; 12993 mg_free(masked_data);; 12994 ; 12995 return retval;; 12996}; 12997 ; 12998 ; 12999static void; 13000handle_websocket_request(struct mg_connection *conn,; 13001 const char *path,; 13002 int is_callback_resource,; 13003 struct mg_websocket_subprotocols *subprotocols,; 13004 mg_websocket_connect_handler ws_connect_handler,; 13005 mg_websocket_ready_handler ws_ready_handler,; 13006 mg_websocket_data_handler ws_data_handler,; 13007 mg_websocket_close_handler ws_close_handler,; 13008 void *cbData); 13009{; 13010 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13011 const char *version = mg_get_header(conn, ""Sec-WebSocket-Version"");; 13012 ptrdiff_t lua_websock = 0;; 13013 ; 13014#if !defined(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:377990,mask,masking,377990,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['mask'],['masking']
Availability,"12948 *(uint32_t *)(void *)(out + i) =; 12949 *(uint32_t *)(void *)(in + i) ^ masking_key;; 12950 i += 4;; 12951 }; 12952 }; 12953 if (i != in_len) {; 12954 /* convert 1-3 remaining bytes if ((dataLen % 4) != 0)*/; 12955 while (i < in_len) {; 12956 *(uint8_t *)(void *)(out + i) =; 12957 *(uint8_t *)(void *)(in + i); 12958 ^ *(((uint8_t *)&masking_key) + (i % 4));; 12959 i++;; 12960 }; 12961 }; 12962}; 12963 ; 12964 ; 12965int; 12966mg_websocket_client_write(struct mg_connection *conn,; 12967 int opcode,; 12968 const char *data,; 12969 size_t dataLen); 12970{; 12971 int retval = -1;; 12972 char *masked_data =; 12973 (char *)mg_malloc_ctx(((dataLen + 7) / 4) * 4, conn->phys_ctx);; 12974 uint32_t masking_key = 0;; 12975 ; 12976 if (masked_data == NULL) {; 12977 /* Return -1 in an error case */; 12978 mg_cry_internal(conn,; 12979 ""%s"",; 12980 ""Cannot allocate buffer for masked websocket response: ""; 12981 ""Out of memory"");; 12982 return -1;; 12983 }; 12984 ; 12985 do {; 12986 /* Get a masking key - but not 0 */; 12987 masking_key = (uint32_t)get_random();; 12988 } while (masking_key == 0);; 12989 ; 12990 mask_data(data, dataLen, masking_key, masked_data);; 12991 ; 12992 retval = mg_websocket_write_exec(; 12993 conn, opcode, masked_data, dataLen, masking_key);; 12994 mg_free(masked_data);; 12995 ; 12996 return retval;; 12997}; 12998 ; 12999 ; 13000static void; 13001handle_websocket_request(struct mg_connection *conn,; 13002 const char *path,; 13003 int is_callback_resource,; 13004 struct mg_websocket_subprotocols *subprotocols,; 13005 mg_websocket_connect_handler ws_connect_handler,; 13006 mg_websocket_ready_handler ws_ready_handler,; 13007 mg_websocket_data_handler ws_data_handler,; 13008 mg_websocket_close_handler ws_close_handler,; 13009 void *cbData); 13010{; 13011 const char *websock_key = mg_get_header(conn, ""Sec-WebSocket-Key"");; 13012 const char *version = mg_get_header(conn, ""Sec-WebSocket-Version"");; 13013 ptrdiff_t lua_websock = 0;; 13014 ; 13015#if !defined(U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:378023,mask,masking,378023,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['mask'],['masking']
Availability,"1296Int_t TChain::LoadBaskets(Long64_t /*maxmemory*/); 1297{; 1298 Error(""LoadBaskets"", ""Function not yet implemented for TChain."");; 1299 return 0;; 1300}; 1301 ; 1302////////////////////////////////////////////////////////////////////////////////; 1303/// Find the tree which contains entry, and set it as the current tree.; 1304///; 1305/// Returns the entry number in that tree.; 1306///; 1307/// The input argument entry is the entry serial number in the whole chain.; 1308///; 1309/// In case of error, LoadTree returns a negative number:; 1310/// * -1: The chain is empty.; 1311/// * -2: The requested entry number is less than zero or too large for the chain.; 1312/// * -3: The file corresponding to the entry could not be correctly open; 1313/// * -4: The TChainElement corresponding to the entry is missing or; 1314/// the TTree is missing from the file.; 1315/// * -5: Internal error, please report the circumstance when this happen; 1316/// as a ROOT issue.; 1317/// * -6: An error occurred within the notify callback.; 1318///; 1319/// Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new sub-tree.; 1320/// See TNotifyLink for more information on the notification mechanism.; 1321///; 1322/// \note This is the only routine which sets the value of fTree to a non-zero pointer.; 1323///; 1324Long64_t TChain::LoadTree(Long64_t entry); 1325{; 1326 // We already have been visited while recursively looking; 1327 // through the friends tree, let's return.; 1328 if (kLoadTree & fFriendLockStatus) {; 1329 return 0;; 1330 }; 1331 ; 1332 if (!fNtrees) {; 1333 // -- The chain is empty.; 1334 return -1;; 1335 }; 1336 ; 1337 if ((entry < 0) || ((entry > 0) && (entry >= fEntries && entry!=(TTree::kMaxEntries-1) ))) {; 1338 // -- Invalid entry number.; 1339 if (fTree) fTree->LoadTree(-1);; 1340 fReadEntry = -1;; 1341 return -2;; 1342 }; 1343 ; 1344 // Find out which tree in the chain contains the passed entry.; 1345 Int_t treenum = fTreeNumber;; 1346 if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:48131,error,error,48131,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['error'],['error']
Availability,"13 Double_t w = GetBinContent(binx,biny,binz);; 7714 np+=w;; 7715 sum+=w*(x-mean)*(x-mean)*(x-mean);; 7716 }; 7717 }; 7718 }; 7719 sum/=np*stddev3;; 7720 return sum;; 7721 }; 7722 else if (axis > 10 && axis <= 13) {; 7723 //compute standard error of skewness; 7724 // assume parent normal distribution use formula from Kendall-Stuart, Vol 1 pag 243, second edition; 7725 Double_t neff = GetEffectiveEntries();; 7726 return ( neff > 0 ? TMath::Sqrt(6./neff ) : 0. );; 7727 }; 7728 else {; 7729 Error(""GetSkewness"", ""illegal value of parameter"");; 7730 return 0;; 7731 }; 7732}; 7733 ; 7734////////////////////////////////////////////////////////////////////////////////; 7735/// - For axis =1, 2 or 3 returns kurtosis of the histogram along x, y or z axis.; 7736/// Kurtosis(gaussian(0, 1)) = 0.; 7737/// - For axis =11, 12 or 13 returns the approximate standard error of kurtosis; 7738/// of the histogram along x, y or z axis; 7739////; 7740/// Note, that since third and fourth moment are not calculated; 7741/// at the fill time, kurtosis and its standard error are computed bin by bin; 7742///; 7743/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7744/// are calculated. See TH1::GetMean and TH1::GetStdDev.; 7745 ; 7746Double_t TH1::GetKurtosis(Int_t axis) const; 7747{; 7748 if (axis > 0 && axis <= 3){; 7749 ; 7750 Double_t mean = GetMean(axis);; 7751 Double_t stddev = GetStdDev(axis);; 7752 Double_t stddev4 = stddev*stddev*stddev*stddev;; 7753 ; 7754 Int_t firstBinX = fXaxis.GetFirst();; 7755 Int_t lastBinX = fXaxis.GetLast();; 7756 Int_t firstBinY = fYaxis.GetFirst();; 7757 Int_t lastBinY = fYaxis.GetLast();; 7758 Int_t firstBinZ = fZaxis.GetFirst();; 7759 Int_t lastBinZ = fZaxis.GetLast();; 7760 // include underflow/overflow if TH1::StatOverflows(kTRUE) in case no range is set on the axis; 7761 if (GetStatOverflowsBehaviour()) {; 7762 if ( !fXaxis.TestBit(TAxis::kAxisRange) ) {; 7763 if (firstBinX == 1) firstBinX = 0;; 7764 if (lastBinX == fXaxis",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:303193,error,error,303193,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,2,['error'],['error']
Availability,"1344 Int_t i = 1;; 1345 while ((lb=(TObjString*)iL())) {; 1346 h1->GetXaxis()->SetBinLabel(i,lb->String().Data());; 1347 i++;; 1348 }; 1349 }; 1350 ; 1351 h1->SetEntries(fEntries);; 1352 return h1;; 1353}; 1354 ; 1355////////////////////////////////////////////////////////////////////////////////; 1356/// Replace current statistics with the values in array stats.; 1357 ; 1358void TProfile::PutStats(Double_t *stats); 1359{; 1360 fTsumw = stats[0];; 1361 fTsumw2 = stats[1];; 1362 fTsumwx = stats[2];; 1363 fTsumwx2 = stats[3];; 1364 fTsumwy = stats[4];; 1365 fTsumwy2 = stats[5];; 1366}; 1367 ; 1368////////////////////////////////////////////////////////////////////////////////; 1369/// Rebin this profile grouping ngroup bins together.; 1370///; 1371/// ## case 1 xbins=0; 1372/// if newname is not blank a new temporary profile hnew is created.; 1373/// else the current profile is modified (default); 1374/// The parameter ngroup indicates how many bins of this have to me merged; 1375/// into one bin of hnew; 1376/// If the original profile has errors stored (via Sumw2), the resulting; 1377/// profile has new errors correctly calculated.; 1378///; 1379/// examples: if hp is an existing TProfile histogram with 100 bins; 1380///; 1381/// ~~~ {.cpp}; 1382/// hp->Rebin(); //merges two bins in one in hp: previous contents of hp are lost; 1383/// hp->Rebin(5); //merges five bins in one in hp; 1384/// TProfile *hnew = hp->Rebin(5,""hnew""); // creates a new profile hnew; 1385/// //merging 5 bins of hp in one bin; 1386/// ~~~; 1387///; 1388/// NOTE: If ngroup is not an exact divider of the number of bins,; 1389/// the top limit of the rebinned profile is changed; 1390/// to the upper edge of the bin=newbins*ngroup and the corresponding; 1391/// bins are added to the overflow bin.; 1392/// Statistics will be recomputed from the new bin contents.; 1393///; 1394/// ## case 2 xbins!=0; 1395/// a new profile is created (you should specify newname).; 1396/// The parameter ngroup is the n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile_8cxx_source.html:50586,error,errors,50586,doc/master/TProfile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile_8cxx_source.html,2,['error'],['errors']
Availability,135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105705,error,error,105705,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1361/// Assume another process1 is connecting this directory in Update mode; 1362/// - Process1 is adding/updating objects in this directory; 1363/// - You want to see the latest status from process1.; 1364/// Example Process1:; 1365/// ~~~{.cpp}; 1366/// obj1.Write();; 1367/// obj2.Write();; 1368/// gDirectory->SaveSelf();; 1369/// ~~~; 1370///; 1371/// Example Process2:; 1372/// ~~~{.cpp}; 1373/// gDirectory->ReadKeys();; 1374/// obj1->Draw();; 1375/// ~~~; 1376/// This is an efficient way (without opening/closing files) to view; 1377/// the latest updates of a file being modified by another process; 1378/// as it is typically the case in a data acquisition system.; 1379 ; 1380Int_t TDirectoryFile::ReadKeys(Bool_t forceRead); 1381{; 1382 if (!fFile || !fKeys) return 0;; 1383 ; 1384 if (!fFile->IsBinary()); 1385 return fFile->DirReadKeys(this);; 1386 ; 1387 TDirectory::TContext ctxt(this);; 1388 ; 1389 char *buffer;; 1390 if (forceRead) {; 1391 fKeys->Delete();; 1392 //In case directory was updated by another process, read new; 1393 //position for the keys; 1394 Int_t nbytes = fNbytesName + TDirectoryFile::Sizeof();; 1395 char *header = new char[nbytes];; 1396 buffer = header;; 1397 fFile->Seek(fSeekDir);; 1398 if ( fFile->ReadBuffer(buffer,nbytes) ) {; 1399 // ReadBuffer return kTRUE in case of failure.; 1400 delete [] header;; 1401 return 0;; 1402 }; 1403 buffer += fNbytesName;; 1404 Version_t versiondir;; 1405 frombuf(buffer,&versiondir);; 1406 fDatimeC.ReadBuffer(buffer);; 1407 fDatimeM.ReadBuffer(buffer);; 1408 frombuf(buffer, &fNbytesKeys);; 1409 frombuf(buffer, &fNbytesName);; 1410 if (versiondir > 1000) {; 1411 frombuf(buffer, &fSeekDir);; 1412 frombuf(buffer, &fSeekParent);; 1413 frombuf(buffer, &fSeekKeys);; 1414 } else {; 1415 Int_t sdir,sparent,skeys;; 1416 frombuf(buffer, &sdir); fSeekDir = (Long64_t)sdir;; 1417 frombuf(buffer, &sparent); fSeekParent = (Long64_t)sparent;; 1418 frombuf(buffer, &skeys); fSeekKeys = (Long64_t)skeys;; 1419 }; 1420 delete []",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html:47564,failure,failure,47564,doc/master/TDirectoryFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TDirectoryFile_8cxx_source.html,1,['failure'],['failure']
Availability,"137; ROOT::Experimental::RLogManager::Removestd::unique_ptr< RLogHandler > Remove(RLogHandler *handler)Remove and return the given log handler. Returns nullptr if not found.Definition RLogger.cxx:68; ROOT::Experimental::RLogManager::Getstatic RLogManager & Get()Definition RLogger.cxx:62; ROOT::Experimental::RLogManager::RLogManagerRLogManager(std::unique_ptr< RLogHandler > lh)Initialize taking a RLogHandler.Definition RLogger.hxx:142; ROOT::Experimental::RLogManager::Emitbool Emit(const RLogEntry &entry) overrideEmit a log entry.Definition RLogger.cxx:82; ROOT::Experimental::RLogManager::PushFrontvoid PushFront(std::unique_ptr< RLogHandler > handler)Add a RLogHandler in the front - to be called before all others.Definition RLogger.hxx:150; ROOT::Experimental::RLogManager::PushBackvoid PushBack(std::unique_ptr< RLogHandler > handler)Add a RLogHandler in the back - to be called after all others.Definition RLogger.hxx:153; ROOT::Experimental::RLogScopedDiagCountObject to count the number of warnings and errors emitted by a section of code, after construction of...Definition RLogger.hxx:260; ROOT::Experimental::RLogScopedDiagCount::GetAccumulatedWarningslong long GetAccumulatedWarnings() constGet the number of warnings that the RLogDiagCount has emitted since construction of *this.Definition RLogger.hxx:282; ROOT::Experimental::RLogScopedDiagCount::HasWarningOccurredbool HasWarningOccurred() constWhether the RLogDiagCount has emitted a warnings since construction time of *this.Definition RLogger.hxx:291; ROOT::Experimental::RLogScopedDiagCount::HasErrorOrWarningOccurredbool HasErrorOrWarningOccurred() constWhether the RLogDiagCount has emitted an error or a warning since construction time of *this.Definition RLogger.hxx:297; ROOT::Experimental::RLogScopedDiagCount::HasErrorOccurredbool HasErrorOccurred() constWhether the RLogDiagCount has emitted an error (fatal or not) since construction time of *this.Definition RLogger.hxx:294; ROOT::Experimental::RLogScopedDiagCount:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RLogger_8hxx_source.html:21420,error,errors,21420,doc/master/RLogger_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RLogger_8hxx_source.html,1,['error'],['errors']
Availability,140 of file Minuit2Minimizer.h. ◆ Errors(). const double * ROOT::Minuit2::Minuit2Minimizer::Errors ; (; ); const. overridevirtual . return errors at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 717 of file Minuit2Minimizer.cxx. ◆ ExamineMinimum(). bool ROOT::Minuit2::Minuit2Minimizer::ExamineMinimum ; (; const ROOT::Minuit2::FunctionMinimum & ; min). protected . examine the minimum result ; Definition at line 594 of file Minuit2Minimizer.cxx. ◆ FixVariable(). bool ROOT::Minuit2::Minuit2Minimizer::FixVariable ; (; unsigned int ; ivar). overridevirtual . fix an existing variable ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 338 of file Minuit2Minimizer.cxx. ◆ GetCovMatrix(). bool ROOT::Minuit2::Minuit2Minimizer::GetCovMatrix ; (; double * ; cov); const. overridevirtual . Fill the passed array with the covariance matrix elements if the variable is fixed or const the value is zero. ; The array will be filled as cov[i *ndim + j] The ordering of the variables is the same as in errors and parameter value. This is different from the direct interface of Minuit2 or TMinuit where the values were obtained only to variable parameters ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 755 of file Minuit2Minimizer.cxx. ◆ GetFCN(). virtual const ROOT::Minuit2::FCNBase * ROOT::Minuit2::Minuit2Minimizer::GetFCN ; (; ); const. inlineprotectedvirtual . Definition at line 287 of file Minuit2Minimizer.h. ◆ GetHessianMatrix(). bool ROOT::Minuit2::Minuit2Minimizer::GetHessianMatrix ; (; double * ; h); const. overridevirtual . Fill the passed array with the Hessian matrix elements The Hessian matrix is the matrix of the second derivatives and is the inverse of the covariance matrix If the variable is fixed or const the values for that variables are zero. ; The array will be filled as h[i *ndim + j] ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 784 of file Minuit2Minimizer.cxx. ◆ GetMinimizer(). virtual const ROOT,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:16421,error,errors,16421,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,1,['error'],['errors']
Availability,"142 of file TAuthenticate.cxx. ◆ PromptUser(). char * TAuthenticate::PromptUser ; (; const char * ; remote). static . Static method to prompt for the user name to be used for authentication to rootd or proofd. ; User is asked to type user name. Returns user name (which must be deleted by caller) or 0. If non-interactive run (eg ProofServ) returns default user. ; Definition at line 1102 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [1/2]. Int_t TAuthenticate::ProofAuthSetup ; (; ). private . Authentication related stuff setup in TProofServ. ; This is the place where the buffer send by the client / master is decoded. It contains also password information, if the case requires. Return 0 on success, -1 on failure. ; Definition at line 3699 of file TAuthenticate.cxx. ◆ ProofAuthSetup() [2/2]. Int_t TAuthenticate::ProofAuthSetup ; (; TSocket * ; sock, . Bool_t ; client . ). staticprivate . Setup of authetication related stuff in PROOF run after a successful authentication. ; Return 0 on success, -1 on failure. ; Definition at line 3820 of file TAuthenticate.cxx. ◆ ReadRootAuthrc(). Int_t TAuthenticate::ReadRootAuthrc ; (; ). static . Read authentication directives from $ROOTAUTHRC, $HOME/.rootauthrc or <Root_etc_dir>/system.rootauthrc and create related THostAuth objects. ; Files are read only if they changed since last reading If 'proofconf' is defined, check also file proofconf for directives ; Definition at line 3212 of file TAuthenticate.cxx. ◆ RemoveHostAuth(). void TAuthenticate::RemoveHostAuth ; (; THostAuth * ; ha, . Option_t * ; opt = """" . ). static . Remove THostAuth instance from the list. ; Definition at line 2203 of file TAuthenticate.cxx. ◆ RemoveSecContext(). void TAuthenticate::RemoveSecContext ; (; TRootSecContext * ; ctx). staticprivate . Tool for removing SecContext ctx from THostAuth listed in fgAuthInfo or fgProofAuthInfo. ; Definition at line 3661 of file TAuthenticate.cxx. ◆ RfioAuth(). Int_t TAuthenticate::RfioAuth ; (; TString & ; user). private .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAuthenticate.html:35260,failure,failure,35260,doc/master/classTAuthenticate.html,https://root.cern,https://root.cern/doc/master/classTAuthenticate.html,1,['failure'],['failure']
Availability,"143 of file RooDataSet.h. ◆ sumEntries() [1/2]. double RooDataSet::sumEntries ; (; ); const. overridevirtual . Return effective number of entries in dataset, i.e., sum all weights. ; Implements RooAbsData.; Definition at line 844 of file RooDataSet.cxx. ◆ sumEntries() [2/2]. double RooDataSet::sumEntries ; (; const char * ; cutSpec, . const char * ; cutRange = nullptr . ); const. overridevirtual . Return the sum of weights in all entries matching cutSpec (if specified) and in named range cutRange (if specified) ; Implements RooAbsData.; Definition at line 854 of file RooDataSet.cxx. ◆ weight(). double RooDataSet::weight ; (; ); const. overridevirtual . Return event weight of current event. ; Implements RooAbsData.; Definition at line 759 of file RooDataSet.cxx. ◆ weightError() [1/2]. void RooDataSet::weightError ; (; double & ; lo, . double & ; hi, . ErrorType ; etype = SumW2 . ); const. overridevirtual . Return the asymmetric errors on the current weight. ; See also weightError(ErrorType) const for symmetric error. Parameters. [out]loLow error. ; [out]hiHigh error. ; etypeerror type . Reimplemented from RooAbsData.; Definition at line 817 of file RooDataSet.cxx. ◆ weightError() [2/2]. double RooDataSet::weightError ; (; ErrorType ; etype = SumW2); const. overridevirtual . Parameters. etypeerror type . Reimplemented from RooAbsData.; Definition at line 826 of file RooDataSet.cxx. ◆ weightSquared(). double RooDataSet::weightSquared ; (; ); const. overridevirtual . Return squared event weight of the current event. ; If this RooDataSet has no weight errors set, this will be the same as weight() * weight(), like expected for an unbinned dataset. When weight errors are set, it is assumed that the RooDataSet represents a weighted binned dataset and weightSquared() is the corresponding sum of weight squares for the bin. ; Implements RooAbsData.; Definition at line 773 of file RooDataSet.cxx. ◆ weightVar(). RooRealVar * RooDataSet::weightVar ; (; ); const. inline . Returns a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:58336,error,error,58336,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['error'],['error']
Availability,"144 out *= _scaleFactor;; 145 ; 146 _var.setVal(oldVal);; 147 return out;; 148 }; 149 double getMinLimit(UInt_t /*dimension*/) const override { return _var.getMin(); }; 150 double getMaxLimit(UInt_t /*dimension*/) const override { return _var.getMax(); }; 151 ; 152private:; 153 RooAbsRealLValue &_var;; 154 std::unique_ptr<RooAbsReal> _arg;; 155 std::span<const double> _dataWeights;; 156 double _scaleFactor;; 157 std::unique_ptr<RooFit::Evaluator> _evaluator;; 158 std::stack<std::vector<double>> _vectorBuffers;; 159};; 160 ; 161struct EvalErrorData {; 162 using ErrorList = std::map<const RooAbsArg *, std::pair<std::string, std::list<RooAbsReal::EvalError>>>;; 163 RooAbsReal::ErrorLoggingMode mode = RooAbsReal::PrintErrors;; 164 int count = 0;; 165 ErrorList errorList;; 166};; 167 ; 168EvalErrorData &evalErrorData(); 169{; 170 static EvalErrorData data;; 171 return data;; 172}; 173 ; 174} // namespace; 175 ; 176Int_t RooAbsReal::numEvalErrorItems(); 177{; 178 return evalErrorData().errorList.size();; 179}; 180 ; 181EvalErrorData::ErrorList::iterator RooAbsReal::evalErrorIter(); 182{; 183 return evalErrorData().errorList.begin();; 184}; 185 ; 186ClassImp(RooAbsReal); 187 ; 188bool RooAbsReal::_globalSelectComp = false;; 189bool RooAbsReal::_hideOffset = true ;; 190 ; 191void RooAbsReal::setHideOffset(bool flag) { _hideOffset = flag ; }; 192bool RooAbsReal::hideOffset() { return _hideOffset ; }; 193 ; 194 ; 195////////////////////////////////////////////////////////////////////////////////; 196/// coverity[UNINIT_CTOR]; 197/// Default constructor; 198 ; 199RooAbsReal::RooAbsReal() {}; 200 ; 201 ; 202////////////////////////////////////////////////////////////////////////////////; 203/// Constructor with unit label; 204 ; 205RooAbsReal::RooAbsReal(const char *name, const char *title, const char *unit) : RooAbsReal{name, title, 0.0, 0.0, unit}; 206{; 207}; 208 ; 209 ; 210////////////////////////////////////////////////////////////////////////////////; 211/// Constructor w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:6066,error,errorList,6066,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errorList']
Availability,"144# Save data for statistical analysis tutorial (rf618_mixture_models.py) ; 145df.Snapshot(""tree"", ROOT.gROOT.GetTutorialDir().Data() + ""/dataframe/df106_HiggsToFourLeptons.root"", [""m4l"", ""sample_category"", ""weight""]); 146 ; 147# Book histograms for the four different samples: data, higgs, zz and other (this is specific to this particular analysis); 148histos = []; 149for sample_category in [""data"", ""higgs"", ""zz"", ""other""]:; 150 histos.append(; 151 df.Filter(f'sample_category == ""{sample_category}""').Histo1D(; 152 ROOT.RDF.TH1DModel(f""{sample_category}"", ""m4l"", 24, 80, 170),; 153 ""m4l"",; 154 ""weight"",; 155 ); 156 ); 157 ; 158# Evaluate the systematic uncertainty; 159 ; 160# The systematic uncertainty in this analysis is the MC scale factor uncertainty that depends on lepton; 161# kinematics such as pT or pseudorapidity.; 162# Muons uncertainties are negligible, as stated in https://atlas.web.cern.ch/Atlas/GROUPS/PHYSICS/PAPERS/MUON-2018-03/.; 163# Electrons uncertainties are evaluated based on the plots available in https://doi.org/10.48550/arXiv.1908.00005.; 164# The uncertainties are linearly interpolated, using the `TGraph::Eval()` method, to cover a range of pT values covered by the analysis.; 165 ; 166# Create a VaryHelper to interpolate the available data.; 167ROOT.gInterpreter.Declare(; 168 """"""; 169using namespace ROOT::VecOps;; 170 ; 171class VaryHelper; 172{; 173 const std::vector<double> x{5.50e3, 5.52e3, 12.54e3, 17.43e3, 22.40e3, 27.48e3, 30e3, 10000e3};; 174 const std::vector<double> y{0.06628, 0.06395, 0.06396, 0.03372, 0.02441, 0.01403, 0, 0};; 175 TGraph graph;; 176 ; 177public:; 178 VaryHelper() : graph(x.size(), x.data(), y.data()) {}; 179 RVec<double> operator()(const double &w, const RVecF &pt, const RVec<unsigned int> &type); 180 {; 181 const auto v = Mean(Map(pt[type == 11], [this](auto p); 182 {return this->graph.Eval(p); }); 183 );; 184 return RVec<double>{(1 + v) * w, (1 - v) * w};; 185 }; 186};; 187 ; 188VaryHelper variationsFactory;; 189""""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:7698,avail,available,7698,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['avail'],['available']
Availability,"15 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; 355 for (unsigned int i = 0; i < npar; ++i); 356 if ( fFitFunc->ParameterName(i) == name) return i;; 357 ; 358 return -1; // case name is not found; 359}; 360 ; 361bool FitResult::IsParameterBound(unsigned int ipar) const {; 362 return fBoundParams.find(ipar) != fBoundParams.end();; 363}; 364 ; 365bool FitResult::IsParameterFixed(unsigned int ipar) const {; 366 return fFixedParams.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:11452,error,error,11452,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,3,['error'],['error']
Availability,"15) && findvis) {; 787 ; 788 // try to find better visual; 789 static XVisualInfo templates[] = {; 790 // Visual, visualid, screen, depth, class , red_mask, green_mask, blue_mask, colormap_size, bits_per_rgb; 791 { nullptr, 0 , 0 , 24 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 792 { nullptr, 0 , 0 , 32 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 793 { nullptr, 0 , 0 , 16 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 794 { nullptr, 0 , 0 , 15 , TrueColor , 0 , 0 , 0 , 0 , 0 },; 795 // no suitable TrueColorMode found - now do the same thing to DirectColor; 796 { nullptr, 0 , 0 , 24 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 797 { nullptr, 0 , 0 , 32 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 798 { nullptr, 0 , 0 , 16 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 799 { nullptr, 0 , 0 , 15 , DirectColor, 0 , 0 , 0 , 0 , 0 },; 800 { nullptr, 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 },; 801 };; 802 ; 803 Int_t nitems = 0;; 804 XVisualInfo *vlist = nullptr;; 805 for (Int_t i = 0; templates[i].depth != 0; i++) {; 806 Int_t mask = VisualScreenMask|VisualDepthMask|VisualClassMask;; 807 templates[i].screen = fScreenNumber;; 808 if ((vlist = XGetVisualInfo((Display*)fDisplay, mask, &(templates[i]), &nitems))) {; 809 FindUsableVisual((RXVisualInfo*)vlist, nitems);; 810 XFree(vlist);; 811 vlist = nullptr;; 812 if (fVisual); 813 break;; 814 }; 815 }; 816 }; 817 ; 818 fRootWin = RootWindow((Display*)fDisplay, fScreenNumber);; 819 ; 820 if (!fVisual) {; 821 fDepth = DefaultDepth((Display*)fDisplay, fScreenNumber);; 822 fVisual = (RVisual*)DefaultVisual((Display*)fDisplay, fScreenNumber);; 823 fVisRootWin = fRootWin;; 824 if (fDepth > 1); 825 fColormap = DefaultColormap((Display*)fDisplay, fScreenNumber);; 826 fBlackPixel = BlackPixel((Display*)fDisplay, fScreenNumber);; 827 fWhitePixel = WhitePixel((Display*)fDisplay, fScreenNumber);; 828 }; 829 if (gDebug > 1); 830 Printf(""Selected visual 0x%lx: depth %d, class %d, colormap: %s"",; 831 fVisual->visualid, fDepth, fVisual->c_class,; 832 fColormap == DefaultColormap((Display*)fDisplay, fS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGX11_8cxx_source.html:25846,mask,mask,25846,doc/master/TGX11_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGX11_8cxx_source.html,1,['mask'],['mask']
Availability,"151\frac{\partial F}{\partial P_{\mathrm{ext}}}; 152\frac{\partial P_{\mathrm{ext}}}{\partial P_{\mathrm{int}}} =; 153\frac{\partial F}{\partial P_{\mathrm{ext}}} = 0; 154\f]; 155 ; 156#### Getting the right parameter errors with limits.; 157 ; 158In the best case, where the minimum is far from any limits, MINUIT will; 159correctly transform the error matrix, and the parameter errors it reports; 160should be accurate and very close to those you would have got without; 161limits. In other cases (which should be more common, since otherwise you; 162wouldn't need limits), the very meaning of parameter errors becomes; 163problematic. Mathematically, since the limit is an absolute constraint on; 164the parameter, a parameter at its limit has no error, at least in one; 165direction. The error matrix, which can assign only symmetric errors, then; 166becomes essentially meaningless.; 167 ; 168### Interpretation of Parameter Errors:; 169 ; 170There are two kinds of problems that can arise: the reliability of; 171MINUIT's error estimates, and their statistical interpretation, assuming; 172they are accurate.; 173 ; 174### Statistical interpretation:; 175 ; 176For discussion of basic concepts, such as the meaning of the elements of; 177the error matrix, or setting of exact confidence levels see:; 178 ; 179 1. F.James.; 180 Determining the statistical Significance of experimental Results.; 181 Technical Report DD/81/02 and CERN Report 81-03, CERN, 1981.; 182 ; 183 2. W.T.Eadie, D.Drijard, F.James, M.Roos, and B.Sadoulet.; 184 Statistical Methods in Experimental Physics.; 185 North-Holland, 1971.; 186 ; 187### Reliability of MINUIT error estimates.; 188 ; 189MINUIT always carries around its own current estimates of the parameter; 190errors, which it will print out on request, no matter how accurate they; 191are at any given point in the execution. For example, at initialization,; 192these estimates are just the starting step sizes as specified by the user.; 193After a HESSE step, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:8297,reliab,reliability,8297,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,"['error', 'reliab']","['error', 'reliability']"
Availability,"153 if (exl) memcpy(fEXlow, exl, memsz);; 154 else memset(fEXlow, 0, memsz);; 155 if (exh) memcpy(fEXhigh, exh, memsz);; 156 else memset(fEXhigh, 0, memsz);; 157 if (eyl) memcpy(fEYlow, eyl, memsz);; 158 else memset(fEYlow, 0, memsz);; 159 if (eyh) memcpy(fEYhigh, eyh, memsz);; 160 else memset(fEYhigh, 0, memsz);; 161 ; 162 if (exld) memcpy(fEXlowd, exld, memsz);; 163 else memset(fEXlowd, 0, memsz);; 164 if (exhd) memcpy(fEXhighd, exhd, memsz);; 165 else memset(fEXhighd, 0, memsz);; 166 if (eyld) memcpy(fEYlowd, eyld, memsz);; 167 else memset(fEYlowd, 0, memsz);; 168 if (eyhd) memcpy(fEYhighd, eyhd, memsz);; 169 else memset(fEYhighd, 0, memsz);; 170}; 171 ; 172 ; 173////////////////////////////////////////////////////////////////////////////////; 174/// TGraphBentErrors default destructor.; 175 ; 176TGraphBentErrors::~TGraphBentErrors(); 177{; 178 delete [] fEXlow;; 179 delete [] fEXhigh;; 180 delete [] fEYlow;; 181 delete [] fEYhigh;; 182 ; 183 delete [] fEXlowd;; 184 delete [] fEXhighd;; 185 delete [] fEYlowd;; 186 delete [] fEYhighd;; 187}; 188 ; 189////////////////////////////////////////////////////////////////////////////////; 190/// Add a point with bent errors to the graph.; 191 ; 192void TGraphBentErrors::AddPointError(Double_t x, Double_t y, Double_t exl, Double_t exh, Double_t eyl, Double_t eyh,; 193 Double_t exld, Double_t exhd, Double_t eyld, Double_t eyhd); 194{; 195 AddPoint(x, y);; 196 SetPointError(fNpoints - 1, exl, exh, eyl, eyh, exld, exhd, eyld, eyhd);; 197}; 198 ; 199////////////////////////////////////////////////////////////////////////////////; 200/// Apply a function to all data points \f$ y = f(x,y) \f$.; 201///; 202/// Errors are calculated as \f$ eyh = f(x,y+eyh)-f(x,y) \f$ and; 203/// \f$ eyl = f(x,y)-f(x,y-eyl) \f$.; 204///; 205/// Special treatment has to be applied for the functions where the; 206/// role of ""up"" and ""down"" is reversed.; 207///; 208/// Function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 209 ; 2",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html:6329,error,errors,6329,doc/master/TGraphBentErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphBentErrors_8cxx_source.html,1,['error'],['errors']
Availability,"1556736; // months (average # days); 1231 rangeOffset = (Double_t) ((Long_t)(timeoffset)%rangeBase);; 1232 if (range>31536000) {; 1233 tp0 = gmtime(&timetp);; 1234 tp0->tm_mon = 0;; 1235 tp0->tm_mday = 1;; 1236 tp0->tm_hour = 0;; 1237 tp0->tm_min = 0;; 1238 tp0->tm_sec = 0;; 1239 tp0->tm_isdst = 1; // daylight saving time is on.; 1240 rangeBase = (timetp-mktime(tp0)); // years; 1241 rangeOffset = (Double_t) (rangeBase);; 1242 }; 1243 wmax += rangeOffset;; 1244 wmin += rangeOffset;; 1245 }; 1246 ; 1247// Determine number of divisions 1, 2 and 3 and the maximum digits for this axis; 1248 n1a = (ndiv%100);; 1249 n2a = (ndiv%10000 - n1a)/100;; 1250 n3a = (ndiv%1000000 - n2a -n1a)/10000;; 1251 nn3 = TMath::Max(n3a,1);; 1252 nn2 = TMath::Max(n2a,1)*nn3;; 1253 nn1 = TMath::Max(n1a,1)*nn2+1;; 1254 nticks = nn1;; 1255 maxDigits = (ndiv/1000000);; 1256 if (maxDigits==0) maxDigits = gStyle->GetAxisMaxDigits();; 1257 ; 1258// Axis bining optimisation is ignored if:; 1259// - the first and the last label are equal; 1260// - the number of divisions is 0; 1261// - less than 1 primary division is requested; 1262// - logarithmic scale is requested; 1263 ; 1264 if (wmin == wmax || ndiv == 0 || n1a <= 1 || optionLog) {; 1265 optionNoopt = 1;; 1266 optionInt = 0;; 1267 }; 1268 ; 1269// Axis bining optimisation; 1270 if ( (wmax-wmin) < 1 && optionInt) {; 1271 Error(where, ""option I not available"");; 1272 optionInt = 0;; 1273 }; 1274 if (!optionNoopt || optionInt ) {; 1275 ; 1276// Primary divisions optimisation; 1277// When integer labelling is required, Optimize is invoked first; 1278// and only if the result is not an integer labelling, AdjustBinSize is invoked.; 1279 ; 1280 THLimitsFinder::Optimize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth,fChopt.Data());; 1281 if (optionInt) {; 1282 if (binLow != Double_t(int(binLow)) || binWidth != Double_t(int(binWidth))) {; 1283 AdjustBinSize(wmin,wmax,n1a,binLow,binHigh,nbins,binWidth);; 1284 }; 1285 }; 1286 if ((wmin-binLow) > epsilon) { binLo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGaxis_8cxx_source.html:44769,avail,available,44769,doc/master/TGaxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGaxis_8cxx_source.html,1,['avail'],['available']
Availability,"1574/*! \brief compute the error function; 1575 *; 1576 *; 1577 */; 1578 template <typename Container, typename ItWeight>; 1579 double Net::errorFunction (LayerData& layerData,; 1580 Container truth,; 1581 ItWeight itWeight,; 1582 ItWeight itWeightEnd,; 1583 double patternWeight,; 1584 double factorWeightDecay,; 1585 EnumRegularization eRegularization) const; 1586 {; 1587 double error (0);; 1588 switch (m_eErrorFunction); 1589 {; 1590 case ModeErrorFunction::SUMOFSQUARES:; 1591 {; 1592 error = sumOfSquares (layerData.valuesBegin (), layerData.valuesEnd (), begin (truth), end (truth),; 1593 layerData.deltasBegin (), layerData.deltasEnd (),; 1594 layerData.inverseActivationFunction (),; 1595 patternWeight);; 1596 break;; 1597 }; 1598 case ModeErrorFunction::CROSSENTROPY:; 1599 {; 1600 assert (!TMVA::DNN::isFlagSet (ModeOutputValues::DIRECT, layerData.outputMode ()));; 1601 std::vector<double> probabilities = layerData.probabilities ();; 1602 error = crossEntropy (begin (probabilities), end (probabilities),; 1603 begin (truth), end (truth),; 1604 layerData.deltasBegin (), layerData.deltasEnd (),; 1605 layerData.inverseActivationFunction (),; 1606 patternWeight);; 1607 break;; 1608 }; 1609 case ModeErrorFunction::CROSSENTROPY_MUTUALEXCLUSIVE:; 1610 {; 1611 std::cout << ""softmax."" << std::endl;; 1612 assert (!TMVA::DNN::isFlagSet (ModeOutputValues::DIRECT, layerData.outputMode ()));; 1613 std::vector<double> probabilities = layerData.probabilities ();; 1614 error = softMaxCrossEntropy (begin (probabilities), end (probabilities),; 1615 begin (truth), end (truth),; 1616 layerData.deltasBegin (), layerData.deltasEnd (),; 1617 layerData.inverseActivationFunction (),; 1618 patternWeight);; 1619 break;; 1620 }; 1621 }; 1622 if (factorWeightDecay != 0 && eRegularization != EnumRegularization::NONE); 1623 {; 1624 error = weightDecay (error, itWeight, itWeightEnd, factorWeightDecay, eRegularization);; 1625 }; 1626 return error;; 1627 }; 1628 ; 1629 ; 1630 ; 1631 ; 1632 ; 1633 ; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:53104,error,error,53104,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['error'],['error']
Availability,"157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2906; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3147; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3094; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::GetUUIDsTProcessUUID * GetUUIDs() constDefinition TROOT.h:275; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetListOfStreamerInfoTSeqCollection * GetListOfStreamerInfo() constDefinition TROOT.h:249; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:39287,error,error,39287,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['error'],['error']
Availability,"157; TROOT::Initializedstatic Bool_t Initialized()Return kTRUE if the TROOT object has been initialized.Definition TROOT.cxx:2910; TROOT::GetApplicationTApplication * GetApplication() constDefinition TROOT.h:209; TROOT::SetBatchvoid SetBatch(Bool_t batch=kTRUE)Set batch mode for ROOT If the argument evaluates to true, the session does not use interactive graph...Definition TROOT.cxx:2803; TROOT::fLineIsProcessingInt_t fLineIsProcessingTo synchronize multi-threads.Definition TROOT.h:100; TROOT::TimerInt_t Timer() constDefinition TROOT.h:336; TROOT::GetSourceDirstatic const TString & GetSourceDir()Get the source directory in the installation. Static utility function.Definition TROOT.cxx:3151; TROOT::GetMacroDirstatic const TString & GetMacroDir()Get the macro directory in the installation. Static utility function.Definition TROOT.cxx:3098; TROOT::fGitCommitTString fGitCommitGit commit SHA1 of built.Definition TROOT.h:120; TROOT::ProcessLineLongptr_t ProcessLine(const char *line, Int_t *error=nullptr)Process interpreter command via TApplication::ProcessLine().Definition TROOT.cxx:2370; TROOT::fClosedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::GetUUIDsTProcessUUID * GetUUIDs() constDefinition TROOT.h:275; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetListOfStreamerInfoTSeqCollection * GetListOfStreamerInfo() constDefinition TROOT.h:249; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::~TROOTvirtual ~TROOT()Clean",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:39286,error,error,39286,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['error'],['error']
Availability,"16233 if (version_id > 0); 16234 ret |= SSL_OP_NO_SSLv2;; 16235 if (version_id > 1); 16236 ret |= SSL_OP_NO_SSLv3;; 16237 if (version_id > 2); 16238 ret |= SSL_OP_NO_TLSv1;; 16239 if (version_id > 3); 16240 ret |= SSL_OP_NO_TLSv1_1;; 16241 if (version_id > 4); 16242 ret |= SSL_OP_NO_TLSv1_2;; 16243#if defined(SSL_OP_NO_TLSv1_3); 16244 if (version_id > 5); 16245 ret |= SSL_OP_NO_TLSv1_3;; 16246#endif; 16247 return (long)ret;; 16248}; 16249#endif /* OPENSSL_API_1_1 */; 16250 ; 16251 ; 16252/* SSL callback documentation:; 16253 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16254 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16255 * https://linux.die.net/man/3/ssl_set_info_callback */; 16256/* Note: There is no ""const"" for the first argument in the documentation; 16257 * examples, however some (maybe most, but not all) headers of OpenSSL; 16258 * versions / OpenSSL compatibility layers have it. Having a different; 16259 * definition will cause a warning in C and an error in C++. Use ""const SSL; 16260 * *"", while automatical conversion from ""SSL *"" works for all compilers,; 16261 * but not other way around */; 16262static void; 16263ssl_info_callback(const SSL *ssl, int what, int ret); 16264{; 16265 (void)ret;; 16266 ; 16267 if (what & SSL_CB_HANDSHAKE_START) {; 16268 SSL_get_app_data(ssl);; 16269 }; 16270 if (what & SSL_CB_HANDSHAKE_DONE) {; 16271 /* TODO: check for openSSL 1.1 */; 16272 //#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001; 16273 // ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;; 16274 }; 16275}; 16276 ; 16277 ; 16278static int; 16279ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16280{; 16281#if defined(GCC_DIAGNOSTIC); 16282#pragma GCC diagnostic push; 16283#pragma GCC diagnostic ignored ""-Wcast-align""; 16284#endif /* defined(GCC_DIAGNOSTIC) */; 16285 ; 16286 /* We used an aligned pointer in SSL_set_app_data */; 16287 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:480317,error,error,480317,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"16234 if (version_id > 0); 16235 ret |= SSL_OP_NO_SSLv2;; 16236 if (version_id > 1); 16237 ret |= SSL_OP_NO_SSLv3;; 16238 if (version_id > 2); 16239 ret |= SSL_OP_NO_TLSv1;; 16240 if (version_id > 3); 16241 ret |= SSL_OP_NO_TLSv1_1;; 16242 if (version_id > 4); 16243 ret |= SSL_OP_NO_TLSv1_2;; 16244#if defined(SSL_OP_NO_TLSv1_3); 16245 if (version_id > 5); 16246 ret |= SSL_OP_NO_TLSv1_3;; 16247#endif; 16248 return (long)ret;; 16249}; 16250#endif /* OPENSSL_API_1_1 */; 16251 ; 16252 ; 16253/* SSL callback documentation:; 16254 * https://www.openssl.org/docs/man1.1.0/ssl/SSL_set_info_callback.html; 16255 * https://wiki.openssl.org/index.php/Manual:SSL_CTX_set_info_callback(3); 16256 * https://linux.die.net/man/3/ssl_set_info_callback */; 16257/* Note: There is no ""const"" for the first argument in the documentation; 16258 * examples, however some (maybe most, but not all) headers of OpenSSL; 16259 * versions / OpenSSL compatibility layers have it. Having a different; 16260 * definition will cause a warning in C and an error in C++. Use ""const SSL; 16261 * *"", while automatical conversion from ""SSL *"" works for all compilers,; 16262 * but not other way around */; 16263static void; 16264ssl_info_callback(const SSL *ssl, int what, int ret); 16265{; 16266 (void)ret;; 16267 ; 16268 if (what & SSL_CB_HANDSHAKE_START) {; 16269 SSL_get_app_data(ssl);; 16270 }; 16271 if (what & SSL_CB_HANDSHAKE_DONE) {; 16272 /* TODO: check for openSSL 1.1 */; 16273 //#define SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS 0x0001; 16274 // ssl->s3->flags |= SSL3_FLAGS_NO_RENEGOTIATE_CIPHERS;; 16275 }; 16276}; 16277 ; 16278 ; 16279static int; 16280ssl_servername_callback(SSL *ssl, int *ad, void *arg); 16281{; 16282#if defined(GCC_DIAGNOSTIC); 16283#pragma GCC diagnostic push; 16284#pragma GCC diagnostic ignored ""-Wcast-align""; 16285#endif /* defined(GCC_DIAGNOSTIC) */; 16286 ; 16287 /* We used an aligned pointer in SSL_set_app_data */; 16288 struct mg_connection *conn = (struct mg_connection *)SSL_get_app_data",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:480350,error,error,480350,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"1626 printf("" Kolmo Probabil = %f for shape alone, =%f for normalisation alone\n"",prb1,prb2);; 1627 }; 1628 // This numerical error condition should never occur:; 1629 if (TMath::Abs(rsum1-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h1=%s\n"",h1->GetName());; 1630 if (TMath::Abs(rsum2-1) > 0.002) Warning(""KolmogorovTest"",""Numerical problems with h2=%s\n"",h2->GetName());; 1631 ; 1632 if(opt.Contains(""M"")) return dfmax; // return average of max distance; 1633 ; 1634 return prb;; 1635}; 1636 ; 1637 ; 1638////////////////////////////////////////////////////////////////////////////////; 1639/// Rebin only the X axis; 1640/// see Rebin2D; 1641 ; 1642TH2 *TH2::RebinX(Int_t ngroup, const char *newname); 1643{; 1644 return Rebin2D(ngroup, 1, newname);; 1645}; 1646 ; 1647 ; 1648////////////////////////////////////////////////////////////////////////////////; 1649/// Rebin only the Y axis; 1650/// see Rebin2D; 1651 ; 1652TH2 *TH2::RebinY(Int_t ngroup, const char *newname); 1653{; 1654 return Rebin2D(1, ngroup, newname);; 1655}; 1656 ; 1657////////////////////////////////////////////////////////////////////////////////; 1658/// Override TH1::Rebin as TH2::RebinX; 1659/// Rebinning in variable binning as for TH1 is not allowed; 1660/// If a non-null pointer is given an error is flagged; 1661/// see RebinX and Rebin2D; 1662 ; 1663TH2 * TH2::Rebin( Int_t ngroup, const char*newname, const Double_t *xbins); 1664{; 1665 if (xbins != nullptr) {; 1666 Error(""Rebin"",""Rebinning a 2-d histogram into variable bins is not supported (it is possible only for 1-d histograms). Return a nullptr"");; 1667 return nullptr;; 1668 }; 1669 Info(""Rebin"",""Rebinning only the x-axis. Use Rebin2D for rebinning both axes"");; 1670 return RebinX(ngroup, newname);; 1671}; 1672////////////////////////////////////////////////////////////////////////////////; 1673/// Rebin this histogram grouping nxgroup/nygroup bins along the xaxis/yaxis together.; 1674///; 1675/// if newname is not blank a new te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:66378,error,error,66378,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability,"1641 fU[ke2-1] = u2min;; 1642 goto L2000;; 1643// Error returns; 1644L1350:; 1645 Printf("" INVALID PARAMETER NUMBERS."");; 1646 goto L1450;; 1647L1400:; 1648 Printf("" LESS THAN FOUR POINTS REQUESTED."");; 1649L1450:; 1650 ierrf = -1;; 1651 fCstatu = ""USER ERROR"";; 1652 goto L2000;; 1653L1500:; 1654 Printf("" MNCONT UNABLE TO FIND FOUR POINTS."");; 1655 fU[ke1-1] = u1min;; 1656 fU[ke2-1] = u2min;; 1657 ierrf = 0;; 1658 fCstatu = ""FAILED"";; 1659L2000:; 1660 fCfrom = ""MNContour "";; 1661 fNfcnfr = nfcnco;; 1662}; 1663 ; 1664////////////////////////////////////////////////////////////////////////////////; 1665/// Cracks the free-format input; 1666///; 1667/// Cracks the free-format input, expecting zero or more; 1668/// alphanumeric fields (which it joins into COMAND(1:LNC)); 1669/// followed by one or more numeric fields separated by; 1670/// blanks and/or one comma. The numeric fields are put into; 1671/// the LLIST (but at most MXP) elements of PLIST.; 1672///; 1673/// IERR :; 1674/// - = 0 if no errors,; 1675/// - = 1 if error(s).; 1676 ; 1677void TMinuit::mncrck(TString cardbuf, Int_t maxcwd, TString &comand, Int_t &lnc,; 1678 Int_t mxp, Double_t *plist, Int_t &llist, Int_t &ierr, Int_t); 1679{; 1680 /* Initialized data */; 1681 ; 1682 char *cnull = nullptr;; 1683 const char *cnumer = ""123456789-.0+"";; 1684 ; 1685 /* Local variables */; 1686 Int_t ifld, iend, lend, left, nreq, ipos, kcmnd, nextb, ic, ibegin, ltoadd;; 1687 Int_t ielmnt, lelmnt[25], nelmnt;; 1688 TString ctemp;; 1689 char *celmnt[25];; 1690 char command[25];; 1691 ; 1692 /* Function Body */; 1693 char *crdbuf = (char*)cardbuf.Data();; 1694 lend = cardbuf.Length();; 1695 ielmnt = 0;; 1696 nextb = 1;; 1697 ierr = 0;; 1698// loop over words CELMNT; 1699L10:; 1700 for (ipos = nextb; ipos <= lend; ++ipos) {; 1701 ibegin = ipos;; 1702 if (crdbuf[ipos-1] == ' ') continue;; 1703 if (crdbuf[ipos-1] == ',') goto L250;; 1704 goto L150;; 1705 }; 1706 goto L300;; 1707L150:; 1708// found beginning of word, look for end",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:56796,error,errors,56796,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"16451static int; 16452init_ssl_ctx_impl(struct mg_context *phys_ctx,; 16453 struct mg_domain_context *dom_ctx,; 16454 const char *pem,; 16455 const char *chain); 16456{; 16457 int callback_ret;; 16458 int should_verify_peer;; 16459 int peer_certificate_optional;; 16460 const char *ca_path;; 16461 const char *ca_file;; 16462 int use_default_verify_paths;; 16463 int verify_depth;; 16464 struct timespec now_mt;; 16465 md5_byte_t ssl_context_id[16];; 16466 md5_state_t md5state;; 16467 int protocol_ver;; 16468 int ssl_cache_timeout;; 16469 ; 16470#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16471 && !defined(NO_SSL_DL); 16472 if ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {; 16473 mg_cry_ctx_internal(phys_ctx,; 16474 ""SSL_CTX_new (server) error: %s"",; 16475 ssl_error());; 16476 return 0;; 16477 }; 16478#else; 16479 if ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {; 16480 mg_cry_ctx_internal(phys_ctx,; 16481 ""SSL_CTX_new (server) error: %s"",; 16482 ssl_error());; 16483 return 0;; 16484 }; 16485#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16486 ; 16487#if defined(SSL_OP_NO_TLSv1_3); 16488 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16489 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16490 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2; 16491 | SSL_OP_NO_TLSv1_3);; 16492#else; 16493 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16494 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16495 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);; 16496#endif; 16497 ; 16498 protocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);; 16499 SSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));; 16500 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);; 16501 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);; 16502 SSL_CTX_set_options(dom_ctx->ssl_ctx,; 16503 SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);; 16504 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);; 16505 ; 16506",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:487413,error,error,487413,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"16452static int; 16453init_ssl_ctx_impl(struct mg_context *phys_ctx,; 16454 struct mg_domain_context *dom_ctx,; 16455 const char *pem,; 16456 const char *chain); 16457{; 16458 int callback_ret;; 16459 int should_verify_peer;; 16460 int peer_certificate_optional;; 16461 const char *ca_path;; 16462 const char *ca_file;; 16463 int use_default_verify_paths;; 16464 int verify_depth;; 16465 struct timespec now_mt;; 16466 md5_byte_t ssl_context_id[16];; 16467 md5_state_t md5state;; 16468 int protocol_ver;; 16469 int ssl_cache_timeout;; 16470 ; 16471#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \; 16472 && !defined(NO_SSL_DL); 16473 if ((dom_ctx->ssl_ctx = SSL_CTX_new(TLS_server_method())) == NULL) {; 16474 mg_cry_ctx_internal(phys_ctx,; 16475 ""SSL_CTX_new (server) error: %s"",; 16476 ssl_error());; 16477 return 0;; 16478 }; 16479#else; 16480 if ((dom_ctx->ssl_ctx = SSL_CTX_new(SSLv23_server_method())) == NULL) {; 16481 mg_cry_ctx_internal(phys_ctx,; 16482 ""SSL_CTX_new (server) error: %s"",; 16483 ssl_error());; 16484 return 0;; 16485 }; 16486#endif /* OPENSSL_API_1_1 || OPENSSL_API_3_0 */; 16487 ; 16488#if defined(SSL_OP_NO_TLSv1_3); 16489 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16490 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16491 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2; 16492 | SSL_OP_NO_TLSv1_3);; 16493#else; 16494 SSL_CTX_clear_options(dom_ctx->ssl_ctx,; 16495 SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1; 16496 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);; 16497#endif; 16498 ; 16499 protocol_ver = atoi(dom_ctx->config[SSL_PROTOCOL_VERSION]);; 16500 SSL_CTX_set_options(dom_ctx->ssl_ctx, ssl_get_protocol(protocol_ver));; 16501 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_SINGLE_DH_USE);; 16502 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);; 16503 SSL_CTX_set_options(dom_ctx->ssl_ctx,; 16504 SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION);; 16505 SSL_CTX_set_options(dom_ctx->ssl_ctx, SSL_OP_NO_COMPRESSION);; 16506 ; 16507",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:487446,error,error,487446,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"1660 TSystem *helper = FindHelper(path);; 1661 if (helper); 1662 return helper->GetPathInfo(path, buf);; 1663 ; 1664 return UnixFilestat(path, buf);; 1665}; 1666 ; 1667////////////////////////////////////////////////////////////////////////////////; 1668/// Get info about a file system: id, bsize, bfree, blocks.; 1669/// Id is file system type (machine dependend, see statfs()); 1670/// Bsize is block size of file system; 1671/// Blocks is total number of blocks in file system; 1672/// Bfree is number of free blocks in file system; 1673/// The function returns 0 in case of success and 1 if the file system could; 1674/// not be stat'ed.; 1675 ; 1676int TUnixSystem::GetFsInfo(const char *path, Long_t *id, Long_t *bsize,; 1677 Long_t *blocks, Long_t *bfree); 1678{; 1679 return UnixFSstat(path, id, bsize, blocks, bfree);; 1680}; 1681 ; 1682////////////////////////////////////////////////////////////////////////////////; 1683/// Create a link from file1 to file2. Returns 0 when successful,; 1684/// -1 in case of failure.; 1685 ; 1686int TUnixSystem::Link(const char *from, const char *to); 1687{; 1688 return ::link(from, to);; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// Create a symlink from file1 to file2. Returns 0 when successful,; 1693/// -1 in case of failure.; 1694 ; 1695int TUnixSystem::Symlink(const char *from, const char *to); 1696{; 1697#if defined(R__AIX); 1698 return ::symlink((char*)from, (char*)to);; 1699#else; 1700 return ::symlink(from, to);; 1701#endif; 1702}; 1703 ; 1704////////////////////////////////////////////////////////////////////////////////; 1705/// Unlink, i.e. remove, a file or directory. Returns 0 when successful,; 1706/// -1 in case of failure.; 1707 ; 1708int TUnixSystem::Unlink(const char *name); 1709{; 1710 TSystem *helper = FindHelper(name);; 1711 if (helper); 1712 return helper->Unlink(name);; 1713 ; 1714#if defined(R__SEEK64); 1715 struct stat64 finfo;; 1716 if (lstat64(name",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:51938,failure,failure,51938,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['failure'],['failure']
Availability,"1737 return 0;; 1738 }; 1739 ; 1740 if (sync); 1741 return gInterpreter->ProcessLineSynch(line, (TInterpreter::EErrorCode*)err);; 1742 else; 1743 return gInterpreter->ProcessLine(line, (TInterpreter::EErrorCode*)err);; 1744}; 1745 ; 1746////////////////////////////////////////////////////////////////////////////////; 1747/// Process a file containing a C++ macro.; 1748 ; 1749Longptr_t TApplication::ProcessFile(const char *file, Int_t *error, Bool_t keep); 1750{; 1751 return ExecuteFile(file, error, keep);; 1752}; 1753 ; 1754////////////////////////////////////////////////////////////////////////////////; 1755/// Execute a file containing a C++ macro (static method). Can be used; 1756/// while TApplication is not yet created.; 1757 ; 1758Longptr_t TApplication::ExecuteFile(const char *file, Int_t *error, Bool_t keep); 1759{; 1760 static const Int_t kBufSize = 1024;; 1761 ; 1762 if (!file || !*file) return 0;; 1763 ; 1764 TString aclicMode;; 1765 TString arguments;; 1766 TString io;; 1767 TString fname = gSystem->SplitAclicMode(file, aclicMode, arguments, io);; 1768 ; 1769 char *exnam = gSystem->Which(TROOT::GetMacroPath(), fname, kReadPermission);; 1770 if (!exnam) {; 1771 ::Error(""TApplication::ExecuteFile"", ""macro %s not found in path %s"", fname.Data(),; 1772 TROOT::GetMacroPath());; 1773 delete [] exnam;; 1774 if (error); 1775 *error = (Int_t)TInterpreter::kRecoverable;; 1776 return 0;; 1777 }; 1778 ; 1779 ::std::ifstream macro(exnam, std::ios::in);; 1780 if (!macro.good()) {; 1781 ::Error(""TApplication::ExecuteFile"", ""%s no such file"", exnam);; 1782 if (error); 1783 *error = (Int_t)TInterpreter::kRecoverable;; 1784 delete [] exnam;; 1785 return 0;; 1786 }; 1787 ; 1788 char currentline[kBufSize];; 1789 char dummyline[kBufSize];; 1790 int tempfile = 0;; 1791 int comment = 0;; 1792 int ifndefc = 0;; 1793 int ifdef = 0;; 1794 char *s = nullptr;; 1795 Bool_t execute = kFALSE;; 1796 Longptr_t retval = 0;; 1797 ; 1798 while (1) {; 1799 bool res = (bool)macro.getline(curr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TApplication_8cxx_source.html:68316,error,error,68316,doc/master/TApplication_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TApplication_8cxx_source.html,1,['error'],['error']
Availability,"174 /// \brief Register systematic variations for multiple existing columns using custom variation tags.; 1175 /// \param[in] colNames set of names of the columns for which varied values are provided.; 1176 /// \param[in] expression a string containing valid C++ code that evaluates to an RVec or RVecs containing the varied; 1177 /// values for the specified columns.; 1178 /// \param[in] variationTags names for each of the varied values, e.g. `""up""` and `""down""`.; 1179 /// \param[in] variationName a generic name for this set of varied values, e.g. `""ptvariation""`.; 1180 ///; 1181 /// This overload adds the possibility for the expression used to evaluate the varied values to be just-in-time; 1182 /// compiled. The example below shows how Vary() is used while dealing with multiple columns. The tags are defined as; 1183 /// `{""down"", ""up""}`.; 1184 /// ~~~{.cpp}; 1185 /// auto nominal_hx =; 1186 /// df.Vary({""x"", ""y""}, ""ROOT::RVec<ROOT::RVecD>{{x*0.9, x*1.1}, {y*0.9, y*1.1}}"", {""down"", ""up""}, ""xy""); 1187 /// .Histo1D(""x"", ""y"");; 1188 ///; 1189 /// auto hx = ROOT::RDF::Experimental::VariationsFor(nominal_hx);; 1190 /// hx[""nominal""].Draw();; 1191 /// hx[""xy:down""].Draw(""SAME"");; 1192 /// hx[""xy:up""].Draw(""SAME"");; 1193 /// ~~~; 1194 ///; 1195 /// \sa This Vary() overload for more information.; 1196 RInterface<Proxied, DS_t> Vary(const std::vector<std::string> &colNames, std::string_view expression,; 1197 const std::vector<std::string> &variationTags, std::string_view variationName); 1198 {; 1199 return JittedVaryImpl(colNames, expression, variationTags, variationName, /*isSingleColumn=*/false);; 1200 }; 1201 ; 1202 ////////////////////////////////////////////////////////////////////////////; 1203 /// \brief Allow to refer to a column with a different name.; 1204 /// \param[in] alias name of the column alias; 1205 /// \param[in] columnName of the column to be aliased; 1206 /// \return the first node of the computation graph for which the alias is available.; 1207 ///; 1208 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:65120,down,down,65120,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['down'],['down']
Availability,175543 43692.5 5; : 933 Minimum Test error found - save the configuration ; : 933 | 4.07608 6.08713 0.0202588 0.00184594 43447.8 0; : 934 | 4.3998 6.10426 0.0204691 0.00178412 42815.1 1; : 935 | 4.23034 6.39854 0.0202977 0.00176426 43165.2 2; : 936 Minimum Test error found - save the configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.29174 0.0201055 0.00180854 43723.1 1; : 941 | 3.89757 5.80965 0.0203179 0.00179759 43195.8 2; : 942 | 3.94904 5.73464 0.0200877 0.00175468 43637.1 3; : 943 | 3.90362 5.73888 0.0200954 0.00175028 43608.4 4; : 944 | 3.87035 5.70718 0.0200345 0.0017513 43756.1 5; : 945 | 4.07017 5.95519 0.020321 0.00177709 43140.8 6; : 946 Minimum Test error found - save the configuration ; : 946 | 4.03451 5.59581 0.0201405 0.00182817 43686.3 0; : 947 | 3.85593 5.66203 0.0200425 0.00175434 43744.1 1; : 948 Minimum Test error found - save the configuration ; : 948 | 3.86683 5.35682 0.0204778 0.00185498 42958.2 0; : 949 Minimum Test error found - save the configuration ; : 949 | 3.68334 5.31467 0.0201988 0.00181717 43521.8 0; : 950 | 3.73312 5.52286 0.0201437 0.00175576 43506.8 1; : 951 | 3.85908 5.35112 0.0203536 0.00178284 43078.6 2; : 952 | 3.97296 5.91801 0.0201499 0.00177356 43534.3 3; : 953 Minimum Test error found - save the configuration ; : 953 | 3.78482 5.22353 0.0202416 0.0018489 43495.5 0; : 954 | 3.77661 6.79704 0.0200822 0.00176597 43677.1 1; : 955 | 4.26211 5.70833 0.020048 0.0017647 43755.8 2; : 956 | 3.83703 5.25865 0.0200643 0.00176603 43720 3; : 957 Minimum Test error found - save the configuration ; : 957 | 3.70429 5.19606 0.0204948 0.00189018 43000 0; : 958 | 3.80095 5.43788 0.0203069 0.00176137 43137.1 1; : 959 Minimum Test er,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:109400,error,error,109400,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175638 42972.7 1; : 880 | 5.71571 8.37499 0.0201251 0.00178041 43609.3 2; : 881 | 5.7556 8.5037 0.0200424 0.00175411 43743.8 3; : 882 | 5.47815 8.64255 0.0200508 0.00175977 43737.3 4; : 883 | 5.49484 8.19099 0.0201663 0.00175135 43443 5; : 884 Minimum Test error found - save the configuration ; : 884 | 5.44144 8.14796 0.020157 0.00182376 43636.7 0; : 885 | 5.72885 9.21369 0.0207466 0.00176462 42145.2 1; : 886 | 5.67418 8.64993 0.0200759 0.00176094 43680.2 2; : 887 Minimum Test error found - save the configuration ; : 887 | 5.55202 8.05484 0.0201465 0.00184145 43703.7 0; : 888 Minimum Test error found - save the configuration ; : 888 | 5.4009 7.86368 0.0201494 0.00184759 43711.4 0; : 889 | 5.09006 7.93881 0.0200766 0.00176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.7864,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:105480,error,error,105480,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error found - save the configuration ; : 916 | 4.49553 6.65717 0.0201015 0.00180949 43734.9 0; : 917 Minimum Test error found - save the configuration ; : 917 | 4.36563 6.60613 0.0201007 0.00181415 43748 0; : 918 Minimum Test error found - save the configuration ; : 918 | 4.47049 6.3479 0.0200865 0.00182018 43796.4 0; : 919 | 4.35846 6.60136 0.0200632 0.00176343 43716.3 1; : 920 | 4.30933 6.53557 0.0200239 0.00175965 43801.4 2; : 921 Minimum Test error found - save the configuration ; : 921 | 4.32266 6.29119 0.0200952 0.00182605 43789.5 0; : 922 | 4.32742 6.39561 0.0200257 0.00176292 43804.9 1; : 923 | 4.33774 6.46608 0.0200201 0.00176071 43813 2; : 924 | 4.36503 6.3111 0.0200702 0.00177545 43728.3 3; : 925 | 4.7314 7.24632 0.0202093 0.00176259 43368.2 4; : 926 | 4.61316 6.64099 0.020249 0.00181216 43391.3 5; : 927 Minimum Test error found - save the configuration ; : 927 | 4.41727 6.09792 0.0203192 0.00184107 43294.4 0; : 928 | 4.15393 6.23618 0.0200677 0.00177036 43722.3 1; : 929 | 4.2848 6.29195 0.0202769 0.00175908 43201.6 2; : 930 | 4.39879 6.60248 0.0204218 0.00176177 42872.3 3; : 931 | 4.17549 6.55946 0.0200581 0.00175886 43717.6 4; : 932 | 4.18849 6.67063 0.0200652 0.00175543 43692.5 5; : 933 Minimum Test error found - save the configuration ; : 933 | 4.07608 6.08713 0.0202588 0.00184594 43447.8 0; : 934 | 4.3998 6.10426 0.0204691 0.00178412 42815.1 1; : 935 | 4.23034 6.39854 0.0202977 0.00176426 43165.2 2; : 936 Minimum Test error found - save the configuration ; : 936 | 4.45077 5.93539 0.020128 0.0018336 43729.3 0; : 937 | 4.31583 6.35935 0.0203501 0.00176302 43040.6 1; : 938 Minimum Test error found - save the configuration ; : 938 | 4.1293 5.8271 0.0205749 0.0018749 42780.8 0; : 939 Minimum Test error found - save the configuration ; : 939 | 4.02273 5.7049 0.0206164 0.00186577 42665.2 0; : 940 | 3.91188 6.2917,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:108056,error,error,108056,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0.0200406 0.00175563 43751.8 2; : 803 | 10.2123 14.6873 0.0200478 0.00175638 43736.3 3; : 804 | 10.1133 14.2109 0.0201368 0.00176313 43540.5 4; : 805 Minimum Test error found - save the configuration ; : 805 | 10.3447 13.9911 0.0201319 0.00182751 43705.3 0; : 806 | 10.3558 15.0191 0.0200537 0.00175652 43722.7 1; : 807 Minimum Test error found - save the configuration ; : 807 | 9.87362 13.4104 0.0202002 0.0018848 43679 0; : 808 | 9.75883 13.5009 0.0202529 0.00175832 43255.9 1; : 809 | 9.54989 13.8103 0.0201225 0.00175709 43560.3 2; : 810 Minimum Test error found - save the configuration ; : 810 | 9.43647 13.1509 0.0201534 0.00182442 43646.8 0; : 811 | 9.40272 13.8504 0.0200559 0.00175676 43717.9 1; : 812 Minimum Test error found - save the configuration ; : 812 | 9.42328 13.0239 0.0202708 0.00183859 43402.3 0; : 813 | 9.26754 13.347 0.0200488 0.00175838 43738.7 1; : 814 | 9.30693 13.2737 0.0200298 0.0017551 43776.4 2; : 815 | 9.2453 13.4411 0.0200383 0.0017608 43769.8 3; : 816 Minimum Test error found - save the configuration ; : 816 | 8.97729 12.8621 0.0200894 0.00181862 43785.8 0; : 817 | 9.05512 13.256 0.0200147 0.0017603 43825 1; : 818 Minimum Test error found - save the configuration ; : 818 | 8.88115 12.6122 0.0201221 0.00182968 43733.9 0; : 819 | 8.6338 13.2547 0.0200872 0.00177159 43678.6 1; : 820 Minimum Test error found - save the configuration ; : 820 | 8.87738 12.3889 0.0200904 0.00182003 43786.8 0; : 821 Minimum Test error found - save the configuration ; : 821 | 8.4572 12.2134 0.0200973 0.00182161 43774.1 0; : 822 | 8.40042 12.784,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:99132,error,error,99132,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,175856 43509.3 2; : 837 | 7.98319 11.3225 0.0201169 0.00175643 43571.8 3; : 838 | 7.66699 11.6657 0.0201662 0.00181142 43585.5 4; : 839 Minimum Test error found - save the configuration ; : 839 | 7.52525 10.9666 0.0202646 0.00182844 43392.9 0; : 840 | 7.48548 11.313 0.020051 0.00174873 43710.5 1; : 841 | 7.28024 11.1847 0.0200374 0.0017493 43744.4 2; : 842 | 7.18939 11.0082 0.0200397 0.00175322 43748.2 3; : 843 Minimum Test error found - save the configuration ; : 843 | 7.01613 10.4197 0.0201334 0.00182993 43707.5 0; : 844 | 6.83302 10.8151 0.020039 0.00176037 43767.1 1; : 845 | 6.97518 10.5462 0.0200409 0.00175987 43761.2 2; : 846 | 6.93317 10.5904 0.0200239 0.00176026 43802.8 3; : 847 | 6.86223 10.6492 0.0200268 0.00176058 43796.8 4; : 848 | 7.00201 10.9279 0.0200258 0.00175939 43796.3 5; : 849 | 6.9266 10.4735 0.0200333 0.00176264 43785.9 6; : 850 | 6.72856 10.6877 0.0200521 0.00176189 43739.2 7; : 851 | 6.84236 10.8522 0.0200238 0.00176009 43802.7 8; : 852 Minimum Test error found - save the configuration ; : 852 | 6.78011 10.0733 0.0201111 0.00182524 43749.6 0; : 853 Minimum Test error found - save the configuration ; : 853 | 6.53284 9.90736 0.0201187 0.00181829 43714.8 0; : 854 | 6.67108 10.0768 0.0205443 0.0017732 42618.8 1; : 855 | 6.58878 10.7427 0.0200637 0.00176264 43713.2 2; : 856 | 6.54513 10.3387 0.0200413 0.00176141 43764 3; : 857 Minimum Test error found - save the configuration ; : 857 | 6.43616 9.72218 0.020097 0.00182688 43787.4 0; : 858 | 6.34936 10.0458 0.0200349 0.00176193 43780.5 1; : 859 Minimum Test error found - save the configuration ; : 859 | 6.20554 9.48603 0.0201607 0.00183833 43662.6 0; : 860 | 6.16695 10.0812 0.0200598 0.00175295 43699.5 1; : 861 Minimum Test error found - save the configuration ; : 861 | 6.43224 9.42041 0.0201492 0.00182399 43655.7 0; : 862 | 6.08067 10.0276 0.0200725 0.0017577 43680.5 1; : 863 | 6.34296 10.0575 0.0200642 0.00175521 43694.5 2; : 864 Minimum Test error found - save the configuration ; : 864 | 6.33486 9,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:102274,error,error,102274,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,17637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.0149 24.223 0.0201139 0.00181842 43726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.6778 23.9945 0.0201044 0.00181062 43730.7 0; : 730 | 22.455 23.9981 0.020057 0.0017578 43717.8 1; : 731 Minimum Test ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:91015,error,error,91015,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,176618 43691 1; : 890 | 5.16257 8.05551 0.0200625 0.00176866 43730.7 2; : 891 Minimum Test error found - save the configuration ; : 891 | 5.07326 7.82028 0.0201532 0.0018382 43680.1 0; : 892 | 5.14088 7.89491 0.0200852 0.00179174 43731.4 1; : 893 Minimum Test error found - save the configuration ; : 893 | 5.13302 7.67646 0.0201541 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 6.77041 0.0201181 0.00182552 43733.5 0; : 913 | 4.96617 7.29752 0.0200675 0.00175608 43688.5 1; : 914 | 4.79524 7.25946 0.0200357 0.00175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:106208,error,error,106208,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1791 SysError(""ReadBuffer"", ""error reading from file %s"", GetName());; 1792 return kTRUE;; 1793 }; 1794 if (siz != len) {; 1795 Error(""ReadBuffer"", ""error reading all requested bytes from file %s, got %ld of %d"",; 1796 GetName(), (Long_t)siz, len);; 1797 return kTRUE;; 1798 }; 1799 fBytesRead += siz;; 1800 fgBytesRead += siz;; 1801 fReadCalls++;; 1802 fgReadCalls++;; 1803 ; 1804 if (gMonitoringWriter); 1805 gMonitoringWriter->SendFileReadProgress(this);; 1806 if (gPerfStats) {; 1807 gPerfStats->FileReadEvent(this, len, start);; 1808 }; 1809 return kFALSE;; 1810 }; 1811 return kTRUE;; 1812}; 1813 ; 1814////////////////////////////////////////////////////////////////////////////////; 1815/// Read the nbuf blocks described in arrays pos and len.; 1816///; 1817/// The value pos[i] is the seek position of block i of length len[i].; 1818/// Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer.; 1819/// This function is overloaded by TNetFile, TWebFile, etc.; 1820/// Returns kTRUE in case of failure.; 1821 ; 1822Bool_t TFile::ReadBuffers(char *buf, Long64_t *pos, Int_t *len, Int_t nbuf); 1823{; 1824 // called with buf=0, from TFileCacheRead to pass list of readahead buffers; 1825 if (!buf) {; 1826 for (Int_t j = 0; j < nbuf; j++) {; 1827 if (ReadBufferAsync(pos[j], len[j])) {; 1828 return kTRUE;; 1829 }; 1830 }; 1831 return kFALSE;; 1832 }; 1833 ; 1834 Int_t k = 0;; 1835 Bool_t result = kTRUE;; 1836 TFileCacheRead *old = fCacheRead;; 1837 fCacheRead = nullptr;; 1838 Long64_t curbegin = pos[0];; 1839 Long64_t cur;; 1840 char *buf2 = nullptr;; 1841 Int_t i = 0, n = 0;; 1842 while (i < nbuf) {; 1843 cur = pos[i]+len[i];; 1844 Bool_t bigRead = kTRUE;; 1845 if (cur -curbegin < fgReadaheadSize) {n++; i++; bigRead = kFALSE;}; 1846 if (bigRead || (i>=nbuf)) {; 1847 if (n == 0) {; 1848 //if the block to read is about the same size as the read-ahead buffer; 1849 //we read the block directly; 1850 Seek(pos[i]);; 1851 result = ReadBuffer(&buf[k], len[i]);; 1852 if (result",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:65798,failure,failure,65798,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['failure'],['failure']
Availability,"18#if defined(__STDC_VERSION__) && __STDC_VERSION__ > 201100L; 119#define mg_static_assert _Static_assert; 120#elif defined(__cplusplus) && __cplusplus >= 201103L; 121#define mg_static_assert static_assert; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping be",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:5751,avail,available,5751,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['avail'],['available']
Availability,181141 43797.6 0; : 769 Minimum Test error found - save the configuration ; : 769 | 14.3366 17.8635 0.0200909 0.00180773 43756.2 0; : 770 Minimum Test error found - save the configuration ; : 770 | 14.5733 17.5465 0.0200968 0.00180191 43728 0; : 771 | 13.9827 17.8429 0.0200367 0.0017469 43740.1 1; : 772 Minimum Test error found - save the configuration ; : 772 | 14.2497 17.3556 0.0201068 0.00181254 43729.6 0; : 773 | 14.0413 17.7428 0.020033 0.00175319 43764.2 1; : 774 Minimum Test error found - save the configuration ; : 774 | 13.9671 16.982 0.020108 0.00180715 43713.8 0; : 775 | 13.7965 17.224 0.0200334 0.0017548 43767 1; : 776 | 13.601 17.9652 0.0200139 0.00175385 43811.5 2; : 777 | 14.0445 17.0226 0.0200253 0.00175316 43782.5 3; : 778 Minimum Test error found - save the configuration ; : 778 | 13.4936 16.5395 0.0200845 0.00181482 43788.4 0; : 779 | 13.0033 16.7495 0.0200505 0.00176209 43743.6 1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Mi,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:96654,error,error,96654,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90676,error,error,90676,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"182THn::THn(const char* name, const char* title,; 183 Int_t dim, const Int_t* nbins,; 184 const Double_t* xmin, const Double_t* xmax):; 185 THnBase(name, title, dim, nbins, xmin, xmax),; 186 fSumw2(dim, nbins, kTRUE /*overflow*/); 187{; 188}; 189 ; 190THn::THn(const char *name, const char *title, Int_t dim, const Int_t *nbins,; 191 const std::vector<std::vector<double>> &xbins); 192 : THnBase(name, title, dim, nbins, xbins), fSumw2(dim, nbins, kTRUE /*overflow*/); 193{; 194}; 195 ; 196////////////////////////////////////////////////////////////////////////////////; 197/// Destruct a THn; 198 ; 199THn::~THn(); 200{; 201}; 202 ; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Create an iterator over all bins. Public interface is THnIter.; 206 ; 207ROOT::Internal::THnBaseBinIter* THn::CreateIter(Bool_t respectAxisRange) const; 208{; 209 return new THnBinIter(GetNdimensions(), GetListOfAxes(), &GetArray(),; 210 respectAxisRange);; 211}; 212 ; 213////////////////////////////////////////////////////////////////////////////////; 214/// Enable calculation of errors; 215 ; 216void THn::Sumw2() {; 217 if (!GetCalculateErrors()) {; 218 fTsumw2 = 0.;; 219 }; 220 // fill sumw2 array with current content; 221 TNDArray & content = GetArray();; 222 Long64_t nbins = GetNbins();; 223 for (Long64_t ibin = 0; ibin < nbins; ++ibin); 224 fSumw2.At(ibin) = content.AtAsDouble(ibin);; 225}; 226 ; 227 ; 228////////////////////////////////////////////////////////////////////////////////; 229/// Create the coordinate buffer. Outlined to hide allocation; 230/// from inlined functions.; 231 ; 232void THn::AllocCoordBuf() const; 233{; 234 fCoordBuf.assign(fNdimensions, 0);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Initialize the storage of a histogram created via Init(); 239 ; 240void THn::InitStorage(Int_t* nbins, Int_t /*chunkSize*/); 241{; 242 fCoordBuf.assign(fNdimensions, 0);; 243",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THn_8cxx_source.html:7909,error,errors,7909,doc/master/THn_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THn_8cxx_source.html,1,['error'],['errors']
Availability,"186 if( command.size() < 1 ) {; 187 error_string = ""Parsing error, wrond or no value specified for key: "" + key;; 188 return false;; 189 }; 190 ; 191 Bool_t hasquote = command[0] == '""';; 192 ; 193 //--------------------------------------------------------------------; 194 // Processing code tag: ""{ code }""; 195 ///////////////////////////////////////////////////////////////////////; 196 ; 197 if( key == ""code"" ) {; 198 // Cleaning of the input command:; 199 // - Trim whitespaces at the borders; 200 // - Get the inner command (i.e. the part between quotes); 201 // - Trim whitespaces again; 202 // - Stitch back together; 203 auto clean_command = [](const std::string &c) {; 204 auto first_trim = TSchemaRuleProcessor::Trim(c);; 205 auto inner_command =; 206 first_trim.substr(first_trim.find_first_of('""') + 1, first_trim.find_last_of('""') - 1);; 207 auto second_trim = TSchemaRuleProcessor::Trim(inner_command);; 208 return '""' + second_trim + '""';; 209 };; 210 command = clean_command(command);; 211 ; 212 if( command[1] != '{' ) {; 213 error_string = ""Parsing error while processing key: code\n"";; 214 error_string += ""Expected \""{ at the beginning of the value."";; 215 return false;; 216 }; 217 l = command.find( ""}\"""" );; 218 if( l == std::string::npos ) {; 219 error_string = ""Parsing error while processing key: \"""" + key + ""\""\n"";; 220 error_string += ""Expected }\"" at the end of the value."";; 221 return false;; 222 }; 223 auto rawCode = command.substr( 2, l-2 );; 224 RemoveEscapeSequences(rawCode);; 225 result[key] = rawCode;; 226 ++l;; 227 }; 228 //--------------------------------------------------------------------; 229 // Processing normal tag: ""value""; 230 ///////////////////////////////////////////////////////////////////////; 231 ; 232 else {; 233 if( hasquote) {; 234 l = command.find( '""', 1 );; 235 if (l == std::string::npos ) {; 236 error_string = ""\nParsing error while processing key: \"""" + key + ""\""\n"";; 237 error_string += ""Expected \"" at the end of the value."";",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html:7882,error,error,7882,doc/master/RConversionRuleParser_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RConversionRuleParser_8cxx_source.html,2,['error'],['error']
Availability,"187 MATH_ERROR_MSG(""Minimizer::Hesse"", ""Hesse not implemented"");; 188 return false;; 189}; 190 ; 191/**; 192 scan function minimum for variable i. Variable and function must be set before using Scan; 193 Return false if an error or if minimizer does not support this functionality; 194 */; 195bool Minimizer::Scan(unsigned int ivar, unsigned int &nstep, double *x, double *y, double xmin, double xmax); 196{; 197 MATH_ERROR_MSG(""Minimizer::Scan"", ""Scan not implemented"");; 198 MATH_UNUSED(ivar);; 199 MATH_UNUSED(nstep);; 200 MATH_UNUSED(x);; 201 MATH_UNUSED(y);; 202 MATH_UNUSED(xmin);; 203 MATH_UNUSED(xmax);; 204 return false;; 205}; 206 ; 207/**; 208 find the contour points (xi, xj) of the function for parameter ivar and jvar around the minimum; 209 The contour will be find for value of the function = Min + ErrorUp();; 210 */; 211bool Minimizer::Contour(unsigned int ivar, unsigned int jvar, unsigned int &npoints, double *xi, double *xj); 212{; 213 MATH_ERROR_MSG(""Minimizer::Contour"", ""Contour not implemented"");; 214 MATH_UNUSED(ivar);; 215 MATH_UNUSED(jvar);; 216 MATH_UNUSED(npoints);; 217 MATH_UNUSED(xi);; 218 MATH_UNUSED(xj);; 219 return false;; 220}; 221 ; 222/// get name of variables (override if minimizer support storing of variable names); 223/// return an empty string if variable is not found; 224std::string Minimizer::VariableName(unsigned int ivar) const; 225{; 226 MATH_UNUSED(ivar);; 227 return std::string(); // return empty string; 228}; 229 ; 230/// get index of variable given a variable given a name; 231/// return -1 if variable is not found; 232int Minimizer::VariableIndex(const std::string &name) const; 233{; 234 MATH_ERROR_MSG(""Minimizer::VariableIndex"", ""Getting variable index from name not implemented"");; 235 MATH_UNUSED(name);; 236 return -1;; 237}; 238 ; 239} // namespace Math; 240} // namespace ROOT; Error.h; MATH_ERROR_MSG#define MATH_ERROR_MSG(loc, str)Definition Error.h:83; MATH_WARN_MSG#define MATH_WARN_MSG(loc, str)Definition Error.h:80; Minimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8cxx_source.html:6906,error,error,6906,doc/master/Minimizer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8cxx_source.html,1,['error'],['error']
Availability,"191 ; 1192 template <typename OutputContainer>; 1193 void fetchOutput (const LayerData& lastLayerData, OutputContainer& outputContainer) const;; 1194 ; 1195 template <typename OutputContainer>; 1196 void fetchOutput (const std::vector<LayerData>& layerPatternData, OutputContainer& outputContainer) const;; 1197 ; 1198 ; 1199 template <typename ItWeight>; 1200 std::tuple</*sumError*/double,/*sumWeights*/double> computeError (const Settings& settings,; 1201 std::vector<LayerData>& lastLayerData,; 1202 Batch& batch,; 1203 ItWeight itWeightBegin,; 1204 ItWeight itWeightEnd) const;; 1205 ; 1206 template <typename Settings>; 1207 void backPropagate (std::vector<std::vector<LayerData>>& layerPatternData,; 1208 const Settings& settings,; 1209 size_t trainFromLayer,; 1210 size_t totalNumWeights) const;; 1211 ; 1212 ; 1213 ; 1214 /*! \brief main NN computation function; 1215 *; 1216 *; 1217 */; 1218 template <typename LayerContainer, typename PassThrough, typename ItWeight, typename ItGradient, typename OutContainer>; 1219 double forward_backward (LayerContainer& layers, PassThrough& settingsAndBatch,; 1220 ItWeight itWeightBegin, ItWeight itWeightEnd,; 1221 ItGradient itGradientBegin, ItGradient itGradientEnd,; 1222 size_t trainFromLayer,; 1223 OutContainer& outputContainer, bool fetchOutput) const;; 1224 ; 1225 ; 1226 ; 1227 double E ();; 1228 void dE ();; 1229 ; 1230 ; 1231 /*! \brief computes the error of the DNN; 1232 *; 1233 *; 1234 */; 1235 template <typename Container, typename ItWeight>; 1236 double errorFunction (LayerData& layerData,; 1237 Container truth,; 1238 ItWeight itWeight,; 1239 ItWeight itWeightEnd,; 1240 double patternWeight,; 1241 double factorWeightDecay,; 1242 EnumRegularization eRegularization) const;; 1243 ; 1244 ; 1245 const std::vector<Layer>& layers () const { return m_layers; } ///< returns the layers (structure); 1246 std::vector<Layer>& layers () { return m_layers; } ///< returns the layers (structure); 1247 ; 1248 void removeLayer () { m_layers.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8h_source.html:45270,error,error,45270,doc/master/NeuralNet_8h_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8h_source.html,2,['error'],"['error', 'errorFunction']"
Availability,"1959 BufferEmpty();; 1960 delete [] fBuffer;; 1961 fBuffer = nullptr;; 1962 }; 1963 if (buffersize <= 0) {; 1964 fBufferSize = 0;; 1965 return;; 1966 }; 1967 if (buffersize < 100) buffersize = 100;; 1968 fBufferSize = 1 + 4*buffersize;; 1969 fBuffer = new Double_t[fBufferSize];; 1970 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1971}; 1972 ; 1973////////////////////////////////////////////////////////////////////////////////; 1974/// Set option to compute profile2D errors.; 1975///; 1976/// The computation of the bin errors is based on the parameter option:; 1977/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (Z),; 1978/// i.e. the standard error of the bin contents.; 1979/// Note that if TProfile::Approximate() is called, an approximation is used when; 1980/// the spread in Z is 0 and the number of bin entries is > 0; 1981/// - 's' The bin errors are the standard deviations of the Z bin values; 1982/// Note that if TProfile::Approximate() is called, an approximation is used when; 1983/// the spread in Z is 0 and the number of bin entries is > 0; 1984/// - 'i' Errors are as in default case (standard errors of the bin contents); 1985/// The only difference is for the case when the spread in Z is zero.; 1986/// In this case for N > 0 the error is 1./SQRT(12.*N); 1987/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1988/// W is the sum in the bin of the weights of the profile.; 1989/// This option is for combining measurements z +/- dz,; 1990/// and the profile is filled with values y and weights z = 1/dz**2; 1991///; 1992/// See TProfile::BuildOptions for a detailed explanation of all options; 1993 ; 1994void TProfile2D::SetErrorOption(Option_t *option); 1995{; 1996 TProfileHelper::SetErrorOption(this, option);; 1997}; 1998 ; 1999////////////////////////////////////////////////////////////////////////////////; 2000/// Stream an object of class TProfile2D.; 2001 ; 2002void TProfile2D::Streamer(T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:72203,error,errors,72203,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,2,['error'],['errors']
Availability,"19712 exit_callback = init->callbacks->exit_context;; 19713 /* The exit callback is activated once the context is successfully; 19714 * created. It should not be called, if an incomplete context object; 19715 * is deleted during a failed initialization. */; 19716 ctx->callbacks.exit_context = 0;; 19717 }; 19718 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19719 ctx->dd.handlers = NULL;; 19720 ctx->dd.next = NULL;; 19721 ; 19722#if defined(USE_LUA); 19723 lua_ctx_init(ctx);; 19724#endif; 19725 ; 19726 /* Store options */; 19727 while (options && (name = *options++) != NULL) {; 19728 if ((idx = get_option_index(name)) == -1) {; 19729 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19730 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19731 mg_snprintf(NULL,; 19732 NULL, /* No truncation check for error buffers */; 19733 error->text,; 19734 error->text_buffer_size,; 19735 ""Invalid configuration option: %s"",; 19736 name);; 19737 }; 19738 free_context(ctx);; 19739 pthread_setspecific(sTlsKey, NULL);; 19740 return NULL;; 19741 } else if ((value = *options++) == NULL) {; 19742 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19743 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19744 mg_snprintf(NULL,; 19745 NULL, /* No truncation check for error buffers */; 19746 error->text,; 19747 error->text_buffer_size,; 19748 ""Invalid configuration option value: %s"",; 19749 name);; 19750 }; 19751 free_context(ctx);; 19752 pthread_setspecific(sTlsKey, NULL);; 19753 return NULL;; 19754 }; 19755 if (ctx->dd.config[idx] != NULL) {; 19756 /* A duplicate configuration option is not an error - the last; 19757 * option value will be used. */; 19758 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19759 mg_free(ctx->dd.config[idx]);; 19760 }; 19761 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19762 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19763 }; 19764 ; 19765 /* Set default value if needed */; 19766 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:588684,error,error,588684,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,10,['error'],['error']
Availability,"19713 exit_callback = init->callbacks->exit_context;; 19714 /* The exit callback is activated once the context is successfully; 19715 * created. It should not be called, if an incomplete context object; 19716 * is deleted during a failed initialization. */; 19717 ctx->callbacks.exit_context = 0;; 19718 }; 19719 ctx->user_data = ((init != NULL) ? (init->user_data) : (NULL));; 19720 ctx->dd.handlers = NULL;; 19721 ctx->dd.next = NULL;; 19722 ; 19723#if defined(USE_LUA); 19724 lua_ctx_init(ctx);; 19725#endif; 19726 ; 19727 /* Store options */; 19728 while (options && (name = *options++) != NULL) {; 19729 if ((idx = get_option_index(name)) == -1) {; 19730 mg_cry_ctx_internal(ctx, ""Invalid option: %s"", name);; 19731 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19732 mg_snprintf(NULL,; 19733 NULL, /* No truncation check for error buffers */; 19734 error->text,; 19735 error->text_buffer_size,; 19736 ""Invalid configuration option: %s"",; 19737 name);; 19738 }; 19739 free_context(ctx);; 19740 pthread_setspecific(sTlsKey, NULL);; 19741 return NULL;; 19742 } else if ((value = *options++) == NULL) {; 19743 mg_cry_ctx_internal(ctx, ""%s: option value cannot be NULL"", name);; 19744 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19745 mg_snprintf(NULL,; 19746 NULL, /* No truncation check for error buffers */; 19747 error->text,; 19748 error->text_buffer_size,; 19749 ""Invalid configuration option value: %s"",; 19750 name);; 19751 }; 19752 free_context(ctx);; 19753 pthread_setspecific(sTlsKey, NULL);; 19754 return NULL;; 19755 }; 19756 if (ctx->dd.config[idx] != NULL) {; 19757 /* A duplicate configuration option is not an error - the last; 19758 * option value will be used. */; 19759 mg_cry_ctx_internal(ctx, ""warning: %s: duplicate option"", name);; 19760 mg_free(ctx->dd.config[idx]);; 19761 }; 19762 ctx->dd.config[idx] = mg_strdup_ctx(value, ctx);; 19763 DEBUG_TRACE(""[%s] -> [%s]"", name, value);; 19764 }; 19765 ; 19766 /* Set default value if needed */; 19767 for ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:588717,error,error,588717,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,10,['error'],['error']
Availability,"1999, Vol.41, NO.3; What are robust estimators? ""An important property of an estimator is its robustness. An estimator; is called robust if it is insensitive to measurements that deviate; from the expected behaviour. There are 2 ways to treat such deviating; measurements: one may either try to recognise them and then remove; them from the data sample; or one may leave them in the sample, taking; care that they do not influence the estimate unduly. In both cases robust; estimators are needed...Robust procedures compensate for systematic errors; as much as possible, and indicate any situation in which a danger of not being; able to operate reliably is detected."" R.Fruhwirth, M.Regler, R.K.Bock, H.Grote, D.Notz ""Data Analysis Techniques for High-Energy Physics"", 2nd edition; What does this algorithm do? It computes a highly robust estimator of multivariate location and scatter. Then, it takes those estimates to compute robust distances of all the data vectors. Those with large robust distances are considered outliers. Robust distances can then be plotted for better visualization of the data.; How does this algorithm do it? The MCD objective is to find h observations(out of n) whose classical covariance matrix has the lowest determinant. The MCD estimator of location is then the average of those h points and the MCD estimate of scatter is their covariance matrix. The minimum(and default) h = (n+nvariables+1)/2 so the algorithm is effective when less than (n+nvar+1)/2 variables are outliers. The algorithm also allows for exact fit situations - that is, when h or more observations lie on a hyperplane. Then the algorithm still yields the MCD location T and scatter matrix S, the latter being singular as it should be. From (T,S) the program then computes the equation of the hyperplane.; How can this algorithm be used? In any case, when contamination of data is suspected, that might influence the classical estimates. Also, robust estimation of location and scatter is a tool to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRobustEstimator.html:1645,robust,robust,1645,doc/master/classTRobustEstimator.html,https://root.cern,https://root.cern/doc/master/classTRobustEstimator.html,1,['robust'],['robust']
Availability,"1::GetMaximumBin can be used to get the location of the maximum value. ; Reimplemented in TH2Poly.; Definition at line 8545 of file TH1.cxx. ◆ GetMaximumBin() [1/2]. Int_t TH1::GetMaximumBin ; (; ); const. virtual . Return location of bin with maximum value in the range. ; TH1::GetMaximum can be used to get the maximum value. ; Definition at line 8577 of file TH1.cxx. ◆ GetMaximumBin() [2/2]. Int_t TH1::GetMaximumBin ; (; Int_t & ; locmax, . Int_t & ; locmay, . Int_t & ; locmaz . ); const. virtual . Return location of bin with maximum value in the range. ; Definition at line 8586 of file TH1.cxx. ◆ GetMaximumStored(). virtual Double_t TH1::GetMaximumStored ; (; ); const. inlinevirtual . Definition at line 289 of file TH1.h. ◆ GetMean(). Double_t TH1::GetMean ; (; Int_t ; axis = 1); const. virtual . For axis = 1,2 or 3 returns the mean value of the histogram along X,Y or Z axis. ; For axis = 11, 12, 13 returns the standard error of the mean value of the histogram along X, Y or Z axis; Note that the mean value/StdDev is computed using the bins in the currently defined range (see TAxis::SetRange). By default the range includes all bins from 1 to nbins included, excluding underflows and overflows. To force the underflows and overflows in the computation, one must call the static function TH1::StatOverflows(kTRUE) before filling the histogram.; IMPORTANT NOTE: The returned value depends on how the histogram statistics are calculated. By default, if no range has been set, the returned mean is the (unbinned) one calculated at fill time. If a range has been set, however, the mean is calculated using the bins in range, as described above; THIS IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS–use TAxis::SetRange(0, 0) to unset the range. To ensure that the returned mean (and all other statistics) is always that of the binned data stored in the histogram, call TH1::ResetStats. See TH1::GetStats.; Return mean value of this histogram along the X axis. ; Definition at line 7535 of file",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:161144,error,error,161144,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBinomialEfficiencyFitter.html:10876,reliab,reliability,10876,root/html604/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html604/TBinomialEfficiencyFitter.html,4,"['error', 'reliab']","['errors', 'reliability']"
Availability,"1::Integral(). ROOT::Fit::Fitter* GetFitter(); Provide access to the underlying fitter object.; This may be useful e.g. for the retrieval of additional information (such; as the output covariance matrix of the fit). TFitResultPtr Fit(TF1* f1, Option_t* option = """"); Carry out the fit of the given function to the given histograms. If option ""I"" is used, the fit function will be averaged over the; bin (the default is to evaluate it simply at the bin center). If option ""R"" is used, the fit range will be taken from the fit; function (the default is to use the entire histogram). If option ""S"" a TFitResult object is returned and it can be used to obtain; additional fit information, like covariance or correlation matrix. Note that all parameter values, limits, and step sizes are copied; from the input fit function f1 (so they should be set before calling; this method. This is particularly relevant for the step sizes, taken; to be the ""error"" set on input, as a null step size usually fixes the; corresponding parameter. That is protected against, but in such cases; an arbitrary starting step size will be used, and the reliability of; the fit should be questioned). If parameters are to be fixed, this; should be done by specifying non-null parameter limits, with lower; limits larger than upper limits. On output, f1 contains the fitted parameters and errors, as well as; the number of degrees of freedom, and the goodness-of-fit estimator; as given by S. Baker and R. Cousins, Nucl. Instr. Meth. A221 (1984) 437. void ComputeFCN(Double_t& f, const Double_t* par); Compute the likelihood. TBinomialEfficiencyFitter(). Double_t EvaluateFCN(const Double_t* par). » Author: Frank Filthaut, Rene Brun 30/05/2007 » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/hist:$Id$ » Last generated: 2015-06-30 14:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TBinomialEfficiencyFitter.html:10876,reliab,reliability,10876,root/html602/TBinomialEfficiencyFitter.html,https://root.cern,https://root.cern/root/html602/TBinomialEfficiencyFitter.html,4,"['error', 'reliab']","['errors', 'reliability']"
Availability,1; : 1001 | 3.31742 4.17699 0.020287 0.00175118 43159.8 2; : 1002 | 3.35839 4.8143 0.0207434 0.00177731 42180.6 3; : 1003 Minimum Test error found - save the configuration ; : 1003 | 3.42381 4.04915 0.0202591 0.00184351 43441.4 0; : 1004 Minimum Test error found - save the configuration ; : 1004 | 3.27488 4.0384 0.0205262 0.00189376 42935.9 0; : 1005 | 3.09776 4.19224 0.0200956 0.00176781 43649.6 1; : 1006 Minimum Test error found - save the configuration ; : 1006 | 3.1757 3.91876 0.0201134 0.00183093 43757.7 0; : 1007 | 3.17471 4.33126 0.0203423 0.00178093 43100.3 1; : 1008 | 3.23752 4.46797 0.0204556 0.0017847 42847.4 2; : 1009 | 3.5099 4.04664 0.0203963 0.00177013 42950.3 3; : 1010 | 3.39993 4.32216 0.0201011 0.00176915 43639.8 4; : 1011 | 3.28002 4.35065 0.020045 0.00175269 43734.2 5; : 1012 | 3.24301 4.1309 0.0202482 0.00178612 43332 6; : 1013 | 3.47685 4.13785 0.0205714 0.00178247 42578.3 7; : 1014 | 3.38367 4.59532 0.0203076 0.00178189 43183.2 8; : 1015 Minimum Test error found - save the configuration ; : 1015 | 3.15343 3.81668 0.0204522 0.00185272 43011.9 0; : 1016 | 2.99441 4.01707 0.0202697 0.00183758 43402.5 1; : 1017 | 3.3956 4.54944 0.0201133 0.00176644 43604.1 2; : 1018 | 3.2792 3.85661 0.0202747 0.00181943 43348.2 3; : 1019 | 3.37748 4.22044 0.0208054 0.00183497 42170.8 4; : 1020 | 3.48034 4.07947 0.020447 0.00177824 42852.4 5; : 1021 | 3.50059 4.11275 0.020219 0.00176964 43361.9 6; : 1022 | 3.15174 3.86168 0.0203283 0.00176093 43086.3 7; : 1023 | 3.4694 4.52782 0.0204007 0.00179059 42987.4 8; : 1024 Minimum Test error found - save the configuration ; : 1024 | 3.57333 3.68346 0.0207199 0.00186469 42428.5 0; : 1025 | 3.1448 3.86932 0.020257 0.0018083 43363.6 1; : 1026 | 3.14966 3.71614 0.0204412 0.00177219 42851.8 2; : 1027 Minimum Test error found - save the configuration ; : 1027 | 3.06278 3.47888 0.0204485 0.00186251 43043.1 0; : 1028 | 3.22518 4.06346 0.0201016 0.00179042 43689.3 1; : 1029 | 3.47015 5.10048 0.0212551 0.0017691 41055.1 2; : 1030 | 3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:114166,error,error,114166,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Minimum Test error found - save the configuration ; : 791 | 11.5078 15.2368 0.0201178 0.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test error found - save the configuration ; : 800 | 10.3317 14.1583 0.0201165 0.00182126 43727.2 0; : 801 | 10.3503 14.2866 0.0200523 0.00175781 43729 1; : 802 | 10.3453 15.2815 0,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:97564,error,error,97564,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"1; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::Newvoid * New(ENewType defConstructor=kClassNew, Bool_t quiet=kFALSE) constReturn a pointer to a newly allocated object of this class.Definition TClass.cxx:5045; TClass::LoadClassstatic TClass * LoadClass(const char *requestedname, Bool_t silent)Helper function used by TClass::GetClass().Definition TClass.cxx:5816; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFastCgiTHttpEngine implementation, based on fastcgi package.Definition TFastCgi.h:20; THttpCallArgContains arguments for single HTTP call.Definition THttpCallArg.h:27; THttpCallArg::Set404void Set404()mark reply as 404 error - page/request not exists or refusedDefinition THttpCallArg.h:163; THttpCallArg::kZipAlways@ kZipAlwaysDefinition THttpCallArg.h:38; THttpEngineAbstract class for implementing http protocol for THttpServer.Definition THttpEngine.h:19; THttpEngine::SetServervoid SetServer(THttpServer *serv)Definition THttpEngine.h:27; THttpEngine::Createvirtual Bool_t Create(const char *)Method to create all components of engine.Definition THttpEngine.h:37; THttpLongPollEngineEmulation of websocket with long poll requests.Definition THttpLongPollEngine.h:23; THttpServerOnline http server for arbitrary ROOT application.Definition THttpServer.h:31; THttpServer::IsReadOnlyBool_t IsReadOnly() constreturns read-only modeDefinition THttpServer.cxx:285; THttpServer::RegisterCommandBool_t RegisterCommand(const char *cmdname, const char *method, const char *icon=nullptr)Register command which can be executed from web interface.Definition THttpServer.cxx:1428; THttpServer::fJSROOTTString fJSROOT! location of ext",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THttpServer_8cxx_source.html:56211,error,error,56211,doc/master/THttpServer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THttpServer_8cxx_source.html,1,['error'],['error']
Availability,"1; j<= ymax; j++){; 4375 for(Int_t k=1; k<= zmax; k++){; 4376 Int_t bin = GetBin(i, j, k);; 4377 // here some bin contents are written into variables to make the error; 4378 // calculation a little more legible:; 4379 Double_t a = h1->RetrieveBinContent(bin);; 4380 Double_t b = h2->RetrieveBinContent(bin);; 4381 Double_t bot = bottom->RetrieveBinContent(bin);; 4382 ; 4383 // make sure there are some events, if not, then the errors are set = 0; 4384 // automatically.; 4385 //if(bot < 1){} was changed to the next line from recommendation of Jason Seely (28 Nov 2005); 4386 if(bot < 1e-6){}; 4387 else{; 4388 // computation of errors by Christos Leonidopoulos; 4389 Double_t dasq = h1->GetBinErrorSqUnchecked(bin);; 4390 Double_t dbsq = h2->GetBinErrorSqUnchecked(bin);; 4391 Double_t error = 2*TMath::Sqrt(a*a*c2*c2*dbsq + c2*c2*b*b*dasq+a*a*b*b*dc2*dc2)/(bot*bot);; 4392 asym->SetBinError(i,j,k,error);; 4393 }; 4394 }; 4395 }; 4396 }; 4397 delete top;; 4398 delete bottom;; 4399 ; 4400 return asym;; 4401}; 4402 ; 4403////////////////////////////////////////////////////////////////////////////////; 4404/// Static function; 4405/// return the default buffer size for automatic histograms; 4406/// the parameter fgBufferSize may be changed via SetDefaultBufferSize; 4407 ; 4408Int_t TH1::GetDefaultBufferSize(); 4409{; 4410 return fgBufferSize;; 4411}; 4412 ; 4413////////////////////////////////////////////////////////////////////////////////; 4414/// Return kTRUE if TH1::Sumw2 must be called when creating new histograms.; 4415/// see TH1::SetDefaultSumw2.; 4416 ; 4417Bool_t TH1::GetDefaultSumw2(); 4418{; 4419 return fgDefaultSumw2;; 4420}; 4421 ; 4422////////////////////////////////////////////////////////////////////////////////; 4423/// Return the current number of entries.; 4424 ; 4425Double_t TH1::GetEntries() const; 4426{; 4427 if (fBuffer) {; 4428 Int_t nentries = (Int_t) fBuffer[0];; 4429 if (nentries > 0) return nentries;; 4430 }; 4431 ; 4432 return fEntries;; 4433}; 4434 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:181420,error,errors,181420,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,3,['error'],"['error', 'errors']"
Availability,1=1 p_ph_sig2_gamma_bin_22=7.28945 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=7.28945 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=7.28945 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:29874,error,error,29874,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"1D histogram.Definition TH1.cxx:9152; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetSumw2virtual TArrayD * GetSumw2()Definition TH1.h:313; TH1::GetBinWidthvirtual Double_t GetBinWidth(Int_t bin) constReturn bin width for 1D histogram.Definition TH1.cxx:9163; TH1::GetSumOfWeightsvirtual Double_t GetSumOfWeights() constReturn the sum of weights excluding under/overflows.Definition TH1.cxx:7917; TIterDefinition TCollection.h:235; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TNamed::GetTitleconst char * GetTitle() const overrideReturns title of object.Definition TNamed.h:48; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::MakeZombievoid MakeZombie()Definition TObject.h:53; TObject::Infovirtual void Info(const char *method, const char *msgfmt,...) constIssue info message.Definition TObject.cxx:967; TStringBasic string class.Definition TString.h:139; TString::LengthSsiz_t Length() constDefinition TString.h:417; TString::ToLowervoid ToLower()Change string to lower-case.Definition TString.cxx:1182; TString::AtoiInt_t Atoi() constReturn integer value of string.Definition TString.cxx:1988; TString::AtofDouble_t Atof() constReturn floating-point value contained in string.Definition TString.cxx:2054; TString::IsFloatBool_t IsFloat() constReturns kTRUE if string contains a floating point or integer number.Definition TString.cxx:1858; TString::Dataconst char * Data() constDefinition TString.h:376; TString::IsDigitBool_t IsDigit() constReturns true if all characters in string are digits (0-9) or white spaces, i.e.Definition TString.cxx:1830; TString::ReplaceAllTStr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:70157,error,error,70157,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['error']
Availability,"1NDC(newx1); //new x start position; Root > st->SetX2NDC(newx2); //new x end position. To change the type of information for an histogram with an existing; TPaveStats one should do:. st->SetOptStat(mode);. Where ""mode"" has the same meaning than when calling; gStyle->SetOptStat(mode) (see above).; One can delete the statistics box for a histogram TH1* h with:. h->SetStats(0). and activate it again with:. h->SetStats(1). Labels used in the statistics box (""Mean"", ""Std Dev"", ...) can be changed from; $ROOTSYS/etc/system.rootrc or; .rootrc; (look for the string ""Hist.Stats.""). Fit Statistics; The type of information about fit parameters printed in the histogram statistics; box can be selected via the parameter mode. The parameter mode can be; = pcev (default = 0111). p = 1; print Probability; c = 1; print Chisquare/Number of degrees of freedom; e = 1; print errors (if e=1, v must be 1); v = 1; print name/values of parameters. Example:. gStyle->SetOptFit(1011);. print fit probability, parameter names/values and errors. When ""v"" = 1 is specified, only the non-fixed parameters are; shown.; When ""v"" = 2 all parameters are shown. Note: gStyle->SetOptFit(1) means ""default value"", so it is equivalent; to gStyle->SetOptFit(111); The error bars options. ""E""; Default. Shows only the error bars, not a marker. ""E1""; Small lines are drawn at the end of the error bars. ""E2""; Error rectangles are drawn. ""E3""; A filled area is drawn through the end points of the vertical error bars. ""E4""; A smoothed filled area is drawn through the end points of the vertical error; bars. ""E0""; Draw also bins with null contents. Picture; Source. {; TCanvas *c1 = new TCanvas(""c1"",""c1"",600,400);; TH1F *he = new TH1F(""he"",""Distribution drawn with error bars (option E1) "",100,-3,3);; Int_t i;; for (i=0;i<10000;i++) he->Fill(gRandom->Gaus(0,1));; gStyle->SetEndErrorSize(3);; gStyle->SetErrorX(1.);; he->SetMarkerStyle(20);; he->Draw(""E1"");; return c1;; }; The options ""E3"" and ""E4"" draw an error band through t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THistPainter.html:19755,error,errors,19755,root/html604/THistPainter.html,https://root.cern,https://root.cern/root/html604/THistPainter.html,2,['error'],['errors']
Availability,"1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TSpectrumFit (Int_t numberPeaks);  numberPeaks: number of fitted peaks (must be greater than zero) ;  ;  TSpectrumFit (void);  Default constructor. ;  ;  ~TSpectrumFit () override;  Destructor. ;  ; void FitAwmi (Double_t *source);  This function fits the source spectrum. ;  ; void FitStiefel (Double_t *source);  This function fits the source spectrum. ;  ; Double_t * GetAmplitudes () const;  ; Double_t * GetAmplitudesErrors () const;  ; Double_t * GetAreas () const;  ; Double_t * GetAreasErrors () const;  ; void GetBackgroundParameters (Double_t &a0, Double_t &a0Err, Double_t &a1, Double_t &a1Err, Double_t &a2, Double_t &a2Err);  This function gets the background parameters and their errors. ;  ; Double_t GetChi () const;  ; Double_t * GetPositions () const;  ; Double_t * GetPositionsErrors () const;  ; void GetSigma (Double_t &sigma, Double_t &sigmaErr);  This function gets the sigma parameter and its error. ;  ; void GetTailParameters (Double_t &t, Double_t &tErr, Double_t &b, Double_t &bErr, Double_t &s, Double_t &sErr);  This function gets the tail parameters and their errors. ;  ; TClass * IsA () const override;  ; void SetBackgroundParameters (Double_t a0Init, Bool_t fixA0, Double_t a1Init, Bool_t fixA1, Double_t a2Init, Bool_t fixA2);  This function sets the following fitting parameters of background: ;  ; void SetFitParameters (Int_t xmin, Int_t xmax, Int_t numberIterations, Double_t alpha, Int_t statisticType, Int_t alphaOptim, Int_t power, Int_t fitTaylor);  This function sets the following fitting parameters: ;  ; void SetPeakParameters (Double_t sigma, Bool_t fixSigma, const Double_t *positionInit, const Bool_t *fixPosition, const Double_t *ampInit, const Bool_t *fixAmp);  This function sets the following fitting parameters of peaks: ;  ; void SetTailParameters (Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTSpectrumFit.html:3574,error,error,3574,doc/master/classTSpectrumFit.html,https://root.cern,https://root.cern/doc/master/classTSpectrumFit.html,1,['error'],['error']
Availability,"1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReadBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:28382,error,error,28382,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,4,['error'],['error']
Availability,"1[,server2:port2,...]/pathfile?checkenv""; c. set the cache size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?cachesz=20000000""; d. set the read-ahead size (in bytes); ""root://server1:port1[,server2:port2,...]/pathfile?readaheadsz=100000""; e. set the cache remove policy; ""root://server1:port1[,server2:port2,...]/pathfile?rmpolicy=1""; f. set the max number of redirections; ""root://server1:port1[,server2:port2,...]/pathfile?mxredir=2""; (multiple options can be set concurrently). ~TXNetFile(); Destructor. void FormUrl(TUrl uut, TString& uu); Form url for rootd socket. Int_t ParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); Parse input options for cache parameters. void CreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); The real creation work is done here. Int_t GetRootdProtocol(TSocket* s); Find out the remote rootd protocol version.; Returns -1 in case of error. Bool_t Open(Option_t* option, Bool_t parallelopen); The real creation work is done here. Bool_t ReadBuffer(char* buf, Int_t len); Override TNetFile::ReadBuffer to deal with the xrootd server.; Returns kTRUE in case of errors. Bool_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Pass through to TNetFile implementation which will call back eventually; to our ReadBuffer with 2 arguments to deal with xrootd errors. Bool_t ReadBufferAsync(Long64_t offs, Int_t len); Implementation dealing with the xrootd server.; Returns kTRUE in case of errors.; This is the same as TXNetFile::ReadBuffer but using the async; call from xrootd. Bool_t ReadBuffers(char* buf, Long64_t* pos, Int_t* len, Int_t nbuf); Read the nbuf blocks described in arrays pos and len,; where pos[i] is the seek position of block i of length len[i].; Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer; This function is overloaded by TNetFile, TWebFile, etc.; Returns kTRUE in case of failure.; Note:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:26370,error,error,26370,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,6,['error'],['error']
Availability,"1] ; for (i=0;i<11;i++) buf[i]=0;; 2348 Bool_t opFound ;; 2349 Int_t opFrac = 0;; 2350 Int_t length = text.Length() ;; 2351 ; 2352 Int_t nOfCurlyBracket, nOfKW1, nOfKW2, nOfKW3, nOfSquareCurly, nOfCurlyCurly ;; 2353 Int_t nOfSquareBracket = 0 ;; 2354 Int_t error = 0 ;; 2355 Bool_t quote1 = kFALSE , quote2 = kFALSE;; 2356 ; 2357 // first find and replace all occurrences of ""kLeft1"" keyword by ""kLeft2"" keyword,; 2358 // and all occurrences of ""kRight"" keyword by ""}"".; 2359 i = 0 ;; 2360 while (i < length) {; 2361 // The string in 'buf' does not need to be null terminated,; 2362 // we will only check with strncmp.; 2363 strncpy(buf,&text[i],TMath::Min(7,length-i));; 2364 opFound = kFALSE ;; 2365 for (k = 0 ; k < nLeft1 ; k++) {; 2366 if (strncmp(buf,kLeft1[k],lLeft1)==0) {; 2367 nOfLeft++ ;; 2368 i+=lLeft1 ;; 2369 opFound = kTRUE ;; 2370 break ;; 2371 }; 2372 }; 2373 if (opFound) continue ;; 2374 ; 2375 for(k=0;k<nRight;k++) {; 2376 if (strncmp(buf,kRight[k],lRight)==0) {; 2377 nOfRight++ ;; 2378 i+=lRight ;; 2379 opFound = kTRUE ;; 2380 break ;; 2381 }; 2382 }; 2383 if (!opFound) i++ ;; 2384 }; 2385 if (nOfLeft != nOfRight) {; 2386 printf("" nOfLeft = %d, nOfRight = %d\n"",nOfLeft,nOfRight) ;; 2387 error = 1 ;; 2388 fError = ""Operators \""#left\"" and \""#right\"" don't match !"" ;; 2389 goto ERROR_END ;; 2390 }; 2391 ; 2392 for (k = 0 ; k < nLeft1 ; k++) {; 2393 text.ReplaceAll(kLeft1[k],lLeft1,kLeft2[k],lLeft2) ;; 2394 }; 2395 for (k = 0 ; k < nRight ; k++) {; 2396 text.ReplaceAll(kRight[k],lRight,""}"",1) ;; 2397 }; 2398 length = text.Length() ;; 2399 ; 2400 i = nOfCurlyBracket = nOfKW1 = nOfKW2 = nOfKW3 = nOfSquareCurly = nOfCurlyCurly =0 ;; 2401 while (i< length){; 2402 switch (text[i]) {; 2403 case '""' : quote1 = !quote1 ; break ;; 2404 case '\'': quote2 = !quote2 ; break ;; 2405 }; 2406 // The string in 'buf' does not need to be null terminated,; 2407 // we will only check with strncmp; 2408 strncpy(buf,&text[i],TMath::Min(11,length-i));; 2409 opFound = kFALSE ;; 2410 ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:86387,error,error,86387,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['error'],['error']
Availability,"1}; b#define b(i)Definition RSha256.hxx:100; g#define g(i)Definition RSha256.hxx:105; Version_tshort Version_tDefinition RtypesCore.h:65; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; TGraph2DErrors.h; TH2.h; THLimitsFinder.h; TVirtualFitter.h; TVirtualPad.h; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TGraph2DErrorsGraph 2D class with errors.Definition TGraph2DErrors.h:26; TGraph2DErrors::Streamervoid Streamer(TBuffer &) overrideStream an object of class TGraph2DErrors.Definition TGraph2DErrors.cxx:462; TGraph2DErrors::GetErrorZDouble_t GetErrorZ(Int_t bin) const overrideThis function is called by Graph2DFitChisquare.Definition TGraph2DErrors.cxx:230; TGraph2DErrors::~TGraph2DErrors~TGraph2DErrors() overrideTGraph2DErrors destructor.Definition TGraph2DErrors.cxx:137; TGraph2DErrors::GetYminEDouble_t GetYminE() const overrideReturns the Y minimum with errors.Definition TGraph2DErrors.cxx:274; TGraph2DErrors::GetXminEDouble_t GetXminE() const overrideReturns the X minimum with errors.Definition TGraph2DErrors.cxx:252; TGraph2DErrors::GetEZDouble_t * GetEZ() const overrideDefinition TGraph2DErrors.h:47; TGraph2DErrors::fEYDouble_t * fEY[fNpoints] array of Y errorsDefinition TGraph2DErrors.h:30; TGraph2DErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraph2DErrors.h:46; TGraph2DErrors::SetPointvoid SetPoint(Int_t i, Double_t x, Double_t y, Double_t z) overrideSet x, y and z values for point number i.Definition TGraph2DErrors.cxx:404; TGraph2DErrors::Scalevoid Scale(Double_t c1=1., Option_t *option=""z"") overrideMultiply the values and errors of a TGraph2DErrors by a constant c1.Definition TGraph2DErrors.cxx:322; TGraph2DErrors::fEZDouble_t * fEZ[fNpoints] array of Z errorsDefinition TGraph2DErrors.h:31; TGraph2DErrors::GetEXDouble_t * GetEX() const overrideDefinition TGraph2DErrors.h:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:14953,error,errors,14953,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,"1 . ). Display the current content starting from line 'from' to line 'to' inclusive. ; A negative value for 'from' indicates lines counted from the end (tail action); 'to' is ignored in such a case. TProofLog::Prt is called to display: the location (screen, file, box) is defined there. Return 0 on success, -1 in case of any error. ; Definition at line 467 of file TProofLog.cxx. ◆ GetMacro(). TMacro * TProofLogElem::GetMacro ; (; ); const. inline . Definition at line 100 of file TProofLog.h. ◆ GetMaxTransferSize(). Long64_t TProofLogElem::GetMaxTransferSize ; (; ). static . Get max transfer size. ; Definition at line 351 of file TProofLog.cxx. ◆ GetRole(). const char * TProofLogElem::GetRole ; (; ). inline . Definition at line 101 of file TProofLog.h. ◆ Grep(). Int_t TProofLogElem::Grep ; (; const char * ; txt, . TString & ; res, . Int_t ; from = 0 . ). Search lines containing 'txt', starting from line 'from'. ; Return their blanck-separated list into 'res'. Return the number of lines found, or -1 in case of error. ; Definition at line 559 of file TProofLog.cxx. ◆ IsA(). TClass * TProofLogElem::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 114 of file TProofLog.h. ◆ IsMaster(). Bool_t TProofLogElem::IsMaster ; (; ); const. inline . Definition at line 103 of file TProofLog.h. ◆ IsSubMaster(). Bool_t TProofLogElem::IsSubMaster ; (; ); const. inline . Definition at line 104 of file TProofLog.h. ◆ IsWorker(). Bool_t TProofLogElem::IsWorker ; (; ); const. inline . Definition at line 105 of file TProofLog.h. ◆ Print(). void TProofLogElem::Print ; (; Option_t * ; opt = 0); const. overridevirtual . Print a line with the relevant info. ; Reimplemented from TNamed.; Definition at line 536 of file TProofLog.cxx. ◆ Prt(). void TProofLogElem::Prt ; (; const char * ; what). Special printing procedure. ; Definition at line 548 of file TProofLog.cxx. ◆ Retrieve(). Int_t TProofLogElem::Retrieve ; (;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLogElem.html:14244,error,error,14244,doc/master/classTProofLogElem.html,https://root.cern,https://root.cern/doc/master/classTProofLogElem.html,1,['error'],['error']
Availability,"1 ;  . ). ◆ VOID_METHOD_ARG7(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG7 ; (; VirtualX ; , . DrawCellArray ; , . Int_t ; , . x1 ; , . Int_t ; , . y1 ; , . Int_t ; , . x2 ; , . Int_t ; , . y2 ; , . Int_t ; , . nx ; , . Int_t ; , . ny ; , . Int_t * ; , . ic ; , . 1 ;  . ). ◆ VOID_METHOD_ARG8(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t VOID_METHOD_ARG8 ; (; VirtualX ; , . QueryPointer ; , . Window_t ; , . id ; , . Window_t & ; , . rootw ; , . Window_t & ; , . childw ; , . Int_t & ; , . root_x ; , . Int_t & ; , . root_y ; , . Int_t & ; , . win_x ; , . Int_t & ; , . win_y ; , . UInt_t & ; , . mask ; , . 1 ;  . ). ◆ VOID_METHOD_ARG9(). Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t VOID_METHOD_ARG9 ; (; VirtualX ; , . PutImage ; , . Drawable_t ; , . id ; , . GContext_t ; , . gc ; , . Drawable_t ; , . img ; , . Int_t ; , . dx ; , . Int_t ; , . dy ; , . Int_t ; , . x ; , . Int_t ; , . y ; , . UInt_t ; , . w ; , . UInt_t ; , . h ; , . 1 ;  . ). Variable Documentation. ◆ act_format. Option_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html:145711,mask,mask,145711,doc/master/TGWin32VirtualXProxy_8cxx.html,https://root.cern,https://root.cern/doc/master/TGWin32VirtualXProxy_8cxx.html,2,['mask'],['mask']
Availability,"2 * Rsq_ij ] ]; r5 = sum_i [ M1_mi * H_ni ]; r6 = sum_i [ M1_ni * H_mi ]. calculate contributions containing matrices F and G; r0,r1,r2. void SetTauError(Double_t delta_tau); set uncertainty on tau. void GetDeltaSysSource(TH1* hist_delta, const char* source, const Int_t* binMap = 0); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(). void GetDeltaSysBackgroundScale(TH1* delta, const char* source, const Int_t* binMap = 0); get correlated shift induced by a background source; delta: output shift vector histogram; source: name of background source; binMap: see method GetEmatrix(); see PrepareSysError(). void GetDeltaSysTau(TH1* delta, const Int_t* binMap = 0); calculate systematic shift from tau variation; ematrix: output; binMap: see method GetEmatrix(). void GetEmatrixSysSource(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given source; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysBackgroundScale(TH2* ematrix, const char* source, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate systematic shift from a given background scale error; ematrix: output; source: name of the error source; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixSysTau(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in regularisation parameter; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the histogram prior to adding the errors. void GetEmatrixInput(TH2* ematrix, const Int_t* binMap = 0, Bool_t clearEmat = kTRUE); calculate error matrix from error in input vector alone; ematrix: output; binMap: see method GetEmatrix(); clearEmat: set kTRUE to clear the h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TUnfoldSys.html:25208,error,error,25208,root/html528/TUnfoldSys.html,https://root.cern,https://root.cern/root/html528/TUnfoldSys.html,8,['error'],"['error', 'errors']"
Availability,"2 // On the link line, we must list the most dependent .o file; 983 // and end with the least dependent (LLVM libraries), unfortunately,; 984 // Fedora Core 17+ or Ubuntu 12 will also execute the initialization; 985 // in the same order (hence doing libCore's before LLVM's and; 986 // vice et versa for both the destructor. We worked around the; 987 // initialization order by delay the TROOT creation until first use.; 988 // We can not do the same for destruction as we have no way of knowing; 989 // the last access ...; 990 // So for now, let's avoid delete TCling except in the special build; 991 // checking the completeness of the termination deletion.; 992 ; 993 // TODO: Should we do more cleanup here than just call delete?; 994 // Segfaults rootcling in some cases, debug and uncomment:; 995 //; 996 // delete fInterpreter;; 997 ; 998 // We cannot delete fCleanups because of the logic in atexit which needs it.; 999 SafeDelete(fCleanups);; 1000#endif; 1001 ; 1002#ifdef _MSC_VER; 1003 // usedToIdentifyRootClingByDlSym is available when TROOT is part of rootcling.; 1004 if (dlsym(RTLD_DEFAULT, ""usedToIdentifyRootClingByDlSym"")) {; 1005 // deleting the interpreter makes things crash at exit in some cases; 1006 delete fInterpreter;; 1007 }; 1008#else; 1009 // deleting the interpreter makes things crash at exit in some cases; 1010 delete fInterpreter;; 1011#endif; 1012 ; 1013 // Prints memory stats; 1014 TStorage::PrintStatistics();; 1015 ; 1016 gROOTLocal = nullptr;; 1017 fgRootInit = kFALSE;; 1018 }; 1019}; 1020 ; 1021////////////////////////////////////////////////////////////////////////////////; 1022/// Add a class to the list and map of classes.; 1023/// This routine is deprecated, use TClass::AddClass directly.; 1024 ; 1025void TROOT::AddClass(TClass *cl); 1026{; 1027 TClass::AddClass(cl);; 1028}; 1029 ; 1030////////////////////////////////////////////////////////////////////////////////; 1031/// Add a class generator. This generator will be called by TClass::GetCl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:39813,avail,available,39813,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,2,['avail'],['available']
Availability,"2 // Set entry offset in buffer and read data from all leaves.; 1803 if (!TestBit(kDoNotUseBufferMap)) {; 1804 buf->ResetMap();; 1805 }; 1806 if (R__unlikely(!buf->IsReading())) {; 1807 basket->SetReadMode();; 1808 }; 1809 Int_t* entryOffset = basket->GetEntryOffset();; 1810 Int_t bufbegin = 0;; 1811 if (entryOffset) {; 1812 bufbegin = entryOffset[entry-first];; 1813 buf->SetBufferOffset(bufbegin);; 1814 Int_t* displacement = basket->GetDisplacement();; 1815 if (R__unlikely(displacement)) {; 1816 buf->SetBufferDisplacement(displacement[entry-first]);; 1817 }; 1818 } else {; 1819 bufbegin = basket->GetKeylen() + ((entry-first) * basket->GetNevBufSize());; 1820 buf->SetBufferOffset(bufbegin);; 1821 }; 1822 TLeaf* leaf = (TLeaf*) fLeaves.UncheckedAt(0);; 1823 leaf->ReadBasketExport(*buf, li, nentries);; 1824 nbytes = buf->Length() - bufbegin;; 1825 return nbytes;; 1826}; 1827 ; 1828////////////////////////////////////////////////////////////////////////////////; 1829/// Fill expectedClass and expectedType with information on the data type of the; 1830/// object/values contained in this branch (and thus the type of pointers; 1831/// expected to be passed to Set[Branch]Address; 1832/// return 0 in case of success and > 0 in case of failure.; 1833 ; 1834Int_t TBranch::GetExpectedType(TClass *&expectedClass,EDataType &expectedType); 1835{; 1836 expectedClass = nullptr;; 1837 expectedType = kOther_t;; 1838 TLeaf* l = (TLeaf*) GetListOfLeaves()->At(0);; 1839 if (l) {; 1840 expectedType = (EDataType) gROOT->GetType(l->GetTypeName())->GetType();; 1841 return 0;; 1842 } else {; 1843 Error(""GetExpectedType"", ""Did not find any leaves in %s"",GetName());; 1844 return 1;; 1845 }; 1846}; 1847 ; 1848////////////////////////////////////////////////////////////////////////////////; 1849/// Return pointer to the file where branch buffers reside, returns 0; 1850/// in case branch buffers reside in the same file as tree header.; 1851/// If mode is 1 the branch buffer file is recreated.; 18",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranch_8cxx_source.html:66820,failure,failure,66820,doc/master/TBranch_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranch_8cxx_source.html,1,['failure'],['failure']
Availability,"2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 348 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 987 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 359 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTObject.html:33334,error,error,33334,doc/v632/classTObject.html,https://root.cern,https://root.cern/doc/v632/classTObject.html,1,['error'],['error']
Availability,"2 0.67 X of 2nd point; fY2 0.83 Y of 2nd point; fUniqueID 0 object unique identifier; fBits 50331648 bit field status word; fLineColor 1 line color; fLineStyle 1 line style; fLineWidth 1 line width; fFillColor 19 fill area color; fFillStyle 1001 fill area style; X#define X(type, name); angleOption_t Option_t TPoint TPoint angleDefinition TGWin32VirtualXProxy.cxx:68; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; styleOption_t Option_t styleDefinition TGWin32VirtualXProxy.cxx:46; TObject::fUniqueIDUInt_t fUniqueIDobject unique identifierDefinition TObject.h:44; TObject::fBitsUInt_t fBitsbit field status wordDefinition TObject.h:45; lineTLine * lineDefinition entrylistblock_figure1.C:235. Reimplemented in TSystemFile, TCollection, TClass, TGFrame, and TGPack.; Definition at line 353 of file TObject.cxx. ◆ Error(). void TObject::Error ; (; const char * ; location, . const char * ; fmt, .  ; ... . ); const. virtual . Issue error message. ; Use ""location"" to specify the method where the error occurred. Accepts standard printf formatting arguments. ; Reimplemented in TFitResult.; Definition at line 993 of file TObject.cxx. ◆ Execute() [1/2]. void TObject::Execute ; (; const char * ; method, . const char * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with the given parameter string, e.g. ; ""3.14,1,\""text\"""". ; Reimplemented in TMethodCall, TCling, TInterpreter, ROOT::R::TRInterface, and TContextMenu.; Definition at line 364 of file TObject.cxx. ◆ Execute() [2/2]. void TObject::Execute ; (; TMethod * ; method, . TObjArray * ; params, . Int_t * ; error = nullptr . ). virtual . Execute method on this object with parameters stored in the TObjArray. ; The TObjArray should contain an argv vector like: argv[0] ... argv[n] = the list of TObjString parameters; TObjStringCollectable string class.Definition TObjString.h:28; nconst Int_t nDefinition legend1.C:16. Reimplemented in TCling, TMethodCall, TInterpreter, ROOT::R::TRIn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTObject.html:33047,error,error,33047,doc/master/classTObject.html,https://root.cern,https://root.cern/doc/master/classTObject.html,1,['error'],['error']
Availability,2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimum Test error found - save the configuration ; : 698 | 33.7716 30.3897 0.0201321 0.00181458 43673.9 0; : 699 | 33.1269 30.7769 0.0201928 0.00175872 43397.8 1; : 700 Minimum Test error found - save the configuration ; : 700 | 32.8076 30.1388 0.0201025 0.00181993 43757.5 0; : 701 | 32.6014 30.2991 0.0200398 0.0017563 43755.4 1; : 702 | 32.0925 30.8793 0.0200419 0.00175584 43749.1 2; : 703 Minimum Test error found - save the configuration ; : 703 | 31.9128 29.3224 0.0202722 0.00182152 43358.7 0; : 704 Minimum Test error found - save the configuration ; : 704 | 31.2876 29.167 0.0201013 0.00181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:89839,error,error,89839,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:; [1] M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-; 132. [2] M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408. [3] M. Morhac et al.: Efficient algorithm of multidimensional; deconvolution and its application to nuclear data processing. Digital; Signal Processing, Vol. 13, No. 1, (2003), 144-171. [4] M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as Postscript files from:. ftp://root.cern.ch/root/SpectrumDec.ps.gz; ftp://root.cern.ch/root/SpectrumSrc.ps.gz; ftp://root.cern.ch/root/SpectrumBck.ps.gz. Function Members (Methods); public:. TSpectrum3(); TSpectrum3(const TSpectrum3&); TSpectrum3(Int_t maxpositions, Float_t resolution = 1); virtual~TSpectrum3(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*Background(const TH1* hist, int niter, Option_t* option = ""goff""); const char*Background(float*** spectrum, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t numberIterationsX, Int_t numberIterationsY, Int_t numberIterationsZ, Int_t direction, Int_t filterType); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSpectrum3.html:1645,avail,available,1645,root/html528/TSpectrum3.html,https://root.cern,https://root.cern/root/html528/TSpectrum3.html,6,['avail'],['available']
Availability,"2 28 BRATISLAVA; SLOVAKIA. email:fyzimiro@savba.sk, fax:+421 7 54772479. The original code in C has been repackaged as a C++ class by R.Brun. The algorithms in this class have been published in the following; references:; [1] M.Morhac et al.: Background elimination methods for; multidimensional coincidence gamma-ray spectra. Nuclear; Instruments and Methods in Physics Research A 401 (1997) 113-; 132. [2] M.Morhac et al.: Efficient one- and two-dimensional Gold; deconvolution and its application to gamma-ray spectra; decomposition. Nuclear Instruments and Methods in Physics; Research A 401 (1997) 385-408. [3] M. Morhac et al.: Efficient algorithm of multidimensional; deconvolution and its application to nuclear data processing. Digital; Signal Processing, Vol. 13, No. 1, (2003), 144-171. [4] M.Morhac et al.: Identification of peaks in multidimensional; coincidence gamma-ray spectra. Nuclear Instruments and Methods in; Research Physics A 443(2000), 108-125. These NIM papers are also available as Postscript files from:. ftp://root.cern.ch/root/SpectrumDec.ps.gz; ftp://root.cern.ch/root/SpectrumSrc.ps.gz; ftp://root.cern.ch/root/SpectrumBck.ps.gz. Function Members (Methods); public:. virtual~TSpectrum3(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual const char*Background(const TH1* hist, Int_t niter, Option_t* option = ""goff""); const char*Background(Double_t*** spectrum, Int_t ssizex, Int_t ssizey, Int_t ssizez, Int_t numberIterationsX, Int_t numberIterationsY, Int_t numberIterationsZ, Int_t direction, Int_t filterType); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; const char*Deconvolution(Double_t*** source, const Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum3.html:1669,avail,available,1669,root/html602/TSpectrum3.html,https://root.cern,https://root.cern/root/html602/TSpectrum3.html,4,['avail'],['available']
Availability,2 43397.8 1; : 700 Minimum Test error found - save the configuration ; : 700 | 32.8076 30.1388 0.0201025 0.00181993 43757.5 0; : 701 | 32.6014 30.2991 0.0200398 0.0017563 43755.4 1; : 702 | 32.0925 30.8793 0.0200419 0.00175584 43749.1 2; : 703 Minimum Test error found - save the configuration ; : 703 | 31.9128 29.3224 0.0202722 0.00182152 43358.7 0; : 704 Minimum Test error found - save the configuration ; : 704 | 31.2876 29.167 0.0201013 0.00181585 43750.6 0; : 705 Minimum Test error found - save the configuration ; : 705 | 30.8198 28.9852 0.0201048 0.0018126 43734.4 0; : 706 Minimum Test error found - save the configuration ; : 706 | 30.3399 28.5636 0.0203047 0.00182247 43284.8 0; : 707 | 29.8899 28.5807 0.0200458 0.00176314 43757.3 1; : 708 | 29.6409 28.6883 0.0201432 0.0017637 43526.7 2; : 709 Minimum Test error found - save the configuration ; : 709 | 29.434 28.2 0.0201313 0.00182437 43699.3 0; : 710 | 28.7076 28.492 0.0200557 0.00176519 43738.5 1; : 711 Minimum Test error found - save the configuration ; : 711 | 28.4018 27.2754 0.0201013 0.00182194 43765.3 0; : 712 | 28.1436 28.1139 0.020041 0.00175734 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test err,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:90229,error,error,90229,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2 ; 763/* Power series for incomplete beta integral.; 764 Use when b*x is small and x not too close to 1. */; 765 ; 766double pseries( double a, double b, double x ); 767{; 768 double s, t, u, v, n, t1, z, ai;; 769 ; 770 ai = 1.0 / a;; 771 u = (1.0 - b) * x;; 772 v = u / (a + 1.0);; 773 t1 = v;; 774 t = u;; 775 n = 2.0;; 776 s = 0.0;; 777 z = kMACHEP * ai;; 778 while( std::abs(v) > z ); 779 {; 780 u = (n - b) * x / n;; 781 t *= u;; 782 v = t / (a + n);; 783 s += v;; 784 n += 1.0;; 785 }; 786 s += t1;; 787 s += ai;; 788 ; 789 u = a * log(x);; 790 if( (a+b) < kMAXSTIR && std::abs(u) < kMAXLOG ); 791 {; 792 t = gamma(a+b)/(gamma(a)*gamma(b));; 793 s = s * t * pow(x,a);; 794 }; 795 else; 796 {; 797 t = lgam(a+b) - lgam(a) - lgam(b) + u + std::log(s);; 798 if( t < kMINLOG ); 799 s = 0.0;; 800 else; 801 s = std::exp(t);; 802 }; 803 return(s);; 804}; 805 ; 806/*---------------------------------------------------------------------------*/; 807 ; 808 ; 809/*---------------------------------------------------------------------------*/; 810/* for evaluation of error function */; 811/*---------------------------------------------------------------------------*/; 812 ; 813static double erfP[] = {; 814 2.46196981473530512524E-10,; 815 5.64189564831068821977E-1,; 816 7.46321056442269912687E0,; 817 4.86371970985681366614E1,; 818 1.96520832956077098242E2,; 819 5.26445194995477358631E2,; 820 9.34528527171957607540E2,; 821 1.02755188689515710272E3,; 822 5.57535335369399327526E2; 823};; 824static double erfQ[] = {; 825/* 1.00000000000000000000E0,*/; 826 1.32281951154744992508E1,; 827 8.67072140885989742329E1,; 828 3.54937778887819891062E2,; 829 9.75708501743205489753E2,; 830 1.82390916687909736289E3,; 831 2.24633760818710981792E3,; 832 1.65666309194161350182E3,; 833 5.57535340817727675546E2; 834};; 835static double erfR[] = {; 836 5.64189583547755073984E-1,; 837 1.27536670759978104416E0,; 838 5.01905042251180477414E0,; 839 6.16021097993053585195E0,; 840 7.40974269950448939160E0,; 841 2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html:17616,error,error,17616,doc/master/SpecFuncCephes_8cxx_source.html,https://root.cern,https://root.cern/doc/master/SpecFuncCephes_8cxx_source.html,1,['error'],['error']
Availability,"2 = new TH2F(""h2"",""h2"",40,-3,3,40,-3,3);; auto h3 = new TH2F(""h3"",""h3"",40,-3,3,40,-3,3);; auto h4 = new TH2F(""h4"",""h4"",40,-3,3,40,-3,3);; h1->SetBit(TH1::kNoStats);; for (Int_t i=0;i<5000;i++) {; double x,y;; gRandom->Rannor(x,y);; if(x>0 && y>0) h1->Fill(x,y,4);; if(x<0 && y<0) h2->Fill(x,y,3);; if(x>0 && y<0) h3->Fill(x,y,2);; if(x<0 && y>0) h4->Fill(x,y,1);; }; h1->Draw(""colz"");; h2->Draw(""col same"");; h3->Draw(""col same"");; h4->Draw(""col same"");; }; c#define c(i)Definition RSha256.hxx:101; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786. The option COL can be combined with the option POL:; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hcol1 = new TH2F(""hcol1"",""Option COLor combined with POL"",40,-4,4,40,-4,4);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hcol1->Fill(px,py);; }; hcol1->Draw(""COLZPOL"");; }. SinceROOT version 6.07/03:; A second rendering technique is also available with the COL2 and COLZ2 options.; These options provide potential performance improvements compared to the standard COL option. The performance comparison of the COL2 to the COL option depends on the histogram and the size of the rendering region in the current pad. In general, a small (approx. less than 100 bins per axis), sparsely populated TH2 will render faster with the COL option.; However, for larger histograms (approx. more than 100 bins per axis) that are not sparse, the COL2 option will provide up to 20 times performance improvements. For example, a 1000x1000 bin TH2 that is not sparse will render an order of magnitude faster with the COL2 option.; The COL2 option will also scale its performance based on the size of the pixmap the histogram image is being rendered into. It also is much better optimized for sessions where the user is forwarding X11 windows through an ssh connection.; For the most part, the COL2 and COLZ2 options are a drop in replacement to the COL a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:47885,avail,available,47885,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['avail'],['available']
Availability,"2 are satisfied'. For unweighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 1 event'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied'. For weighted weighted comparison; igood=1'There is a bin in the 1st histogram with less then 10 effective number of events'; igood=2'There is a bin in the 2nd histogram with less then 10 effective number of events'; igood=3'when the conditions for igood=1 and igood=2 are satisfied' . [out]chi2chisquare of the test ; [out]ndfnumber of degrees of freedom (important, when both histograms have the same empty bins) ; [out]resnormalized residuals for further analysis . Definition at line 2067 of file TH1.cxx. ◆ Chisquare(). Double_t TH1::Chisquare ; (; TF1 * ; func, . Option_t * ; option = """" . ); const. virtual . Compute and return the chisquare of this histogram with respect to a function The chisquare is computed by weighting each histogram point by the bin error By default the full range of the histogram is used. ; Use option ""R"" for restricting the chisquare calculation to the given range of the function Use option ""L"" for using the chisquare based on the poisson likelihood (Baker-Cousins Chisquare) Use option ""P"" for using the Pearson chisquare based on the expected bin errors ; Definition at line 2496 of file TH1.cxx. ◆ Class(). static TClass * TH1::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TH1::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TH1::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 444 of file TH1.h. ◆ ClearUnderflowAndOverflow(). void TH1::ClearUnderflowAndOverflow ; (; ). virtual . Remove all the content from the underflow and overflow bins, without changing the number of entries After calling this method, every undeflow",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:101026,error,error,101026,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"2 fBytesRead -= extra;; 1873 fgBytesRead -= extra;; 1874 n = 0;; 1875 }; 1876 curbegin = i < nbuf ? pos[i] : 0;; 1877 }; 1878 }; 1879 if (buf2) delete [] buf2;; 1880 fCacheRead = old;; 1881 return result;; 1882}; 1883 ; 1884////////////////////////////////////////////////////////////////////////////////; 1885/// Read buffer via cache.; 1886///; 1887/// Returns 0 if the requested block is not in the cache, 1 in case read via; 1888/// cache was successful, 2 in case read via cache failed.; 1889 ; 1890Int_t TFile::ReadBufferViaCache(char *buf, Int_t len); 1891{; 1892 Long64_t off = GetRelOffset();; 1893 if (fCacheRead) {; 1894 Int_t st = fCacheRead->ReadBuffer(buf, off, len);; 1895 if (st < 0); 1896 return 2; // failure reading; 1897 else if (st == 1) {; 1898 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1899 SetOffset(off + len);; 1900 return 1;; 1901 }; 1902 // fOffset might have been changed via TFileCacheRead::ReadBuffer(), reset it; 1903 Seek(off);; 1904 } else {; 1905 // if write cache is active check if data still in write cache; 1906 if (fWritable && fCacheWrite) {; 1907 if (fCacheWrite->ReadBuffer(buf, off, len) == 0) {; 1908 SetOffset(off + len);; 1909 return 1;; 1910 }; 1911 // fOffset might have been changed via TFileCacheWrite::ReadBuffer(), reset it; 1912 SetOffset(off);; 1913 }; 1914 }; 1915 ; 1916 return 0;; 1917}; 1918 ; 1919////////////////////////////////////////////////////////////////////////////////; 1920/// Read the FREE linked list.; 1921///; 1922/// Every file has a linked list (fFree) of free segments.; 1923/// This linked list has been written on the file via WriteFree; 1924/// as a single data record.; 1925 ; 1926void TFile::ReadFree(); 1927{; 1928 // Avoid problem with file corruption.; 1929 if (fNbytesFree < 0 || fNbytesFree > fEND) {; 1930 fNbytesFree = 0;; 1931 return;; 1932 }; 1933 TKey *headerfree = new TKey(fSeekFree, fNbytesFree, this);; 1934 headerfree->ReadFile();; 1935 char *buffer = headerfree->Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:68142,failure,failure,68142,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['failure'],['failure']
Availability,"2 of file RuleFitAPI.h. ◆ VarImp(). void TMVA::RuleFitAPI::VarImp ; (; ). inline . Definition at line 221 of file RuleFitAPI.h. ◆ WelcomeMessage(). void TMVA::RuleFitAPI::WelcomeMessage ; (; ). welcome message ; Definition at line 76 of file RuleFitAPI.cxx. ◆ WriteAll(). Bool_t TMVA::RuleFitAPI::WriteAll ; (; ). protected . write all files read by rf_go.exe ; Definition at line 248 of file RuleFitAPI.cxx. ◆ WriteFloat(). Bool_t TMVA::RuleFitAPI::WriteFloat ; (; std::ofstream & ; f, . const Float_t * ; v, . Int_t ; n = 1 . ). inlineprotected . Definition at line 274 of file RuleFitAPI.h. ◆ WriteInt(). Bool_t TMVA::RuleFitAPI::WriteInt ; (; std::ofstream & ; f, . const Int_t * ; v, . Int_t ; n = 1 . ). inlineprotected . Definition at line 266 of file RuleFitAPI.h. ◆ WriteIntParms(). Bool_t TMVA::RuleFitAPI::WriteIntParms ; (; ). protected . write int params file ; Definition at line 264 of file RuleFitAPI.cxx. ◆ WriteLx(). Bool_t TMVA::RuleFitAPI::WriteLx ; (; ). protected . Save input variable mask. ; If the lx vector size is not the same as inputVars, resize it and fill it with 1 NOTE: Always set all to 1 if (fRFLx.size() != m_inputVars->size()) { ; Definition at line 291 of file RuleFitAPI.cxx. ◆ WriteProgram(). Bool_t TMVA::RuleFitAPI::WriteProgram ; (; ). protected . write command to rf_go.exe ; Definition at line 305 of file RuleFitAPI.cxx. ◆ WriteRealParms(). Bool_t TMVA::RuleFitAPI::WriteRealParms ; (; ). protected . write int params file ; Definition at line 275 of file RuleFitAPI.cxx. ◆ WriteRealVarImp(). Bool_t TMVA::RuleFitAPI::WriteRealVarImp ; (; ). protected . write the minimum importance to be considered ; Definition at line 333 of file RuleFitAPI.cxx. ◆ WriteRfOut(). Bool_t TMVA::RuleFitAPI::WriteRfOut ; (; ). protected . written by rf_go.exe; write rulefit output (rfout) ; Definition at line 347 of file RuleFitAPI.cxx. ◆ WriteRfStatus(). Bool_t TMVA::RuleFitAPI::WriteRfStatus ; (; ). protected . written by rf_go.exe; write rulefit status ; Definition",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html:12049,mask,mask,12049,doc/master/classTMVA_1_1RuleFitAPI.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitAPI.html,1,['mask'],['mask']
Availability,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 659 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 547 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:170858,error,error,170858,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,1,['error'],['error']
Availability,"2 of file TTree.cxx. ◆ IsA(). TClass * TTree::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Reimplemented in TTreeSQL.; Definition at line 705 of file TTree.h. ◆ IsFolder(). bool TTree::IsFolder ; (; ); const. inlineoverridevirtual . Returns kTRUE in case object contains browsable objects (like containers or lists of other objects). ; Reimplemented from TObject.; Definition at line 587 of file TTree.h. ◆ KeepCircular(). void TTree::KeepCircular ; (; ). protectedvirtual . Keep a maximum of fMaxEntries in memory. ; Definition at line 6415 of file TTree.cxx. ◆ LoadBaskets(). Int_t TTree::LoadBaskets ; (; Long64_t ; maxmemory = 2000000000). virtual . Read in memory all baskets from all branches up to the limit of maxmemory bytes. ; If maxmemory is non null and positive SetMaxVirtualSize is called with this value. Default for maxmemory is 2000000000 (2 Gigabytes). The function returns the total number of baskets read into memory if negative an error occurred while loading the branches. This method may be called to force branch baskets in memory when random access to branch entries is required. If random access to only a few branches is required, you should call directly TBranch::LoadBaskets. ; Reimplemented in TChain.; Definition at line 6451 of file TTree.cxx. ◆ LoadTree(). Long64_t TTree::LoadTree ; (; Long64_t ; entry). virtual . Set current entry. ; Returns -2 if entry does not exist (just as TChain::LoadTree()). Returns -6 if an error occurs in the notification callback (just as TChain::LoadTree()).; Calls fNotify->Notify() (if fNotify is not null) when starting the processing of a new tree.; NoteThis function is overloaded in TChain. ; Reimplemented in TChain, and TTreeSQL.; Definition at line 6473 of file TTree.cxx. ◆ LoadTreeFriend(). Long64_t TTree::LoadTreeFriend ; (; Long64_t ; entry, . TTree * ; masterTree . ). virtual . Load entry on behalf of our master tree, we may use an index. ; Called by",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:173046,error,error,173046,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,1,['error'],['error']
Availability,"2 void MasterToLocalVect(const Double_t *master, Double_t *local) const override; 433 {; 434 memcpy(local, master, 3 * sizeof(Double_t));; 435 }; 436 void MasterToLocalBomb(const Double_t *master, Double_t *local) const override; 437 {; 438 TGeoIdentity::MasterToLocal(master, local);; 439 }; 440 ; 441 const Double_t *GetTranslation() const override { return &kNullVector[0]; }; 442 const Double_t *GetRotationMatrix() const override { return &kIdentityMatrix[0]; }; 443 const Double_t *GetScale() const override { return &kUnitScale[0]; }; 444 void SavePrimitive(std::ostream &, Option_t * = """") override {}; 445 ; 446 ClassDefOverride(TGeoIdentity, 1) // identity transformation class; 447};; 448 ; 449////////////////////////////////////////////////////////////////////////////; 450// //; 451// TGeoHMatrix - Matrix class used for computing global transformations //; 452// Should NOT be used for node definition. An instance of this class //; 453// is generally used to pile-up local transformations starting from //; 454// the top level physical node, down to the current node. //; 455// //; 456////////////////////////////////////////////////////////////////////////////; 457 ; 458class TGeoHMatrix : public TGeoMatrix {; 459private:; 460 Double_t fTranslation[3]; // translation component; 461 Double_t fRotationMatrix[9]; // rotation matrix; 462 Double_t fScale[3]; // scale component; 463 ; 464public:; 465 TGeoHMatrix();; 466 TGeoHMatrix(const TGeoHMatrix &other) : TGeoHMatrix((TGeoMatrix &)other) {}; 467 TGeoHMatrix(const TGeoMatrix &matrix);; 468 TGeoHMatrix(const char *name);; 469 ~TGeoHMatrix() override;; 470 ; 471 TGeoHMatrix &operator=(const TGeoHMatrix &other) { return TGeoHMatrix::operator=((TGeoMatrix &)other); }; 472 TGeoHMatrix &operator=(const TGeoMatrix *other);; 473 TGeoHMatrix &operator=(const TGeoMatrix &other);; 474 TGeoHMatrix &operator*=(const TGeoMatrix &other);; 475 TGeoHMatrix operator*(const TGeoMatrix &other) const;; 476 Bool_t operator==(const TGeoMatrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoMatrix_8h_source.html:20610,down,down,20610,doc/master/TGeoMatrix_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoMatrix_8h_source.html,1,['down'],['down']
Availability,"2 }; 703#endif; 704 }; 705 }; 706#ifndef R__HAS_COCOA; 707 if (!gROOT->IsBatch() && !getenv(""DISPLAY"")) {; 708 Error(""SetDisplay"", ""Can't figure out DISPLAY, set it manually\n""; 709 ""In case you run a remote ssh session, restart your ssh session with:\n""; 710 ""=========> ssh -Y"");; 711 }; 712#endif; 713 }; 714}; 715 ; 716////////////////////////////////////////////////////////////////////////////////; 717/// Return system error string.; 718 ; 719const char *TUnixSystem::GetError(); 720{; 721 Int_t err = GetErrno();; 722 if (err == 0 && GetLastErrorString() != """"); 723 return GetLastErrorString();; 724 ; 725#if defined(R__SOLARIS) || defined (R__LINUX) || defined(R__AIX) || \; 726 defined(R__FBSD) || defined(R__OBSD) || defined(R__HURD); 727 return strerror(err);; 728#else; 729 if (err < 0 || err >= sys_nerr); 730 return Form(""errno out of range %d"", err);; 731 return sys_errlist[err];; 732#endif; 733}; 734 ; 735////////////////////////////////////////////////////////////////////////////////; 736/// Return cryptographic random number; 737/// Fill provided buffer with random values; 738/// Returns number of bytes written to buffer or -1 in case of error; 739 ; 740Int_t TUnixSystem::GetCryptoRandom(void *buf, Int_t len); 741{; 742#if defined(R__ARC4_STDLIB) || defined(R__ARC4_BSDLIB); 743 arc4random_buf(buf, len);; 744 return len;; 745#elif defined(R__GETRANDOM_CLIB); 746 return getrandom(buf, len, GRND_NONBLOCK);; 747#elif defined(R__USE_URANDOM); 748 std::ifstream urandom{""/dev/urandom""};; 749 if (!urandom); 750 return -1;; 751 urandom.read(reinterpret_cast<char *>(buf), len);; 752 return len;; 753#else; 754#error ""Reliable cryptographic random function not defined""; 755 return -1;; 756#endif; 757}; 758 ; 759////////////////////////////////////////////////////////////////////////////////; 760/// Return the system's host name.; 761 ; 762const char *TUnixSystem::HostName(); 763{; 764 if (fHostname == """") {; 765 char hn[64];; 766#if defined(R__SOLARIS); 767 sysinfo(SI_H",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:22255,error,error,22255,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"2 }; 9983 ; 9984 if (!mg_fopen(conn, path, MG_FOPEN_MODE_READ, filep)) {; 9985 mg_send_http_error(conn,; 9986 500,; 9987 ""Error: Cannot open file\nfopen(%s): %s"",; 9988 path,; 9989 strerror(ERRNO));; 9990 return;; 9991 }; 9992 ; 9993 fclose_on_exec(&filep->access, conn);; 9994 ; 9995 /* If ""Range"" request was made: parse header, send only selected part; 9996 * of the file. */; 9997 r1 = r2 = 0;; 9998 if ((range_hdr != NULL); 9999 && ((n = parse_range_header(range_hdr, &r1, &r2)) > 0) && (r1 >= 0); 10000 && (r2 >= 0)) {; 10001 /* actually, range requests don't play well with a pre-gzipped; 10002 * file (since the range is specified in the uncompressed space) */; 10003 if (filep->stat.is_gzipped) {; 10004 mg_send_http_error(; 10005 conn,; 10006 416, /* 416 = Range Not Satisfiable */; 10007 ""%s"",; 10008 ""Error: Range requests in gzipped files are not supported"");; 10009 (void)mg_fclose(; 10010 &filep->access); /* ignore error on read only file */; 10011 return;; 10012 }; 10013 conn->status_code = 206;; 10014 cl = (n == 2) ? (((r2 > cl) ? cl : r2) - r1 + 1) : (cl - r1);; 10015 mg_snprintf(conn,; 10016 NULL, /* range buffer is big enough */; 10017 range,; 10018 sizeof(range),; 10019 ""bytes ""; 10020 ""%"" INT64_FMT ""-%"" INT64_FMT ""/%"" INT64_FMT,; 10021 r1,; 10022 r1 + cl - 1,; 10023 filep->stat.size);; 10024 ; 10025#if defined(USE_ZLIB); 10026 /* Do not compress ranges. */; 10027 allow_on_the_fly_compression = 0;; 10028#endif; 10029 }; 10030 ; 10031 /* Do not compress small files. Small files do not benefit from file; 10032 * compression, but there is still some overhead. */; 10033#if defined(USE_ZLIB); 10034 if (filep->stat.size < MG_FILE_COMPRESSION_SIZE_LIMIT) {; 10035 /* File is below the size limit. */; 10036 allow_on_the_fly_compression = 0;; 10037 }; 10038#endif; 10039 ; 10040 /* Standard CORS header */; 10041 cors_orig_cfg = conn->dom_ctx->config[ACCESS_CONTROL_ALLOW_ORIGIN];; 10042 origin_hdr = mg_get_header(conn, ""Origin"");; 10043 if (cors_orig_cfg && *cors_orig_c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:287061,error,error,287061,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"2, 0.3, 0.4, 0.5};; 289 double ey[] = {1, 0.5, 1, 0.5, 1};; 290 auto ge = new TGraphErrors(5, x, y, ex, ey);; 291 ge->SetTitle(""Errors as a band"");; 292 ge->SetFillColor(4);; 293 ge->SetFillStyle(3010);; 294 ge->Draw(""a3"");; 295}; 296End_Macro; 297 ; 298The option ""4"" is similar to the option ""3"" except that the band; 299is smoothed. As the following picture shows, this option should be; 300used carefully because the smoothing algorithm may show some (huge); 301""bouncing"" effects. In some cases it looks nicer than option ""3""; 302(because it is smooth) but it can be misleading.; 303 ; 304Begin_Macro(source); 305{; 306 auto c42 = new TCanvas(""c42"",""c42"",200,10,600,400);; 307 double x[] = {0, 1, 2, 3, 4};; 308 double y[] = {0, 2, 4, 1, 3};; 309 double ex[] = {0.1, 0.2, 0.3, 0.4, 0.5};; 310 double ey[] = {1, 0.5, 1, 0.5, 1};; 311 auto ge = new TGraphErrors(5, x, y, ex, ey);; 312 ge->SetTitle(""Errors as a smooth band"");; 313 ge->SetFillColor(6);; 314 ge->SetFillStyle(3005);; 315 ge->Draw(""a4"");; 316}; 317End_Macro; 318 ; 319The following example shows how the option ""[]"" can be used to superimpose; 320systematic errors on top of a graph with statistical errors.; 321 ; 322Begin_Macro(source); 323{; 324 auto c43 = new TCanvas(""c43"",""c43"",200,10,600,400);; 325 c43->DrawFrame(0., -0.5, 6., 2);; 326 ; 327 double x[5] = {1, 2, 3, 4, 5};; 328 double zero[5] = {0, 0, 0, 0, 0};; 329 ; 330 // data set (1) with stat and sys errors; 331 double py1[5] = {1.2, 1.15, 1.19, 0.9, 1.4};; 332 double ey_stat1[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 333 double ey_sys1[5] = {0.5, 0.71, 0.76, 0.5, 0.45};; 334 ; 335 // data set (2) with stat and sys errors; 336 double y2[5] = {0.25, 0.18, 0.29, 0.2, 0.21};; 337 double ey_stat2[5] = {0.2, 0.18, 0.17, 0.2, 0.4};; 338 double ey_sys2[5] = {0.63, 0.19, 0.7, 0.2, 0.7};; 339 ; 340 // Now draw data set (1); 341 ; 342 // We first have to draw it only with the stat errors; 343 auto graph1 = new TGraphErrors(5, x, py1, zero, ey_stat1);; 344 graph1->SetMarkerSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:12522,error,errors,12522,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,2,['error'],['errors']
Availability,"2,y2right up corner ; [in]nx,nyarray size ; [in]icarray . Reimplemented from TVirtualX.; Definition at line 244 of file TGQuartz.mm. ◆ DrawFillArea(). void TGQuartz::DrawFillArea ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Fills area described by the polygon. ; Parameters. [in]nnumber of points ; [in]xylist of points. xy(2,n) . Reimplemented from TVirtualX.; Definition at line 186 of file TGQuartz.mm. ◆ DrawFTGlyphIntoPixmap(). void TGQuartz::DrawFTGlyphIntoPixmap ; (; void * ; pixmap, . FT_Bitmap * ; source, . ULong_t ; fore, . ULong_t ; back, . Int_t ; bx, . Int_t ; by . ). private . Definition at line 916 of file TGQuartz.mm. ◆ DrawLine() [1/2]. void TGCocoa::DrawLine ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x1, . Int_t ; y1, . Int_t ; x2, . Int_t ; y2 . ). overridevirtual . Uses the components of the specified GC to draw a line between the specified set of points (x1, y1) and (x2, y2). ; GC components in use: function, plane-mask, line-width, line-style, cap-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, and clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the GCValues_t structure) ; Reimplemented from TGCocoa.; Definition at line 172 of file TGCocoa.mm. ◆ DrawLine() [2/2]. void TGQuartz::DrawLine ; (; Int_t ; x1, . Int_t ; y1, . Int_t ; x2, . Int_t ; y2 . ). overridevirtual . Draws a line. ; Parameters. [in]x1,y1begin of line ; [in]x2,y2end of line . Reimplemented from TVirtualX.; Definition at line 252 of file TGQuartz.mm. ◆ DrawPolyLine(). void TGQuartz::DrawPolyLine ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Draws a line through all points in the list. ; Parameters. [in]nnumber of points ; [in]xylist of points . Reimplemented from TVirtualX.; Definition at line 300 of file TGQuartz.mm. ◆ DrawPolyMarker(). void TGQuartz::DrawPolyMarker ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Draws ""n""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGQuartz.html:56118,mask,mask,56118,doc/master/classTGQuartz.html,https://root.cern,https://root.cern/doc/master/classTGQuartz.html,2,['mask'],['mask']
Availability,"2.21831, denominator=wrap_pdf_Int[pTV]=89722.5; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=3.44258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13241,recover,recover,13241,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,2.5 0; : 762 | 15.5545 19.1688 0.0200359 0.00175521 43762.1 1; : 763 Minimum Test error found - save the configuration ; : 763 | 15.3589 18.6297 0.0200894 0.00181179 43769.4 0; : 764 Minimum Test error found - save the configuration ; : 764 | 15.3977 18.5678 0.0201039 0.0018081 43725.8 0; : 765 | 15.238 19.0685 0.0200523 0.00175459 43721.4 1; : 766 Minimum Test error found - save the configuration ; : 766 | 14.9634 18.5633 0.0200937 0.00181207 43759.7 0; : 767 Minimum Test error found - save the configuration ; : 767 | 14.6611 18.2211 0.0200896 0.00180918 43762.7 0; : 768 Minimum Test error found - save the configuration ; : 768 | 14.4892 18.1817 0.0200772 0.00181141 43797.6 0; : 769 Minimum Test error found - save the configuration ; : 769 | 14.3366 17.8635 0.0200909 0.00180773 43756.2 0; : 770 Minimum Test error found - save the configuration ; : 770 | 14.5733 17.5465 0.0200968 0.00180191 43728 0; : 771 | 13.9827 17.8429 0.0200367 0.0017469 43740.1 1; : 772 Minimum Test error found - save the configuration ; : 772 | 14.2497 17.3556 0.0201068 0.00181254 43729.6 0; : 773 | 14.0413 17.7428 0.020033 0.00175319 43764.2 1; : 774 Minimum Test error found - save the configuration ; : 774 | 13.9671 16.982 0.020108 0.00180715 43713.8 0; : 775 | 13.7965 17.224 0.0200334 0.0017548 43767 1; : 776 | 13.601 17.9652 0.0200139 0.00175385 43811.5 2; : 777 | 14.0445 17.0226 0.0200253 0.00175316 43782.5 3; : 778 Minimum Test error found - save the configuration ; : 778 | 13.4936 16.5395 0.0200845 0.00181482 43788.4 0; : 779 | 13.0033 16.7495 0.0200505 0.00176209 43743.6 1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.08,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:95985,error,error,95985,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,2.9 4; : 1090 | 2.7802 2.77409 0.0201095 0.00176132 43601.1 5; : 1091 Minimum Test error found - save the configuration ; : 1091 | 2.70558 2.65986 0.0201114 0.00182448 43747.2 0; : 1092 | 2.6448 3.0589 0.0201057 0.00177852 43651.1 1; : 1093 | 2.72808 2.74342 0.0203461 0.00179008 43112.8 2; : 1094 | 2.90448 3.26391 0.0206789 0.00182352 42428.3 3; : 1095 | 2.99675 3.1053 0.0203677 0.00177969 43038.5 4; : 1096 | 2.82435 2.85928 0.0200663 0.00175842 43696.9 5; : 1097 | 2.94319 2.67707 0.0201699 0.00175551 43444.3 6; : 1098 | 3.07322 3.0122 0.0200534 0.00175203 43712.7 7; : 1099 | 2.83008 3.95183 0.0205372 0.0017939 42681.9 8; : 1100 | 2.67822 3.34195 0.020666 0.00184085 42496.4 9; : 1101 | 2.97088 2.72336 0.0206136 0.0017901 42500 10; : 1102 Minimum Test error found - save the configuration ; : 1102 | 2.66188 2.52638 0.020367 0.00185502 43215.3 0; : 1103 | 3.01155 3.18843 0.0202364 0.00176536 43311 1; : 1104 | 2.71885 3.00051 0.0201103 0.00176305 43603.3 2; : 1105 Minimum Test error found - save the configuration ; : 1105 | 2.73591 2.50832 0.0201341 0.0018587 43774.7 0; : 1106 | 2.7002 2.7081 0.0203577 0.00176876 43036.3 1; : 1107 | 2.85017 3.38001 0.0201747 0.00176074 43445.3 2; : 1108 | 2.78494 2.55451 0.0203389 0.00176376 43068.3 3; : 1109 | 2.71632 3.12003 0.0200899 0.00175276 43627.4 4; : 1110 | 3.16531 2.9918 0.020346 0.00180026 43136.7 5; : 1111 Minimum Test error found - save the configuration ; : 1111 | 2.97087 2.45167 0.0201922 0.00182484 43555.6 0; : 1112 | 2.60355 2.50464 0.0200664 0.00176061 43702 1; : 1113 | 2.54376 2.96916 0.0200737 0.00178101 43733.3 2; : 1114 | 2.77186 2.89815 0.0200657 0.00175793 43697.4 3; : 1115 | 2.58652 2.73506 0.020068 0.00175912 43694.6 4; : 1116 Minimum Test error found - save the configuration ; : 1116 | 2.82496 2.31503 0.0201083 0.00181922 43742 0; : 1117 | 2.74168 2.90157 0.0200454 0.00175765 43745.2 1; : 1118 | 2.51176 4.00704 0.0201409 0.00176812 43542.7 2; : 1119 | 3.03618 2.55498 0.0202517 0.00178949 43331.7 3; : 1120 | 2.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:120007,error,error,120007,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2/2]. void TGraphMultiErrors::SetPointError ; (; Int_t ; i, . Int_t ; ne, . Double_t ; exL, . Double_t ; exH, . const Double_t * ; eyL, . const Double_t * ; eyH . ). virtual . Set ex and ey values for point i. ; Definition at line 1834 of file TGraphMultiErrors.cxx. ◆ SetPointEX(). void TGraphMultiErrors::SetPointEX ; (; Int_t ; i, . Double_t ; exL, . Double_t ; exH . ). virtual . Set ex values for point i. ; Definition at line 1844 of file TGraphMultiErrors.cxx. ◆ SetPointEXhigh(). void TGraphMultiErrors::SetPointEXhigh ; (; Int_t ; i, . Double_t ; exH . ). virtual . Set exH value for point i. ; Definition at line 1869 of file TGraphMultiErrors.cxx. ◆ SetPointEXlow(). void TGraphMultiErrors::SetPointEXlow ; (; Int_t ; i, . Double_t ; exL . ). virtual . Set exL value for point i. ; Definition at line 1853 of file TGraphMultiErrors.cxx. ◆ SetPointEY() [1/2]. void TGraphMultiErrors::SetPointEY ; (; Int_t ; i, . Int_t ; e, . Double_t ; eyL, . Double_t ; eyH . ). virtual . Set error e ey values for point i. ; Definition at line 1920 of file TGraphMultiErrors.cxx. ◆ SetPointEY() [2/2]. void TGraphMultiErrors::SetPointEY ; (; Int_t ; i, . Int_t ; ne, . const Double_t * ; eyL, . const Double_t * ; eyH . ). virtual . Set ey values for point i. ; Definition at line 1885 of file TGraphMultiErrors.cxx. ◆ SetPointEYhigh() [1/2]. void TGraphMultiErrors::SetPointEYhigh ; (; Int_t ; i, . Int_t ; e, . Double_t ; eyH . ). virtual . Set error e eyH value for point i. ; Definition at line 1951 of file TGraphMultiErrors.cxx. ◆ SetPointEYhigh() [2/2]. void TGraphMultiErrors::SetPointEYhigh ; (; Int_t ; i, . Int_t ; ne, . const Double_t * ; eyH . ). virtual . Set eyH values for point i. ; Definition at line 1907 of file TGraphMultiErrors.cxx. ◆ SetPointEYlow() [1/2]. void TGraphMultiErrors::SetPointEYlow ; (; Int_t ; i, . Int_t ; e, . Double_t ; eyL . ). virtual . Set error e eyL value for point i. ; Definition at line 1929 of file TGraphMultiErrors.cxx. ◆ SetPointEYlow() [2/2]. void TGra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:75275,error,error,75275,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,"2/3 of the marker size. |; 228| ""X"" | Do not draw error bars. By default, graph classes that have errors are drawn with the errors (TGraph itself has no errors, and so this option has no effect.) |; 229| \""\|\|\"" | Draw only the small vertical/horizontal lines at the ends of the error bars, without drawing the bars themselves. This option is interesting to superimpose statistical-only errors on top of a graph with statistical+systematic errors. |; 230| ""[]"" | Does the same as option \""\|\|\"" except that it draws additional marks at the ends of the small vertical/horizontal lines. It makes plots less ambiguous in case several graphs are drawn on the same picture. |; 231| ""0"" | By default, when a data point is outside the visible range along the Y axis, the error bars are not drawn. This option forces error bars' drawing for the data points outside the visible range along the Y axis (see example below). |; 232| ""2"" | Error rectangles are drawn. |; 233| ""3"" | A filled area is drawn through the end points of the vertical error bars. |; 234| ""4"" | A smoothed filled area is drawn through the end points of the vertical error bars. |; 235| ""5"" | Error rectangles are drawn like option ""2"". In addition the contour line around the boxes is drawn. This can be useful when boxes' fill colors are very light or in gray scale mode. |; 236 ; 237 ; 238`gStyle->SetErrorX(dx)` controls the size of the error along x.; 239`dx = 0` removes the error along x.; 240 ; 241`gStyle->SetEndErrorSize(np)` controls the size of the lines; 242at the end of the error bars (when option 1 is used).; 243By default `np=1`. (np represents the number of pixels).; 244 ; 245\anchor GrP3a; 246#### TGraphErrors; 247 ; 248A `TGraphErrors` is a `TGraph` with error bars. The errors are; 249defined along X and Y and are symmetric: The left and right errors are the same; 250along X and the bottom and up errors are the same along Y.; 251 ; 252Begin_Macro(source); 253{; 254 auto c4 = new TCanvas(""c4"",""c4"",200,10,600,4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPainter_8cxx_source.html:9397,error,error,9397,doc/master/TGraphPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPainter_8cxx_source.html,1,['error'],['error']
Availability,20 | 2.66116 2.61177 0.0204165 0.00176394 42889.5 4; : 1121 | 3.00965 2.56116 0.0204562 0.00180217 42886.2 5; : 1122 | 3.0625 3.75816 0.0204635 0.00176149 42776.2 6; : 1123 | 2.88666 2.6576 0.0204265 0.00178135 42906.6 7; : 1124 | 2.54231 2.73598 0.020225 0.00176346 43333.4 8; : 1125 | 2.44231 2.73459 0.0201498 0.00175906 43500.1 9; : 1126 | 2.45201 2.82465 0.0200726 0.00175651 43677.5 10; : 1127 | 2.54248 2.42056 0.0201867 0.00176633 43430.3 11; : 1128 | 2.47016 2.53962 0.0206089 0.00182988 42600.8 12; : 1129 | 2.38268 2.44496 0.0204067 0.00176828 42922.1 13; : 1130 | 2.59925 2.55821 0.0200531 0.00176378 43741.4 14; : 1131 | 2.55367 2.59723 0.0200573 0.00177202 43751.1 15; : 1132 | 2.73554 2.74944 0.020135 0.00176885 43558.3 16; : 1133 | 2.68556 2.54814 0.0200421 0.00176557 43772.1 17; : 1134 | 2.52258 2.47147 0.0200724 0.0017645 43696.9 18; : 1135 | 2.54757 2.67188 0.0200351 0.00176104 43778 19; : 1136 | 2.63764 2.78828 0.0200363 0.0017639 43781.8 20; : 1137 Minimum Test error found - save the configuration ; : 1137 | 2.5743 2.19951 0.0201074 0.00183887 43791.1 0; : 1138 | 2.48438 2.23196 0.0200456 0.00175699 43743.1 1; : 1139 | 2.50812 2.26597 0.0200665 0.00175755 43694.4 2; : 1140 | 2.3988 2.24899 0.0200386 0.00175805 43762.4 3; : 1141 | 2.7672 3.06409 0.0200539 0.00176427 43740.6 4; : 1142 | 2.49905 2.42566 0.0200843 0.00176461 43669 5; : 1143 | 2.42701 2.41776 0.0200668 0.00178464 43758.5 6; : 1144 | 2.26582 2.24235 0.0200333 0.00176428 43790 7; : 1145 | 2.32819 2.25052 0.0200451 0.00176354 43759.9 8; : 1146 | 2.38829 2.61112 0.0201128 0.00176481 43601.4 9; : 1147 Minimum Test error found - save the configuration ; : 1147 | 2.71251 2.10665 0.0201008 0.00183197 43790.4 0; : 1148 | 2.56397 2.40861 0.020487 0.00176022 42719.5 1; : 1149 | 2.55242 2.99103 0.0200648 0.00175967 43703.6 2; : 1150 | 2.53052 2.44638 0.0200564 0.00175887 43721.8 3; : 1151 | 2.36129 2.75405 0.0200417 0.00175605 43750.1 4; : 1152 | 2.30106 2.27284 0.0200533 0.00175628 43722.9 5; : 1153 | 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:122001,error,error,122001,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"20, Option_t *option=""same"")This function calculates the background spectrum in this histogram.Definition TH1.cxx:9287; TH1::FillNvirtual void FillN(Int_t, const Double_t *, const Double_t *, const Double_t *, Int_t)Definition TH1.h:224; TH1::SameLimitsAndNBinsstatic Bool_t SameLimitsAndNBins(const TAxis &axis1, const TAxis &axis2)Same limits and bins.Definition TH1.cxx:5898; TH1::Addvirtual Bool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""")Performs the operation: this = this + c1*f1 if errors are defined (see TH1::Sumw2),...Definition TH1.cxx:826; TH1::fMaximumDouble_t fMaximumMaximum value for plotting.Definition TH1.h:100; TH1::fBufferSizeInt_t fBufferSizefBuffer sizeDefinition TH1.h:107; TH1::RetrieveBinContentvirtual Double_t RetrieveBinContent(Int_t bin) constRaw retrieval of bin content on internal data structure see convention for numbering bins in TH1::Get...Definition TH1.cxx:9439; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::fDimensionInt_t fDimension! Histogram dimension (1, 2 or 3 dim)Definition TH1.h:110; TH1::SetBinErrorvirtual void SetBinError(Int_t bin, Double_t error)Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empt...Definition TH1.cxx:9206; TH1::fBinStatErrOptEBinErrorOpt fBinStatErrOptOption for bin statistical errors.Definition TH1.h:113; TH1::fgBufferSizestatic Int_t fgBufferSize! Default buffer size for automatic histogramsDefinition TH1.h:115; TH1::SetBinsLengthvirtual void SetBinsLength(Int_t=-1)Definition TH1.h:380; TH1::fNormFactorDouble_t fNormFactorNormalization factor.Definition TH1.h:102; TH1::Fillvirtual Int_t Fill(Double_t x)Increment bin with abscissa X by 1.Definition TH1.cxx:3344; TH1::GetYaxisTAxis * GetYaxis()Definition TH1.h:325; TH1::fContourTArrayD fContourArray to display contour levels.Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8h_source.html:66704,error,error,66704,doc/master/TH1_8h_source.html,https://root.cern,https://root.cern/doc/master/TH1_8h_source.html,1,['error'],['error']
Availability,"202 bool NormalizeErrors() const { return fNormErrors; }; 203 ; 204 ///do analysis for parabolic errors; 205 bool ParabErrors() const { return fParabErrors; }; 206 ; 207 ///do minos errors analysis on the parameters; 208 bool MinosErrors() const { return fMinosErrors; }; 209 ; 210 ///Update configuration after a fit using the FitResult; 211 bool UpdateAfterFit() const { return fUpdateAfterFit; }; 212 ; 213 ///Apply Weight correction for error matrix computation; 214 bool UseWeightCorrection() const { return fWeightCorr; }; 215 ; 216 ; 217 /// return vector of parameter indices for which the Minos Error will be computed; 218 const std::vector<unsigned int> & MinosParams() const { return fMinosParams; }; 219 ; 220 /**; 221 set the option to normalize the error on the result according to chi2/ndf; 222 */; 223 void SetNormErrors(bool on = true) { fNormErrors= on; }; 224 ; 225 ///set parabolic errors; 226 void SetParabErrors(bool on = true) { fParabErrors = on; }; 227 ; 228 ///set Minos errors computation to be performed after fitting; 229 void SetMinosErrors(bool on = true) { fMinosErrors = on; }; 230 ; 231 ///apply the weight correction for error matrix computation; 232 void SetWeightCorrection(bool on = true) { fWeightCorr = on; }; 233 ; 234 /// set parameter indices for running Minos; 235 /// this can be used for running Minos on a subset of parameters - otherwise is run on all of them; 236 /// if MinosErrors() is set; 237 void SetMinosErrors(const std::vector<unsigned int> & paramInd ) {; 238 fMinosErrors = true;; 239 fMinosParams = paramInd;; 240 }; 241 ; 242 ///Update configuration after a fit using the FitResult; 243 void SetUpdateAfterFit(bool on = true) { fUpdateAfterFit = on; }; 244 ; 245 ; 246 /**; 247 static function to control default minimizer type and algorithm; 248 */; 249 static void SetDefaultMinimizer(const char *type, const char *algo = nullptr);; 250 ; 251 ; 252 ; 253 ; 254protected:; 255 ; 256 ; 257private:; 258 ; 259 bool fNormErrors; ///< flag for",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitConfig_8h_source.html:6663,error,errors,6663,doc/master/FitConfig_8h_source.html,https://root.cern,https://root.cern/doc/master/FitConfig_8h_source.html,1,['error'],['errors']
Availability,"2046}; a#define a(i)Definition RSha256.hxx:99; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Float_tfloat Float_tDefinition RtypesCore.h:57; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; Long64_tlong long Long64_tDefinition RtypesCore.h:69; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBuffer.h; TClass.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; wwinID wDefinition TGWin32VirtualGLProxy.cxx:39; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; namechar name[80]Definition TGX11.cxx:110; THLimitsFinder.h; xminfloat xminDefinition THbookFile.cxx:95; yminfloat yminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; ymaxfloat ymaxDefinition THbookFile.cxx:95; TMath.h; TProfile2D.h; TProfileHelper.h; EErrorTypeEErrorTypeDefinition TProfile.h:28; kERRORSPREAD@ kERRORSPREADDefinition TProfile.h:28; kERRORSPREADG@ kERRORSPREADGDefinition TProfile.h:28; kERRORSPREADI@ kERRORSPREADIDefinition TProfile.h:28; gDebugInt_t gDebugDefinition TROOT.cxx:597; TArrayDArray of doubles (64 bits per element).Definition TArrayD.h:27; TArrayD::fArrayDouble_t * fArrayDefinition TArrayD.h:30; TArrayD::Streamervoid Streamer(TBuffer &) overrideStream a TArrayD object.Definition TArrayD.cxx:149; TArrayD::Copyvoid Copy(TArrayD &array) constDef",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile2D_8cxx_source.html:75744,error,error,75744,doc/master/TProfile2D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile2D_8cxx_source.html,1,['error'],['error']
Availability,207 43759.7 0; : 767 Minimum Test error found - save the configuration ; : 767 | 14.6611 18.2211 0.0200896 0.00180918 43762.7 0; : 768 Minimum Test error found - save the configuration ; : 768 | 14.4892 18.1817 0.0200772 0.00181141 43797.6 0; : 769 Minimum Test error found - save the configuration ; : 769 | 14.3366 17.8635 0.0200909 0.00180773 43756.2 0; : 770 Minimum Test error found - save the configuration ; : 770 | 14.5733 17.5465 0.0200968 0.00180191 43728 0; : 771 | 13.9827 17.8429 0.0200367 0.0017469 43740.1 1; : 772 Minimum Test error found - save the configuration ; : 772 | 14.2497 17.3556 0.0201068 0.00181254 43729.6 0; : 773 | 14.0413 17.7428 0.020033 0.00175319 43764.2 1; : 774 Minimum Test error found - save the configuration ; : 774 | 13.9671 16.982 0.020108 0.00180715 43713.8 0; : 775 | 13.7965 17.224 0.0200334 0.0017548 43767 1; : 776 | 13.601 17.9652 0.0200139 0.00175385 43811.5 2; : 777 | 14.0445 17.0226 0.0200253 0.00175316 43782.5 3; : 778 Minimum Test error found - save the configuration ; : 778 | 13.4936 16.5395 0.0200845 0.00181482 43788.4 0; : 779 | 13.0033 16.7495 0.0200505 0.00176209 43743.6 1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 1,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:96429,error,error,96429,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2095 iercr = 3;; 2096// in any case; 2097L1000:; 2098 if (ldebug) {; 2099 itoohi = 0;; 2100 for (i = 1; i <= ipt; ++i) {; 2101 if (fYpt[i-1] > aim + fUp) {; 2102 fYpt[i-1] = aim + fUp;; 2103 fChpt[i-1] = '+';; 2104 itoohi = 1;; 2105 }; 2106 }; 2107 fChpt[ipt] = 0;; 2108 chsign = ""POSI"";; 2109 if (fXdircr < 0) chsign = ""NEGA"";; 2110 if (fKe2cr == 0) {; 2111 Printf("" %sTIVE MINOS ERROR, PARAMETER %3d"",chsign,fKe1cr);; 2112 }; 2113 if (itoohi == 1) {; 2114 Printf(""POINTS LABELLED '+' WERE TOO HIGH TO PLOT."");; 2115 }; 2116 if (iercr == 1) {; 2117 Printf(""RIGHTMOST POINT IS UP AGAINST LIMIT."");; 2118 }; 2119 mnplot(fXpt, fYpt, fChpt, ipt, fNpagwd, fNpagln);; 2120 }; 2121}; 2122 ; 2123////////////////////////////////////////////////////////////////////////////////; 2124/// Makes sure that the current point is a local minimum; 2125///; 2126/// Makes sure that the current point is a local; 2127/// minimum and that the error matrix exists,; 2128/// or at least something good enough for MINOS and MNCONT; 2129 ; 2130void TMinuit::mncuve(); 2131{; 2132 /* Local variables */; 2133 Double_t dxdi, wint;; 2134 Int_t ndex, iext, i, j;; 2135 ; 2136 if (fISW[3] < 1) {; 2137 Printf("" FUNCTION MUST BE MINIMIZED BEFORE CALLING %s"",(const char*)fCfrom);; 2138 fApsi = fEpsi;; 2139 mnmigr();; 2140 }; 2141 if (fISW[1] < 3) {; 2142 mnhess();; 2143 if (fISW[1] < 1) {; 2144 mnwarn(""W"", fCfrom, ""NO ERROR MATRIX. WILL IMPROVISE."");; 2145 for (i = 1; i <= fNpar; ++i) {; 2146 ndex = i*(i-1) / 2;; 2147 for (j = 1; j <= i-1; ++j) {; 2148 ++ndex;; 2149 fVhmat[ndex-1] = 0;; 2150 }; 2151 ++ndex;; 2152 if (fG2[i-1] <= 0) {; 2153 wint = fWerr[i-1];; 2154 iext = fNexofi[i-1];; 2155 if (fNvarl[iext-1] > 1) {; 2156 mndxdi(fX[i-1], i-1, dxdi);; 2157 if (TMath::Abs(dxdi) < .001) wint = .01;; 2158 else wint /= TMath::Abs(dxdi);; 2159 }; 2160 fG2[i-1] = fUp / (wint*wint);; 2161 }; 2162 fVhmat[ndex-1] = 2 / fG2[i-1];; 2163 }; 2164 fISW[1] = 1;; 2165 fDcovar = 1;; 2166 } else mnwerr();; 2167 }; 2168}; 2169 ; 2170",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:71143,error,error,71143,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,1,['error'],['error']
Availability,"21 return;; 7822 }; 7823 ; 7824// 'SHO WARnings', ask if any suppressed mess in buffer; 7825 if (copt == ""W"") {; 7826 ityp = 1;; 7827 ctyp = ""WARNING"";; 7828 } else {; 7829 ityp = 2;; 7830 ctyp = ""*DEBUG*"";; 7831 }; 7832 if (fNwrmes[ityp-1] > 0) {; 7833 englsh = "" WAS SUPPRESSED. "";; 7834 if (fNwrmes[ityp-1] > 1) englsh = ""S WERE SUPPRESSED."";; 7835 Printf("" %5d MINUIT %s MESSAGE%s"",fNwrmes[ityp-1]; 7836 ,(const char*)ctyp,(const char*)englsh);; 7837 nm = fNwrmes[ityp-1];; 7838 ic = 0;; 7839 if (nm > kMAXMES) {; 7840 Printf("" ONLY THE MOST RECENT 10 WILL BE LISTED BELOW."");; 7841 nm = kMAXMES;; 7842 ic = fIcirc[ityp-1];; 7843 }; 7844 Printf("" CALLS ORIGIN MESSAGE"");; 7845 for (i = 1; i <= nm; ++i) {; 7846 ++ic;; 7847 if (ic > kMAXMES) ic = 1;; 7848 Printf("" %6d %s %s"", fNfcwar[ic],fOrigin[ic].Data(),fWarmes[ic].Data());; 7849 }; 7850 fNwrmes[ityp-1] = 0;; 7851 Printf("" "");; 7852 }; 7853}; 7854 ; 7855////////////////////////////////////////////////////////////////////////////////; 7856/// Calculates the WERR, external parameter errors; 7857///; 7858/// and the global correlation coefficients, to be called; 7859/// whenever a new covariance matrix is available.; 7860 ; 7861void TMinuit::mnwerr(); 7862{; 7863 Double_t denom, ba, al, dx, du1, du2;; 7864 Int_t ndex, ierr, i, j, k, l, ndiag, k1, iin;; 7865 ; 7866// calculate external error if v exists; 7867 if (fISW[1] >= 1) {; 7868 for (l = 1; l <= fNpar; ++l) {; 7869 ndex = l*(l + 1) / 2;; 7870 dx = TMath::Sqrt(TMath::Abs(fVhmat[ndex-1]*fUp));; 7871 i = fNexofi[l-1];; 7872 if (fNvarl[i-1] > 1) {; 7873 al = fAlim[i-1];; 7874 ba = fBlim[i-1] - al;; 7875 du1 = al + 0.5*(TMath::Sin(fX[l-1] + dx) + 1)*ba - fU[i-1];; 7876 du2 = al + 0.5*(TMath::Sin(fX[l-1] - dx) + 1)*ba - fU[i-1];; 7877 if (dx > 1) du1 = ba;; 7878 dx = 0.5*(TMath::Abs(du1) + TMath::Abs(du2));; 7879 }; 7880 fWerr[l-1] = dx;; 7881 }; 7882 }; 7883// global correlation coefficients; 7884 if (fISW[1] >= 1) {; 7885 for (i = 1; i <= fNpar; ++i) {; 7886 fGlobcc[i-1] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMinuit_8cxx_source.html:251048,error,errors,251048,doc/master/TMinuit_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMinuit_8cxx_source.html,2,"['avail', 'error']","['available', 'errors']"
Availability,"212 ; 1213////////////////////////////////////////////////////////////////////////////////; 1214/// Stream an object of class TAxis.; 1215 ; 1216void TAxis::Streamer(TBuffer &R__b); 1217{; 1218 if (R__b.IsReading()) {; 1219 UInt_t R__s, R__c;; 1220 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 1221 if (R__v > 5) {; 1222 R__b.ReadClassBuffer(TAxis::Class(), this, R__v, R__s, R__c);; 1223 return;; 1224 }; 1225 //====process old versions before automatic schema evolution; 1226 TNamed::Streamer(R__b);; 1227 TAttAxis::Streamer(R__b);; 1228 R__b >> fNbins;; 1229 if (R__v < 5) {; 1230 Float_t xmin,xmax;; 1231 R__b >> xmin; fXmin = xmin;; 1232 R__b >> xmax; fXmax = xmax;; 1233 Float_t *xbins = nullptr;; 1234 Int_t n = R__b.ReadArray(xbins);; 1235 fXbins.Set(n);; 1236 for (Int_t i=0;i<n;i++) fXbins.fArray[i] = xbins[i];; 1237 delete [] xbins;; 1238 } else {; 1239 R__b >> fXmin;; 1240 R__b >> fXmax;; 1241 fXbins.Streamer(R__b);; 1242 }; 1243 if (R__v > 2) {; 1244 R__b >> fFirst;; 1245 R__b >> fLast;; 1246 // following lines required to repair for a bug in Root version 1.03; 1247 if (fFirst < 0 || fFirst > fNbins) fFirst = 0;; 1248 if (fLast < 0 || fLast > fNbins) fLast = 0;; 1249 if (fLast < fFirst) { fFirst = 0; fLast = 0;}; 1250 if (fFirst ==0 && fLast == 0) SetBit(kAxisRange,false);; 1251 }; 1252 if (R__v > 3) {; 1253 R__b >> fTimeDisplay;; 1254 fTimeFormat.Streamer(R__b);; 1255 } else {; 1256 SetTimeFormat();; 1257 }; 1258 R__b.CheckByteCount(R__s, R__c, TAxis::IsA());; 1259 //====end of old versions; 1260 ; 1261 } else {; 1262 R__b.WriteClassBuffer(TAxis::Class(),this);; 1263 }; 1264}; 1265 ; 1266////////////////////////////////////////////////////////////////////////////////; 1267/// Reset first & last bin to the full range; 1268 ; 1269void TAxis::UnZoom(); 1270{; 1271 if (!gPad) {; 1272 Warning(""TAxis::UnZoom"",""Cannot UnZoom if gPad does not exist. Did you mean to draw the TAxis first?"");; 1273 return;; 1274 }; 1275 gPad->SetView();; 1276 ; 1277 //unzoom object owni",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAxis_8cxx_source.html:42275,repair,repair,42275,doc/master/TAxis_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAxis_8cxx_source.html,1,['repair'],['repair']
Availability,"212 return 0;; 8213 }; 8214 }; 8215 ; 8216 Bool_t afunc1 = kFALSE;; 8217 Bool_t afunc2 = kFALSE;; 8218 Double_t sum1 = 0, sum2 = 0;; 8219 Double_t ew1, ew2, w1 = 0, w2 = 0;; 8220 Int_t bin;; 8221 Int_t ifirst = 1;; 8222 Int_t ilast = ncx1;; 8223 // integral of all bins (use underflow/overflow if option); 8224 if (opt.Contains(""U"")) ifirst = 0;; 8225 if (opt.Contains(""O"")) ilast = ncx1 +1;; 8226 for (bin = ifirst; bin <= ilast; bin++) {; 8227 sum1 += h1->RetrieveBinContent(bin);; 8228 sum2 += h2->RetrieveBinContent(bin);; 8229 ew1 = h1->GetBinError(bin);; 8230 ew2 = h2->GetBinError(bin);; 8231 w1 += ew1*ew1;; 8232 w2 += ew2*ew2;; 8233 }; 8234 if (sum1 == 0) {; 8235 Error(""KolmogorovTest"",""Histogram1 %s integral is zero\n"",h1->GetName());; 8236 return 0;; 8237 }; 8238 if (sum2 == 0) {; 8239 Error(""KolmogorovTest"",""Histogram2 %s integral is zero\n"",h2->GetName());; 8240 return 0;; 8241 }; 8242 ; 8243 // calculate the effective entries.; 8244 // the case when errors are zero (w1 == 0 or w2 ==0) are equivalent to; 8245 // compare to a function. In that case the rescaling is done only on sqrt(esum2) or sqrt(esum1); 8246 Double_t esum1 = 0, esum2 = 0;; 8247 if (w1 > 0); 8248 esum1 = sum1 * sum1 / w1;; 8249 else; 8250 afunc1 = kTRUE; // use later for calculating z; 8251 ; 8252 if (w2 > 0); 8253 esum2 = sum2 * sum2 / w2;; 8254 else; 8255 afunc2 = kTRUE; // use later for calculating z; 8256 ; 8257 if (afunc2 && afunc1) {; 8258 Error(""KolmogorovTest"",""Errors are zero for both histograms\n"");; 8259 return 0;; 8260 }; 8261 ; 8262 ; 8263 Double_t s1 = 1/sum1;; 8264 Double_t s2 = 1/sum2;; 8265 ; 8266 // Find largest difference for Kolmogorov Test; 8267 Double_t dfmax =0, rsum1 = 0, rsum2 = 0;; 8268 ; 8269 for (bin=ifirst;bin<=ilast;bin++) {; 8270 rsum1 += s1*h1->RetrieveBinContent(bin);; 8271 rsum2 += s2*h2->RetrieveBinContent(bin);; 8272 dfmax = TMath::Max(dfmax,TMath::Abs(rsum1-rsum2));; 8273 }; 8274 ; 8275 // Get Kolmogorov probability; 8276 Double_t z, prb1=0, prb2=0, prb3=0;; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:324096,error,errors,324096,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"213 Int_t GetMore() const final;; 214 TClass *GenerateTClass(const char *classname, Bool_t emulation, Bool_t silent = kFALSE) final;; 215 TClass *GenerateTClass(ClassInfo_t *classinfo, Bool_t silent = kFALSE) final;; 216 Int_t GenerateDictionary(const char* classes, const char* includes = """", const char* options = nullptr) final;; 217 char* GetPrompt() final { return fPrompt; }; 218 const char* GetSharedLibs() final;; 219 const char* GetClassSharedLibs(const char* cls, bool skipCore = true) final;; 220 const char* GetSharedLibDeps(const char* lib, bool tryDyld = false) final;; 221 const char* GetIncludePath() final;; 222 virtual const char* GetSTLIncludePath() const final;; 223 TObjArray* GetRootMapFiles() const final { return fRootmapFiles; }; 224 unsigned long long GetInterpreterStateMarker() const final { return fTransactionCount;}; 225 virtual void Initialize() final;; 226 virtual void ShutDown() final;; 227 void InspectMembers(TMemberInspector&, const void* obj, const TClass* cl, Bool_t isTransient) final;; 228 Bool_t IsLoaded(const char* filename) const final;; 229 Bool_t IsLibraryLoaded(const char* libname) const final;; 230 Bool_t HasPCMForLibrary(const char *libname) const final;; 231 Int_t Load(const char* filenam, Bool_t system = kFALSE) final;; 232 void LoadMacro(const char* filename, EErrorCode* error = nullptr) final;; 233 Int_t LoadLibraryMap(const char* rootmapfile = nullptr) final;; 234 Int_t RescanLibraryMap() final;; 235 Int_t ReloadAllSharedLibraryMaps() final;; 236 Int_t UnloadAllSharedLibraryMaps() final;; 237 Int_t UnloadLibraryMap(const char* library) final;; 238 Longptr_t ProcessLine(const char* line, EErrorCode* error = nullptr) final;; 239 Longptr_t ProcessLineAsynch(const char* line, EErrorCode* error = nullptr);; 240 Longptr_t ProcessLineSynch(const char* line, EErrorCode* error = nullptr) final;; 241 void PrintIntro() final;; 242 bool RegisterPrebuiltModulePath(const std::string& FullPath,; 243 const std::string& ModuleMapName = ""module.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:10043,error,error,10043,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,4,['error'],['error']
Availability,"216 ; 3217 return cachedRDF;; 3218 }; 3219 ; 3220 template <bool IsSingleColumn, typename F>; 3221 RInterface<Proxied, DS_t>; 3222 VaryImpl(const std::vector<std::string> &colNames, F &&expression, const ColumnNames_t &inputColumns,; 3223 const std::vector<std::string> &variationTags, std::string_view variationName); 3224 {; 3225 using F_t = std::decay_t<F>;; 3226 using ColTypes_t = typename TTraits::CallableTraits<F_t>::arg_types;; 3227 using RetType = typename TTraits::CallableTraits<F_t>::ret_type;; 3228 constexpr auto nColumns = ColTypes_t::list_size;; 3229 ; 3230 SanityChecksForVary<RetType>(colNames, variationTags, variationName);; 3231 ; 3232 const auto validColumnNames = GetValidatedColumnNames(nColumns, inputColumns);; 3233 CheckAndFillDSColumns(validColumnNames, ColTypes_t{});; 3234 ; 3235 auto retTypeName = RDFInternal::TypeID2TypeName(typeid(RetType));; 3236 if (retTypeName.empty()) {; 3237 // The type is not known to the interpreter, but we don't want to error out; 3238 // here, rather if/when this column is used in jitted code, so we inject a broken but telling type name.; 3239 const auto demangledType = RDFInternal::DemangleTypeIdName(typeid(RetType));; 3240 retTypeName = ""CLING_UNKNOWN_TYPE_"" + demangledType;; 3241 }; 3242 ; 3243 auto variation = std::make_shared<RDFInternal::RVariation<F_t, IsSingleColumn>>(; 3244 colNames, variationName, std::forward<F>(expression), variationTags, retTypeName, fColRegister, *fLoopManager,; 3245 validColumnNames);; 3246 ; 3247 RDFInternal::RColumnRegister newCols(fColRegister);; 3248 newCols.AddVariation(std::move(variation));; 3249 ; 3250 RInterface<Proxied> newInterface(fProxiedPtr, *fLoopManager, std::move(newCols));; 3251 ; 3252 return newInterface;; 3253 }; 3254 ; 3255 RInterface<Proxied, DS_t> JittedVaryImpl(const std::vector<std::string> &colNames, std::string_view expression,; 3256 const std::vector<std::string> &variationTags,; 3257 std::string_view variationName, bool isSingleColumn); 3258 {; 3259 R__ASSERT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:184128,error,error,184128,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['error'],['error']
Availability,"216 b = ((i + 1) >= src_len) ? 0 : src[i + 1];; 7217 c = ((i + 2) >= src_len) ? 0 : src[i + 2];; 7218 ; 7219 dst[j++] = b64[a >> 2];; 7220 dst[j++] = b64[((a & 3) << 4) | (b >> 4)];; 7221 if (i + 1 < src_len) {; 7222 dst[j++] = b64[(b & 15) << 2 | (c >> 6)];; 7223 }; 7224 if (i + 2 < src_len) {; 7225 dst[j++] = b64[c & 63];; 7226 }; 7227 }; 7228 while (j % 4 != 0) {; 7229 dst[j++] = '=';; 7230 }; 7231 dst[j++] = '\0';; 7232}; 7233#endif; 7234 ; 7235 ; 7236#if defined(USE_LUA); 7237static unsigned char; 7238b64reverse(char letter); 7239{; 7240 if ((letter >= 'A') && (letter <= 'Z')) {; 7241 return letter - 'A';; 7242 }; 7243 if ((letter >= 'a') && (letter <= 'z')) {; 7244 return letter - 'a' + 26;; 7245 }; 7246 if ((letter >= '0') && (letter <= '9')) {; 7247 return letter - '0' + 52;; 7248 }; 7249 if (letter == '+') {; 7250 return 62;; 7251 }; 7252 if (letter == '/') {; 7253 return 63;; 7254 }; 7255 if (letter == '=') {; 7256 return 255; /* normal end */; 7257 }; 7258 return 254; /* error */; 7259}; 7260 ; 7261 ; 7262static int; 7263base64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len); 7264{; 7265 int i;; 7266 unsigned char a, b, c, d;; 7267 ; 7268 *dst_len = 0;; 7269 ; 7270 for (i = 0; i < src_len; i += 4) {; 7271 a = b64reverse(src[i]);; 7272 if (a >= 254) {; 7273 return i;; 7274 }; 7275 ; 7276 b = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);; 7277 if (b >= 254) {; 7278 return i + 1;; 7279 }; 7280 ; 7281 c = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);; 7282 if (c == 254) {; 7283 return i + 2;; 7284 }; 7285 ; 7286 d = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);; 7287 if (d == 254) {; 7288 return i + 3;; 7289 }; 7290 ; 7291 dst[(*dst_len)++] = (a << 2) + (b >> 4);; 7292 if (c != 255) {; 7293 dst[(*dst_len)++] = (b << 4) + (c >> 2);; 7294 if (d != 255) {; 7295 dst[(*dst_len)++] = (c << 6) + d;; 7296 }; 7297 }; 7298 }; 7299 return -1;; 7300}; 7301#endif; 7302 ; 7303 ; 7304static int; 7305is_put_or_delete_method(const stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:208461,error,error,208461,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"217 b = ((i + 1) >= src_len) ? 0 : src[i + 1];; 7218 c = ((i + 2) >= src_len) ? 0 : src[i + 2];; 7219 ; 7220 dst[j++] = b64[a >> 2];; 7221 dst[j++] = b64[((a & 3) << 4) | (b >> 4)];; 7222 if (i + 1 < src_len) {; 7223 dst[j++] = b64[(b & 15) << 2 | (c >> 6)];; 7224 }; 7225 if (i + 2 < src_len) {; 7226 dst[j++] = b64[c & 63];; 7227 }; 7228 }; 7229 while (j % 4 != 0) {; 7230 dst[j++] = '=';; 7231 }; 7232 dst[j++] = '\0';; 7233}; 7234#endif; 7235 ; 7236 ; 7237#if defined(USE_LUA); 7238static unsigned char; 7239b64reverse(char letter); 7240{; 7241 if ((letter >= 'A') && (letter <= 'Z')) {; 7242 return letter - 'A';; 7243 }; 7244 if ((letter >= 'a') && (letter <= 'z')) {; 7245 return letter - 'a' + 26;; 7246 }; 7247 if ((letter >= '0') && (letter <= '9')) {; 7248 return letter - '0' + 52;; 7249 }; 7250 if (letter == '+') {; 7251 return 62;; 7252 }; 7253 if (letter == '/') {; 7254 return 63;; 7255 }; 7256 if (letter == '=') {; 7257 return 255; /* normal end */; 7258 }; 7259 return 254; /* error */; 7260}; 7261 ; 7262 ; 7263static int; 7264base64_decode(const unsigned char *src, int src_len, char *dst, size_t *dst_len); 7265{; 7266 int i;; 7267 unsigned char a, b, c, d;; 7268 ; 7269 *dst_len = 0;; 7270 ; 7271 for (i = 0; i < src_len; i += 4) {; 7272 a = b64reverse(src[i]);; 7273 if (a >= 254) {; 7274 return i;; 7275 }; 7276 ; 7277 b = b64reverse(((i + 1) >= src_len) ? 0 : src[i + 1]);; 7278 if (b >= 254) {; 7279 return i + 1;; 7280 }; 7281 ; 7282 c = b64reverse(((i + 2) >= src_len) ? 0 : src[i + 2]);; 7283 if (c == 254) {; 7284 return i + 2;; 7285 }; 7286 ; 7287 d = b64reverse(((i + 3) >= src_len) ? 0 : src[i + 3]);; 7288 if (d == 254) {; 7289 return i + 3;; 7290 }; 7291 ; 7292 dst[(*dst_len)++] = (a << 2) + (b >> 4);; 7293 if (c != 255) {; 7294 dst[(*dst_len)++] = (b << 4) + (c >> 2);; 7295 if (d != 255) {; 7296 dst[(*dst_len)++] = (c << 6) + d;; 7297 }; 7298 }; 7299 }; 7300 return -1;; 7301}; 7302#endif; 7303 ; 7304 ; 7305static int; 7306is_put_or_delete_method(const stru",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:208493,error,error,208493,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"22, as shown above; #; # (Note that Vred is _not_ a simple sub-matrix of V); ; # Propagate partial error due to shape parameters (m,m2) using linear and; # sampling method; model.plotOn(frame2, VisualizeError=(r, {m, m2}, 2), FillColor=""c""); model.plotOn(frame2, Components=""bkg"", VisualizeError=(r, {m, m2}, 2), FillColor=""c""); ; model.plotOn(frame2); model.plotOn(frame2, Components=""bkg"", LineStyle=""--""); frame2.SetMinimum(0); ; # Make plot frame; frame3 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from (s,s2)""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame3, VisualizeError=(r, {s, s2}, 2), FillColor=""g""); model.plotOn(frame3, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""g""); ; model.plotOn(frame3); model.plotOn(frame3, Components=""bkg"", LineStyle=""--""); frame3.SetMinimum(0); ; # Make plot frame; frame4 = x.frame(Bins=40, Title=""Visualization of 2-sigma partial error from fsig""); ; # Propagate partial error due to yield parameter using linear and sampling; # method; model.plotOn(frame4, VisualizeError=(r, {fsig}, 2), FillColor=""m""); model.plotOn(frame4, Components=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:5032,error,error,5032,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,2,['error'],['error']
Availability,"22; TMarker::DrawMarkervirtual TMarker * DrawMarker(Double_t x, Double_t y)Draw this marker with new coordinates.Definition TMarker.cxx:208; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; ttauto * ttDefinition textangle.C:16; t1auto * t1Definition textangle.C:20; . Text Color; The text color is a color index (integer) pointing in the ROOT color table. The text color of any class inheriting from TAttText can be changed using the method SetTextColor and retrieved using the method GetTextColor. The following table shows the first 50 default colors. Color transparency; SetTextColorAlpha(), allows to set a transparent color. In the following example the text color of the text text is set to blue with an opacity of 35% (i.e. a transparency of 65%). (The color kBlue itself is internally stored as fully opaque.); text->SetTextColorAlpha(kBlue, 0.35);; textOption_t Option_t TPoint TPoint const char textDefinition TGWin32VirtualXProxy.cxx:68; The transparency is available on all platforms when the flag OpenGL.CanvasPreferGL is set to 1 in $ROOTSYS/etc/system.rootrc, or on Mac with the Cocoa backend. On the file output it is visible with PDF, PNG, Gif, JPEG, SVG, TeX ... but not PostScript.; Alternatively, you can call at the top of your script gSytle->SetCanvasPreferGL();. Or if you prefer to activate GL for a single canvas c, then use c->SetSupportGL(true);. Text Size; If the text precision (see next paragraph) is smaller than 3, the text size (textsize) is a fraction of the current pad size. Therefore the same textsize value can generate text outputs with different absolute sizes in two different pads. The text size in pixels (charheight) is computed the following way:; pad_width = gPad->XtoPixel(gPad->GetX2());; pad_height = gPad->YtoPixel(gPad->GetY1());; if (pad_width < pad_height) charheight = textsize*pad_width;; else charheight = textsize*pad_height;; textsizeOption_t Option_t textsizeDefinition TGWin32VirtualXProxy.cxx:58; gPad#define gPadDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTAttText.html:6182,avail,available,6182,doc/master/classTAttText.html,https://root.cern,https://root.cern/doc/master/classTAttText.html,1,['avail'],['available']
Availability,22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=7.28945 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=7.28945 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=7.28945 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this re,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:31508,error,error,31508,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"234 ; 235for h, color in zip([h_other, h_zz, h_higgs], [ROOT.kViolet - 9, ROOT.kAzure - 9, ROOT.kRed + 2]):; 236 h.SetLineWidth(1); 237 h.SetLineColor(1); 238 h.SetFillColor(color); 239 stack.Add(h); 240 ; 241stack.Draw(""HIST""); 242stack.GetXaxis().SetLabelSize(0.04); 243stack.GetXaxis().SetTitleSize(0.045); 244stack.GetXaxis().SetTitleOffset(1.3); 245stack.GetXaxis().SetTitle(""m_{4l}^{H#rightarrow ZZ} [GeV]""); 246stack.GetYaxis().SetLabelSize(0.04); 247stack.GetYaxis().SetTitleSize(0.045); 248stack.GetYaxis().SetTitle(""Events""); 249stack.SetMaximum(35); 250stack.GetYaxis().ChangeLabel(1, -1, 0); 251 ; 252# Draw MC scale factor and variations; 253histos_mc[""nominal""].SetFillColor(ROOT.kBlack); 254histos_mc[""nominal""].SetFillStyle(3254); 255h_nominal = histos_mc[""nominal""].DrawClone(""E2 same""); 256histos_mc[""weight:up""].SetLineColor(ROOT.kGreen + 2); 257h_weight_up = histos_mc[""weight:up""].DrawClone(""HIST SAME""); 258histos_mc[""weight:down""].SetLineColor(ROOT.kBlue + 2); 259h_weight_down = histos_mc[""weight:down""].DrawClone(""HIST SAME""); 260 ; 261# Draw data histogram; 262h_data.SetMarkerStyle(20); 263h_data.SetMarkerSize(1.2); 264h_data.SetLineWidth(2); 265h_data.SetLineColor(ROOT.kBlack); 266h_data.Draw(""E SAME"") # Draw raw data with errorbars; 267 ; 268# Add legend; 269legend = ROOT.TLegend(0.57, 0.65, 0.94, 0.94); 270legend.SetTextFont(42); 271legend.SetFillStyle(0); 272legend.SetBorderSize(0); 273legend.SetTextSize(0.025); 274legend.SetTextAlign(32); 275legend.AddEntry(h_data, ""Data"", ""lep""); 276legend.AddEntry(h_higgs, ""Higgs MC"", ""f""); 277legend.AddEntry(h_zz, ""ZZ MC"", ""f""); 278legend.AddEntry(h_other, ""Other MC"", ""f""); 279legend.AddEntry(h_weight_down, ""Total MC Variations Down"", ""l""); 280legend.AddEntry(h_weight_up, ""Total MC Variations Up"", ""l""); 281legend.AddEntry(h_nominal, ""Total MC Uncertainty"", ""f""); 282legend.Draw(); 283 ; 284text = ROOT.TLatex(); 285text.SetTextFont(72); 286text.SetTextSize(0.04); 287text.DrawLatexNDC(0.19, 0.85, ""ATLAS""); 288text.Set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html:11596,down,down,11596,doc/master/df106__HiggsToFourLeptons_8py_source.html,https://root.cern,https://root.cern/doc/master/df106__HiggsToFourLeptons_8py_source.html,1,['down'],['down']
Availability,"237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Copy constructor (necessary to hold unique_ptr as member variable).; 240 ; 241TF1Convolution::TF1Convolution(const TF1Convolution &conv); 242{; 243 conv.TF1Convolution::Copy(*this);; 244}; 245 ; 246////////////////////////////////////////////////////////////////////////////////; 247/// Operator =; 248 ; 249TF1Convolution &TF1Convolution::operator=(const TF1Convolution &rhs); 250{; 251 if (this != &rhs); 252 rhs.TF1Convolution::Copy(*this);; 253 return *this;; 254}; 255 ; 256////////////////////////////////////////////////////////////////////////////////; 257/// Perform the FFT of the two functions.; 258 ; 259void TF1Convolution::MakeFFTConv(); 260{; 261 if (gDebug); 262 Info(""MakeFFTConv"",""Making FFT convolution using %d points in range [%g,%g]"",fNofPoints,fXmin,fXmax);; 263 ; 264 std::vector < Double_t > x (fNofPoints);; 265 std::vector < Double_t > in1(fNofPoints);; 266 std::vector < Double_t > in2(fNofPoints);; 267 ; 268 TVirtualFFT *fft1 = TVirtualFFT::FFT(1, &fNofPoints, ""R2C K"");; 269 TVirtualFFT *fft2 = TVirtualFFT::FFT(1, &fNofPoints, ""R2C K"");; 270 if (fft1 == nullptr || fft2 == nullptr) {; 271 Warning(""MakeFFTConv"",""Cannot use FFT, probably FFTW package is not available. Switch to numerical convolution"");; 272 fFlagFFT = false;; 273 return;; 274 }; 275 ; 276 // apply a shift in order to have the second function centered around middle of the range of the convolution; 277 Double_t shift2 = 0.5*(fXmin+fXmax);; 278 Double_t x2;; 279 for (int i=0; i<fNofPoints; i++); 280 {; 281 x[i] = fXmin + (fXmax-fXmin)/(fNofPoints-1)*i;; 282 x2 = x[i] - shift2;; 283 in1[i] = fFunction1 -> EvalPar( &x[i], nullptr);; 284 in2[i] = fFunction2 -> EvalPar( &x2, nullptr);; 285 fft1 -> SetPoint(i, in1[i]);; 286 fft2 -> SetPoint(i, in2[i]);; 287 }; 288 fft1 -> Transform();; 289 fft2 -> Transform();; 290 ; 291 //inverse transformation of the product; 292 ; 293 TVirtualFFT *fftinverse = T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1Convolution_8cxx_source.html:10293,avail,available,10293,doc/master/TF1Convolution_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1Convolution_8cxx_source.html,1,['avail'],['available']
Availability,"24);; 5308 procinfo->fMemResident = rss * (getpagesize() / 1024);; 5309 }; 5310}; 5311#endif; 5312 ; 5313////////////////////////////////////////////////////////////////////////////////; 5314/// Returns static system info, like OS type, CPU type, number of CPUs; 5315/// RAM size, etc into the SysInfo_t structure. Returns -1 in case of error,; 5316/// 0 otherwise.; 5317 ; 5318int TUnixSystem::GetSysInfo(SysInfo_t *info) const; 5319{; 5320 if (!info) return -1;; 5321 ; 5322 static SysInfo_t sysinfo;; 5323 ; 5324 if (!sysinfo.fCpus) {; 5325#if defined(R__MACOSX); 5326 GetDarwinSysInfo(&sysinfo);; 5327#elif defined(R__LINUX); 5328 GetLinuxSysInfo(&sysinfo);; 5329#elif defined(R__FBSD); 5330 GetFreeBSDSysInfo(&sysinfo);; 5331#endif; 5332 }; 5333 ; 5334 *info = sysinfo;; 5335 ; 5336 return 0;; 5337}; 5338 ; 5339////////////////////////////////////////////////////////////////////////////////; 5340/// Returns cpu load average and load info into the CpuInfo_t structure.; 5341/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 5342/// interval over which the CPU load will be measured, in ms (default 1000).; 5343 ; 5344int TUnixSystem::GetCpuInfo(CpuInfo_t *info, Int_t sampleTime) const; 5345{; 5346 if (!info) return -1;; 5347 ; 5348#if defined(R__MACOSX); 5349 GetDarwinCpuInfo(info, sampleTime);; 5350#elif defined(R__LINUX); 5351 GetLinuxCpuInfo(info, sampleTime);; 5352#elif defined(R__FBSD); 5353 GetFreeBSDCpuInfo(info, sampleTime);; 5354#endif; 5355 ; 5356 return 0;; 5357}; 5358 ; 5359////////////////////////////////////////////////////////////////////////////////; 5360/// Returns ram and swap memory usage info into the MemInfo_t structure.; 5361/// Returns -1 in case of error, 0 otherwise.; 5362 ; 5363int TUnixSystem::GetMemInfo(MemInfo_t *info) const; 5364{; 5365 if (!info) return -1;; 5366 ; 5367#if defined(R__MACOSX); 5368 GetDarwinMemInfo(info);; 5369#elif defined(R__LINUX); 5370 GetLinuxMemInfo(info);; 5371#endif; 5372 ; 5373 return 0;; 5374}; 5375",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:173323,error,error,173323,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,24.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 | 57.7428 43.9646 0.0201606 0.00184632 43681.8 0; : 659 Minimum Test error found - save the configuration ; : 659 | 56.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:84175,error,error,84175,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"24/// the histogram.; 7525///; 7526/// IMPORTANT NOTE: The returned value depends on how the histogram statistics; 7527/// are calculated. By default, if no range has been set, the returned mean is; 7528/// the (unbinned) one calculated at fill time. If a range has been set, however,; 7529/// the mean is calculated using the bins in range, as described above; THIS; 7530/// IS TRUE EVEN IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset; 7531/// the range. To ensure that the returned mean (and all other statistics) is; 7532/// always that of the binned data stored in the histogram, call TH1::ResetStats.; 7533/// See TH1::GetStats.; 7534///; 7535/// Return mean value of this histogram along the X axis.; 7536 ; 7537Double_t TH1::GetMean(Int_t axis) const; 7538{; 7539 if (axis<1 || (axis>3 && axis<11) || axis>13) return 0;; 7540 Double_t stats[kNstat];; 7541 for (Int_t i=4;i<kNstat;i++) stats[i] = 0;; 7542 GetStats(stats);; 7543 if (stats[0] == 0) return 0;; 7544 if (axis<4){; 7545 Int_t ax[3] = {2,4,7};; 7546 return stats[ax[axis-1]]/stats[0];; 7547 } else {; 7548 // mean error = StdDev / sqrt( Neff ); 7549 Double_t stddev = GetStdDev(axis-10);; 7550 Double_t neff = GetEffectiveEntries();; 7551 return ( neff > 0 ? stddev/TMath::Sqrt(neff) : 0. );; 7552 }; 7553}; 7554 ; 7555////////////////////////////////////////////////////////////////////////////////; 7556/// Return standard error of mean of this histogram along the X axis.; 7557///; 7558/// Note that the mean value/StdDev is computed using the bins in the currently; 7559/// defined range (see TAxis::SetRange). By default the range includes; 7560/// all bins from 1 to nbins included, excluding underflows and overflows.; 7561/// To force the underflows and overflows in the computation, one must; 7562/// call the static function TH1::StatOverflows(kTRUE) before filling; 7563/// the histogram.; 7564///; 7565/// Also note, that although the definition of standard error doesn't include the; 7566/// assumpti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:294236,error,error,294236,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,"242////////////////////////////////////////////////////////////////////////////////; 5243/// Reduce the number of bins for the axis passed in the option to the number of bins having a label.; 5244/// The method will remove only the extra bins existing after the last ""labeled"" bin.; 5245/// Note that if there are ""un-labeled"" bins present between ""labeled"" bins they will not be removed; 5246 ; 5247void TH1::LabelsDeflate(Option_t *ax); 5248{; 5249 Int_t iaxis = AxisChoice(ax);; 5250 TAxis *axis = nullptr;; 5251 if (iaxis == 1) axis = GetXaxis();; 5252 if (iaxis == 2) axis = GetYaxis();; 5253 if (iaxis == 3) axis = GetZaxis();; 5254 if (!axis) {; 5255 Error(""LabelsDeflate"",""Invalid axis option %s"",ax);; 5256 return;; 5257 }; 5258 if (!axis->GetLabels()) return;; 5259 ; 5260 // find bin with last labels; 5261 // bin number is object ID in list of labels; 5262 // therefore max bin number is number of bins of the deflated histograms; 5263 TIter next(axis->GetLabels());; 5264 TObject *obj;; 5265 Int_t nbins = 0;; 5266 while ((obj = next())) {; 5267 Int_t ibin = obj->GetUniqueID();; 5268 if (ibin > nbins) nbins = ibin;; 5269 }; 5270 if (nbins < 1) nbins = 1;; 5271 ; 5272 // Do nothing in case it was the last bin; 5273 if (nbins==axis->GetNbins()) return;; 5274 ; 5275 TH1 *hold = (TH1*)IsA()->New();; 5276 R__ASSERT(hold);; 5277 hold->SetDirectory(nullptr);; 5278 Copy(*hold);; 5279 ; 5280 Bool_t timedisp = axis->GetTimeDisplay();; 5281 Double_t xmin = axis->GetXmin();; 5282 Double_t xmax = axis->GetBinUpEdge(nbins);; 5283 if (xmax <= xmin) xmax = xmin +nbins;; 5284 axis->SetRange(0,0);; 5285 axis->Set(nbins,xmin,xmax);; 5286 SetBinsLength(-1); // reset the number of cells; 5287 Int_t errors = fSumw2.fN;; 5288 if (errors) fSumw2.Set(fNcells);; 5289 axis->SetTimeDisplay(timedisp);; 5290 // reset histogram content; 5291 Reset(""ICE"");; 5292 ; 5293 //now loop on all bins and refill; 5294 // NOTE that if the bins without labels have content; 5295 // it will be put in the underflow/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:212831,error,errors,212831,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"2426 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12427 int n, error, exit_by_callback;; 12428 int ret;; 12429 ; 12430 /* body_len is the length of the entire queue in bytes; 12431 * len is the length of the current message; 12432 * data_len is the length of the current message's data payload; 12433 * header_len is the length of the current message's header */; 12434 size_t i, len, mask_len = 0, header_len, body_len;; 12435 uint64_t data_len = 0;; 12436 ; 12437 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12438 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12439 */; 12440 unsigned char mask[4];; 12441 ; 12442 /* data points to the place where the message is stored when passed to; 12443 * the websocket_data callback. This is either mem on the stack, or a; 12444 * dynamically allocated buffer if it is too large. */; 12445 unsigned char mem[4096];; 12446 unsigned char mop; /* mask flag and opcode */; 12447 ; 12448 ; 12449 /* Variables used for connection monitoring */; 12450 double timeout = -1.0;; 12451 int enable_ping_pong = 0;; 12452 int ping_count = 0;; 12453 ; 12454 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12455 enable_ping_pong =; 12456 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12457 ""yes"");; 12458 }; 12459 ; 12460 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12461 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12462 }; 12463 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12464 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12465 }; 12466 if (timeout <= 0.0) {; 12467 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12468 }; 12469 ; 12470 /* Enter data processing loop */; 12471 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12472 conn->request_info.remote_addr,; 12473 conn->request_info.remote_port);; 12474 conn->in_websocket_h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:360858,mask,mask,360858,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['mask'],['mask']
Availability,"2427 unsigned char *buf = (unsigned char *)conn->buf + conn->request_len;; 12428 int n, error, exit_by_callback;; 12429 int ret;; 12430 ; 12431 /* body_len is the length of the entire queue in bytes; 12432 * len is the length of the current message; 12433 * data_len is the length of the current message's data payload; 12434 * header_len is the length of the current message's header */; 12435 size_t i, len, mask_len = 0, header_len, body_len;; 12436 uint64_t data_len = 0;; 12437 ; 12438 /* ""The masking key is a 32-bit value chosen at random by the client.""; 12439 * http://tools.ietf.org/html/draft-ietf-hybi-thewebsocketprotocol-17#section-5; 12440 */; 12441 unsigned char mask[4];; 12442 ; 12443 /* data points to the place where the message is stored when passed to; 12444 * the websocket_data callback. This is either mem on the stack, or a; 12445 * dynamically allocated buffer if it is too large. */; 12446 unsigned char mem[4096];; 12447 unsigned char mop; /* mask flag and opcode */; 12448 ; 12449 ; 12450 /* Variables used for connection monitoring */; 12451 double timeout = -1.0;; 12452 int enable_ping_pong = 0;; 12453 int ping_count = 0;; 12454 ; 12455 if (conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG]) {; 12456 enable_ping_pong =; 12457 !mg_strcasecmp(conn->dom_ctx->config[ENABLE_WEBSOCKET_PING_PONG],; 12458 ""yes"");; 12459 }; 12460 ; 12461 if (conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) {; 12462 timeout = atoi(conn->dom_ctx->config[WEBSOCKET_TIMEOUT]) / 1000.0;; 12463 }; 12464 if ((timeout <= 0.0) && (conn->dom_ctx->config[REQUEST_TIMEOUT])) {; 12465 timeout = atoi(conn->dom_ctx->config[REQUEST_TIMEOUT]) / 1000.0;; 12466 }; 12467 if (timeout <= 0.0) {; 12468 timeout = atof(config_options[REQUEST_TIMEOUT].default_value) / 1000.0;; 12469 }; 12470 ; 12471 /* Enter data processing loop */; 12472 DEBUG_TRACE(""Websocket connection %s:%u start data processing loop"",; 12473 conn->request_info.remote_addr,; 12474 conn->request_info.remote_port);; 12475 conn->in_websocket_h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:360891,mask,mask,360891,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['mask'],['mask']
Availability,"245 fMvaEventErrorUpper( 0 ),; 246 fLogger ( 0 ); 247{; 248 fDataSetManager = new DataSetManager( fDataInputHandler );; 249 fDataSetManager->AddDataSetInfo(fDataSetInfo);; 250 fLogger = new MsgLogger(this);; 251 SetConfigName( GetName() );; 252 DeclareOptions();; 253 ParseOptions();; 254 ; 255 // arguments: names of input variables given in form: ""name1:name2:name3""; 256 // verbose flag; 257 DecodeVarNames(varNames);; 258 Init();; 259}; 260 ; 261////////////////////////////////////////////////////////////////////////////////; 262/// declaration of configuration options; 263 ; 264void TMVA::Reader::DeclareOptions(); 265{; 266 if (gTools().CheckForSilentOption( GetOptions() )) Log().InhibitOutput(); // make sure is silent if wanted to; 267 ; 268 DeclareOptionRef( fVerbose, ""V"", ""Verbose flag"" );; 269 DeclareOptionRef( fColor, ""Color"", ""Color flag (default True)"" );; 270 DeclareOptionRef( fSilent, ""Silent"", ""Boolean silent flag (default False)"" );; 271 DeclareOptionRef( fCalculateError, ""Error"", ""Calculates errors (default False)"" );; 272}; 273 ; 274////////////////////////////////////////////////////////////////////////////////; 275/// destructor; 276 ; 277TMVA::Reader::~Reader( void ); 278{; 279 delete fDataSetManager; // DSMTEST; 280 ; 281 delete fLogger;; 282 ; 283 for (auto it=fMethodMap.begin(); it!=fMethodMap.end(); it++){; 284 MethodBase * kl = dynamic_cast<TMVA::MethodBase*>(it->second);; 285 delete kl;; 286 }; 287}; 288 ; 289////////////////////////////////////////////////////////////////////////////////; 290/// default initialisation (no member variables); 291 ; 292void TMVA::Reader::Init( void ); 293{; 294 if (Verbose()) fLogger->SetMinType( kVERBOSE );; 295 ; 296 gConfig().SetUseColor( fColor );; 297 gConfig().SetSilent ( fSilent );; 298}; 299 ; 300////////////////////////////////////////////////////////////////////////////////; 301/// Add a float variable or expression to the reader; 302 ; 303void TMVA::Reader::AddVariable( const TString& expression, Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Reader_8cxx_source.html:9298,error,errors,9298,doc/master/Reader_8cxx_source.html,https://root.cern,https://root.cern/doc/master/Reader_8cxx_source.html,1,['error'],['errors']
Availability,"2457/// if option ""o"" original axis range of the target axes will be; 2458/// kept, but only bins inside the selected range will be filled.; 2459///; 2460/// Using a TCutG object, it is possible to select a sub-range of a 2-D histogram.; 2461/// One must create a graphical cut (mouse or C++) and specify the name; 2462/// of the cut between [] in the option.; 2463/// For example, with a TCutG named ""cutg"", one can call:; 2464/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg]"");; 2465/// To invert the cut, it is enough to put a ""-"" in front of its name:; 2466/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[-cutg]"");; 2467/// It is possible to apply several cuts:; 2468/// myhist->ProjectionY("" "",firstxbin,lastxbin,""[cutg1,cutg2]"");; 2469///; 2470/// NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; 2471/// a compatible axis, the histogram is reset and filled again with the projected contents of the TH2.; 2472/// In the case of axis incompatibility, an error is reported and a NULL pointer is returned.; 2473///; 2474/// NOTE that the Y axis attributes of the TH2 are copied to the X axis of the projection.; 2475 ; 2476TH1D *TH2::ProjectionY(const char *name, Int_t firstxbin, Int_t lastxbin, Option_t *option) const; 2477{; 2478 return DoProjection(false, name, firstxbin, lastxbin, option);; 2479}; 2480 ; 2481 ; 2482////////////////////////////////////////////////////////////////////////////////; 2483/// Replace current statistics with the values in array stats; 2484 ; 2485void TH2::PutStats(Double_t *stats); 2486{; 2487 TH1::PutStats(stats);; 2488 fTsumwy = stats[4];; 2489 fTsumwy2 = stats[5];; 2490 fTsumwxy = stats[6];; 2491}; 2492 ; 2493 ; 2494////////////////////////////////////////////////////////////////////////////////; 2495/// Compute the X distribution of quantiles in the other variable Y; 2496/// name is the name of the returned histogram; 2497/// prob is the probability content for the quantile (0.5 is the default for the medi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:101433,error,error,101433,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability,"2493<b>WARNING:</b> The palette axis is always drawn vertically.; 2494 ; 2495 ; 2496\anchor HP23; 2497### Setting the color palette; 2498 ; 2499 ; 2500To change the color palette `TStyle::SetPalette` should be used, eg:; 2501 ; 2502 gStyle->SetPalette(ncolors,colors);; 2503 ; 2504For example the option `COL` draws a 2D histogram with cells; 2505represented by a box filled with a color index which is a function; 2506of the cell content.; 2507If the cell content is N, the color index used will be the color number; 2508in `colors[N]`, etc. If the maximum cell content is greater than; 2509`ncolors`, all cell contents are scaled to `ncolors`.; 2510 ; 2511If ` ncolors <= 0`, a default palette (see below) of 50 colors is; 2512defined. This palette is recommended for pads, labels ...; 2513 ; 2514`if ncolors == 1 && colors == 0`, then a Pretty Palette with a; 2515Spectrum Violet->Red is created with 50 colors. That's the default rain bow; 2516palette.; 2517 ; 2518Other pre-defined palettes with 255 colors are available when `colors == 0`.; 2519The following value of `ncolors` give access to:; 2520 ; 2521 ; 2522 if ncolors = 51 and colors=0, a Deep Sea palette is used.; 2523 if ncolors = 52 and colors=0, a Grey Scale palette is used.; 2524 if ncolors = 53 and colors=0, a Dark Body Radiator palette is used.; 2525 if ncolors = 54 and colors=0, a two-color hue palette palette is used.(dark blue through neutral gray to bright yellow); 2526 if ncolors = 55 and colors=0, a Rain Bow palette is used.; 2527 if ncolors = 56 and colors=0, an inverted Dark Body Radiator palette is used.; 2528 ; 2529 ; 2530If `ncolors > 0 && colors == 0`, the default palette is used with a maximum of ncolors.; 2531 ; 2532The default palette defines:; 2533 ; 2534- index 0 to 9 : shades of grey; 2535- index 10 to 19 : shades of brown; 2536- index 20 to 29 : shades of blue; 2537- index 30 to 39 : shades of red; 2538- index 40 to 49 : basic colors; 2539 ; 2540The color numbers specified in the palette can be v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/THistPainter_8cxx_source.html:102216,avail,available,102216,doc/master/THistPainter_8cxx_source.html,https://root.cern,https://root.cern/doc/master/THistPainter_8cxx_source.html,1,['avail'],['available']
Availability,"25, -10, 10); for i in range(100):; hh.Fill(ROOT.gRandom.Gaus(0, 3)); return hh; ; ; def makeTTree():; # Create ROOT ROOT.TTree filled with a Gaussian distribution in x and a; # uniform distribution in y; ; tree = ROOT.TTree(""tree"", ""tree""); px = array(""d"", [0]); py = array(""d"", [0]); tree.Branch(""x"", px, ""x/D""); tree.Branch(""y"", py, ""y/D""); for i in range(100):; px[0] = ROOT.gRandom.Gaus(0, 3); py[0] = ROOT.gRandom.Uniform() * 30 - 15; tree.Fill(); return tree; ; ; ############################; # Importing ROOT histograms; ############################; # Import ROOT TH1 into a RooDataHist; # ---------------------------------------------------------; # Create a ROOT TH1 histogram; hh = makeTH1(); ; # Declare observable x; x = ROOT.RooRealVar(""x"", ""x"", -10, 10); ; # Create a binned dataset that imports contents of ROOT.TH1 and associates; # its contents to observable 'x'; dh = ROOT.RooDataHist(""dh"", ""dh"", [x], Import=hh); ; # Plot and fit a RooDataHist; # ---------------------------------------------------; # Make plot of binned dataset showing Poisson error bars (RooFit default); frame = x.frame(Title=""Imported ROOT.TH1 with Poisson error bars""); dh.plotOn(frame); ; # Fit a Gaussian p.d.f to the data; mean = ROOT.RooRealVar(""mean"", ""mean"", 0, -10, 10); sigma = ROOT.RooRealVar(""sigma"", ""sigma"", 3, 0.1, 10); gauss = ROOT.RooGaussian(""gauss"", ""gauss"", x, mean, sigma); gauss.fitTo(dh, PrintLevel=-1); gauss.plotOn(frame); ; # Plot and fit a RooDataHist with internal errors; # ---------------------------------------------------------------------------------------------; ; # If histogram has custom error (i.e. its contents is does not originate from a Poisson process; # but e.g. is a sum of weighted events) you can data with symmetric 'sum-of-weights' error instead; # (same error bars as shown by ROOT); frame2 = x.frame(Title=""Imported ROOT.TH1 with internal errors""); dh.plotOn(frame2, DataError=""SumW2""); gauss.plotOn(frame2); ; # Please note that error bars shown (Poisson ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf102__dataimport_8py.html:1562,error,error,1562,doc/master/rf102__dataimport_8py.html,https://root.cern,https://root.cern/doc/master/rf102__dataimport_8py.html,1,['error'],['error']
Availability,"25/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2726/// Example:; 2727/// ~~~~{.cpp}; 2728/// TFitResultPtr r = histo2d->Fit(func2, ""S"");; 2729/// func2->IntegralError(a,b,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2730/// ~~~~; 2731///; 2732/// IMPORTANT NOTE1:; 2733///; 2734/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2735/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2736/// TF1 function object are used in the integral error computation.; 2737/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2738/// from a global fitter instance when it exists. Note that the global fitter instance; 2739/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2740/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2741/// returned.; 2742///; 2743///; 2744/// IMPORTANT NOTE2:; 2745///; 2746/// When no covariance matrix is passed and in the meantime a fit is done; 2747/// using another function, the routine will signal an error and it will return zero only; 2748/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2749/// In the case that npar is the same, an incorrect result is returned.; 2750///; 2751/// IMPORTANT NOTE3:; 2752///; 2753/// The user must pass a pointer to the elements of the full covariance matrix; 2754/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2755/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2756/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2757 ; 2758Double_t TF1::IntegralError(Int_t n, const Double_t *a, const Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:103607,error,error,103607,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"2509 out << "" // parse all voxelized volumes"" << std::endl;; 2510 TGeoVolume *vol = nullptr;; 2511 Bool_t cyltype;; 2512 TIter next(fVolumes);; 2513 while ((vol = (TGeoVolume *)next())) {; 2514 if (!vol->GetVoxels()); 2515 continue;; 2516 out << "" vol = gGeoManager->GetVolume(\"""" << vol->GetName() << ""\"");"" << std::endl;; 2517 cyltype = vol->OptimizeVoxels();; 2518 if (cyltype) {; 2519 out << "" vol->SetCylVoxels();"" << std::endl;; 2520 } else {; 2521 out << "" vol->SetCylVoxels(kFALSE);"" << std::endl;; 2522 }; 2523 }; 2524 out << ""}"" << std::endl;; 2525 out.close();; 2526}; 2527////////////////////////////////////////////////////////////////////////////////; 2528/// Parse a string boolean expression and do a syntax check. Find top; 2529/// level boolean operator and returns its type. Fill the two; 2530/// substrings to which this operator applies. The returned integer is :; 2531/// - -1 : parse error; 2532/// - 0 : no boolean operator; 2533/// - 1 : union - represented as '+' in expression; 2534/// - 2 : difference (subtraction) - represented as '-' in expression; 2535/// - 3 : intersection - represented as '*' in expression.; 2536/// Parentheses should be used to avoid ambiguities. For instance :; 2537/// - A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); 2538/// eliminate not needed parentheses; 2539 ; 2540Int_t TGeoManager::Parse(const char *expr, TString &expr1, TString &expr2, TString &expr3); 2541{; 2542 TString startstr(expr);; 2543 Int_t len = startstr.Length();; 2544 Int_t i;; 2545 TString e0 = """";; 2546 expr3 = """";; 2547 // eliminate blanks; 2548 for (i = 0; i < len; i++) {; 2549 if (startstr(i) == ' '); 2550 continue;; 2551 e0 += startstr(i, 1);; 2552 }; 2553 Int_t level = 0;; 2554 Int_t levmin = 999;; 2555 Int_t boolop = 0;; 2556 Int_t indop = 0;; 2557 Int_t iloop = 1;; 2558 Int_t lastop = 0;; 2559 Int_t lastdp = 0;; 2560 Int_t lastpp = 0;; 2561 Bool_t foundmat = kFALSE;; 2562 // check/eliminate parentheses; 2563 while (iloop == 1) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:90551,error,error,90551,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,1,['error'],['error']
Availability,254 43729.6 0; : 773 | 14.0413 17.7428 0.020033 0.00175319 43764.2 1; : 774 Minimum Test error found - save the configuration ; : 774 | 13.9671 16.982 0.020108 0.00180715 43713.8 0; : 775 | 13.7965 17.224 0.0200334 0.0017548 43767 1; : 776 | 13.601 17.9652 0.0200139 0.00175385 43811.5 2; : 777 | 14.0445 17.0226 0.0200253 0.00175316 43782.5 3; : 778 Minimum Test error found - save the configuration ; : 778 | 13.4936 16.5395 0.0200845 0.00181482 43788.4 0; : 779 | 13.0033 16.7495 0.0200505 0.00176209 43743.6 1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Minimum Test error found - save the configuration ; : 791 | 11.5078 15.2368 0.0201178 0.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.13,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:97052,error,error,97052,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"2545 }; 2546 return quantile;; 2547}; 2548 ; 2549////////////////////////////////////////////////////////////////////////////////; 2550/// Simple recursive algorithm to find the permutations of; 2551/// n natural numbers, not necessarily all distinct; 2552/// adapted from CERNLIB routine PERMU.; 2553/// The input array has to be initialised with a non descending; 2554/// sequence. The method returns kFALSE when; 2555/// all combinations are exhausted.; 2556 ; 2557Bool_t TMath::Permute(Int_t n, Int_t *a); 2558{; 2559 Int_t i,itmp;; 2560 Int_t i1=-1;; 2561 ; 2562 // find rightmost upward transition; 2563 for(i=n-2; i>-1; i--) {; 2564 if(a[i]<a[i+1]) {; 2565 i1=i;; 2566 break;; 2567 }; 2568 }; 2569 // no more upward transitions, end of the story; 2570 if(i1==-1) return kFALSE;; 2571 else {; 2572 // find lower right element higher than the lower; 2573 // element of the upward transition; 2574 for(i=n-1;i>i1;i--) {; 2575 if(a[i] > a[i1]) {; 2576 // swap the two; 2577 itmp=a[i1];; 2578 a[i1]=a[i];; 2579 a[i]=itmp;; 2580 break;; 2581 }; 2582 }; 2583 // order the rest, in fact just invert, as there; 2584 // are only downward transitions from here on; 2585 for(i=0;i<(n-i1-1)/2;i++) {; 2586 itmp=a[i1+i+1];; 2587 a[i1+i+1]=a[n-i-1];; 2588 a[n-i-1]=itmp;; 2589 }; 2590 }; 2591 return kTRUE;; 2592}; 2593 ; 2594////////////////////////////////////////////////////////////////////////////////; 2595/// Computes density function for Student's t- distribution; 2596/// (the probability function (integral of density) is computed in StudentI).; 2597///; 2598/// First parameter stands for x - the actual variable of the; 2599/// density function p(x) and the point at which the density is calculated.; 2600/// Second parameter stands for number of degrees of freedom.; 2601///; 2602/// About Student distribution:; 2603/// Student's t-distribution is used for many significance tests, for example,; 2604/// for the Student's t-tests for the statistical significance of difference; 2605/// between t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:88413,down,downward,88413,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['down'],['downward']
Availability,"254; TObjectMother of all ROOT objects.Definition TObject.h:41; TObject::TestBitR__ALWAYS_INLINE Bool_t TestBit(UInt_t f) constDefinition TObject.h:199; TObject::Streamervirtual void Streamer(TBuffer &)Stream an object of class TObject.Definition TObject.cxx:894; TObject::ClassNamevirtual const char * ClassName() constReturns name of class to which the object belongs.Definition TObject.cxx:213; TObject::AppendPadvirtual void AppendPad(Option_t *option="""")Append graphics object to current pad.Definition TObject.cxx:190; TObject::SetBitvoid SetBit(UInt_t f, Bool_t set)Set or unset the user status bits as specified in f.Definition TObject.cxx:786; TObject::InheritsFromvirtual Bool_t InheritsFrom(const char *classname) constReturns kTRUE if object inherits from class ""classname"".Definition TObject.cxx:530; TObject::Copyvirtual void Copy(TObject &object) constCopy this to obj.Definition TObject.cxx:146; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TObject::ResetBitvoid ResetBit(UInt_t f)Definition TObject.h:198; TObject::kCanDelete@ kCanDeleteif object in a list can be deletedDefinition TObject.h:62; TPolyLineDefined by an array on N points in a 2-D space.Definition TPolyLine.h:23; TPolyLine::fOptionTString fOptionoptionsDefinition TPolyLine.h:30; TPolyLine::Sizevirtual Int_t Size() constDefinition TPolyLine.h:71; TPolyLine::fLastPointInt_t fLastPointThe index of the last filled point.Definition TPolyLine.h:27; TPolyLine::Mergevirtual Int_t Merge(TCollection *list)Merge polylines in the collection in this polyline.Definition TPolyLine.cxx:479; TPolyLine::PaintPolyLineNDCvirtual void PaintPolyLineNDC(Int_t n, Double_t *x, Double_t *y, Option_t *option="""")Draw this polyline with new coordinates in NDC.Definition TPolyLine.cxx:560; TPolyLine::Copyvoid Copy(TObject &polyline) const overrideCopy this polyline to polyline.Definition TPolyLine.cxx:140; TPolyLine::DistancetoPrimitiveInt_t Distanc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPolyLine_8cxx_source.html:28596,error,error,28596,doc/master/TPolyLine_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPolyLine_8cxx_source.html,1,['error'],['error']
Availability,"258 cHl3=4.96668 cHq3=0.0273884; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, deno",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:13479,recover,recover,13479,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,"258 if (!axis->GetLabels()) return;; 5259 ; 5260 // find bin with last labels; 5261 // bin number is object ID in list of labels; 5262 // therefore max bin number is number of bins of the deflated histograms; 5263 TIter next(axis->GetLabels());; 5264 TObject *obj;; 5265 Int_t nbins = 0;; 5266 while ((obj = next())) {; 5267 Int_t ibin = obj->GetUniqueID();; 5268 if (ibin > nbins) nbins = ibin;; 5269 }; 5270 if (nbins < 1) nbins = 1;; 5271 ; 5272 // Do nothing in case it was the last bin; 5273 if (nbins==axis->GetNbins()) return;; 5274 ; 5275 TH1 *hold = (TH1*)IsA()->New();; 5276 R__ASSERT(hold);; 5277 hold->SetDirectory(nullptr);; 5278 Copy(*hold);; 5279 ; 5280 Bool_t timedisp = axis->GetTimeDisplay();; 5281 Double_t xmin = axis->GetXmin();; 5282 Double_t xmax = axis->GetBinUpEdge(nbins);; 5283 if (xmax <= xmin) xmax = xmin +nbins;; 5284 axis->SetRange(0,0);; 5285 axis->Set(nbins,xmin,xmax);; 5286 SetBinsLength(-1); // reset the number of cells; 5287 Int_t errors = fSumw2.fN;; 5288 if (errors) fSumw2.Set(fNcells);; 5289 axis->SetTimeDisplay(timedisp);; 5290 // reset histogram content; 5291 Reset(""ICE"");; 5292 ; 5293 //now loop on all bins and refill; 5294 // NOTE that if the bins without labels have content; 5295 // it will be put in the underflow/overflow.; 5296 // For this reason we use AddBinContent method; 5297 Double_t oldEntries = fEntries;; 5298 Int_t bin,binx,biny,binz;; 5299 for (bin=0; bin < hold->fNcells; ++bin) {; 5300 hold->GetBinXYZ(bin,binx,biny,binz);; 5301 Int_t ibin = GetBin(binx,biny,binz);; 5302 Double_t cu = hold->RetrieveBinContent(bin);; 5303 AddBinContent(ibin,cu);; 5304 if (errors) {; 5305 fSumw2.fArray[ibin] += hold->fSumw2.fArray[bin];; 5306 }; 5307 }; 5308 fEntries = oldEntries;; 5309 delete hold;; 5310}; 5311 ; 5312////////////////////////////////////////////////////////////////////////////////; 5313/// Double the number of bins for axis.; 5314/// Refill histogram.; 5315/// This function is called by TAxis::FindBin(const char *label); 5316",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:212861,error,errors,212861,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"25; ROOT::Math::Minimizer::MinimizerMinimizer(Minimizer &&)=delete; ROOT::Math::Minimizer::fStatusint fStatusstatus of minimizerDefinition Minimizer.h:371; ROOT::Math::Minimizer::SetVariableValuevirtual bool SetVariableValue(unsigned int ivar, double value)set the value of an already existing variableDefinition Minimizer.cxx:53; ROOT::Math::Minimizer::SetFunctionvirtual void SetFunction(const ROOT::Math::IMultiGenFunction &func)=0set the function to minimize; ROOT::Math::Minimizer::Scanvirtual bool Scan(unsigned int ivar, unsigned int &nstep, double *x, double *y, double xmin=0, double xmax=0)scan function minimum for variable i.Definition Minimizer.cxx:195; ROOT::Math::Minimizer::MaxIterationsunsigned int MaxIterations() constmax iterationsDefinition Minimizer.h:297; ROOT::Math::Minimizer::SetDefaultOptionsvoid SetDefaultOptions()reset the default options (defined in MinimizerOptions)Definition Minimizer.h:361; ROOT::Math::Minimizer::fValidErrorbool fValidErrorflag to control if errors have been validated (Hesse has been run in case of Minuit)Definition Minimizer.h:369; ROOT::Math::Minimizer::MinosStatusvirtual int MinosStatus() conststatus code of Minos (to be re-implemented by the minimizers supporting Minos)Definition Minimizer.h:313; ROOT::Math::Minimizer::SetVariableLimitsvirtual bool SetVariableLimits(unsigned int ivar, double lower, double upper)set the limits of an already existing variableDefinition Minimizer.h:199; ROOT::Math::Minimizer::SetTolerancevoid SetTolerance(double tol)set the toleranceDefinition Minimizer.h:337; ROOT::Math::Minimizer::MinimizerMinimizer(Minimizer const &)=delete; ROOT::Math::Minimizer::CovMatrixStatusvirtual int CovMatrixStatus() constreturn status of covariance matrix using Minuit convention {0 not calculated 1 approximated 2 made po...Definition Minimizer.h:256; ROOT::Math::Minimizer::Minimizevirtual bool Minimize()=0method to perform the minimization; ROOT::Math::Minimizer::Statusint Status() conststatus code of minimizerDefi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:24921,error,errors,24921,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['error'],['errors']
Availability,"26 of file TPSocket.cxx. ◆ RecvRaw(). Int_t TPSocket::RecvRaw ; (; void * ; buffer, . Int_t ; length, . ESendRecvOptions ; opt = kDefault . ). overridevirtual . Send a raw buffer of specified length. ; Returns the number of bytes sent or -1 in case of error. ; Reimplemented from TSocket.; Definition at line 679 of file TPSocket.cxx. ◆ Send() [1/4]. Int_t TPSocket::Send ; (; const char * ; str, . Int_t ; kind = kMESS_STRING . ). inlineoverridevirtual . Send a character string buffer. ; Use kind to set the TMessage ""what"" field. Returns the number of bytes in the string str that were sent and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented from TSocket.; Definition at line 71 of file TPSocket.h. ◆ Send() [2/4]. Int_t TPSocket::Send ; (; const TMessage & ; mess). overridevirtual . Send a TMessage object. ; Returns the number of bytes in the TMessage that were sent and -1 in case of error. In case the TMessage::What has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. Returns -4 in case of kNoBlock and errno == EWOULDBLOCK. ; Reimplemented from TSocket.; Definition at line 483 of file TPSocket.cxx. ◆ Send() [3/4]. Int_t TPSocket::Send ; (; Int_t ; kind). inlineoverridevirtual . Send a single message opcode. ; Use kind (opcode) to set the TMessage ""what"" field. Returns the number of bytes that were sent (always sizeof(Int_t)) and -1 in case of error. In case the kind has been or'ed with kMESS_ACK, the call will only return after having received an acknowledgement, making the sending process synchronous. ; Reimplemented from TSocket.; Definition at line 69 of file TPSocket.h. ◆ Send() [4/4]. Int_t TPSocket::Send ; (; Int_t ; status, . Int_t ; kind . ). inlineoverridevirtual . Send a status and a single message opcode. ; Use kind (opcode) to set ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPSocket.html:28792,error,error,28792,doc/master/classTPSocket.html,https://root.cern,https://root.cern/doc/master/classTPSocket.html,1,['error'],['error']
Availability,"2675/// Note that to get the TFitResult, te fit should be done using the fit option `S`.; 2676/// Example:; 2677/// ~~~~{.cpp}; 2678/// TFitResultPtr r = histo->Fit(func, ""S"");; 2679/// func->IntegralError(x1,x2,r->GetParams(), r->GetCovarianceMatrix()->GetMatrixArray() );; 2680/// ~~~~; 2681///; 2682/// IMPORTANT NOTE1:; 2683///; 2684/// A null pointer to the parameter values vector and to the covariance matrix can be passed.; 2685/// In this case, when the parameter values pointer is null, the parameter values stored in this; 2686/// TF1 function object are used in the integral error computation.; 2687/// When the poassed pointer to the covariance matrix is null, a covariance matrix from the last fit is retrieved; 2688/// from a global fitter instance when it exists. Note that the global fitter instance; 2689/// esists only when ROOT is not running with multi-threading enabled (ROOT::IsImplicitMTEnabled() == True).; 2690/// When the ovariance matrix from the last fit cannot be retrieved, an error message is printed and a zero value is; 2691/// returned.; 2692///; 2693///; 2694/// IMPORTANT NOTE2:; 2695///; 2696/// When no covariance matrix is passed and in the meantime a fit is done; 2697/// using another function, the routine will signal an error and it will return zero only; 2698/// when the number of fit parameter is different than the values stored in TF1 (TF1::GetNpar() ).; 2699/// In the case that npar is the same, an incorrect result is returned.; 2700///; 2701/// IMPORTANT NOTE3:; 2702///; 2703/// The user must pass a pointer to the elements of the full covariance matrix; 2704/// dimensioned with the right size (npar*npar), where npar is the total number of parameters (TF1::GetNpar()),; 2705/// including also the fixed parameters. The covariance matrix must be retrieved from the TFitResult class as; 2706/// shown above and not from TVirtualFitter::GetCovarianceMatrix() function.; 2707 ; 2708Double_t TF1::IntegralError(Double_t a, Double_t b, const Double_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:100700,error,error,100700,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,1,['error'],['error']
Availability,"27 TStreamerLoop *eloop = (TStreamerLoop*)element;; 2828 if (fName == eloop->GetCountClass()) {; 2829 eloop->SetCountClass(newname);; 2830 eloop->Init();; 2831 }; 2832 } else if (element->IsA() == TStreamerBasicPointer::Class()) {; 2833 TStreamerBasicPointer *eptr = (TStreamerBasicPointer*)element;; 2834 if (fName == eptr->GetCountClass()) {; 2835 eptr->SetCountClass(newname);; 2836 eptr->Init();; 2837 }; 2838 }; 2839 }; 2840 }; 2841 ++fgCount;; 2842 newinfo->fNumber = fgCount;; 2843 return newinfo;; 2844}; 2845 ; 2846////////////////////////////////////////////////////////////////////////////////; 2847/// Return True if the current StreamerInfo in cl or info is equivalent to this TStreamerInfo.; 2848///; 2849/// In this context 'Equivalent' means the same number of persistent data member which the same actual C++ type and; 2850/// the same name.; 2851/// If 'warn' is true, Warning message are printed to explicit the differences.; 2852/// If 'complete' is false, stop at the first error, otherwise continue until all members have been checked.; 2853 ; 2854Bool_t TStreamerInfo::CompareContent(TClass *cl, TVirtualStreamerInfo *info, Bool_t warn, Bool_t complete, TFile *file); 2855{; 2856 Bool_t result = kTRUE;; 2857 R__ASSERT( (cl==0 || info==0) && (cl!=0 || info!=0) /* must compare to only one thing! */);; 2858 ; 2859 TString name;; 2860 TString type;; 2861 TStreamerElement *el;; 2862 TStreamerElement *infoel = 0;; 2863 ; 2864 TIter next(GetElements());; 2865 TIter infonext((TList*)0);; 2866 TIter basenext((TList*)0);; 2867 TIter membernext((TList*)0);; 2868 if (info) {; 2869 infonext = info->GetElements();; 2870 }; 2871 if (cl) {; 2872 TList *tlb = cl->GetListOfBases();; 2873 if (tlb) { // Loop over bases; 2874 basenext = tlb;; 2875 }; 2876 tlb = cl->GetListOfDataMembers();; 2877 if (tlb) {; 2878 membernext = tlb;; 2879 }; 2880 }; 2881 ; 2882 // First let's compare base classes; 2883 Bool_t done = kFALSE;; 2884 TString localClass;; 2885 TString otherClass;; 2886 while",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:113436,error,error,113436,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['error'],['error']
Availability,"2735 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12736 /* Opcode == 8, connection close */; 12737 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12738 conn->request_info.remote_addr,; 12739 conn->request_info.remote_port);; 12740 break;; 12741 }; 12742 ; 12743 /* Not breaking the loop, process next websocket frame. */; 12744 } else {; 12745 /* Read from the socket into the next available location in the; 12746 * message queue. */; 12747 n = pull_inner(NULL,; 12748 conn,; 12749 conn->buf + conn->data_len,; 12750 conn->buf_size - conn->data_len,; 12751 timeout);; 12752 if (n <= -2) {; 12753 /* Error, no bytes read */; 12754 DEBUG_TRACE(""PULL from %s:%u failed"",; 12755 conn->request_info.remote_addr,; 12756 conn->request_info.remote_port);; 12757 break;; 12758 }; 12759 if (n > 0) {; 12760 conn->data_len += n;; 12761 /* Reset open PING count */; 12762 ping_count = 0;; 12763 } else {; 12764 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12765 && (!conn->must_close)) {; 12766 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12767 /* Stop sending PING */; 12768 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12769 ""- closing connection"",; 12770 ping_count,; 12771 conn->request_info.remote_addr,; 12772 conn->request_info.remote_port);; 12773 break;; 12774 }; 12775 if (enable_ping_pong) {; 12776 /* Send Websocket PING message */; 12777 DEBUG_TRACE(""PING to %s:%u"",; 12778 conn->request_info.remote_addr,; 12779 conn->request_info.remote_port);; 12780 ret = mg_websocket_write(conn,; 12781 MG_WEBSOCKET_OPCODE_PING,; 12782 NULL,; 12783 0);; 12784 ; 12785 if (ret <= 0) {; 12786 /* Error: send failed */; 12787 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12788 break;; 12789 }; 12790 ping_count++;; 12791 }; 12792 }; 12793 /* Timeout: should retry */; 12794 /* TODO: get timeout def */; 12795 }; 12796 }; 12797 }; 12798 ; 12799 /* Leave data processing loop */; 12800 mg_set_thread_name(""worker"");; 12801 conn->in_websocket_handling = 0;; 12802 DEBU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:371138,ping,ping,371138,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['ping'],['ping']
Availability,"2736 if ((mop & 0xf) == MG_WEBSOCKET_OPCODE_CONNECTION_CLOSE) {; 12737 /* Opcode == 8, connection close */; 12738 DEBUG_TRACE(""Message requests to close connection from %s:%u"",; 12739 conn->request_info.remote_addr,; 12740 conn->request_info.remote_port);; 12741 break;; 12742 }; 12743 ; 12744 /* Not breaking the loop, process next websocket frame. */; 12745 } else {; 12746 /* Read from the socket into the next available location in the; 12747 * message queue. */; 12748 n = pull_inner(NULL,; 12749 conn,; 12750 conn->buf + conn->data_len,; 12751 conn->buf_size - conn->data_len,; 12752 timeout);; 12753 if (n <= -2) {; 12754 /* Error, no bytes read */; 12755 DEBUG_TRACE(""PULL from %s:%u failed"",; 12756 conn->request_info.remote_addr,; 12757 conn->request_info.remote_port);; 12758 break;; 12759 }; 12760 if (n > 0) {; 12761 conn->data_len += n;; 12762 /* Reset open PING count */; 12763 ping_count = 0;; 12764 } else {; 12765 if (STOP_FLAG_IS_ZERO(&conn->phys_ctx->stop_flag); 12766 && (!conn->must_close)) {; 12767 if (ping_count > MG_MAX_UNANSWERED_PING) {; 12768 /* Stop sending PING */; 12769 DEBUG_TRACE(""Too many (%i) unanswered ping from %s:%u ""; 12770 ""- closing connection"",; 12771 ping_count,; 12772 conn->request_info.remote_addr,; 12773 conn->request_info.remote_port);; 12774 break;; 12775 }; 12776 if (enable_ping_pong) {; 12777 /* Send Websocket PING message */; 12778 DEBUG_TRACE(""PING to %s:%u"",; 12779 conn->request_info.remote_addr,; 12780 conn->request_info.remote_port);; 12781 ret = mg_websocket_write(conn,; 12782 MG_WEBSOCKET_OPCODE_PING,; 12783 NULL,; 12784 0);; 12785 ; 12786 if (ret <= 0) {; 12787 /* Error: send failed */; 12788 DEBUG_TRACE(""Send PING failed (%i)"", ret);; 12789 break;; 12790 }; 12791 ping_count++;; 12792 }; 12793 }; 12794 /* Timeout: should retry */; 12795 /* TODO: get timeout def */; 12796 }; 12797 }; 12798 }; 12799 ; 12800 /* Leave data processing loop */; 12801 mg_set_thread_name(""worker"");; 12802 conn->in_websocket_handling = 0;; 12803 DEBU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:371171,ping,ping,371171,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['ping'],['ping']
Availability,"2776 for (j=jfirst; j<=jlast; j++){; 2777 bin = GetBin(i,j);; 2778 buf[bin] = RetrieveBinContent(bin);; 2779 if (ebuf) ebuf[bin]=GetBinError(bin);; 2780 }; 2781 }; 2782 ; 2783 // Kernel tail sizes (kernel sizes must be odd for this to work!); 2784 Int_t x_push = (ksize_x-1)/2;; 2785 Int_t y_push = (ksize_y-1)/2;; 2786 ; 2787 // main work loop; 2788 for (i=ifirst; i<=ilast; i++){; 2789 for (j=jfirst; j<=jlast; j++) {; 2790 Double_t content = 0.0;; 2791 Double_t error = 0.0;; 2792 Double_t norm = 0.0;; 2793 ; 2794 for (Int_t n=0; n<ksize_x; n++) {; 2795 for (Int_t m=0; m<ksize_y; m++) {; 2796 Int_t xb = i+(n-x_push);; 2797 Int_t yb = j+(m-y_push);; 2798 if ( (xb >= 1) && (xb <= nx) && (yb >= 1) && (yb <= ny) ) {; 2799 bin = GetBin(xb,yb);; 2800 Double_t k = kernel[n*ksize_y +m];; 2801 //if ( (k != 0.0 ) && (buf[bin] != 0.0) ) { // General version probably does not want the second condition; 2802 if ( k != 0.0 ) {; 2803 norm += k;; 2804 content += k*buf[bin];; 2805 if (ebuf) error += k*k*ebuf[bin]*ebuf[bin];; 2806 }; 2807 }; 2808 }; 2809 }; 2810 ; 2811 if ( norm != 0.0 ) {; 2812 SetBinContent(i,j,content/norm);; 2813 if (ebuf) {; 2814 error /= (norm*norm);; 2815 SetBinError(i,j,sqrt(error));; 2816 }; 2817 }; 2818 }; 2819 }; 2820 fEntries = nentries;; 2821 ; 2822 delete [] buf;; 2823 delete [] ebuf;; 2824}; 2825 ; 2826 ; 2827////////////////////////////////////////////////////////////////////////////////; 2828/// Stream an object of class TH2.; 2829 ; 2830void TH2::Streamer(TBuffer &R__b); 2831{; 2832 if (R__b.IsReading()) {; 2833 UInt_t R__s, R__c;; 2834 Version_t R__v = R__b.ReadVersion(&R__s, &R__c);; 2835 if (R__v > 2) {; 2836 R__b.ReadClassBuffer(TH2::Class(), this, R__v, R__s, R__c);; 2837 return;; 2838 }; 2839 //====process old versions before automatic schema evolution; 2840 TH1::Streamer(R__b);; 2841 R__b >> fScalefactor;; 2842 R__b >> fTsumwy;; 2843 R__b >> fTsumwy2;; 2844 R__b >> fTsumwxy;; 2845 //====end of old versions; 2846 ; 2847 } else {; 2848 R__b.Write",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8cxx_source.html:114509,error,error,114509,doc/master/TH2_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH2_8cxx_source.html,1,['error'],['error']
Availability,"278 latex.DrawLatex(.3,.6,""K^{*0}"");; 279 latex.DrawLatex(.2,.5,longstring);; 280 ; 281 latex.SetTextAlign(11); //default bottom alignment; 282 latex.DrawLatex(.2,.4,""K_{S}"");; 283 latex.DrawLatex(.3,.4,""K^{*0}"");; 284 latex.DrawLatex(.2,.3,longstring);; 285 ; 286 latex.SetTextAlign(10); //special bottom alignment; 287 latex.DrawLatex(.2,.2,""K_{S}"");; 288 latex.DrawLatex(.3,.2,""K^{*0}"");; 289 latex.DrawLatex(.2,.1,longstring);; 290 ; 291 latex.SetTextAlign(12);; 292 latex.SetTextFont(72);; 293 latex.DrawLatex(.1,.80,""13"");; 294 latex.DrawLatex(.1,.55,""12"");; 295 latex.DrawLatex(.1,.35,""11"");; 296 latex.DrawLatex(.1,.18,""10"");; 297 return Tlva;; 298}; 299End_Macro; 300 ; 301 ; 302\anchor L11; 303## Character Adjustment; 304 ; 305The two commands `#kern` and `#lower` enable a better control; 306over character placement. The command `#kern[(Float_t)dx]{text}` moves; 307the output string horizontally by the fraction `dx` of its length.; 308Similarly, `#lower[(Float_t)dy]{text}` shifts the text up or down by; 309the fraction `dy` of its height.; 310 ; 311Examples:; 312 ; 313Begin_Macro; 314{; 315 TCanvas *cl = new TCanvas(""cl"",""cl"",10,10,900,300);; 316 TLatex Tl; Tl.SetTextFont(43); Tl.SetTextSize(20);; 317 TLatex Tt; Tt.SetTextFont(43); Tt.SetTextSize(16);; 318 Double_t dy = 1./7.;; 319 Tl.DrawLatex(.5, dy, ""Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g}"");; 320 Tt.DrawText(.01, 2*dy, ""Positive k#kern[0.3]{e}#kern[0.3]{r}#kern[0.3]{n}#kern[0.3]{i}#kern[0.3]{n}#kern[0.3]{g} :"");; 321 Tl.DrawLatex(.5, 3*dy, ""Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g}"");; 322 Tt.DrawText(.01, 4*dy, ""Negative k#kern[-0.3]{e}#kern[-0.3]{r}#kern[-0.3]{n}#kern[-0.3]{i}#kern[-0.3]{n}#kern[-0.3]{g} :"");; 323 Tl.DrawLatex(.5, 5*dy, ""Vertical a#lower[0.2]{d}#lower[0.4]{j}#lower[0.1]{u}#lower[-0.1]{s}#lower[-0.3]{t}#lower[-0.4]{m}#lower[-0.2]{e}#lower[0.1]{n}t"");; 324 Tt.DrawText(.01, 6*dy, ""Vertical a#low",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TLatex_8cxx_source.html:11170,down,down,11170,doc/master/TLatex_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TLatex_8cxx_source.html,1,['down'],['down']
Availability,28 0; : 611 | 105.742 70.7984 0.0200525 0.00175765 43728.1 1; : 612 Minimum Test error found - save the configuration ; : 612 | 104.268 69.338 0.0202166 0.00183521 43522.3 0; : 613 Minimum Test error found - save the configuration ; : 613 | 102.858 68.9009 0.0202348 0.00182917 43464.9 0; : 614 Minimum Test error found - save the configuration ; : 614 | 101.983 68.108 0.0201318 0.00182452 43698.5 0; : 615 Minimum Test error found - save the configuration ; : 615 | 100.329 67.3723 0.0201441 0.00182383 43667.6 0; : 616 Minimum Test error found - save the configuration ; : 616 | 99.0728 66.9343 0.0201375 0.00182665 43689.9 0; : 617 Minimum Test error found - save the configuration ; : 617 | 97.8374 65.9501 0.0201618 0.00184005 43664 0; : 618 Minimum Test error found - save the configuration ; : 618 | 96.3739 65.107 0.0201565 0.0018204 43629.8 0; : 619 Minimum Test error found - save the configuration ; : 619 | 95.4431 64.9258 0.0202106 0.00183339 43532.2 0; : 620 Minimum Test error found - save the configuration ; : 620 | 94.1902 64.0162 0.020412 0.0018551 43110.6 0; : 621 Minimum Test error found - save the configuration ; : 621 | 92.9103 63.3038 0.0201905 0.00182603 43562.4 0; : 622 Minimum Test error found - save the configuration ; : 622 | 91.6075 63.2578 0.0201995 0.00184553 43587.4 0; : 623 Minimum Test error found - save the configuration ; : 623 | 90.7693 62.0703 0.0202228 0.00181118 43450.9 0; : 624 Minimum Test error found - save the configuration ; : 624 | 89.2125 61.1087 0.0202046 0.00181706 43507.7 0; : 625 | 88.1287 61.343 0.0200847 0.00175821 43652.7 1; : 626 Minimum Test error found - save the configuration ; : 626 | 87.0203 60.0927 0.0202246 0.00182742 43485 0; : 627 | 86.1022 60.6165 0.020286 0.00178227 43234.5 1; : 628 Minimum Test error found - save the configuration ; : 628 | 84.7933 59.0719 0.0201769 0.00183209 43609.1 0; : 629 Minimum Test error found - save the configuration ; : 629 | 83.7285 58.2513 0.0204361 0.0018731 43096.5 0; : 630 Minimum T,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:81007,error,error,81007,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"280 return nullptr;; 4281 TClass *cl = TClass::GetClass(h->GetClass());; 4282 if (cl && cl->InheritsFrom(""TNetFile"")); 4283 f = (TFile*) h->ExecPlugin(5, name.Data(), option, ftitle, compress, netopt);; 4284 else; 4285 f = (TFile*) h->ExecPlugin(4, name.Data(), option, ftitle, compress);; 4286 } else {; 4287 // Just try to open it locally but via TFile::Open, so that we pick-up the correct; 4288 // plug-in in the case file name contains information about a special backend (e.g.); 4289 if (strcmp(name, urlname.GetFileAndOptions()) != 0); 4290 f = TFile::Open(urlname.GetFileAndOptions(), option, ftitle, compress);; 4291 }; 4292 }; 4293 }; 4294 ; 4295 if (f && f->IsZombie()) {; 4296 TString newUrl = f->GetNewUrl();; 4297 delete f;; 4298 if( newUrl.Length() && (newUrl != name) && gEnv->GetValue(""TFile.CrossProtocolRedirects"", 1) ); 4299 f = TFile::Open( newUrl, option, ftitle, compress );; 4300 else; 4301 f = nullptr;; 4302 }; 4303 }; 4304 ; 4305 if (rediroutput) {; 4306 // Restore output to stdout; 4307 gSystem->RedirectOutput(0, """", &rh);; 4308 // If we failed print error messages; 4309 if (!f); 4310 gSystem->ShowOutput(&rh);; 4311 // Remove the file; 4312 gSystem->Unlink(rh.fFile);; 4313 }; 4314 ; 4315 // if the file is writable, non local, and not opened in raw mode; 4316 // we create a default write cache of 512 KBytes; 4317 if (type != kLocal && type != kFile &&; 4318 f && f->IsWritable() && !f->IsRaw()) {; 4319 new TFileCacheWrite(f, 1);; 4320 }; 4321 ; 4322 return f;; 4323}; 4324 ; 4325////////////////////////////////////////////////////////////////////////////////; 4326/// Submit an asynchronous open request.; 4327 ; 4328/// See TFile::Open(const char *, ...) for an; 4329/// explanation of the arguments. A handler is returned which is to be passed; 4330/// to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; 4331/// the file is open.; 4332/// This call never blocks and it is provided to allow parallel submission; 4333/// of file opening operati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:157564,error,error,157564,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['error'],['error']
Availability,"2::FCNBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameters&, const ROOT::Minuit2::MnUserCovariance&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::MnFcn&, const ROOT::Minuit2::GradientCalculator&, const ROOT::Minuit2::MinimumSeed&, const ROOT::Minuit2::MnStrategy&, unsigned int, double) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const vector<double>&, unsigned int, const vector<double>&, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.10000000000000001) const; ROOT::Minuit2::ModularFunctionMinimizerModularFunctionMinimizer(); ROOT::Minuit2::ModularFunctionMinimizerModularFunctionMinimizer(const ROOT::Minuit2::ModularFunctionMinimizer&); ROOT::Minuit2::ModularFunctionMinimizer&operator=(const ROOT::Minuit2::ModularFunctionMinimizer&); virtual const ROOT::Minuit2::MinimumSeedGenerator&SeedGenerator() const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~ModularFunctionMinimizer(); {}. FunctionMinimum Minimize(const FCNBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1); inherited interface. FunctionMinimum Minimize(const FCNGradientBase&, const std::vector<double>&, const std::vector<double>&, unsigned int stra=1, unsigned int maxfcn = 0, double toler = 0.1). FunctionMinimum",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html:3611,toler,toler,3611,root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,https://root.cern,https://root.cern/root/html602/ROOT__Minuit2__ModularFunctionMinimizer.html,4,['toler'],['toler']
Availability,"2; TGraph2DErrors TGraph2DErrors, TH2; TH2 TGraph2DErrors, TH2; TH3 TH3. Double_t* GetCovarianceMatrix() const; Returns covariance matrix. void GetCovarianceMatrix(TMatrixD& matr); Returns covariance matrix. void GetDesignMatrix(TMatrixD& matr); Returns the internal design matrix. void GetErrors(TVectorD& vpar); Returns parameter errors. void GetParameters(TVectorD& vpar); Returns parameter values. Int_t GetParameter(Int_t ipar, char* name, Double_t& value, Double_t& , Double_t& , Double_t& ) const; Returns the value and the name of the parameter #ipar; NB: In the calling function he argument name must be set large enough. Double_t GetParError(Int_t ipar) const; Returns the error of parameter #ipar. const char * GetParName(Int_t ipar) const; Returns name of parameter #ipar. Double_t GetParTValue(Int_t ipar); Returns the t-value for parameter #ipar. Double_t GetParSignificance(Int_t ipar); Returns the significance of parameter #ipar. void GetFitSample(TBits& bits); For robust lts fitting, returns the sample, on which the best fit was based. Int_t Merge(TCollection* list); Merge objects in list. void SetBasisFunctions(TObjArray* functions); set the basis functions in case the fitting function is not; set directly; The TLinearFitter will manage and delete the functions contained in the list. void SetDim(Int_t n); set the number of dimensions. void SetFormula(const char* formula); Additive parts should be separated by ""++"".; Examples (ai are parameters to fit):; 1.fitting function: a0*x0 + a1*x1 + a2*x2; input formula ""x[0]++x[1]++x[2]""; 2.TMath functions can be used:; fitting function: a0*TMath::Gaus(x, 0, 1) + a1*y; input formula: ""TMath::Gaus(x, 0, 1)++y""; fills the array of functions. void SetFormula(TFormula* function); Set the fitting function. Bool_t UpdateMatrix(); Update the design matrix after the formula has been changed. Int_t ExecuteCommand(const char* command, Double_t* args, Int_t nargs); To use in TGraph::Fit and TH1::Fit(). void PrintResults(Int_t level,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TLinearFitter.html:25639,robust,robust,25639,root/html528/TLinearFitter.html,https://root.cern,https://root.cern/root/html528/TLinearFitter.html,6,['robust'],['robust']
Availability,"2; TGraphDelaunay::fXNDouble_t * fXN! fGraph2D vectors normalized of size fNpointsDefinition TGraphDelaunay.h:45; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TObject::Warningvirtual void Warning(const char *method, const char *msgfmt,...) constIssue warning message.Definition TObject.cxx:979; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; bool; double; int; Interpolate#define Interpolate(a, x, b, y)Definition geom.c:179; yDouble_t y[n]Definition legend1.C:17; c1return c1Definition legend1.C:41; xDouble_t x[n]Definition legend1.C:17; nconst Int_t nDefinition legend1.C:16; f1TF1 * f1Definition legend1.C:11; c2return c2Definition legend2.C:14; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::IsInsideBool_t IsInside(T xp, T yp, Int_t np, T *x, T *y)Function which returns kTRUE if point xp,yp lies inside the polygon defined by the np points in array...Definition TMath.h:1233; TMath::ATan2Double_t ATan2(Double_t y, Double_t x)Returns the principal value of the arc tangent of y/x, expressed in radians.Definition TMath.h:646; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::Sortvoid Sort(Index n, const Element *a, Index *index, Bool_t down=kTRUE)Sort the n elements of the array a of generic templated type Element.Definition TMathBase.h:431; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; TMath::TwoPiconstexpr Double_t TwoPi()Definition TMath.h:44; v@ vDefinition rootcling_impl.cxx:3699; mTMarker mDefinition textangle.C:8; lTLine lDefinition textangle.C:4; t1auto * t1Definition textangle.C:20. histhistsrcTGraphDelaunay.cxx. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:40:33 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:41094,down,down,41094,doc/master/TGraphDelaunay_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html,1,['down'],['down']
Availability,"2; kUShort_t@ kUShort_tDefinition TDataType.h:29; kDouble_t@ kDouble_tDefinition TDataType.h:31; kCharStar@ kCharStarDefinition TDataType.h:34; kChar_t@ kChar_tDefinition TDataType.h:29; kUChar_t@ kUChar_tDefinition TDataType.h:29; kUInt_t@ kUInt_tDefinition TDataType.h:30; kFloat16_t@ kFloat16_tDefinition TDataType.h:33; kOther_t@ kOther_tDefinition TDataType.h:32; operator!=Bool_t operator!=(const TDatime &d1, const TDatime &d2)Definition TDatime.h:104; kIsUnionMember@ kIsUnionMemberDefinition TDictionary.h:74; kIsAbstract@ kIsAbstractDefinition TDictionary.h:71; kIsStatic@ kIsStaticDefinition TDictionary.h:80; kMaxLenconst Int_t kMaxLenDefinition TDirectory.cxx:34; gDirectory#define gDirectoryDefinition TDirectory.h:384; TEnum.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; kErrorconstexpr Int_t kErrorDefinition TError.h:47; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; gErrorIgnoreLevelInt_t gErrorIgnoreLevelError handling routines.Definition TError.cxx:31; TFile.h; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; cindexOption_t Option_t cindexDefinition TGWin32VirtualXProxy.cxx:50; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html:237953,error,error,237953,doc/master/TStreamerInfo_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfo_8cxx_source.html,1,['error'],['error']
Availability,"2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.94999999999999996, bool nor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitResult.html:8504,error,error,8504,root/html602/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitResult.html,4,['error'],['error']
Availability,"2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). bool HasMinosError(unsigned int i) const; query if parameter i has the Minos error. double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Fit__FitResult.html:8106,error,error,8106,root/html530/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html530/ROOT__Fit__FitResult.html,5,['error'],['error']
Availability,"2; }. unsigned int Ndf() const; Number of degree of freedom. { return fNdf; }. double Prob() const; p value of the fit (chi2 probability). const std::vector<double> & Errors() const; parameter errors (return st::vector). { return fErrors; }. const double * GetErrors() const; parameter errors (return const pointer). { return (fErrors.empty()) ? 0 : &fErrors.front(); }. const std::vector<double> & Parameters() const; parameter values (return std::vector). { return fParams; }. const double * GetParams() const; parameter values (return const pointer). { return &fParams.front(); }. double Value(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Parameter(unsigned int i) const; parameter value by index. { return fParams[i]; }. double Error(unsigned int i) const; parameter error by index; (NOTE: this due to conflict with TObject::Error cannot used in derived class which; inherits from TObject. Use instead ParError (or Errors()[i] ). double ParError(unsigned int i) const; parameter error by index. std::string ParName(unsigned int i) const; name of the parameter. void SetMinosError(unsigned int i, double elow, double eup); set the Minos errors for parameter i (called by the Fitter class when running Minos). double LowerError(unsigned int i) const; lower Minos error. If Minos has not run for parameter i return the parabolic error. double UpperError(unsigned int i) const; upper Minos error. If Minos has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetCovarianceMatrix(TMatrixTSym<double>& mat) const; fill covariance matrix elements using a generic matrix class implementing operator(i,j); the matrix must be previously allocates with right size (npar * npar). void GetCorrelationMatri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Fit__FitResult.html:7870,error,error,7870,root/html528/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html528/ROOT__Fit__FitResult.html,1,['error'],['error']
Availability,"2; » ROOT::Minuit2::FumiliMinimizer. class ROOT::Minuit2::FumiliMinimizer: public ROOT::Minuit2::ModularFunctionMinimizer. Instantiates the seed generator and Minimum builder for the; Fumili minimization method. Produces the Minimum via the; Minimize methods inherited from ModularFunctionMinimizer. @author Andras Zsenei and Lorenzo Moneta, Creation date: 28 Sep 2004. @ingroup Minuit. Function Members (Methods); public:. virtual~FumiliMinimizer(); virtual const ROOT::Minuit2::FumiliBuilder&Builder() const; virtual ROOT::Minuit2::FumiliBuilder&Builder(); ROOT::Minuit2::FumiliMinimizerFumiliMinimizer(); ROOT::Minuit2::FumiliMinimizerFumiliMinimizer(const ROOT::Minuit2::FumiliMinimizer&); virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase&, const ROOT::Minuit2::MnUserParameterState&, const ROOT::Minuit2::MnStrategy&, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const ROOT::Minuit2::MnUserParameters& par, const ROOT::Minuit2::MnStrategy& stra, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual ROOT::Minuit2::FunctionMinimumMinimize(const ROOT::Minuit2::FCNGradientBase& fcn, const vector<double>& par, const vector<double>& err, unsigned int stra = 1, unsigned int maxfcn = 0, double toler = 0.1) const; virtual RO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__FumiliMinimizer.html:1337,toler,toler,1337,root/html534/ROOT__Minuit2__FumiliMinimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__FumiliMinimizer.html,2,['toler'],['toler']
Availability,"2D ; (; Int_t ; n). Graph2D constructor. ; The arrays fX, fY and fZ should be filled via calls to SetPoint ; Definition at line 382 of file TGraph2D.cxx. ◆ TGraph2D() [3/9]. TGraph2D::TGraph2D ; (; Int_t ; n, . Int_t * ; x, . Int_t * ; y, . Int_t * ; z . ). Graph2D constructor with three vectors of ints as input. ; Definition at line 264 of file TGraph2D.cxx. ◆ TGraph2D() [4/9]. TGraph2D::TGraph2D ; (; Int_t ; n, . Float_t * ; x, . Float_t * ; y, . Float_t * ; z . ). Graph2D constructor with three vectors of floats as input. ; Definition at line 281 of file TGraph2D.cxx. ◆ TGraph2D() [5/9]. TGraph2D::TGraph2D ; (; Int_t ; n, . Double_t * ; x, . Double_t * ; y, . Double_t * ; z . ). Graph2D constructor with three vectors of doubles as input. ; Definition at line 298 of file TGraph2D.cxx. ◆ TGraph2D() [6/9]. TGraph2D::TGraph2D ; (; TH2 * ; h2). Graph2D constructor with a TH2 (h2) as input. ; Only the h2's bins within the X and Y axis ranges are used. Empty bins, recognized when both content and errors are zero, are excluded. ; Definition at line 317 of file TGraph2D.cxx. ◆ TGraph2D() [7/9]. TGraph2D::TGraph2D ; (; const char * ; name, . const char * ; title, . Int_t ; n, . Double_t * ; x, . Double_t * ; y, . Double_t * ; z . ). Graph2D constructor with name, title and three vectors of doubles as input. ; name : name of 2D graph (avoid blanks) title : 2D graph title if title is of the form ""stringt;stringx;stringy;stringz"" the 2D graph title is set to stringt, the x axis title to stringx, the y axis title to stringy,etc ; Definition at line 363 of file TGraph2D.cxx. ◆ TGraph2D() [8/9]. TGraph2D::TGraph2D ; (; const char * ; filename, . const char * ; format = ""%lg %lg %lg"", . Option_t * ; option = """" . ). Graph2D constructor reading input from filename filename is assumed to contain at least three columns of numbers. ; For files separated by a specific delimiter different from ' ' and '\t' (e.g. ';' in csv files) you can avoid using %*s to bypass this delimiter by expl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraph2D.html:36154,error,errors,36154,doc/master/classTGraph2D.html,https://root.cern,https://root.cern/doc/master/classTGraph2D.html,1,['error'],['errors']
Availability,"2D, and TProfile3D.; Definition at line 6111 of file TH1.cxx. ◆ Multiply() [2/3]. Bool_t TH1::Multiply ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1, . Option_t * ; option = """" . ). virtual . Replace contents of this histogram by multiplication of h1 by h2. ; this = (c1*h1)*(c2*h2); If errors of this are available (TH1::Sumw2), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply; The function return kFALSE if the Multiply operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 6160 of file TH1.cxx. ◆ Multiply() [3/3]. Bool_t TH1::Multiply ; (; TF1 * ; f1, . Double_t ; c1 = 1 . ). virtual . Performs the operation: ; this = this*c1*f1; If errors are defined (see TH1::Sumw2), errors are also recalculated.; Only bins inside the function range are recomputed. IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply; The function return kFALSE if the Multiply operation failed ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 6049 of file TH1.cxx. ◆ operator=(). TH1 & TH1::operator= ; (; const TH1 & ; ). privatedelete . ◆ Paint(). void TH1::Paint ; (; Option_t * ; option = """"). overridevirtual . Control routine to paint any kind of histograms. ; This function is automatically called by TCanvas::Update. (see TH1::Draw for the list of options) ; Reimplemented from TObject.; Definition at line 6206 of file TH1.cxx. ◆ Print(). void TH1::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print some global quantities for this histogram. ; Parameters. [",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:192256,error,errors,192256,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,2,['error'],['errors']
Availability,"2D::fNpyNumber of bins along Y in fHistogram; TVirtualHistPainter*TGraph2D::fPainter!pointer to histogram painter; Int_tTGraph2D::fSize!Real size of fX, fY and fZ; TStringTNamed::fTitleobject title; Double_t*TGraph2D::fX[fNpoints]; Double_t*TGraph2D::fY[fNpoints] Data set to be plotted; Double_t*TGraph2D::fZ[fNpoints]; Double_tTGraph2D::fZoutfHistogram bin height for points lying outside the interpolated area. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGraph2DErrors(); TGraph2DErrors default constructor. TGraph2DErrors(Int_t n); TGraph2DErrors normal constructor; the arrays are preset to zero. TGraph2DErrors(Int_t n, Double_t* x, Double_t* y, Double_t* z, Double_t* ex = 0, Double_t* ey = 0, Double_t* ez = 0, Option_t* option = """"); TGraph2DErrors constructor with doubles vectors as input. ~TGraph2DErrors(); TGraph2DErrors destructor. Double_t GetErrorX(Int_t bin) const; This function is called by Graph2DFitChisquare.; It returns the error along X at point i. Double_t GetErrorY(Int_t bin) const; This function is called by Graph2DFitChisquare.; It returns the error along X at point i. Double_t GetErrorZ(Int_t bin) const; This function is called by Graph2DFitChisquare.; It returns the error along X at point i. Double_t GetXmaxE() const; Returns the X maximum with errors. Double_t GetXminE() const; Returns the X minimum with errors. Double_t GetYmaxE() const; Returns the Y maximum with errors. Double_t GetYminE() const; Returns the Y minimum with errors. Double_t GetZmaxE() const; Returns the Z maximum with errors. Double_t GetZminE() const; Returns the Z minimum with errors. void Set(Int_t n); Set number of points in the 2D graph.; Existing coordinates are preserved.; New coordinates above fNpoints are preset to 0. void SetPoint(Int_t i, Double_t x, Double_t y, Double_t z); Set x, y and z values for point number i. void SetPointError(Int_t i, Double_t ex, Double_t ey, Double_t ez); Set ex, ey and ez values for point numb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGraph2DErrors.html:12856,error,error,12856,root/html530/TGraph2DErrors.html,https://root.cern,https://root.cern/root/html530/TGraph2DErrors.html,3,['error'],['error']
Availability,"2Double_t TGraphAsymmErrors::GetErrorXlow(Int_t i) const; 1163{; 1164 if (i<0 || i>fNpoints) return -1;; 1165 if (fEXlow) return fEXlow[i];; 1166 return -1;; 1167}; 1168 ; 1169 ; 1170////////////////////////////////////////////////////////////////////////////////; 1171/// Get high error on Y.; 1172 ; 1173Double_t TGraphAsymmErrors::GetErrorYhigh(Int_t i) const; 1174{; 1175 if (i<0 || i>fNpoints) return -1;; 1176 if (fEYhigh) return fEYhigh[i];; 1177 return -1;; 1178}; 1179 ; 1180 ; 1181////////////////////////////////////////////////////////////////////////////////; 1182/// Get low error on Y.; 1183 ; 1184Double_t TGraphAsymmErrors::GetErrorYlow(Int_t i) const; 1185{; 1186 if (i<0 || i>fNpoints) return -1;; 1187 if (fEYlow) return fEYlow[i];; 1188 return -1;; 1189}; 1190 ; 1191 ; 1192////////////////////////////////////////////////////////////////////////////////; 1193/// Adds all graphs with asymmetric errors from the collection to this graph.; 1194/// Returns the total number of points in the result or -1 in case of an error.; 1195 ; 1196Int_t TGraphAsymmErrors::Merge(TCollection* li); 1197{; 1198 TIter next(li);; 1199 while (TObject* o = next()) {; 1200 TGraph *g = dynamic_cast<TGraph*>(o);; 1201 if (!g) {; 1202 Error(""Merge"",; 1203 ""Cannot merge - an object which doesn't inherit from TGraph found in the list"");; 1204 return -1;; 1205 }; 1206 int n0 = GetN();; 1207 int n1 = n0+g->GetN();; 1208 Set(n1);; 1209 Double_t * x = g->GetX();; 1210 Double_t * y = g->GetY();; 1211 Double_t * exlow = g->GetEXlow();; 1212 Double_t * exhigh = g->GetEXhigh();; 1213 Double_t * eylow = g->GetEYlow();; 1214 Double_t * eyhigh = g->GetEYhigh();; 1215 for (Int_t i = 0 ; i < g->GetN(); i++) {; 1216 SetPoint(n0+i, x[i], y[i]);; 1217 if (exlow) fEXlow[n0+i] = exlow[i];; 1218 if (exhigh) fEXhigh[n0+i] = exhigh[i];; 1219 if (eylow) fEYlow[n0+i] = eylow[i];; 1220 if (eyhigh) fEYhigh[n0+i] = eyhigh[i];; 1221 }; 1222 }; 1223 return GetN();; 1224}; 1225 ; 1226/////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html:41315,error,error,41315,doc/master/TGraphAsymmErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphAsymmErrors_8cxx_source.html,1,['error'],['error']
Availability,"2PolyBin(TObject* poly, Int_t bin_number); virtual~TH2PolyBin(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); voidClearContent(); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFill(Double_t w); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tGetArea(); Int_tGetBinNumber() const; Bool_tGetChanged() const; Double_tGetContent() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; TObject*GetPolygon() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; Double_tGetXMax(); Double_tGetXMin(); Double_tGetYMax(); Double_tGetYMin()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH2PolyBin.html:1390,error,error,1390,root/html528/TH2PolyBin.html,https://root.cern,https://root.cern/root/html528/TH2PolyBin.html,6,['error'],['error']
Availability,"2VirtualXProxy, TGX11, and TGCocoa.; Definition at line 2300 of file TVirtualX.cxx. ◆ QueryColor(). void TVirtualX::QueryColor ; (; Colormap_t ; cmap, . ColorStruct_t & ; color . ). virtual . Returns the current RGB value for the pixel in the ""color"" structure. ; The color components are set to default.; Parameters. [in]cmapthe colormap ; [in]colorspecifies and returns the RGB values for the pixel specified in the structure . Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 128 of file TVirtualX.cxx. ◆ QueryPointer() [1/2]. void TVirtualX::QueryPointer ; (; Int_t & ; ix, . Int_t & ; iy . ). virtual . Returns the pointer position. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 598 of file TVirtualX.cxx. ◆ QueryPointer() [2/2]. void TVirtualX::QueryPointer ; (; Window_t ; id, . Window_t & ; rootw, . Window_t & ; childw, . Int_t & ; root_x, . Int_t & ; root_y, . Int_t & ; win_x, . Int_t & ; win_y, . UInt_t & ; mask . ). virtual . Returns the root window the pointer is logically on and the pointer coordinates relative to the root window's origin. ; Parameters. [in]idspecifies the window ; [in]rootwthe root window that the pointer is in ; [in]childwthe child window that the pointer is located in, if any ; [in]root_x,root_ythe pointer coordinates relative to the root window's origin ; [in]win_x,win_ythe pointer coordinates relative to the specified window ""id"" ; [in]maskthe current state of the modifier keys and pointer buttons . Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 2087 of file TVirtualX.cxx. ◆ RaiseWindow(). void TVirtualX::RaiseWindow ; (; Window_t ; id). virtual . Raises the specified window to the top of the stack so that no sibling window obscures it. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1052 of file TVirtualX.cxx. ◆ ReadGIF(). Pixmap_t TVirtualX::ReadGIF ; (; Int_t ; x0, . Int_t ; y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:110253,mask,mask,110253,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['mask'],['mask']
Availability,"2] - Range not considered when computing integral of RooParamHistFunc; [#7547] - [DF] Crash in lazy jitted Snapshot; [#7010] - fifo in $CWD causes TCanvas to hang on macOS; [#7676] - hadd reverses order of object cycles; [#6343] - Problem with using namespace std in generated dictionary files; [#7657] - New dictionary-related crash in 6.24.00-patches; [#7718] - PyROOT in root 6.24 branch hangs while loading CMSSW library; [#7090] - Apple M1: bug in jitting argument of type short; [#6802] - Allow to pass Bearer token authentication header to Davix client; [#7345] - Issue building built-in libafterimage; [#6812] - root REPL problem with unsigned num assigned to a not declared item; [#7292] - compilation fails on xrootd: _STAT_VER was not declared; [#7481] - String parse error in RooSimPdfBuilder.cxx; [#7433] - Segmentation fault after quitting Cling in CUDA mode; [#7239] - [RF] Use integral of PDF curves for pull plots and residuals; [#7390] - Must not forward declare template specialization with enumerator as template arg; [#7454] - [RF][Docs] Breaking changes of batch computation interface not documented in release notes; [#7558] - AfterImage compilation broken with binutils 2.36; [#7507] - [tree] Possible error in TLeaf::GetLeafCounter; [#7361] - RooFit backend library: force to specific architecture; [#7362] - Incremental build problems; [#7319] - [Hist] Wrong computation in TH3::GetCovariance for diagonal elements; [#7206] - Unable to build with builtin_cling=OFF for LLVM 9; [#7157] - RooFFTConvPdf doesn’t work with RooProdPdf; [#7076] - RNTuple, parallel unzip tear down race condition; [#7021] - cling depends on exact macOS SDK headers; [#6953] - Missing documentation for ROOT.RDF.MakeNumpyDataFrame; [#6421] - Proposal to unify logging in Minuit2; [#7302] - TGraph copy constructor error; [#7212] - TMathText does not display with high value coordinates; [#6997] - Fill attribute is not fully reflected in THStack; [#6360] - [Docs] Missing figures in RDF tutorials 10",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:45551,fault,fault,45551,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['fault'],['fault']
Availability,"2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff . ); const. risk assessment ; Definition at line 314 of file RuleFitParams.cxx. ◆ Risk() [2/2]. Double_t TMVA::RuleFitParams::Risk ; (; UInt_t ; ind1, . UInt_t ; ind2, . Double_t ; neff, . UInt_t ; itau . ); const. risk assessment for tau model <itau> ; Definition at line 334 of file RuleFitParams.cxx. ◆ RiskPath(). Double_t TMVA::RuleFitParams::RiskPath ; (; ); const. inline . Definition at line 108 of file RuleFitParams.h. ◆ RiskPerf() [1/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; ); const. inline . Definition at line 109 of file RuleFitParams.h. ◆ RiskPerf() [2/2]. Double_t TMVA::RuleFitParams::RiskPerf ; (; UInt_t ; itau); const. inline . Definition at line 110 of file RuleFitParams.h. ◆ RiskPerfTst(). UInt_t TMVA::RuleFitParams::RiskPerfTst ; (; ). Estimates the error rate with the current set of parameters. ; using the <Perf> subsample. Return the tau index giving the lowest error ; Definition at line 1201 of file RuleFitParams.cxx. ◆ SetGDErrScale(). void TMVA::RuleFitParams::SetGDErrScale ; (; Double_t ; s). inline . Definition at line 85 of file RuleFitParams.h. ◆ SetGDNPathSteps(). void TMVA::RuleFitParams::SetGDNPathSteps ; (; Int_t ; np). inline . Definition at line 65 of file RuleFitParams.h. ◆ SetGDPathStep(). void TMVA::RuleFitParams::SetGDPathStep ; (; Double_t ; s). inline . Definition at line 68 of file RuleFitParams.h. ◆ SetGDTau(). void TMVA::RuleFitParams::SetGDTau ; (; Double_t ; t). inline . Definition at line 82 of file RuleFitParams.h. ◆ SetGDTauPrec(). void TMVA::RuleFitParams::SetGDTauPrec ; (; Double_t ; p). inline . Definition at line 86 of file RuleFitParams.h. ◆ SetGDTauRange(). void TMVA::RuleFitParams::SetGDTauRange ; (; Double_t ; t0, . Double_t ; t1 . ). inline . Definition at line 71 of file RuleFitParams.h. ◆ SetGDTauScan(). void TMVA::RuleFitParams::SetGDTauScan ; (; UInt_t ; n). inline . Definition at line 79 of file RuleFitParams",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html:17454,error,error,17454,doc/master/classTMVA_1_1RuleFitParams.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1RuleFitParams.html,1,['error'],['error']
Availability,2_gamma_bin_21=7.28945 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=7.28945 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=7.28945 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:29057,error,error,29057,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=7.28945 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=7.28945 p_ph_sig2_gamma_bin_3=1 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back out of this region. Error log follows.; Parameter values: Abkg=1 Asig=1 p_ph_sig2_gamma_bin_0=1 p_ph_sig2_gamma_bin_1=1 p_ph_sig2_gamma_bin_10=1 p_ph_sig2_gamma_bin_11=1 p_ph_sig2_gamma_bin_12=1 p_ph_sig2_gamma_bin_13=1 p_ph_sig2_gamma_bin_14=1 p_ph_sig2_gamma_bin_15=1 p_ph_sig2_gamma_bin_16=1 p_ph_sig2_gamma_bin_17=1 p_ph_sig2_gamma_bin_18=1 p_ph_sig2_gamma_bin_19=1 p_ph_sig2_gamma_bin_2=1 p_ph_sig2_gamma_bin_20=1 p_ph_sig2_gamma_bin_21=1 p_ph_sig2_gamma_bin_22=1 p_ph_sig2_gamma_bin_23=1 p_ph_sig2_gamma_bin_24=1 p_ph_sig2_gamma_bin_3=7.28945 p_ph_sig2_gamma_bin_4=1 p_ph_sig2_gamma_bin_5=1 p_ph_sig2_gamma_bin_6=1 p_ph_sig2_gamma_bin_7=1 p_ph_sig2_gamma_bin_8=1 p_ph_sig2_gamma_bin_9=1; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (10415.9) to force MIGRAD to back ou,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html:30691,error,error,30691,doc/master/rf709__BarlowBeeston_8C.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8C.html,2,['error'],['error']
Availability,"2arr, const Double_t* dvalarr, const Roo2DMomentMorphFunction::Setting& setting = Linear, const Bool_t& verbose = false); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; voidsetMode(const Roo2DMomentMorphFunction::Setting& setting); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DMomentMorphFunction.html:24432,Error,ErrorLoggingMode,24432,root/html602/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo2DMomentMorphFunction.html,2,['Error'],['ErrorLoggingMode']
Availability,"2f"", h1->GetMean(), h1->GetRMS()), ""l"");; l3->Draw();; ; c1->cd(4);; hChisquared->Draw(""HIST"");; }; ; int main() {; TestBinomial();; }; BinData.h; HFitInterface.h; IntegratorOptions.h; mainint main()Definition Prototype.cxx:12; h#define h(i)Definition RSha256.hxx:106; kRed@ kRedDefinition Rtypes.h:66; kBlue@ kBlueDefinition Rtypes.h:66; TBinomialEfficiencyFitter.h; TCanvas.h; TF1.h; TFitResult.h; plotwinID h TVirtualViewer3D TVirtualGLPainter char TVirtualGLPainter plotDefinition TGWin32VirtualGLProxy.cxx:53; widthOption_t Option_t widthDefinition TGWin32VirtualXProxy.cxx:56; TGraphErrors.h; TH1.h; xminfloat xminDefinition THbookFile.cxx:95; xmaxfloat xmaxDefinition THbookFile.cxx:95; TLegend.h; TObjArray.h; TPaveStats.h; TRandom3.h; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TStyle.h; gStyleR__EXTERN TStyle * gStyleDefinition TStyle.h:436; TVirtualFitter.h; ROOT::Fit::BinDataClass describing the binned data sets : vectors of x coordinates, y values and optionally error on y ...Definition BinData.h:52; ROOT::Fit::FitResult::GetConfidenceIntervalsvoid GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double *x, double *ci, double cl=0.95, bool norm=false) constget confidence intervals for an array of n points x.Definition FitResult.cxx:506; ROOT::Math::IntegratorOneDimOptions::SetDefaultIntegratorstatic void SetDefaultIntegrator(const char *name)Definition IntegratorOptions.cxx:222; TAttFill::SetFillColorvirtual void SetFillColor(Color_t fcolor)Set the fill area color.Definition TAttFill.h:37; TAttFill::SetFillStylevirtual void SetFillStyle(Style_t fstyle)Set the fill area style.Definition TAttFill.h:39; TAttLine::SetLineWidthvirtual void SetLineWidth(Width_t lwidth)Set the line width.Definition TAttLine.h:43; TAttLine::SetLineColorvirtual void SetLineColor(Color_t lcolor)Set the line color.Definition TAttLine.h:40; TAttMarker::SetMarkerStylevirtual void SetMa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TestBinomial_8C.html:56434,error,error,56434,doc/master/TestBinomial_8C.html,https://root.cern,https://root.cern/doc/master/TestBinomial_8C.html,1,['error'],['error']
Availability,"2{; 833 return cl->InheritsFrom(base);; 834}; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; TBrowser.h; TBuffer.h; TClass.h; gCollectionMutexTVirtualMutex * gCollectionMutexDefinition TCollection.cxx:52; TCollection.h; gCollectionMutexR__EXTERN TVirtualMutex * gCollectionMutexDefinition TCollection.h:45; R__FOR_EACH#define R__FOR_EACH(type, proc)Definition TCollection.h:373; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; optionOption_t Option_t optionDefinition TGWin32VirtualXProxy.cxx:44; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; namechar name[80]Definition TGX11.cxx:110; TObjArray.h; TObjectTable.h; TPRegexp.h; TROOT.h; TRegexp.h; TSpinLockGuard.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TVirtualMutex.h; R__LOCKGUARD2#define R__LOCKGUARD2(mutex)Definition TVirtualMutex.h:96; Varargs.h; va_#define va_(arg)Definition Varargs.h:35; ROOT::Internal::TSpinLockGuardA spin mutex-as-code-guard class.Definition TSpinLockGuard.h:35; TBrowserUsing a TBrowser one can browse all ROOT objects.Definition TBrowser.h:37; TBufferBuffer base class used for serializing objects.Definition TBuffer.h:43; TClassTClass instances represent cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCollection_8cxx_source.html:28649,error,error,28649,doc/master/TCollection_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCollection_8cxx_source.html,1,['error'],['error']
Availability,"2}; 203 ; 204////////////////////////////////////////////////////////////////////////////////; 205/// Use this function in case an error occurred.; 206 ; 207void Break(const char *location, const char *fmt, ...); 208{; 209 std::va_list ap;; 210 va_start(ap, fmt);; 211 ErrorHandler(kBreak, location, fmt, ap);; 212 va_end(ap);; 213}; 214 ; 215////////////////////////////////////////////////////////////////////////////////; 216/// Use this function for informational messages.; 217 ; 218void Info(const char *location, const char *fmt, ...); 219{; 220 std::va_list ap;; 221 va_start(ap, fmt);; 222 ErrorHandler(kInfo, location, fmt, ap);; 223 va_end(ap);; 224}; 225 ; 226////////////////////////////////////////////////////////////////////////////////; 227/// Use this function in warning situations.; 228 ; 229void Warning(const char *location, const char *fmt, ...); 230{; 231 std::va_list ap;; 232 va_start(ap, fmt);; 233 ErrorHandler(kWarning, location, fmt, ap);; 234 va_end(ap);; 235}; 236 ; 237////////////////////////////////////////////////////////////////////////////////; 238/// Use this function in case of a fatal error. It will abort the program.; 239 ; 240/// @warning Fatal() *will* not abort the program if `gErrorIgnoreLevel > kFatal`; 241/// - but for all reasonable settings it *will* abort.; 242// So let's be reasonable wrt Coverity:; 243// coverity[+kill]; 244void Fatal(const char *location, const char *fmt, ...); 245{; 246 std::va_list ap;; 247 va_start(ap, fmt);; 248 ErrorHandler(kFatal, location, fmt, ap);; 249 va_end(ap);; 250}; h#define h(i)Definition RSha256.hxx:106; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; gErrorAbortLevelInt_t gErrorAbortLevelDefinition TError.cxx:32; kAssertMsgconst char * kAssertMsgDefinition TError.cxx:35; Errorvoid Error(const char *location, const char *fmt,...)Use this function i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TError_8cxx_source.html:8001,error,error,8001,doc/master/TError_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TError_8cxx_source.html,1,['error'],['error']
Availability,"2};; if (randomSeed >= 0) {; TRandom2 r(randomSeed);; variable[0] = r.Uniform(-20,20);; variable[1] = r.Uniform(-20,20);; }; ; minimum->SetFunction(f);; ; // Set the free variables to be minimized !; minimum->SetVariable(0,""x"",variable[0], step[0]);; minimum->SetVariable(1,""y"",variable[1], step[1]);; ; // do the minimization; minimum->Minimize();; ; const double *xs = minimum->X();; std::cout << ""Minimum: f("" << xs[0] << "","" << xs[1] << ""): ""; << minimum->MinValue() << std::endl;; ; // expected minimum is 0; if ( minimum->MinValue() < 1.E-4 ); std::cout << ""Minimizer "" << minName << "" - "" << algoName; << "" converged to the right minimum"" << std::endl;; else {; std::cout << ""Minimizer "" << minName << "" - "" << algoName; << "" failed to converge !!!"" << std::endl;; Error(""NumericalMinimization"",""fail to converge"");; }; ; return 0;; }; Functor.h; Minimizer.h; f#define f(i)Definition RSha256.hxx:104; TError.h; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; rOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t rDefinition TGWin32VirtualXProxy.cxx:168; TRandom2.h; ROOT::Math::Factory::CreateMinimizerstatic ROOT::Math::Minimizer * CreateMinimizer(const std::string &minimizerType="""", const std::string &algoType="""")static method to create the corresponding Minimizer given the string Supported Minimizers types are: ...Definition Factory.cxx:63; ROOT::Math::FunctorDocumentation for class Functor class.Definition Functor.h:47; ROOT::Math::MinimizerAbstract Minimizer class, defining the interface for the various minimizer (like Minuit2,...Definition Minimizer.h:119; ROOT::Math::Minimizer::Xvirtual const double * X() const =0return pointer to X values at the minimum; ROOT::Math::Minimizer::SetMaxIterationsvoid SetMaxIterations(unsigned int maxite",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NumericalMinimization_8C.html:2954,error,error,2954,doc/master/NumericalMinimization_8C.html,https://root.cern,https://root.cern/doc/master/NumericalMinimization_8C.html,1,['error'],['error']
Availability,"2 . ). overridevirtual . Draws a line. ; Parameters. [in]x1,y1begin of line ; [in]x2,y2end of line . Reimplemented from TVirtualX. ◆ DrawPolyLine(). void TGWin32VirtualXProxy::DrawPolyLine ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Draws a line through all points in the list. ; Parameters. [in]nnumber of points ; [in]xylist of points . Reimplemented from TVirtualX. ◆ DrawPolyMarker(). void TGWin32VirtualXProxy::DrawPolyMarker ; (; Int_t ; n, . TPoint * ; xy . ). overridevirtual . Draws ""n"" markers with the current attributes at position [x,y]. ; Parameters. [in]nnumber of markers to draw ; [in]xyan array of x,y marker coordinates . Reimplemented from TVirtualX. ◆ DrawRectangle(). void TGWin32VirtualXProxy::DrawRectangle ; (; Drawable_t ; id, . GContext_t ; gc, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Draws rectangle outlines of [x,y] [x+w,y] [x+w,y+h] [x,y+h]. ; GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask. GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, dash-list. (see also the GCValues_t structure) ; Reimplemented from TVirtualX. ◆ DrawSegments(). void TGWin32VirtualXProxy::DrawSegments ; (; Drawable_t ; id, . GContext_t ; gc, . Segment_t * ; seg, . Int_t ; nseg . ). overridevirtual . Draws multiple line segments. ; Each line is specified by a pair of points.; Parameters. [in]idDrawable identifier ; [in]gcgraphics context ; [in]*segspecifies an array of segments ; [in]nsegspecifies the number of segments in the array. GC components in use: function, plane-mask, line-width, line-style, cap-style, join-style, fill-style, subwindow-mode, clip-x-origin, clip-y-origin, clip-mask.; GC mode-dependent components: foreground, background, tile, stipple, tile-stipple-x-origin, tile-stipple-y-origin, dash-offset, and dash-list. (see also t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGWin32VirtualXProxy.html:71304,mask,mask,71304,doc/master/classTGWin32VirtualXProxy.html,https://root.cern,https://root.cern/doc/master/classTGWin32VirtualXProxy.html,2,['mask'],['mask']
Availability,"3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  . Public Member Functions;  TGraphMultiErrors ();  TGraphMultiErrors default constructor. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title);  TGraphMultiErrors default constructor with name and title. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, const Double_t *x, const Double_t *y, const Double_t *exL=nullptr, const Double_t *exH=nullptr, const Double_t *eyL=nullptr, const Double_t *eyH=nullptr, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and a single y-error. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, const Float_t *x, const Float_t *y, const Float_t *exL=nullptr, const Float_t *exH=nullptr, const Float_t *eyL=nullptr, const Float_t *eyH=nullptr, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and a single y-error. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL, const Double_t *exH, std::vector< std::vector< Double_t > > eyL, std::vector< std::vector< Double_t > > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x, const Double_t *y, const Double_t *exL, const Double_t *exH, std::vector< TArrayD > eyL, std::vector< TArrayD > eyH, Int_t m=kOnlyFirst);  TGraphMultiErrors normal constructor with name, title, np points and ne y-errors. ;  ;  TGraphMultiErrors (const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Float_t *x, const Float_t *y, const Float_t *exL, const F",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGraphMultiErrors.html:4408,error,error,4408,doc/master/classTGraphMultiErrors.html,https://root.cern,https://root.cern/doc/master/classTGraphMultiErrors.html,1,['error'],['error']
Availability,"3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Protected Types inherited from TGFrame; enum  { kDeleteWindowCalled = (1ULL << ( 15 )); };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from TGFrame; Pixel_t fBackground;  frame background color ;  ; Int_t fBorderWidth;  frame border width ;  ; Int_t fDNDState;  EDNDFlags. ;  ; UInt_t fEventMask;  currently active event mask ;  ; TGFrameElement * fFE;  pointer to frame element ;  ; UInt_t fHeight;  frame height ;  ; UInt_t fMaxHeight;  maximal frame height ;  ; UInt_t fMaxWidth;  maximal frame width ;  ; UInt_t fMinHeight;  minimal frame height ;  ; UInt_t fMinWidth;  minimal frame width ;  ; UInt_t fOptions;  frame options ;  ; UInt_t fWidth;  frame width ;  ; Int_t fX;  frame x position ;  ; Int_t fY;  frame y position ;  ;  Protected Attributes inherited from TGWindow; UInt_t fEditDisabled;  flags used for ""guibuilding"" ;  ; TString fName;  name of the window used in SavePrimitive() ;  ; Bool_t fNeedRedraw;  kTRUE if window needs to be redrawn ;  ; const TGWindow * fParent;  Parent window. ;  ;  Protected Attributes inherited from TGObject; TGClient * fClient;  Connection to display server. ;  ; Handle_t fId;  X11/Win32 Window identifier. ;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  ;  Static Protected Attributes inherited from TGFrame; static const TGGC * fgBckgndGC = nullptr;  ; static const TGGC * fgBlackGC = nullptr;  ; static Pixel_t fgBlackPixel = 0;  ; static Window_t fgDbw = 0;  ; static Int_t fgDbx = 0;  ; static Int_t fgDby = 0;  ; static ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLWidget.html:29203,mask,mask,29203,doc/master/classTGLWidget.html,https://root.cern,https://root.cern/doc/master/classTGLWidget.html,1,['mask'],['mask']
Availability,"3 ; 2464////////////////////////////////////////////////////////////////////////////////; 2465/// Returns cpu load average and load info into the CpuInfo_t structure.; 2466/// Returns -1 in case of error, 0 otherwise. Use sampleTime to set the; 2467/// interval over which the CPU load will be measured, in ms (default 1000).; 2468 ; 2469int TSystem::GetCpuInfo(CpuInfo_t *, Int_t) const; 2470{; 2471 AbstractMethod(""GetCpuInfo"");; 2472 return -1;; 2473}; 2474 ; 2475////////////////////////////////////////////////////////////////////////////////; 2476/// Returns ram and swap memory usage info into the MemInfo_t structure.; 2477/// Returns -1 in case of error, 0 otherwise.; 2478 ; 2479int TSystem::GetMemInfo(MemInfo_t *) const; 2480{; 2481 AbstractMethod(""GetMemInfo"");; 2482 return -1;; 2483}; 2484 ; 2485////////////////////////////////////////////////////////////////////////////////; 2486/// Returns cpu and memory used by this process into the ProcInfo_t structure.; 2487/// Returns -1 in case of error, 0 otherwise.; 2488 ; 2489int TSystem::GetProcInfo(ProcInfo_t *) const; 2490{; 2491 AbstractMethod(""GetProcInfo"");; 2492 return -1;; 2493}; 2494 ; 2495//---- Script Compiler ---------------------------------------------------------; 2496 ; 2497void AssignAndDelete(TString& target, char *tobedeleted); 2498{; 2499 // Assign the char* value to the TString and then delete it.; 2500 ; 2501 target = tobedeleted;; 2502 delete [] tobedeleted;; 2503}; 2504 ; 2505#ifdef WIN32; 2506 ; 2507static TString R__Exec(const char *cmd); 2508{; 2509 // Execute a command and return the stdout in a string.; 2510 ; 2511 FILE * f = gSystem->OpenPipe(cmd,""r"");; 2512 if (!f) {; 2513 return """";; 2514 }; 2515 TString result;; 2516 ; 2517 char x;; 2518 while ((x = fgetc(f))!=EOF ) {; 2519 if (x=='\n' || x=='\r') break;; 2520 result += x;; 2521 }; 2522 ; 2523 fclose(f);; 2524 return result;; 2525}; 2526 ; 2527static void R__FixLink(TString &cmd); 2528{; 2529 // Replace the call to 'link' by a full path ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:80321,error,error,80321,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['error'],['error']
Availability,"3 ; 3094const TString& TROOT::GetMacroDir() {; 3095#ifdef ROOTMACRODIR; 3096 if (IgnorePrefix()) {; 3097#endif; 3098 static TString rootmacrodir;; 3099 if (rootmacrodir.IsNull()) {; 3100 rootmacrodir = ""macros"";; 3101 gSystem->PrependPathName(GetRootSys(), rootmacrodir);; 3102 }; 3103 return rootmacrodir;; 3104#ifdef ROOTMACRODIR; 3105 } else {; 3106 const static TString rootmacrodir = ROOTMACRODIR;; 3107 return rootmacrodir;; 3108 }; 3109#endif; 3110}; 3111 ; 3112////////////////////////////////////////////////////////////////////////////////; 3113/// Get the tutorials directory in the installation. Static utility function.; 3114 ; 3115const TString& TROOT::GetTutorialDir() {; 3116#ifdef ROOTTUTDIR; 3117 if (IgnorePrefix()) {; 3118#endif; 3119 static TString roottutdir;; 3120 if (roottutdir.IsNull()) {; 3121 roottutdir = ""tutorials"";; 3122 gSystem->PrependPathName(GetRootSys(), roottutdir);; 3123 }; 3124 return roottutdir;; 3125#ifdef ROOTTUTDIR; 3126 } else {; 3127 const static TString roottutdir = ROOTTUTDIR;; 3128 return roottutdir;; 3129 }; 3130#endif; 3131}; 3132 ; 3133////////////////////////////////////////////////////////////////////////////////; 3134/// Shut down ROOT.; 3135 ; 3136void TROOT::ShutDown(); 3137{; 3138 if (gROOT); 3139 gROOT->EndOfProcessCleanups();; 3140 else if (gInterpreter); 3141 gInterpreter->ShutDown();; 3142}; 3143 ; 3144////////////////////////////////////////////////////////////////////////////////; 3145/// Get the source directory in the installation. Static utility function.; 3146 ; 3147const TString& TROOT::GetSourceDir() {; 3148#ifdef ROOTSRCDIR; 3149 if (IgnorePrefix()) {; 3150#endif; 3151 static TString rootsrcdir;; 3152 if (rootsrcdir.IsNull()) {; 3153 rootsrcdir = ""src"";; 3154 gSystem->PrependPathName(GetRootSys(), rootsrcdir);; 3155 }; 3156 return rootsrcdir;; 3157#ifdef ROOTSRCDIR; 3158 } else {; 3159 const static TString rootsrcdir = ROOTSRCDIR;; 3160 return rootsrcdir;; 3161 }; 3162#endif; 3163}; 3164 ; 3165//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:118400,down,down,118400,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['down'],['down']
Availability,"3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var constructor. Optional arguments taken. Extended() -- Include extended term in calculation; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooAbsData::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChi2Var.html:45444,Error,ErrorType,45444,root/html534/RooChi2Var.html,https://root.cern,https://root.cern/root/html534/RooChi2Var.html,1,['Error'],['ErrorType']
Availability,"3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none()); RooChi2Var constructor. Optional arguments taken. Extended() -- Include extended term in calculation; DataError() -- Choose between Poisson errors and Sum-of-weights errors; NumCPU() -- Activate parallel processing feature; Range() -- Fit only selected region; SumCoefRange() -- Set the range in which to interpret the coefficients of RooAddPdf components; SplitRange() -- Fit range is split by index catory of simultaneous PDF; ConditionalObservables() -- Define projected observables; Verbose() -- Verbose output of GOF framework. RooChi2Var(const char* name, const char* title, RooAbsPdf& pdf, RooDataHist& data, Bool_t extended = kFALSE, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kTRUE, RooDataHist::ErrorType = RooDataHist::SumW2); Constructor of a chi2 for given p.d.f. with respect given binned; dataset. If cutRange is specified the calculation of the chi2 is; restricted to that named range. If addCoefRange is specified, the; interpretation of fractions for all component RooAddPdfs that do; not have a frozen range interpretation is set to chosen range; name. If nCPU is greater than one the chi^2 calculation is; paralellized over the specified number of processors. If; interleave is true the partitioning of event over processors; follows a (i % n == i_set) strategy rather than a bulk; partitioning strategy which may result in unequal load balancing; in binned datasets with many (adjacent) zero bins. If; splitCutRange is true the cutRange is used to construct an; individual cutRange for each RooSimultaneous index category state; name cutRange_{indexStateName}. RooC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:47132,Error,ErrorType,47132,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,2,['Error'],['ErrorType']
Availability,"3 const RDFInternal::RColumnRegister &colRegister); 3314 : RInterfaceBase(lm, colRegister), fProxiedPtr(proxied); 3315 {; 3316 }; 3317 ; 3318 const std::shared_ptr<Proxied> &GetProxiedPtr() const { return fProxiedPtr; }; 3319};; 3320 ; 3321} // namespace RDF; 3322 ; 3323} // namespace ROOT; 3324 ; 3325#endif // ROOT_RDF_INTERFACE; ActionHelpers.hxx; HistoModels.hxx; InterfaceUtils.hxx; RColumnRegister.hxx; RDFDescription.hxx; RDataSource.hxx; RDefaultValueFor.hxx; RDefinePerSample.hxx; RDefine.hxx; RFilterWithMissingValues.hxx; RFilter.hxx; RInterfaceBase.hxx; RLazyDSImpl.hxx; RLoopManager.hxx; RRange.hxx; RResultPtr.hxx; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; RSnapshotOptions.hxx; RVariation.hxx; RVariationsDescription.hxx; RVec.hxx; RtypesCore.h; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; ULong64_tunsigned long long ULong64_tDefinition RtypesCore.h:70; X#define X(type, name); TDirectory.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; kErrorconstexpr Int_t kErrorDefinition TError.h:47; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char filenameDefinition TGWin32VirtualXProxy.cxx:232; valueOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void valueDefinition TGWin32VirtualXProxy.cxx:142; typeOp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RInterface_8hxx_source.html:188752,error,error,188752,doc/master/RInterface_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RInterface_8hxx_source.html,1,['error'],['error']
Availability,"3 if (error) {; 12564 mg_cry_internal(; 12565 conn,; 12566 ""%s"",; 12567 ""Websocket pull failed; closing connection"");; 12568 if (data != mem) {; 12569 mg_free(data);; 12570 }; 12571 break;; 12572 }; 12573 ; 12574 conn->data_len = conn->request_len;; 12575 ; 12576 } else {; 12577 ; 12578 mop = buf[0]; /* current mask and opcode, overwritten by; 12579 * memmove() */; 12580 ; 12581 /* Length of the message being read at the front of the; 12582 * queue. Cast to 31 bit is OK, since we limited; 12583 * data_len before. */; 12584 len = (size_t)data_len + header_len;; 12585 ; 12586 /* Copy the data payload into the data pointer for the; 12587 * callback. Cast to 31 bit is OK, since we; 12588 * limited data_len */; 12589 memcpy(data, buf + header_len, (size_t)data_len);; 12590 ; 12591 /* Move the queue forward len bytes */; 12592 memmove(buf, buf + len, body_len - len);; 12593 ; 12594 /* Mark the queue as advanced */; 12595 conn->data_len -= (int)len;; 12596 }; 12597 ; 12598 /* Apply mask if necessary */; 12599 if (mask_len > 0) {; 12600 for (i = 0; i < (size_t)data_len; i++) {; 12601 data[i] ^= mask[i & 3];; 12602 }; 12603 }; 12604 ; 12605 exit_by_callback = 0;; 12606 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12607 /* filter PONG messages */; 12608 DEBUG_TRACE(""PONG from %s:%u"",; 12609 conn->request_info.remote_addr,; 12610 conn->request_info.remote_port);; 12611 /* No unanwered PINGs left */; 12612 ping_count = 0;; 12613 } else if (enable_ping_pong; 12614 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12615 /* reply PING messages */; 12616 DEBUG_TRACE(""Reply PING from %s:%u"",; 12617 conn->request_info.remote_addr,; 12618 conn->request_info.remote_port);; 12619 ret = mg_websocket_write(conn,; 12620 MG_WEBSOCKET_OPCODE_PONG,; 12621 (char *)data,; 12622 (size_t)data_len);; 12623 if (ret <= 0) {; 12624 /* Error: send failed */; 12625 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12626 break;; 12627 }; 12628 ; 12629 ; 12630 } else {; 12631 /* Exit t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:365846,mask,mask,365846,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['mask'],['mask']
Availability,"3 iter != end;; 4374 ++iter); 4375 {; 4376 iter->fConfiguration->Print();; 4377 if (strstr(opt,""func"")) {; 4378 printf(""StreamerInfoAction func: %s\n"",R__GetSymbolName((voidfunc)iter->fAction));; 4379 }; 4380 }; 4381}; 4382 ; 4383 ; b#define b(i)Definition RSha256.hxx:100; UShort_tunsigned short UShort_tDefinition RtypesCore.h:40; Int_tint Int_tDefinition RtypesCore.h:45; kMaxIntconstexpr Int_t kMaxIntDefinition RtypesCore.h:105; Version_tshort Version_tDefinition RtypesCore.h:65; Long_tlong Long_tDefinition RtypesCore.h:54; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; kFALSEconstexpr Bool_t kFALSEDefinition RtypesCore.h:94; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; Option_tconst char Option_tDefinition RtypesCore.h:66; TBufferFile.h; TBufferText.h; TClassEdit.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; Warningvoid Warning(const char *location, const char *msgfmt,...)Use this function in warning situations.Definition TError.cxx:229; Fatalvoid Fatal(const char *location, const char *msgfmt,...)Use this function in case of a fatal error. It will abort the program.Definition TError.cxx:244; TFile.h; offsetOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html:206212,error,error,206212,doc/master/TStreamerInfoActions_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TStreamerInfoActions_8cxx_source.html,1,['error'],['error']
Availability,"3 l.Add((TObject*)&arg5) ; l.Add((TObject*)&arg6) ;; 4284 l.Add((TObject*)&arg7) ; l.Add((TObject*)&arg8) ;; 4285 return createChi2(data,l) ;; 4286}; 4287 ; 4288 ; 4289////////////////////////////////////////////////////////////////////////////////; 4290/// See RooAbsReal::createChi2(RooDataSet&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&,const RooCmdArg&); 4291 ; 4292RooFit::OwningPtr<RooAbsReal> RooAbsReal::createChi2(RooDataSet &data, const RooLinkedList &cmdList); 4293{; 4294 return RooFit::makeOwningPtr(RooFit::FitHelpers::createChi2(*this, data, cmdList));; 4295}; 4296 ; 4297 ; 4298 ; 4299////////////////////////////////////////////////////////////////////////////////; 4300/// Return current evaluation error logging mode.; 4301 ; 4302RooAbsReal::ErrorLoggingMode RooAbsReal::evalErrorLoggingMode(); 4303{; 4304 return evalErrorData().mode ;; 4305}; 4306 ; 4307////////////////////////////////////////////////////////////////////////////////; 4308/// Set evaluation error logging mode. Options are; 4309///; 4310/// PrintErrors - Print each error through RooMsgService() as it occurs; 4311/// CollectErrors - Accumulate errors, but do not print them. A subsequent call; 4312/// to printEvalErrors() will print a summary; 4313/// CountErrors - Accumulate error count, but do not print them.; 4314///; 4315 ; 4316void RooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); 4317{; 4318 evalErrorData().mode = m;; 4319}; 4320 ; 4321 ; 4322////////////////////////////////////////////////////////////////////////////////; 4323 ; 4324void RooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); 4325{; 4326 std::string plist ;; 4327 for (auto const* arg : paramVars) {; 4328 if (!dependsOnValue(*arg)) {; 4329 coutW(InputArguments) << ""RooAbsReal::setParameterizeIntegral("" << GetName(); 4330 << "") function does not depend on listed parameter "" << arg->GetName() << "", ignoring"" << std::endl ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:190361,error,error,190361,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['error']
Availability,"3 return kFALSE;; 454}; 455 ; 456////////////////////////////////////////////////////////////////////////////////; 457/// Evaluate a python expression (e.g. ""ROOT.TBrowser()"").; 458///; 459/// Caution: do not hold on to the return value: either store it in a builtin; 460/// type (implicit casting will work), or in a pointer to a ROOT object (explicit; 461/// casting to a void* is required).; 462///; 463/// \deprecated Use TPython::Exec() with an std::any output parameter instead.; 464 ; 465const TPyReturn TPython::Eval(const char *expr); 466{; 467 // setup; 468 if (!Initialize()); 469 return TPyReturn();; 470 ; 471 PyGILRAII gilRaii;; 472 ; 473 // evaluate the expression; 474 PyObject *result = PyRun_String(const_cast<char *>(expr), Py_eval_input, gMainDict, gMainDict);; 475 ; 476 // report errors as appropriate; return void; 477 if (!result) {; 478 PyErr_Print();; 479 return TPyReturn();; 480 }; 481 ; 482 // results that require no conversion; 483 if (result == Py_None || CPyCppyy::Instance_Check(result) || PyBytes_Check(result) || PyFloat_Check(result) ||; 484 PyLong_Check(result)); 485 return TPyReturn(result);; 486 ; 487 // explicit conversion for python type required; 488 PyObject *pyclass = PyObject_GetAttrString(result, const_cast<char *>(""__class__""));; 489 if (pyclass != 0) {; 490 CachedPyString moduleStr{""__module__""};; 491 CachedPyString nameStr{""__name__""};; 492 ; 493 // retrieve class name and the module in which it resides; 494 PyObject *name = PyObject_GetAttr(pyclass, nameStr.obj());; 495 PyObject *module = PyObject_GetAttr(pyclass, moduleStr.obj());; 496 ; 497 // concat name; 498 std::string qname = std::string(PyUnicode_AsUTF8(module)) + '.' + PyUnicode_AsUTF8(name);; 499 Py_DECREF(module);; 500 Py_DECREF(name);; 501 Py_DECREF(pyclass);; 502 ; 503 // locate ROOT style class with this name; 504 TClass *klass = TClass::GetClass(qname.c_str());; 505 ; 506 // construct general ROOT python object that pretends to be of class 'klass'; 507 if (klass != 0);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TPython_8cxx_source.html:15997,error,errors,15997,doc/master/TPython_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TPython_8cxx_source.html,1,['error'],['errors']
Availability,"3"". Here ALIC is the top most; or master volume which has only 1 instance of. Of all of the daughter; volumes of ALICE, DDIP volume copy #1 is indicated. Similarly for; the daughter volume of DDIP is S05I copy #2 and so on.; Inputs:; TString& volumePath The volume path to the specific volume; for which you want the matrix. Volume name; hierarchy is separated by ""/"" while the; copy number is appended using a ""_"".; Outputs:; TGeoHMatrix &mat A matrix with its values set to those; appropriate to the Local to Master transformation; Return:; A logical value if kFALSE then an error occurred and no change to; mat was made. Bool_t GetShape(const TString& volumePath, TString& shapeType, TArrayD& par); Returns the shape and its parameters for the volume specified; by volumeName.; Inputs:; TString& volumeName The volume name; Outputs:; TString &shapeType Shape type; TArrayD &par A TArrayD of parameters with all of the; parameters of the specified shape.; Return:; A logical indicating whether there was an error in getting this; information. Bool_t GetMaterial(const TString& volumeName, TString& name, Int_t& imat, Double_t& a, Double_t& z, Double_t& density, Double_t& radl, Double_t& inter, TArrayD& par); Returns the Material and its parameters for the volume specified; by volumeName.; Note, Geant3 stores and uses mixtures as an element with an effective; Z and A. Consequently, if the parameter Z is not integer, then; this material represents some sort of mixture.; Inputs:; TString& volumeName The volume name; Outputs:; TSrting &name Material name; Int_t &imat Material index number; Double_t &a Average Atomic mass of material; Double_t &z Average Atomic number of material; Double_t &dens Density of material [g/cm^3]; Double_t &radl Average radiation length of material [cm]; Double_t &inter Average interaction length of material [cm]; TArrayD &par A TArrayD of user defined parameters.; Return:; kTRUE if no errors. Bool_t GetMedium(const TString& volumeName, TString& name, Int_t& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoMCGeometry.html:19780,error,error,19780,root/html528/TGeoMCGeometry.html,https://root.cern,https://root.cern/root/html528/TGeoMCGeometry.html,10,['error'],['error']
Availability,"3.2 Getting the right parameter errors with limits; [answer:right-errors]; In the best case, where the minimum is far from any limits, M will correctly transform the error matrix, and the parameter errors it reports should be accurate and very close to those you would have got without limits. In other cases (which should be more common, since otherwise you wouldn’t need limits), the very meaning of parameter errors becomes problematic. Mathematically, since the limit is an absolute constraint on the parameter, a parameter at its limit has no error, at least in one direction. The error matrix, which can assign only symmetric errors, then becomes essentially meaningless. On the other hand, the \(\mbox{MINOS}\) analysis is still meaningful, at least in principle, as long as \(\mbox{MIGRAD}\) (which is called internally by \(\mbox{MINOS}\)) does not get blocked at a limit. Unfortunately, the user has no control over this aspect of the \(\mbox{MINOS}\) calculation, although it is possible to get enough printout from the \(\mbox{MINOS}\) result to be able to determine whether the results are reliable or not.; 6.4 Fixing and releasing parameters; When M needs to be guided to the “right” minimum, often the best way to do this is with the methods e.g. MnMigrad::fix(…) and MnMigrad::release(…). That is, suppose you have a problem with ten free parameters, and when you minimize with respect to all at once, M goes to an unphysical solution characterized by an unphysical or unwanted value of parameter number four. One way to avoid this is to fix parameter four at a “good” value (not necessarily the best, since you presumably don’t know that yet), and minimize with respect to the others. Then release parameter four and minimize again. If the problem admits a “good” physical solution, you will normally find it this way. If it doesn’t work, you may see what is wrong by the following sequence (where \(\mbox{xxx}\) is the expected physical value for parameter four):; MnMigrad migrad(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:71550,reliab,reliable,71550,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,4,['reliab'],['reliable']
Availability,3.4 1; : 678 Minimum Test error found - save the configuration ; : 678 | 43.7163 36.54 0.0202108 0.00183597 43537.9 0; : 679 Minimum Test error found - save the configuration ; : 679 | 43.1003 36.3421 0.0201203 0.00181258 43697.4 0; : 680 Minimum Test error found - save the configuration ; : 680 | 42.8206 35.8087 0.0201316 0.00181818 43683.7 0; : 681 Minimum Test error found - save the configuration ; : 681 | 42.0593 35.186 0.0205402 0.00185408 42812.5 0; : 682 Minimum Test error found - save the configuration ; : 682 | 41.3592 34.9319 0.0201181 0.00182063 43721.9 0; : 683 | 40.8775 34.9951 0.020058 0.00175108 43699.3 1; : 684 Minimum Test error found - save the configuration ; : 684 | 40.654 34.3931 0.0201589 0.00183818 43666.4 0; : 685 Minimum Test error found - save the configuration ; : 685 | 40.0613 33.8904 0.0201577 0.00183348 43658.1 0; : 686 | 39.3281 34.3645 0.0200576 0.00176772 43739.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.3466 33.422 0.0201552 0.00185044 43704.5 0; : 689 Minimum Test error found - save the configuration ; : 689 | 37.998 33.2339 0.0201139 0.00182328 43738.2 0; : 690 Minimum Test error found - save the configuration ; : 690 | 37.3126 32.8977 0.0200976 0.0018112 43748.3 0; : 691 Minimum Test error found - save the configuration ; : 691 | 36.956 32.4497 0.0202163 0.00185879 43578.8 0; : 692 | 36.3494 32.5119 0.0203375 0.00178876 43129.6 1; : 693 Minimum Test error found - save the configuration ; : 693 | 35.9446 31.7942 0.0202985 0.00181447 43280.7 0; : 694 | 35.3125 31.8389 0.0201438 0.00175333 43500.7 1; : 695 Minimum Test error found - save the configuration ; : 695 | 34.8867 31.3734 0.0201347 0.00182018 43681.2 0; : 696 Minimum Test error found - save the configuration ; : 696 | 34.4357 31.1348 0.0201081 0.00181563 43733.9 0; : 697 Minimum Test error found - save the configuration ; : 697 | 34.0416 30.9812 0.0205543 0.00184744 42765.1 0; : 698 Minimu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:88084,error,error,88084,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,3.916) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.877959 a1=-0.428367 mean=4.99746 nbkg=167.444 nsig=157.288 sig1frac=0.424997; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 860; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 850; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 840; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 830; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-970.563) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.867793 a1=-0.296045 mean=5.10353 nbkg=164.822 nsig=173.566 sig1frac=0.899431; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 820; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 810; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 800; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 790; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 780; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 770; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 760; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-915.472) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.807508 a1=-0.34963 mean=5.09438 nbkg=142.436 nsig=172.312 sig1frac=0.886183; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; [#0] PROGRESS:Generation -- RooMCStudy::run: sample 750; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (-885.867) to force MIGRAD to back out of this region. Error log follows.; Parameter values: a0=0.7962 a1=-0.414289 mean=5.07605 nbkg=135.514 nsig=167.164 sig1frac=0.927781; RooAddPdf::model[ nbkg * bkg_over_bkg_Int[x] + nsig * sig ] has 1 errors; ; RooAbsMinimizerFcn: Minimized function has error status,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf801__mcstudy_8C.html:13158,error,errors,13158,doc/master/rf801__mcstudy_8C.html,https://root.cern,https://root.cern/doc/master/rf801__mcstudy_8C.html,4,['error'],"['error', 'errors']"
Availability,"3.h; TRandom.h; gRandomR__EXTERN TRandom * gRandomDefinition TRandom.h:62; Formchar * Form(const char *fmt,...)Formats a string in a circular formatting buffer.Definition TString.cxx:2489; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TUUID.h; TDirectoryDescribe directory structure in memory.Definition TDirectory.h:45; TDirectory::WriteTObjectvirtual Int_t WriteTObject(const TObject *obj, const char *name=nullptr, Option_t *="""", Int_t=0)Write an object with proper type checking.Definition TDirectory.cxx:1400; TDirectory::GetFilevirtual TFile * GetFile() constDefinition TDirectory.h:220; TDirectory::ReadTObjectvirtual Int_t ReadTObject(TObject *, const char *)Definition TDirectory.h:249; TNamedThe TNamed class is the base class for all named ROOT classes.Definition TNamed.h:29; TNamed::GetNameconst char * GetName() const overrideReturns name of object.Definition TNamed.h:47; TObject::Errorvirtual void Error(const char *method, const char *msgfmt,...) constIssue error message.Definition TObject.cxx:993; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27; TRandom::Gausvirtual Double_t Gaus(Double_t mean=0, Double_t sigma=1)Samples a random number from the standard Normal (Gaussian) Distribution with the given mean and sigm...Definition TRandom.cxx:275; TRandom::RndmArrayvirtual void RndmArray(Int_t n, Float_t *array)Return an array of n random numbers uniformly distributed in ]0,1].Definition TRandom.cxx:595; TRandom::SetSeedvirtual void SetSeed(ULong_t seed=0)Set the random generator seed.Definition TRandom.cxx:615; TRandom::WriteRandomvirtual void WriteRandom(const char *filename) constWrites random generator status to filename.Definition TRandom.cxx:700; TRandom::RndmDouble_t Rndm() overrideMachine independent random number generator.Definition TRandom.cxx:559; TRandom::fSeedUInt_t fSeedDefinition TRandom.h:30; TRandom::Rannorvirtual void Rannor(Float_t &a, Float_t &b)Return 2 numbers distributed follo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:31702,error,error,31702,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['error'],['error']
Availability,"3/// \f[; 1214/// D(h) = \frac{f(x+2h) - 2f(x+h) + 2f(x-h) - f(x-2h)}{2h^{3}}; 1215/// \f]; 1216/// the final estimate; 1217/// \f[; 1218/// D = \frac{4D(h/2) - D(h)}{3}; 1219/// \f]; 1220/// ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition""; 1221///; 1222/// if the argument params is null, the current function parameters are used,; 1223/// otherwise the parameters in params are used.; 1224///; 1225/// the argument eps may be specified to control the step size (precision).; 1226/// the step size is taken as eps*(xmax-xmin).; 1227/// the default value (0.001) should be good enough for the vast majority; 1228/// of functions. Give a smaller value if your function has many changes; 1229/// of the second derivative in the function range.; 1230///; 1231/// Getting the error via TF1::DerivativeError:; 1232/// (total error = roundoff error + interpolation error); 1233/// the estimate of the roundoff error is taken as follows:; 1234/// \f[; 1235/// err = k\sqrt{f(x)^{2} + x^{2}deriv^{2}}\sqrt{\sum ai^{2}},; 1236/// \f]; 1237/// where k is the double precision, ai are coefficients used in; 1238/// central difference formulas; 1239/// interpolation error is decreased by making the step size h smaller.; 1240///; 1241/// \author Anna Kreshuk; 1242 ; 1243Double_t TF1::Derivative3(Double_t x, Double_t *params, Double_t eps) const; 1244{; 1245 if (GetNdim() > 1) {; 1246 Warning(""Derivative3"", ""Function dimension is larger than one"");; 1247 }; 1248 ; 1249 ROOT::Math::RichardsonDerivator rd;; 1250 double xmin, xmax;; 1251 GetRange(xmin, xmax);; 1252 // this is not optimal (should be used the average x instead of the range); 1253 double h = eps * std::abs(xmax - xmin);; 1254 if (h <= 0) h = 0.001;; 1255 double der = 0;; 1256 if (params) {; 1257 ROOT::Math::WrappedTF1 wtf(*(const_cast<TF1 *>(this)));; 1258 wtf.SetParameters(params);; 1259 der = rd.Derivative3(wtf, x, h);; 1260 } else {; 1261 // no need to set parameters used a non-parametric wrapper to avoid all",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TF1_8cxx_source.html:44396,error,error,44396,doc/master/TF1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TF1_8cxx_source.html,6,['error'],['error']
Availability,"3/2015 - 21:49 Permalink . Re: Other Python bindings . Hi Bram, Axel,; let me add to that (and point out that none of the mentioned tools are intrusive, btw.). The biggest problem with boost.python (with pyste; standalone it is a non-starter) and SWIG is that you need to run a separate tool to create and compile bindings. On top, these bindings are compiled against a specific version of Python, making for a distribution headache (just see the non-pickup of Python3 because of this problem). Compare: dictionaries are already available for all the most important classes in experiments, the EDM, because they are generated for I/O needs. They also do not depend on Python, and thus not on any specific version (only PyROOT does). Besides the obvious ease of use, there is also the benefit of lower memory footprints by not replicating structures. (For that matter, PyROOT creates bindings lazily, the others do not.); Other problems we've had, are that boost.python is very, very slow and only in ""keeping alive"" mode since 2004 or so. Pyste is based on gccxml, so no C++11 there, and has seen no major updates since 2005. SWIG is much, much better in both regards, but not up to snuff: it plain and simply can not parse our header files. The way around that, is to write .i files, but as you can imagine, that duplication is not nice for maintenance. Worse, the developers of individual packages need to do this work, and not every C++ developer has Python, let alone SWIG, experience.; Then there's PyPy. All existing binding generator tools (including PyROOT) rely on CPython internals, or at least on the Python C-API. That does not jive with PyPy as it has for example a garbage collector instead of reference counting. Through some heroics, it does expose a Python C-API, but it's slow as it interferes (blocks, really) the just-in-time compiler. Therefore, within PyPy, there are two new approaches: cffi for C and cppyy for C++. Both are part of the standard PyPy releases. There is also a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html:7544,alive,alive,7544,d/blog/do-we-need-yet-another-custom-c-interpreter.html,https://root.cern,https://root.cern/d/blog/do-we-need-yet-another-custom-c-interpreter.html,1,['alive'],['alive']
Availability,"30 BufferEmpty();; 1331 delete [] fBuffer;; 1332 fBuffer = nullptr;; 1333 }; 1334 if (buffersize <= 0) {; 1335 fBufferSize = 0;; 1336 return;; 1337 }; 1338 if (buffersize < 100) buffersize = 100;; 1339 fBufferSize = 1 + 5*buffersize;; 1340 fBuffer = new Double_t[fBufferSize];; 1341 memset(fBuffer,0,sizeof(Double_t)*fBufferSize);; 1342}; 1343 ; 1344////////////////////////////////////////////////////////////////////////////////; 1345/// Set option to compute profile3D errors.; 1346///; 1347/// The computation of the bin errors is based on the parameter option:; 1348/// - ' ' (Default) The bin errors are the standard error on the mean of the bin profiled values (T),; 1349/// i.e. the standard error of the bin contents.; 1350/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1351/// the spread in T is 0 and the number of bin entries is > 0; 1352/// - 's' The bin errors are the standard deviations of the T bin values; 1353/// Note that if TProfile3D::Approximate() is called, an approximation is used when; 1354/// the spread in T is 0 and the number of bin entries is > 0; 1355/// - 'i' Errors are as in default case (standard errors of the bin contents); 1356/// The only difference is for the case when the spread in T is zero.; 1357/// In this case for N > 0 the error is 1./SQRT(12.*N); 1358/// - 'g' Errors are 1./SQRT(W) for W not equal to 0 and 0 for W = 0.; 1359/// W is the sum in the bin of the weights of the profile.; 1360/// This option is for combining measurements t +/- dt,; 1361/// and the profile is filled with values t and weights w = 1/dt**2; 1362///; 1363/// See TProfile::BuildOptions for explanation of all options; 1364 ; 1365void TProfile3D::SetErrorOption(Option_t *option); 1366{; 1367 TProfileHelper::SetErrorOption(this, option);; 1368}; 1369 ; 1370////////////////////////////////////////////////////////////////////////////////; 1371/// Create/Delete structure to store sum of squares of weights per bin; 1372/// This is ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:51114,error,errors,51114,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,2,['error'],['errors']
Availability,"30,-55,55);; TRandom r;; for (Int_t i=0;i<10000;i++) {; h1->Fill(r.Gaus(-55,10));; h2->Fill(r.Gaus(55,10));; h3->Fill(r.Gaus(0,10));; }; ; TList *list = new TList;; list->Add(h1);; list->Add(h2);; list->Add(h3);; TH1F *h = (TH1F*)h1->Clone(""h"");; h->Reset();; h->Merge(list);; h->Draw();; }; TListA doubly linked list.Definition TList.h:38; TList::Addvoid Add(TObject *obj) overrideDefinition TList.h:83; TObject::Drawvirtual void Draw(Option_t *option="""")Default Draw method for all objects.Definition TObject.cxx:280; TRandomThis is the base class for the ROOT Random number generators.Definition TRandom.h:27. Definition at line 6022 of file TH1.cxx. ◆ Multiply() [1/3]. Bool_t TH1::Multiply ; (; const TH1 * ; h1). virtual . Multiply this histogram by h1. ; this = this*h1; If errors of this are available (TH1::Sumw2), errors are recalculated. Note that if h1 has Sumw2 set, Sumw2 is automatically called for this if not already set.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply; The function return kFALSE if the Multiply operation failed ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at line 6111 of file TH1.cxx. ◆ Multiply() [2/3]. Bool_t TH1::Multiply ; (; const TH1 * ; h1, . const TH1 * ; h2, . Double_t ; c1 = 1, . Double_t ; c2 = 1, . Option_t * ; option = """" . ). virtual . Replace contents of this histogram by multiplication of h1 by h2. ; this = (c1*h1)*(c2*h2); If errors of this are available (TH1::Sumw2), errors are recalculated. Note that if h1 or h2 have Sumw2 set, Sumw2 is automatically called for this if not already set.; IMPORTANT NOTE: If you intend to use the errors of this histogram later you should call Sumw2 before making this operation. This is particularly important if you fit the histogram after TH1::Multiply; The function return kFALSE if the Multiply operation failed ; Reimpleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:191007,error,errors,191007,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability,"30/// ~~~ {.cpp}; 631/// TVirtualFitter::Fitter(mygraph)->SetFCN(MyFittingFunction); 632/// ~~~; 633/// where MyFittingFunction is of type:; 634/// ~~~ {.cpp}; 635/// extern void MyFittingFunction(Int_t &npar, Double_t *gin, Double_t &f, Double_t *u, Int_t flag);; 636/// ~~~; 637///; 638/// ### Access to the fit result; 639///; 640/// The function returns a TFitResultPtr which can hold a pointer to a TFitResult object.; 641/// By default the TFitResultPtr contains only the status of the fit and it converts; 642/// automatically to an integer. If the option ""S"" is instead used, TFitResultPtr contains; 643/// the TFitResult and behaves as a smart pointer to it. For example one can do:; 644/// ~~~ {.cpp}; 645/// TFitResultPtr r = graph->Fit(""myFunc"",""S"");; 646/// TMatrixDSym cov = r->GetCovarianceMatrix(); // to access the covariance matrix; 647/// Double_t par0 = r->Parameter(0); // retrieve the value for the parameter 0; 648/// Double_t err0 = r->ParError(0); // retrieve the error for the parameter 0; 649/// r->Print(""V""); // print full information of fit including covariance matrix; 650/// r->Write(); // store the result in a file; 651/// ~~~; 652///; 653/// The fit parameters, error and chi2 (but not covariance matrix) can be retrieved also; 654/// from the fitted function.; 655///; 656/// ### Associated functions; 657///; 658/// One or more object (typically a TF1*) can be added to the list; 659/// of functions (fFunctions) associated to each graph.; 660/// When TGraph::Fit is invoked, the fitted function is added to this list.; 661/// Given a graph gr, one can retrieve an associated function; 662/// with:; 663/// ~~~ {.cpp}; 664/// TF1 *myfunc = gr->GetFunction(""myfunc"");; 665/// ~~~; 666///; 667/// If the graph is made persistent, the list of; 668/// associated functions is also persistent. Given a pointer (see above); 669/// to an associated function myfunc, one can retrieve the function/fit; 670/// parameters with calls such as:; 671/// ~~~ {.cpp}; 672/// Doubl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMultiGraph_8cxx_source.html:20934,error,error,20934,doc/master/TMultiGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html,2,['error'],['error']
Availability,"300 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 256 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 256 , 1 ) Activation Function = Identity; : Using 2560 events for training and 640 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.805395; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.725372 0.686272 0.190597 0.0152439 14599.1 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.695636 0.683324 0.189128 0.015082 14708.8 0; : 3 | 0.691864 0.689576 0.189646 0.0148842 14648.6 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.689168 0.677551 0.190642 0.015026 14577.3 0; : 5 | 0.686885 0.678678 0.189865 0.0148775 14629.7 1; : 6 | 0.68905 0.681357 0.189104 0.014885 14694.1 2; : 7 | 0.687138 0.683485 0.19023 0.0152893 14633.6 3; : 8 | 0.686429 0.685529 0.189996 0.0147979 14612 4; : 9 | 0.685179 0.683467 0.190317 0.0152552 14623.4 5; : 10 Minimum Test error found - save the configuration ; : 10 | 0.684262 0.673795 0.18992 0.0153518 14664.7 0; : 11 Minimum Test error found - save the configuration ; : 11 | 0.682907 0.671521 0.194162 0.0155002 14328.7 0; : 12 | 0.693473 0.677553 0.188937 0.0147664 14698.2 1; : 13 | 0.695581 0.671789 0.190501 0.0149406 14581.9 2; : 14 | 0.68024 0.680521 0.188432 0.0146998 14735.3 3; : 15 | 0.68435 0.688062 0.189615 0.0147881 14643.1 4; : 16 | 0.686476 0.675588 0.190015 0.0152195 14645.7 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:18497,error,error,18497,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['error'],['error']
Availability,"300 TVirtualCollectionProxy* proxy = GetCollectionProxy();; 4301 TVirtualCollectionProxy::TPushPop helper(proxy, fObject);; 4302 void* alternate = proxy->Allocate(fNdata, true);; 4303 if(fSTLtype != ROOT::kSTLvector && proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ) {; 4304 fPtrIterators->CreateIterators(alternate, proxy);; 4305 } else {; 4306 fIterators->CreateIterators(alternate, proxy);; 4307 }; 4308 ; 4309 Int_t nbranches = fBranches.GetEntriesFast();; 4310 switch (fSTLtype) {; 4311 case ROOT::kSTLset:; 4312 case ROOT::kSTLunorderedset:; 4313 case ROOT::kSTLunorderedmultiset:; 4314 case ROOT::kSTLmultiset:; 4315 case ROOT::kSTLmap:; 4316 case ROOT::kSTLmultimap:; 4317 case ROOT::kSTLunorderedmap:; 4318 case ROOT::kSTLunorderedmultimap:; 4319 for (Int_t i = 0; i < nbranches; ++i) {; 4320 TBranch *branch = (TBranch*) fBranches[i];; 4321 Int_t nb = branch->GetEntry(GetReadEntry(), 1);; 4322 if (nb < 0) {; 4323 // Give up on i/o failure.; 4324 // FIXME: We need an error message here.; 4325 break;; 4326 }; 4327 }; 4328 break;; 4329 default:; 4330 break;; 4331 }; 4332 //------------------------------------------------------------------------; 4333 // We have split this stuff, so we need to create the pointers; 4334 /////////////////////////////////////////////////////////////////////////////; 4335 ; 4336 if( proxy->HasPointers() && fSplitLevel > TTree::kSplitCollectionOfPointers ); 4337 {; 4338 TClass *elClass = proxy->GetValueClass();; 4339 ; 4340 //--------------------------------------------------------------------; 4341 // The allocation is done in this strange way because ReadLeaves; 4342 // is being called many times by TTreeFormula!!!; 4343 //////////////////////////////////////////////////////////////////////////; 4344 ; 4345 Int_t i = 0;; 4346 // coverity[returned_null] the fNdata is check enough to prevent the use of null value of At(0); 4347 if( !fNdata || *(void**)proxy->At( 0 ) != nullptr ); 4348 i = fNdata;; 4349 ; 4350 for( ; i ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:159970,error,error,159970,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,1,['error'],['error']
Availability,"302 double s = std::sqrt(fChi2/fNdf);; 303 for (unsigned int i = 0; i < fErrors.size() ; ++i); 304 fErrors[i] *= s;; 305 for (unsigned int i = 0; i < fCovMatrix.size() ; ++i); 306 fCovMatrix[i] *= s2;; 307 ; 308 fNormalized = true;; 309}; 310 ; 311void FitResult::SetChi2AndNdf(double chi2, unsigned int npoints) {; 312 if (chi2 >= 0); 313 fChi2 = chi2;; 314 if (npoints > fNFree ); 315 fNdf = npoints - fNFree;; 316 else; 317 fNdf = 0;; 318}; 319 ; 320double FitResult::Prob() const {; 321 // fit probability; 322 return ROOT::Math::chisquared_cdf_c(fChi2, static_cast<double>(fNdf) );; 323}; 324 ; 325bool FitResult::HasMinosError(unsigned int i) const {; 326 // query if the parameter i has the Minos error; 327 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 328 return (itr != fMinosErrors.end() );; 329}; 330 ; 331 ; 332double FitResult::LowerError(unsigned int i) const {; 333 // return lower Minos error for parameter i; 334 // return the parabolic error if Minos error has not been calculated for the parameter i; 335 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 336 return ( itr != fMinosErrors.end() ) ? itr->second.first : Error(i) ;; 337}; 338 ; 339double FitResult::UpperError(unsigned int i) const {; 340 // return upper Minos error for parameter i; 341 // return the parabolic error if Minos error has not been calculated for the parameter i; 342 std::map<unsigned int, std::pair<double,double> >::const_iterator itr = fMinosErrors.find(i);; 343 return ( itr != fMinosErrors.end() ) ? itr->second.second : Error(i) ;; 344}; 345 ; 346void FitResult::SetMinosError(unsigned int i, double elow, double eup) {; 347 // set the Minos error for parameter i; 348 fMinosErrors[i] = std::make_pair(elow,eup);; 349}; 350 ; 351int FitResult::Index(const std::string & name) const {; 352 // find index for given parameter name; 353 if (! fFitFunc) return -1;; 354 unsigned int npar = fParams.size();; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/FitResult_8cxx_source.html:11066,error,error,11066,doc/master/FitResult_8cxx_source.html,https://root.cern,https://root.cern/doc/master/FitResult_8cxx_source.html,3,['error'],['error']
Availability,"304 TH1::LabelsDeflate(axis) with axis = ""X"", ""Y"" or ""Z""; 305~~~; 306 This operation is automatic when using TTree::Draw.; 307 Once bin labels have been created, they become persistent if the histogram; 308 is written to a file or when generating the C++ code via SavePrimitive.; 309 ; 310\anchor auto-bin; 311### Histograms with automatic bins; 312 ; 313 When a histogram is created with an axis lower limit greater or equal; 314 to its upper limit, the SetBuffer is automatically called with an; 315 argument fBufferSize equal to fgBufferSize (default value=1000).; 316 fgBufferSize may be reset via the static function TH1::SetDefaultBufferSize.; 317 The axis limits will be automatically computed when the buffer will; 318 be full or when the function BufferEmpty is called.; 319 ; 320\anchor rebinning; 321### Rebinning; 322 ; 323 At any time, a histogram can be rebinned via TH1::Rebin. This function; 324 returns a new histogram with the rebinned contents.; 325 If bin errors were stored, they are recomputed during the rebinning.; 326 ; 327 ; 328\anchor filling-histograms; 329## Filling histograms; 330 ; 331 A histogram is typically filled with statements like:; 332~~~ {.cpp}; 333 h1->Fill(x);; 334 h1->Fill(x, w); //fill with weight; 335 h2->Fill(x, y); 336 h2->Fill(x, y, w); 337 h3->Fill(x, y, z); 338 h3->Fill(x, y, z, w); 339~~~; 340 or via one of the Fill functions accepting names described above.; 341 The Fill functions compute the bin number corresponding to the given; 342 x, y or z argument and increment this bin by the given weight.; 343 The Fill functions return the bin number for 1-D histograms or global; 344 bin number for 2-D and 3-D histograms.; 345 If TH1::Sumw2 has been called before filling, the sum of squares of; 346 weights is also stored.; 347 One can also increment directly a bin number via TH1::AddBinContent; 348 or replace the existing content via TH1::SetBinContent. Passing an; 349 out-of-range bin to TH1::AddBinContent leads to undefined behavior.; 35",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:14328,error,errors,14328,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,"305 Info(""Chi2TestX"",""There is a bin in h1 with less than 1 event.\n"");; 2306 }; 2307 if (n) {; 2308 igood += 2;; 2309 Info(""Chi2TestX"",""There is a bin in h2 with less than 1 event.\n"");; 2310 }; 2311 ; 2312 Double_t prob = TMath::Prob(chi2,ndf);; 2313 return prob;; 2314 ; 2315 }; 2316 ; 2317 // unweighted - weighted comparison; 2318 // case of error = 0 and content not zero is treated without problems by excluding second chi2 sum; 2319 // and can be considered as a data-theory comparison; 2320 if ( comparisonUW ) {; 2321 for (Int_t i = i_start; i <= i_end; ++i) {; 2322 for (Int_t j = j_start; j <= j_end; ++j) {; 2323 for (Int_t k = k_start; k <= k_end; ++k) {; 2324 ; 2325 Int_t bin = GetBin(i, j, k);; 2326 ; 2327 Double_t cnt1 = RetrieveBinContent(bin);; 2328 Double_t cnt2 = h2->RetrieveBinContent(bin);; 2329 Double_t e2sq = h2->GetBinErrorSqUnchecked(bin);; 2330 ; 2331 // case both histogram have zero bin contents; 2332 if (cnt1 * cnt1 == 0 && cnt2 * cnt2 == 0) {; 2333 --ndf; //no data means one degree of freedom less; 2334 continue;; 2335 }; 2336 ; 2337 // case weighted histogram has zero bin content and error; 2338 if (cnt2 * cnt2 == 0 && e2sq == 0) {; 2339 if (sumw2 > 0) {; 2340 // use as approximated error as 1 scaled by a scaling ratio; 2341 // estimated from the total sum weight and sum weight squared; 2342 e2sq = sumw2 / sum2;; 2343 }; 2344 else {; 2345 // return error because infinite discrepancy here:; 2346 // bin1 != 0 and bin2 =0 in a histogram with all errors zero; 2347 Error(""Chi2TestX"",""Hist2 has in bin (%d,%d,%d) zero content and zero errors\n"", i, j, k);; 2348 chi2 = 0; return 0;; 2349 }; 2350 }; 2351 ; 2352 if (cnt1 < 1) m++;; 2353 if (e2sq > 0 && cnt2 * cnt2 / e2sq < 10) n++;; 2354 ; 2355 Double_t var1 = sum2 * cnt2 - sum1 * e2sq;; 2356 Double_t var2 = var1 * var1 + 4. * sum2 * sum2 * cnt1 * e2sq;; 2357 ; 2358 // if cnt1 is zero and cnt2 = 1 and sum1 = sum2 var1 = 0 && var2 == 0; 2359 // approximate by incrementing cnt1; 2360 // LM (this need to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:92870,error,error,92870,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,6,['error'],"['error', 'errors']"
Availability,"32 bits per element).Definition TArrayI.h:27; TArrayI::fArrayInt_t * fArrayDefinition TArrayI.h:30; TArrayI::Resetvoid Reset()Definition TArrayI.h:47; TArrayL64Array of long64s (64 bits per element).Definition TArrayL64.h:27; TArrayL64::fArrayLong64_t * fArrayDefinition TArrayL64.h:30; TArrayL64::Resetvoid Reset()Definition TArrayL64.h:47; TArraySArray of shorts (16 bits per element).Definition TArrayS.h:27; TArrayS::Resetvoid Reset()Definition TArrayS.h:47; TArrayS::fArrayShort_t * fArrayDefinition TArrayS.h:30; TF11-Dim function classDefinition TF1.h:233; TH1D1-D histogram with a double per channel (see TH1 documentation)Definition TH1.h:670; TH1TH1 is the base class of all histogram classes in ROOT.Definition TH1.h:59; TH1::IntegralAndErrorvirtual Double_t IntegralAndError(Int_t binx1, Int_t binx2, Double_t &err, Option_t *option="""") constReturn integral of bin contents in range [binx1,binx2] and its error.Definition TH1.cxx:7968; TH1::GetBinErrorLowvirtual Double_t GetBinErrorLow(Int_t bin) constReturn lower error associated to bin number bin.Definition TH1.cxx:9079; TH1::Integralvirtual Double_t Integral(Option_t *option="""") constReturn integral of bin contents.Definition TH1.cxx:7941; TH1::GetBinContentvirtual Double_t GetBinContent(Int_t bin) constReturn content of bin number bin.Definition TH1.cxx:5061; TH1::GetBinErrorUpvirtual Double_t GetBinErrorUp(Int_t bin) constReturn upper error associated to bin number bin.Definition TH1.cxx:9110; TH2C2-D histogram with a byte per channel (see TH1 documentation)Definition TH2.h:139; TH2C::operator*friend TH2C operator*(TH2C const &h1, Float_t c1)Definition TH2.h:166; TH2C::Resetvoid Reset(Option_t *option="""") overrideReset this histogram: contents, errors, etc.Definition TH2.cxx:2990; TH2C::AddBinContentvoid AddBinContent(Int_t binx, Int_t biny, Double_t w) overrideIncrement 2D bin content by a weight w.Definition TH2.h:159; TH2C::operator+friend TH2C operator+(TH2C const &h1, TH2C const &h2)Operator +.Definition TH2.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH2_8h_source.html:23133,error,error,23133,doc/master/TH2_8h_source.html,https://root.cern,https://root.cern/doc/master/TH2_8h_source.html,1,['error'],['error']
Availability,"328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.Atof() ;; 334 value_idx++ ;; 335 }; 336 }; 337 token = R__STRTOK_R(nullptr, option, &rest); // next token; 338 token_idx++ ;; 339 }; 340 if (!isLineToBeSkipped && value_idx > 1) { //i.e. 2,3 or 4; 341 x = value[0];; 342 y = value[1];; 343 ex = value[2];; 344 ey = value[3];; 345 SetPoint(np, x, y);; 346 SetPointError(np, ex, ey);; 347 np++ ;; 348 }; 349 }; 350 isLineToBeSkipped = kFALSE;; 351 token = nullptr;; 352 token_idx = 0;; 353 value_idx = 0;; 354 }; 355 Set(np) ;; 356 ; 357 // Cleaning; 358 delete [] isTokenToBeSaved;; 359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:12428,error,errorbars,12428,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errorbars']
Availability,32 ; kInt16 ; kUInt16 ; kInt8 ; kUInt8 ; kSplitIndex64 ; kSplitIndex32 ; kSplitReal64 ; kSplitReal32 ; kSplitInt64 ; kSplitUInt64 ; kSplitInt32 ; kSplitUInt32 ; kSplitInt16 ; kSplitUInt16 ; kReal32Trunc ; kReal32Quant ; kMax . Definition at line 72 of file RNTupleUtil.hxx. ◆ EExtraTypeInfoIds. enum class ROOT::Experimental::EExtraTypeInfoIds. strong . Used in RExtraTypeInfoDescriptor. . EnumeratorkInvalid ; kStreamerInfo . Definition at line 467 of file RNTupleDescriptor.hxx. ◆ EIOFeatures. enum class ROOT::Experimental::EIOFeatures. strong . EnumeratorkGenerateOffsetMap ; kSupported . Definition at line 52 of file TIOFeatures.hxx. ◆ EIOUnsupportedFeatures. enum class ROOT::Experimental::EIOUnsupportedFeatures. strong . EnumeratorkUnsupported . Definition at line 61 of file TIOFeatures.hxx. ◆ ELogLevel. enum class ROOT::Experimental::ELogLevel : unsigned char. strong . Kinds of diagnostics. . EnumeratorkUnset ; kFatal An error which causes further processing to be unreliable. . kError An error. . kWarning Warnings about likely unexpected behavior. . kInfo Informational messages; used for instance for tracing. . kDebug Debug information; only useful for developers; can have added verbosity up to 255-kDebug. . Definition at line 36 of file RLogger.hxx. ◆ ENTupleInfo. enum class ROOT::Experimental::ENTupleInfo. strong . Listing of the different options that can be printed by RNTupleReader::GetInfo() . EnumeratorkSummary ; kStorageDetails ; kMetrics . Definition at line 43 of file RNTupleReader.hxx. ◆ ENTupleInspectorHist. enum class ROOT::Experimental::ENTupleInspectorHist. strong . EnumeratorkCount ; kNElems ; kCompressedSize ; kUncompressedSize . Definition at line 43 of file RNTupleInspector.hxx. ◆ ENTupleInspectorPrintFormat. enum class ROOT::Experimental::ENTupleInspectorPrintFormat. strong . EnumeratorkTable ; kCSV . Definition at line 42 of file RNTupleInspector.hxx. ◆ ENTupleStructure. enum ROOT::Experimental::ENTupleStructure : std::uint16_t. The fields in the ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html:42048,error,error,42048,doc/master/namespaceROOT_1_1Experimental.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Experimental.html,1,['error'],['error']
Availability,"33 else if (special == 200) ROOT::Fit::InitExpo (*fitdata, f1); // exponential; 234 ; 235 }; 236 ; 237 ; 238 // set the fit function; 239 // if option grad is specified use gradient; 240 if ( (linear || fitOption.Gradient) ); 241 fitter->SetFunction(ROOT::Math::WrappedMultiTF1(*f1));; 242#ifdef R__HAS_VECCORE; 243 else if(f1->IsVectorized()); 244 fitter->SetFunction(static_cast<const ROOT::Math::IParamMultiFunctionTempl<ROOT::Double_v> &>(ROOT::Math::WrappedMultiTF1Templ<ROOT::Double_v>(*f1)));; 245#endif; 246 else; 247 fitter->SetFunction(static_cast<const ROOT::Math::IParamMultiFunction &>(ROOT::Math::WrappedMultiTF1(*f1) ) );; 248 ; 249 // error normalization in case of zero error in the data; 250 if (fitdata->GetErrorType() == ROOT::Fit::BinData::kNoError) fitConfig.SetNormErrors(true);; 251 // error normalization also in case of W or WW options (weights = 1); 252 if (fitdata->Opt().fErrors1) fitConfig.SetNormErrors(true);; 253 // normalize errors also in case you are fitting a Ndim histo with a N-1 function; 254 if (int(fitdata->NDim()) == hdim -1 ) fitConfig.SetNormErrors(true);; 255 ; 256 ; 257 // here need to get some static extra information (like max iterations, error def, etc...); 258 ; 259 ; 260 // parameter settings and transfer the parameters values, names and limits from the functions; 261 // is done automatically in the Fitter.cxx; 262 for (int i = 0; i < npar; ++i) {; 263 ROOT::Fit::ParameterSettings & parSettings = fitConfig.ParSettings(i);; 264 ; 265 // check limits; 266 double plow,pup;; 267 f1->GetParLimits(i,plow,pup);; 268 if (plow*pup != 0 && plow >= pup) { // this is a limitation - cannot fix a parameter to zero value; 269 parSettings.Fix();; 270 }; 271 else if (plow < pup ) {; 272 if (!TMath::Finite(pup) && TMath::Finite(plow) ); 273 parSettings.SetLowerLimit(plow);; 274 else if (!TMath::Finite(plow) && TMath::Finite(pup) ); 275 parSettings.SetUpperLimit(pup);; 276 else; 277 parSettings.SetLimits(plow,pup);; 278 }; 279 ; 280 // set the param",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitImpl_8cxx_source.html:9800,error,errors,9800,doc/master/HFitImpl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitImpl_8cxx_source.html,1,['error'],['errors']
Availability,33 if (fEZ) return fEZ[i];; 234 return -1;; 235}; 236 ; 237 ; 238////////////////////////////////////////////////////////////////////////////////; 239/// Returns the X maximum with errors.; 240 ; 241Double_t TGraph2DErrors::GetXmaxE() const; 242{; 243 Double_t v = fX[0]+fEX[0];; 244 for (Int_t i=1; i<fNpoints; i++) if (fX[i]+fEX[i]>v) v=fX[i]+fEX[i];; 245 return v;; 246}; 247 ; 248 ; 249////////////////////////////////////////////////////////////////////////////////; 250/// Returns the X minimum with errors.; 251 ; 252Double_t TGraph2DErrors::GetXminE() const; 253{; 254 Double_t v = fX[0]-fEX[0];; 255 for (Int_t i=1; i<fNpoints; i++) if (fX[i]-fEX[i]<v) v=fX[i]-fEX[i];; 256 return v;; 257}; 258 ; 259 ; 260////////////////////////////////////////////////////////////////////////////////; 261/// Returns the Y maximum with errors.; 262 ; 263Double_t TGraph2DErrors::GetYmaxE() const; 264{; 265 Double_t v = fY[0]+fEY[0];; 266 for (Int_t i=1; i<fNpoints; i++) if (fY[i]+fEY[i]>v) v=fY[i]+fEY[i];; 267 return v;; 268}; 269 ; 270 ; 271////////////////////////////////////////////////////////////////////////////////; 272/// Returns the Y minimum with errors.; 273 ; 274Double_t TGraph2DErrors::GetYminE() const; 275{; 276 Double_t v = fY[0]-fEY[0];; 277 for (Int_t i=1; i<fNpoints; i++) if (fY[i]-fEY[i]<v) v=fY[i]-fEY[i];; 278 return v;; 279}; 280 ; 281 ; 282////////////////////////////////////////////////////////////////////////////////; 283/// Returns the Z maximum with errors.; 284 ; 285Double_t TGraph2DErrors::GetZmaxE() const; 286{; 287 Double_t v = fZ[0]+fEZ[0];; 288 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]+fEZ[i]>v) v=fZ[i]+fEZ[i];; 289 return v;; 290}; 291 ; 292 ; 293////////////////////////////////////////////////////////////////////////////////; 294/// Returns the Z minimum with errors.; 295 ; 296Double_t TGraph2DErrors::GetZminE() const; 297{; 298 Double_t v = fZ[0]-fEZ[0];; 299 for (Int_t i=1; i<fNpoints; i++) if (fZ[i]-fEZ[i]<v) v=fZ[i]-fEZ[i];; 300 return v;; 301}; 3,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html:7961,error,errors,7961,doc/master/TGraph2DErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraph2DErrors_8cxx_source.html,1,['error'],['errors']
Availability,34 43754.9 1; : 713 | 27.878 27.4183 0.0200281 0.0017564 43783.5 2; : 714 | 27.4734 27.8632 0.020054 0.00175612 43720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.0149 24.223 0.0201139 0.00181842 43726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.6778 23.9945 0.0201044 0.00181062 43730.7 0; : 730 | 22.455 23.9981 0.020057 0.0017578 43717.8 1; : 731 Minimum Test error found - save the configuration ; : 731 | 22.3369 23.5918 0.0200927 0.00181127 43760.4 0; : 732 | 21.8719 23.7484 0.0200451 0.00175548 43740.6 1; : 733 Minimum Test error found - save the configuration ; : 733 | 21.6244 23.3245 0.0201038 0.00181384 43739.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:91352,error,error,91352,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"34 DEBUG_TRACE_FUNC(__func__, __LINE__, fmt, __VA_ARGS__); 235 ; 236#define NEED_DEBUG_TRACE_FUNC; 237#if !defined(DEBUG_TRACE_STREAM); 238#define DEBUG_TRACE_STREAM stdout; 239#endif; 240 ; 241#else; 242#define DEBUG_TRACE(fmt, ...) \; 243 do { \; 244 } while (0); 245#endif /* DEBUG */; 246#endif /* DEBUG_TRACE */; 247 ; 248 ; 249#if !defined(DEBUG_ASSERT); 250#if defined(DEBUG); 251#include <stdlib.h>; 252#define DEBUG_ASSERT(cond) \; 253 do { \; 254 if (!(cond)) { \; 255 DEBUG_TRACE(""ASSERTION FAILED: %s"", #cond); \; 256 exit(2); /* Exit with error */ \; 257 } \; 258 } while (0); 259#else; 260#define DEBUG_ASSERT(cond); 261#endif /* DEBUG */; 262#endif; 263 ; 264 ; 265#if defined(__GNUC__) && defined(GCC_INSTRUMENTATION); 266void __cyg_profile_func_enter(void *this_fn, void *call_site); 267 __attribute__((no_instrument_function));; 268 ; 269void __cyg_profile_func_exit(void *this_fn, void *call_site); 270 __attribute__((no_instrument_function));; 271 ; 272void; 273__cyg_profile_func_enter(void *this_fn, void *call_site); 274{; 275 if ((void *)this_fn != (void *)printf) {; 276 printf(""E %p %p\n"", this_fn, call_site);; 277 }; 278}; 279 ; 280void; 281__cyg_profile_func_exit(void *this_fn, void *call_site); 282{; 283 if ((void *)this_fn != (void *)printf) {; 284 printf(""X %p %p\n"", this_fn, call_site);; 285 }; 286}; 287#endif; 288 ; 289 ; 290#if !defined(IGNORE_UNUSED_RESULT); 291#define IGNORE_UNUSED_RESULT(a) ((void)((a) && 1)); 292#endif; 293 ; 294 ; 295#if defined(__GNUC__) || defined(__MINGW32__); 296 ; 297/* GCC unused function attribute seems fundamentally broken.; 298 * Several attempts to tell the compiler ""THIS FUNCTION MAY BE USED; 299 * OR UNUSED"" for individual functions failed.; 300 * Either the compiler creates an ""unused-function"" warning if a; 301 * function is not marked with __attribute__((unused)).; 302 * On the other hand, if the function is marked with this attribute,; 303 * but is used, the compiler raises a completely idiotic; 304 * ""used-but-",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:9745,error,error,9745,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['error'],['error']
Availability,"34),1234)\n"");; 3433 fprintf(fmk, ""ifeq ($(MACOSX_MINOR),4)\n"");; 3434 fprintf(fmk, ""\t\tln -sf $@ $(subst .$(DllSuf),.so,$@)\n"");; 3435 fprintf(fmk, ""else\n"");; 3436 fprintf(fmk, ""\t\t$(LD) -bundle -undefined $(UNDEFOPT) $(LDFLAGS) $^ \\\n"");; 3437 fprintf(fmk, ""\t\t $(OutPutOpt) $(subst .$(DllSuf),.so,$@)\n"");; 3438 fprintf(fmk, ""endif\n"");; 3439 fprintf(fmk, ""endif\n"");; 3440 fprintf(fmk, ""else\n"");; 3441 fprintf(fmk, ""ifeq ($(PLATFORM),win32)\n"");; 3442 fprintf(fmk, ""\t\tbindexplib $* $^ > $*.def\n"");; 3443 fprintf(fmk, ""\t\tlib -nologo -MACHINE:IX86 $^ -def:$*.def \\\n"");; 3444 fprintf(fmk, ""\t\t $(OutPutOpt)$(PACKLIB)\n"");; 3445 fprintf(fmk, ""\t\t$(LD) $(SOFLAGS) $(LDFLAGS) $^ $*.exp $(LIBS) \\\n"");; 3446 fprintf(fmk, ""\t\t $(OutPutOpt)$@\n"");; 3447 fprintf(fmk, ""else\n"");; 3448 fprintf(fmk, ""\t\t$(LD) $(SOFLAGS) $(LDFLAGS) $^ $(OutPutOpt) $@ $(LIBS) $(EXPLLINKLIBS)\n"");; 3449 fprintf(fmk, ""endif\n"");; 3450 fprintf(fmk, ""endif\n"");; 3451 fprintf(fmk, ""endif\n"");; 3452 fprintf(fmk, ""endif\n"");; 3453 fprintf(fmk, ""\t\t@echo \""$@ done\""\n"");; 3454 fprintf(fmk, ""\n"");; 3455 fprintf(fmk, ""clean:\n"");; 3456 fprintf(fmk, ""\t\t@rm -f $(OBJS) core\n"");; 3457 fprintf(fmk, ""\n"");; 3458 fprintf(fmk, ""distclean: clean\n"");; 3459 fprintf(fmk, ""\t\t@rm -f $(PROGRAMS) $(PACKSO) $(PACKLIB) *Dict.* *.def *.exp \\\n"");; 3460 fprintf(fmk, ""\t\t *.so *.lib *.dll *.d *.log .def so_locations\n"");; 3461 fprintf(fmk, ""\t\t@rm -rf cxx_repository\n"");; 3462 fprintf(fmk, ""\n"");; 3463 fprintf(fmk, ""# Dependencies\n"");; 3464 fprintf(fmk, ""\n"");; 3465 fprintf(fmk, ""%sProjectSource.$(ObjSuf): %sProjectHeaders.h %sLinkDef.h %sProjectDict.$(SrcSuf)\n"", pack, pack, pack, pack);; 3466 fprintf(fmk, ""\n"");; 3467 fprintf(fmk, ""%sProjectDict.$(SrcSuf): %sProjectHeaders.h %sLinkDef.h\n"", pack, pack, pack);; 3468 fprintf(fmk, ""\t\t@echo \""Generating dictionary $@...\""\n"");; 3469 fprintf(fmk, ""\t\t@rootcint -f $@ $^\n"");; 3470 fprintf(fmk, ""\n"");; 3471 fprintf(fmk, "".$(SrcSuf).$(ObjSuf):\n"");; 3472 fpri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:125349,echo,echo,125349,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['echo'],['echo']
Availability,"3444 ; 3445 inLogEvalError = false ;; 3446}; 3447 ; 3448 ; 3449 ; 3450////////////////////////////////////////////////////////////////////////////////; 3451/// Log evaluation error message. Evaluation errors may be routed through a different; 3452/// protocol than generic RooFit warning message (which go straight through RooMsgService); 3453/// because evaluation errors can occur in very large numbers in the use of likelihood; 3454/// evaluations. In logEvalError mode, controlled by global method enableEvalErrorLogging(); 3455/// messages reported through this function are not printed but all stored in a list,; 3456/// along with server values at the time of reporting. Error messages logged in this; 3457/// way can be printed in a structured way, eliminating duplicates and with the ability; 3458/// to truncate the list by printEvalErrors. This is the standard mode of error logging; 3459/// during MINUIT operations. If enableEvalErrorLogging() is false, all errors; 3460/// reported through this method are passed for immediate printing through RooMsgService.; 3461/// A string with server names and values is constructed automatically for error logging; 3462/// purposes, unless a custom string with similar information is passed as argument.; 3463 ; 3464void RooAbsReal::logEvalError(const char* message, const char* serverValueString) const; 3465{; 3466 if (evalErrorData().mode == Ignore) {; 3467 return ;; 3468 }; 3469 ; 3470 if (evalErrorData().mode == CountErrors) {; 3471 evalErrorData().count++ ;; 3472 return ;; 3473 }; 3474 ; 3475 static bool inLogEvalError = false ;; 3476 ; 3477 if (inLogEvalError) {; 3478 return ;; 3479 }; 3480 inLogEvalError = true ;; 3481 ; 3482 EvalError ee ;; 3483 ee.setMessage(message) ;; 3484 ; 3485 if (serverValueString) {; 3486 ee.setServerValues(serverValueString) ;; 3487 } else {; 3488 std::string srvval ;; 3489 std::ostringstream oss ;; 3490 bool first(true) ;; 3491 for (Int_t i=0 ; i<numProxies() ; i++) {; 3492 RooAbsProxy* p = getProxy(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:148472,error,errors,148472,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['error'],['errors']
Availability,"3528 else {; 3529 // For the non system libs, we'd like to be able to unload them.; 3530 // FIXME: Here we lose the information about kLoadLibAlreadyLoaded case.; 3531 cling::Interpreter::CompilationResult compRes;; 3532 HandleInterpreterException(GetMetaProcessorImpl(), Form("".L %s"", canonLib.c_str()), compRes, /*cling::Value*/nullptr);; 3533 if (compRes == cling::Interpreter::kSuccess); 3534 res = cling::DynamicLibraryManager::kLoadLibSuccess;; 3535 }; 3536 }; 3537 ; 3538 if (res == cling::DynamicLibraryManager::kLoadLibSuccess) {; 3539 UpdateListOfLoadedSharedLibraries();; 3540 }; 3541 switch (res) {; 3542 case cling::DynamicLibraryManager::kLoadLibSuccess: return 0;; 3543 case cling::DynamicLibraryManager::kLoadLibAlreadyLoaded: return 1;; 3544 default: break;; 3545 };; 3546 return -1;; 3547}; 3548 ; 3549////////////////////////////////////////////////////////////////////////////////; 3550/// Load a macro file in cling's memory.; 3551 ; 3552void TCling::LoadMacro(const char* filename, EErrorCode* error); 3553{; 3554 ProcessLine(Form("".L %s"", filename), error);; 3555}; 3556 ; 3557////////////////////////////////////////////////////////////////////////////////; 3558/// Let cling process a command line asynch.; 3559 ; 3560Longptr_t TCling::ProcessLineAsynch(const char* line, EErrorCode* error); 3561{; 3562 return ProcessLine(line, error);; 3563}; 3564 ; 3565////////////////////////////////////////////////////////////////////////////////; 3566/// Let cling process a command line synchronously, i.e we are waiting; 3567/// it will be finished.; 3568 ; 3569Longptr_t TCling::ProcessLineSynch(const char* line, EErrorCode* error); 3570{; 3571 R__LOCKGUARD_CLING(fLockProcessLine ? gInterpreterMutex : nullptr);; 3572 if (gApplication) {; 3573 if (gApplication->IsCmdThread()) {; 3574 return ProcessLine(line, error);; 3575 }; 3576 return 0;; 3577 }; 3578 return ProcessLine(line, error);; 3579}; 3580 ; 3581////////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:138241,error,error,138241,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['error'],['error']
Availability,"356 va_list ap;; 4357 int has_body;; 4358 ; 4359#if !defined(NO_FILESYSTEMS); 4360 char path_buf[UTF8_PATH_MAX];; 4361 int len, i, page_handler_found, scope, truncated;; 4362 const char *error_handler = NULL;; 4363 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4364 const char *error_page_file_ext, *tstr;; 4365#endif /* NO_FILESYSTEMS */; 4366 int handled_by_callback = 0;; 4367 ; 4368 if ((conn == NULL) || (fmt == NULL)) {; 4369 return -2;; 4370 }; 4371 ; 4372 /* Set status (for log) */; 4373 conn->status_code = status;; 4374 ; 4375 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4376 has_body = ((status > 199) && (status != 204) && (status != 304));; 4377 ; 4378 /* Prepare message in buf, if required */; 4379 if (has_body; 4380 || (!conn->in_error_handler; 4381 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4382 /* Store error message in errmsg_buf */; 4383 va_copy(ap, args);; 4384 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4385 va_end(ap);; 4386 /* In a debug build, print all html errors */; 4387 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4388 }; 4389 ; 4390 /* If there is a http_error callback, call it.; 4391 * But don't do it recursively, if callback calls mg_send_http_error again.; 4392 */; 4393 if (!conn->in_error_handler; 4394 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4395 /* Mark in_error_handler to avoid recursion and call user callback. */; 4396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:130867,error,error,130867,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"357 va_list ap;; 4358 int has_body;; 4359 ; 4360#if !defined(NO_FILESYSTEMS); 4361 char path_buf[UTF8_PATH_MAX];; 4362 int len, i, page_handler_found, scope, truncated;; 4363 const char *error_handler = NULL;; 4364 struct mg_file error_page_file = STRUCT_FILE_INITIALIZER;; 4365 const char *error_page_file_ext, *tstr;; 4366#endif /* NO_FILESYSTEMS */; 4367 int handled_by_callback = 0;; 4368 ; 4369 if ((conn == NULL) || (fmt == NULL)) {; 4370 return -2;; 4371 }; 4372 ; 4373 /* Set status (for log) */; 4374 conn->status_code = status;; 4375 ; 4376 /* Errors 1xx, 204 and 304 MUST NOT send a body */; 4377 has_body = ((status > 199) && (status != 204) && (status != 304));; 4378 ; 4379 /* Prepare message in buf, if required */; 4380 if (has_body; 4381 || (!conn->in_error_handler; 4382 && (conn->phys_ctx->callbacks.http_error != NULL))) {; 4383 /* Store error message in errmsg_buf */; 4384 va_copy(ap, args);; 4385 mg_vsnprintf(conn, NULL, errmsg_buf, sizeof(errmsg_buf), fmt, ap);; 4386 va_end(ap);; 4387 /* In a debug build, print all html errors */; 4388 DEBUG_TRACE(""Error %i - [%s]"", status, errmsg_buf);; 4389 }; 4390 ; 4391 /* If there is a http_error callback, call it.; 4392 * But don't do it recursively, if callback calls mg_send_http_error again.; 4393 */; 4394 if (!conn->in_error_handler; 4395 && (conn->phys_ctx->callbacks.http_error != NULL)) {; 4396 /* Mark in_error_handler to avoid recursion and call user callback. */; 4397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:130899,error,error,130899,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['error'],"['error', 'errors']"
Availability,"359 delete token;; 360 }; 361 infile.close();; 362}; 363 ; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// TGraphErrors default destructor.; 367 ; 368TGraphErrors::~TGraphErrors(); 369{; 370 delete [] fEX;; 371 delete [] fEY;; 372}; 373 ; 374////////////////////////////////////////////////////////////////////////////////; 375/// Add a point with errorbars to the graph.; 376 ; 377void TGraphErrors::AddPointError(Double_t x, Double_t y, Double_t ex, Double_t ey); 378{; 379 AddPoint(x, y); // fNpoints will increase automatically; 380 SetPointError(fNpoints - 1, ex, ey);; 381}; 382 ; 383////////////////////////////////////////////////////////////////////////////////; 384/// Apply function to all the data points \f$ y = f(x,y) \f$.; 385///; 386/// The error is calculated as \f$ ey=(f(x,y+ey)-f(x,y-ey))/2 \f$.; 387/// This is the same as \f$ error(fy) = df/dy * ey \f$ for small errors.; 388///; 389/// For generic functions the symmetric errors might become non-symmetric; 390/// and are averaged here. Use TGraphAsymmErrors if desired.; 391///; 392/// Error on \f$ x \f$ doesn't change.; 393///; 394/// function suggested/implemented by Miroslav Helbich <helbich@mail.desy.de>; 395 ; 396void TGraphErrors::Apply(TF1 *f); 397{; 398 Double_t x, y, ex, ey;; 399 ; 400 if (fHistogram) {; 401 delete fHistogram;; 402 fHistogram = nullptr;; 403 }; 404 for (Int_t i = 0; i < GetN(); i++) {; 405 GetPoint(i, x, y);; 406 ex = GetErrorX(i);; 407 ey = GetErrorY(i);; 408 ; 409 SetPoint(i, x, f->Eval(x, y));; 410 SetPointError(i, ex, TMath::Abs(f->Eval(x, y + ey) - f->Eval(x, y - ey)) / 2.);; 411 }; 412 if (gPad) gPad->Modified();; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Apply function to all the data points \f$ x = f(x,y) \f$.; 417///; 418/// The error is calculated as \f$ ex=(f(x+ex,y)-f(x-ex,y))/2 \f$.; 419/// This is the same as \f$ error(fx) = df/dx * ex \f$ for small errors.; 4",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:13025,error,errors,13025,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['errors']
Availability,"36 gSystem->Exec(""chmod +x MAKEP"");; 3337 int res = !gSystem->Exec(""./MAKEP"");; 3338#else; 3339 // not really needed for Windows but it would work both both Unix and NT; 3340 chmod(""makep.cmd"",00700);; 3341 int res = !gSystem->Exec(""MAKEP"");; 3342#endif; 3343 gSystem->ChangeDirectory(path);; 3344 path.Form(""%s/%s.%s"",clean_dirname.Data(),subdirname.Data(),gSystem->GetSoExt());; 3345 if (res) printf(""Shared lib %s has been generated\n"",path.Data());; 3346 ; 3347 //dynamically link the generated shared lib; 3348 if (opt.Contains(""++"")) {; 3349 res = !gSystem->Load(path);; 3350 if (res) printf(""Shared lib %s has been dynamically linked\n"",path.Data());; 3351 }; 3352 }; 3353 ; 3354 delete list;; 3355 filelist->Delete();; 3356 delete filelist;; 3357}; 3358 ; 3359////////////////////////////////////////////////////////////////////////////////; 3360/// Create makefile at 'filemake' for PAR package 'pack'.; 3361///; 3362/// Called by MakeProject when option 'par' is given.; 3363/// Return 0 on success, -1 on error.; 3364 ; 3365Int_t TFile::MakeProjectParMake(const char *pack, const char *filemake); 3366{; 3367 // Output file path must be defined; 3368 if (!filemake || (filemake && strlen(filemake) <= 0)) {; 3369 Error(""MakeProjectParMake"", ""path for output file undefined!"");; 3370 return -1;; 3371 }; 3372 ; 3373 // Package name must be defined; 3374 if (!pack || (pack && strlen(pack) <= 0)) {; 3375 Error(""MakeProjectParMake"", ""package name undefined!"");; 3376 return -1;; 3377 }; 3378 ; 3379#ifdef R__WINGCC; 3380 FILE *fmk = fopen(filemake, ""wb"");; 3381#else; 3382 FILE *fmk = fopen(filemake, ""w"");; 3383#endif; 3384 if (!fmk) {; 3385 Error(""MakeProjectParMake"", ""cannot create file '%s' (errno: %d)"", filemake, TSystem::GetErrno());; 3386 return -1;; 3387 }; 3388 ; 3389 // Fill the file now; 3390 fprintf(fmk, ""# Makefile for the ROOT test programs.\n"");; 3391 fprintf(fmk, ""# This Makefile shows how to compile and link applications\n"");; 3392 fprintf(fmk, ""# using the ROOT librar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:121283,error,error,121283,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['error'],['error']
Availability,"360 if (m == 1) {; 361 p1 = pa;; 362 p2 = na;; 363 p3 = ma;; 364 } else if (m == 2) {; 365 p1 = pa;; 366 p2 = ma;; 367 p3 = na;; 368 } else if (m == 3) {; 369 p1 = na;; 370 p2 = ma;; 371 p3 = pa;; 372 }; 373 // get the coordinates of the centre of this side; 374 xm = (fXN[p1]+fXN[p2])/2.;; 375 ym = (fYN[p1]+fYN[p2])/2.;; 376 // we want to add a little to these coordinates to get a point just; 377 // outside the triangle; (sx,sy) will be the vector that represents; 378 // the side; 379 sx = fXN[p1]-fXN[p2];; 380 sy = fYN[p1]-fYN[p2];; 381 // (nx,ny) will be the normal to the side, but don't know if it's; 382 // pointing in or out yet; 383 nx = sy;; 384 ny = -sx;; 385 nn = TMath::Sqrt(nx*nx+ny*ny);; 386 nx = nx/nn;; 387 ny = ny/nn;; 388 mx = fXN[p3]-xm;; 389 my = fYN[p3]-ym;; 390 mdotn = mx*nx+my*ny;; 391 if (mdotn > 0) {; 392 // (nx,ny) is pointing in, we want it pointing out; 393 nx = -nx;; 394 ny = -ny;; 395 }; 396 // increase/decrease xm and ym a little to produce a point; 397 // just outside the triangle (ensuring that the amount added will; 398 // be large enough such that it won't be lost in rounding errors); 399 a = TMath::Abs(TMath::Max(alittlebit*xm,alittlebit*ym));; 400 xx = xm+nx*a;; 401 yy = ym+ny*a;; 402 // try and find a new Delaunay triangle for this point; 403 Interpolate(xx,yy);; 404 ; 405 // this side of t1 should now, hopefully, if it's not part of the; 406 // hull, be shared with a new Delaunay triangle just calculated by Interpolate; 407 }; 408 }; 409 t1++;; 410 }; 411}; 412 ; 413 ; 414////////////////////////////////////////////////////////////////////////////////; 415/// Finds those points which make up the convex hull of the set. If the xy; 416/// plane were a sheet of wood, and the points were nails hammered into it; 417/// at the respective coordinates, then if an elastic band were stretched; 418/// over all the nails it would form the shape of the convex hull. Those; 419/// nails in contact with it are the points that make up the hull.; 420",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html:13482,error,errors,13482,doc/master/TGraphDelaunay_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8cxx_source.html,1,['error'],['errors']
Availability,"369 : TGraph(np, x, y), fNYErrors(ne), fSumErrorsMode(m); 370{; 371 if (!CtorAllocate()); 372 return;; 373 ; 374 Int_t n = fNpoints * sizeof(Double_t);; 375 ; 376 if (exL); 377 memcpy(fExL, exL, n);; 378 else; 379 memset(fExL, 0, n);; 380 if (exH); 381 memcpy(fExH, exH, n);; 382 else; 383 memset(fExH, 0, n);; 384 ; 385 for (Int_t i = 0; i < fNpoints; i++) {; 386 for (Int_t j = 0; j < fNYErrors; j++) {; 387 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 388 fEyL[j][i] = eyL[j][i];; 389 else; 390 fEyL[j][i] = 0.;; 391 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 392 fEyH[j][i] = eyH[j][i];; 393 else; 394 fEyH[j][i] = 0.;; 395 }; 396 }; 397 ; 398 CalcYErrorsSum();; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TG",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:14453,error,errors,14453,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['errors']
Availability,"37 of file TH1.cxx. ◆ SavePrimitiveHelp(). void TH1::SavePrimitiveHelp ; (; std::ostream & ; out, . const char * ; hname, . Option_t * ; option = """" . ). protectedvirtual . Helper function for the SavePrimitive functions from TH1 or classes derived from TH1, eg TProfile, TProfile2D. ; Definition at line 7379 of file TH1.cxx. ◆ Scale(). void TH1::Scale ; (; Double_t ; c1 = 1, . Option_t * ; option = """" . ). virtual . Multiply this histogram by a constant c1. ; this = c1*this; Note that both contents and errors (if any) are scaled. This function uses the services of TH1::Add; IMPORTANT NOTE: Sumw2() is called automatically when scaling. If you are not interested in the histogram statistics you can call Sumw2(kFALSE) or use the option ""nosw2""; One can scale a histogram such that the bins integral is equal to the normalization parameter via TH1::Scale(Double_t norm), where norm is the desired normalization divided by the integral of the histogram.; If option contains ""width"" the bin contents and errors are divided by the bin width. ; Reimplemented in TH2Poly, TProfile, TProfile2D, and TProfile3D.; Definition at line 6604 of file TH1.cxx. ◆ SetAxisColor(). void TH1::SetAxisColor ; (; Color_t ; color = 1, . Option_t * ; axis = ""X"" . ). virtual . Set color to draw the axis line and tick marks. ; axis specifies which axis (""x"",""y"",""z""), default = ""x"" if axis=""xyz"" set all 3 axes ; Definition at line 187 of file Haxis.cxx. ◆ SetAxisRange(). void TH1::SetAxisRange ; (; Double_t ; xmin, . Double_t ; xmax, . Option_t * ; axis = ""X"" . ). virtual . Set the ""axis"" range. ; Definition at line 201 of file Haxis.cxx. ◆ SetBarOffset(). void TH1::SetBarOffset ; (; Float_t ; offset = 0.25). inlinevirtual . Set the bar offset as fraction of the bin width for drawing mode ""B"". ; This shifts bars to the right on the x axis, and helps to draw bars next to each other. See alsoTHistPainter, SetBarWidth() ; Definition at line 364 of file TH1.h. ◆ SetBarWidth(). void TH1::SetBarWidth ; (; Float",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:201460,error,errors,201460,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['errors']
Availability,"37///Return integral of bin contents. Only bins in the bins range are considered.; 7938///; 7939/// By default the integral is computed as the sum of bin contents in the range.; 7940/// if option ""width"" is specified, the integral is the sum of; 7941/// the bin contents multiplied by the bin width in x.; 7942 ; 7943Double_t TH1::Integral(Option_t *option) const; 7944{; 7945 return Integral(fXaxis.GetFirst(),fXaxis.GetLast(),option);; 7946}; 7947 ; 7948////////////////////////////////////////////////////////////////////////////////; 7949/// Return integral of bin contents in range [binx1,binx2].; 7950///; 7951/// By default the integral is computed as the sum of bin contents in the range.; 7952/// if option ""width"" is specified, the integral is the sum of; 7953/// the bin contents multiplied by the bin width in x.; 7954 ; 7955Double_t TH1::Integral(Int_t binx1, Int_t binx2, Option_t *option) const; 7956{; 7957 double err = 0;; 7958 return DoIntegral(binx1,binx2,0,-1,0,-1,err,option);; 7959}; 7960 ; 7961////////////////////////////////////////////////////////////////////////////////; 7962/// Return integral of bin contents in range [binx1,binx2] and its error.; 7963///; 7964/// By default the integral is computed as the sum of bin contents in the range.; 7965/// if option ""width"" is specified, the integral is the sum of; 7966/// the bin contents multiplied by the bin width in x.; 7967/// the error is computed using error propagation from the bin errors assuming that; 7968/// all the bins are uncorrelated; 7969 ; 7970Double_t TH1::IntegralAndError(Int_t binx1, Int_t binx2, Double_t & error, Option_t *option) const; 7971{; 7972 return DoIntegral(binx1,binx2,0,-1,0,-1,error,option,kTRUE);; 7973}; 7974 ; 7975////////////////////////////////////////////////////////////////////////////////; 7976/// Internal function compute integral and optionally the error between the limits; 7977/// specified by the bin number values working for all histograms (1D, 2D and 3D); 7978 ; 7979",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:312236,error,error,312236,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['error']
Availability,3720.8 3; : 715 Minimum Test error found - save the configuration ; : 715 | 27.1251 26.6487 0.0201232 0.0018277 43726.6 0; : 716 | 26.6302 26.7712 0.0200343 0.00176196 43782.1 1; : 717 Minimum Test error found - save the configuration ; : 717 | 26.542 26.4691 0.020103 0.00182338 43764.7 0; : 718 Minimum Test error found - save the configuration ; : 718 | 25.9613 26.206 0.0200958 0.00181915 43771.6 0; : 719 Minimum Test error found - save the configuration ; : 719 | 25.6965 25.7845 0.0200932 0.00181887 43777.1 0; : 720 Minimum Test error found - save the configuration ; : 720 | 25.279 25.7029 0.0200856 0.00181582 43788.1 0; : 721 | 24.9296 25.8529 0.0200326 0.00176051 43782.6 1; : 722 | 24.8179 25.9725 0.0200485 0.0017542 43729.4 2; : 723 Minimum Test error found - save the configuration ; : 723 | 24.602 25.0488 0.0200826 0.00181241 43787.1 0; : 724 Minimum Test error found - save the configuration ; : 724 | 24.1724 25.032 0.0200931 0.00180717 43749.4 0; : 725 Minimum Test error found - save the configuration ; : 725 | 23.8272 24.7604 0.0201019 0.00180745 43729.1 0; : 726 Minimum Test error found - save the configuration ; : 726 | 23.3507 24.439 0.0200878 0.00180894 43766.5 0; : 727 | 23.4129 26.1943 0.0200349 0.00176004 43776.1 1; : 728 Minimum Test error found - save the configuration ; : 728 | 23.0149 24.223 0.0201139 0.00181842 43726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.6778 23.9945 0.0201044 0.00181062 43730.7 0; : 730 | 22.455 23.9981 0.020057 0.0017578 43717.8 1; : 731 Minimum Test error found - save the configuration ; : 731 | 22.3369 23.5918 0.0200927 0.00181127 43760.4 0; : 732 | 21.8719 23.7484 0.0200451 0.00175548 43740.6 1; : 733 Minimum Test error found - save the configuration ; : 733 | 21.6244 23.3245 0.0201038 0.00181384 43739.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:91465,error,error,91465,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,3726.6 0; : 729 Minimum Test error found - save the configuration ; : 729 | 22.6778 23.9945 0.0201044 0.00181062 43730.7 0; : 730 | 22.455 23.9981 0.020057 0.0017578 43717.8 1; : 731 Minimum Test error found - save the configuration ; : 731 | 22.3369 23.5918 0.0200927 0.00181127 43760.4 0; : 732 | 21.8719 23.7484 0.0200451 0.00175548 43740.6 1; : 733 Minimum Test error found - save the configuration ; : 733 | 21.6244 23.3245 0.0201038 0.00181384 43739.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test error found - save the configuration ; : 736 | 20.9485 22.9069 0.0201996 0.00182864 43547 0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:92819,error,error,92819,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,3730.7 0; : 730 | 22.455 23.9981 0.020057 0.0017578 43717.8 1; : 731 Minimum Test error found - save the configuration ; : 731 | 22.3369 23.5918 0.0200927 0.00181127 43760.4 0; : 732 | 21.8719 23.7484 0.0200451 0.00175548 43740.6 1; : 733 Minimum Test error found - save the configuration ; : 733 | 21.6244 23.3245 0.0201038 0.00181384 43739.9 0; : 734 | 21.7205 24.0895 0.02004 0.0017539 43749.1 1; : 735 Minimum Test error found - save the configuration ; : 735 | 21.2911 23.0542 0.0200889 0.00181051 43767.5 0; : 736 Minimum Test error found - save the configuration ; : 736 | 20.9485 22.9069 0.0201996 0.00182864 43547 0; : 737 Minimum Test error found - save the configuration ; : 737 | 20.4393 22.6213 0.0200735 0.00180745 43797.2 0; : 738 Minimum Test error found - save the configuration ; : 738 | 20.2862 22.4457 0.0201199 0.00181602 43706.6 0; : 739 Minimum Test error found - save the configuration ; : 739 | 20.1208 22.4048 0.0200963 0.00181207 43753.7 0; : 740 Minimum Test error found - save the configuration ; : 740 | 19.913 22.3841 0.0200932 0.00181057 43757.3 0; : 741 Minimum Test error found - save the configuration ; : 741 | 19.6956 22.1693 0.0200949 0.00182186 43780.3 0; : 742 Minimum Test error found - save the configuration ; : 742 | 19.5563 22.0339 0.0201148 0.00182382 43737.3 0; : 743 Minimum Test error found - save the configuration ; : 743 | 19.2633 21.9202 0.0201113 0.00181809 43732 0; : 744 Minimum Test error found - save the configuration ; : 744 | 18.9779 21.4146 0.0200848 0.00181658 43791.8 0; : 745 | 19.0558 21.8309 0.0200351 0.00176335 43783.5 1; : 746 Minimum Test error found - save the configuration ; : 746 | 18.8292 21.203 0.0201069 0.00182679 43763.3 0; : 747 Minimum Test error found - save the configuration ; : 747 | 18.4234 20.9247 0.0201054 0.00181179 43731.2 0; : 748 Minimum Test error found - save the configuration ; : 748 | 18.2054 20.8597 0.0200854 0.00181067 43776.4 0; : 749 Minimum Test error found - save the configuration ; : 749 | 17,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:92933,error,error,92933,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"38 ; 539 The following statements create a ROOT file and store a histogram; 540 on the file. Because TH1 derives from TNamed, the key identifier on; 541 the file is the histogram name:; 542~~~ {.cpp}; 543 TFile f(""histos.root"", ""new"");; 544 TH1F h1(""hgaus"", ""histo from a gaussian"", 100, -3, 3);; 545 h1.FillRandom(""gaus"", 10000);; 546 h1->Write();; 547~~~; 548 To read this histogram in another Root session, do:; 549~~~ {.cpp}; 550 TFile f(""histos.root"");; 551 TH1F *h = (TH1F*)f.Get(""hgaus"");; 552~~~; 553 One can save all histograms in memory to the file by:; 554~~~ {.cpp}; 555 file->Write();; 556~~~; 557 ; 558 ; 559\anchor misc; 560## Miscellaneous operations; 561 ; 562~~~ {.cpp}; 563 TH1::KolmogorovTest(): statistical test of compatibility in shape; 564 between two histograms; 565 TH1::Smooth() smooths the bin contents of a 1-d histogram; 566 TH1::Integral() returns the integral of bin contents in a given bin range; 567 TH1::GetMean(int axis) returns the mean value along axis; 568 TH1::GetStdDev(int axis) returns the sigma distribution along axis; 569 TH1::GetEntries() returns the number of entries; 570 TH1::Reset() resets the bin contents and errors of a histogram; 571~~~; 572 IMPORTANT NOTE: The returned values for GetMean and GetStdDev depend on how the; 573 histogram statistics are calculated. By default, if no range has been set, the; 574 returned values are the (unbinned) ones calculated at fill time. If a range has been; 575 set, however, the values are calculated using the bins in range; THIS IS TRUE EVEN; 576 IF THE RANGE INCLUDES ALL BINS--use TAxis::SetRange(0, 0) to unset the range.; 577 To ensure that the returned values are always those of the binned data stored in the; 578 histogram, call TH1::ResetStats. See TH1::GetStats.; 579*/; 580 ; 581TF1 *gF1=nullptr; //left for back compatibility (use TVirtualFitter::GetUserFunc instead); 582 ; 583Int_t TH1::fgBufferSize = 1000;; 584Bool_t TH1::fgAddDirectory = kTRUE;; 585Bool_t TH1::fgDefaultSumw2 = kFALSE;; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:24541,error,errors,24541,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['error'],['errors']
Availability,38.5 4; : 1096 | 2.82435 2.85928 0.0200663 0.00175842 43696.9 5; : 1097 | 2.94319 2.67707 0.0201699 0.00175551 43444.3 6; : 1098 | 3.07322 3.0122 0.0200534 0.00175203 43712.7 7; : 1099 | 2.83008 3.95183 0.0205372 0.0017939 42681.9 8; : 1100 | 2.67822 3.34195 0.020666 0.00184085 42496.4 9; : 1101 | 2.97088 2.72336 0.0206136 0.0017901 42500 10; : 1102 Minimum Test error found - save the configuration ; : 1102 | 2.66188 2.52638 0.020367 0.00185502 43215.3 0; : 1103 | 3.01155 3.18843 0.0202364 0.00176536 43311 1; : 1104 | 2.71885 3.00051 0.0201103 0.00176305 43603.3 2; : 1105 Minimum Test error found - save the configuration ; : 1105 | 2.73591 2.50832 0.0201341 0.0018587 43774.7 0; : 1106 | 2.7002 2.7081 0.0203577 0.00176876 43036.3 1; : 1107 | 2.85017 3.38001 0.0201747 0.00176074 43445.3 2; : 1108 | 2.78494 2.55451 0.0203389 0.00176376 43068.3 3; : 1109 | 2.71632 3.12003 0.0200899 0.00175276 43627.4 4; : 1110 | 3.16531 2.9918 0.020346 0.00180026 43136.7 5; : 1111 Minimum Test error found - save the configuration ; : 1111 | 2.97087 2.45167 0.0201922 0.00182484 43555.6 0; : 1112 | 2.60355 2.50464 0.0200664 0.00176061 43702 1; : 1113 | 2.54376 2.96916 0.0200737 0.00178101 43733.3 2; : 1114 | 2.77186 2.89815 0.0200657 0.00175793 43697.4 3; : 1115 | 2.58652 2.73506 0.020068 0.00175912 43694.6 4; : 1116 Minimum Test error found - save the configuration ; : 1116 | 2.82496 2.31503 0.0201083 0.00181922 43742 0; : 1117 | 2.74168 2.90157 0.0200454 0.00175765 43745.2 1; : 1118 | 2.51176 4.00704 0.0201409 0.00176812 43542.7 2; : 1119 | 3.03618 2.55498 0.0202517 0.00178949 43331.7 3; : 1120 | 2.66116 2.61177 0.0204165 0.00176394 42889.5 4; : 1121 | 3.00965 2.56116 0.0204562 0.00180217 42886.2 5; : 1122 | 3.0625 3.75816 0.0204635 0.00176149 42776.2 6; : 1123 | 2.88666 2.6576 0.0204265 0.00178135 42906.6 7; : 1124 | 2.54231 2.73598 0.020225 0.00176346 43333.4 8; : 1125 | 2.44231 2.73459 0.0201498 0.00175906 43500.1 9; : 1126 | 2.45201 2.82465 0.0200726 0.00175651 43677.5 10; : 1127 | 2,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:120403,error,error,120403,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"3807 // case of writing; 3808 b.WriteClassBuffer(TFormula::Class(), this);; 3809 // std::cout << ""writing npar = "" << GetNpar() << std::endl;; 3810 }; 3811}; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; c#define c(i)Definition RSha256.hxx:101; a#define a(i)Definition RSha256.hxx:99; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; Bool_tbool Bool_tDefinition RtypesCore.h:63; Int_tint Int_tDefinition RtypesCore.h:45; Version_tshort Version_tDefinition RtypesCore.h:65; Double_tdouble Double_tDefinition RtypesCore.h:59; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Option_tconst char Option_tDefinition RtypesCore.h:66; ClassImp#define ClassImp(name)Definition Rtypes.h:382; StringUtils.hxx; TBenchmark.h; TBuffer.h; TError.h; R__ASSERT#define R__ASSERT(e)Checks condition e and reports a fatal error if it's false.Definition TError.h:125; Errorvoid Error(const char *location, const char *msgfmt,...)Use this function in case an error occurred.Definition TError.cxx:185; TF1.h; GetParametersvoid GetParameters(TFitEditor::FuncParams_t &pars, TF1 *func)Stores the parameters of the given function into pars.Definition TFitEditor.cxx:256; gClingFunctionsstatic std::unordered_map< std::string, void * > gClingFunctionsDefinition TFormula.cxx:264; IncludeCladRuntimestatic void IncludeCladRuntime(Bool_t &IsCladRuntimeIncluded)Definition TFormula.cxx:3127; TFormulaUpdater_tvoid(*)(Int_t nobjects, TObject **from, TObject **to) TFormulaUpdater_tDefinition TFormula.cxx:280; gNamePrefixstatic const TString gNamePrefixDefinition TFormula.cxx:260; CallCladFunctionstatic void CallCladFunction(TInterpreter::CallFuncIFacePtr_t::Generic_t FuncPtr, const Double_t *vars, const Double_t *pars, Double_t *result, const Int_t)Definition TFormula.cxx:3159; prepareMethodstatic std::unique_ptr< TMethodCall > prepareMethod(bool HasParameters, bool HasVariables, const char *FuncName, bool IsVectorized, bool AddCladArrayRef=false)Defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFormula_8cxx_source.html:145504,error,error,145504,doc/master/TFormula_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFormula_8cxx_source.html,1,['error'],['error']
Availability,"3818 if (!keep) k->SetBit(kMustCleanup);; 3819 fCompiled->Add(k);; 3820 ; 3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:130843,echo,echo,130843,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['echo'],['echo']
Availability,"382 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, InvFnc invFnc, double patternWeight); 383 {; 384 double errorSum = 0.0;; 385 ; 386 // output - truth; 387 ItTruth itTruth = itTruthBegin;; 388 bool hasDeltas = (itDelta != itDeltaEnd);; 389 for (ItOutput itOutput = itOutputBegin; itOutput != itOutputEnd; ++itOutput, ++itTruth); 390 {; 391// assert (itTruth != itTruthEnd);; 392 double output = (*itOutput);; 393 double error = output - (*itTruth);; 394 if (hasDeltas); 395 {; 396 (*itDelta) = (*invFnc.get ()) (output) * error * patternWeight;; 397 ++itDelta;; 398 }; 399 errorSum += error*error * patternWeight;; 400 }; 401 ; 402 return 0.5*errorSum;; 403 }; 404 ; 405 ; 406 ; 407/*! \brief cross entropy error function; 408 *; 409 *; 410 */; 411 template <typename ItProbability, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 412 double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc /*itInvActFnc*/, double patternWeight); 413 {; 414 bool hasDeltas = (itDelta != itDeltaEnd);; 415 ; 416 double errorSum = 0.0;; 417 for (ItProbability itProbability = itProbabilityBegin; itProbability != itProbabilityEnd; ++itProbability); 418 {; 419 double probability = *itProbability;; 420 double truth = *itTruthBegin;; 421 /* truth = truth < 0.1 ? 0.1 : truth; */; 422 /* truth = truth > 0.9 ? 0.9 : truth; */; 423 truth = truth < 0.5 ? 0.1 : 0.9;; 424 if (hasDeltas); 425 {; 426 double delta = probability - truth;; 427 (*itDelta) = delta*patternWeight;; 428// (*itDelta) = (*itInvActFnc)(probability) * delta * patternWeight;; 429 ++itDelta;; 430 }; 431 double error (0);; 432 if (probability == 0) // protection against log (0); 433 {; 434 if (truth >= 0.5); 435 error += 1.0;; 436 }; 437 else if (probability == 1); 438 {; 439 if (truth < 0.5); 440 error += 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:11730,error,errorSum,11730,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,3,['error'],"['error', 'errorSum']"
Availability,"3821 if (needLoadMap) {; 3822 gInterpreter->LoadLibraryMap(libmapfilename);; 3823 }; 3824 if (verboseLevel>3 && withInfo) ::Info(""ACLiC"",""loading the shared library"");; 3825 if (loadLib); 3826 result = LoadLibrary(library);; 3827 else; 3828 result = kTRUE;; 3829 ; 3830 if ( !result ) {; 3831 if (verboseLevel>3 && withInfo) {; 3832 ::Info(""ACLiC"",""testing for missing symbols:"");; 3833 if (verboseLevel>4) ::Info(""ACLiC"", ""%s"", testcmd.Data());; 3834 }; 3835 gSystem->Exec(testcmd);; 3836 gSystem->Unlink( exec );; 3837 }; 3838 ; 3839 };; 3840 ; 3841 if (verboseLevel<=5 && !internalDebug) {; 3842 gSystem->Unlink( dict );; 3843 gSystem->Unlink( dicth );; 3844 gSystem->Unlink( dictObj );; 3845 gSystem->Unlink( linkdef );; 3846 gSystem->Unlink( mapfilein );; 3847 gSystem->Unlink( mapfileout );; 3848 gSystem->Unlink( fakeMain );; 3849 gSystem->Unlink( exec );; 3850 }; 3851 if (verboseLevel>6) {; 3852 rcling.Prepend(""echo "");; 3853 cmd.Prepend(""echo \"" "").Append("" \"" "");; 3854 testcmd.Prepend(""echo \"" "").Append("" \"" "");; 3855 gSystem->Exec(rcling);; 3856 gSystem->Exec( cmd );; 3857 gSystem->Exec(testcmd);; 3858 }; 3859 ; 3860 return result;; 3861}; 3862 ; 3863////////////////////////////////////////////////////////////////////////////////; 3864/// Return the ACLiC properties field. See EAclicProperties for details; 3865/// on the semantic of each bit.; 3866 ; 3867Int_t TSystem::GetAclicProperties() const; 3868{; 3869 return fAclicProperties;; 3870}; 3871 ; 3872////////////////////////////////////////////////////////////////////////////////; 3873/// Return the build architecture.; 3874 ; 3875const char *TSystem::GetBuildArch() const; 3876{; 3877 return fBuildArch;; 3878}; 3879 ; 3880////////////////////////////////////////////////////////////////////////////////; 3881/// Return the build compiler; 3882 ; 3883const char *TSystem::GetBuildCompiler() const; 3884{; 3885 return fBuildCompiler;; 3886}; 3887 ; 3888//////////////////////////////////////////////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:130921,echo,echo,130921,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['echo'],['echo']
Availability,"384 ; 385 for (Int_t i = 0; i < fNpoints; i++) {; 386 for (Int_t j = 0; j < fNYErrors; j++) {; 387 if (Int_t(eyL.size()) > j && eyL[j].GetSize() > i); 388 fEyL[j][i] = eyL[j][i];; 389 else; 390 fEyL[j][i] = 0.;; 391 if (Int_t(eyH.size()) > j && eyH[j].GetSize() > i); 392 fEyH[j][i] = eyH[j][i];; 393 else; 394 fEyH[j][i] = 0.;; 395 }; 396 }; 397 ; 398 CalcYErrorsSum();; 399}; 400 ; 401////////////////////////////////////////////////////////////////////////////////; 402/// TGraphMultiErrors normal constructor with `name`, `title`, `np` points and `ne` y-errors.; 403///; 404/// If `exL`,`exH` are NULL, the corresponding values are preset to zero.; 405/// The multiple y-errors are passed as std::vectors of TArrayD objects.; 406 ; 407TGraphMultiErrors::TGraphMultiErrors(const Char_t *name, const Char_t *title, Int_t np, Int_t ne, const Double_t *x,; 408 const Double_t *y, const Double_t *exL, const Double_t *exH,; 409 std::vector<TArrayD> eyL, std::vector<TArrayD> eyH, Int_t m); 410 : TGraphMultiErrors(np, ne, x, y, exL, exH, eyL, eyH, m); 411{; 412 SetNameTitle(name, title);; 413}; 414 ; 415////////////////////////////////////////////////////////////////////////////////; 416/// Constructor with six vectors of floats in input and a single y error dimension.; 417/// The signature of this constructor is equal to the corresponding constructor of TGraphAsymmErrors.; 418/// A grapherrors is built with the X coordinates taken from `tvX` the Y coordinates from `tvY`; 419/// and the errors from vectors `tvExL`, `tvExH` and `tvEyL`, `tvEyH`.; 420/// The number of points in the graph is the minimum of number of points; 421/// in `tvX` and `tvY`.; 422 ; 423TGraphMultiErrors::TGraphMultiErrors(const TVectorF &tvX, const TVectorF &tvY, const TVectorF &tvExL,; 424 const TVectorF &tvExH, const TVectorF &tvEyL, const TVectorF &tvEyH, Int_t m); 425 : fNYErrors(1), fSumErrorsMode(m); 426{; 427 fNpoints = TMath::Min(tvX.GetNrows(), tvY.GetNrows());; 428 ; 429 if (!TGraph::CtorAllocate()); ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:15034,error,error,15034,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,1,['error'],['error']
Availability,"386 return res;; 387}; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Generates a random integer N according to a Poisson law.; 391/// Prob(N) = exp(-mean)*mean^N/Factorial(N); 392///; 393/// Use a different procedure according to the mean value.; 394/// The algorithm is the same used by CLHEP.; 395/// For lower value (mean < 25) use the rejection method based on; 396/// the exponential.; 397/// For higher values use a rejection method comparing with a Lorentzian; 398/// distribution, as suggested by several authors.; 399/// This routine returns now an unsigned 64 bit integer; 400/// For large values, larger than 1.84e+19, we print an error message; 401/// advising to use the Trandom::PoissonD for such large values,; 402/// and return the max value UINT64_MAX; 403 ; 404ULong64_t TRandom::Poisson(Double_t mean); 405{; 406 ULong64_t n;; 407 if (mean <= 0) return 0;; 408 if (mean < 25) {; 409 Double_t expmean = TMath::Exp(-mean);; 410 Double_t pir = 1;; 411 n = -1;; 412 while(true) {; 413 n++;; 414 pir *= Rndm();; 415 if (pir <= expmean) break;; 416 }; 417 return n;; 418 }; 419 // for large value we use inversion method; 420 else if (mean < 1E9) {; 421 Double_t em, t, y;; 422 Double_t sq, alxm, g;; 423 Double_t pi = TMath::Pi();; 424 ; 425 sq = TMath::Sqrt(2.0*mean);; 426 alxm = TMath::Log(mean);; 427 g = mean*alxm - TMath::LnGamma(mean + 1.0);; 428 ; 429 do {; 430 do {; 431 y = TMath::Tan(pi*Rndm());; 432 em = sq*y + mean;; 433 } while( em < 0.0 );; 434 ; 435 em = TMath::Floor(em);; 436 t = 0.9*(1.0 + y*y)* TMath::Exp(em*alxm - TMath::LnGamma(em + 1.0) - g);; 437 } while( Rndm() > t );; 438 ; 439 return static_cast<ULong64_t>(em);; 440 ; 441 }; 442 else {; 443 // use Gaussian approximation for very large values; 444 Double_t x = Gaus(0, 1) * TMath::Sqrt(mean) + mean + 0.5;; 445 if (x > TMath::Limits<ULong64_t>::Max()) {; 446 Error(""Poisson"", ""Overflow in return value. Use PoissonD instead."");; 447 return TMath::Limits<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TRandom_8cxx_source.html:18073,error,error,18073,doc/master/TRandom_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TRandom_8cxx_source.html,1,['error'],['error']
Availability,39 43793.9 0; : 640 Minimum Test error found - save the configuration ; : 640 | 72.4195 52.0402 0.0201153 0.00181887 43724.4 0; : 641 | 71.5077 52.3492 0.0200565 0.00175616 43715 1; : 642 Minimum Test error found - save the configuration ; : 642 | 70.8829 51.1798 0.0201079 0.00181215 43725.9 0; : 643 Minimum Test error found - save the configuration ; : 643 | 69.8143 50.8726 0.0201142 0.00180555 43695.1 0; : 644 Minimum Test error found - save the configuration ; : 644 | 68.806 50.1244 0.0201666 0.00186273 43706.7 0; : 645 Minimum Test error found - save the configuration ; : 645 | 67.8562 49.8828 0.0202418 0.00183622 43465.2 0; : 646 Minimum Test error found - save the configuration ; : 646 | 67.0733 49.0958 0.0205161 0.00187288 42911 0; : 647 Minimum Test error found - save the configuration ; : 647 | 66.0907 48.4839 0.0203074 0.00181472 43260.4 0; : 648 Minimum Test error found - save the configuration ; : 648 | 65.1425 47.9895 0.0205925 0.00181541 42605 0; : 649 Minimum Test error found - save the configuration ; : 649 | 64.2291 47.827 0.0205836 0.00185514 42715.8 0; : 650 Minimum Test error found - save the configuration ; : 650 | 63.5181 47.2461 0.0203914 0.00184161 43127.1 0; : 651 Minimum Test error found - save the configuration ; : 651 | 62.641 46.7417 0.020143 0.00182812 43680.3 0; : 652 Minimum Test error found - save the configuration ; : 652 | 61.875 46.3421 0.0201124 0.00182035 43734.8 0; : 653 Minimum Test error found - save the configuration ; : 653 | 61.1155 45.9892 0.0201549 0.00182806 43651.9 0; : 654 | 60.3955 46.5097 0.0201006 0.00177795 43661.9 1; : 655 Minimum Test error found - save the configuration ; : 655 | 59.5776 45.1172 0.0204622 0.00186914 43026.9 0; : 656 Minimum Test error found - save the configuration ; : 656 | 58.5813 44.6814 0.020214 0.00181641 43484.1 0; : 657 Minimum Test error found - save the configuration ; : 657 | 58.1075 44.2582 0.0201216 0.0018139 43697.5 0; : 658 Minimum Test error found - save the configuration ; : 658 ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:84062,error,error,84062,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"39 of file TTabCom.cxx. ◆ IsA(). virtual TClass * TTabCom::IsA ; (; ); const. inlinevirtual . ReturnsTClass describing current object ; Definition at line 226 of file TTabCom.h. ◆ IsDirectory(). Bool_t TTabCom::IsDirectory ; (; const char ; fileName[]). static . [static utility function]///////////////////////////// ; calls TSystem::GetPathInfo() to see if ""fileName"" is a system directory. ; Definition at line 1029 of file TTabCom.cxx. ◆ MakeClassFromClassName(). TClass * TTabCom::MakeClassFromClassName ; (; const char ; className[]); const. private . [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a class. ; user must delete. returns 0 in case of error. ; Definition at line 2206 of file TTabCom.cxx. ◆ MakeClassFromVarName(). TClass * TTabCom::MakeClassFromVarName ; (; const char ; varName[], . EContext_t & ; context, . int ; iter = 0 . ). private . [private] (does some specific error handling that makes the function unsuitable for general use.) returns a new'd TClass given the name of a variable. ; user must delete. returns 0 in case of error. if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf. context sensitive behavior. ; Definition at line 2255 of file TTabCom.cxx. ◆ NewListOfFilesInPath(). TSeqCollection * TTabCom::NewListOfFilesInPath ; (; const char ; path1[]). static . [static utility function]///////////////////////////// ; creates a list containing the full path name for each file in the (colon separated) string ""path1""; memory is allocated with ""new"", so whoever calls this function takes responsibility for deleting it. ; Definition at line 1049 of file TTabCom.cxx. ◆ NoMsg(). void TTabCom::NoMsg ; (; Int_t ; errorLevel). static . [static utility function]///////////////////////////// ; calling ""NoMsg( errorLevel )"", sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that all errors with ""level < errorLevel"" will be ignored.; calling t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTabCom.html:15717,error,error,15717,doc/master/classTTabCom.html,https://root.cern,https://root.cern/doc/master/classTTabCom.html,1,['error'],['error']
Availability,"39 return 0;; 2640 }; 2641 evhdl = *(int *)eventhdl;; 2642 ; 2643 s = (int)write(evhdl, &u, sizeof(u));; 2644 if (s != sizeof(u)) {; 2645 /* error */; 2646 return 0;; 2647 }; 2648 return 1;; 2649}; 2650 ; 2651 ; 2652static void; 2653event_destroy(void *eventhdl); 2654{; 2655 int evhdl;; 2656 ; 2657 if (!eventhdl) {; 2658 /* error */; 2659 return;; 2660 }; 2661 evhdl = *(int *)eventhdl;; 2662 ; 2663 close(evhdl);; 2664 mg_free(eventhdl);; 2665}; 2666 ; 2667 ; 2668#endif; 2669 ; 2670#endif; 2671 ; 2672 ; 2673#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE); 2674 ; 2675struct posix_event {; 2676 pthread_mutex_t mutex;; 2677 pthread_cond_t cond;; 2678 int signaled;; 2679};; 2680 ; 2681 ; 2682static void *; 2683event_create(void); 2684{; 2685 struct posix_event *ret = mg_malloc(sizeof(struct posix_event));; 2686 if (ret == 0) {; 2687 /* out of memory */; 2688 return 0;; 2689 }; 2690 if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {; 2691 /* pthread mutex not available */; 2692 mg_free(ret);; 2693 return 0;; 2694 }; 2695 if (0 != pthread_cond_init(&(ret->cond), NULL)) {; 2696 /* pthread cond not available */; 2697 pthread_mutex_destroy(&(ret->mutex));; 2698 mg_free(ret);; 2699 return 0;; 2700 }; 2701 ret->signaled = 0;; 2702 return (void *)ret;; 2703}; 2704 ; 2705 ; 2706static int; 2707event_wait(void *eventhdl); 2708{; 2709 struct posix_event *ev = (struct posix_event *)eventhdl;; 2710 pthread_mutex_lock(&(ev->mutex));; 2711 while (!ev->signaled) {; 2712 pthread_cond_wait(&(ev->cond), &(ev->mutex));; 2713 }; 2714 ev->signaled = 0;; 2715 pthread_mutex_unlock(&(ev->mutex));; 2716 return 1;; 2717}; 2718 ; 2719 ; 2720static int; 2721event_signal(void *eventhdl); 2722{; 2723 struct posix_event *ev = (struct posix_event *)eventhdl;; 2724 pthread_mutex_lock(&(ev->mutex));; 2725 pthread_cond_signal(&(ev->cond));; 2726 ev->signaled = 1;; 2727 pthread_mutex_unlock(&(ev->mutex));; 2728 return 1;; 2729}; 2730 ; 2731 ; 2732static void; 2733event_destroy(voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:83135,avail,available,83135,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['avail'],['available']
Availability,39.5 5; : 1052 Minimum Test error found - save the configuration ; : 1052 | 2.87354 3.24293 0.0202139 0.00182119 43495.4 0; : 1053 | 2.96323 3.45692 0.0200573 0.00175839 43718.4 1; : 1054 | 2.84926 3.80103 0.0200558 0.00175409 43711.6 2; : 1055 | 2.95781 3.27091 0.020067 0.00175747 43693.1 3; : 1056 | 3.19444 5.21663 0.0200546 0.00175884 43725.9 4; : 1057 | 3.64244 3.58532 0.0204609 0.00177451 42811.8 5; : 1058 | 3.4344 3.25697 0.0201011 0.00178651 43681.1 6; : 1059 | 2.82841 3.35413 0.020208 0.00176662 43380.6 7; : 1060 | 2.98819 3.74969 0.0202318 0.00179746 43397.3 8; : 1061 | 3.26859 3.94266 0.0201482 0.00175781 43501 9; : 1062 Minimum Test error found - save the configuration ; : 1062 | 3.14929 3.19749 0.0201067 0.00181963 43746.8 0; : 1063 | 2.87068 3.26991 0.0200491 0.00176391 43751.2 1; : 1064 | 2.93768 3.71885 0.0200468 0.00176208 43752.3 2; : 1065 | 2.97083 3.36192 0.0201608 0.00179095 43549.7 3; : 1066 | 3.04197 3.49012 0.0203588 0.00177356 43045 4; : 1067 Minimum Test error found - save the configuration ; : 1067 | 3.05672 2.86026 0.0203982 0.00182711 43077.7 0; : 1068 | 3.10603 3.29637 0.020205 0.00184144 43564.6 1; : 1069 | 2.88449 4.01918 0.0203768 0.00179741 43058.4 2; : 1070 | 2.97807 3.34364 0.0200746 0.00174903 43654.8 3; : 1071 | 3.12106 3.50221 0.0203054 0.0017782 43179.8 4; : 1072 | 2.87393 2.91962 0.020149 0.001768 43523.2 5; : 1073 | 2.90826 3.29161 0.0202848 0.00180763 43296.8 6; : 1074 | 3.06053 3.26664 0.0201588 0.00175733 43474.8 7; : 1075 Minimum Test error found - save the configuration ; : 1075 | 2.97935 2.76485 0.0202008 0.00187279 43649.1 0; : 1076 | 2.74949 3.00321 0.0203478 0.00181324 43162.6 1; : 1077 | 2.76284 3.75591 0.0207943 0.00180912 42138.1 2; : 1078 Minimum Test error found - save the configuration ; : 1078 | 3.00913 2.73577 0.0203661 0.0018517 43209.6 0; : 1079 | 2.90364 3.01716 0.0202612 0.00175591 43230.9 1; : 1080 | 2.84249 3.41706 0.0201644 0.00176658 43483.3 2; : 1081 | 2.8573 3.42383 0.0204284 0.00175777 42848.1 3; :,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:117512,error,error,117512,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"3918 of file TGCocoa.mm. ◆ SetDoubleBuffer(). void TGCocoa::SetDoubleBuffer ; (; Int_t ; wid, . Int_t ; mode . ). overridevirtual . Sets the double buffer on/off on the window ""wid"". ; Parameters. [in]widwindow identifier.; 999 means all opened windows. . [in]modethe on/off switch; mode = 1 double buffer is on; mode = 0 double buffer is off . Reimplemented from TVirtualX.; Definition at line 3441 of file TGCocoa.mm. ◆ SetDoubleBufferOFF(). void TGCocoa::SetDoubleBufferOFF ; (; ). overridevirtual . Turns double buffer mode off. ; Reimplemented from TVirtualX.; Definition at line 3456 of file TGCocoa.mm. ◆ SetDoubleBufferON(). void TGCocoa::SetDoubleBufferON ; (; ). overridevirtual . Turns double buffer mode on. ; Reimplemented from TVirtualX.; Definition at line 3462 of file TGCocoa.mm. ◆ SetDrawMode(). void TGCocoa::SetDrawMode ; (; EDrawMode ; mode). overridevirtual . Sets the drawing mode. ; Parameters. [in]modedrawing mode.; mode = 1 copy; mode = 2 xor; mode = 3 invert; mode = 4 set the suitable mode for cursor echo according to the vendor . Reimplemented from TVirtualX.; Definition at line 3495 of file TGCocoa.mm. ◆ SetForeground(). void TGCocoa::SetForeground ; (; GContext_t ; gc, . ULong_t ; foreground . ). overridevirtual . Sets the foreground color for the specified GC (shortcut for ChangeGC with only foreground mask set). ; Parameters. [in]gcspecifies the GC ; [in]foregroundthe foreground you want to set. (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 2995 of file TGCocoa.mm. ◆ SetIconName(). void TGCocoa::SetIconName ; (; Window_t ; id, . char * ; name . ). overridevirtual . Sets the window icon name. ; Reimplemented from TVirtualX.; Definition at line 1533 of file TGCocoa.mm. ◆ SetIconPixmap(). void TGCocoa::SetIconPixmap ; (; Window_t ; id, . Pixmap_t ; pix . ). overridevirtual . Sets the icon name pixmap. ; Reimplemented from TVirtualX.; Definition at line 1539 of file TGCocoa.mm. ◆ SetInputFocus(). void TGCocoa:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:116624,echo,echo,116624,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['echo'],['echo']
Availability,"394 of file TGCocoa.mm. ◆ GetFontHandle(). FontH_t TGCocoa::GetFontHandle ; (; FontStruct_t ; fs). overridevirtual . Returns the font handle of the specified font structure ""fs"". ; Reimplemented from TVirtualX.; Definition at line 2829 of file TGCocoa.mm. ◆ GetFontProperties(). void TGCocoa::GetFontProperties ; (; FontStruct_t ; font, . Int_t & ; max_ascent, . Int_t & ; max_descent . ). overridevirtual . Returns the font properties. ; Reimplemented from TVirtualX.; Definition at line 2856 of file TGCocoa.mm. ◆ GetFontStruct(). FontStruct_t TGCocoa::GetFontStruct ; (; FontH_t ; fh). overridevirtual . Retrieves the associated font structure of the font specified font handle ""fh"". ; Free returned FontStruct_t using FreeFontStruct(). ; Reimplemented from TVirtualX.; Definition at line 2863 of file TGCocoa.mm. ◆ GetGCValues(). void TGCocoa::GetGCValues ; (; GContext_t ; gc, . GCValues_t & ; gval . ). overridevirtual . Returns the components specified by the mask in ""gval"" for the specified GC ""gc"" (see also the GCValues_t structure) ; Reimplemented from TVirtualX.; Definition at line 3090 of file TGCocoa.mm. ◆ GetGeometry(). void TGCocoa::GetGeometry ; (; Int_t ; wid, . Int_t & ; x, . Int_t & ; y, . UInt_t & ; w, . UInt_t & ; h . ). overridevirtual . Returns position and size of window ""wid"". ; Parameters. [in]widwindow identifier if wid < 0 the size of the display is returned ; [in]x,yreturned window position ; [in]w,hreturned window size . Reimplemented from TVirtualX.; Definition at line 707 of file TGCocoa.mm. ◆ GetImageSize(). void TGCocoa::GetImageSize ; (; Drawable_t ; id, . UInt_t & ; width, . UInt_t & ; height . ). overridevirtual . Returns the width and height of the image id. ; Reimplemented from TVirtualX.; Definition at line 2589 of file TGCocoa.mm. ◆ GetInputFocus(). Window_t TGCocoa::GetInputFocus ; (; ). overridevirtual . Returns the window id of the window having the input focus. ; Reimplemented from TVirtualX.; Definition at line 2768 of file TGCocoa.mm.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:84656,mask,mask,84656,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['mask'],['mask']
Availability,"396 conn->in_error_handler = 1;; 4397 handled_by_callback =; 4398 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4399 == 0);; 4400 conn->in_error_handler = 0;; 4401 }; 4402 ; 4403 if (!handled_by_callback) {; 4404 /* Check for recursion */; 4405 if (conn->in_error_handler) {; 4406 DEBUG_TRACE(; 4407 ""Recursion when handling error %u - fall back to default"",; 4408 status);; 4409#if !defined(NO_FILESYSTEMS); 4410 } else {; 4411 /* Send user defined error pages, if defined */; 4412 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4413 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4414 page_handler_found = 0;; 4415 ; 4416 if (error_handler != NULL) {; 4417 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4418 switch (scope) {; 4419 case 1: /* Handler for specific error, e.g. 404 error */; 4420 mg_snprintf(conn,; 4421 &truncated,; 4422 path_buf,; 4423 sizeof(path_buf) - 32,; 4424 ""%serror%03u."",; 4425 error_handler,; 4426 status);; 4427 break;; 4428 case 2: /* Handler for error group, e.g., 5xx error; 4429 * handler; 4430 * for all server errors (500-599) */; 4431 mg_snprintf(conn,; 4432 &truncated,; 4433 path_buf,; 4434 sizeof(path_buf) - 32,; 4435 ""%serror%01uxx."",; 4436 error_handler,; 4437 status / 100);; 4438 break;; 4439 default: /* Handler for all errors */; 4440 mg_snprintf(conn,; 4441 &truncated,; 4442 path_buf,; 4443 sizeof(path_buf) - 32,; 4444 ""%serror."",; 4445 error_handler);; 4446 break;; 4447 }; 4448 ; 4449 /* String truncation in buf may only occur if; 4450 * error_handler is too long. This string is; 4451 * from the config, not from a client. */; 4452 (void)truncated;; 4453 ; 4454 /* The following code is redundant, but it should avoid; 4455 * false positives in static source code analyzers and; 4456 * vulnerability scanners.; 4457 */; 4458 path_buf[sizeof(path_buf) - 32] = 0;; 4459 len = (int)strlen(path_buf);; 4460 if (len > (int)sizeof(path_buf) - 32) {; 4461 len = (int)sizeof(path_buf) - 32;; 4462 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:132487,error,error,132487,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"397 conn->in_error_handler = 1;; 4398 handled_by_callback =; 4399 (conn->phys_ctx->callbacks.http_error(conn, status, errmsg_buf); 4400 == 0);; 4401 conn->in_error_handler = 0;; 4402 }; 4403 ; 4404 if (!handled_by_callback) {; 4405 /* Check for recursion */; 4406 if (conn->in_error_handler) {; 4407 DEBUG_TRACE(; 4408 ""Recursion when handling error %u - fall back to default"",; 4409 status);; 4410#if !defined(NO_FILESYSTEMS); 4411 } else {; 4412 /* Send user defined error pages, if defined */; 4413 error_handler = conn->dom_ctx->config[ERROR_PAGES];; 4414 error_page_file_ext = conn->dom_ctx->config[INDEX_FILES];; 4415 page_handler_found = 0;; 4416 ; 4417 if (error_handler != NULL) {; 4418 for (scope = 1; (scope <= 3) && !page_handler_found; scope++) {; 4419 switch (scope) {; 4420 case 1: /* Handler for specific error, e.g. 404 error */; 4421 mg_snprintf(conn,; 4422 &truncated,; 4423 path_buf,; 4424 sizeof(path_buf) - 32,; 4425 ""%serror%03u."",; 4426 error_handler,; 4427 status);; 4428 break;; 4429 case 2: /* Handler for error group, e.g., 5xx error; 4430 * handler; 4431 * for all server errors (500-599) */; 4432 mg_snprintf(conn,; 4433 &truncated,; 4434 path_buf,; 4435 sizeof(path_buf) - 32,; 4436 ""%serror%01uxx."",; 4437 error_handler,; 4438 status / 100);; 4439 break;; 4440 default: /* Handler for all errors */; 4441 mg_snprintf(conn,; 4442 &truncated,; 4443 path_buf,; 4444 sizeof(path_buf) - 32,; 4445 ""%serror."",; 4446 error_handler);; 4447 break;; 4448 }; 4449 ; 4450 /* String truncation in buf may only occur if; 4451 * error_handler is too long. This string is; 4452 * from the config, not from a client. */; 4453 (void)truncated;; 4454 ; 4455 /* The following code is redundant, but it should avoid; 4456 * false positives in static source code analyzers and; 4457 * vulnerability scanners.; 4458 */; 4459 path_buf[sizeof(path_buf) - 32] = 0;; 4460 len = (int)strlen(path_buf);; 4461 if (len > (int)sizeof(path_buf) - 32) {; 4462 len = (int)sizeof(path_buf) - 32;; 4463 };",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:132519,error,error,132519,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"397 return SSL_TLSEXT_ERR_OK;; 16398 }; 16399 }; 16400 }; 16401 ; 16402 /* Nothing found */; 16403 return SSL_TLSEXT_ERR_NOACK;; 16404}; 16405 ; 16406 ; 16407static int; 16408next_protos_advertised_cb(SSL *ssl,; 16409 const unsigned char **data,; 16410 unsigned int *len,; 16411 void *arg); 16412{; 16413 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16414 *data = (const unsigned char *)alpn_proto_list;; 16415 *len = (unsigned int)strlen((const char *)data);; 16416 ; 16417 (void)ssl;; 16418 (void)dom_ctx;; 16419 ; 16420 return SSL_TLSEXT_ERR_OK;; 16421}; 16422 ; 16423 ; 16424static int; 16425init_alpn(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16426{; 16427 unsigned int alpn_len = (unsigned int)strlen((char *)alpn_proto_list);; 16428 int ret = SSL_CTX_set_alpn_protos(dom_ctx->ssl_ctx,; 16429 (const unsigned char *)alpn_proto_list,; 16430 alpn_len);; 16431 if (ret != 0) {; 16432 mg_cry_ctx_internal(phys_ctx,; 16433 ""SSL_CTX_set_alpn_protos error: %s"",; 16434 ssl_error());; 16435 }; 16436 ; 16437 SSL_CTX_set_alpn_select_cb(dom_ctx->ssl_ctx,; 16438 alpn_select_cb,; 16439 (void *)dom_ctx);; 16440 ; 16441 SSL_CTX_set_next_protos_advertised_cb(dom_ctx->ssl_ctx,; 16442 next_protos_advertised_cb,; 16443 (void *)dom_ctx);; 16444 ; 16445 return ret;; 16446}; 16447#endif; 16448 ; 16449 ; 16450/* Setup SSL CTX as required by CivetWeb */; 16451static int; 16452init_ssl_ctx_impl(struct mg_context *phys_ctx,; 16453 struct mg_domain_context *dom_ctx,; 16454 const char *pem,; 16455 const char *chain); 16456{; 16457 int callback_ret;; 16458 int should_verify_peer;; 16459 int peer_certificate_optional;; 16460 const char *ca_path;; 16461 const char *ca_file;; 16462 int use_default_verify_paths;; 16463 int verify_depth;; 16464 struct timespec now_mt;; 16465 md5_byte_t ssl_context_id[16];; 16466 md5_state_t md5state;; 16467 int protocol_ver;; 16468 int ssl_cache_timeout;; 16469 ; 16470#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:486021,error,error,486021,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['error'],['error']
Availability,"398 return SSL_TLSEXT_ERR_OK;; 16399 }; 16400 }; 16401 }; 16402 ; 16403 /* Nothing found */; 16404 return SSL_TLSEXT_ERR_NOACK;; 16405}; 16406 ; 16407 ; 16408static int; 16409next_protos_advertised_cb(SSL *ssl,; 16410 const unsigned char **data,; 16411 unsigned int *len,; 16412 void *arg); 16413{; 16414 struct mg_domain_context *dom_ctx = (struct mg_domain_context *)arg;; 16415 *data = (const unsigned char *)alpn_proto_list;; 16416 *len = (unsigned int)strlen((const char *)data);; 16417 ; 16418 (void)ssl;; 16419 (void)dom_ctx;; 16420 ; 16421 return SSL_TLSEXT_ERR_OK;; 16422}; 16423 ; 16424 ; 16425static int; 16426init_alpn(struct mg_context *phys_ctx, struct mg_domain_context *dom_ctx); 16427{; 16428 unsigned int alpn_len = (unsigned int)strlen((char *)alpn_proto_list);; 16429 int ret = SSL_CTX_set_alpn_protos(dom_ctx->ssl_ctx,; 16430 (const unsigned char *)alpn_proto_list,; 16431 alpn_len);; 16432 if (ret != 0) {; 16433 mg_cry_ctx_internal(phys_ctx,; 16434 ""SSL_CTX_set_alpn_protos error: %s"",; 16435 ssl_error());; 16436 }; 16437 ; 16438 SSL_CTX_set_alpn_select_cb(dom_ctx->ssl_ctx,; 16439 alpn_select_cb,; 16440 (void *)dom_ctx);; 16441 ; 16442 SSL_CTX_set_next_protos_advertised_cb(dom_ctx->ssl_ctx,; 16443 next_protos_advertised_cb,; 16444 (void *)dom_ctx);; 16445 ; 16446 return ret;; 16447}; 16448#endif; 16449 ; 16450 ; 16451/* Setup SSL CTX as required by CivetWeb */; 16452static int; 16453init_ssl_ctx_impl(struct mg_context *phys_ctx,; 16454 struct mg_domain_context *dom_ctx,; 16455 const char *pem,; 16456 const char *chain); 16457{; 16458 int callback_ret;; 16459 int should_verify_peer;; 16460 int peer_certificate_optional;; 16461 const char *ca_path;; 16462 const char *ca_file;; 16463 int use_default_verify_paths;; 16464 int verify_depth;; 16465 struct timespec now_mt;; 16466 md5_byte_t ssl_context_id[16];; 16467 md5_state_t md5state;; 16468 int protocol_ver;; 16469 int ssl_cache_timeout;; 16470 ; 16471#if (defined(OPENSSL_API_1_1) || defined(OPENSSL_API_3_0)) \",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:486054,error,error,486054,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['error'],['error']
Availability,"3997 while (iter != theEnd) {; 3998 alternateTuple << "" "" << *iter << "" _"" << nMember << "";\n"";; 3999 ++iter;; 4000 ++nMember;; 4001 }; 4002 break;; 4003 }; 4004 case ETupleOrdering::kDescending: {; 4005 unsigned int nMember = tupleContent.fElements.size() - 3;; 4006 auto iter = tupleContent.fElements.rbegin() + 1; // skip the 'stars'.; 4007 auto theEnd = tupleContent.fElements.rend() - 1; // Skip the template name (tuple).; 4008 while (iter != theEnd) {; 4009 alternateTuple << "" "" << *iter << "" _"" << nMember << "";\n"";; 4010 ++iter;; 4011 --nMember;; 4012 }; 4013 break;; 4014 }; 4015 case ETupleOrdering::kUnexpected: {; 4016 Fatal(""TCling::SetClassInfo::AlternateTuple"",; 4017 ""Layout of std::tuple on this platform is unexpected."");; 4018 break;; 4019 }; 4020 }; 4021 ; 4022 alternateTuple << ""};\n"";; 4023 alternateTuple << ""}}\n"";; 4024 alternateTuple << ""#endif\n"";; 4025 if (!gCling->Declare(alternateTuple.str().c_str())); 4026 {; 4027 // Declare is not silent (yet?), so add an explicit error message; 4028 // to indicate the consequence of the syntax errors.; 4029 Error(""Load"",""Could not declare %s"",alternateName.c_str());; 4030 return """";; 4031 }; 4032 alternateName = ""ROOT::Internal::"" + alternateName;; 4033 return alternateName;; 4034}; 4035 ; 4036////////////////////////////////////////////////////////////////////////////////; 4037/// Set pointer to the TClingClassInfo in TClass.; 4038/// If 'reload' is true, (attempt to) generate a new ClassInfo even if we; 4039/// already have one.; 4040 ; 4041void TCling::SetClassInfo(TClass* cl, Bool_t reload, Bool_t silent); 4042{; 4043 // We are shutting down, there is no point in reloading, it only triggers; 4044 // redundant deserializations.; 4045 if (fIsShuttingDown) {; 4046 // Remove the decl_id from the DeclIdToTClass map; 4047 if (cl->fClassInfo) {; 4048 R__LOCKGUARD(gInterpreterMutex);; 4049 TClingClassInfo* TClinginfo = (TClingClassInfo*) cl->fClassInfo;; 4050 // Test again as another thread may have set fClassInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:155646,error,error,155646,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"3::PutStats(stats);; 1178 fTsumwt = stats[11];; 1179 fTsumwt2 = stats[12];; 1180}; 1181 ; 1182////////////////////////////////////////////////////////////////////////////////; 1183/// Reset contents of a Profile3D histogram.; 1184 ; 1185void TProfile3D::Reset(Option_t *option); 1186{; 1187 TH3D::Reset(option);; 1188 fBinSumw2.Reset();; 1189 fBinEntries.Reset();; 1190 TString opt = option;; 1191 opt.ToUpper();; 1192 if (opt.Contains(""ICE"") && !opt.Contains(""S"")) return;; 1193 fTsumwt = fTsumwt2 = 0;; 1194}; 1195 ; 1196////////////////////////////////////////////////////////////////////////////////; 1197/// Profile histogram is resized along axis such that x is in the axis range.; 1198/// The new axis limits are recomputed by doubling iteratively; 1199/// the current axis range until the specified value x is within the limits.; 1200/// The algorithm makes a copy of the histogram, then loops on all bins; 1201/// of the old histogram to fill the rebinned histogram.; 1202/// Takes into account errors (Sumw2) if any.; 1203/// The axis must be rebinnable before invoking this function.; 1204/// Ex: `h->GetXaxis()->SetCanExtend(kTRUE)`; 1205 ; 1206void TProfile3D::ExtendAxis(Double_t x, TAxis *axis); 1207{; 1208 TProfile3D* hold = TProfileHelper::ExtendAxis(this, x, axis);; 1209 if ( hold ) {; 1210 fTsumwt = hold->fTsumwt;; 1211 fTsumwt2 = hold->fTsumwt2;; 1212 delete hold;; 1213 }; 1214}; 1215 ; 1216////////////////////////////////////////////////////////////////////////////////; 1217/// Save primitive as a C++ statement(s) on output stream out.; 1218///; 1219/// Note the following restrictions in the code generated:; 1220/// - variable bin size not implemented; 1221/// - SetErrorOption not implemented; 1222 ; 1223void TProfile3D::SavePrimitive(std::ostream &out, Option_t *option /*= """"*/); 1224{; 1225 char quote = '""';; 1226 out <<"" ""<<std::endl;; 1227 out <<"" ""<<ClassName()<<"" *"";; 1228 ; 1229 out << GetName() << "" = new "" << ClassName() << ""("" << quote; 1230 << GetName() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:45809,error,errors,45809,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['errors']
Availability,3; : 778 Minimum Test error found - save the configuration ; : 778 | 13.4936 16.5395 0.0200845 0.00181482 43788.4 0; : 779 | 13.0033 16.7495 0.0200505 0.00176209 43743.6 1; : 780 | 12.772 17.4981 0.0200745 0.00176104 43683.8 2; : 781 Minimum Test error found - save the configuration ; : 781 | 12.7689 16.2598 0.0201132 0.00182368 43740.8 0; : 782 | 12.7687 16.3043 0.0200467 0.00175214 43728.9 1; : 783 Minimum Test error found - save the configuration ; : 783 | 12.8267 16.1842 0.0201195 0.00182779 43735.8 0; : 784 Minimum Test error found - save the configuration ; : 784 | 12.4995 16.0856 0.0201584 0.00184241 43677.8 0; : 785 Minimum Test error found - save the configuration ; : 785 | 12.0807 15.9892 0.0201102 0.00181891 43736.6 0; : 786 Minimum Test error found - save the configuration ; : 786 | 12.1859 15.8365 0.0202015 0.00183664 43561.5 0; : 787 Minimum Test error found - save the configuration ; : 787 | 12.2089 15.7994 0.0201254 0.00182497 43714.8 0; : 788 Minimum Test error found - save the configuration ; : 788 | 11.8962 15.4841 0.0201259 0.00183192 43730.1 0; : 789 | 11.7703 15.6571 0.0200815 0.00176624 43679.3 1; : 790 Minimum Test error found - save the configuration ; : 790 | 11.5659 15.3611 0.0201716 0.00184466 43651.5 0; : 791 Minimum Test error found - save the configuration ; : 791 | 11.5078 15.2368 0.0201178 0.00182919 43743 0; : 792 | 11.3858 15.3308 0.0200358 0.001762 43778.5 1; : 793 Minimum Test error found - save the configuration ; : 793 | 11.148 14.9168 0.0201055 0.00182242 43756.2 0; : 794 Minimum Test error found - save the configuration ; : 794 | 10.9366 14.9107 0.0201153 0.00182387 43736.3 0; : 795 | 11.1392 14.953 0.020041 0.00176266 43767.6 1; : 796 | 11.1019 15.4101 0.0200549 0.00175791 43723.2 2; : 797 | 11.12 15.292 0.0200628 0.00175972 43708.5 3; : 798 | 10.8935 14.9786 0.0200585 0.0017545 43706.3 4; : 799 Minimum Test error found - save the configuration ; : 799 | 10.7942 14.6749 0.0201633 0.00182171 43616.6 0; : 800 Minimum Test erro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:97394,error,error,97394,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"3; ROOT::Fit::EChisquareType::kPLikeRatio@ kPLikeRatio; ROOT::Fit::EChisquareType::kNeyman@ kNeyman; ROOT::Fit::EChisquareType::kPearson@ kPearson; ROOT::gCoreMutexR__EXTERN TVirtualRWMutex * gCoreMutexDefinition TVirtualRWMutex.h:37; TMath::IsNaNBool_t IsNaN(Double_t x)Definition TMath.h:892; TMath::NintInt_t Nint(T x)Round to nearest integer. Rounds half integers to the nearest even integer.Definition TMath.h:693; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::ProbDouble_t Prob(Double_t chi2, Int_t ndf)Computation of the probability for a certain Chi-squared (chi2) and number of degrees of freedom (ndf...Definition TMath.cxx:637; TMath::MedianDouble_t Median(Long64_t n, const T *a, const Double_t *w=nullptr, Long64_t *work=nullptr)Same as RMS.Definition TMath.h:1272; TMath::QuietNaNDouble_t QuietNaN()Returns a quiet NaN as defined by IEEE 754.Definition TMath.h:902; TMath::FloorDouble_t Floor(Double_t x)Rounds x downward, returning the largest integral value that is not greater than x.Definition TMath.h:680; TMath::ATanDouble_t ATan(Double_t)Returns the principal value of the arc tangent of x, expressed in radians.Definition TMath.h:640; TMath::CeilDouble_t Ceil(Double_t x)Rounds x upward, returning the smallest integral value that is not less than x.Definition TMath.h:668; TMath::MinElementT MinElement(Long64_t n, const T *a)Returns minimum of array a of length n.Definition TMath.h:960; TMath::LogDouble_t Log(Double_t x)Returns the natural logarithm of x.Definition TMath.h:756; TMath::SqrtDouble_t Sqrt(Double_t x)Returns the square root of x.Definition TMath.h:662; TMath::PowerLongDouble_t Power(LongDouble_t x, LongDouble_t y)Returns x raised to the power y.Definition TMath.h:721; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::Piconstexpr Double_t Pi()Definition TMath.h:37; TMath::AreEqualRelBool_t AreEqualRel(Double_t af, Double_t bf, Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH1_8cxx_source.html:476165,down,downward,476165,doc/master/TH1_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH1_8cxx_source.html,1,['down'],['downward']
Availability,"3D histogram. ;  ; void SavePrimitive (std::ostream &out, Option_t *option="""") override;  Save primitive as a C++ statement(s) on output stream out. ;  ; void Scale (Double_t c1=1, Option_t *option="""") override;  Multiply this profile2D by a constant c1. ;  ; virtual void SetBinEntries (Int_t bin, Double_t w);  Set the number of entries in bin. ;  ; void SetBins (Int_t nbinsx, Double_t xmin, Double_t xmax, Int_t nbinsy, Double_t ymin, Double_t ymax, Int_t nbinsz, Double_t zmin, Double_t zmax) override;  Redefine x, y and z axis parameters. ;  ; void SetBins (Int_t nx, const Double_t *xBins, Int_t ny, const Double_t *yBins, Int_t nz, const Double_t *zBins) override;  Redefine x, y and z axis parameters with variable bin sizes. ;  ; void SetBinsLength (Int_t n=-1) override;  Set total number of bins including under/overflow. ;  ; void SetBuffer (Int_t buffersize, Option_t *opt="""") override;  Set the buffer size in units of 8 bytes (double). ;  ; virtual void SetErrorOption (Option_t *option="""");  Set option to compute profile3D errors. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TH3D. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Sumw2 (Bool_t flag=kTRUE) override;  Create/Delete structure to store sum of squares of weights per bin This is needed to compute the correct statistical quantities of a profile filled with weights. ;  ;  Public Member Functions inherited from TH3D;  TH3D ();  Constructor. ;  ;  TH3D (const char *name, const char *title, Int_t nbinsx, const Double_t *xbins, Int_t nbinsy, const Double_t *ybins, Int_t nbinsz, const Double_t *zbins);  Constructor for variable bin size 3-D histograms (see TH3::TH3 for explanation of parameters) ;  ;  TH3D (const char *name, const char *title, Int_t nbinsx, const Float_t *xbins, Int_t nbinsy, const Float_t *ybins, Int_t nbinsz, const Float_t *zbins);  Constructor for variable bin size 3-D histograms (see TH3::TH3 for explanation of parameters) ;  ;  TH3D (const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProfile3D.html:8431,error,errors,8431,doc/master/classTProfile3D.html,https://root.cern,https://root.cern/doc/master/classTProfile3D.html,1,['error'],['errors']
Availability,"3D.cxx:1288; TProfile3D::BuildOptionsvoid BuildOptions(Double_t tmin, Double_t tmax, Option_t *option)Set Profile3D histogram structure and options.Definition TProfile3D.cxx:141; TProfile3D::Classstatic TClass * Class(); TProfile3D::FillInt_t Fill(const Double_t *v)Definition TProfile3D.h:53; TProfile3D::fBinSumw2TArrayD fBinSumw2Array of sum of squares of weights per bin.Definition TProfile3D.h:41; TProfile3D::GetBDouble_t * GetB()Definition TProfile3D.h:73; TProfile3D::BufferEmptyInt_t BufferEmpty(Int_t action=0) overrideFill histogram with all entries in the buffer.Definition TProfile3D.cxx:246; TProfile3D::SetBuffervoid SetBuffer(Int_t buffersize, Option_t *opt="""") overrideSet the buffer size in units of 8 bytes (double).Definition TProfile3D.cxx:1327; TProfile3D::SavePrimitivevoid SavePrimitive(std::ostream &out, Option_t *option="""") overrideSave primitive as a C++ statement(s) on output stream out.Definition TProfile3D.cxx:1223; TProfile3D::SetErrorOptionvirtual void SetErrorOption(Option_t *option="""")Set option to compute profile3D errors.Definition TProfile3D.cxx:1365; TProfile3D::ProjectionXYZvirtual TH3D * ProjectionXYZ(const char *name=""_pxyz"", Option_t *option=""e"") constProject this profile3D into a 3-D histogram along X,Y,Z.Definition TProfile3D.cxx:961; TProfile3D::AddBool_t Add(TF1 *h1, Double_t c1=1, Option_t *option="""") overridePerforms the operation: this = this + c1*f1 .Definition TProfile3D.cxx:172; TProfile3D::GetBinContentDouble_t GetBinContent(Int_t bin) const overrideReturn bin content of a Profile3D histogram.Definition TProfile3D.cxx:691; TProfile3D::fErrorModeEErrorType fErrorModeOption to compute errors.Definition TProfile3D.h:35; TProfile3D::SetBinsLengthvoid SetBinsLength(Int_t n=-1) overrideSet total number of bins including under/overflow.Definition TProfile3D.cxx:1318; TProfile3D::GetBinEntriesvirtual Double_t GetBinEntries(Int_t bin) constReturn bin entries of a Profile3D histogram.Definition TProfile3D.cxx:704; TProfile3D::GetW2Doub",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TProfile3D_8cxx_source.html:67614,error,errors,67614,doc/master/TProfile3D_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TProfile3D_8cxx_source.html,1,['error'],['errors']
Availability,"3Ref<double,unsigned int,double,unsigned int>(const RooCFunction3Ref<double,unsigned int,double,unsigned int>&); virtual~RooCFunction3Ref<double,unsigned int,double,unsigned int>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*argName(Int_t iarg); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static RooCFunction3Map<double,unsigned int,double,unsigned int>&fmap(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_double_unsigned_int_.html:2214,Error,Error,2214,root/html534/RooCFunction3Ref_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_double_unsigned_int_.html,1,['Error'],['Error']
Availability,"3Ref<double,unsigned int,unsigned int,double>(const RooCFunction3Ref<double,unsigned int,unsigned int,double>&); virtual~RooCFunction3Ref<double,unsigned int,unsigned int,double>(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); const char*argName(Int_t iarg); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTObject::Clear(Option_t* = """"); virtual TObject*TObject::Clone(const char* newname = """") const; virtual Int_tTObject::Compare(const TObject* obj) const; virtual voidTObject::Copy(TObject& object) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidTObject::Draw(Option_t* option = """"); virtual voidTObject::DrawClass() constMENU ; virtual TObject*TObject::DrawClone(Option_t* option = """") constMENU ; virtual voidTObject::Dump() constMENU ; virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; static RooCFunction3Map<double,unsigned int,unsigned int,double>&fmap(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); virtual const char*TObject::GetIconName() const; virtual const char*TObject::GetName() const; virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual Option_t*TObject::GetOption() const; virtual const char*TObject::GetTitle() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_unsigned_int_double_.html:2214,Error,Error,2214,root/html534/RooCFunction3Ref_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Ref_double_unsigned_int_unsigned_int_double_.html,1,['Error'],['Error']
Availability,"3\anchor C03; 184## Bright and dark colors; 185Dark and bright colors are used to add 3D effects to graphical objects like; 186TWbox, TPave, TPaveText, TPaveLabel, etc. and in colored lego plots.; 187 ; 188Two static functions are available that return the bright or dark color number corresponding; 189to a given color index. If these variants don't already exist, they are created as needed:; 190~~~ {.cpp}; 191 Int_t dark = TColor::GetColorDark(color_index);; 192 Int_t bright = TColor::GetColorBright(color_index);; 193~~~; 194 ; 195\anchor C031; 196## Accessible Color Schemes; 197Choosing an appropriate color scheme is essential for making results easy to understand and; 198interpret. Factors like colorblindness and converting colors to grayscale for publications; 199can impact accessibility. Furthermore, results should be aesthetically pleasing. The following; 200three color schemes, recommended by M. Petroff in [arXiv:2107.02270v2](https://arxiv.org/pdf/2107.02270); 201and available on [GitHub](https://github.com/mpetroff/accessible-color-cycles); 202under the MIT License, meet these criteria.; 203 ; 204These three color schemes are available as color sets with 6, 8, and 10 colors, named; 205`kP[6, 8, 10]ColorName`. For example, `kP6Red` represents the red color within the P6 color scheme; 206(`P` for Petroff or Preferred).; 207 ; 208Begin_Macro; 209../../../tutorials/graphics/accessiblecolorschemes.C; 210End_Macro; 211 ; 212The example thstackcolorscheme.C illustrates how to use these color schemes in THStack drawings.; 213It also demonstrates that they are effective in grayscale.; 214 ; 215\anchor C04; 216## Grayscale view of of canvas with colors; 217One can toggle between a grayscale preview and the regular colored mode using; 218`TCanvas::SetGrayscale()`. Note that in grayscale mode, access via RGB; 219will return grayscale values according to ITU standards (and close to b&w; 220printer gray-scales), while access via HLS returns de-saturated gray-scales. The; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:7153,avail,available,7153,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['avail'],['available']
Availability,"3]. TPServerSocket::TPServerSocket ; (; const TPServerSocket & ; ). privatedelete . ◆ TPServerSocket() [2/3]. TPServerSocket::TPServerSocket ; (; Int_t ; port, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object on a specified port. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 = no error (socket is valid) -1 = low level socket() call failed -2 = low level bind() call failed -3 = low level listen() call failed Every valid server socket is added to the TROOT sockets list which will make sure that any open sockets are properly closed on program termination. ; Definition at line 49 of file TPServerSocket.cxx. ◆ TPServerSocket() [3/3]. TPServerSocket::TPServerSocket ; (; const char * ; service, . Bool_t ; reuse = kFALSE, . Int_t ; backlog = kDefaultBacklog, . Int_t ; tcpwindowsize = -1 . ). Create a parallel server socket object for a named service. ; Set reuse to true to force reuse of the server socket (i.e. do not wait for the time out to pass). Using backlog one can set the desirable queue length for pending connections. Use tcpwindowsize to specify the size of the receive buffer, it has to be specified here to make sure the window scale option is set (for tcpwindowsize > 65KB and for platforms supporting window scaling). Use IsValid() to check the validity of the server socket. In case server socket is not valid use GetErrorCode() to obtain the specific error value. These values are: 0 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPServerSocket.html:20514,error,error,20514,doc/master/classTPServerSocket.html,https://root.cern,https://root.cern/doc/master/classTPServerSocket.html,1,['error'],['error']
Availability,"3]. virtual void TH1::SetBinContent ; (; Int_t ; bin, . Int_t ; , . Int_t ; , . Double_t ; content . ). inlinevirtual . Reimplemented in TH3, TH2, and TH2Poly.; Definition at line 368 of file TH1.h. ◆ SetBinError() [1/3]. void TH1::SetBinError ; (; Int_t ; bin, . Double_t ; error . ). virtual . Set the bin Error Note that this resets the bin eror option to be of Normal Type and for the non-empty bin the bin error is set by default to the square root of their content. ; Note that in case the user sets after calling SetBinError explicitly a new bin content (e.g. using SetBinContent) he needs then to provide also the corresponding bin error (using SetBinError) since the bin error will not be recalculated after setting the content and a default error = 0 will be used for those bins.; See convention for numbering bins in TH1::GetBin ; Reimplemented in TH2Poly.; Definition at line 9206 of file TH1.cxx. ◆ SetBinError() [2/3]. void TH1::SetBinError ; (; Int_t ; binx, . Int_t ; biny, . Double_t ; error . ). virtual . See convention for numbering bins in TH1::GetBin. ; Reimplemented in TH2Poly.; Definition at line 9241 of file TH1.cxx. ◆ SetBinError() [3/3]. void TH1::SetBinError ; (; Int_t ; binx, . Int_t ; biny, . Int_t ; binz, . Double_t ; error . ). virtual . See convention for numbering bins in TH1::GetBin. ; Reimplemented in TH2Poly.; Definition at line 9251 of file TH1.cxx. ◆ SetBinErrorOption(). virtual void TH1::SetBinErrorOption ; (; EBinErrorOpt ; type). inlinevirtual . Definition at line 381 of file TH1.h. ◆ SetBins() [1/6]. void TH1::SetBins ; (; Int_t ; nx, . const Double_t * ; xBins . ). virtual . Redefine x axis parameters with variable bin sizes. ; The X axis parameters are modified. The bins content array is resized if errors (Sumw2) the errors array is resized The previous bin contents are lost To change only the axis limits, see TAxis::SetRange xBins is supposed to be of length nx+1 ; Reimplemented in TProfile, TProfile2D, and TProfile3D.; Definition at lin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH1.html:204442,error,error,204442,doc/master/classTH1.html,https://root.cern,https://root.cern/doc/master/classTH1.html,1,['error'],['error']
Availability,"4 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 4 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 128 , 1 ) Activation Function = Identity; : Using 11200 events for training and 2800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.868652; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.659892 0.620582 0.589558 0.0469541 20523.3 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.604286 0.594787 0.586926 0.0471912 20632.4 0; : 3 | 0.58117 0.603906 0.587335 0.047007 20609.7 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.57382 0.588714 0.592175 0.0469679 20425.3 0; : 5 | 0.569519 0.59535 0.590168 0.0468081 20494.7 1; : 6 | 0.567869 0.590023 0.589038 0.0469022 20541 2; : 7 Minimum Test error found - save the configuration ; : 7 | 0.561012 0.586993 0.590467 0.0471223 20495.3 0; : 8 | 0.559195 0.590522 0.590271 0.0471869 20505.1 1; : 9 | 0.558998 0.588766 0.598449 0.0469787 20193.3 2; : 10 | 0.555383 0.590075 0.591595 0.0470733 20451 3; : 11 Minimum Test error found - save the configuration ; : 11 | 0.555591 0.582449 0.595129 0.047292 20327.2 0; : 12 Minimum Test error found - save the configuration ; : 12 | 0.550993 0.581236 0.592181 0.0472746 20436.5 0; : 13 | 0.548186 0.58351 0.592876 0.0471057 20404.2 1; : 14 | 0.547427 0.581875 0.592374 0.0471592 20425 2; : 15 Minimum Test error found - save the configuratio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:24371,error,error,24371,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['error'],['error']
Availability,"4 gInterpreter->SetClassInfo(this, kFALSE, silent); // sets fClassInfo pointer; 1585 if (fClassInfo) {; 1586 // This should be moved out of GetCheckSum itself however the last time; 1587 // we tried this cause problem, in particular in the end-of-process operation.; 1588 // fCheckSum = GetCheckSum(kLatestCheckSum);; 1589 } else {; 1590 if (!fClassInfo) {; 1591 if (IsZombie()) {; 1592 TClass::RemoveClass(this);; 1593 return;; 1594 }; 1595 }; 1596 }; 1597 }; 1598 }; 1599 if (!silent && (!fClassInfo && !fCanLoadClassInfo) && !isStl && !TClassEdit::IsArtificial(fName) &&; 1600 !TClassEdit::IsInterpreterDetail(fName.Data()) ) {; 1601 if (fState == kHasTClassInit) {; 1602 if (fImplFileLine == -1 && fClassVersion == 0) {; 1603 // We have a 'transient' class with a ClassDefInline and apparently no interpreter; 1604 // information. Since it is transient, it is more than likely that the lack; 1605 // will be harmles.; 1606 } else {; 1607 ::Error(""TClass::Init"", ""no interpreter information for class %s is available even though it has a TClass ""; 1608 ""initialization routine."",; 1609 fName.Data());; 1610 }; 1611 } else {; 1612 const bool ispairbase = TClassEdit::IsStdPairBase(fName.Data()) && !IsFromRootCling();; 1613 if (!ispairbase); 1614 ::Warning(""TClass::Init"", ""no dictionary for class %s is available"", fName.Data());; 1615 }; 1616 }; 1617 ; 1618 fgClassCount++;; 1619 SetUniqueID(fgClassCount);; 1620 ; 1621 // Make the typedef-expanded -> original hash table entries.; 1622 // There may be several entries for any given key.; 1623 // We only make entries if the typedef-expanded name; 1624 // is different from the original name.; 1625 TString resolvedThis;; 1626 if (!givenInfo && strchr (name, '<')) {; 1627 if ( fName != name) {; 1628 if (!fgClassTypedefHash) {; 1629 fgClassTypedefHash = new THashTable (100, 5);; 1630 fgClassTypedefHash->SetOwner (kTRUE);; 1631 }; 1632 ; 1633 fgClassTypedefHash->Add (new TNameMapNode (name, fName));; 1634 SetBit (kHasNameMapNode);; 1635 ; 163",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:62428,avail,available,62428,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['avail'],['available']
Availability,"4 if (!format_.IsDigit()) {; 285 Error(""TGraphErrors"", ""Incorrect input format! Allowed format tags are {\""%%lg\"",\""%%*lg\"" or \""%%*s\""}"");; 286 return ;; 287 }; 288 Int_t ntokens = format_.Length() ;; 289 if (ntokens < 2) {; 290 Error(""TGraphErrors"", ""Incorrect input format! Only %d tag(s) in format whereas at least 2 \""%%lg\"" tags are expected!"", ntokens);; 291 return ;; 292 }; 293 Int_t ntokensToBeSaved = 0 ;; 294 Bool_t * isTokenToBeSaved = new Bool_t [ntokens] ;; 295 for (Int_t idx = 0; idx < ntokens; idx++) {; 296 isTokenToBeSaved[idx] = TString::Format(""%c"", format_[idx]).Atoi() ; //atoi(&format_[idx]) does not work for some reason...; 297 if (isTokenToBeSaved[idx] == 1) {; 298 ntokensToBeSaved++ ;; 299 }; 300 }; 301 if (ntokens >= 2 && (ntokensToBeSaved < 2 || ntokensToBeSaved > 4)) { //first condition not to repeat the previous error message; 302 Error(""TGraphErrors"", ""Incorrect input format! There are %d \""%%lg\"" tag(s) in format whereas 2,3 or 4 are expected!"", ntokensToBeSaved);; 303 delete [] isTokenToBeSaved ;; 304 return ;; 305 }; 306 ; 307 // Initializing loop variables; 308 Bool_t isLineToBeSkipped = kFALSE; //empty and ill-formed lines; 309 char *token = nullptr;; 310 TString token_str = """";; 311 Int_t token_idx = 0;; 312 Double_t value[4]; //x,y,ex,ey buffers; 313 for (Int_t k = 0; k < 4; k++); 314 value[k] = 0.;; 315 Int_t value_idx = 0;; 316 ; 317 // Looping; 318 char *rest;; 319 while (std::getline(infile, line, '\n')) {; 320 if (!line.empty()) {; 321 if (line[line.size() - 1] == char(13)) { // removing DOS CR character; 322 line.erase(line.end() - 1, line.end()) ;; 323 }; 324 token = R__STRTOK_R(const_cast<char *>(line.c_str()), option, &rest);; 325 while (token != nullptr && value_idx < ntokensToBeSaved) {; 326 if (isTokenToBeSaved[token_idx]) {; 327 token_str = TString(token) ;; 328 token_str.ReplaceAll(""\t"", """") ;; 329 if (!token_str.IsFloat()) {; 330 isLineToBeSkipped = kTRUE ;; 331 break ;; 332 } else {; 333 value[value_idx] = token_str.At",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8cxx_source.html:10349,error,error,10349,doc/master/TGraphErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8cxx_source.html,1,['error'],['error']
Availability,"4 if (error) {; 12565 mg_cry_internal(; 12566 conn,; 12567 ""%s"",; 12568 ""Websocket pull failed; closing connection"");; 12569 if (data != mem) {; 12570 mg_free(data);; 12571 }; 12572 break;; 12573 }; 12574 ; 12575 conn->data_len = conn->request_len;; 12576 ; 12577 } else {; 12578 ; 12579 mop = buf[0]; /* current mask and opcode, overwritten by; 12580 * memmove() */; 12581 ; 12582 /* Length of the message being read at the front of the; 12583 * queue. Cast to 31 bit is OK, since we limited; 12584 * data_len before. */; 12585 len = (size_t)data_len + header_len;; 12586 ; 12587 /* Copy the data payload into the data pointer for the; 12588 * callback. Cast to 31 bit is OK, since we; 12589 * limited data_len */; 12590 memcpy(data, buf + header_len, (size_t)data_len);; 12591 ; 12592 /* Move the queue forward len bytes */; 12593 memmove(buf, buf + len, body_len - len);; 12594 ; 12595 /* Mark the queue as advanced */; 12596 conn->data_len -= (int)len;; 12597 }; 12598 ; 12599 /* Apply mask if necessary */; 12600 if (mask_len > 0) {; 12601 for (i = 0; i < (size_t)data_len; i++) {; 12602 data[i] ^= mask[i & 3];; 12603 }; 12604 }; 12605 ; 12606 exit_by_callback = 0;; 12607 if (enable_ping_pong && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PONG)) {; 12608 /* filter PONG messages */; 12609 DEBUG_TRACE(""PONG from %s:%u"",; 12610 conn->request_info.remote_addr,; 12611 conn->request_info.remote_port);; 12612 /* No unanwered PINGs left */; 12613 ping_count = 0;; 12614 } else if (enable_ping_pong; 12615 && ((mop & 0xF) == MG_WEBSOCKET_OPCODE_PING)) {; 12616 /* reply PING messages */; 12617 DEBUG_TRACE(""Reply PING from %s:%u"",; 12618 conn->request_info.remote_addr,; 12619 conn->request_info.remote_port);; 12620 ret = mg_websocket_write(conn,; 12621 MG_WEBSOCKET_OPCODE_PONG,; 12622 (char *)data,; 12623 (size_t)data_len);; 12624 if (ret <= 0) {; 12625 /* Error: send failed */; 12626 DEBUG_TRACE(""Reply PONG failed (%i)"", ret);; 12627 break;; 12628 }; 12629 ; 12630 ; 12631 } else {; 12632 /* Exit t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:365879,mask,mask,365879,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['mask'],['mask']
Availability,"4 int once = 0;; 4515 if (flag == -1) {; 4516 flag = 0;; 4517 once = 1;; 4518 }; 4519 if (flag == MSG_PEEK); 4520 once = 1;; 4521 ; 4522 int n, nrecv = 0;; 4523 char *buf = (char *)buffer;; 4524 ; 4525 for (n = 0; n < length; n += nrecv) {; 4526 if ((nrecv = recv(sock, buf+n, length-n, flag)) <= 0) {; 4527 if (nrecv == 0); 4528 break; // EOF; 4529 if (flag == MSG_OOB) {; 4530 if (GetErrno() == EWOULDBLOCK); 4531 return -2;; 4532 else if (GetErrno() == EINVAL); 4533 return -3;; 4534 }; 4535 if (GetErrno() == EWOULDBLOCK); 4536 return -4;; 4537 else {; 4538 if (GetErrno() != EINTR); 4539 ::SysError(""TUnixSystem::UnixRecv"", ""recv"");; 4540 if (GetErrno() == EPIPE || GetErrno() == ECONNRESET); 4541 return -5;; 4542 else; 4543 return -1;; 4544 }; 4545 }; 4546 if (once); 4547 return nrecv;; 4548 }; 4549 return n;; 4550}; 4551 ; 4552////////////////////////////////////////////////////////////////////////////////; 4553/// Send exactly length bytes from buffer. Returns -1 in case of error,; 4554/// otherwise number of sent bytes. Returns -4 in case of kNoBlock and; 4555/// errno == EWOULDBLOCK. Returns -5 if pipe broken or reset by peer; 4556/// (EPIPE || ECONNRESET).; 4557 ; 4558int TUnixSystem::UnixSend(int sock, const void *buffer, int length, int flag); 4559{; 4560 if (sock < 0) return -1;; 4561 ; 4562 int once = 0;; 4563 if (flag == -1) {; 4564 flag = 0;; 4565 once = 1;; 4566 }; 4567 ; 4568 int n, nsent = 0;; 4569 const char *buf = (const char *)buffer;; 4570 ; 4571 for (n = 0; n < length; n += nsent) {; 4572 if ((nsent = send(sock, buf+n, length-n, flag)) <= 0) {; 4573 if (nsent == 0); 4574 break;; 4575 if (GetErrno() == EWOULDBLOCK); 4576 return -4;; 4577 else {; 4578 if (GetErrno() != EINTR); 4579 ::SysError(""TUnixSystem::UnixSend"", ""send"");; 4580 if (GetErrno() == EPIPE || GetErrno() == ECONNRESET); 4581 return -5;; 4582 else; 4583 return -1;; 4584 }; 4585 }; 4586 if (once); 4587 return nsent;; 4588 }; 4589 return n;; 4590}; 4591 ; 4592//---- Dynamic Loading --------",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TUnixSystem_8cxx_source.html:145817,error,error,145817,doc/master/TUnixSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TUnixSystem_8cxx_source.html,1,['error'],['error']
Availability,"4 of file TListOfFunctions.cxx. ◆ MakeIterator(). TIterator * TListOfFunctions::MakeIterator ; (; Bool_t ; dir = kIterForward); const. overridevirtual . Return a list iterator. ; Reimplemented from TList.; Definition at line 451 of file TListOfFunctions.cxx. ◆ MapObject(). void TListOfFunctions::MapObject ; (; TObject * ; obj). private . Add pair<id, object> to the map of functions and their ids. ; Definition at line 51 of file TListOfFunctions.cxx. ◆ operator=(). TListOfFunctions & TListOfFunctions::operator= ; (; const TListOfFunctions & ; ). privatedelete . ◆ RecursiveRemove(). void TListOfFunctions::RecursiveRemove ; (; TObject * ; obj). overridevirtual . Remove object from this collection and recursively remove the object from all other objects (and collections). ; This function overrides TCollection::RecursiveRemove that calls the Remove function. THashList::Remove cannot be called because it uses the hash value of the hash table. This hash value is not available anymore when RecursiveRemove is called from the TObject destructor. ; Reimplemented from THashList.; Definition at line 328 of file TListOfFunctions.cxx. ◆ Remove() [1/2]. TObject * TListOfFunctions::Remove ; (; TObject * ; obj). overridevirtual . Remove object from the list. ; Reimplemented from THashList.; Definition at line 341 of file TListOfFunctions.cxx. ◆ Remove() [2/2]. TObject * TListOfFunctions::Remove ; (; TObjLink * ; lnk). overridevirtual . Remove object via its objlink from the list. ; Reimplemented from THashList.; Definition at line 357 of file TListOfFunctions.cxx. ◆ Streamer(). void TListOfFunctions::Streamer ; (; TBuffer & ; b). overridevirtual . Stream all objects in the collection to or from the I/O buffer. ; Reimplemented from THashList. ◆ StreamerNVirtual(). void TListOfFunctions::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 102 of file TListOfFunctions.h. ◆ Unload() [1/2]. void TListOfFunctions::Unload ; (; ). Mark 'all func' as bei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfFunctions.html:33178,avail,available,33178,doc/master/classTListOfFunctions.html,https://root.cern,https://root.cern/doc/master/classTListOfFunctions.html,1,['avail'],['available']
Availability,"4 out->write(&buffer.front(), buffer.size());; 2025 ; 2026 // Make sure it hits disk now.; 2027 out->flush();; 2028 ; 2029 return true;; 2030}; 2031 ; 2032////////////////////////////////////////////////////////////////////////////////; 2033/// Generates a PCH from the given ModuleGenerator and CompilerInstance.; 2034/// Returns true iff the PCH was successfully generated.; 2035static bool GenerateAllDict(TModuleGenerator &modGen, clang::CompilerInstance *compilerInstance,; 2036 const std::string &currentDirectory); 2037{; 2038 assert(modGen.IsPCH() && ""modGen must be in PCH mode"");; 2039 ; 2040 std::string iSysRoot(""/DUMMY_SYSROOT/include/"");; 2041 if (gBuildingROOT) iSysRoot = (currentDirectory + ""/"");; 2042 return WriteAST(modGen.GetModuleFileName(), compilerInstance, iSysRoot);; 2043}; 2044 ; 2045////////////////////////////////////////////////////////////////////////////////; 2046/// Includes all given headers in the interpreter. Returns true when we could; 2047/// include the headers and otherwise false on an error when including.; 2048static bool IncludeHeaders(const std::vector<std::string> &headers, cling::Interpreter &interpreter); 2049{; 2050 // If no headers are given, this is a no-op.; 2051 if (headers.empty()); 2052 return true;; 2053 ; 2054 // Turn every header name into an include and parse it in the interpreter.; 2055 std::stringstream includes;; 2056 for (const std::string &header : headers) {; 2057 includes << ""#include \"""" << header << ""\""\n"";; 2058 }; 2059 std::string includeListStr = includes.str();; 2060 auto result = interpreter.declare(includeListStr);; 2061 return result == cling::Interpreter::CompilationResult::kSuccess;; 2062}; 2063 ; 2064 ; 2065////////////////////////////////////////////////////////////////////////////////; 2066 ; 2067void AddPlatformDefines(std::vector<std::string> &clingArgs); 2068{; 2069 char platformDefines[64] = {0};; 2070#ifdef __INTEL_COMPILER; 2071 snprintf(platformDefines, 64, ""-DG__INTEL_COMPILER=%ld"", (long)_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootcling__impl_8cxx_source.html:81131,error,error,81131,doc/master/rootcling__impl_8cxx_source.html,https://root.cern,https://root.cern/doc/master/rootcling__impl_8cxx_source.html,1,['error'],['error']
Availability,"4#include ""TMultiGraph.h""; 35#include ""TList.h""; 36#include ""TError.h""; 37 ; 38 ; 39//#define DEBUG; 40#ifdef DEBUG; 41#include ""TClass.h""; 42#include <iostream>; 43#endif; 44 ; 45 ; 46namespace ROOT {; 47 ; 48namespace Fit {; 49 ; 50// add a namespace to distinguish from the Graph functions; 51namespace HFitInterface {; 52 ; 53 ; 54bool IsPointOutOfRange(const TF1 * func, const double * x) {; 55 // function to check if a point is outside range; 56 if (func ==nullptr) return false;; 57 return !func->IsInside(x);; 58}; 59 ; 60bool AdjustError(const DataOptions & option, double & error, double value = 1) {; 61 // adjust the given error according to the option; 62 // return false when point must be skipped.; 63 // When point error = 0, the point is kept if the option UseEmpty is set or if; 64 // fErrors1 is set and the point value is not zero.; 65 // The value should be used only for points representing counts (histograms), not for the graph.; 66 // In the graph points with zero errors are by default skipped indepentently of the value.; 67 // If one wants to keep the points, the option fUseEmpty must be set; 68 ; 69 if (error <= 0) {; 70 if (option.fUseEmpty || (option.fErrors1 && std::abs(value) > 0 ) ); 71 error = 1.; // set error to 1; 72 else; 73 return false; // skip bins with zero errors or empty; 74 } else if (option.fErrors1); 75 error = 1; // set all error to 1 for non-empty bins; 76 return true;; 77}; 78 ; 79void ExamineRange(const TAxis * axis, std::pair<double,double> range,int &hxfirst,int &hxlast) {; 80 // examine the range given with the pair on the given histogram axis; 81 // correct in case the bin values hxfirst hxlast; 82 double xlow = range.first;; 83 double xhigh = range.second;; 84#ifdef DEBUG; 85 std::cout << ""xlow "" << xlow << "" xhigh = "" << xhigh << std::endl;; 86#endif; 87 // ignore ranges specified outside histogram range; 88 int ilow = axis->FindFixBin(xlow);; 89 int ihigh = axis->FindFixBin(xhigh);; 90 if (ilow > hxlast || ihigh < hxfirst) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/HFitInterface_8cxx_source.html:2030,error,errors,2030,doc/master/HFitInterface_8cxx_source.html,https://root.cern,https://root.cern/doc/master/HFitInterface_8cxx_source.html,1,['error'],['errors']
Availability,"4, 3.0, 6.0);; RooGaussian g2(""g2"", ""g2"", x, mean, sigma_g2);; ; RooRealVar frac(""frac"", ""frac"", 0.5, 0.0, 1.0);; RooAddPdf model(""model"", ""model"", RooArgList(g1, g2), frac);; ; // Generate 1000 events; std::unique_ptr<RooDataSet> data{model.generate(x, 1000)};; ; // Construct unbinned likelihood of model w.r.t. data; std::unique_ptr<RooAbsReal> nll{model.createNLL(*data)};; ; // I n t e r a c t i v e m i n i m i z a t i o n , e r r o r a n a l y s i s; // -------------------------------------------------------------------------------; ; // Create MINUIT interface object; RooMinimizer m(*nll);; ; // Activate verbose logging of MINUIT parameter space stepping; m.setVerbose(true);; ; // Call MIGRAD to minimize the likelihood; m.migrad();; ; // Print values of all parameters, that reflect values (and error estimates); // that are back propagated from MINUIT; std::unique_ptr<RooArgSet>{model.getParameters(x)}->Print(""s"");; ; // Disable verbose logging; m.setVerbose(false);; ; // Run HESSE to calculate errors from d2L/dp2; m.hesse();; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // Run MINOS on sigma_g2 parameter only; m.minos(sigma_g2);; ; // Print value (and error) of sigma_g2 parameter, that reflects; // value and error back propagated from MINUIT; sigma_g2.Print();; ; // S a v i n g r e s u l t s , c o n t o u r p l o t s; // ---------------------------------------------------------; ; // Save a snapshot of the fit result. This object contains the initial; // fit parameters, the final fit parameters, the complete correlation; // matrix, the EDM, the minimized FCN , the last MINUIT status code and; // the number of times the RooFit function object has indicated evaluation; // problems (e.g. zero probabilities during likelihood evaluation); std::unique_ptr<RooFitResult> fitResult{m.save()};; ; // Make contour plot of mx vs sx at 1,2,3 sigma; RooPlot *frame = m.contour(frac, sigma_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf601__intminuit_8C.html:2016,error,errors,2016,doc/master/rf601__intminuit_8C.html,https://root.cern,https://root.cern/doc/master/rf601__intminuit_8C.html,1,['error'],['errors']
Availability,"4, p5, p6, p7, p8;; 198 Double_t px2, py2;; 199 p2 = p3 = p4 = p5 = p6 = p7 = p8 = kFALSE;; 200 if (!gPad->IsEditable()) return;; 201 switch (event) {; 202 case kMouseMotion:; 203 px1 = gPad->XtoAbsPixel(TMath::Cos(GetAngle()));; 204 py1 = gPad->YtoAbsPixel(TMath::Sin(GetAngle()));; 205 d1 = TMath::Abs(px1 - px) + TMath::Abs(py1-py); //simply take sum of pixels differences; 206 p1 = kFALSE;; 207 px2 = gPad->XtoAbsPixel(-1);; 208 py2 = gPad->YtoAbsPixel(1);; 209 d2 = (Int_t)(TMath::Abs(px2 - px) + TMath::Abs(py2 - py)) ;; 210 px3 = gPad->XtoAbsPixel(-1);; 211 py3 = gPad->YtoAbsPixel(-1);; 212 d3 = TMath::Abs(px3 - px) + TMath::Abs(py3 - py) ; //simply take sum of pixels differences; 213 // check if point is close to the radial axis; 214 if (d1 < kMaxDiff) {; 215 gPad->SetCursor(kMove);; 216 p1 = kTRUE;; 217 }; 218 // check if point is close to the left high axis; 219 if ( d2 < kMaxDiff) {; 220 gPad->SetCursor(kHand);; 221 p7 = kTRUE;; 222 }; 223 // check if point is close to the left down axis; 224 if ( d3 < kMaxDiff) {; 225 gPad->SetCursor(kHand);; 226 p8 = kTRUE;; 227 }; 228 // check if point is close to a main circle; 229 if (!p1 && !p7 ) {; 230 p6 = kTRUE;; 231 gPad->SetCursor(kHand);; 232 }; 233 break;; 234 ; 235 case kButton1Down:; 236 // Record initial coordinates; 237 //px4 = px;; 238 //py4 = py;; 239 ; 240 case kButton1Motion:; 241 if (p1) {; 242 px2 = gPad->AbsPixeltoX(px);; 243 py2 = gPad->AbsPixeltoY(py);; 244 if ( px2 < 0 && py2 < 0) {p2 = kTRUE;};; 245 if ( px2 < 0 && py2 > 0 ) {p3 = kTRUE;};; 246 if ( px2 > 0 && py2 > 0 ) {p4 = kTRUE;};; 247 if ( px2 > 0 && py2 < 0 ) {p5 = kTRUE;};; 248 px2 = TMath::ACos(TMath::Abs(px2));; 249 py2 = TMath::ASin(TMath::Abs(py2));; 250 if (p2) {; 251 fAxisAngle = TMath::Pi()+(px2+py2)/2;; 252 p2 = kFALSE;; 253 };; 254 if (p3) {; 255 fAxisAngle = TMath::Pi()-(px2+py2)/2;; 256 p3 = kFALSE;; 257 };; 258 if (p4) {; 259 fAxisAngle = (px2+py2)/2;; 260 p4 = kFALSE;; 261 };; 262 if (p5) {; 263 fAxisAngle = -(px2+py2)/2;; 264 p5 =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html:7037,down,down,7037,doc/master/TGraphPolargram_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphPolargram_8cxx_source.html,1,['down'],['down']
Availability,"4. starts with an environment variable (""$ROOTSYS/bin""). void NoMsg(Int_t errorLevel); [static utility function]. calling ""NoMsg( errorLevel )"",; sets ""gErrorIgnoreLevel"" to ""errorLevel+1"" so that; all errors with ""level < errorLevel"" will be ignored. calling the function with a negative argument; (e.g., ""NoMsg( -1 )""); resets gErrorIgnoreLevel to its previous value. Int_t Complete(const TRegexp& re, const TSeqCollection* pListOfCandidates, const char* appendage, ostream& out, TString::ECaseCompare cmp = TString::kExact); [private]. void CopyMatch(char* dest, const char* localName, const char* appendage = 0, const char* fullName = 0) const; [private]. TString DeterminePath(const TString& fileName, const char* defaultPath) const; [private]. TString ExtendPath(const char* originalPath, TString newBase) const; [private]. Int_t Hook(char* buf, int* pLoc, ostream& out); [private]. void InitPatterns(); [private]. TClass * MakeClassFromClassName(const char* className) const; [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a class.; user must delete.; returns 0 in case of error. TClass * TryMakeClassFromClassName(const char* className) const; Same as above but does not print the error message. TClass * MakeClassFromVarName(const char* varName, TTabCom::EContext_t& context, int iter = 0); [private]; (does some specific error handling that makes the function unsuitable for general use.); returns a new'd TClass given the name of a variable.; user must delete.; returns 0 in case of error.; if user has operator.() or operator->() backwards, will modify: context, *fpLoc and fBuf.; context sensitive behavior. void SetPattern(TTabCom::EContext_t handle, const char* regexp); [private]. int ParseReverse(const char* var_str, int start). Returns the place in the string where to put the \0, starting the search; from ""start"". TTabCom(). TTabCom& operator=(const TTabCom& ). EContext_t DetermineCon",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTabCom.html:11809,error,error,11809,root/html530/TTabCom.html,https://root.cern,https://root.cern/root/html530/TTabCom.html,5,['error'],['error']
Availability,4.3 0; : 604 Minimum Test error found - save the configuration ; : 604 | 115.282 75.4842 0.0201093 0.00181811 43737 0; : 605 Minimum Test error found - save the configuration ; : 605 | 113.756 74.5415 0.0201179 0.00181105 43699.5 0; : 606 Minimum Test error found - save the configuration ; : 606 | 112.65 73.8117 0.0200987 0.00180944 43741.5 0; : 607 Minimum Test error found - save the configuration ; : 607 | 110.993 73.1273 0.0200934 0.00180455 43742.6 0; : 608 Minimum Test error found - save the configuration ; : 608 | 109.653 72.3206 0.0201066 0.00180567 43713.6 0; : 609 Minimum Test error found - save the configuration ; : 609 | 108.357 71.632 0.0200983 0.00180999 43743.9 0; : 610 Minimum Test error found - save the configuration ; : 610 | 106.875 70.7773 0.0201154 0.00182046 43728 0; : 611 | 105.742 70.7984 0.0200525 0.00175765 43728.1 1; : 612 Minimum Test error found - save the configuration ; : 612 | 104.268 69.338 0.0202166 0.00183521 43522.3 0; : 613 Minimum Test error found - save the configuration ; : 613 | 102.858 68.9009 0.0202348 0.00182917 43464.9 0; : 614 Minimum Test error found - save the configuration ; : 614 | 101.983 68.108 0.0201318 0.00182452 43698.5 0; : 615 Minimum Test error found - save the configuration ; : 615 | 100.329 67.3723 0.0201441 0.00182383 43667.6 0; : 616 Minimum Test error found - save the configuration ; : 616 | 99.0728 66.9343 0.0201375 0.00182665 43689.9 0; : 617 Minimum Test error found - save the configuration ; : 617 | 97.8374 65.9501 0.0201618 0.00184005 43664 0; : 618 Minimum Test error found - save the configuration ; : 618 | 96.3739 65.107 0.0201565 0.0018204 43629.8 0; : 619 Minimum Test error found - save the configuration ; : 619 | 95.4431 64.9258 0.0202106 0.00183339 43532.2 0; : 620 Minimum Test error found - save the configuration ; : 620 | 94.1902 64.0162 0.020412 0.0018551 43110.6 0; : 621 Minimum Test error found - save the configuration ; : 621 | 92.9103 63.3038 0.0201905 0.00182603 43562.4 0; : 622 Minimum ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:80214,error,error,80214,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,4.4 0; : 668 | 49.9429 40.0919 0.0200598 0.00176937 43738.7 1; : 669 Minimum Test error found - save the configuration ; : 669 | 49.7924 39.9525 0.02013 0.00182828 43711.6 0; : 670 Minimum Test error found - save the configuration ; : 670 | 48.9056 38.9634 0.0204345 0.00193878 43253.1 0; : 671 Minimum Test error found - save the configuration ; : 671 | 47.9479 38.4436 0.0207053 0.00182816 42379.4 0; : 672 | 47.2853 39.0804 0.0202162 0.00175216 43327.4 1; : 673 Minimum Test error found - save the configuration ; : 673 | 47.0153 38.3207 0.0201285 0.00181671 43687.7 0; : 674 Minimum Test error found - save the configuration ; : 674 | 46.5986 38.0788 0.0201224 0.00182147 43713.7 0; : 675 Minimum Test error found - save the configuration ; : 675 | 45.6663 37.2199 0.020138 0.00182969 43696.1 0; : 676 Minimum Test error found - save the configuration ; : 676 | 44.8146 36.9047 0.0201419 0.00182761 43681.7 0; : 677 | 44.1854 37.155 0.0200983 0.0017637 43633.4 1; : 678 Minimum Test error found - save the configuration ; : 678 | 43.7163 36.54 0.0202108 0.00183597 43537.9 0; : 679 Minimum Test error found - save the configuration ; : 679 | 43.1003 36.3421 0.0201203 0.00181258 43697.4 0; : 680 Minimum Test error found - save the configuration ; : 680 | 42.8206 35.8087 0.0201316 0.00181818 43683.7 0; : 681 Minimum Test error found - save the configuration ; : 681 | 42.0593 35.186 0.0205402 0.00185408 42812.5 0; : 682 Minimum Test error found - save the configuration ; : 682 | 41.3592 34.9319 0.0201181 0.00182063 43721.9 0; : 683 | 40.8775 34.9951 0.020058 0.00175108 43699.3 1; : 684 Minimum Test error found - save the configuration ; : 684 | 40.654 34.3931 0.0201589 0.00183818 43666.4 0; : 685 Minimum Test error found - save the configuration ; : 685 | 40.0613 33.8904 0.0201577 0.00183348 43658.1 0; : 686 | 39.3281 34.3645 0.0200576 0.00176772 43739.9 1; : 687 | 38.8187 34.1117 0.0201676 0.00177122 43486.9 2; : 688 Minimum Test error found - save the configuration ; : 688 | 38.34,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:87123,error,error,87123,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"4.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,. const std::vector\(<\)double\(>\)&) ###; Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html:57368,error,error,57368,root/htmldoc/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/htmldoc/guides/minuit2/Minuit2.html,8,['error'],['error']
Availability,"4.7 setUpperLimit(…); [api:setupperlimits] setUpperLimit(unsigned int n, double up) or setUpperLimit(const char* name, double up) sets the upper bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have a lower limit.; 5.14.8 setLowerLimit(…); [api:setlowerlimits] setLowerLimit(unsigned int n, double low) or setLowerLimit(const char* name, double low) sets the lower bound of parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameters does not have an upper limit.; 5.14.9 removeLimits(…); [api:removelimits] removeLimits(unsigned int n) or removeLimits(const char* name) removes all possible limits on parameter \(\mbox{n}\) or with name \(\mbox{name}\). The parameter can then vary in both directions without any bounds.; 5.14.10 value(…); value(unsigned int n) or value(const char* name) return the current value of parameter \(\mbox{n}\) or with name \(\mbox{name}\).; 5.14.11 error(…); error(unsigned int n) or error(const char* name) return the current uncertainty (error) of parameter \(\mbox{n}\) or with name \(\mbox{ name}\).; 5.14.12 index(…); index(const char* name) returns the index (current position) of the parameter with name \(\mbox{ name}\) in the list of defined parameters. The index is the same as for the calculation of the function value in the user’s FCN (FCNBase::operator()).; 5.14.13 name(…); name(unsigned int n) returns the name of the parameter with index \(n\).; 5.15 MnUserParameterState; [api:state] The class MnUserParameterState contains the MnUserParameters and the MnUserCovariance. It can be created on input by the user, or by M itself as user representable format of the result of the minimization.; 5.15.1 MnUserParameterState(const std::vector\(<\)double\(>\)&,; const std::vector\(<\)double\(>\)&); Construct a state from starting values specified via std::vector\(<\)double\(>\). No covariance is available.; 5.15.2 MnUserParameterState(const MnUserParameters&); Construct a state from starting values specified ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:61360,error,error,61360,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,8,['error'],['error']
Availability,"4//////////////////////////////////////////////////////////////////////////; 295/// To resolve problem with storing of shared pointers; 296/// Call this method when reading canvas from the file; 297/// Can be called many times - after reinitialization of shared pointers no changes will be performed; 298 ; 299void ROOT::Experimental::RCanvas::ResolveSharedPtrs(); 300{; 301 Internal::RIOSharedVector_t vect;; 302 ; 303 CollectShared(vect);; 304 ; 305 for (unsigned n = 0; n < vect.size(); ++n) {; 306 if (vect[n]->HasShared() || !vect[n]->GetIOPtr()) continue;; 307 ; 308 auto shrd_ptr = vect[n]->MakeShared();; 309 ; 310 for (auto n2 = n+1; n2 < vect.size(); ++n2) {; 311 if (vect[n2]->GetIOPtr() == vect[n]->GetIOPtr()) {; 312 if (vect[n2]->HasShared()); 313 R__LOG_ERROR(GPadLog()) << ""FATAL Shared pointer for same IO ptr already exists"";; 314 else; 315 vect[n2]->SetShared(shrd_ptr);; 316 }; 317 }; 318 ; 319 }; 320}; 321 ; 322 ; 323/////////////////////////////////////////////////////////////////////////////////////////////////; 324/// Apply attributes changes to the drawable; 325/// Return mask with actions which were really applied; 326 ; 327std::unique_ptr<ROOT::Experimental::RDrawableReply> ROOT::Experimental::RChangeAttrRequest::Process(); 328{; 329 // suppress all changes coming from non-main connection; 330 if (!GetContext().IsMainConn()); 331 return nullptr;; 332 ; 333 auto canv = const_cast<ROOT::Experimental::RCanvas *>(GetContext().GetCanvas());; 334 if (!canv) return nullptr;; 335 ; 336 if ((ids.size() != names.size()) || (ids.size() != values.size())) {; 337 R__LOG_ERROR(GPadLog()) << ""Mismatch of arrays size in RChangeAttrRequest"";; 338 return nullptr;; 339 }; 340 ; 341 Version_t vers = 0;; 342 ; 343 for(int indx = 0; indx < (int) ids.size(); indx++) {; 344 if (ids[indx] == ""canvas"") {; 345 if (canv->GetAttrMap().Change(names[indx], values[indx].get())) {; 346 if (!vers) vers = canv->IncModified();; 347 canv->SetDrawableVersion(vers);; 348 }; 349 } else {; 35",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RCanvas_8cxx_source.html:10678,mask,mask,10678,doc/master/RCanvas_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RCanvas_8cxx_source.html,1,['mask'],['mask']
Availability,"40 return 0;; 2641 }; 2642 evhdl = *(int *)eventhdl;; 2643 ; 2644 s = (int)write(evhdl, &u, sizeof(u));; 2645 if (s != sizeof(u)) {; 2646 /* error */; 2647 return 0;; 2648 }; 2649 return 1;; 2650}; 2651 ; 2652 ; 2653static void; 2654event_destroy(void *eventhdl); 2655{; 2656 int evhdl;; 2657 ; 2658 if (!eventhdl) {; 2659 /* error */; 2660 return;; 2661 }; 2662 evhdl = *(int *)eventhdl;; 2663 ; 2664 close(evhdl);; 2665 mg_free(eventhdl);; 2666}; 2667 ; 2668 ; 2669#endif; 2670 ; 2671#endif; 2672 ; 2673 ; 2674#if !defined(__linux__) && !defined(_WIN32) && defined(ALTERNATIVE_QUEUE); 2675 ; 2676struct posix_event {; 2677 pthread_mutex_t mutex;; 2678 pthread_cond_t cond;; 2679 int signaled;; 2680};; 2681 ; 2682 ; 2683static void *; 2684event_create(void); 2685{; 2686 struct posix_event *ret = mg_malloc(sizeof(struct posix_event));; 2687 if (ret == 0) {; 2688 /* out of memory */; 2689 return 0;; 2690 }; 2691 if (0 != pthread_mutex_init(&(ret->mutex), NULL)) {; 2692 /* pthread mutex not available */; 2693 mg_free(ret);; 2694 return 0;; 2695 }; 2696 if (0 != pthread_cond_init(&(ret->cond), NULL)) {; 2697 /* pthread cond not available */; 2698 pthread_mutex_destroy(&(ret->mutex));; 2699 mg_free(ret);; 2700 return 0;; 2701 }; 2702 ret->signaled = 0;; 2703 return (void *)ret;; 2704}; 2705 ; 2706 ; 2707static int; 2708event_wait(void *eventhdl); 2709{; 2710 struct posix_event *ev = (struct posix_event *)eventhdl;; 2711 pthread_mutex_lock(&(ev->mutex));; 2712 while (!ev->signaled) {; 2713 pthread_cond_wait(&(ev->cond), &(ev->mutex));; 2714 }; 2715 ev->signaled = 0;; 2716 pthread_mutex_unlock(&(ev->mutex));; 2717 return 1;; 2718}; 2719 ; 2720 ; 2721static int; 2722event_signal(void *eventhdl); 2723{; 2724 struct posix_event *ev = (struct posix_event *)eventhdl;; 2725 pthread_mutex_lock(&(ev->mutex));; 2726 pthread_cond_signal(&(ev->cond));; 2727 ev->signaled = 1;; 2728 pthread_mutex_unlock(&(ev->mutex));; 2729 return 1;; 2730}; 2731 ; 2732 ; 2733static void; 2734event_destroy(voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:83167,avail,available,83167,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['avail'],['available']
Availability,"40 });; 341 m_prevGradients.clear ();; 342 }; 343 else; 344 {; 345 auto itW = std::begin (weights);; 346 std::for_each (std::begin (m_localGradients), std::end (m_localGradients), [&itW](double& g); 347 {; 348 *itW += g;; 349 ++itW;; 350 });; 351 }; 352 ; 353 ++currentRepetition;; 354 }; 355 return E;; 356 }; 357 ; 358 ; 359 ; 360 ; 361 ; 362 ; 363 ; 364 ; 365 ; 366 ; 367 ; 368 ; 369 ; 370 ; 371 ; 372 ; 373 ; 374 ; 375 ; 376 ; 377/*! \brief sum of squares error function; 378 *; 379 *; 380 */; 381 template <typename ItOutput, typename ItTruth, typename ItDelta, typename InvFnc>; 382 double sumOfSquares (ItOutput itOutputBegin, ItOutput itOutputEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, InvFnc invFnc, double patternWeight); 383 {; 384 double errorSum = 0.0;; 385 ; 386 // output - truth; 387 ItTruth itTruth = itTruthBegin;; 388 bool hasDeltas = (itDelta != itDeltaEnd);; 389 for (ItOutput itOutput = itOutputBegin; itOutput != itOutputEnd; ++itOutput, ++itTruth); 390 {; 391// assert (itTruth != itTruthEnd);; 392 double output = (*itOutput);; 393 double error = output - (*itTruth);; 394 if (hasDeltas); 395 {; 396 (*itDelta) = (*invFnc.get ()) (output) * error * patternWeight;; 397 ++itDelta;; 398 }; 399 errorSum += error*error * patternWeight;; 400 }; 401 ; 402 return 0.5*errorSum;; 403 }; 404 ; 405 ; 406 ; 407/*! \brief cross entropy error function; 408 *; 409 *; 410 */; 411 template <typename ItProbability, typename ItTruth, typename ItDelta, typename ItInvActFnc>; 412 double crossEntropy (ItProbability itProbabilityBegin, ItProbability itProbabilityEnd, ItTruth itTruthBegin, ItTruth /*itTruthEnd*/, ItDelta itDelta, ItDelta itDeltaEnd, ItInvActFnc /*itInvActFnc*/, double patternWeight); 413 {; 414 bool hasDeltas = (itDelta != itDeltaEnd);; 415 ; 416 double errorSum = 0.0;; 417 for (ItProbability itProbability = itProbabilityBegin; itProbability != itProbabilityEnd; ++itProbability); 418 {; 419 double probability = *itProbabil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/NeuralNet_8icc_source.html:11507,error,error,11507,doc/master/NeuralNet_8icc_source.html,https://root.cern,https://root.cern/doc/master/NeuralNet_8icc_source.html,1,['error'],['error']
Availability,41 0.00183919 43680.3 0; : 894 | 5.44229 7.83993 0.0200562 0.00176505 43736.9 1; : 895 | 5.40474 8.2327 0.0200223 0.00176151 43809.8 2; : 896 Minimum Test error found - save the configuration ; : 896 | 5.30823 7.62628 0.0201123 0.00182273 43740.8 0; : 897 | 6.20081 8.04326 0.0200652 0.00176931 43725.7 1; : 898 | 5.99101 8.0649 0.0200274 0.00175928 43792 2; : 899 Minimum Test error found - save the configuration ; : 899 | 5.1416 7.3348 0.0201215 0.00182199 43717.1 0; : 900 | 4.88699 7.46821 0.0200416 0.0017612 43762.6 1; : 901 Minimum Test error found - save the configuration ; : 901 | 4.92918 7.2702 0.0200754 0.00181642 43814.2 0; : 902 Minimum Test error found - save the configuration ; : 902 | 5.04871 7.17895 0.0200791 0.00180807 43785.1 0; : 903 | 4.88551 7.21813 0.0200213 0.00174992 43784.3 1; : 904 | 4.98683 7.44507 0.0200553 0.00174858 43699.9 2; : 905 | 4.82992 7.45009 0.0202406 0.00175807 43284.1 3; : 906 | 4.86112 7.78644 0.0202162 0.00175457 43333 4; : 907 Minimum Test error found - save the configuration ; : 907 | 4.76534 7.04169 0.0202678 0.00183052 43390.4 0; : 908 | 4.77659 7.36078 0.0201903 0.00174867 43380.2 1; : 909 | 5.40526 9.09975 0.0204121 0.00175613 42881.7 2; : 910 | 5.23108 7.3695 0.0200572 0.0017555 43711.7 3; : 911 | 4.9718 7.21676 0.0200739 0.00175828 43678.5 4; : 912 Minimum Test error found - save the configuration ; : 912 | 4.64478 6.77041 0.0201181 0.00182552 43733.5 0; : 913 | 4.96617 7.29752 0.0200675 0.00175608 43688.5 1; : 914 | 4.79524 7.25946 0.0200357 0.00175682 43766.4 2; : 915 Minimum Test error found - save the configuration ; : 915 | 4.5624 6.6787 0.0201058 0.0018145 43736.7 0; : 916 Minimum Test error found - save the configuration ; : 916 | 4.49553 6.65717 0.0201015 0.00180949 43734.9 0; : 917 Minimum Test error found - save the configuration ; : 917 | 4.36563 6.60613 0.0201007 0.00181415 43748 0; : 918 Minimum Test error found - save the configuration ; : 918 | 4.47049 6.3479 0.0200865 0.00182018 43796.4 0; : 919 | 4.3584,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVARegression_8C.html:106544,error,error,106544,doc/master/TMVARegression_8C.html,https://root.cern,https://root.cern/doc/master/TMVARegression_8C.html,1,['error'],['error']
Availability,"41 assert( fDataErrorHigh.empty() && fDataErrorLow.empty() );; 342 assert( fDataError.empty() || &fDataError.front() == fDataErrorPtr );; 343 ; 344 double eval = fDataErrorPtr[ ipoint ];; 345 ; 346 // in case of wrapped data the pointer stores the error and; 347 // not the inverse; 348 if (fWrapped); 349 return 1.0 / eval;; 350 else; 351 return (eval != 0.0) ? eval : 0.0;; 352 }; 353 ; 354 if ( fErrorType == kAsymError ) {; 355 // return inverse of 1/2(el + eh); 356 assert( !fDataErrorPtr && fDataErrorHighPtr && fDataErrorLowPtr );; 357 assert( fDataError.empty() );; 358 assert( fDataErrorHigh.empty() || &fDataErrorHigh.front() == fDataErrorHighPtr );; 359 assert( fDataErrorLow.empty() || &fDataErrorLow.front() == fDataErrorLowPtr );; 360 assert( fDataErrorLow.empty() == fDataErrorHigh.empty() );; 361 ; 362 double eh = fDataErrorHighPtr[ ipoint ];; 363 double el = fDataErrorLowPtr[ ipoint ];; 364 ; 365 return 2.0 / (el+eh);; 366 }; 367 ; 368 assert( fErrorType == kCoordError );; 369 // for coordinate error we store the error and not the inverse; 370 return 1.0 / fDataErrorPtr[ ipoint ];; 371 }; 372 ; 373 ; 374 /**; 375 retrieve at the same time a pointer to the coordinate data and the fit value; 376 More efficient than calling Coords(i) and Value(i); 377 */; 378 // not threadsafe, to be replaced with never constructs!; 379 // for example: just return std::array or std::vector, there's; 380 // is going to be only minor overhead in c++11.; 381 const double * GetPoint( unsigned int ipoint, double & value ) const; 382 {; 383 assert( ipoint < fMaxPoints );; 384 value = Value( ipoint );; 385 ; 386 return Coords( ipoint );; 387 }; 388 ; 389 /**; 390 returns a single coordinate error component of a point.; 391 This function is threadsafe in contrast to Coords(...); 392 and can easily get vectorized by the compiler in loops; 393 running over the ipoint-index.; 394 */; 395 double GetCoordErrorComponent( unsigned int ipoint, unsigned int icoord ) const; 396 {; 397 assert( ipoi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/BinData_8h_source.html:12959,error,error,12959,doc/master/BinData_8h_source.html,https://root.cern,https://root.cern/doc/master/BinData_8h_source.html,2,['error'],['error']
Availability,"41/// Add a user-defined property. Returns true if added, false if existing.; 642 ; 643Bool_t TGeoManager::AddProperty(const char *property, Double_t value); 644{; 645 auto pos = fProperties.insert(ConstPropMap_t::value_type(property, value));; 646 if (!pos.second) {; 647 Warning(""AddProperty"", ""Property \""%s\"" already exists with value %g"", property, (pos.first)->second);; 648 return false;; 649 }; 650 return true;; 651}; 652 ; 653////////////////////////////////////////////////////////////////////////////////; 654/// Get a user-defined property; 655 ; 656Double_t TGeoManager::GetProperty(const char *property, Bool_t *error) const; 657{; 658 auto pos = fProperties.find(property);; 659 if (pos == fProperties.end()) {; 660 if (error); 661 *error = kTRUE;; 662 return 0.;; 663 }; 664 if (error); 665 *error = kFALSE;; 666 return pos->second;; 667}; 668 ; 669////////////////////////////////////////////////////////////////////////////////; 670/// Get a user-defined property from a given index; 671 ; 672Double_t TGeoManager::GetProperty(size_t i, TString &name, Bool_t *error) const; 673{; 674 // This is a quite inefficient way to access map elements, but needed for the GDML writer to; 675 if (i >= fProperties.size()) {; 676 if (error); 677 *error = kTRUE;; 678 return 0.;; 679 }; 680 size_t pos = 0;; 681 auto it = fProperties.begin();; 682 while (pos < i) {; 683 ++it;; 684 ++pos;; 685 }; 686 if (error); 687 *error = kFALSE;; 688 name = (*it).first;; 689 return (*it).second;; 690}; 691 ; 692////////////////////////////////////////////////////////////////////////////////; 693/// Add a matrix to the list. Returns index of the matrix in list.; 694 ; 695Int_t TGeoManager::AddTransformation(const TGeoMatrix *matrix); 696{; 697 return TGeoBuilder::Instance(this)->AddTransformation((TGeoMatrix *)matrix);; 698}; 699 ; 700////////////////////////////////////////////////////////////////////////////////; 701/// Add a shape to the list. Returns index of the shape in list.; 702 ; 703Int_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoManager_8cxx_source.html:25230,error,error,25230,doc/master/TGeoManager_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGeoManager_8cxx_source.html,3,['error'],['error']
Availability,"41{; 2042 if (e == -1); 2043 SetFillColor(fcolor);; 2044 else if (e >= 0 && e < fNYErrors); 2045 fAttFill[e].SetFillColor(fcolor);; 2046}; 2047 ; 2048////////////////////////////////////////////////////////////////////////////////; 2049/// Set Fill Color and Alpha of error e (-1 = Global and x errors).; 2050 ; 2051void TGraphMultiErrors::SetFillColorAlpha(Int_t e, Color_t fcolor, Float_t falpha); 2052{; 2053 if (e == -1); 2054 SetFillColorAlpha(fcolor, falpha);; 2055 else if (e >= 0 && e < fNYErrors); 2056 fAttFill[e].SetFillColorAlpha(fcolor, falpha);; 2057}; 2058 ; 2059////////////////////////////////////////////////////////////////////////////////; 2060/// Set Fill Style of error e (-1 = Global and x errors).; 2061 ; 2062void TGraphMultiErrors::SetFillStyle(Int_t e, Style_t fstyle); 2063{; 2064 if (e == -1); 2065 SetFillStyle(fstyle);; 2066 else if (e >= 0 && e < fNYErrors); 2067 fAttFill[e].SetFillStyle(fstyle);; 2068}; 2069 ; 2070////////////////////////////////////////////////////////////////////////////////; 2071/// Set Line Color of error e (-1 = Global and x errors).; 2072 ; 2073void TGraphMultiErrors::SetLineColor(Int_t e, Color_t lcolor); 2074{; 2075 if (e == -1); 2076 SetLineColor(lcolor);; 2077 else if (e >= 0 && e < fNYErrors); 2078 fAttLine[e].SetLineColor(lcolor);; 2079}; 2080 ; 2081////////////////////////////////////////////////////////////////////////////////; 2082/// Set Line Color and Alpha of error e (-1 = Global and x errors).; 2083 ; 2084void TGraphMultiErrors::SetLineColorAlpha(Int_t e, Color_t lcolor, Float_t lalpha); 2085{; 2086 if (e == -1); 2087 SetLineColorAlpha(lcolor, lalpha);; 2088 else if (e >= 0 && e < fNYErrors); 2089 fAttLine[e].SetLineColorAlpha(lcolor, lalpha);; 2090}; 2091 ; 2092////////////////////////////////////////////////////////////////////////////////; 2093/// Set Line Style of error e (-1 = Global and x errors).; 2094 ; 2095void TGraphMultiErrors::SetLineStyle(Int_t e, Style_t lstyle); 2096{; 2097 if (e == -1); 2098 Se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html:69752,error,error,69752,doc/master/TGraphMultiErrors_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGraphMultiErrors_8cxx_source.html,2,['error'],"['error', 'errors']"
Availability,"42.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=0.403042, denominator=wrap_pdf_Int[pTV]=242.998; ... (remaining 14 messages suppressed); ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=-3.35967 cHl3=-9.58704 cHq3=-6.27461; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; p.d.f value is less than zero, trying to recover @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=486.968, denominator=wrap_pdf_Int[pTV]=829530; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.154263 cHl3=2.95902 cHq3=-2.78828; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pTV][ numerator=wrap_pdf denominator=wrap_pdf_Int[pTV] ]; getLogVal() top-level p.d.f evaluates to NaN @ numerator=wrap_pdf=59.1285, denominator=wrap_pdf_Int[pTV]=200921; ; RooAbsMinimizerFcn: Minimized function has error status.; Returning maximum FCN so far (86348.3) to force MIGRAD to back out of this region. Error log follows.; Parameter values: cHDD=0.338546 cHl3=0.879879 cHq3=-1.35856; RooAbsPdf::wrap_pdf_over_wrap_pdf_Int[pT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html:14551,recover,recover,14551,doc/master/rf712__lagrangianmorphfit_8C.html,https://root.cern,https://root.cern/doc/master/rf712__lagrangianmorphfit_8C.html,2,['recover'],['recover']
Availability,"42343 0.99744 [ -3.2803 5.7307 ]; : m_wwbb: 0.0046014 0.99948 [ -3.2802 5.7307 ]; : -----------------------------------------------------------; : ***** Deep Learning Network *****; DEEP NEURAL NETWORK: Depth = 5 Input = ( 1, 1, 7 ) Batch size = 128 Loss function = C; Layer 0 DENSE Layer: ( Input = 7 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 1 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 2 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 3 DENSE Layer: ( Input = 64 , Width = 64 ) Output = ( 1 , 128 , 64 ) Activation Function = Tanh; Layer 4 DENSE Layer: ( Input = 64 , Width = 1 ) Output = ( 1 , 128 , 1 ) Activation Function = Identity; : Using 11200 events for training and 2800 for testing; : Compute initial loss on the validation data ; : Training phase 1 of 1: Optimizer ADAM (beta1=0.9,beta2=0.999,eps=1e-07) Learning rate = 0.001 regularization 0 minimum error = 0.868652; : --------------------------------------------------------------; : Epoch | Train Err. Val. Err. t(s)/epoch t(s)/Loss nEvents/s Conv. Steps; : --------------------------------------------------------------; : Start epoch iteration ...; : 1 Minimum Test error found - save the configuration ; : 1 | 0.659892 0.620582 0.589558 0.0469541 20523.3 0; : 2 Minimum Test error found - save the configuration ; : 2 | 0.604286 0.594787 0.586926 0.0471912 20632.4 0; : 3 | 0.58117 0.603906 0.587335 0.047007 20609.7 1; : 4 Minimum Test error found - save the configuration ; : 4 | 0.57382 0.588714 0.592175 0.0469679 20425.3 0; : 5 | 0.569519 0.59535 0.590168 0.0468081 20494.7 1; : 6 | 0.567869 0.590023 0.589038 0.0469022 20541 2; : 7 Minimum Test error found - save the configuration ; : 7 | 0.561012 0.586993 0.590467 0.0471223 20495.3 0; : 8 | 0.559195 0.590522 0.590271 0.0471869 20505.1 1; : 9 | 0.558998 0.588766 0.598449 0.0469787 20193.3 2; : 10 | 0.555383 0.590075 0.591595",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html:23990,error,error,23990,doc/master/TMVA__Higgs__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__Higgs__Classification_8py.html,1,['error'],['error']
